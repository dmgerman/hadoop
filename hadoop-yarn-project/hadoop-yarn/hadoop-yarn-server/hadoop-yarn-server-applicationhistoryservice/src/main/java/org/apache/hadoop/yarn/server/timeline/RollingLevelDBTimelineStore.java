begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.timeline
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|timeline
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|collections
operator|.
name|map
operator|.
name|LRUMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|Private
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|AbstractService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|timeline
operator|.
name|TimelineDomain
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|timeline
operator|.
name|TimelineDomains
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|timeline
operator|.
name|TimelineEntities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|timeline
operator|.
name|TimelineEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|timeline
operator|.
name|TimelineEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|timeline
operator|.
name|TimelineEvents
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|timeline
operator|.
name|TimelineEvents
operator|.
name|EventsOfOneEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|timeline
operator|.
name|TimelinePutResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|timeline
operator|.
name|TimelinePutResponse
operator|.
name|TimelinePutError
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|proto
operator|.
name|YarnServerCommonProtos
operator|.
name|VersionProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|records
operator|.
name|Version
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|records
operator|.
name|impl
operator|.
name|pb
operator|.
name|VersionPBImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|timeline
operator|.
name|RollingLevelDB
operator|.
name|RollingWriteBatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|timeline
operator|.
name|TimelineDataManager
operator|.
name|CheckAcl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|timeline
operator|.
name|util
operator|.
name|LeveldbUtils
operator|.
name|KeyBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|timeline
operator|.
name|util
operator|.
name|LeveldbUtils
operator|.
name|KeyParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|fusesource
operator|.
name|leveldbjni
operator|.
name|JniDBFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|iq80
operator|.
name|leveldb
operator|.
name|DB
import|;
end_import

begin_import
import|import
name|org
operator|.
name|iq80
operator|.
name|leveldb
operator|.
name|DBException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|iq80
operator|.
name|leveldb
operator|.
name|DBIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|iq80
operator|.
name|leveldb
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|iq80
operator|.
name|leveldb
operator|.
name|ReadOptions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|iq80
operator|.
name|leveldb
operator|.
name|WriteBatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|nustaq
operator|.
name|serialization
operator|.
name|FSTConfiguration
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
operator|.
name|UTF_8
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|timeline
operator|.
name|GenericObjectMapper
operator|.
name|readReverseOrderedLong
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|timeline
operator|.
name|GenericObjectMapper
operator|.
name|writeReverseOrderedLong
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|timeline
operator|.
name|TimelineDataManager
operator|.
name|DEFAULT_DOMAIN_ID
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|timeline
operator|.
name|util
operator|.
name|LeveldbUtils
operator|.
name|prefixMatches
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|DEFAULT_TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|DEFAULT_TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|DEFAULT_TIMELINE_SERVICE_LEVELDB_START_TIME_READ_CACHE_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|DEFAULT_TIMELINE_SERVICE_LEVELDB_START_TIME_WRITE_CACHE_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|DEFAULT_TIMELINE_SERVICE_LEVELDB_TTL_INTERVAL_MS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|DEFAULT_TIMELINE_SERVICE_LEVELDB_WRITE_BATCH_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|DEFAULT_TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|DEFAULT_TIMELINE_SERVICE_TTL_MS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_LEVELDB_PATH
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_LEVELDB_START_TIME_READ_CACHE_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_LEVELDB_START_TIME_WRITE_CACHE_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_LEVELDB_TTL_INTERVAL_MS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_LEVELDB_WRITE_BATCH_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_TTL_ENABLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_TTL_MS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|fusesource
operator|.
name|leveldbjni
operator|.
name|JniDBFactory
operator|.
name|bytes
import|;
end_import

begin_comment
comment|/**  *<p>  * An implementation of an application timeline store backed by leveldb.  *</p>  *  *<p>  * There are three sections of the db, the start time section, the entity  * section, and the indexed entity section.  *</p>  *  *<p>  * The start time section is used to retrieve the unique start time for a given  * entity. Its values each contain a start time while its keys are of the form:  *</p>  *  *<pre>  *   START_TIME_LOOKUP_PREFIX + entity type + entity id  *</pre>  *  *<p>  * The entity section is ordered by entity type, then entity start time  * descending, then entity ID. There are four sub-sections of the entity  * section: events, primary filters, related entities, and other info. The event  * entries have event info serialized into their values. The other info entries  * have values corresponding to the values of the other info name/value map for  * the entry (note the names are contained in the key). All other entries have  * empty values. The key structure is as follows:  *</p>  *  *<pre>  *   ENTITY_ENTRY_PREFIX + entity type + revstarttime + entity id  *  *   ENTITY_ENTRY_PREFIX + entity type + revstarttime + entity id +  *     DOMAIN_ID_COLUMN  *  *   ENTITY_ENTRY_PREFIX + entity type + revstarttime + entity id +  *     EVENTS_COLUMN + reveventtimestamp + eventtype  *  *   ENTITY_ENTRY_PREFIX + entity type + revstarttime + entity id +  *     PRIMARY_FILTERS_COLUMN + name + value  *  *   ENTITY_ENTRY_PREFIX + entity type + revstarttime + entity id +  *     OTHER_INFO_COLUMN + name  *  *   ENTITY_ENTRY_PREFIX + entity type + revstarttime + entity id +  *     RELATED_ENTITIES_COLUMN + relatedentity type + relatedentity id  *</pre>  *  *<p>  * The indexed entity section contains a primary filter name and primary filter  * value as the prefix. Within a given name/value, entire entity entries are  * stored in the same format as described in the entity section above (below,  * "key" represents any one of the possible entity entry keys described above).  *</p>  *  *<pre>  *   INDEXED_ENTRY_PREFIX + primaryfilter name + primaryfilter value +  *     key  *</pre>  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|RollingLevelDBTimelineStore
specifier|public
class|class
name|RollingLevelDBTimelineStore
extends|extends
name|AbstractService
implements|implements
name|TimelineStore
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|RollingLevelDBTimelineStore
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|fstConf
specifier|private
specifier|static
name|FSTConfiguration
name|fstConf
init|=
name|FSTConfiguration
operator|.
name|createDefaultConfiguration
argument_list|()
decl_stmt|;
static|static
block|{
name|fstConf
operator|.
name|setShareReferences
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Private
annotation|@
name|VisibleForTesting
DECL|field|FILENAME
specifier|static
specifier|final
name|String
name|FILENAME
init|=
literal|"leveldb-timeline-store"
decl_stmt|;
DECL|field|DOMAIN
specifier|static
specifier|final
name|String
name|DOMAIN
init|=
literal|"domain-ldb"
decl_stmt|;
DECL|field|ENTITY
specifier|static
specifier|final
name|String
name|ENTITY
init|=
literal|"entity-ldb"
decl_stmt|;
DECL|field|INDEX
specifier|static
specifier|final
name|String
name|INDEX
init|=
literal|"indexes-ldb"
decl_stmt|;
DECL|field|STARTTIME
specifier|static
specifier|final
name|String
name|STARTTIME
init|=
literal|"starttime-ldb"
decl_stmt|;
DECL|field|OWNER
specifier|static
specifier|final
name|String
name|OWNER
init|=
literal|"owner-ldb"
decl_stmt|;
DECL|field|DOMAIN_ID_COLUMN
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|DOMAIN_ID_COLUMN
init|=
literal|"d"
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
decl_stmt|;
DECL|field|EVENTS_COLUMN
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|EVENTS_COLUMN
init|=
literal|"e"
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
decl_stmt|;
DECL|field|PRIMARY_FILTERS_COLUMN
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|PRIMARY_FILTERS_COLUMN
init|=
literal|"f"
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
decl_stmt|;
DECL|field|OTHER_INFO_COLUMN
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|OTHER_INFO_COLUMN
init|=
literal|"i"
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
decl_stmt|;
DECL|field|RELATED_ENTITIES_COLUMN
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|RELATED_ENTITIES_COLUMN
init|=
literal|"r"
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
decl_stmt|;
DECL|field|DESCRIPTION_COLUMN
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|DESCRIPTION_COLUMN
init|=
literal|"d"
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
decl_stmt|;
DECL|field|OWNER_COLUMN
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|OWNER_COLUMN
init|=
literal|"o"
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
decl_stmt|;
DECL|field|READER_COLUMN
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|READER_COLUMN
init|=
literal|"r"
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
decl_stmt|;
DECL|field|WRITER_COLUMN
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|WRITER_COLUMN
init|=
literal|"w"
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
decl_stmt|;
DECL|field|TIMESTAMP_COLUMN
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|TIMESTAMP_COLUMN
init|=
literal|"t"
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
decl_stmt|;
DECL|field|EMPTY_BYTES
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|EMPTY_BYTES
init|=
operator|new
name|byte
index|[
literal|0
index|]
decl_stmt|;
DECL|field|TIMELINE_STORE_VERSION_KEY
specifier|private
specifier|static
specifier|final
name|String
name|TIMELINE_STORE_VERSION_KEY
init|=
literal|"timeline-store-version"
decl_stmt|;
DECL|field|CURRENT_VERSION_INFO
specifier|private
specifier|static
specifier|final
name|Version
name|CURRENT_VERSION_INFO
init|=
name|Version
operator|.
name|newInstance
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
DECL|field|writeBatchSize
specifier|private
specifier|static
name|long
name|writeBatchSize
init|=
literal|10000
decl_stmt|;
annotation|@
name|Private
annotation|@
name|VisibleForTesting
DECL|field|LEVELDB_DIR_UMASK
specifier|static
specifier|final
name|FsPermission
name|LEVELDB_DIR_UMASK
init|=
name|FsPermission
operator|.
name|createImmutable
argument_list|(
operator|(
name|short
operator|)
literal|0700
argument_list|)
decl_stmt|;
DECL|field|startTimeWriteCache
specifier|private
name|Map
argument_list|<
name|EntityIdentifier
argument_list|,
name|Long
argument_list|>
name|startTimeWriteCache
decl_stmt|;
DECL|field|startTimeReadCache
specifier|private
name|Map
argument_list|<
name|EntityIdentifier
argument_list|,
name|Long
argument_list|>
name|startTimeReadCache
decl_stmt|;
DECL|field|domaindb
specifier|private
name|DB
name|domaindb
decl_stmt|;
DECL|field|entitydb
specifier|private
name|RollingLevelDB
name|entitydb
decl_stmt|;
DECL|field|indexdb
specifier|private
name|RollingLevelDB
name|indexdb
decl_stmt|;
DECL|field|starttimedb
specifier|private
name|DB
name|starttimedb
decl_stmt|;
DECL|field|ownerdb
specifier|private
name|DB
name|ownerdb
decl_stmt|;
DECL|field|deletionThread
specifier|private
name|Thread
name|deletionThread
decl_stmt|;
DECL|method|RollingLevelDBTimelineStore ()
specifier|public
name|RollingLevelDBTimelineStore
parameter_list|()
block|{
name|super
argument_list|(
name|RollingLevelDBTimelineStore
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|serviceInit (Configuration conf)
specifier|protected
name|void
name|serviceInit
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
name|TIMELINE_SERVICE_TTL_MS
argument_list|,
name|DEFAULT_TIMELINE_SERVICE_TTL_MS
argument_list|)
operator|>
literal|0
argument_list|,
literal|"%s property value should be greater than zero"
argument_list|,
name|TIMELINE_SERVICE_TTL_MS
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
name|TIMELINE_SERVICE_LEVELDB_TTL_INTERVAL_MS
argument_list|,
name|DEFAULT_TIMELINE_SERVICE_LEVELDB_TTL_INTERVAL_MS
argument_list|)
operator|>
literal|0
argument_list|,
literal|"%s property value should be greater than zero"
argument_list|,
name|TIMELINE_SERVICE_LEVELDB_TTL_INTERVAL_MS
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
name|TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE
argument_list|,
name|DEFAULT_TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE
argument_list|)
operator|>=
literal|0
argument_list|,
literal|"%s property value should be greater than or equal to zero"
argument_list|,
name|TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
name|TIMELINE_SERVICE_LEVELDB_START_TIME_READ_CACHE_SIZE
argument_list|,
name|DEFAULT_TIMELINE_SERVICE_LEVELDB_START_TIME_READ_CACHE_SIZE
argument_list|)
operator|>
literal|0
argument_list|,
literal|" %s property value should be greater than zero"
argument_list|,
name|TIMELINE_SERVICE_LEVELDB_START_TIME_READ_CACHE_SIZE
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
name|TIMELINE_SERVICE_LEVELDB_START_TIME_WRITE_CACHE_SIZE
argument_list|,
name|DEFAULT_TIMELINE_SERVICE_LEVELDB_START_TIME_WRITE_CACHE_SIZE
argument_list|)
operator|>
literal|0
argument_list|,
literal|"%s property value should be greater than zero"
argument_list|,
name|TIMELINE_SERVICE_LEVELDB_START_TIME_WRITE_CACHE_SIZE
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
name|TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES
argument_list|,
name|DEFAULT_TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES
argument_list|)
operator|>
literal|0
argument_list|,
literal|"%s property value should be greater than zero"
argument_list|,
name|TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
name|TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE
argument_list|,
name|DEFAULT_TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE
argument_list|)
operator|>
literal|0
argument_list|,
literal|"%s property value should be greater than zero"
argument_list|,
name|TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE
argument_list|)
expr_stmt|;
name|Options
name|options
init|=
operator|new
name|Options
argument_list|()
decl_stmt|;
name|options
operator|.
name|createIfMissing
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|options
operator|.
name|cacheSize
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
name|TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE
argument_list|,
name|DEFAULT_TIMELINE_SERVICE_LEVELDB_READ_CACHE_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|JniDBFactory
name|factory
init|=
operator|new
name|JniDBFactory
argument_list|()
decl_stmt|;
name|Path
name|dbPath
init|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|TIMELINE_SERVICE_LEVELDB_PATH
argument_list|)
argument_list|,
name|FILENAME
argument_list|)
decl_stmt|;
name|Path
name|domainDBPath
init|=
operator|new
name|Path
argument_list|(
name|dbPath
argument_list|,
name|DOMAIN
argument_list|)
decl_stmt|;
name|Path
name|starttimeDBPath
init|=
operator|new
name|Path
argument_list|(
name|dbPath
argument_list|,
name|STARTTIME
argument_list|)
decl_stmt|;
name|Path
name|ownerDBPath
init|=
operator|new
name|Path
argument_list|(
name|dbPath
argument_list|,
name|OWNER
argument_list|)
decl_stmt|;
try|try
init|(
name|FileSystem
name|localFS
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
init|)
block|{
if|if
condition|(
operator|!
name|localFS
operator|.
name|exists
argument_list|(
name|dbPath
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|localFS
operator|.
name|mkdirs
argument_list|(
name|dbPath
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Couldn't create directory for leveldb "
operator|+
literal|"timeline store "
operator|+
name|dbPath
argument_list|)
throw|;
block|}
name|localFS
operator|.
name|setPermission
argument_list|(
name|dbPath
argument_list|,
name|LEVELDB_DIR_UMASK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|localFS
operator|.
name|exists
argument_list|(
name|domainDBPath
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|localFS
operator|.
name|mkdirs
argument_list|(
name|domainDBPath
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Couldn't create directory for leveldb "
operator|+
literal|"timeline store "
operator|+
name|domainDBPath
argument_list|)
throw|;
block|}
name|localFS
operator|.
name|setPermission
argument_list|(
name|domainDBPath
argument_list|,
name|LEVELDB_DIR_UMASK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|localFS
operator|.
name|exists
argument_list|(
name|starttimeDBPath
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|localFS
operator|.
name|mkdirs
argument_list|(
name|starttimeDBPath
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Couldn't create directory for leveldb "
operator|+
literal|"timeline store "
operator|+
name|starttimeDBPath
argument_list|)
throw|;
block|}
name|localFS
operator|.
name|setPermission
argument_list|(
name|starttimeDBPath
argument_list|,
name|LEVELDB_DIR_UMASK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|localFS
operator|.
name|exists
argument_list|(
name|ownerDBPath
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|localFS
operator|.
name|mkdirs
argument_list|(
name|ownerDBPath
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Couldn't create directory for leveldb "
operator|+
literal|"timeline store "
operator|+
name|ownerDBPath
argument_list|)
throw|;
block|}
name|localFS
operator|.
name|setPermission
argument_list|(
name|ownerDBPath
argument_list|,
name|LEVELDB_DIR_UMASK
argument_list|)
expr_stmt|;
block|}
block|}
name|options
operator|.
name|maxOpenFiles
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES
argument_list|,
name|DEFAULT_TIMELINE_SERVICE_LEVELDB_MAX_OPEN_FILES
argument_list|)
argument_list|)
expr_stmt|;
name|options
operator|.
name|writeBufferSize
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE
argument_list|,
name|DEFAULT_TIMELINE_SERVICE_LEVELDB_WRITE_BUFFER_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Using leveldb path "
operator|+
name|dbPath
argument_list|)
expr_stmt|;
name|domaindb
operator|=
name|factory
operator|.
name|open
argument_list|(
operator|new
name|File
argument_list|(
name|domainDBPath
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|entitydb
operator|=
operator|new
name|RollingLevelDB
argument_list|(
name|ENTITY
argument_list|)
expr_stmt|;
name|entitydb
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|indexdb
operator|=
operator|new
name|RollingLevelDB
argument_list|(
name|INDEX
argument_list|)
expr_stmt|;
name|indexdb
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|starttimedb
operator|=
name|factory
operator|.
name|open
argument_list|(
operator|new
name|File
argument_list|(
name|starttimeDBPath
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|ownerdb
operator|=
name|factory
operator|.
name|open
argument_list|(
operator|new
name|File
argument_list|(
name|ownerDBPath
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|checkVersion
argument_list|()
expr_stmt|;
name|startTimeWriteCache
operator|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|LRUMap
argument_list|(
name|getStartTimeWriteCacheSize
argument_list|(
name|conf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|startTimeReadCache
operator|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|LRUMap
argument_list|(
name|getStartTimeReadCacheSize
argument_list|(
name|conf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|writeBatchSize
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|TIMELINE_SERVICE_LEVELDB_WRITE_BATCH_SIZE
argument_list|,
name|DEFAULT_TIMELINE_SERVICE_LEVELDB_WRITE_BATCH_SIZE
argument_list|)
expr_stmt|;
name|super
operator|.
name|serviceInit
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|serviceStart ()
specifier|protected
name|void
name|serviceStart
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|getConfig
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|TIMELINE_SERVICE_TTL_ENABLE
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|deletionThread
operator|=
operator|new
name|EntityDeletionThread
argument_list|(
name|getConfig
argument_list|()
argument_list|)
expr_stmt|;
name|deletionThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|super
operator|.
name|serviceStart
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|serviceStop ()
specifier|protected
name|void
name|serviceStop
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|deletionThread
operator|!=
literal|null
condition|)
block|{
name|deletionThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting for deletion thread to complete its current action"
argument_list|)
expr_stmt|;
try|try
block|{
name|deletionThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted while waiting for deletion thread to complete,"
operator|+
literal|" closing db now"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|domaindb
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|starttimedb
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|ownerdb
argument_list|)
expr_stmt|;
name|entitydb
operator|.
name|stop
argument_list|()
expr_stmt|;
name|indexdb
operator|.
name|stop
argument_list|()
expr_stmt|;
name|super
operator|.
name|serviceStop
argument_list|()
expr_stmt|;
block|}
DECL|class|EntityDeletionThread
specifier|private
class|class
name|EntityDeletionThread
extends|extends
name|Thread
block|{
DECL|field|ttl
specifier|private
specifier|final
name|long
name|ttl
decl_stmt|;
DECL|field|ttlInterval
specifier|private
specifier|final
name|long
name|ttlInterval
decl_stmt|;
DECL|method|EntityDeletionThread (Configuration conf)
specifier|public
name|EntityDeletionThread
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|ttl
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|TIMELINE_SERVICE_TTL_MS
argument_list|,
name|DEFAULT_TIMELINE_SERVICE_TTL_MS
argument_list|)
expr_stmt|;
name|ttlInterval
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|TIMELINE_SERVICE_LEVELDB_TTL_INTERVAL_MS
argument_list|,
name|DEFAULT_TIMELINE_SERVICE_LEVELDB_TTL_INTERVAL_MS
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting deletion thread with ttl "
operator|+
name|ttl
operator|+
literal|" and cycle "
operator|+
literal|"interval "
operator|+
name|ttlInterval
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setName
argument_list|(
literal|"Leveldb Timeline Store Retention"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|long
name|timestamp
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|ttl
decl_stmt|;
try|try
block|{
name|discardOldEntities
argument_list|(
name|timestamp
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|ttlInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Deletion thread received interrupt, exiting"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|getEntity (String entityId, String entityType, EnumSet<Field> fields)
specifier|public
name|TimelineEntity
name|getEntity
parameter_list|(
name|String
name|entityId
parameter_list|,
name|String
name|entityType
parameter_list|,
name|EnumSet
argument_list|<
name|Field
argument_list|>
name|fields
parameter_list|)
throws|throws
name|IOException
block|{
name|Long
name|revStartTime
init|=
name|getStartTimeLong
argument_list|(
name|entityId
argument_list|,
name|entityType
argument_list|)
decl_stmt|;
if|if
condition|(
name|revStartTime
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|byte
index|[]
name|prefix
init|=
name|KeyBuilder
operator|.
name|newInstance
argument_list|()
operator|.
name|add
argument_list|(
name|entityType
argument_list|)
operator|.
name|add
argument_list|(
name|writeReverseOrderedLong
argument_list|(
name|revStartTime
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
name|entityId
argument_list|)
operator|.
name|getBytesForLookup
argument_list|()
decl_stmt|;
name|DB
name|db
init|=
name|entitydb
operator|.
name|getDBForStartTime
argument_list|(
name|revStartTime
argument_list|)
decl_stmt|;
if|if
condition|(
name|db
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
try|try
init|(
name|DBIterator
name|iterator
init|=
name|db
operator|.
name|iterator
argument_list|()
init|)
block|{
name|iterator
operator|.
name|seek
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
return|return
name|getEntity
argument_list|(
name|entityId
argument_list|,
name|entityType
argument_list|,
name|revStartTime
argument_list|,
name|fields
argument_list|,
name|iterator
argument_list|,
name|prefix
argument_list|,
name|prefix
operator|.
name|length
argument_list|)
return|;
block|}
block|}
comment|/**    * Read entity from a db iterator. If no information is found in the specified    * fields for this entity, return null.    */
DECL|method|getEntity (String entityId, String entityType, Long startTime, EnumSet<Field> fields, DBIterator iterator, byte[] prefix, int prefixlen)
specifier|private
specifier|static
name|TimelineEntity
name|getEntity
parameter_list|(
name|String
name|entityId
parameter_list|,
name|String
name|entityType
parameter_list|,
name|Long
name|startTime
parameter_list|,
name|EnumSet
argument_list|<
name|Field
argument_list|>
name|fields
parameter_list|,
name|DBIterator
name|iterator
parameter_list|,
name|byte
index|[]
name|prefix
parameter_list|,
name|int
name|prefixlen
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
name|fields
operator|=
name|EnumSet
operator|.
name|allOf
argument_list|(
name|Field
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
name|TimelineEntity
name|entity
init|=
operator|new
name|TimelineEntity
argument_list|()
decl_stmt|;
name|boolean
name|events
init|=
literal|false
decl_stmt|;
name|boolean
name|lastEvent
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|fields
operator|.
name|contains
argument_list|(
name|Field
operator|.
name|EVENTS
argument_list|)
condition|)
block|{
name|events
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fields
operator|.
name|contains
argument_list|(
name|Field
operator|.
name|LAST_EVENT_ONLY
argument_list|)
condition|)
block|{
name|lastEvent
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|entity
operator|.
name|setEvents
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|boolean
name|relatedEntities
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|fields
operator|.
name|contains
argument_list|(
name|Field
operator|.
name|RELATED_ENTITIES
argument_list|)
condition|)
block|{
name|relatedEntities
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|entity
operator|.
name|setRelatedEntities
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|boolean
name|primaryFilters
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|fields
operator|.
name|contains
argument_list|(
name|Field
operator|.
name|PRIMARY_FILTERS
argument_list|)
condition|)
block|{
name|primaryFilters
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|entity
operator|.
name|setPrimaryFilters
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|boolean
name|otherInfo
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|fields
operator|.
name|contains
argument_list|(
name|Field
operator|.
name|OTHER_INFO
argument_list|)
condition|)
block|{
name|otherInfo
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|entity
operator|.
name|setOtherInfo
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// iterate through the entity's entry, parsing information if it is part
comment|// of a requested field
for|for
control|(
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
name|iterator
operator|.
name|next
argument_list|()
control|)
block|{
name|byte
index|[]
name|key
init|=
name|iterator
operator|.
name|peekNext
argument_list|()
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|prefixMatches
argument_list|(
name|prefix
argument_list|,
name|prefixlen
argument_list|,
name|key
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|key
operator|.
name|length
operator|==
name|prefixlen
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|key
index|[
name|prefixlen
index|]
operator|==
name|PRIMARY_FILTERS_COLUMN
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|primaryFilters
condition|)
block|{
name|addPrimaryFilter
argument_list|(
name|entity
argument_list|,
name|key
argument_list|,
name|prefixlen
operator|+
name|PRIMARY_FILTERS_COLUMN
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|key
index|[
name|prefixlen
index|]
operator|==
name|OTHER_INFO_COLUMN
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|otherInfo
condition|)
block|{
name|entity
operator|.
name|addOtherInfo
argument_list|(
name|parseRemainingKey
argument_list|(
name|key
argument_list|,
name|prefixlen
operator|+
name|OTHER_INFO_COLUMN
operator|.
name|length
argument_list|)
argument_list|,
name|fstConf
operator|.
name|asObject
argument_list|(
name|iterator
operator|.
name|peekNext
argument_list|()
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|key
index|[
name|prefixlen
index|]
operator|==
name|RELATED_ENTITIES_COLUMN
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|relatedEntities
condition|)
block|{
name|addRelatedEntity
argument_list|(
name|entity
argument_list|,
name|key
argument_list|,
name|prefixlen
operator|+
name|RELATED_ENTITIES_COLUMN
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|key
index|[
name|prefixlen
index|]
operator|==
name|EVENTS_COLUMN
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|events
operator|||
operator|(
name|lastEvent
operator|&&
name|entity
operator|.
name|getEvents
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
name|TimelineEvent
name|event
init|=
name|getEntityEvent
argument_list|(
literal|null
argument_list|,
name|key
argument_list|,
name|prefixlen
operator|+
name|EVENTS_COLUMN
operator|.
name|length
argument_list|,
name|iterator
operator|.
name|peekNext
argument_list|()
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|event
operator|!=
literal|null
condition|)
block|{
name|entity
operator|.
name|addEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|key
index|[
name|prefixlen
index|]
operator|==
name|DOMAIN_ID_COLUMN
index|[
literal|0
index|]
condition|)
block|{
name|byte
index|[]
name|v
init|=
name|iterator
operator|.
name|peekNext
argument_list|()
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|domainId
init|=
operator|new
name|String
argument_list|(
name|v
argument_list|,
name|UTF_8
argument_list|)
decl_stmt|;
name|entity
operator|.
name|setDomainId
argument_list|(
name|domainId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Found unexpected column for entity %s of "
operator|+
literal|"type %s (0x%02x)"
argument_list|,
name|entityId
argument_list|,
name|entityType
argument_list|,
name|key
index|[
name|prefixlen
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|entity
operator|.
name|setEntityId
argument_list|(
name|entityId
argument_list|)
expr_stmt|;
name|entity
operator|.
name|setEntityType
argument_list|(
name|entityType
argument_list|)
expr_stmt|;
name|entity
operator|.
name|setStartTime
argument_list|(
name|startTime
argument_list|)
expr_stmt|;
return|return
name|entity
return|;
block|}
annotation|@
name|Override
DECL|method|getEntityTimelines (String entityType, SortedSet<String> entityIds, Long limit, Long windowStart, Long windowEnd, Set<String> eventType)
specifier|public
name|TimelineEvents
name|getEntityTimelines
parameter_list|(
name|String
name|entityType
parameter_list|,
name|SortedSet
argument_list|<
name|String
argument_list|>
name|entityIds
parameter_list|,
name|Long
name|limit
parameter_list|,
name|Long
name|windowStart
parameter_list|,
name|Long
name|windowEnd
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|eventType
parameter_list|)
throws|throws
name|IOException
block|{
name|TimelineEvents
name|events
init|=
operator|new
name|TimelineEvents
argument_list|()
decl_stmt|;
if|if
condition|(
name|entityIds
operator|==
literal|null
operator|||
name|entityIds
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|events
return|;
block|}
comment|// create a lexicographically-ordered map from start time to entities
name|Map
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|EntityIdentifier
argument_list|>
argument_list|>
name|startTimeMap
init|=
operator|new
name|TreeMap
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|EntityIdentifier
argument_list|>
argument_list|>
argument_list|(
operator|new
name|Comparator
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|byte
index|[]
name|o1
parameter_list|,
name|byte
index|[]
name|o2
parameter_list|)
block|{
return|return
name|WritableComparator
operator|.
name|compareBytes
argument_list|(
name|o1
argument_list|,
literal|0
argument_list|,
name|o1
operator|.
name|length
argument_list|,
name|o2
argument_list|,
literal|0
argument_list|,
name|o2
operator|.
name|length
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
comment|// look up start times for the specified entities
comment|// skip entities with no start time
for|for
control|(
name|String
name|entityId
range|:
name|entityIds
control|)
block|{
name|byte
index|[]
name|startTime
init|=
name|getStartTime
argument_list|(
name|entityId
argument_list|,
name|entityType
argument_list|)
decl_stmt|;
if|if
condition|(
name|startTime
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|EntityIdentifier
argument_list|>
name|entities
init|=
name|startTimeMap
operator|.
name|get
argument_list|(
name|startTime
argument_list|)
decl_stmt|;
if|if
condition|(
name|entities
operator|==
literal|null
condition|)
block|{
name|entities
operator|=
operator|new
name|ArrayList
argument_list|<
name|EntityIdentifier
argument_list|>
argument_list|()
expr_stmt|;
name|startTimeMap
operator|.
name|put
argument_list|(
name|startTime
argument_list|,
name|entities
argument_list|)
expr_stmt|;
block|}
name|entities
operator|.
name|add
argument_list|(
operator|new
name|EntityIdentifier
argument_list|(
name|entityId
argument_list|,
name|entityType
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|List
argument_list|<
name|EntityIdentifier
argument_list|>
argument_list|>
name|entry
range|:
name|startTimeMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// look up the events matching the given parameters (limit,
comment|// start time, end time, event types) for entities whose start times
comment|// were found and add the entities to the return list
name|byte
index|[]
name|revStartTime
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
for|for
control|(
name|EntityIdentifier
name|entityIdentifier
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
name|EventsOfOneEntity
name|entity
init|=
operator|new
name|EventsOfOneEntity
argument_list|()
decl_stmt|;
name|entity
operator|.
name|setEntityId
argument_list|(
name|entityIdentifier
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|entity
operator|.
name|setEntityType
argument_list|(
name|entityType
argument_list|)
expr_stmt|;
name|events
operator|.
name|addEvent
argument_list|(
name|entity
argument_list|)
expr_stmt|;
name|KeyBuilder
name|kb
init|=
name|KeyBuilder
operator|.
name|newInstance
argument_list|()
operator|.
name|add
argument_list|(
name|entityType
argument_list|)
operator|.
name|add
argument_list|(
name|revStartTime
argument_list|)
operator|.
name|add
argument_list|(
name|entityIdentifier
operator|.
name|getId
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|EVENTS_COLUMN
argument_list|)
decl_stmt|;
name|byte
index|[]
name|prefix
init|=
name|kb
operator|.
name|getBytesForLookup
argument_list|()
decl_stmt|;
if|if
condition|(
name|windowEnd
operator|==
literal|null
condition|)
block|{
name|windowEnd
operator|=
name|Long
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
name|byte
index|[]
name|revts
init|=
name|writeReverseOrderedLong
argument_list|(
name|windowEnd
argument_list|)
decl_stmt|;
name|kb
operator|.
name|add
argument_list|(
name|revts
argument_list|)
expr_stmt|;
name|byte
index|[]
name|first
init|=
name|kb
operator|.
name|getBytesForLookup
argument_list|()
decl_stmt|;
name|byte
index|[]
name|last
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|windowStart
operator|!=
literal|null
condition|)
block|{
name|last
operator|=
name|KeyBuilder
operator|.
name|newInstance
argument_list|()
operator|.
name|add
argument_list|(
name|prefix
argument_list|)
operator|.
name|add
argument_list|(
name|writeReverseOrderedLong
argument_list|(
name|windowStart
argument_list|)
argument_list|)
operator|.
name|getBytesForLookup
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|limit
operator|==
literal|null
condition|)
block|{
name|limit
operator|=
name|DEFAULT_LIMIT
expr_stmt|;
block|}
name|DB
name|db
init|=
name|entitydb
operator|.
name|getDBForStartTime
argument_list|(
name|readReverseOrderedLong
argument_list|(
name|revStartTime
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|db
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
try|try
init|(
name|DBIterator
name|iterator
init|=
name|db
operator|.
name|iterator
argument_list|()
init|)
block|{
for|for
control|(
name|iterator
operator|.
name|seek
argument_list|(
name|first
argument_list|)
init|;
name|entity
operator|.
name|getEvents
argument_list|()
operator|.
name|size
argument_list|()
operator|<
name|limit
operator|&&
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
name|iterator
operator|.
name|next
argument_list|()
control|)
block|{
name|byte
index|[]
name|key
init|=
name|iterator
operator|.
name|peekNext
argument_list|()
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|prefixMatches
argument_list|(
name|prefix
argument_list|,
name|prefix
operator|.
name|length
argument_list|,
name|key
argument_list|)
operator|||
operator|(
name|last
operator|!=
literal|null
operator|&&
name|WritableComparator
operator|.
name|compareBytes
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|length
argument_list|,
name|last
argument_list|,
literal|0
argument_list|,
name|last
operator|.
name|length
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
break|break;
block|}
name|TimelineEvent
name|event
init|=
name|getEntityEvent
argument_list|(
name|eventType
argument_list|,
name|key
argument_list|,
name|prefix
operator|.
name|length
argument_list|,
name|iterator
operator|.
name|peekNext
argument_list|()
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|event
operator|!=
literal|null
condition|)
block|{
name|entity
operator|.
name|addEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|events
return|;
block|}
annotation|@
name|Override
DECL|method|getEntities (String entityType, Long limit, Long windowStart, Long windowEnd, String fromId, Long fromTs, NameValuePair primaryFilter, Collection<NameValuePair> secondaryFilters, EnumSet<Field> fields, CheckAcl checkAcl)
specifier|public
name|TimelineEntities
name|getEntities
parameter_list|(
name|String
name|entityType
parameter_list|,
name|Long
name|limit
parameter_list|,
name|Long
name|windowStart
parameter_list|,
name|Long
name|windowEnd
parameter_list|,
name|String
name|fromId
parameter_list|,
name|Long
name|fromTs
parameter_list|,
name|NameValuePair
name|primaryFilter
parameter_list|,
name|Collection
argument_list|<
name|NameValuePair
argument_list|>
name|secondaryFilters
parameter_list|,
name|EnumSet
argument_list|<
name|Field
argument_list|>
name|fields
parameter_list|,
name|CheckAcl
name|checkAcl
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|primaryFilter
operator|==
literal|null
condition|)
block|{
comment|// if no primary filter is specified, prefix the lookup with
comment|// ENTITY_ENTRY_PREFIX
return|return
name|getEntityByTime
argument_list|(
name|EMPTY_BYTES
argument_list|,
name|entityType
argument_list|,
name|limit
argument_list|,
name|windowStart
argument_list|,
name|windowEnd
argument_list|,
name|fromId
argument_list|,
name|fromTs
argument_list|,
name|secondaryFilters
argument_list|,
name|fields
argument_list|,
name|checkAcl
argument_list|,
literal|false
argument_list|)
return|;
block|}
else|else
block|{
comment|// if a primary filter is specified, prefix the lookup with
comment|// INDEXED_ENTRY_PREFIX + primaryFilterName + primaryFilterValue +
comment|// ENTITY_ENTRY_PREFIX
name|byte
index|[]
name|base
init|=
name|KeyBuilder
operator|.
name|newInstance
argument_list|()
operator|.
name|add
argument_list|(
name|primaryFilter
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|fstConf
operator|.
name|asByteArray
argument_list|(
name|primaryFilter
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|,
literal|true
argument_list|)
operator|.
name|getBytesForLookup
argument_list|()
decl_stmt|;
return|return
name|getEntityByTime
argument_list|(
name|base
argument_list|,
name|entityType
argument_list|,
name|limit
argument_list|,
name|windowStart
argument_list|,
name|windowEnd
argument_list|,
name|fromId
argument_list|,
name|fromTs
argument_list|,
name|secondaryFilters
argument_list|,
name|fields
argument_list|,
name|checkAcl
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
comment|/**    * Retrieves a list of entities satisfying given parameters.    *    * @param base    *          A byte array prefix for the lookup    * @param entityType    *          The type of the entity    * @param limit    *          A limit on the number of entities to return    * @param starttime    *          The earliest entity start time to retrieve (exclusive)    * @param endtime    *          The latest entity start time to retrieve (inclusive)    * @param fromId    *          Retrieve entities starting with this entity    * @param fromTs    *          Ignore entities with insert timestamp later than this ts    * @param secondaryFilters    *          Filter pairs that the entities should match    * @param fields    *          The set of fields to retrieve    * @param usingPrimaryFilter    *          true if this query is using a primary filter    * @return A list of entities    * @throws IOException    */
DECL|method|getEntityByTime (byte[] base, String entityType, Long limit, Long starttime, Long endtime, String fromId, Long fromTs, Collection<NameValuePair> secondaryFilters, EnumSet<Field> fields, CheckAcl checkAcl, boolean usingPrimaryFilter)
specifier|private
name|TimelineEntities
name|getEntityByTime
parameter_list|(
name|byte
index|[]
name|base
parameter_list|,
name|String
name|entityType
parameter_list|,
name|Long
name|limit
parameter_list|,
name|Long
name|starttime
parameter_list|,
name|Long
name|endtime
parameter_list|,
name|String
name|fromId
parameter_list|,
name|Long
name|fromTs
parameter_list|,
name|Collection
argument_list|<
name|NameValuePair
argument_list|>
name|secondaryFilters
parameter_list|,
name|EnumSet
argument_list|<
name|Field
argument_list|>
name|fields
parameter_list|,
name|CheckAcl
name|checkAcl
parameter_list|,
name|boolean
name|usingPrimaryFilter
parameter_list|)
throws|throws
name|IOException
block|{
name|KeyBuilder
name|kb
init|=
name|KeyBuilder
operator|.
name|newInstance
argument_list|()
operator|.
name|add
argument_list|(
name|base
argument_list|)
operator|.
name|add
argument_list|(
name|entityType
argument_list|)
decl_stmt|;
comment|// only db keys matching the prefix (base + entity type) will be parsed
name|byte
index|[]
name|prefix
init|=
name|kb
operator|.
name|getBytesForLookup
argument_list|()
decl_stmt|;
if|if
condition|(
name|endtime
operator|==
literal|null
condition|)
block|{
comment|// if end time is null, place no restriction on end time
name|endtime
operator|=
name|Long
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
comment|// Sanitize the fields parameter
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
name|fields
operator|=
name|EnumSet
operator|.
name|allOf
argument_list|(
name|Field
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|// construct a first key that will be seeked to using end time or fromId
name|long
name|firstStartTime
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
name|byte
index|[]
name|first
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|fromId
operator|!=
literal|null
condition|)
block|{
name|Long
name|fromIdStartTime
init|=
name|getStartTimeLong
argument_list|(
name|fromId
argument_list|,
name|entityType
argument_list|)
decl_stmt|;
if|if
condition|(
name|fromIdStartTime
operator|==
literal|null
condition|)
block|{
comment|// no start time for provided id, so return empty entities
return|return
operator|new
name|TimelineEntities
argument_list|()
return|;
block|}
if|if
condition|(
name|fromIdStartTime
operator|<=
name|endtime
condition|)
block|{
comment|// if provided id's start time falls before the end of the window,
comment|// use it to construct the seek key
name|firstStartTime
operator|=
name|fromIdStartTime
expr_stmt|;
name|first
operator|=
name|kb
operator|.
name|add
argument_list|(
name|writeReverseOrderedLong
argument_list|(
name|fromIdStartTime
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
name|fromId
argument_list|)
operator|.
name|getBytesForLookup
argument_list|()
expr_stmt|;
block|}
block|}
comment|// if seek key wasn't constructed using fromId, construct it using end ts
if|if
condition|(
name|first
operator|==
literal|null
condition|)
block|{
name|firstStartTime
operator|=
name|endtime
expr_stmt|;
name|first
operator|=
name|kb
operator|.
name|add
argument_list|(
name|writeReverseOrderedLong
argument_list|(
name|endtime
argument_list|)
argument_list|)
operator|.
name|getBytesForLookup
argument_list|()
expr_stmt|;
block|}
name|byte
index|[]
name|last
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|starttime
operator|!=
literal|null
condition|)
block|{
comment|// if start time is not null, set a last key that will not be
comment|// iterated past
name|last
operator|=
name|KeyBuilder
operator|.
name|newInstance
argument_list|()
operator|.
name|add
argument_list|(
name|base
argument_list|)
operator|.
name|add
argument_list|(
name|entityType
argument_list|)
operator|.
name|add
argument_list|(
name|writeReverseOrderedLong
argument_list|(
name|starttime
argument_list|)
argument_list|)
operator|.
name|getBytesForLookup
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|limit
operator|==
literal|null
condition|)
block|{
comment|// if limit is not specified, use the default
name|limit
operator|=
name|DEFAULT_LIMIT
expr_stmt|;
block|}
name|TimelineEntities
name|entities
init|=
operator|new
name|TimelineEntities
argument_list|()
decl_stmt|;
name|RollingLevelDB
name|rollingdb
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|usingPrimaryFilter
condition|)
block|{
name|rollingdb
operator|=
name|indexdb
expr_stmt|;
block|}
else|else
block|{
name|rollingdb
operator|=
name|entitydb
expr_stmt|;
block|}
name|DB
name|db
init|=
name|rollingdb
operator|.
name|getDBForStartTime
argument_list|(
name|firstStartTime
argument_list|)
decl_stmt|;
while|while
condition|(
name|entities
operator|.
name|getEntities
argument_list|()
operator|.
name|size
argument_list|()
operator|<
name|limit
operator|&&
name|db
operator|!=
literal|null
condition|)
block|{
try|try
init|(
name|DBIterator
name|iterator
init|=
name|db
operator|.
name|iterator
argument_list|()
init|)
block|{
name|iterator
operator|.
name|seek
argument_list|(
name|first
argument_list|)
expr_stmt|;
comment|// iterate until one of the following conditions is met: limit is
comment|// reached, there are no more keys, the key prefix no longer matches,
comment|// or a start time has been specified and reached/exceeded
while|while
condition|(
name|entities
operator|.
name|getEntities
argument_list|()
operator|.
name|size
argument_list|()
operator|<
name|limit
operator|&&
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|byte
index|[]
name|key
init|=
name|iterator
operator|.
name|peekNext
argument_list|()
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|prefixMatches
argument_list|(
name|prefix
argument_list|,
name|prefix
operator|.
name|length
argument_list|,
name|key
argument_list|)
operator|||
operator|(
name|last
operator|!=
literal|null
operator|&&
name|WritableComparator
operator|.
name|compareBytes
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|key
operator|.
name|length
argument_list|,
name|last
argument_list|,
literal|0
argument_list|,
name|last
operator|.
name|length
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
break|break;
block|}
comment|// read the start time and entity id from the current key
name|KeyParser
name|kp
init|=
operator|new
name|KeyParser
argument_list|(
name|key
argument_list|,
name|prefix
operator|.
name|length
argument_list|)
decl_stmt|;
name|Long
name|startTime
init|=
name|kp
operator|.
name|getNextLong
argument_list|()
decl_stmt|;
name|String
name|entityId
init|=
name|kp
operator|.
name|getNextString
argument_list|()
decl_stmt|;
if|if
condition|(
name|fromTs
operator|!=
literal|null
condition|)
block|{
name|long
name|insertTime
init|=
name|readReverseOrderedLong
argument_list|(
name|iterator
operator|.
name|peekNext
argument_list|()
operator|.
name|getValue
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|insertTime
operator|>
name|fromTs
condition|)
block|{
name|byte
index|[]
name|firstKey
init|=
name|key
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|key
operator|=
name|iterator
operator|.
name|peekNext
argument_list|()
operator|.
name|getKey
argument_list|()
expr_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|prefixMatches
argument_list|(
name|firstKey
argument_list|,
name|kp
operator|.
name|getOffset
argument_list|()
argument_list|,
name|key
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
continue|continue;
block|}
block|}
comment|// Even if other info and primary filter fields are not included, we
comment|// still need to load them to match secondary filters when they are
comment|// non-empty
name|EnumSet
argument_list|<
name|Field
argument_list|>
name|queryFields
init|=
name|EnumSet
operator|.
name|copyOf
argument_list|(
name|fields
argument_list|)
decl_stmt|;
name|boolean
name|addPrimaryFilters
init|=
literal|false
decl_stmt|;
name|boolean
name|addOtherInfo
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|secondaryFilters
operator|!=
literal|null
operator|&&
name|secondaryFilters
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|queryFields
operator|.
name|contains
argument_list|(
name|Field
operator|.
name|PRIMARY_FILTERS
argument_list|)
condition|)
block|{
name|queryFields
operator|.
name|add
argument_list|(
name|Field
operator|.
name|PRIMARY_FILTERS
argument_list|)
expr_stmt|;
name|addPrimaryFilters
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|queryFields
operator|.
name|contains
argument_list|(
name|Field
operator|.
name|OTHER_INFO
argument_list|)
condition|)
block|{
name|queryFields
operator|.
name|add
argument_list|(
name|Field
operator|.
name|OTHER_INFO
argument_list|)
expr_stmt|;
name|addOtherInfo
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// parse the entity that owns this key, iterating over all keys for
comment|// the entity
name|TimelineEntity
name|entity
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|usingPrimaryFilter
condition|)
block|{
name|entity
operator|=
name|getEntity
argument_list|(
name|entityId
argument_list|,
name|entityType
argument_list|,
name|queryFields
argument_list|)
expr_stmt|;
name|iterator
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|entity
operator|=
name|getEntity
argument_list|(
name|entityId
argument_list|,
name|entityType
argument_list|,
name|startTime
argument_list|,
name|queryFields
argument_list|,
name|iterator
argument_list|,
name|key
argument_list|,
name|kp
operator|.
name|getOffset
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// determine if the retrieved entity matches the provided secondary
comment|// filters, and if so add it to the list of entities to return
name|boolean
name|filterPassed
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|secondaryFilters
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|NameValuePair
name|filter
range|:
name|secondaryFilters
control|)
block|{
name|Object
name|v
init|=
name|entity
operator|.
name|getOtherInfo
argument_list|()
operator|.
name|get
argument_list|(
name|filter
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|null
condition|)
block|{
name|Set
argument_list|<
name|Object
argument_list|>
name|vs
init|=
name|entity
operator|.
name|getPrimaryFilters
argument_list|()
operator|.
name|get
argument_list|(
name|filter
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|vs
operator|==
literal|null
operator|||
operator|!
name|vs
operator|.
name|contains
argument_list|(
name|filter
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|filterPassed
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|v
operator|.
name|equals
argument_list|(
name|filter
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|filterPassed
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|filterPassed
condition|)
block|{
if|if
condition|(
name|entity
operator|.
name|getDomainId
argument_list|()
operator|==
literal|null
condition|)
block|{
name|entity
operator|.
name|setDomainId
argument_list|(
name|DEFAULT_DOMAIN_ID
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|checkAcl
operator|==
literal|null
operator|||
name|checkAcl
operator|.
name|check
argument_list|(
name|entity
argument_list|)
condition|)
block|{
comment|// Remove primary filter and other info if they are added for
comment|// matching secondary filters
if|if
condition|(
name|addPrimaryFilters
condition|)
block|{
name|entity
operator|.
name|setPrimaryFilters
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addOtherInfo
condition|)
block|{
name|entity
operator|.
name|setOtherInfo
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|entities
operator|.
name|addEntity
argument_list|(
name|entity
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|db
operator|=
name|rollingdb
operator|.
name|getPreviousDB
argument_list|(
name|db
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|entities
return|;
block|}
comment|/**    * Put a single entity. If there is an error, add a TimelinePutError to the    * given response.    *    * @param entityUpdates    *          a map containing all the scheduled writes for this put to the    *          entity db    * @param indexUpdates    *          a map containing all the scheduled writes for this put to the    *          index db    */
DECL|method|putEntities (TreeMap<Long, RollingWriteBatch> entityUpdates, TreeMap<Long, RollingWriteBatch> indexUpdates, TimelineEntity entity, TimelinePutResponse response)
specifier|private
name|long
name|putEntities
parameter_list|(
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|RollingWriteBatch
argument_list|>
name|entityUpdates
parameter_list|,
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|RollingWriteBatch
argument_list|>
name|indexUpdates
parameter_list|,
name|TimelineEntity
name|entity
parameter_list|,
name|TimelinePutResponse
name|response
parameter_list|)
block|{
name|long
name|putCount
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|EntityIdentifier
argument_list|>
name|relatedEntitiesWithoutStartTimes
init|=
operator|new
name|ArrayList
argument_list|<
name|EntityIdentifier
argument_list|>
argument_list|()
decl_stmt|;
name|byte
index|[]
name|revStartTime
init|=
literal|null
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|Object
argument_list|>
argument_list|>
name|primaryFilters
init|=
literal|null
decl_stmt|;
try|try
block|{
name|List
argument_list|<
name|TimelineEvent
argument_list|>
name|events
init|=
name|entity
operator|.
name|getEvents
argument_list|()
decl_stmt|;
comment|// look up the start time for the entity
name|Long
name|startTime
init|=
name|getAndSetStartTime
argument_list|(
name|entity
operator|.
name|getEntityId
argument_list|()
argument_list|,
name|entity
operator|.
name|getEntityType
argument_list|()
argument_list|,
name|entity
operator|.
name|getStartTime
argument_list|()
argument_list|,
name|events
argument_list|)
decl_stmt|;
if|if
condition|(
name|startTime
operator|==
literal|null
condition|)
block|{
comment|// if no start time is found, add an error and return
name|TimelinePutError
name|error
init|=
operator|new
name|TimelinePutError
argument_list|()
decl_stmt|;
name|error
operator|.
name|setEntityId
argument_list|(
name|entity
operator|.
name|getEntityId
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|.
name|setEntityType
argument_list|(
name|entity
operator|.
name|getEntityType
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|.
name|setErrorCode
argument_list|(
name|TimelinePutError
operator|.
name|NO_START_TIME
argument_list|)
expr_stmt|;
name|response
operator|.
name|addError
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
name|putCount
return|;
block|}
comment|// Must have a domain
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|entity
operator|.
name|getDomainId
argument_list|()
argument_list|)
condition|)
block|{
name|TimelinePutError
name|error
init|=
operator|new
name|TimelinePutError
argument_list|()
decl_stmt|;
name|error
operator|.
name|setEntityId
argument_list|(
name|entity
operator|.
name|getEntityId
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|.
name|setEntityType
argument_list|(
name|entity
operator|.
name|getEntityType
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|.
name|setErrorCode
argument_list|(
name|TimelinePutError
operator|.
name|NO_DOMAIN
argument_list|)
expr_stmt|;
name|response
operator|.
name|addError
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
name|putCount
return|;
block|}
name|revStartTime
operator|=
name|writeReverseOrderedLong
argument_list|(
name|startTime
argument_list|)
expr_stmt|;
name|long
name|roundedStartTime
init|=
name|entitydb
operator|.
name|computeCurrentCheckMillis
argument_list|(
name|startTime
argument_list|)
decl_stmt|;
name|RollingWriteBatch
name|rollingWriteBatch
init|=
name|entityUpdates
operator|.
name|get
argument_list|(
name|roundedStartTime
argument_list|)
decl_stmt|;
if|if
condition|(
name|rollingWriteBatch
operator|==
literal|null
condition|)
block|{
name|DB
name|db
init|=
name|entitydb
operator|.
name|getDBForStartTime
argument_list|(
name|startTime
argument_list|)
decl_stmt|;
if|if
condition|(
name|db
operator|!=
literal|null
condition|)
block|{
name|WriteBatch
name|writeBatch
init|=
name|db
operator|.
name|createWriteBatch
argument_list|()
decl_stmt|;
name|rollingWriteBatch
operator|=
operator|new
name|RollingWriteBatch
argument_list|(
name|db
argument_list|,
name|writeBatch
argument_list|)
expr_stmt|;
name|entityUpdates
operator|.
name|put
argument_list|(
name|roundedStartTime
argument_list|,
name|rollingWriteBatch
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rollingWriteBatch
operator|==
literal|null
condition|)
block|{
comment|// if no start time is found, add an error and return
name|TimelinePutError
name|error
init|=
operator|new
name|TimelinePutError
argument_list|()
decl_stmt|;
name|error
operator|.
name|setEntityId
argument_list|(
name|entity
operator|.
name|getEntityId
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|.
name|setEntityType
argument_list|(
name|entity
operator|.
name|getEntityType
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|.
name|setErrorCode
argument_list|(
name|TimelinePutError
operator|.
name|EXPIRED_ENTITY
argument_list|)
expr_stmt|;
name|response
operator|.
name|addError
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
name|putCount
return|;
block|}
name|WriteBatch
name|writeBatch
init|=
name|rollingWriteBatch
operator|.
name|getWriteBatch
argument_list|()
decl_stmt|;
comment|// Save off the getBytes conversion to avoid unnecessary cost
name|byte
index|[]
name|entityIdBytes
init|=
name|entity
operator|.
name|getEntityId
argument_list|()
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
decl_stmt|;
name|byte
index|[]
name|entityTypeBytes
init|=
name|entity
operator|.
name|getEntityType
argument_list|()
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
decl_stmt|;
name|byte
index|[]
name|domainIdBytes
init|=
name|entity
operator|.
name|getDomainId
argument_list|()
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
decl_stmt|;
comment|// write entity marker
name|byte
index|[]
name|markerKey
init|=
name|KeyBuilder
operator|.
name|newInstance
argument_list|(
literal|3
argument_list|)
operator|.
name|add
argument_list|(
name|entityTypeBytes
argument_list|,
literal|true
argument_list|)
operator|.
name|add
argument_list|(
name|revStartTime
argument_list|)
operator|.
name|add
argument_list|(
name|entityIdBytes
argument_list|,
literal|true
argument_list|)
operator|.
name|getBytesForLookup
argument_list|()
decl_stmt|;
name|writeBatch
operator|.
name|put
argument_list|(
name|markerKey
argument_list|,
name|EMPTY_BYTES
argument_list|)
expr_stmt|;
operator|++
name|putCount
expr_stmt|;
comment|// write domain id entry
name|byte
index|[]
name|domainkey
init|=
name|KeyBuilder
operator|.
name|newInstance
argument_list|(
literal|4
argument_list|)
operator|.
name|add
argument_list|(
name|entityTypeBytes
argument_list|,
literal|true
argument_list|)
operator|.
name|add
argument_list|(
name|revStartTime
argument_list|)
operator|.
name|add
argument_list|(
name|entityIdBytes
argument_list|,
literal|true
argument_list|)
operator|.
name|add
argument_list|(
name|DOMAIN_ID_COLUMN
argument_list|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|writeBatch
operator|.
name|put
argument_list|(
name|domainkey
argument_list|,
name|domainIdBytes
argument_list|)
expr_stmt|;
operator|++
name|putCount
expr_stmt|;
comment|// write event entries
if|if
condition|(
name|events
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|TimelineEvent
name|event
range|:
name|events
control|)
block|{
name|byte
index|[]
name|revts
init|=
name|writeReverseOrderedLong
argument_list|(
name|event
operator|.
name|getTimestamp
argument_list|()
argument_list|)
decl_stmt|;
name|byte
index|[]
name|key
init|=
name|KeyBuilder
operator|.
name|newInstance
argument_list|()
operator|.
name|add
argument_list|(
name|entityTypeBytes
argument_list|,
literal|true
argument_list|)
operator|.
name|add
argument_list|(
name|revStartTime
argument_list|)
operator|.
name|add
argument_list|(
name|entityIdBytes
argument_list|,
literal|true
argument_list|)
operator|.
name|add
argument_list|(
name|EVENTS_COLUMN
argument_list|)
operator|.
name|add
argument_list|(
name|revts
argument_list|)
operator|.
name|add
argument_list|(
name|event
operator|.
name|getEventType
argument_list|()
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
argument_list|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|byte
index|[]
name|value
init|=
name|fstConf
operator|.
name|asByteArray
argument_list|(
name|event
operator|.
name|getEventInfo
argument_list|()
argument_list|)
decl_stmt|;
name|writeBatch
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
operator|++
name|putCount
expr_stmt|;
block|}
block|}
comment|// write primary filter entries
name|primaryFilters
operator|=
name|entity
operator|.
name|getPrimaryFilters
argument_list|()
expr_stmt|;
if|if
condition|(
name|primaryFilters
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|Object
argument_list|>
argument_list|>
name|primaryFilter
range|:
name|primaryFilters
operator|.
name|entrySet
argument_list|()
control|)
block|{
for|for
control|(
name|Object
name|primaryFilterValue
range|:
name|primaryFilter
operator|.
name|getValue
argument_list|()
control|)
block|{
name|byte
index|[]
name|key
init|=
name|KeyBuilder
operator|.
name|newInstance
argument_list|(
literal|6
argument_list|)
operator|.
name|add
argument_list|(
name|entityTypeBytes
argument_list|,
literal|true
argument_list|)
operator|.
name|add
argument_list|(
name|revStartTime
argument_list|)
operator|.
name|add
argument_list|(
name|entityIdBytes
argument_list|,
literal|true
argument_list|)
operator|.
name|add
argument_list|(
name|PRIMARY_FILTERS_COLUMN
argument_list|)
operator|.
name|add
argument_list|(
name|primaryFilter
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|fstConf
operator|.
name|asByteArray
argument_list|(
name|primaryFilterValue
argument_list|)
argument_list|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|writeBatch
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|EMPTY_BYTES
argument_list|)
expr_stmt|;
operator|++
name|putCount
expr_stmt|;
block|}
block|}
block|}
comment|// write other info entries
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|otherInfo
init|=
name|entity
operator|.
name|getOtherInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|otherInfo
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|info
range|:
name|otherInfo
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|byte
index|[]
name|key
init|=
name|KeyBuilder
operator|.
name|newInstance
argument_list|(
literal|5
argument_list|)
operator|.
name|add
argument_list|(
name|entityTypeBytes
argument_list|,
literal|true
argument_list|)
operator|.
name|add
argument_list|(
name|revStartTime
argument_list|)
operator|.
name|add
argument_list|(
name|entityIdBytes
argument_list|,
literal|true
argument_list|)
operator|.
name|add
argument_list|(
name|OTHER_INFO_COLUMN
argument_list|)
operator|.
name|add
argument_list|(
name|info
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|byte
index|[]
name|value
init|=
name|fstConf
operator|.
name|asByteArray
argument_list|(
name|info
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|writeBatch
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
operator|++
name|putCount
expr_stmt|;
block|}
block|}
comment|// write related entity entries
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|relatedEntities
init|=
name|entity
operator|.
name|getRelatedEntities
argument_list|()
decl_stmt|;
if|if
condition|(
name|relatedEntities
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|relatedEntityList
range|:
name|relatedEntities
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|relatedEntityType
init|=
name|relatedEntityList
operator|.
name|getKey
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|relatedEntityId
range|:
name|relatedEntityList
operator|.
name|getValue
argument_list|()
control|)
block|{
comment|// look up start time of related entity
name|Long
name|relatedStartTimeLong
init|=
name|getStartTimeLong
argument_list|(
name|relatedEntityId
argument_list|,
name|relatedEntityType
argument_list|)
decl_stmt|;
comment|// delay writing the related entity if no start time is found
if|if
condition|(
name|relatedStartTimeLong
operator|==
literal|null
condition|)
block|{
name|relatedEntitiesWithoutStartTimes
operator|.
name|add
argument_list|(
operator|new
name|EntityIdentifier
argument_list|(
name|relatedEntityId
argument_list|,
name|relatedEntityType
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|byte
index|[]
name|relatedEntityStartTime
init|=
name|writeReverseOrderedLong
argument_list|(
name|relatedStartTimeLong
argument_list|)
decl_stmt|;
name|long
name|relatedRoundedStartTime
init|=
name|entitydb
operator|.
name|computeCurrentCheckMillis
argument_list|(
name|relatedStartTimeLong
argument_list|)
decl_stmt|;
name|RollingWriteBatch
name|relatedRollingWriteBatch
init|=
name|entityUpdates
operator|.
name|get
argument_list|(
name|relatedRoundedStartTime
argument_list|)
decl_stmt|;
if|if
condition|(
name|relatedRollingWriteBatch
operator|==
literal|null
condition|)
block|{
name|DB
name|db
init|=
name|entitydb
operator|.
name|getDBForStartTime
argument_list|(
name|relatedStartTimeLong
argument_list|)
decl_stmt|;
if|if
condition|(
name|db
operator|!=
literal|null
condition|)
block|{
name|WriteBatch
name|relatedWriteBatch
init|=
name|db
operator|.
name|createWriteBatch
argument_list|()
decl_stmt|;
name|relatedRollingWriteBatch
operator|=
operator|new
name|RollingWriteBatch
argument_list|(
name|db
argument_list|,
name|relatedWriteBatch
argument_list|)
expr_stmt|;
name|entityUpdates
operator|.
name|put
argument_list|(
name|relatedRoundedStartTime
argument_list|,
name|relatedRollingWriteBatch
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|relatedRollingWriteBatch
operator|==
literal|null
condition|)
block|{
comment|// if no start time is found, add an error and return
name|TimelinePutError
name|error
init|=
operator|new
name|TimelinePutError
argument_list|()
decl_stmt|;
name|error
operator|.
name|setEntityId
argument_list|(
name|entity
operator|.
name|getEntityId
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|.
name|setEntityType
argument_list|(
name|entity
operator|.
name|getEntityType
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|.
name|setErrorCode
argument_list|(
name|TimelinePutError
operator|.
name|EXPIRED_ENTITY
argument_list|)
expr_stmt|;
name|response
operator|.
name|addError
argument_list|(
name|error
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// This is the existing entity
name|byte
index|[]
name|relatedDomainIdBytes
init|=
name|relatedRollingWriteBatch
operator|.
name|getDB
argument_list|()
operator|.
name|get
argument_list|(
name|createDomainIdKey
argument_list|(
name|relatedEntityId
argument_list|,
name|relatedEntityType
argument_list|,
name|relatedEntityStartTime
argument_list|)
argument_list|)
decl_stmt|;
comment|// The timeline data created by the server before 2.6 won't have
comment|// the domain field. We assume this timeline data is in the
comment|// default timeline domain.
name|String
name|domainId
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|relatedDomainIdBytes
operator|==
literal|null
condition|)
block|{
name|domainId
operator|=
name|TimelineDataManager
operator|.
name|DEFAULT_DOMAIN_ID
expr_stmt|;
block|}
else|else
block|{
name|domainId
operator|=
operator|new
name|String
argument_list|(
name|relatedDomainIdBytes
argument_list|,
name|UTF_8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|domainId
operator|.
name|equals
argument_list|(
name|entity
operator|.
name|getDomainId
argument_list|()
argument_list|)
condition|)
block|{
comment|// in this case the entity will be put, but the relation will be
comment|// ignored
name|TimelinePutError
name|error
init|=
operator|new
name|TimelinePutError
argument_list|()
decl_stmt|;
name|error
operator|.
name|setEntityId
argument_list|(
name|entity
operator|.
name|getEntityId
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|.
name|setEntityType
argument_list|(
name|entity
operator|.
name|getEntityType
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|.
name|setErrorCode
argument_list|(
name|TimelinePutError
operator|.
name|FORBIDDEN_RELATION
argument_list|)
expr_stmt|;
name|response
operator|.
name|addError
argument_list|(
name|error
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// write "forward" entry (related entity -> entity)
name|byte
index|[]
name|key
init|=
name|createRelatedEntityKey
argument_list|(
name|relatedEntityId
argument_list|,
name|relatedEntityType
argument_list|,
name|relatedEntityStartTime
argument_list|,
name|entity
operator|.
name|getEntityId
argument_list|()
argument_list|,
name|entity
operator|.
name|getEntityType
argument_list|()
argument_list|)
decl_stmt|;
name|WriteBatch
name|relatedWriteBatch
init|=
name|relatedRollingWriteBatch
operator|.
name|getWriteBatch
argument_list|()
decl_stmt|;
name|relatedWriteBatch
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|EMPTY_BYTES
argument_list|)
expr_stmt|;
operator|++
name|putCount
expr_stmt|;
block|}
block|}
block|}
comment|// write index entities
name|RollingWriteBatch
name|indexRollingWriteBatch
init|=
name|indexUpdates
operator|.
name|get
argument_list|(
name|roundedStartTime
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexRollingWriteBatch
operator|==
literal|null
condition|)
block|{
name|DB
name|db
init|=
name|indexdb
operator|.
name|getDBForStartTime
argument_list|(
name|startTime
argument_list|)
decl_stmt|;
if|if
condition|(
name|db
operator|!=
literal|null
condition|)
block|{
name|WriteBatch
name|indexWriteBatch
init|=
name|db
operator|.
name|createWriteBatch
argument_list|()
decl_stmt|;
name|indexRollingWriteBatch
operator|=
operator|new
name|RollingWriteBatch
argument_list|(
name|db
argument_list|,
name|indexWriteBatch
argument_list|)
expr_stmt|;
name|indexUpdates
operator|.
name|put
argument_list|(
name|roundedStartTime
argument_list|,
name|indexRollingWriteBatch
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|indexRollingWriteBatch
operator|==
literal|null
condition|)
block|{
comment|// if no start time is found, add an error and return
name|TimelinePutError
name|error
init|=
operator|new
name|TimelinePutError
argument_list|()
decl_stmt|;
name|error
operator|.
name|setEntityId
argument_list|(
name|entity
operator|.
name|getEntityId
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|.
name|setEntityType
argument_list|(
name|entity
operator|.
name|getEntityType
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|.
name|setErrorCode
argument_list|(
name|TimelinePutError
operator|.
name|EXPIRED_ENTITY
argument_list|)
expr_stmt|;
name|response
operator|.
name|addError
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
name|putCount
return|;
block|}
name|WriteBatch
name|indexWriteBatch
init|=
name|indexRollingWriteBatch
operator|.
name|getWriteBatch
argument_list|()
decl_stmt|;
name|putCount
operator|+=
name|writePrimaryFilterEntries
argument_list|(
name|indexWriteBatch
argument_list|,
name|primaryFilters
argument_list|,
name|markerKey
argument_list|,
name|EMPTY_BYTES
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error putting entity "
operator|+
name|entity
operator|.
name|getEntityId
argument_list|()
operator|+
literal|" of type "
operator|+
name|entity
operator|.
name|getEntityType
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|TimelinePutError
name|error
init|=
operator|new
name|TimelinePutError
argument_list|()
decl_stmt|;
name|error
operator|.
name|setEntityId
argument_list|(
name|entity
operator|.
name|getEntityId
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|.
name|setEntityType
argument_list|(
name|entity
operator|.
name|getEntityType
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|.
name|setErrorCode
argument_list|(
name|TimelinePutError
operator|.
name|IO_EXCEPTION
argument_list|)
expr_stmt|;
name|response
operator|.
name|addError
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|EntityIdentifier
name|relatedEntity
range|:
name|relatedEntitiesWithoutStartTimes
control|)
block|{
try|try
block|{
name|Long
name|relatedEntityStartAndInsertTime
init|=
name|getAndSetStartTime
argument_list|(
name|relatedEntity
operator|.
name|getId
argument_list|()
argument_list|,
name|relatedEntity
operator|.
name|getType
argument_list|()
argument_list|,
name|readReverseOrderedLong
argument_list|(
name|revStartTime
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|relatedEntityStartAndInsertTime
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Error setting start time for related entity"
argument_list|)
throw|;
block|}
name|long
name|relatedStartTimeLong
init|=
name|relatedEntityStartAndInsertTime
decl_stmt|;
name|long
name|relatedRoundedStartTime
init|=
name|entitydb
operator|.
name|computeCurrentCheckMillis
argument_list|(
name|relatedStartTimeLong
argument_list|)
decl_stmt|;
name|RollingWriteBatch
name|relatedRollingWriteBatch
init|=
name|entityUpdates
operator|.
name|get
argument_list|(
name|relatedRoundedStartTime
argument_list|)
decl_stmt|;
if|if
condition|(
name|relatedRollingWriteBatch
operator|==
literal|null
condition|)
block|{
name|DB
name|db
init|=
name|entitydb
operator|.
name|getDBForStartTime
argument_list|(
name|relatedStartTimeLong
argument_list|)
decl_stmt|;
if|if
condition|(
name|db
operator|!=
literal|null
condition|)
block|{
name|WriteBatch
name|relatedWriteBatch
init|=
name|db
operator|.
name|createWriteBatch
argument_list|()
decl_stmt|;
name|relatedRollingWriteBatch
operator|=
operator|new
name|RollingWriteBatch
argument_list|(
name|db
argument_list|,
name|relatedWriteBatch
argument_list|)
expr_stmt|;
name|entityUpdates
operator|.
name|put
argument_list|(
name|relatedRoundedStartTime
argument_list|,
name|relatedRollingWriteBatch
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|relatedRollingWriteBatch
operator|==
literal|null
condition|)
block|{
comment|// if no start time is found, add an error and return
name|TimelinePutError
name|error
init|=
operator|new
name|TimelinePutError
argument_list|()
decl_stmt|;
name|error
operator|.
name|setEntityId
argument_list|(
name|entity
operator|.
name|getEntityId
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|.
name|setEntityType
argument_list|(
name|entity
operator|.
name|getEntityType
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|.
name|setErrorCode
argument_list|(
name|TimelinePutError
operator|.
name|EXPIRED_ENTITY
argument_list|)
expr_stmt|;
name|response
operator|.
name|addError
argument_list|(
name|error
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|WriteBatch
name|relatedWriteBatch
init|=
name|relatedRollingWriteBatch
operator|.
name|getWriteBatch
argument_list|()
decl_stmt|;
name|byte
index|[]
name|relatedEntityStartTime
init|=
name|writeReverseOrderedLong
argument_list|(
name|relatedEntityStartAndInsertTime
argument_list|)
decl_stmt|;
comment|// This is the new entity, the domain should be the same
name|byte
index|[]
name|key
init|=
name|createDomainIdKey
argument_list|(
name|relatedEntity
operator|.
name|getId
argument_list|()
argument_list|,
name|relatedEntity
operator|.
name|getType
argument_list|()
argument_list|,
name|relatedEntityStartTime
argument_list|)
decl_stmt|;
name|relatedWriteBatch
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|entity
operator|.
name|getDomainId
argument_list|()
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|putCount
expr_stmt|;
name|relatedWriteBatch
operator|.
name|put
argument_list|(
name|createRelatedEntityKey
argument_list|(
name|relatedEntity
operator|.
name|getId
argument_list|()
argument_list|,
name|relatedEntity
operator|.
name|getType
argument_list|()
argument_list|,
name|relatedEntityStartTime
argument_list|,
name|entity
operator|.
name|getEntityId
argument_list|()
argument_list|,
name|entity
operator|.
name|getEntityType
argument_list|()
argument_list|)
argument_list|,
name|EMPTY_BYTES
argument_list|)
expr_stmt|;
operator|++
name|putCount
expr_stmt|;
name|relatedWriteBatch
operator|.
name|put
argument_list|(
name|createEntityMarkerKey
argument_list|(
name|relatedEntity
operator|.
name|getId
argument_list|()
argument_list|,
name|relatedEntity
operator|.
name|getType
argument_list|()
argument_list|,
name|relatedEntityStartTime
argument_list|)
argument_list|,
name|EMPTY_BYTES
argument_list|)
expr_stmt|;
operator|++
name|putCount
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error putting related entity "
operator|+
name|relatedEntity
operator|.
name|getId
argument_list|()
operator|+
literal|" of type "
operator|+
name|relatedEntity
operator|.
name|getType
argument_list|()
operator|+
literal|" for entity "
operator|+
name|entity
operator|.
name|getEntityId
argument_list|()
operator|+
literal|" of type "
operator|+
name|entity
operator|.
name|getEntityType
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|TimelinePutError
name|error
init|=
operator|new
name|TimelinePutError
argument_list|()
decl_stmt|;
name|error
operator|.
name|setEntityId
argument_list|(
name|entity
operator|.
name|getEntityId
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|.
name|setEntityType
argument_list|(
name|entity
operator|.
name|getEntityType
argument_list|()
argument_list|)
expr_stmt|;
name|error
operator|.
name|setErrorCode
argument_list|(
name|TimelinePutError
operator|.
name|IO_EXCEPTION
argument_list|)
expr_stmt|;
name|response
operator|.
name|addError
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|putCount
return|;
block|}
comment|/**    * For a given key / value pair that has been written to the db, write    * additional entries to the db for each primary filter.    */
DECL|method|writePrimaryFilterEntries (WriteBatch writeBatch, Map<String, Set<Object>> primaryFilters, byte[] key, byte[] value)
specifier|private
specifier|static
name|long
name|writePrimaryFilterEntries
parameter_list|(
name|WriteBatch
name|writeBatch
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|Object
argument_list|>
argument_list|>
name|primaryFilters
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|putCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|primaryFilters
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|Object
argument_list|>
argument_list|>
name|pf
range|:
name|primaryFilters
operator|.
name|entrySet
argument_list|()
control|)
block|{
for|for
control|(
name|Object
name|pfval
range|:
name|pf
operator|.
name|getValue
argument_list|()
control|)
block|{
name|writeBatch
operator|.
name|put
argument_list|(
name|addPrimaryFilterToKey
argument_list|(
name|pf
operator|.
name|getKey
argument_list|()
argument_list|,
name|pfval
argument_list|,
name|key
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
operator|++
name|putCount
expr_stmt|;
block|}
block|}
block|}
return|return
name|putCount
return|;
block|}
annotation|@
name|Override
DECL|method|put (TimelineEntities entities)
specifier|public
name|TimelinePutResponse
name|put
parameter_list|(
name|TimelineEntities
name|entities
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Starting put"
argument_list|)
expr_stmt|;
block|}
name|TimelinePutResponse
name|response
init|=
operator|new
name|TimelinePutResponse
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|RollingWriteBatch
argument_list|>
name|entityUpdates
init|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|RollingWriteBatch
argument_list|>
argument_list|()
decl_stmt|;
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|RollingWriteBatch
argument_list|>
name|indexUpdates
init|=
operator|new
name|TreeMap
argument_list|<
name|Long
argument_list|,
name|RollingWriteBatch
argument_list|>
argument_list|()
decl_stmt|;
name|long
name|entityCount
init|=
literal|0
decl_stmt|;
name|long
name|indexCount
init|=
literal|0
decl_stmt|;
try|try
block|{
for|for
control|(
name|TimelineEntity
name|entity
range|:
name|entities
operator|.
name|getEntities
argument_list|()
control|)
block|{
name|entityCount
operator|+=
name|putEntities
argument_list|(
name|entityUpdates
argument_list|,
name|indexUpdates
argument_list|,
name|entity
argument_list|,
name|response
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|RollingWriteBatch
name|entityUpdate
range|:
name|entityUpdates
operator|.
name|values
argument_list|()
control|)
block|{
name|entityUpdate
operator|.
name|write
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|RollingWriteBatch
name|indexUpdate
range|:
name|indexUpdates
operator|.
name|values
argument_list|()
control|)
block|{
name|indexUpdate
operator|.
name|write
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
for|for
control|(
name|RollingWriteBatch
name|entityRollingWriteBatch
range|:
name|entityUpdates
operator|.
name|values
argument_list|()
control|)
block|{
name|entityRollingWriteBatch
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|RollingWriteBatch
name|indexRollingWriteBatch
range|:
name|indexUpdates
operator|.
name|values
argument_list|()
control|)
block|{
name|indexRollingWriteBatch
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Put "
operator|+
name|entityCount
operator|+
literal|" new leveldb entity entries and "
operator|+
name|indexCount
operator|+
literal|" new leveldb index entries from "
operator|+
name|entities
operator|.
name|getEntities
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|" timeline entities"
argument_list|)
expr_stmt|;
block|}
return|return
name|response
return|;
block|}
comment|/**    * Get the unique start time for a given entity as a byte array that sorts the    * timestamps in reverse order (see    * {@link GenericObjectMapper#writeReverseOrderedLong(long)}).    *    * @param entityId    *          The id of the entity    * @param entityType    *          The type of the entity    * @return A byte array, null if not found    * @throws IOException    */
DECL|method|getStartTime (String entityId, String entityType)
specifier|private
name|byte
index|[]
name|getStartTime
parameter_list|(
name|String
name|entityId
parameter_list|,
name|String
name|entityType
parameter_list|)
throws|throws
name|IOException
block|{
name|Long
name|l
init|=
name|getStartTimeLong
argument_list|(
name|entityId
argument_list|,
name|entityType
argument_list|)
decl_stmt|;
return|return
name|l
operator|==
literal|null
condition|?
literal|null
else|:
name|writeReverseOrderedLong
argument_list|(
name|l
argument_list|)
return|;
block|}
comment|/**    * Get the unique start time for a given entity as a Long.    *    * @param entityId    *          The id of the entity    * @param entityType    *          The type of the entity    * @return A Long, null if not found    * @throws IOException    */
DECL|method|getStartTimeLong (String entityId, String entityType)
specifier|private
name|Long
name|getStartTimeLong
parameter_list|(
name|String
name|entityId
parameter_list|,
name|String
name|entityType
parameter_list|)
throws|throws
name|IOException
block|{
name|EntityIdentifier
name|entity
init|=
operator|new
name|EntityIdentifier
argument_list|(
name|entityId
argument_list|,
name|entityType
argument_list|)
decl_stmt|;
comment|// start time is not provided, so try to look it up
if|if
condition|(
name|startTimeReadCache
operator|.
name|containsKey
argument_list|(
name|entity
argument_list|)
condition|)
block|{
comment|// found the start time in the cache
return|return
name|startTimeReadCache
operator|.
name|get
argument_list|(
name|entity
argument_list|)
return|;
block|}
else|else
block|{
comment|// try to look up the start time in the db
name|byte
index|[]
name|b
init|=
name|createStartTimeLookupKey
argument_list|(
name|entity
operator|.
name|getId
argument_list|()
argument_list|,
name|entity
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|byte
index|[]
name|v
init|=
name|starttimedb
operator|.
name|get
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|null
condition|)
block|{
comment|// did not find the start time in the db
return|return
literal|null
return|;
block|}
else|else
block|{
comment|// found the start time in the db
name|Long
name|l
init|=
name|readReverseOrderedLong
argument_list|(
name|v
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|startTimeReadCache
operator|.
name|put
argument_list|(
name|entity
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|l
return|;
block|}
block|}
block|}
comment|/**    * Get the unique start time for a given entity as a byte array that sorts the    * timestamps in reverse order (see    * {@link GenericObjectMapper#writeReverseOrderedLong(long)}). If the start    * time doesn't exist, set it based on the information provided.    *    * @param entityId    *          The id of the entity    * @param entityType    *          The type of the entity    * @param startTime    *          The start time of the entity, or null    * @param events    *          A list of events for the entity, or null    * @return A StartAndInsertTime    * @throws IOException    */
DECL|method|getAndSetStartTime (String entityId, String entityType, Long startTime, List<TimelineEvent> events)
specifier|private
name|Long
name|getAndSetStartTime
parameter_list|(
name|String
name|entityId
parameter_list|,
name|String
name|entityType
parameter_list|,
name|Long
name|startTime
parameter_list|,
name|List
argument_list|<
name|TimelineEvent
argument_list|>
name|events
parameter_list|)
throws|throws
name|IOException
block|{
name|EntityIdentifier
name|entity
init|=
operator|new
name|EntityIdentifier
argument_list|(
name|entityId
argument_list|,
name|entityType
argument_list|)
decl_stmt|;
name|Long
name|time
init|=
name|startTimeWriteCache
operator|.
name|get
argument_list|(
name|entity
argument_list|)
decl_stmt|;
if|if
condition|(
name|time
operator|!=
literal|null
condition|)
block|{
comment|// return the value in the cache
return|return
name|time
return|;
block|}
if|if
condition|(
name|startTime
operator|==
literal|null
operator|&&
name|events
operator|!=
literal|null
condition|)
block|{
comment|// calculate best guess start time based on lowest event time
name|startTime
operator|=
name|Long
operator|.
name|MAX_VALUE
expr_stmt|;
for|for
control|(
name|TimelineEvent
name|e
range|:
name|events
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getTimestamp
argument_list|()
operator|<
name|startTime
condition|)
block|{
name|startTime
operator|=
name|e
operator|.
name|getTimestamp
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// check the provided start time matches the db
return|return
name|checkStartTimeInDb
argument_list|(
name|entity
argument_list|,
name|startTime
argument_list|)
return|;
block|}
comment|/**    * Checks db for start time and returns it if it exists. If it doesn't exist,    * writes the suggested start time (if it is not null). This is only called    * when the start time is not found in the cache, so it adds it back into the    * cache if it is found.    */
DECL|method|checkStartTimeInDb (EntityIdentifier entity, Long suggestedStartTime)
specifier|private
name|Long
name|checkStartTimeInDb
parameter_list|(
name|EntityIdentifier
name|entity
parameter_list|,
name|Long
name|suggestedStartTime
parameter_list|)
throws|throws
name|IOException
block|{
name|Long
name|startAndInsertTime
init|=
literal|null
decl_stmt|;
comment|// create lookup key for start time
name|byte
index|[]
name|b
init|=
name|createStartTimeLookupKey
argument_list|(
name|entity
operator|.
name|getId
argument_list|()
argument_list|,
name|entity
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// retrieve value for key
name|byte
index|[]
name|v
init|=
name|starttimedb
operator|.
name|get
argument_list|(
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|null
condition|)
block|{
comment|// start time doesn't exist in db
if|if
condition|(
name|suggestedStartTime
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|startAndInsertTime
operator|=
name|suggestedStartTime
expr_stmt|;
comment|// write suggested start time
name|starttimedb
operator|.
name|put
argument_list|(
name|b
argument_list|,
name|writeReverseOrderedLong
argument_list|(
name|suggestedStartTime
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// found start time in db, so ignore suggested start time
name|startAndInsertTime
operator|=
name|readReverseOrderedLong
argument_list|(
name|v
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|startTimeWriteCache
operator|.
name|put
argument_list|(
name|entity
argument_list|,
name|startAndInsertTime
argument_list|)
expr_stmt|;
name|startTimeReadCache
operator|.
name|put
argument_list|(
name|entity
argument_list|,
name|startAndInsertTime
argument_list|)
expr_stmt|;
return|return
name|startAndInsertTime
return|;
block|}
comment|/**    * Creates a key for looking up the start time of a given entity, of the form    * START_TIME_LOOKUP_PREFIX + entity type + entity id.    */
DECL|method|createStartTimeLookupKey (String entityId, String entityType)
specifier|private
specifier|static
name|byte
index|[]
name|createStartTimeLookupKey
parameter_list|(
name|String
name|entityId
parameter_list|,
name|String
name|entityType
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|KeyBuilder
operator|.
name|newInstance
argument_list|()
operator|.
name|add
argument_list|(
name|entityType
argument_list|)
operator|.
name|add
argument_list|(
name|entityId
argument_list|)
operator|.
name|getBytes
argument_list|()
return|;
block|}
comment|/**    * Creates an entity marker, serializing ENTITY_ENTRY_PREFIX + entity type +    * revstarttime + entity id.    */
DECL|method|createEntityMarkerKey (String entityId, String entityType, byte[] revStartTime)
specifier|private
specifier|static
name|byte
index|[]
name|createEntityMarkerKey
parameter_list|(
name|String
name|entityId
parameter_list|,
name|String
name|entityType
parameter_list|,
name|byte
index|[]
name|revStartTime
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|KeyBuilder
operator|.
name|newInstance
argument_list|()
operator|.
name|add
argument_list|(
name|entityType
argument_list|)
operator|.
name|add
argument_list|(
name|revStartTime
argument_list|)
operator|.
name|add
argument_list|(
name|entityId
argument_list|)
operator|.
name|getBytesForLookup
argument_list|()
return|;
block|}
comment|/**    * Creates an index entry for the given key of the form INDEXED_ENTRY_PREFIX +    * primaryfiltername + primaryfiltervalue + key.    */
DECL|method|addPrimaryFilterToKey (String primaryFilterName, Object primaryFilterValue, byte[] key)
specifier|private
specifier|static
name|byte
index|[]
name|addPrimaryFilterToKey
parameter_list|(
name|String
name|primaryFilterName
parameter_list|,
name|Object
name|primaryFilterValue
parameter_list|,
name|byte
index|[]
name|key
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|KeyBuilder
operator|.
name|newInstance
argument_list|()
operator|.
name|add
argument_list|(
name|primaryFilterName
argument_list|)
operator|.
name|add
argument_list|(
name|fstConf
operator|.
name|asByteArray
argument_list|(
name|primaryFilterValue
argument_list|)
argument_list|,
literal|true
argument_list|)
operator|.
name|add
argument_list|(
name|key
argument_list|)
operator|.
name|getBytes
argument_list|()
return|;
block|}
comment|/**    * Creates an event object from the given key, offset, and value. If the event    * type is not contained in the specified set of event types, returns null.    */
DECL|method|getEntityEvent (Set<String> eventTypes, byte[] key, int offset, byte[] value)
specifier|private
specifier|static
name|TimelineEvent
name|getEntityEvent
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|eventTypes
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|,
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|KeyParser
name|kp
init|=
operator|new
name|KeyParser
argument_list|(
name|key
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|long
name|ts
init|=
name|kp
operator|.
name|getNextLong
argument_list|()
decl_stmt|;
name|String
name|tstype
init|=
name|kp
operator|.
name|getNextString
argument_list|()
decl_stmt|;
if|if
condition|(
name|eventTypes
operator|==
literal|null
operator|||
name|eventTypes
operator|.
name|contains
argument_list|(
name|tstype
argument_list|)
condition|)
block|{
name|TimelineEvent
name|event
init|=
operator|new
name|TimelineEvent
argument_list|()
decl_stmt|;
name|event
operator|.
name|setTimestamp
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|event
operator|.
name|setEventType
argument_list|(
name|tstype
argument_list|)
expr_stmt|;
name|Object
name|o
init|=
name|fstConf
operator|.
name|asObject
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
name|event
operator|.
name|setEventInfo
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|Map
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|m
init|=
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
operator|)
name|o
decl_stmt|;
name|event
operator|.
name|setEventInfo
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Couldn't deserialize event info map"
argument_list|)
throw|;
block|}
return|return
name|event
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Parses the primary filter from the given key at the given offset and adds    * it to the given entity.    */
DECL|method|addPrimaryFilter (TimelineEntity entity, byte[] key, int offset)
specifier|private
specifier|static
name|void
name|addPrimaryFilter
parameter_list|(
name|TimelineEntity
name|entity
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|KeyParser
name|kp
init|=
operator|new
name|KeyParser
argument_list|(
name|key
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|String
name|name
init|=
name|kp
operator|.
name|getNextString
argument_list|()
decl_stmt|;
name|byte
index|[]
name|bytes
init|=
name|kp
operator|.
name|getRemainingBytes
argument_list|()
decl_stmt|;
name|Object
name|value
init|=
name|fstConf
operator|.
name|asObject
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
name|entity
operator|.
name|addPrimaryFilter
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a string representation of the byte array from the given offset to    * the end of the array (for parsing other info keys).    */
DECL|method|parseRemainingKey (byte[] b, int offset)
specifier|private
specifier|static
name|String
name|parseRemainingKey
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
return|return
operator|new
name|String
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|b
operator|.
name|length
operator|-
name|offset
argument_list|,
name|UTF_8
argument_list|)
return|;
block|}
comment|/**    * Creates a related entity key, serializing ENTITY_ENTRY_PREFIX + entity type    * + revstarttime + entity id + RELATED_ENTITIES_COLUMN + relatedentity type +    * relatedentity id.    */
DECL|method|createRelatedEntityKey (String entityId, String entityType, byte[] revStartTime, String relatedEntityId, String relatedEntityType)
specifier|private
specifier|static
name|byte
index|[]
name|createRelatedEntityKey
parameter_list|(
name|String
name|entityId
parameter_list|,
name|String
name|entityType
parameter_list|,
name|byte
index|[]
name|revStartTime
parameter_list|,
name|String
name|relatedEntityId
parameter_list|,
name|String
name|relatedEntityType
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|KeyBuilder
operator|.
name|newInstance
argument_list|()
operator|.
name|add
argument_list|(
name|entityType
argument_list|)
operator|.
name|add
argument_list|(
name|revStartTime
argument_list|)
operator|.
name|add
argument_list|(
name|entityId
argument_list|)
operator|.
name|add
argument_list|(
name|RELATED_ENTITIES_COLUMN
argument_list|)
operator|.
name|add
argument_list|(
name|relatedEntityType
argument_list|)
operator|.
name|add
argument_list|(
name|relatedEntityId
argument_list|)
operator|.
name|getBytes
argument_list|()
return|;
block|}
comment|/**    * Parses the related entity from the given key at the given offset and adds    * it to the given entity.    */
DECL|method|addRelatedEntity (TimelineEntity entity, byte[] key, int offset)
specifier|private
specifier|static
name|void
name|addRelatedEntity
parameter_list|(
name|TimelineEntity
name|entity
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|int
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|KeyParser
name|kp
init|=
operator|new
name|KeyParser
argument_list|(
name|key
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|String
name|type
init|=
name|kp
operator|.
name|getNextString
argument_list|()
decl_stmt|;
name|String
name|id
init|=
name|kp
operator|.
name|getNextString
argument_list|()
decl_stmt|;
name|entity
operator|.
name|addRelatedEntity
argument_list|(
name|type
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a domain id key, serializing ENTITY_ENTRY_PREFIX + entity type +    * revstarttime + entity id + DOMAIN_ID_COLUMN.    */
DECL|method|createDomainIdKey (String entityId, String entityType, byte[] revStartTime)
specifier|private
specifier|static
name|byte
index|[]
name|createDomainIdKey
parameter_list|(
name|String
name|entityId
parameter_list|,
name|String
name|entityType
parameter_list|,
name|byte
index|[]
name|revStartTime
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|KeyBuilder
operator|.
name|newInstance
argument_list|()
operator|.
name|add
argument_list|(
name|entityType
argument_list|)
operator|.
name|add
argument_list|(
name|revStartTime
argument_list|)
operator|.
name|add
argument_list|(
name|entityId
argument_list|)
operator|.
name|add
argument_list|(
name|DOMAIN_ID_COLUMN
argument_list|)
operator|.
name|getBytes
argument_list|()
return|;
block|}
comment|/**    * Clears the cache to test reloading start times from leveldb (only for    * testing).    */
annotation|@
name|VisibleForTesting
DECL|method|clearStartTimeCache ()
name|void
name|clearStartTimeCache
parameter_list|()
block|{
name|startTimeWriteCache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|startTimeReadCache
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getStartTimeReadCacheSize (Configuration conf)
specifier|static
name|int
name|getStartTimeReadCacheSize
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getInt
argument_list|(
name|TIMELINE_SERVICE_LEVELDB_START_TIME_READ_CACHE_SIZE
argument_list|,
name|DEFAULT_TIMELINE_SERVICE_LEVELDB_START_TIME_READ_CACHE_SIZE
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getStartTimeWriteCacheSize (Configuration conf)
specifier|static
name|int
name|getStartTimeWriteCacheSize
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getInt
argument_list|(
name|TIMELINE_SERVICE_LEVELDB_START_TIME_WRITE_CACHE_SIZE
argument_list|,
name|DEFAULT_TIMELINE_SERVICE_LEVELDB_START_TIME_WRITE_CACHE_SIZE
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|evictOldStartTimes (long minStartTime)
name|long
name|evictOldStartTimes
parameter_list|(
name|long
name|minStartTime
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Searching for start times to evict earlier than "
operator|+
name|minStartTime
argument_list|)
expr_stmt|;
name|long
name|batchSize
init|=
literal|0
decl_stmt|;
name|long
name|totalCount
init|=
literal|0
decl_stmt|;
name|long
name|startTimesCount
init|=
literal|0
decl_stmt|;
name|WriteBatch
name|writeBatch
init|=
literal|null
decl_stmt|;
name|ReadOptions
name|readOptions
init|=
operator|new
name|ReadOptions
argument_list|()
decl_stmt|;
name|readOptions
operator|.
name|fillCache
argument_list|(
literal|false
argument_list|)
expr_stmt|;
try|try
init|(
name|DBIterator
name|iterator
init|=
name|starttimedb
operator|.
name|iterator
argument_list|(
name|readOptions
argument_list|)
init|)
block|{
comment|// seek to the first start time entry
name|iterator
operator|.
name|seekToFirst
argument_list|()
expr_stmt|;
name|writeBatch
operator|=
name|starttimedb
operator|.
name|createWriteBatch
argument_list|()
expr_stmt|;
comment|// evaluate each start time entry to see if it needs to be evicted or not
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|byte
index|[]
argument_list|,
name|byte
index|[]
argument_list|>
name|current
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|byte
index|[]
name|entityKey
init|=
name|current
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|byte
index|[]
name|entityValue
init|=
name|current
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|long
name|startTime
init|=
name|readReverseOrderedLong
argument_list|(
name|entityValue
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|startTime
operator|<
name|minStartTime
condition|)
block|{
operator|++
name|batchSize
expr_stmt|;
operator|++
name|startTimesCount
expr_stmt|;
name|writeBatch
operator|.
name|delete
argument_list|(
name|entityKey
argument_list|)
expr_stmt|;
comment|// a large delete will hold the lock for too long
if|if
condition|(
name|batchSize
operator|>=
name|writeBatchSize
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Preparing to delete a batch of "
operator|+
name|batchSize
operator|+
literal|" old start times"
argument_list|)
expr_stmt|;
block|}
name|starttimedb
operator|.
name|write
argument_list|(
name|writeBatch
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Deleted batch of "
operator|+
name|batchSize
operator|+
literal|". Total start times deleted so far this cycle: "
operator|+
name|startTimesCount
argument_list|)
expr_stmt|;
block|}
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|writeBatch
argument_list|)
expr_stmt|;
name|writeBatch
operator|=
name|starttimedb
operator|.
name|createWriteBatch
argument_list|()
expr_stmt|;
name|batchSize
operator|=
literal|0
expr_stmt|;
block|}
block|}
operator|++
name|totalCount
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Preparing to delete a batch of "
operator|+
name|batchSize
operator|+
literal|" old start times"
argument_list|)
expr_stmt|;
block|}
name|starttimedb
operator|.
name|write
argument_list|(
name|writeBatch
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Deleted batch of "
operator|+
name|batchSize
operator|+
literal|". Total start times deleted so far this cycle: "
operator|+
name|startTimesCount
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleted "
operator|+
name|startTimesCount
operator|+
literal|"/"
operator|+
name|totalCount
operator|+
literal|" start time entities earlier than "
operator|+
name|minStartTime
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|writeBatch
argument_list|)
expr_stmt|;
block|}
return|return
name|startTimesCount
return|;
block|}
comment|/**    * Discards entities with start timestamp less than or equal to the given    * timestamp.    */
annotation|@
name|VisibleForTesting
DECL|method|discardOldEntities (long timestamp)
name|void
name|discardOldEntities
parameter_list|(
name|long
name|timestamp
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|long
name|totalCount
init|=
literal|0
decl_stmt|;
name|long
name|t1
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
block|{
name|totalCount
operator|+=
name|evictOldStartTimes
argument_list|(
name|timestamp
argument_list|)
expr_stmt|;
name|indexdb
operator|.
name|evictOldDBs
argument_list|()
expr_stmt|;
name|entitydb
operator|.
name|evictOldDBs
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|long
name|t2
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Discarded "
operator|+
name|totalCount
operator|+
literal|" entities for timestamp "
operator|+
name|timestamp
operator|+
literal|" and earlier in "
operator|+
operator|(
name|t2
operator|-
name|t1
operator|)
operator|/
literal|1000.0
operator|+
literal|" seconds"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|loadVersion ()
name|Version
name|loadVersion
parameter_list|()
throws|throws
name|IOException
block|{
name|byte
index|[]
name|data
init|=
name|starttimedb
operator|.
name|get
argument_list|(
name|bytes
argument_list|(
name|TIMELINE_STORE_VERSION_KEY
argument_list|)
argument_list|)
decl_stmt|;
comment|// if version is not stored previously, treat it as 1.0.
if|if
condition|(
name|data
operator|==
literal|null
operator|||
name|data
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|Version
operator|.
name|newInstance
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|Version
name|version
init|=
operator|new
name|VersionPBImpl
argument_list|(
name|VersionProto
operator|.
name|parseFrom
argument_list|(
name|data
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|version
return|;
block|}
comment|// Only used for test
annotation|@
name|VisibleForTesting
DECL|method|storeVersion (Version state)
name|void
name|storeVersion
parameter_list|(
name|Version
name|state
parameter_list|)
throws|throws
name|IOException
block|{
name|dbStoreVersion
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
DECL|method|dbStoreVersion (Version state)
specifier|private
name|void
name|dbStoreVersion
parameter_list|(
name|Version
name|state
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|key
init|=
name|TIMELINE_STORE_VERSION_KEY
decl_stmt|;
name|byte
index|[]
name|data
init|=
operator|(
operator|(
name|VersionPBImpl
operator|)
name|state
operator|)
operator|.
name|getProto
argument_list|()
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
try|try
block|{
name|starttimedb
operator|.
name|put
argument_list|(
name|bytes
argument_list|(
name|key
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DBException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|getCurrentVersion ()
name|Version
name|getCurrentVersion
parameter_list|()
block|{
return|return
name|CURRENT_VERSION_INFO
return|;
block|}
comment|/**    * 1) Versioning timeline store: major.minor. For e.g. 1.0, 1.1, 1.2...1.25,    * 2.0 etc. 2) Any incompatible change of TS-store is a major upgrade, and any    * compatible change of TS-store is a minor upgrade. 3) Within a minor    * upgrade, say 1.1 to 1.2: overwrite the version info and proceed as normal.    * 4) Within a major upgrade, say 1.2 to 2.0: throw exception and indicate    * user to use a separate upgrade tool to upgrade timeline store or remove    * incompatible old state.    */
DECL|method|checkVersion ()
specifier|private
name|void
name|checkVersion
parameter_list|()
throws|throws
name|IOException
block|{
name|Version
name|loadedVersion
init|=
name|loadVersion
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Loaded timeline store version info "
operator|+
name|loadedVersion
argument_list|)
expr_stmt|;
if|if
condition|(
name|loadedVersion
operator|.
name|equals
argument_list|(
name|getCurrentVersion
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|loadedVersion
operator|.
name|isCompatibleTo
argument_list|(
name|getCurrentVersion
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Storing timeline store version info "
operator|+
name|getCurrentVersion
argument_list|()
argument_list|)
expr_stmt|;
name|dbStoreVersion
argument_list|(
name|CURRENT_VERSION_INFO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|incompatibleMessage
init|=
literal|"Incompatible version for timeline store: "
operator|+
literal|"expecting version "
operator|+
name|getCurrentVersion
argument_list|()
operator|+
literal|", but loading version "
operator|+
name|loadedVersion
decl_stmt|;
name|LOG
operator|.
name|fatal
argument_list|(
name|incompatibleMessage
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|incompatibleMessage
argument_list|)
throw|;
block|}
block|}
comment|// TODO: make data retention work with the domain data as well
annotation|@
name|Override
DECL|method|put (TimelineDomain domain)
specifier|public
name|void
name|put
parameter_list|(
name|TimelineDomain
name|domain
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|WriteBatch
name|domainWriteBatch
init|=
name|domaindb
operator|.
name|createWriteBatch
argument_list|()
init|;
name|WriteBatch
name|ownerWriteBatch
operator|=
name|ownerdb
operator|.
name|createWriteBatch
argument_list|()
init|;
init|)
block|{
if|if
condition|(
name|domain
operator|.
name|getId
argument_list|()
operator|==
literal|null
operator|||
name|domain
operator|.
name|getId
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Domain doesn't have an ID"
argument_list|)
throw|;
block|}
if|if
condition|(
name|domain
operator|.
name|getOwner
argument_list|()
operator|==
literal|null
operator|||
name|domain
operator|.
name|getOwner
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Domain doesn't have an owner."
argument_list|)
throw|;
block|}
comment|// Write description
name|byte
index|[]
name|domainEntryKey
init|=
name|createDomainEntryKey
argument_list|(
name|domain
operator|.
name|getId
argument_list|()
argument_list|,
name|DESCRIPTION_COLUMN
argument_list|)
decl_stmt|;
name|byte
index|[]
name|ownerLookupEntryKey
init|=
name|createOwnerLookupKey
argument_list|(
name|domain
operator|.
name|getOwner
argument_list|()
argument_list|,
name|domain
operator|.
name|getId
argument_list|()
argument_list|,
name|DESCRIPTION_COLUMN
argument_list|)
decl_stmt|;
if|if
condition|(
name|domain
operator|.
name|getDescription
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|domainWriteBatch
operator|.
name|put
argument_list|(
name|domainEntryKey
argument_list|,
name|domain
operator|.
name|getDescription
argument_list|()
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
name|ownerWriteBatch
operator|.
name|put
argument_list|(
name|ownerLookupEntryKey
argument_list|,
name|domain
operator|.
name|getDescription
argument_list|()
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|domainWriteBatch
operator|.
name|put
argument_list|(
name|domainEntryKey
argument_list|,
name|EMPTY_BYTES
argument_list|)
expr_stmt|;
name|ownerWriteBatch
operator|.
name|put
argument_list|(
name|ownerLookupEntryKey
argument_list|,
name|EMPTY_BYTES
argument_list|)
expr_stmt|;
block|}
comment|// Write owner
name|domainEntryKey
operator|=
name|createDomainEntryKey
argument_list|(
name|domain
operator|.
name|getId
argument_list|()
argument_list|,
name|OWNER_COLUMN
argument_list|)
expr_stmt|;
name|ownerLookupEntryKey
operator|=
name|createOwnerLookupKey
argument_list|(
name|domain
operator|.
name|getOwner
argument_list|()
argument_list|,
name|domain
operator|.
name|getId
argument_list|()
argument_list|,
name|OWNER_COLUMN
argument_list|)
expr_stmt|;
comment|// Null check for owner is done before
name|domainWriteBatch
operator|.
name|put
argument_list|(
name|domainEntryKey
argument_list|,
name|domain
operator|.
name|getOwner
argument_list|()
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
name|ownerWriteBatch
operator|.
name|put
argument_list|(
name|ownerLookupEntryKey
argument_list|,
name|domain
operator|.
name|getOwner
argument_list|()
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
comment|// Write readers
name|domainEntryKey
operator|=
name|createDomainEntryKey
argument_list|(
name|domain
operator|.
name|getId
argument_list|()
argument_list|,
name|READER_COLUMN
argument_list|)
expr_stmt|;
name|ownerLookupEntryKey
operator|=
name|createOwnerLookupKey
argument_list|(
name|domain
operator|.
name|getOwner
argument_list|()
argument_list|,
name|domain
operator|.
name|getId
argument_list|()
argument_list|,
name|READER_COLUMN
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
operator|.
name|getReaders
argument_list|()
operator|!=
literal|null
operator|&&
name|domain
operator|.
name|getReaders
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|domainWriteBatch
operator|.
name|put
argument_list|(
name|domainEntryKey
argument_list|,
name|domain
operator|.
name|getReaders
argument_list|()
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
name|ownerWriteBatch
operator|.
name|put
argument_list|(
name|ownerLookupEntryKey
argument_list|,
name|domain
operator|.
name|getReaders
argument_list|()
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|domainWriteBatch
operator|.
name|put
argument_list|(
name|domainEntryKey
argument_list|,
name|EMPTY_BYTES
argument_list|)
expr_stmt|;
name|ownerWriteBatch
operator|.
name|put
argument_list|(
name|ownerLookupEntryKey
argument_list|,
name|EMPTY_BYTES
argument_list|)
expr_stmt|;
block|}
comment|// Write writers
name|domainEntryKey
operator|=
name|createDomainEntryKey
argument_list|(
name|domain
operator|.
name|getId
argument_list|()
argument_list|,
name|WRITER_COLUMN
argument_list|)
expr_stmt|;
name|ownerLookupEntryKey
operator|=
name|createOwnerLookupKey
argument_list|(
name|domain
operator|.
name|getOwner
argument_list|()
argument_list|,
name|domain
operator|.
name|getId
argument_list|()
argument_list|,
name|WRITER_COLUMN
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
operator|.
name|getWriters
argument_list|()
operator|!=
literal|null
operator|&&
name|domain
operator|.
name|getWriters
argument_list|()
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|domainWriteBatch
operator|.
name|put
argument_list|(
name|domainEntryKey
argument_list|,
name|domain
operator|.
name|getWriters
argument_list|()
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
name|ownerWriteBatch
operator|.
name|put
argument_list|(
name|ownerLookupEntryKey
argument_list|,
name|domain
operator|.
name|getWriters
argument_list|()
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|domainWriteBatch
operator|.
name|put
argument_list|(
name|domainEntryKey
argument_list|,
name|EMPTY_BYTES
argument_list|)
expr_stmt|;
name|ownerWriteBatch
operator|.
name|put
argument_list|(
name|ownerLookupEntryKey
argument_list|,
name|EMPTY_BYTES
argument_list|)
expr_stmt|;
block|}
comment|// Write creation time and modification time
comment|// We put both timestamps together because they are always retrieved
comment|// together, and store them in the same way as we did for the entity's
comment|// start time and insert time.
name|domainEntryKey
operator|=
name|createDomainEntryKey
argument_list|(
name|domain
operator|.
name|getId
argument_list|()
argument_list|,
name|TIMESTAMP_COLUMN
argument_list|)
expr_stmt|;
name|ownerLookupEntryKey
operator|=
name|createOwnerLookupKey
argument_list|(
name|domain
operator|.
name|getOwner
argument_list|()
argument_list|,
name|domain
operator|.
name|getId
argument_list|()
argument_list|,
name|TIMESTAMP_COLUMN
argument_list|)
expr_stmt|;
name|long
name|currentTimestamp
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|byte
index|[]
name|timestamps
init|=
name|domaindb
operator|.
name|get
argument_list|(
name|domainEntryKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|timestamps
operator|==
literal|null
condition|)
block|{
name|timestamps
operator|=
operator|new
name|byte
index|[
literal|16
index|]
expr_stmt|;
name|writeReverseOrderedLong
argument_list|(
name|currentTimestamp
argument_list|,
name|timestamps
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writeReverseOrderedLong
argument_list|(
name|currentTimestamp
argument_list|,
name|timestamps
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeReverseOrderedLong
argument_list|(
name|currentTimestamp
argument_list|,
name|timestamps
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
name|domainWriteBatch
operator|.
name|put
argument_list|(
name|domainEntryKey
argument_list|,
name|timestamps
argument_list|)
expr_stmt|;
name|ownerWriteBatch
operator|.
name|put
argument_list|(
name|ownerLookupEntryKey
argument_list|,
name|timestamps
argument_list|)
expr_stmt|;
name|domaindb
operator|.
name|write
argument_list|(
name|domainWriteBatch
argument_list|)
expr_stmt|;
name|ownerdb
operator|.
name|write
argument_list|(
name|ownerWriteBatch
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Creates a domain entity key with column name suffix, of the form    * DOMAIN_ENTRY_PREFIX + domain id + column name.    */
DECL|method|createDomainEntryKey (String domainId, byte[] columnName)
specifier|private
specifier|static
name|byte
index|[]
name|createDomainEntryKey
parameter_list|(
name|String
name|domainId
parameter_list|,
name|byte
index|[]
name|columnName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|KeyBuilder
operator|.
name|newInstance
argument_list|()
operator|.
name|add
argument_list|(
name|domainId
argument_list|)
operator|.
name|add
argument_list|(
name|columnName
argument_list|)
operator|.
name|getBytes
argument_list|()
return|;
block|}
comment|/**    * Creates an owner lookup key with column name suffix, of the form    * OWNER_LOOKUP_PREFIX + owner + domain id + column name.    */
DECL|method|createOwnerLookupKey (String owner, String domainId, byte[] columnName)
specifier|private
specifier|static
name|byte
index|[]
name|createOwnerLookupKey
parameter_list|(
name|String
name|owner
parameter_list|,
name|String
name|domainId
parameter_list|,
name|byte
index|[]
name|columnName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|KeyBuilder
operator|.
name|newInstance
argument_list|()
operator|.
name|add
argument_list|(
name|owner
argument_list|)
operator|.
name|add
argument_list|(
name|domainId
argument_list|)
operator|.
name|add
argument_list|(
name|columnName
argument_list|)
operator|.
name|getBytes
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getDomain (String domainId)
specifier|public
name|TimelineDomain
name|getDomain
parameter_list|(
name|String
name|domainId
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|DBIterator
name|iterator
init|=
name|domaindb
operator|.
name|iterator
argument_list|()
init|)
block|{
name|byte
index|[]
name|prefix
init|=
name|KeyBuilder
operator|.
name|newInstance
argument_list|()
operator|.
name|add
argument_list|(
name|domainId
argument_list|)
operator|.
name|getBytesForLookup
argument_list|()
decl_stmt|;
name|iterator
operator|.
name|seek
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
return|return
name|getTimelineDomain
argument_list|(
name|iterator
argument_list|,
name|domainId
argument_list|,
name|prefix
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|getDomains (String owner)
specifier|public
name|TimelineDomains
name|getDomains
parameter_list|(
name|String
name|owner
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|DBIterator
name|iterator
init|=
name|ownerdb
operator|.
name|iterator
argument_list|()
init|)
block|{
name|byte
index|[]
name|prefix
init|=
name|KeyBuilder
operator|.
name|newInstance
argument_list|()
operator|.
name|add
argument_list|(
name|owner
argument_list|)
operator|.
name|getBytesForLookup
argument_list|()
decl_stmt|;
name|iterator
operator|.
name|seek
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|TimelineDomain
argument_list|>
name|domains
init|=
operator|new
name|ArrayList
argument_list|<
name|TimelineDomain
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|byte
index|[]
name|key
init|=
name|iterator
operator|.
name|peekNext
argument_list|()
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|prefixMatches
argument_list|(
name|prefix
argument_list|,
name|prefix
operator|.
name|length
argument_list|,
name|key
argument_list|)
condition|)
block|{
break|break;
block|}
comment|// Iterator to parse the rows of an individual domain
name|KeyParser
name|kp
init|=
operator|new
name|KeyParser
argument_list|(
name|key
argument_list|,
name|prefix
operator|.
name|length
argument_list|)
decl_stmt|;
name|String
name|domainId
init|=
name|kp
operator|.
name|getNextString
argument_list|()
decl_stmt|;
name|byte
index|[]
name|prefixExt
init|=
name|KeyBuilder
operator|.
name|newInstance
argument_list|()
operator|.
name|add
argument_list|(
name|owner
argument_list|)
operator|.
name|add
argument_list|(
name|domainId
argument_list|)
operator|.
name|getBytesForLookup
argument_list|()
decl_stmt|;
name|TimelineDomain
name|domainToReturn
init|=
name|getTimelineDomain
argument_list|(
name|iterator
argument_list|,
name|domainId
argument_list|,
name|prefixExt
argument_list|)
decl_stmt|;
if|if
condition|(
name|domainToReturn
operator|!=
literal|null
condition|)
block|{
name|domains
operator|.
name|add
argument_list|(
name|domainToReturn
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Sort the domains to return
name|Collections
operator|.
name|sort
argument_list|(
name|domains
argument_list|,
operator|new
name|Comparator
argument_list|<
name|TimelineDomain
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|TimelineDomain
name|domain1
parameter_list|,
name|TimelineDomain
name|domain2
parameter_list|)
block|{
name|int
name|result
init|=
name|domain2
operator|.
name|getCreatedTime
argument_list|()
operator|.
name|compareTo
argument_list|(
name|domain1
operator|.
name|getCreatedTime
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
return|return
name|domain2
operator|.
name|getModifiedTime
argument_list|()
operator|.
name|compareTo
argument_list|(
name|domain1
operator|.
name|getModifiedTime
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|result
return|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
name|TimelineDomains
name|domainsToReturn
init|=
operator|new
name|TimelineDomains
argument_list|()
decl_stmt|;
name|domainsToReturn
operator|.
name|addDomains
argument_list|(
name|domains
argument_list|)
expr_stmt|;
return|return
name|domainsToReturn
return|;
block|}
block|}
DECL|method|getTimelineDomain (DBIterator iterator, String domainId, byte[] prefix)
specifier|private
specifier|static
name|TimelineDomain
name|getTimelineDomain
parameter_list|(
name|DBIterator
name|iterator
parameter_list|,
name|String
name|domainId
parameter_list|,
name|byte
index|[]
name|prefix
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Iterate over all the rows whose key starts with prefix to retrieve the
comment|// domain information.
name|TimelineDomain
name|domain
init|=
operator|new
name|TimelineDomain
argument_list|()
decl_stmt|;
name|domain
operator|.
name|setId
argument_list|(
name|domainId
argument_list|)
expr_stmt|;
name|boolean
name|noRows
init|=
literal|true
decl_stmt|;
for|for
control|(
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
name|iterator
operator|.
name|next
argument_list|()
control|)
block|{
name|byte
index|[]
name|key
init|=
name|iterator
operator|.
name|peekNext
argument_list|()
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|prefixMatches
argument_list|(
name|prefix
argument_list|,
name|prefix
operator|.
name|length
argument_list|,
name|key
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|noRows
condition|)
block|{
name|noRows
operator|=
literal|false
expr_stmt|;
block|}
name|byte
index|[]
name|value
init|=
name|iterator
operator|.
name|peekNext
argument_list|()
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
operator|&&
name|value
operator|.
name|length
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|key
index|[
name|prefix
operator|.
name|length
index|]
operator|==
name|DESCRIPTION_COLUMN
index|[
literal|0
index|]
condition|)
block|{
name|domain
operator|.
name|setDescription
argument_list|(
operator|new
name|String
argument_list|(
name|value
argument_list|,
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
index|[
name|prefix
operator|.
name|length
index|]
operator|==
name|OWNER_COLUMN
index|[
literal|0
index|]
condition|)
block|{
name|domain
operator|.
name|setOwner
argument_list|(
operator|new
name|String
argument_list|(
name|value
argument_list|,
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
index|[
name|prefix
operator|.
name|length
index|]
operator|==
name|READER_COLUMN
index|[
literal|0
index|]
condition|)
block|{
name|domain
operator|.
name|setReaders
argument_list|(
operator|new
name|String
argument_list|(
name|value
argument_list|,
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
index|[
name|prefix
operator|.
name|length
index|]
operator|==
name|WRITER_COLUMN
index|[
literal|0
index|]
condition|)
block|{
name|domain
operator|.
name|setWriters
argument_list|(
operator|new
name|String
argument_list|(
name|value
argument_list|,
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
index|[
name|prefix
operator|.
name|length
index|]
operator|==
name|TIMESTAMP_COLUMN
index|[
literal|0
index|]
condition|)
block|{
name|domain
operator|.
name|setCreatedTime
argument_list|(
name|readReverseOrderedLong
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|domain
operator|.
name|setModifiedTime
argument_list|(
name|readReverseOrderedLong
argument_list|(
name|value
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unrecognized domain column: "
operator|+
name|key
index|[
name|prefix
operator|.
name|length
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|noRows
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|domain
return|;
block|}
block|}
block|}
end_class

end_unit

