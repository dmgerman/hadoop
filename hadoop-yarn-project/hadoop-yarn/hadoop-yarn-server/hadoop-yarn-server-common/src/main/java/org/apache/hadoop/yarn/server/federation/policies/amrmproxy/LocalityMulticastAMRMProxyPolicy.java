begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.federation.policies.amrmproxy
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|federation
operator|.
name|policies
operator|.
name|amrmproxy
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|AllocateResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ResourceRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnRuntimeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|federation
operator|.
name|policies
operator|.
name|FederationPolicyInitializationContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|federation
operator|.
name|policies
operator|.
name|FederationPolicyUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|federation
operator|.
name|policies
operator|.
name|dao
operator|.
name|WeightedPolicyInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|federation
operator|.
name|policies
operator|.
name|exceptions
operator|.
name|FederationPolicyException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|federation
operator|.
name|policies
operator|.
name|exceptions
operator|.
name|FederationPolicyInitializationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|federation
operator|.
name|policies
operator|.
name|exceptions
operator|.
name|NoActiveSubclustersException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|federation
operator|.
name|resolver
operator|.
name|SubClusterResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|records
operator|.
name|SubClusterId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|records
operator|.
name|SubClusterIdInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|federation
operator|.
name|store
operator|.
name|records
operator|.
name|SubClusterInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|federation
operator|.
name|utils
operator|.
name|FederationStateStoreFacade
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_comment
comment|/**  * An implementation of the {@link FederationAMRMProxyPolicy} interface that  * carefully multicasts the requests with the following behavior:  *  *<p>  * Host localized {@link ResourceRequest}s are always forwarded to the RM that  * owns the corresponding node, based on the feedback of a  * {@link SubClusterResolver}. If the {@link SubClusterResolver} cannot resolve  * this node we default to forwarding the {@link ResourceRequest} to the home  * sub-cluster.  *</p>  *  *<p>  * Rack localized {@link ResourceRequest}s are forwarded to the RMs that owns  * the corresponding rack. Note that in some deployments each rack could be  * striped across multiple RMs. Thsi policy respects that. If the  * {@link SubClusterResolver} cannot resolve this rack we default to forwarding  * the {@link ResourceRequest} to the home sub-cluster.  *</p>  *  *<p>  * ANY requests corresponding to node/rack local requests are forwarded only to  * the set of RMs that owns the corresponding localized requests. The number of  * containers listed in each ANY is proportional to the number of localized  * container requests (associated to this ANY via the same allocateRequestId).  *</p>  *  *<p>  * ANY that are not associated to node/rack local requests are split among RMs  * based on the "weights" in the {@link WeightedPolicyInfo} configuration *and*  * headroom information. The {@code headroomAlpha} parameter of the policy  * configuration indicates how much headroom contributes to the splitting  * choice. Value of 1.0f indicates the weights are interpreted only as 0/1  * boolean but all splitting is based on the advertised headroom (fallback to  * 1/N for RMs that we don't have headroom info from). An {@code headroomAlpha}  * value of 0.0f means headroom is ignored and all splitting decisions are  * proportional to the "weights" in the configuration of the policy.  *</p>  *  *<p>  * ANY of zero size are forwarded to all known subclusters (i.e., subclusters  * where we scheduled containers before), as they may represent a user attempt  * to cancel a previous request (and we are mostly stateless now, so should  * forward to all known RMs).  *</p>  *  *<p>  * Invariants:  *</p>  *  *<p>  * The policy always excludes non-active RMs.  *</p>  *  *<p>  * The policy always excludes RMs that do not appear in the policy configuration  * weights, or have a weight of 0 (even if localized resources explicit refer to  * it).  *</p>  *  *<p>  * (Bar rounding to closest ceiling of fractional containers) The sum of  * requests made to multiple RMs at the ANY level "adds-up" to the user request.  * The maximum possible excess in a given request is a number of containers less  * or equal to number of sub-clusters in the federation.  *</p>  */
end_comment

begin_class
DECL|class|LocalityMulticastAMRMProxyPolicy
specifier|public
class|class
name|LocalityMulticastAMRMProxyPolicy
extends|extends
name|AbstractAMRMProxyPolicy
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|LocalityMulticastAMRMProxyPolicy
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|weights
specifier|private
name|Map
argument_list|<
name|SubClusterId
argument_list|,
name|Float
argument_list|>
name|weights
decl_stmt|;
DECL|field|resolver
specifier|private
name|SubClusterResolver
name|resolver
decl_stmt|;
DECL|field|headroom
specifier|private
name|Map
argument_list|<
name|SubClusterId
argument_list|,
name|Resource
argument_list|>
name|headroom
decl_stmt|;
DECL|field|lastHeartbeatTimeStamp
specifier|private
name|Map
argument_list|<
name|SubClusterId
argument_list|,
name|Long
argument_list|>
name|lastHeartbeatTimeStamp
decl_stmt|;
DECL|field|subClusterTimeOut
specifier|private
name|long
name|subClusterTimeOut
decl_stmt|;
DECL|field|hrAlpha
specifier|private
name|float
name|hrAlpha
decl_stmt|;
DECL|field|federationFacade
specifier|private
name|FederationStateStoreFacade
name|federationFacade
decl_stmt|;
DECL|field|bookkeeper
specifier|private
name|AllocationBookkeeper
name|bookkeeper
decl_stmt|;
DECL|field|homeSubcluster
specifier|private
name|SubClusterId
name|homeSubcluster
decl_stmt|;
annotation|@
name|Override
DECL|method|reinitialize ( FederationPolicyInitializationContext policyContext)
specifier|public
name|void
name|reinitialize
parameter_list|(
name|FederationPolicyInitializationContext
name|policyContext
parameter_list|)
throws|throws
name|FederationPolicyInitializationException
block|{
comment|// save reference to old weights
name|WeightedPolicyInfo
name|tempPolicy
init|=
name|getPolicyInfo
argument_list|()
decl_stmt|;
name|super
operator|.
name|reinitialize
argument_list|(
name|policyContext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getIsDirty
argument_list|()
condition|)
block|{
return|return;
block|}
name|Map
argument_list|<
name|SubClusterId
argument_list|,
name|Float
argument_list|>
name|newWeightsConverted
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|boolean
name|allInactive
init|=
literal|true
decl_stmt|;
name|WeightedPolicyInfo
name|policy
init|=
name|getPolicyInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|policy
operator|.
name|getAMRMPolicyWeights
argument_list|()
operator|!=
literal|null
operator|&&
name|policy
operator|.
name|getAMRMPolicyWeights
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|SubClusterIdInfo
argument_list|,
name|Float
argument_list|>
name|e
range|:
name|policy
operator|.
name|getAMRMPolicyWeights
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|>
literal|0
condition|)
block|{
name|allInactive
operator|=
literal|false
expr_stmt|;
block|}
name|newWeightsConverted
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|toId
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|allInactive
condition|)
block|{
comment|// reset the policyInfo and throw
name|setPolicyInfo
argument_list|(
name|tempPolicy
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|FederationPolicyInitializationException
argument_list|(
literal|"The weights used to configure "
operator|+
literal|"this policy are all set to zero! (no ResourceRequest could be "
operator|+
literal|"forwarded with this setting.)"
argument_list|)
throw|;
block|}
if|if
condition|(
name|policyContext
operator|.
name|getHomeSubcluster
argument_list|()
operator|==
literal|null
condition|)
block|{
name|setPolicyInfo
argument_list|(
name|tempPolicy
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|FederationPolicyInitializationException
argument_list|(
literal|"The homeSubcluster "
operator|+
literal|"filed in the context must be initialized to use this policy"
argument_list|)
throw|;
block|}
name|weights
operator|=
name|newWeightsConverted
expr_stmt|;
name|resolver
operator|=
name|policyContext
operator|.
name|getFederationSubclusterResolver
argument_list|()
expr_stmt|;
if|if
condition|(
name|headroom
operator|==
literal|null
condition|)
block|{
name|headroom
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|lastHeartbeatTimeStamp
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|hrAlpha
operator|=
name|policy
operator|.
name|getHeadroomAlpha
argument_list|()
expr_stmt|;
name|this
operator|.
name|federationFacade
operator|=
name|policyContext
operator|.
name|getFederationStateStoreFacade
argument_list|()
expr_stmt|;
name|this
operator|.
name|homeSubcluster
operator|=
name|policyContext
operator|.
name|getHomeSubcluster
argument_list|()
expr_stmt|;
name|this
operator|.
name|subClusterTimeOut
operator|=
name|this
operator|.
name|federationFacade
operator|.
name|getConf
argument_list|()
operator|.
name|getLong
argument_list|(
name|YarnConfiguration
operator|.
name|FEDERATION_AMRMPROXY_SUBCLUSTER_TIMEOUT
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_FEDERATION_AMRMPROXY_SUBCLUSTER_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|subClusterTimeOut
operator|<=
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"{} configured to be {}, should be positive. Using default of {}."
argument_list|,
name|YarnConfiguration
operator|.
name|FEDERATION_AMRMPROXY_SUBCLUSTER_TIMEOUT
argument_list|,
name|this
operator|.
name|subClusterTimeOut
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_FEDERATION_AMRMPROXY_SUBCLUSTER_TIMEOUT
argument_list|)
expr_stmt|;
name|this
operator|.
name|subClusterTimeOut
operator|=
name|YarnConfiguration
operator|.
name|DEFAULT_FEDERATION_AMRMPROXY_SUBCLUSTER_TIMEOUT
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|notifyOfResponse (SubClusterId subClusterId, AllocateResponse response)
specifier|public
name|void
name|notifyOfResponse
parameter_list|(
name|SubClusterId
name|subClusterId
parameter_list|,
name|AllocateResponse
name|response
parameter_list|)
throws|throws
name|YarnException
block|{
if|if
condition|(
name|response
operator|.
name|getAvailableResources
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|headroom
operator|.
name|put
argument_list|(
name|subClusterId
argument_list|,
name|response
operator|.
name|getAvailableResources
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Subcluster {} updated with {} memory headroom"
argument_list|,
name|subClusterId
argument_list|,
name|response
operator|.
name|getAvailableResources
argument_list|()
operator|.
name|getMemorySize
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|lastHeartbeatTimeStamp
operator|.
name|put
argument_list|(
name|subClusterId
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|splitResourceRequests ( List<ResourceRequest> resourceRequests)
specifier|public
name|Map
argument_list|<
name|SubClusterId
argument_list|,
name|List
argument_list|<
name|ResourceRequest
argument_list|>
argument_list|>
name|splitResourceRequests
parameter_list|(
name|List
argument_list|<
name|ResourceRequest
argument_list|>
name|resourceRequests
parameter_list|)
throws|throws
name|YarnException
block|{
comment|// object used to accumulate statistics about the answer, initialize with
comment|// active subclusters. Create a new instance per call because this method
comment|// can be called concurrently.
name|bookkeeper
operator|=
operator|new
name|AllocationBookkeeper
argument_list|()
expr_stmt|;
name|bookkeeper
operator|.
name|reinitialize
argument_list|(
name|federationFacade
operator|.
name|getSubClusters
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ResourceRequest
argument_list|>
name|nonLocalizedRequests
init|=
operator|new
name|ArrayList
argument_list|<
name|ResourceRequest
argument_list|>
argument_list|()
decl_stmt|;
name|SubClusterId
name|targetId
init|=
literal|null
decl_stmt|;
name|Set
argument_list|<
name|SubClusterId
argument_list|>
name|targetIds
init|=
literal|null
decl_stmt|;
comment|// if the RR is resolved to a local subcluster add it directly (node and
comment|// resolvable racks)
for|for
control|(
name|ResourceRequest
name|rr
range|:
name|resourceRequests
control|)
block|{
name|targetId
operator|=
literal|null
expr_stmt|;
name|targetIds
operator|=
literal|null
expr_stmt|;
comment|// Handle: ANY (accumulated for later)
if|if
condition|(
name|ResourceRequest
operator|.
name|isAnyLocation
argument_list|(
name|rr
operator|.
name|getResourceName
argument_list|()
argument_list|)
condition|)
block|{
name|nonLocalizedRequests
operator|.
name|add
argument_list|(
name|rr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// Handle "node" requests
try|try
block|{
name|targetId
operator|=
name|resolver
operator|.
name|getSubClusterForNode
argument_list|(
name|rr
operator|.
name|getResourceName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|YarnException
name|e
parameter_list|)
block|{
comment|// this might happen as we can't differentiate node from rack names
comment|// we log altogether later
block|}
if|if
condition|(
name|bookkeeper
operator|.
name|isActiveAndEnabled
argument_list|(
name|targetId
argument_list|)
condition|)
block|{
name|bookkeeper
operator|.
name|addLocalizedNodeRR
argument_list|(
name|targetId
argument_list|,
name|rr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// Handle "rack" requests
try|try
block|{
name|targetIds
operator|=
name|resolver
operator|.
name|getSubClustersForRack
argument_list|(
name|rr
operator|.
name|getResourceName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|YarnException
name|e
parameter_list|)
block|{
comment|// this might happen as we can't differentiate node from rack names
comment|// we log altogether later
block|}
if|if
condition|(
name|targetIds
operator|!=
literal|null
operator|&&
name|targetIds
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|boolean
name|hasActive
init|=
literal|false
decl_stmt|;
for|for
control|(
name|SubClusterId
name|tid
range|:
name|targetIds
control|)
block|{
if|if
condition|(
name|bookkeeper
operator|.
name|isActiveAndEnabled
argument_list|(
name|tid
argument_list|)
condition|)
block|{
name|bookkeeper
operator|.
name|addRackRR
argument_list|(
name|tid
argument_list|,
name|rr
argument_list|)
expr_stmt|;
name|hasActive
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hasActive
condition|)
block|{
continue|continue;
block|}
block|}
comment|// Handle node/rack requests that the SubClusterResolver cannot map to
comment|// any cluster. Defaulting to home subcluster.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ERROR resolving sub-cluster for resourceName: "
operator|+
name|rr
operator|.
name|getResourceName
argument_list|()
operator|+
literal|" we are falling back to homeSubCluster:"
operator|+
name|homeSubcluster
argument_list|)
expr_stmt|;
block|}
comment|// If home-subcluster is not active, ignore node/rack request
if|if
condition|(
name|bookkeeper
operator|.
name|isActiveAndEnabled
argument_list|(
name|homeSubcluster
argument_list|)
condition|)
block|{
if|if
condition|(
name|targetIds
operator|!=
literal|null
operator|&&
name|targetIds
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|bookkeeper
operator|.
name|addRackRR
argument_list|(
name|homeSubcluster
argument_list|,
name|rr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bookkeeper
operator|.
name|addLocalizedNodeRR
argument_list|(
name|homeSubcluster
argument_list|,
name|rr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The homeSubCluster ("
operator|+
name|homeSubcluster
operator|+
literal|") we are "
operator|+
literal|"defaulting to is not active, the ResourceRequest "
operator|+
literal|"will be ignored."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// handle all non-localized requests (ANY)
name|splitAnyRequests
argument_list|(
name|nonLocalizedRequests
argument_list|,
name|bookkeeper
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|SubClusterId
argument_list|,
name|List
argument_list|<
name|ResourceRequest
argument_list|>
argument_list|>
name|entry
range|:
name|bookkeeper
operator|.
name|getAnswer
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// A new-cluster here will trigger new UAM luanch, which might take a long
comment|// time. We don't want too many requests stuck in this UAM before it is
comment|// ready and starts heartbeating
if|if
condition|(
operator|!
name|lastHeartbeatTimeStamp
operator|.
name|containsKey
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|lastHeartbeatTimeStamp
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|bookkeeper
operator|.
name|getAnswer
argument_list|()
return|;
block|}
comment|/**    * It splits a list of non-localized resource requests among sub-clusters.    */
DECL|method|splitAnyRequests (List<ResourceRequest> originalResourceRequests, AllocationBookkeeper allocationBookkeeper)
specifier|private
name|void
name|splitAnyRequests
parameter_list|(
name|List
argument_list|<
name|ResourceRequest
argument_list|>
name|originalResourceRequests
parameter_list|,
name|AllocationBookkeeper
name|allocationBookkeeper
parameter_list|)
throws|throws
name|YarnException
block|{
for|for
control|(
name|ResourceRequest
name|resourceRequest
range|:
name|originalResourceRequests
control|)
block|{
comment|// FIRST: pick the target set of subclusters (based on whether this RR
comment|// is associated with other localized requests via an allocationId)
name|Long
name|allocationId
init|=
name|resourceRequest
operator|.
name|getAllocationRequestId
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|SubClusterId
argument_list|>
name|targetSubclusters
decl_stmt|;
if|if
condition|(
name|allocationBookkeeper
operator|.
name|getSubClustersForId
argument_list|(
name|allocationId
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|targetSubclusters
operator|=
name|allocationBookkeeper
operator|.
name|getSubClustersForId
argument_list|(
name|allocationId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|targetSubclusters
operator|=
name|allocationBookkeeper
operator|.
name|getActiveAndEnabledSC
argument_list|()
expr_stmt|;
block|}
comment|// SECOND: pick how much to ask to each RM for each request
name|splitIndividualAny
argument_list|(
name|resourceRequest
argument_list|,
name|targetSubclusters
argument_list|,
name|allocationBookkeeper
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Return a projection of this ANY {@link ResourceRequest} that belongs to    * this sub-cluster. This is done based on the "count" of the containers that    * require locality in each sublcuster (if any) or based on the "weights" and    * headroom.    */
DECL|method|splitIndividualAny (ResourceRequest originalResourceRequest, Set<SubClusterId> targetSubclusters, AllocationBookkeeper allocationBookkeeper)
specifier|private
name|void
name|splitIndividualAny
parameter_list|(
name|ResourceRequest
name|originalResourceRequest
parameter_list|,
name|Set
argument_list|<
name|SubClusterId
argument_list|>
name|targetSubclusters
parameter_list|,
name|AllocationBookkeeper
name|allocationBookkeeper
parameter_list|)
throws|throws
name|YarnException
block|{
name|long
name|allocationId
init|=
name|originalResourceRequest
operator|.
name|getAllocationRequestId
argument_list|()
decl_stmt|;
name|int
name|numContainer
init|=
name|originalResourceRequest
operator|.
name|getNumContainers
argument_list|()
decl_stmt|;
comment|// If the ANY request has 0 containers to begin with we must forward it to
comment|// any RM we have previously contacted (this might be the user way
comment|// to cancel a previous request).
if|if
condition|(
name|numContainer
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|SubClusterId
name|targetId
range|:
name|headroom
operator|.
name|keySet
argument_list|()
control|)
block|{
name|allocationBookkeeper
operator|.
name|addAnyRR
argument_list|(
name|targetId
argument_list|,
name|originalResourceRequest
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// List preserves iteration order
name|List
argument_list|<
name|SubClusterId
argument_list|>
name|targetSCs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|targetSubclusters
argument_list|)
decl_stmt|;
comment|// Compute the distribution weights
name|ArrayList
argument_list|<
name|Float
argument_list|>
name|weightsList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SubClusterId
name|targetId
range|:
name|targetSCs
control|)
block|{
comment|// If ANY is associated with localized asks, split based on their ratio
if|if
condition|(
name|allocationBookkeeper
operator|.
name|getSubClustersForId
argument_list|(
name|allocationId
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|weightsList
operator|.
name|add
argument_list|(
name|getLocalityBasedWeighting
argument_list|(
name|allocationId
argument_list|,
name|targetId
argument_list|,
name|allocationBookkeeper
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// split ANY based on load and policy configuration
name|float
name|headroomWeighting
init|=
name|getHeadroomWeighting
argument_list|(
name|targetId
argument_list|,
name|allocationBookkeeper
argument_list|)
decl_stmt|;
name|float
name|policyWeighting
init|=
name|getPolicyConfigWeighting
argument_list|(
name|targetId
argument_list|,
name|allocationBookkeeper
argument_list|)
decl_stmt|;
comment|// hrAlpha controls how much headroom influencing decision
name|weightsList
operator|.
name|add
argument_list|(
name|hrAlpha
operator|*
name|headroomWeighting
operator|+
operator|(
literal|1
operator|-
name|hrAlpha
operator|)
operator|*
name|policyWeighting
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Compute the integer container counts for each sub-cluster
name|ArrayList
argument_list|<
name|Integer
argument_list|>
name|containerNums
init|=
name|computeIntegerAssignment
argument_list|(
name|numContainer
argument_list|,
name|weightsList
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|SubClusterId
name|targetId
range|:
name|targetSCs
control|)
block|{
comment|// if the calculated request is non-empty add it to the answer
if|if
condition|(
name|containerNums
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|>
literal|0
condition|)
block|{
name|ResourceRequest
name|out
init|=
name|ResourceRequest
operator|.
name|clone
argument_list|(
name|originalResourceRequest
argument_list|)
decl_stmt|;
name|out
operator|.
name|setNumContainers
argument_list|(
name|containerNums
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ResourceRequest
operator|.
name|isAnyLocation
argument_list|(
name|out
operator|.
name|getResourceName
argument_list|()
argument_list|)
condition|)
block|{
name|allocationBookkeeper
operator|.
name|addAnyRR
argument_list|(
name|targetId
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allocationBookkeeper
operator|.
name|addRackRR
argument_list|(
name|targetId
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
comment|/**    * Split the integer into bins according to the weights.    *    * @param totalNum total number of containers to split    * @param weightsList the weights for each subcluster    * @return the container allocation after split    * @throws YarnException if fails    */
annotation|@
name|VisibleForTesting
DECL|method|computeIntegerAssignment (int totalNum, ArrayList<Float> weightsList)
specifier|protected
name|ArrayList
argument_list|<
name|Integer
argument_list|>
name|computeIntegerAssignment
parameter_list|(
name|int
name|totalNum
parameter_list|,
name|ArrayList
argument_list|<
name|Float
argument_list|>
name|weightsList
parameter_list|)
throws|throws
name|YarnException
block|{
name|int
name|i
decl_stmt|,
name|residue
decl_stmt|;
name|ArrayList
argument_list|<
name|Integer
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|float
name|totalWeight
init|=
literal|0
decl_stmt|,
name|totalNumFloat
init|=
name|totalNum
decl_stmt|;
if|if
condition|(
name|weightsList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|weightsList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|.
name|add
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|weightsList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|>
literal|0
condition|)
block|{
name|totalWeight
operator|+=
name|weightsList
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|totalWeight
operator|==
literal|0
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Float
name|weight
range|:
name|weightsList
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|weight
operator|+
literal|", "
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|FederationPolicyException
argument_list|(
literal|"No positive value found in weight array "
operator|+
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
comment|// First pass, do flooring for all bins
name|residue
operator|=
name|totalNum
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|weightsList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|weightsList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|>
literal|0
condition|)
block|{
name|int
name|base
init|=
call|(
name|int
call|)
argument_list|(
name|totalNumFloat
operator|*
name|weightsList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|/
name|totalWeight
argument_list|)
decl_stmt|;
name|ret
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|ret
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|+
name|base
argument_list|)
expr_stmt|;
name|residue
operator|-=
name|base
expr_stmt|;
block|}
block|}
comment|// By now residue< weights.length, assign one a time
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|residue
condition|;
name|i
operator|++
control|)
block|{
name|int
name|index
init|=
name|FederationPolicyUtils
operator|.
name|getWeightedRandom
argument_list|(
name|weightsList
argument_list|)
decl_stmt|;
name|ret
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|ret
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Compute the weight to assign to a subcluster based on how many local    * requests a subcluster is target of.    */
DECL|method|getLocalityBasedWeighting (long reqId, SubClusterId targetId, AllocationBookkeeper allocationBookkeeper)
specifier|private
name|float
name|getLocalityBasedWeighting
parameter_list|(
name|long
name|reqId
parameter_list|,
name|SubClusterId
name|targetId
parameter_list|,
name|AllocationBookkeeper
name|allocationBookkeeper
parameter_list|)
block|{
name|float
name|totWeight
init|=
name|allocationBookkeeper
operator|.
name|getTotNumLocalizedContainers
argument_list|(
name|reqId
argument_list|)
decl_stmt|;
name|float
name|localWeight
init|=
name|allocationBookkeeper
operator|.
name|getNumLocalizedContainers
argument_list|(
name|reqId
argument_list|,
name|targetId
argument_list|)
decl_stmt|;
return|return
name|totWeight
operator|>
literal|0
condition|?
name|localWeight
operator|/
name|totWeight
else|:
literal|0
return|;
block|}
comment|/**    * Compute the "weighting" to give to a sublcuster based on the configured    * policy weights (for the active subclusters).    */
DECL|method|getPolicyConfigWeighting (SubClusterId targetId, AllocationBookkeeper allocationBookkeeper)
specifier|private
name|float
name|getPolicyConfigWeighting
parameter_list|(
name|SubClusterId
name|targetId
parameter_list|,
name|AllocationBookkeeper
name|allocationBookkeeper
parameter_list|)
block|{
name|float
name|totWeight
init|=
name|allocationBookkeeper
operator|.
name|totPolicyWeight
decl_stmt|;
name|Float
name|localWeight
init|=
name|allocationBookkeeper
operator|.
name|policyWeights
operator|.
name|get
argument_list|(
name|targetId
argument_list|)
decl_stmt|;
return|return
operator|(
name|localWeight
operator|!=
literal|null
operator|&&
name|totWeight
operator|>
literal|0
operator|)
condition|?
name|localWeight
operator|/
name|totWeight
else|:
literal|0
return|;
block|}
comment|/**    * Compute the weighting based on available headroom. This is proportional to    * the available headroom memory announced by RM, or to 1/N for RMs we have    * not seen yet. If all RMs report zero headroom, we fallback to 1/N again.    */
DECL|method|getHeadroomWeighting (SubClusterId targetId, AllocationBookkeeper allocationBookkeeper)
specifier|private
name|float
name|getHeadroomWeighting
parameter_list|(
name|SubClusterId
name|targetId
parameter_list|,
name|AllocationBookkeeper
name|allocationBookkeeper
parameter_list|)
block|{
comment|// baseline weight for all RMs
name|float
name|headroomWeighting
init|=
literal|1
operator|/
operator|(
name|float
operator|)
name|allocationBookkeeper
operator|.
name|getActiveAndEnabledSC
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// if we have headroom infomration for this sub-cluster (and we are safe
comment|// from /0 issues)
if|if
condition|(
name|headroom
operator|.
name|containsKey
argument_list|(
name|targetId
argument_list|)
operator|&&
name|allocationBookkeeper
operator|.
name|totHeadroomMemory
operator|>
literal|0
condition|)
block|{
comment|// compute which portion of the RMs that are active/enabled have reported
comment|// their headroom (needed as adjustment factor)
comment|// (note: getActiveAndEnabledSC should never be null/zero)
name|float
name|ratioHeadroomKnown
init|=
name|allocationBookkeeper
operator|.
name|totHeadRoomEnabledRMs
operator|/
operator|(
name|float
operator|)
name|allocationBookkeeper
operator|.
name|getActiveAndEnabledSC
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// headroomWeighting is the ratio of headroom memory in the targetId
comment|// cluster / total memory. The ratioHeadroomKnown factor is applied to
comment|// adjust for missing information and ensure sum of allocated containers
comment|// closely approximate what the user asked (small excess).
name|headroomWeighting
operator|=
operator|(
name|headroom
operator|.
name|get
argument_list|(
name|targetId
argument_list|)
operator|.
name|getMemorySize
argument_list|()
operator|/
name|allocationBookkeeper
operator|.
name|totHeadroomMemory
operator|)
operator|*
operator|(
name|ratioHeadroomKnown
operator|)
expr_stmt|;
block|}
return|return
name|headroomWeighting
return|;
block|}
comment|/**    * This helper class is used to book-keep the requests made to each    * subcluster, and maintain useful statistics to split ANY requests.    */
DECL|class|AllocationBookkeeper
specifier|private
specifier|final
class|class
name|AllocationBookkeeper
block|{
comment|// the answer being accumulated
DECL|field|answer
specifier|private
name|Map
argument_list|<
name|SubClusterId
argument_list|,
name|List
argument_list|<
name|ResourceRequest
argument_list|>
argument_list|>
name|answer
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// stores how many containers we have allocated in each RM for localized
comment|// asks, used to correctly "spread" the corresponding ANY
DECL|field|countContainersPerRM
specifier|private
name|Map
argument_list|<
name|Long
argument_list|,
name|Map
argument_list|<
name|SubClusterId
argument_list|,
name|AtomicLong
argument_list|>
argument_list|>
name|countContainersPerRM
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|totNumLocalizedContainers
specifier|private
name|Map
argument_list|<
name|Long
argument_list|,
name|AtomicLong
argument_list|>
name|totNumLocalizedContainers
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|activeAndEnabledSC
specifier|private
name|Set
argument_list|<
name|SubClusterId
argument_list|>
name|activeAndEnabledSC
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|totHeadroomMemory
specifier|private
name|float
name|totHeadroomMemory
init|=
literal|0
decl_stmt|;
DECL|field|totHeadRoomEnabledRMs
specifier|private
name|int
name|totHeadRoomEnabledRMs
init|=
literal|0
decl_stmt|;
DECL|field|policyWeights
specifier|private
name|Map
argument_list|<
name|SubClusterId
argument_list|,
name|Float
argument_list|>
name|policyWeights
decl_stmt|;
DECL|field|totPolicyWeight
specifier|private
name|float
name|totPolicyWeight
init|=
literal|0
decl_stmt|;
DECL|method|reinitialize ( Map<SubClusterId, SubClusterInfo> activeSubclusters)
specifier|private
name|void
name|reinitialize
parameter_list|(
name|Map
argument_list|<
name|SubClusterId
argument_list|,
name|SubClusterInfo
argument_list|>
name|activeSubclusters
parameter_list|)
throws|throws
name|YarnException
block|{
if|if
condition|(
name|activeSubclusters
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|YarnRuntimeException
argument_list|(
literal|"null activeSubclusters received"
argument_list|)
throw|;
block|}
comment|// reset data structures
name|answer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|countContainersPerRM
operator|.
name|clear
argument_list|()
expr_stmt|;
name|totNumLocalizedContainers
operator|.
name|clear
argument_list|()
expr_stmt|;
name|activeAndEnabledSC
operator|.
name|clear
argument_list|()
expr_stmt|;
name|totHeadroomMemory
operator|=
literal|0
expr_stmt|;
name|totHeadRoomEnabledRMs
operator|=
literal|0
expr_stmt|;
comment|// save the reference locally in case the weights get reinitialized
comment|// concurrently
name|policyWeights
operator|=
name|weights
expr_stmt|;
name|totPolicyWeight
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|SubClusterId
argument_list|,
name|Float
argument_list|>
name|entry
range|:
name|policyWeights
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|>
literal|0
operator|&&
name|activeSubclusters
operator|.
name|containsKey
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|activeAndEnabledSC
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|activeAndEnabledSC
operator|.
name|size
argument_list|()
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|NoActiveSubclustersException
argument_list|(
literal|"None of the subclusters enabled in this policy (weight>0) are "
operator|+
literal|"currently active we cannot forward the ResourceRequest(s)"
argument_list|)
throw|;
block|}
name|Set
argument_list|<
name|SubClusterId
argument_list|>
name|tmpSCSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|activeAndEnabledSC
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|SubClusterId
argument_list|,
name|Long
argument_list|>
name|entry
range|:
name|lastHeartbeatTimeStamp
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|long
name|duration
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|duration
operator|>
name|subClusterTimeOut
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Subcluster {} does not have a success heartbeat for {}s, "
operator|+
literal|"skip routing asks there for this request"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
operator|(
name|double
operator|)
name|duration
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|tmpSCSet
operator|.
name|remove
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tmpSCSet
operator|.
name|size
argument_list|()
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"All active and enabled subclusters have expired last "
operator|+
literal|"heartbeat time. Ignore the expiry check for this request"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|activeAndEnabledSC
operator|=
name|tmpSCSet
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"{} subcluster active, {} subclusters active and enabled"
argument_list|,
name|activeSubclusters
operator|.
name|size
argument_list|()
argument_list|,
name|activeAndEnabledSC
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// pre-compute the set of subclusters that are both active and enabled by
comment|// the policy weights, and accumulate their total weight
for|for
control|(
name|SubClusterId
name|sc
range|:
name|activeAndEnabledSC
control|)
block|{
name|totPolicyWeight
operator|+=
name|policyWeights
operator|.
name|get
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|// pre-compute headroom-based weights for active/enabled subclusters
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|SubClusterId
argument_list|,
name|Resource
argument_list|>
name|r
range|:
name|headroom
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|activeAndEnabledSC
operator|.
name|contains
argument_list|(
name|r
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|totHeadroomMemory
operator|+=
name|r
operator|.
name|getValue
argument_list|()
operator|.
name|getMemorySize
argument_list|()
expr_stmt|;
name|totHeadRoomEnabledRMs
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Add to the answer a localized node request, and keeps track of statistics      * on a per-allocation-id and per-subcluster bases.      */
DECL|method|addLocalizedNodeRR (SubClusterId targetId, ResourceRequest rr)
specifier|private
name|void
name|addLocalizedNodeRR
parameter_list|(
name|SubClusterId
name|targetId
parameter_list|,
name|ResourceRequest
name|rr
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|!
name|ResourceRequest
operator|.
name|isAnyLocation
argument_list|(
name|rr
operator|.
name|getResourceName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rr
operator|.
name|getNumContainers
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|countContainersPerRM
operator|.
name|containsKey
argument_list|(
name|rr
operator|.
name|getAllocationRequestId
argument_list|()
argument_list|)
condition|)
block|{
name|countContainersPerRM
operator|.
name|put
argument_list|(
name|rr
operator|.
name|getAllocationRequestId
argument_list|()
argument_list|,
operator|new
name|HashMap
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|countContainersPerRM
operator|.
name|get
argument_list|(
name|rr
operator|.
name|getAllocationRequestId
argument_list|()
argument_list|)
operator|.
name|containsKey
argument_list|(
name|targetId
argument_list|)
condition|)
block|{
name|countContainersPerRM
operator|.
name|get
argument_list|(
name|rr
operator|.
name|getAllocationRequestId
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
name|targetId
argument_list|,
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|countContainersPerRM
operator|.
name|get
argument_list|(
name|rr
operator|.
name|getAllocationRequestId
argument_list|()
argument_list|)
operator|.
name|get
argument_list|(
name|targetId
argument_list|)
operator|.
name|addAndGet
argument_list|(
name|rr
operator|.
name|getNumContainers
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|totNumLocalizedContainers
operator|.
name|containsKey
argument_list|(
name|rr
operator|.
name|getAllocationRequestId
argument_list|()
argument_list|)
condition|)
block|{
name|totNumLocalizedContainers
operator|.
name|put
argument_list|(
name|rr
operator|.
name|getAllocationRequestId
argument_list|()
argument_list|,
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|totNumLocalizedContainers
operator|.
name|get
argument_list|(
name|rr
operator|.
name|getAllocationRequestId
argument_list|()
argument_list|)
operator|.
name|addAndGet
argument_list|(
name|rr
operator|.
name|getNumContainers
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|internalAddToAnswer
argument_list|(
name|targetId
argument_list|,
name|rr
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add a rack-local request to the final asnwer.      */
DECL|method|addRackRR (SubClusterId targetId, ResourceRequest rr)
specifier|public
name|void
name|addRackRR
parameter_list|(
name|SubClusterId
name|targetId
parameter_list|,
name|ResourceRequest
name|rr
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|!
name|ResourceRequest
operator|.
name|isAnyLocation
argument_list|(
name|rr
operator|.
name|getResourceName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|internalAddToAnswer
argument_list|(
name|targetId
argument_list|,
name|rr
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add an ANY request to the final answer.      */
DECL|method|addAnyRR (SubClusterId targetId, ResourceRequest rr)
specifier|private
name|void
name|addAnyRR
parameter_list|(
name|SubClusterId
name|targetId
parameter_list|,
name|ResourceRequest
name|rr
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|ResourceRequest
operator|.
name|isAnyLocation
argument_list|(
name|rr
operator|.
name|getResourceName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|internalAddToAnswer
argument_list|(
name|targetId
argument_list|,
name|rr
argument_list|)
expr_stmt|;
block|}
DECL|method|internalAddToAnswer (SubClusterId targetId, ResourceRequest partialRR)
specifier|private
name|void
name|internalAddToAnswer
parameter_list|(
name|SubClusterId
name|targetId
parameter_list|,
name|ResourceRequest
name|partialRR
parameter_list|)
block|{
if|if
condition|(
operator|!
name|answer
operator|.
name|containsKey
argument_list|(
name|targetId
argument_list|)
condition|)
block|{
name|answer
operator|.
name|put
argument_list|(
name|targetId
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|ResourceRequest
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|answer
operator|.
name|get
argument_list|(
name|targetId
argument_list|)
operator|.
name|add
argument_list|(
name|partialRR
argument_list|)
expr_stmt|;
block|}
comment|/**      * Return all known subclusters associated with an allocation id.      *      * @param allocationId the allocation id considered      *      * @return the list of {@link SubClusterId}s associated with this allocation      *         id      */
DECL|method|getSubClustersForId (long allocationId)
specifier|private
name|Set
argument_list|<
name|SubClusterId
argument_list|>
name|getSubClustersForId
parameter_list|(
name|long
name|allocationId
parameter_list|)
block|{
if|if
condition|(
name|countContainersPerRM
operator|.
name|get
argument_list|(
name|allocationId
argument_list|)
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|countContainersPerRM
operator|.
name|get
argument_list|(
name|allocationId
argument_list|)
operator|.
name|keySet
argument_list|()
return|;
block|}
comment|/**      * Return the answer accumulated so far.      *      * @return the answer      */
DECL|method|getAnswer ()
specifier|private
name|Map
argument_list|<
name|SubClusterId
argument_list|,
name|List
argument_list|<
name|ResourceRequest
argument_list|>
argument_list|>
name|getAnswer
parameter_list|()
block|{
return|return
name|answer
return|;
block|}
comment|/**      * Return the set of sub-clusters that are both active and allowed by our      * policy (weight> 0).      *      * @return a set of active and enabled {@link SubClusterId}s      */
DECL|method|getActiveAndEnabledSC ()
specifier|private
name|Set
argument_list|<
name|SubClusterId
argument_list|>
name|getActiveAndEnabledSC
parameter_list|()
block|{
return|return
name|activeAndEnabledSC
return|;
block|}
comment|/**      * Return the total number of container coming from localized requests      * matching an allocation Id.      */
DECL|method|getTotNumLocalizedContainers (long allocationId)
specifier|private
name|long
name|getTotNumLocalizedContainers
parameter_list|(
name|long
name|allocationId
parameter_list|)
block|{
name|AtomicLong
name|c
init|=
name|totNumLocalizedContainers
operator|.
name|get
argument_list|(
name|allocationId
argument_list|)
decl_stmt|;
return|return
name|c
operator|==
literal|null
condition|?
literal|0
else|:
name|c
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**      * Returns the number of containers matching an allocation Id that are      * localized in the targetId subcluster.      */
DECL|method|getNumLocalizedContainers (long allocationId, SubClusterId targetId)
specifier|private
name|long
name|getNumLocalizedContainers
parameter_list|(
name|long
name|allocationId
parameter_list|,
name|SubClusterId
name|targetId
parameter_list|)
block|{
name|AtomicLong
name|c
init|=
name|countContainersPerRM
operator|.
name|get
argument_list|(
name|allocationId
argument_list|)
operator|.
name|get
argument_list|(
name|targetId
argument_list|)
decl_stmt|;
return|return
name|c
operator|==
literal|null
condition|?
literal|0
else|:
name|c
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**      * Returns true is the subcluster request is both active and enabled.      */
DECL|method|isActiveAndEnabled (SubClusterId targetId)
specifier|private
name|boolean
name|isActiveAndEnabled
parameter_list|(
name|SubClusterId
name|targetId
parameter_list|)
block|{
if|if
condition|(
name|targetId
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|getActiveAndEnabledSC
argument_list|()
operator|.
name|contains
argument_list|(
name|targetId
argument_list|)
return|;
block|}
block|}
block|}
block|}
end_class

end_unit

