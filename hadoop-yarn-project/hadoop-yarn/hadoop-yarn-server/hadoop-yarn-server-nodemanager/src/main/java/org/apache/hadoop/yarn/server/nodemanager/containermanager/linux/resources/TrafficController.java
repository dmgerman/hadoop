begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * *  *  Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements. See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership. The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License. You may obtain a copy of the License at  *  *  http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  * /  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.nodemanager.containermanager.linux.resources
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|linux
operator|.
name|resources
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|linux
operator|.
name|privileged
operator|.
name|PrivilegedOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|linux
operator|.
name|privileged
operator|.
name|PrivilegedOperationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|linux
operator|.
name|privileged
operator|.
name|PrivilegedOperationExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_comment
comment|/**  * Wrapper around the 'tc' tool. Provides access to a very specific subset of  * the functionality provided by the tc tool.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|TrafficController
annotation|@
name|InterfaceStability
operator|.
name|Unstable
class|class
name|TrafficController
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TrafficController
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|ROOT_QDISC_HANDLE
specifier|private
specifier|static
specifier|final
name|int
name|ROOT_QDISC_HANDLE
init|=
literal|42
decl_stmt|;
DECL|field|ZERO_CLASS_ID
specifier|private
specifier|static
specifier|final
name|int
name|ZERO_CLASS_ID
init|=
literal|0
decl_stmt|;
DECL|field|ROOT_CLASS_ID
specifier|private
specifier|static
specifier|final
name|int
name|ROOT_CLASS_ID
init|=
literal|1
decl_stmt|;
comment|/** Traffic shaping class used for all unclassified traffic */
DECL|field|DEFAULT_CLASS_ID
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_CLASS_ID
init|=
literal|2
decl_stmt|;
comment|/** Traffic shaping class used for all YARN traffic */
DECL|field|YARN_ROOT_CLASS_ID
specifier|private
specifier|static
specifier|final
name|int
name|YARN_ROOT_CLASS_ID
init|=
literal|3
decl_stmt|;
comment|/** Classes 0-3 are used already. We need to ensure that container classes    * do not collide with these classids.    */
DECL|field|MIN_CONTAINER_CLASS_ID
specifier|private
specifier|static
specifier|final
name|int
name|MIN_CONTAINER_CLASS_ID
init|=
literal|4
decl_stmt|;
comment|/** This is the number of distinct (container) traffic shaping classes    * that are supported */
DECL|field|MAX_CONTAINER_CLASSES
specifier|private
specifier|static
specifier|final
name|int
name|MAX_CONTAINER_CLASSES
init|=
literal|1024
decl_stmt|;
DECL|field|MBIT_SUFFIX
specifier|private
specifier|static
specifier|final
name|String
name|MBIT_SUFFIX
init|=
literal|"mbit"
decl_stmt|;
DECL|field|TMP_FILE_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|TMP_FILE_PREFIX
init|=
literal|"tc."
decl_stmt|;
DECL|field|TMP_FILE_SUFFIX
specifier|private
specifier|static
specifier|final
name|String
name|TMP_FILE_SUFFIX
init|=
literal|".cmds"
decl_stmt|;
comment|/** Root queuing discipline attached to the root of the interface */
DECL|field|FORMAT_QDISC_ADD_TO_ROOT_WITH_DEFAULT
specifier|private
specifier|static
specifier|final
name|String
name|FORMAT_QDISC_ADD_TO_ROOT_WITH_DEFAULT
init|=
literal|"qdisc add dev %s root handle %d: htb default %s"
decl_stmt|;
comment|/** Specifies a cgroup/classid based filter - based on the classid associated    * with the outbound packet, the corresponding traffic shaping rule is used    * . Please see tc documentation for additional details.    */
DECL|field|FORMAT_FILTER_CGROUP_ADD_TO_PARENT
specifier|private
specifier|static
specifier|final
name|String
name|FORMAT_FILTER_CGROUP_ADD_TO_PARENT
init|=
literal|"filter add dev %s parent %d: protocol ip prio 10 handle 1: cgroup"
decl_stmt|;
comment|/** Standard format for adding a traffic shaping class to a parent, with    * the specified bandwidth limits    */
DECL|field|FORMAT_CLASS_ADD_TO_PARENT_WITH_RATES
specifier|private
specifier|static
specifier|final
name|String
name|FORMAT_CLASS_ADD_TO_PARENT_WITH_RATES
init|=
literal|"class add dev %s parent %d:%d classid %d:%d htb rate %s ceil %s"
decl_stmt|;
comment|/** Standard format to delete a traffic shaping class */
DECL|field|FORMAT_DELETE_CLASS
specifier|private
specifier|static
specifier|final
name|String
name|FORMAT_DELETE_CLASS
init|=
literal|"class del dev %s classid %d:%d"
decl_stmt|;
comment|/** Format of the classid that is to be used with the net_cls cgroup. Needs    * to be of the form 0xAAAABBBB */
DECL|field|FORMAT_NET_CLS_CLASS_ID
specifier|private
specifier|static
specifier|final
name|String
name|FORMAT_NET_CLS_CLASS_ID
init|=
literal|"0x%04d%04d"
decl_stmt|;
comment|/** Commands to read the qdsic(s)/filter(s)/class(es) associated with an    * interface    */
DECL|field|FORMAT_READ_STATE
specifier|private
specifier|static
specifier|final
name|String
name|FORMAT_READ_STATE
init|=
literal|"qdisc show dev %1$s%n"
operator|+
literal|"filter show dev %1$s%n"
operator|+
literal|"class show dev %1$s"
decl_stmt|;
DECL|field|FORMAT_READ_CLASSES
specifier|private
specifier|static
specifier|final
name|String
name|FORMAT_READ_CLASSES
init|=
literal|"class show dev %s"
decl_stmt|;
comment|/** Delete a qdisc and all its children - classes/filters etc */
DECL|field|FORMAT_WIPE_STATE
specifier|private
specifier|static
specifier|final
name|String
name|FORMAT_WIPE_STATE
init|=
literal|"qdisc del dev %s parent root"
decl_stmt|;
DECL|field|conf
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
comment|//Used to store the set of classids in use for container classes
DECL|field|classIdSet
specifier|private
specifier|final
name|BitSet
name|classIdSet
decl_stmt|;
DECL|field|privilegedOperationExecutor
specifier|private
specifier|final
name|PrivilegedOperationExecutor
name|privilegedOperationExecutor
decl_stmt|;
DECL|field|tmpDirPath
specifier|private
name|String
name|tmpDirPath
decl_stmt|;
DECL|field|device
specifier|private
name|String
name|device
decl_stmt|;
DECL|field|rootBandwidthMbit
specifier|private
name|int
name|rootBandwidthMbit
decl_stmt|;
DECL|field|yarnBandwidthMbit
specifier|private
name|int
name|yarnBandwidthMbit
decl_stmt|;
DECL|field|defaultClassBandwidthMbit
specifier|private
name|int
name|defaultClassBandwidthMbit
decl_stmt|;
DECL|method|TrafficController (Configuration conf, PrivilegedOperationExecutor exec)
name|TrafficController
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|PrivilegedOperationExecutor
name|exec
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|classIdSet
operator|=
operator|new
name|BitSet
argument_list|(
name|MAX_CONTAINER_CLASSES
argument_list|)
expr_stmt|;
name|this
operator|.
name|privilegedOperationExecutor
operator|=
name|exec
expr_stmt|;
block|}
comment|/**    * Bootstrap tc configuration    */
DECL|method|bootstrap (String device, int rootBandwidthMbit, int yarnBandwidthMbit)
specifier|public
name|void
name|bootstrap
parameter_list|(
name|String
name|device
parameter_list|,
name|int
name|rootBandwidthMbit
parameter_list|,
name|int
name|yarnBandwidthMbit
parameter_list|)
throws|throws
name|ResourceHandlerException
block|{
if|if
condition|(
name|device
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ResourceHandlerException
argument_list|(
literal|"device cannot be null!"
argument_list|)
throw|;
block|}
name|String
name|tmpDirBase
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"hadoop.tmp.dir"
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmpDirBase
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ResourceHandlerException
argument_list|(
literal|"hadoop.tmp.dir not set!"
argument_list|)
throw|;
block|}
name|tmpDirPath
operator|=
name|tmpDirBase
operator|+
literal|"/nm-tc-rules"
expr_stmt|;
name|File
name|tmpDir
init|=
operator|new
name|File
argument_list|(
name|tmpDirPath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmpDir
operator|.
name|exists
argument_list|()
operator|||
name|tmpDir
operator|.
name|mkdirs
argument_list|()
operator|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to create directory: "
operator|+
name|tmpDirPath
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ResourceHandlerException
argument_list|(
literal|"Unable to create directory: "
operator|+
name|tmpDirPath
argument_list|)
throw|;
block|}
name|this
operator|.
name|device
operator|=
name|device
expr_stmt|;
name|this
operator|.
name|rootBandwidthMbit
operator|=
name|rootBandwidthMbit
expr_stmt|;
name|this
operator|.
name|yarnBandwidthMbit
operator|=
name|yarnBandwidthMbit
expr_stmt|;
name|defaultClassBandwidthMbit
operator|=
operator|(
name|rootBandwidthMbit
operator|-
name|yarnBandwidthMbit
operator|)
operator|<=
literal|0
condition|?
name|rootBandwidthMbit
else|:
operator|(
name|rootBandwidthMbit
operator|-
name|yarnBandwidthMbit
operator|)
expr_stmt|;
name|boolean
name|recoveryEnabled
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|YarnConfiguration
operator|.
name|NM_RECOVERY_ENABLED
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_NM_RECOVERY_ENABLED
argument_list|)
decl_stmt|;
name|String
name|state
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|recoveryEnabled
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"NM recovery is not enabled. We'll wipe tc state before proceeding."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//NM recovery enabled - run a state check
name|state
operator|=
name|readState
argument_list|()
expr_stmt|;
if|if
condition|(
name|checkIfAlreadyBootstrapped
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"TC configuration is already in place. Not wiping state."
argument_list|)
expr_stmt|;
comment|//We already have the list of existing container classes, if any
comment|//that were created after bootstrapping
name|reacquireContainerClasses
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"TC configuration is incomplete. Wiping tc state before proceeding"
argument_list|)
expr_stmt|;
block|}
block|}
name|wipeState
argument_list|()
expr_stmt|;
comment|//start over in case preview bootstrap was incomplete
name|initializeState
argument_list|()
expr_stmt|;
block|}
DECL|method|initializeState ()
specifier|private
name|void
name|initializeState
parameter_list|()
throws|throws
name|ResourceHandlerException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Initializing tc state."
argument_list|)
expr_stmt|;
name|BatchBuilder
name|builder
init|=
operator|new
name|BatchBuilder
argument_list|(
name|PrivilegedOperation
operator|.
name|OperationType
operator|.
name|TC_MODIFY_STATE
argument_list|)
operator|.
name|addRootQDisc
argument_list|()
operator|.
name|addCGroupFilter
argument_list|()
operator|.
name|addClassToRootQDisc
argument_list|(
name|rootBandwidthMbit
argument_list|)
operator|.
name|addDefaultClass
argument_list|(
name|defaultClassBandwidthMbit
argument_list|,
name|rootBandwidthMbit
argument_list|)
comment|//yarn bandwidth is capped with rate = ceil
operator|.
name|addYARNRootClass
argument_list|(
name|yarnBandwidthMbit
argument_list|,
name|yarnBandwidthMbit
argument_list|)
decl_stmt|;
name|PrivilegedOperation
name|op
init|=
name|builder
operator|.
name|commitBatchToTempFile
argument_list|()
decl_stmt|;
try|try
block|{
name|privilegedOperationExecutor
operator|.
name|executePrivilegedOperation
argument_list|(
name|op
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PrivilegedOperationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to bootstrap outbound bandwidth configuration"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ResourceHandlerException
argument_list|(
literal|"Failed to bootstrap outbound bandwidth configuration"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Function to check if the interface in use has already been fully    * bootstrapped with the required tc configuration    *    * @return boolean indicating the result of the check    */
DECL|method|checkIfAlreadyBootstrapped (String state)
specifier|private
name|boolean
name|checkIfAlreadyBootstrapped
parameter_list|(
name|String
name|state
parameter_list|)
throws|throws
name|ResourceHandlerException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|regexes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|//root qdisc
name|regexes
operator|.
name|add
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"^qdisc htb %d: root(.)*$"
argument_list|,
name|ROOT_QDISC_HANDLE
argument_list|)
argument_list|)
expr_stmt|;
comment|//cgroup filter
name|regexes
operator|.
name|add
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"^filter parent %d: protocol ip "
operator|+
literal|"(.)*cgroup(.)*$"
argument_list|,
name|ROOT_QDISC_HANDLE
argument_list|)
argument_list|)
expr_stmt|;
comment|//root, default and yarn classes
name|regexes
operator|.
name|add
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"^class htb %d:%d root(.)*$"
argument_list|,
name|ROOT_QDISC_HANDLE
argument_list|,
name|ROOT_CLASS_ID
argument_list|)
argument_list|)
expr_stmt|;
name|regexes
operator|.
name|add
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"^class htb %d:%d parent %d:%d(.)*$"
argument_list|,
name|ROOT_QDISC_HANDLE
argument_list|,
name|DEFAULT_CLASS_ID
argument_list|,
name|ROOT_QDISC_HANDLE
argument_list|,
name|ROOT_CLASS_ID
argument_list|)
argument_list|)
expr_stmt|;
name|regexes
operator|.
name|add
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"^class htb %d:%d parent %d:%d(.)*$"
argument_list|,
name|ROOT_QDISC_HANDLE
argument_list|,
name|YARN_ROOT_CLASS_ID
argument_list|,
name|ROOT_QDISC_HANDLE
argument_list|,
name|ROOT_CLASS_ID
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|regex
range|:
name|regexes
control|)
block|{
name|Pattern
name|pattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|regex
argument_list|,
name|Pattern
operator|.
name|MULTILINE
argument_list|)
decl_stmt|;
if|if
condition|(
name|pattern
operator|.
name|matcher
argument_list|(
name|state
argument_list|)
operator|.
name|find
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Matched regex: "
operator|+
name|regex
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|String
name|logLine
init|=
operator|new
name|StringBuffer
argument_list|(
literal|"Failed to match regex: "
argument_list|)
operator|.
name|append
argument_list|(
name|regex
argument_list|)
operator|.
name|append
argument_list|(
literal|" Current state: "
argument_list|)
operator|.
name|append
argument_list|(
name|state
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|logLine
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Bootstrap check succeeded"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|readState ()
specifier|private
name|String
name|readState
parameter_list|()
throws|throws
name|ResourceHandlerException
block|{
comment|//Sample state output:
comment|//    qdisc htb 42: root refcnt 2 r2q 10 default 2 direct_packets_stat 0
comment|//    filter parent 42: protocol ip pref 10 cgroup handle 0x1
comment|//
comment|//    filter parent 42: protocol ip pref 10 cgroup handle 0x1
comment|//
comment|//    class htb 42:1 root rate 10000Kbit ceil 10000Kbit burst 1600b cburst 1600b
comment|//    class htb 42:2 parent 42:1 prio 0 rate 3000Kbit ceil 10000Kbit burst 1599b cburst 1600b
comment|//    class htb 42:3 parent 42:1 prio 0 rate 7000Kbit ceil 7000Kbit burst 1598b cburst 1598b
name|BatchBuilder
name|builder
init|=
operator|new
name|BatchBuilder
argument_list|(
name|PrivilegedOperation
operator|.
name|OperationType
operator|.
name|TC_READ_STATE
argument_list|)
operator|.
name|readState
argument_list|()
decl_stmt|;
name|PrivilegedOperation
name|op
init|=
name|builder
operator|.
name|commitBatchToTempFile
argument_list|()
decl_stmt|;
try|try
block|{
name|String
name|output
init|=
name|privilegedOperationExecutor
operator|.
name|executePrivilegedOperation
argument_list|(
name|op
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"TC state: %n"
operator|+
name|output
argument_list|)
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
catch|catch
parameter_list|(
name|PrivilegedOperationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to bootstrap outbound bandwidth rules"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ResourceHandlerException
argument_list|(
literal|"Failed to bootstrap outbound bandwidth rules"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|wipeState ()
specifier|private
name|void
name|wipeState
parameter_list|()
throws|throws
name|ResourceHandlerException
block|{
name|BatchBuilder
name|builder
init|=
operator|new
name|BatchBuilder
argument_list|(
name|PrivilegedOperation
operator|.
name|OperationType
operator|.
name|TC_MODIFY_STATE
argument_list|)
operator|.
name|wipeState
argument_list|()
decl_stmt|;
name|PrivilegedOperation
name|op
init|=
name|builder
operator|.
name|commitBatchToTempFile
argument_list|()
decl_stmt|;
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Wiping tc state."
argument_list|)
expr_stmt|;
name|privilegedOperationExecutor
operator|.
name|executePrivilegedOperation
argument_list|(
name|op
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PrivilegedOperationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to wipe tc state. This could happen if the interface"
operator|+
literal|" is already in its default state. Ignoring."
argument_list|)
expr_stmt|;
comment|//Ignoring this exception. This could happen if the interface is already
comment|//in its default state. For this reason we don't throw a
comment|//ResourceHandlerException here.
block|}
block|}
comment|/**    * Parses the current state looks for classids already in use    */
DECL|method|reacquireContainerClasses (String state)
specifier|private
name|void
name|reacquireContainerClasses
parameter_list|(
name|String
name|state
parameter_list|)
block|{
comment|//At this point we already have already successfully passed
comment|//checkIfAlreadyBootstrapped() - so we know that at least the
comment|//root classes are in place.
name|String
name|tcClassesStr
init|=
name|state
operator|.
name|substring
argument_list|(
name|state
operator|.
name|indexOf
argument_list|(
literal|"class"
argument_list|)
argument_list|)
decl_stmt|;
comment|//one class per line - the results of the split will need to trimmed
name|String
index|[]
name|tcClasses
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"$"
argument_list|,
name|Pattern
operator|.
name|MULTILINE
argument_list|)
operator|.
name|split
argument_list|(
name|tcClassesStr
argument_list|)
decl_stmt|;
name|Pattern
name|tcClassPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"class htb %d:(\\d+) .*"
argument_list|,
name|ROOT_QDISC_HANDLE
argument_list|)
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|classIdSet
init|)
block|{
for|for
control|(
name|String
name|tcClassSplit
range|:
name|tcClasses
control|)
block|{
name|String
name|tcClass
init|=
name|tcClassSplit
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|tcClass
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Matcher
name|classMatcher
init|=
name|tcClassPattern
operator|.
name|matcher
argument_list|(
name|tcClass
argument_list|)
decl_stmt|;
if|if
condition|(
name|classMatcher
operator|.
name|matches
argument_list|()
condition|)
block|{
name|int
name|classId
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|classMatcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|classId
operator|>=
name|MIN_CONTAINER_CLASS_ID
condition|)
block|{
name|classIdSet
operator|.
name|set
argument_list|(
name|classId
operator|-
name|MIN_CONTAINER_CLASS_ID
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Reacquired container classid: "
operator|+
name|classId
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to match classid in string:"
operator|+
name|tcClass
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|method|readStats ()
specifier|public
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|readStats
parameter_list|()
throws|throws
name|ResourceHandlerException
block|{
name|BatchBuilder
name|builder
init|=
operator|new
name|BatchBuilder
argument_list|(
name|PrivilegedOperation
operator|.
name|OperationType
operator|.
name|TC_READ_STATS
argument_list|)
operator|.
name|readClasses
argument_list|()
decl_stmt|;
name|PrivilegedOperation
name|op
init|=
name|builder
operator|.
name|commitBatchToTempFile
argument_list|()
decl_stmt|;
try|try
block|{
name|String
name|output
init|=
name|privilegedOperationExecutor
operator|.
name|executePrivilegedOperation
argument_list|(
name|op
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"TC stats output:"
operator|+
name|output
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|classIdBytesStats
init|=
name|parseStatsString
argument_list|(
name|output
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"classId -> bytes sent %n"
operator|+
name|classIdBytesStats
argument_list|)
expr_stmt|;
block|}
return|return
name|classIdBytesStats
return|;
block|}
catch|catch
parameter_list|(
name|PrivilegedOperationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to get tc stats"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ResourceHandlerException
argument_list|(
literal|"Failed to get tc stats"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|parseStatsString (String stats)
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|parseStatsString
parameter_list|(
name|String
name|stats
parameter_list|)
block|{
comment|//Example class stats segment (multiple present in tc output)
comment|//  class htb 42:4 parent 42:3 prio 0 rate 1000Kbit ceil 7000Kbit burst1600b cburst 1598b
comment|//   Sent 77921300 bytes 52617 pkt (dropped 0, overlimits 0 requeues 0)
comment|//   rate 6973Kbit 589pps backlog 0b 39p requeues 0
comment|//   lended: 3753 borrowed: 22514 giants: 0
comment|//   tokens: -122164 ctokens: -52488
name|String
index|[]
name|lines
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"$"
argument_list|,
name|Pattern
operator|.
name|MULTILINE
argument_list|)
operator|.
name|split
argument_list|(
name|stats
argument_list|)
decl_stmt|;
name|Pattern
name|tcClassPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"class htb %d:(\\d+) .*"
argument_list|,
name|ROOT_QDISC_HANDLE
argument_list|)
argument_list|)
decl_stmt|;
name|Pattern
name|bytesPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"Sent (\\d+) bytes.*"
argument_list|)
decl_stmt|;
name|int
name|currentClassId
init|=
operator|-
literal|1
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|containerClassIdStats
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|lineSplit
range|:
name|lines
control|)
block|{
name|String
name|line
init|=
name|lineSplit
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//Check if we encountered a stats segment for a container class
name|Matcher
name|classMatcher
init|=
name|tcClassPattern
operator|.
name|matcher
argument_list|(
name|line
argument_list|)
decl_stmt|;
if|if
condition|(
name|classMatcher
operator|.
name|matches
argument_list|()
condition|)
block|{
name|int
name|classId
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|classMatcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|classId
operator|>=
name|MIN_CONTAINER_CLASS_ID
condition|)
block|{
name|currentClassId
operator|=
name|classId
expr_stmt|;
continue|continue;
block|}
block|}
comment|//Check if we encountered a stats line
name|Matcher
name|bytesMatcher
init|=
name|bytesPattern
operator|.
name|matcher
argument_list|(
name|line
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytesMatcher
operator|.
name|matches
argument_list|()
condition|)
block|{
comment|//we found at least one class segment
if|if
condition|(
name|currentClassId
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|bytes
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|bytesMatcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|containerClassIdStats
operator|.
name|put
argument_list|(
name|currentClassId
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Matched a 'bytes sent' line outside of a class stats "
operator|+
literal|"segment : "
operator|+
name|line
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|//skip other kinds of non-empty lines - since we aren't interested in
comment|//them.
block|}
block|}
return|return
name|containerClassIdStats
return|;
block|}
comment|/**    * Returns a formatted string for attaching a qdisc to the root of the    * device/interface. Additional qdisc    * parameters can be supplied - for example, the default 'class' to use for    * incoming packets    */
DECL|method|getStringForAddRootQDisc ()
specifier|private
name|String
name|getStringForAddRootQDisc
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
name|FORMAT_QDISC_ADD_TO_ROOT_WITH_DEFAULT
argument_list|,
name|device
argument_list|,
name|ROOT_QDISC_HANDLE
argument_list|,
name|DEFAULT_CLASS_ID
argument_list|)
return|;
block|}
comment|/**    * Returns a formatted string for a filter that matches packets based on the    * presence of net_cls classids    */
DECL|method|getStringForaAddCGroupFilter ()
specifier|private
name|String
name|getStringForaAddCGroupFilter
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
name|FORMAT_FILTER_CGROUP_ADD_TO_PARENT
argument_list|,
name|device
argument_list|,
name|ROOT_QDISC_HANDLE
argument_list|)
return|;
block|}
comment|/**    * Get the next available classid. This has to be released post container    * complete    */
DECL|method|getNextClassId ()
specifier|public
name|int
name|getNextClassId
parameter_list|()
throws|throws
name|ResourceHandlerException
block|{
synchronized|synchronized
init|(
name|classIdSet
init|)
block|{
name|int
name|index
init|=
name|classIdSet
operator|.
name|nextClearBit
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
name|MAX_CONTAINER_CLASSES
condition|)
block|{
throw|throw
operator|new
name|ResourceHandlerException
argument_list|(
literal|"Reached max container classes: "
operator|+
name|MAX_CONTAINER_CLASSES
argument_list|)
throw|;
block|}
name|classIdSet
operator|.
name|set
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
operator|(
name|index
operator|+
name|MIN_CONTAINER_CLASS_ID
operator|)
return|;
block|}
block|}
DECL|method|releaseClassId (int classId)
specifier|public
name|void
name|releaseClassId
parameter_list|(
name|int
name|classId
parameter_list|)
throws|throws
name|ResourceHandlerException
block|{
synchronized|synchronized
init|(
name|classIdSet
init|)
block|{
name|int
name|index
init|=
name|classId
operator|-
name|MIN_CONTAINER_CLASS_ID
decl_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|MAX_CONTAINER_CLASSES
condition|)
block|{
throw|throw
operator|new
name|ResourceHandlerException
argument_list|(
literal|"Invalid incoming classId: "
operator|+
name|classId
argument_list|)
throw|;
block|}
name|classIdSet
operator|.
name|clear
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns a formatted string representing the given classId including a    * handle    */
DECL|method|getStringForNetClsClassId (int classId)
specifier|public
name|String
name|getStringForNetClsClassId
parameter_list|(
name|int
name|classId
parameter_list|)
block|{
return|return
name|String
operator|.
name|format
argument_list|(
name|FORMAT_NET_CLS_CLASS_ID
argument_list|,
name|ROOT_QDISC_HANDLE
argument_list|,
name|classId
argument_list|)
return|;
block|}
comment|/**    * A value read out of net_cls.classid file is in decimal form. We need to    * convert to 32-bit/8 digit hex, extract the lower 16-bit/four digits    * as an int    */
DECL|method|getClassIdFromFileContents (String input)
specifier|public
name|int
name|getClassIdFromFileContents
parameter_list|(
name|String
name|input
parameter_list|)
block|{
comment|//convert from decimal back to fixed size hex form
comment|//e.g 4325381 -> 00420005
name|String
name|classIdStr
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%08x"
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|input
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ClassId hex string : "
operator|+
name|classIdStr
argument_list|)
expr_stmt|;
block|}
comment|//extract and return 4 digits
comment|//e.g 00420005 -> 0005
return|return
name|Integer
operator|.
name|parseInt
argument_list|(
name|classIdStr
operator|.
name|substring
argument_list|(
literal|4
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Adds a tc class to qdisc at root    */
DECL|method|getStringForAddClassToRootQDisc (int rateMbit)
specifier|private
name|String
name|getStringForAddClassToRootQDisc
parameter_list|(
name|int
name|rateMbit
parameter_list|)
block|{
name|String
name|rateMbitStr
init|=
name|rateMbit
operator|+
name|MBIT_SUFFIX
decl_stmt|;
comment|//example : "class add dev eth0 parent 42:0 classid 42:1 htb rate 1000mbit
comment|// ceil 1000mbit"
return|return
name|String
operator|.
name|format
argument_list|(
name|FORMAT_CLASS_ADD_TO_PARENT_WITH_RATES
argument_list|,
name|device
argument_list|,
name|ROOT_QDISC_HANDLE
argument_list|,
name|ZERO_CLASS_ID
argument_list|,
name|ROOT_QDISC_HANDLE
argument_list|,
name|ROOT_CLASS_ID
argument_list|,
name|rateMbitStr
argument_list|,
name|rateMbitStr
argument_list|)
return|;
block|}
DECL|method|getStringForAddDefaultClass (int rateMbit, int ceilMbit)
specifier|private
name|String
name|getStringForAddDefaultClass
parameter_list|(
name|int
name|rateMbit
parameter_list|,
name|int
name|ceilMbit
parameter_list|)
block|{
name|String
name|rateMbitStr
init|=
name|rateMbit
operator|+
name|MBIT_SUFFIX
decl_stmt|;
name|String
name|ceilMbitStr
init|=
name|ceilMbit
operator|+
name|MBIT_SUFFIX
decl_stmt|;
comment|//example : "class add dev eth0 parent 42:1 classid 42:2 htb rate 300mbit
comment|// ceil 1000mbit"
return|return
name|String
operator|.
name|format
argument_list|(
name|FORMAT_CLASS_ADD_TO_PARENT_WITH_RATES
argument_list|,
name|device
argument_list|,
name|ROOT_QDISC_HANDLE
argument_list|,
name|ROOT_CLASS_ID
argument_list|,
name|ROOT_QDISC_HANDLE
argument_list|,
name|DEFAULT_CLASS_ID
argument_list|,
name|rateMbitStr
argument_list|,
name|ceilMbitStr
argument_list|)
return|;
block|}
DECL|method|getStringForAddYARNRootClass (int rateMbit, int ceilMbit)
specifier|private
name|String
name|getStringForAddYARNRootClass
parameter_list|(
name|int
name|rateMbit
parameter_list|,
name|int
name|ceilMbit
parameter_list|)
block|{
name|String
name|rateMbitStr
init|=
name|rateMbit
operator|+
name|MBIT_SUFFIX
decl_stmt|;
name|String
name|ceilMbitStr
init|=
name|ceilMbit
operator|+
name|MBIT_SUFFIX
decl_stmt|;
comment|//example : "class add dev eth0 parent 42:1 classid 42:3 htb rate 700mbit
comment|// ceil 1000mbit"
return|return
name|String
operator|.
name|format
argument_list|(
name|FORMAT_CLASS_ADD_TO_PARENT_WITH_RATES
argument_list|,
name|device
argument_list|,
name|ROOT_QDISC_HANDLE
argument_list|,
name|ROOT_CLASS_ID
argument_list|,
name|ROOT_QDISC_HANDLE
argument_list|,
name|YARN_ROOT_CLASS_ID
argument_list|,
name|rateMbitStr
argument_list|,
name|ceilMbitStr
argument_list|)
return|;
block|}
DECL|method|getStringForAddContainerClass (int classId, int rateMbit, int ceilMbit)
specifier|private
name|String
name|getStringForAddContainerClass
parameter_list|(
name|int
name|classId
parameter_list|,
name|int
name|rateMbit
parameter_list|,
name|int
name|ceilMbit
parameter_list|)
block|{
name|String
name|rateMbitStr
init|=
name|rateMbit
operator|+
name|MBIT_SUFFIX
decl_stmt|;
name|String
name|ceilMbitStr
init|=
name|ceilMbit
operator|+
name|MBIT_SUFFIX
decl_stmt|;
comment|//example : "class add dev eth0 parent 42:99 classid 42:99 htb rate 50mbit
comment|// ceil 700mbit"
return|return
name|String
operator|.
name|format
argument_list|(
name|FORMAT_CLASS_ADD_TO_PARENT_WITH_RATES
argument_list|,
name|device
argument_list|,
name|ROOT_QDISC_HANDLE
argument_list|,
name|YARN_ROOT_CLASS_ID
argument_list|,
name|ROOT_QDISC_HANDLE
argument_list|,
name|classId
argument_list|,
name|rateMbitStr
argument_list|,
name|ceilMbitStr
argument_list|)
return|;
block|}
DECL|method|getStringForDeleteContainerClass (int classId)
specifier|private
name|String
name|getStringForDeleteContainerClass
parameter_list|(
name|int
name|classId
parameter_list|)
block|{
comment|//example "class del dev eth0 classid 42:7"
return|return
name|String
operator|.
name|format
argument_list|(
name|FORMAT_DELETE_CLASS
argument_list|,
name|device
argument_list|,
name|ROOT_QDISC_HANDLE
argument_list|,
name|classId
argument_list|)
return|;
block|}
DECL|method|getStringForReadState ()
specifier|private
name|String
name|getStringForReadState
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
name|FORMAT_READ_STATE
argument_list|,
name|device
argument_list|)
return|;
block|}
DECL|method|getStringForReadClasses ()
specifier|private
name|String
name|getStringForReadClasses
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
name|FORMAT_READ_CLASSES
argument_list|,
name|device
argument_list|)
return|;
block|}
DECL|method|getStringForWipeState ()
specifier|private
name|String
name|getStringForWipeState
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
name|FORMAT_WIPE_STATE
argument_list|,
name|device
argument_list|)
return|;
block|}
DECL|class|BatchBuilder
specifier|public
class|class
name|BatchBuilder
block|{
DECL|field|operation
specifier|final
name|PrivilegedOperation
name|operation
decl_stmt|;
DECL|field|commands
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|commands
decl_stmt|;
DECL|method|BatchBuilder (PrivilegedOperation.OperationType opType)
specifier|public
name|BatchBuilder
parameter_list|(
name|PrivilegedOperation
operator|.
name|OperationType
name|opType
parameter_list|)
throws|throws
name|ResourceHandlerException
block|{
switch|switch
condition|(
name|opType
condition|)
block|{
case|case
name|TC_MODIFY_STATE
case|:
case|case
name|TC_READ_STATE
case|:
case|case
name|TC_READ_STATS
case|:
name|operation
operator|=
operator|new
name|PrivilegedOperation
argument_list|(
name|opType
argument_list|,
operator|(
name|String
operator|)
literal|null
argument_list|)
expr_stmt|;
name|commands
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|ResourceHandlerException
argument_list|(
literal|"Not a tc operation type : "
operator|+
name|opType
argument_list|)
throw|;
block|}
block|}
DECL|method|addRootQDisc ()
specifier|private
name|BatchBuilder
name|addRootQDisc
parameter_list|()
block|{
name|commands
operator|.
name|add
argument_list|(
name|getStringForAddRootQDisc
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|addCGroupFilter ()
specifier|private
name|BatchBuilder
name|addCGroupFilter
parameter_list|()
block|{
name|commands
operator|.
name|add
argument_list|(
name|getStringForaAddCGroupFilter
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|addClassToRootQDisc (int rateMbit)
specifier|private
name|BatchBuilder
name|addClassToRootQDisc
parameter_list|(
name|int
name|rateMbit
parameter_list|)
block|{
name|commands
operator|.
name|add
argument_list|(
name|getStringForAddClassToRootQDisc
argument_list|(
name|rateMbit
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|addDefaultClass (int rateMbit, int ceilMbit)
specifier|private
name|BatchBuilder
name|addDefaultClass
parameter_list|(
name|int
name|rateMbit
parameter_list|,
name|int
name|ceilMbit
parameter_list|)
block|{
name|commands
operator|.
name|add
argument_list|(
name|getStringForAddDefaultClass
argument_list|(
name|rateMbit
argument_list|,
name|ceilMbit
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|addYARNRootClass (int rateMbit, int ceilMbit)
specifier|private
name|BatchBuilder
name|addYARNRootClass
parameter_list|(
name|int
name|rateMbit
parameter_list|,
name|int
name|ceilMbit
parameter_list|)
block|{
name|commands
operator|.
name|add
argument_list|(
name|getStringForAddYARNRootClass
argument_list|(
name|rateMbit
argument_list|,
name|ceilMbit
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|addContainerClass (int classId, int rateMbit, boolean strictMode)
specifier|public
name|BatchBuilder
name|addContainerClass
parameter_list|(
name|int
name|classId
parameter_list|,
name|int
name|rateMbit
parameter_list|,
name|boolean
name|strictMode
parameter_list|)
block|{
name|int
name|ceilMbit
decl_stmt|;
if|if
condition|(
name|strictMode
condition|)
block|{
name|ceilMbit
operator|=
name|rateMbit
expr_stmt|;
block|}
else|else
block|{
name|ceilMbit
operator|=
name|yarnBandwidthMbit
expr_stmt|;
block|}
name|commands
operator|.
name|add
argument_list|(
name|getStringForAddContainerClass
argument_list|(
name|classId
argument_list|,
name|rateMbit
argument_list|,
name|ceilMbit
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|deleteContainerClass (int classId)
specifier|public
name|BatchBuilder
name|deleteContainerClass
parameter_list|(
name|int
name|classId
parameter_list|)
block|{
name|commands
operator|.
name|add
argument_list|(
name|getStringForDeleteContainerClass
argument_list|(
name|classId
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|readState ()
specifier|private
name|BatchBuilder
name|readState
parameter_list|()
block|{
name|commands
operator|.
name|add
argument_list|(
name|getStringForReadState
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|//We'll read all classes, but use a different tc operation type
comment|//when reading stats for all these classes. Stats are fetched using a
comment|//different tc cli option (-s).
DECL|method|readClasses ()
specifier|private
name|BatchBuilder
name|readClasses
parameter_list|()
block|{
comment|//We'll read all classes, but use a different tc operation type
comment|//for reading stats for all these classes. Stats are fetched using a
comment|//different tc cli option (-s).
name|commands
operator|.
name|add
argument_list|(
name|getStringForReadClasses
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|wipeState ()
specifier|private
name|BatchBuilder
name|wipeState
parameter_list|()
block|{
name|commands
operator|.
name|add
argument_list|(
name|getStringForWipeState
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|commitBatchToTempFile ()
specifier|public
name|PrivilegedOperation
name|commitBatchToTempFile
parameter_list|()
throws|throws
name|ResourceHandlerException
block|{
try|try
block|{
name|File
name|tcCmds
init|=
name|File
operator|.
name|createTempFile
argument_list|(
name|TMP_FILE_PREFIX
argument_list|,
name|TMP_FILE_SUFFIX
argument_list|,
operator|new
name|File
argument_list|(
name|tmpDirPath
argument_list|)
argument_list|)
decl_stmt|;
name|Writer
name|writer
init|=
operator|new
name|OutputStreamWriter
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|tcCmds
argument_list|)
argument_list|,
literal|"UTF-8"
argument_list|)
decl_stmt|;
name|PrintWriter
name|printWriter
init|=
operator|new
name|PrintWriter
argument_list|(
name|writer
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|command
range|:
name|commands
control|)
block|{
name|printWriter
operator|.
name|println
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
name|printWriter
operator|.
name|close
argument_list|()
expr_stmt|;
name|operation
operator|.
name|appendArgs
argument_list|(
name|tcCmds
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|operation
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to create or write to temporary file in dir: "
operator|+
name|tmpDirPath
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ResourceHandlerException
argument_list|(
literal|"Failed to create or write to temporary file in dir: "
operator|+
name|tmpDirPath
argument_list|)
throw|;
block|}
block|}
block|}
comment|//end BatchBuilder
block|}
end_class

end_unit

