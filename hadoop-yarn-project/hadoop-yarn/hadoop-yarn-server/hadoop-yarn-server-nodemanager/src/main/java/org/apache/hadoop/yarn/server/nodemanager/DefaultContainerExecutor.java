begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/** * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.nodemanager
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CreateFlag
operator|.
name|CREATE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CreateFlag
operator|.
name|OVERWRITE
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|IOStreamPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|runtime
operator|.
name|ContainerExecutionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|executor
operator|.
name|ContainerExecContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|RandomUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|Private
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|UnsupportedFileSystemException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
operator|.
name|CommandExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
operator|.
name|ExitCodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
operator|.
name|ShellCommandExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|ConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|factory
operator|.
name|providers
operator|.
name|RecordFactoryProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|container
operator|.
name|Container
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|container
operator|.
name|ContainerDiagnosticsUpdateEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|launcher
operator|.
name|ContainerLaunch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|localizer
operator|.
name|ContainerLocalizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|executor
operator|.
name|ContainerLivenessContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|executor
operator|.
name|ContainerReapContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|executor
operator|.
name|ContainerSignalContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|executor
operator|.
name|ContainerStartContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|executor
operator|.
name|DeletionAsUserContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|executor
operator|.
name|LocalizerStartContext
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Optional
import|;
end_import

begin_comment
comment|/**  * The {@code DefaultContainerExecuter} class offers generic container  * execution services. Process execution is handled in a platform-independent  * way via {@link ProcessBuilder}.  */
end_comment

begin_class
DECL|class|DefaultContainerExecutor
specifier|public
class|class
name|DefaultContainerExecutor
extends|extends
name|ContainerExecutor
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|DefaultContainerExecutor
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|WIN_MAX_PATH
specifier|private
specifier|static
specifier|final
name|int
name|WIN_MAX_PATH
init|=
literal|260
decl_stmt|;
comment|/**    * A {@link FileContext} for the local file system.    */
DECL|field|lfs
specifier|protected
specifier|final
name|FileContext
name|lfs
decl_stmt|;
DECL|field|logDirPermissions
specifier|private
name|String
name|logDirPermissions
init|=
literal|null
decl_stmt|;
comment|/**    * Default constructor for use in testing.    */
annotation|@
name|VisibleForTesting
DECL|method|DefaultContainerExecutor ()
specifier|public
name|DefaultContainerExecutor
parameter_list|()
block|{
try|try
block|{
name|this
operator|.
name|lfs
operator|=
name|FileContext
operator|.
name|getLocalFSFileContext
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedFileSystemException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Create an instance with a given {@link FileContext}.    *    * @param lfs the given {@link FileContext}    */
DECL|method|DefaultContainerExecutor (FileContext lfs)
name|DefaultContainerExecutor
parameter_list|(
name|FileContext
name|lfs
parameter_list|)
block|{
name|this
operator|.
name|lfs
operator|=
name|lfs
expr_stmt|;
block|}
comment|/**    * Copy a file using the {@link #lfs} {@link FileContext}.    *    * @param src the file to copy    * @param dst where to copy the file    * @param owner the owner of the new copy. Used only in secure Windows    * clusters    * @throws IOException when the copy fails    * @see WindowsSecureContainerExecutor    */
DECL|method|copyFile (Path src, Path dst, String owner)
specifier|protected
name|void
name|copyFile
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|,
name|String
name|owner
parameter_list|)
throws|throws
name|IOException
block|{
name|lfs
operator|.
name|util
argument_list|()
operator|.
name|copy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Make a file executable using the {@link #lfs} {@link FileContext}.    *    * @param script the path to make executable    * @param owner the new owner for the file. Used only in secure Windows    * clusters    * @throws IOException when the change mode operation fails    * @see WindowsSecureContainerExecutor    */
DECL|method|setScriptExecutable (Path script, String owner)
specifier|protected
name|void
name|setScriptExecutable
parameter_list|(
name|Path
name|script
parameter_list|,
name|String
name|owner
parameter_list|)
throws|throws
name|IOException
block|{
name|lfs
operator|.
name|setPermission
argument_list|(
name|script
argument_list|,
name|ContainerExecutor
operator|.
name|TASK_LAUNCH_SCRIPT_PERMISSION
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|init (Context nmContext)
specifier|public
name|void
name|init
parameter_list|(
name|Context
name|nmContext
parameter_list|)
throws|throws
name|IOException
block|{
comment|// nothing to do or verify here
block|}
annotation|@
name|Override
DECL|method|startLocalizer (LocalizerStartContext ctx)
specifier|public
name|void
name|startLocalizer
parameter_list|(
name|LocalizerStartContext
name|ctx
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|Path
name|nmPrivateContainerTokensPath
init|=
name|ctx
operator|.
name|getNmPrivateContainerTokens
argument_list|()
decl_stmt|;
name|InetSocketAddress
name|nmAddr
init|=
name|ctx
operator|.
name|getNmAddr
argument_list|()
decl_stmt|;
name|String
name|user
init|=
name|ctx
operator|.
name|getUser
argument_list|()
decl_stmt|;
name|String
name|appId
init|=
name|ctx
operator|.
name|getAppId
argument_list|()
decl_stmt|;
name|String
name|locId
init|=
name|ctx
operator|.
name|getLocId
argument_list|()
decl_stmt|;
name|LocalDirsHandlerService
name|dirsHandler
init|=
name|ctx
operator|.
name|getDirsHandler
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|localDirs
init|=
name|dirsHandler
operator|.
name|getLocalDirs
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|logDirs
init|=
name|dirsHandler
operator|.
name|getLogDirs
argument_list|()
decl_stmt|;
name|createUserLocalDirs
argument_list|(
name|localDirs
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|createUserCacheDirs
argument_list|(
name|localDirs
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|createAppDirs
argument_list|(
name|localDirs
argument_list|,
name|user
argument_list|,
name|appId
argument_list|)
expr_stmt|;
name|createAppLogDirs
argument_list|(
name|appId
argument_list|,
name|logDirs
argument_list|,
name|user
argument_list|)
expr_stmt|;
comment|// randomly choose the local directory
name|Path
name|appStorageDir
init|=
name|getWorkingDir
argument_list|(
name|localDirs
argument_list|,
name|user
argument_list|,
name|appId
argument_list|)
decl_stmt|;
name|String
name|tokenFn
init|=
name|String
operator|.
name|format
argument_list|(
name|ContainerLocalizer
operator|.
name|TOKEN_FILE_NAME_FMT
argument_list|,
name|locId
argument_list|)
decl_stmt|;
name|Path
name|tokenDst
init|=
operator|new
name|Path
argument_list|(
name|appStorageDir
argument_list|,
name|tokenFn
argument_list|)
decl_stmt|;
name|copyFile
argument_list|(
name|nmPrivateContainerTokensPath
argument_list|,
name|tokenDst
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Copying from "
operator|+
name|nmPrivateContainerTokensPath
operator|+
literal|" to "
operator|+
name|tokenDst
argument_list|)
expr_stmt|;
name|FileContext
name|localizerFc
init|=
name|FileContext
operator|.
name|getFileContext
argument_list|(
name|lfs
operator|.
name|getDefaultFileSystem
argument_list|()
argument_list|,
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
name|localizerFc
operator|.
name|setUMask
argument_list|(
name|lfs
operator|.
name|getUMask
argument_list|()
argument_list|)
expr_stmt|;
name|localizerFc
operator|.
name|setWorkingDirectory
argument_list|(
name|appStorageDir
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Localizer CWD set to "
operator|+
name|appStorageDir
operator|+
literal|" = "
operator|+
name|localizerFc
operator|.
name|getWorkingDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|ContainerLocalizer
name|localizer
init|=
name|createContainerLocalizer
argument_list|(
name|user
argument_list|,
name|appId
argument_list|,
name|locId
argument_list|,
name|localDirs
argument_list|,
name|localizerFc
argument_list|)
decl_stmt|;
comment|// TODO: DO it over RPC for maintaining similarity?
name|localizer
operator|.
name|runLocalization
argument_list|(
name|nmAddr
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a new {@link ContainerLocalizer} instance.    *    * @param user the user who owns the job for which the localization is being    * run    * @param appId the ID of the application for which the localization is being    * run    * @param locId the ID of the container for which the localization is being    * run    * @param localDirs a list of directories to use as destinations for the    * localization    * @param localizerFc the {@link FileContext} to use when localizing files    * @return the new {@link ContainerLocalizer} instance    * @throws IOException if {@code user} or {@code locId} is {@code null} or if    * the container localizer has an initialization failure    */
annotation|@
name|Private
annotation|@
name|VisibleForTesting
DECL|method|createContainerLocalizer (String user, String appId, String locId, List<String> localDirs, FileContext localizerFc)
specifier|protected
name|ContainerLocalizer
name|createContainerLocalizer
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|appId
parameter_list|,
name|String
name|locId
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|localDirs
parameter_list|,
name|FileContext
name|localizerFc
parameter_list|)
throws|throws
name|IOException
block|{
name|ContainerLocalizer
name|localizer
init|=
operator|new
name|ContainerLocalizer
argument_list|(
name|localizerFc
argument_list|,
name|user
argument_list|,
name|appId
argument_list|,
name|locId
argument_list|,
name|getPaths
argument_list|(
name|localDirs
argument_list|)
argument_list|,
name|RecordFactoryProvider
operator|.
name|getRecordFactory
argument_list|(
name|getConf
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|localizer
return|;
block|}
annotation|@
name|Override
DECL|method|launchContainer (ContainerStartContext ctx)
specifier|public
name|int
name|launchContainer
parameter_list|(
name|ContainerStartContext
name|ctx
parameter_list|)
throws|throws
name|IOException
throws|,
name|ConfigurationException
block|{
name|Container
name|container
init|=
name|ctx
operator|.
name|getContainer
argument_list|()
decl_stmt|;
name|Path
name|nmPrivateContainerScriptPath
init|=
name|ctx
operator|.
name|getNmPrivateContainerScriptPath
argument_list|()
decl_stmt|;
name|Path
name|nmPrivateTokensPath
init|=
name|ctx
operator|.
name|getNmPrivateTokensPath
argument_list|()
decl_stmt|;
name|String
name|user
init|=
name|ctx
operator|.
name|getUser
argument_list|()
decl_stmt|;
name|Path
name|containerWorkDir
init|=
name|ctx
operator|.
name|getContainerWorkDir
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|localDirs
init|=
name|ctx
operator|.
name|getLocalDirs
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|logDirs
init|=
name|ctx
operator|.
name|getLogDirs
argument_list|()
decl_stmt|;
name|FsPermission
name|dirPerm
init|=
operator|new
name|FsPermission
argument_list|(
name|APPDIR_PERM
argument_list|)
decl_stmt|;
name|ContainerId
name|containerId
init|=
name|container
operator|.
name|getContainerId
argument_list|()
decl_stmt|;
comment|// create container dirs on all disks
name|String
name|containerIdStr
init|=
name|containerId
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|appIdStr
init|=
name|containerId
operator|.
name|getApplicationAttemptId
argument_list|()
operator|.
name|getApplicationId
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|sLocalDir
range|:
name|localDirs
control|)
block|{
name|Path
name|usersdir
init|=
operator|new
name|Path
argument_list|(
name|sLocalDir
argument_list|,
name|ContainerLocalizer
operator|.
name|USERCACHE
argument_list|)
decl_stmt|;
name|Path
name|userdir
init|=
operator|new
name|Path
argument_list|(
name|usersdir
argument_list|,
name|user
argument_list|)
decl_stmt|;
name|Path
name|appCacheDir
init|=
operator|new
name|Path
argument_list|(
name|userdir
argument_list|,
name|ContainerLocalizer
operator|.
name|APPCACHE
argument_list|)
decl_stmt|;
name|Path
name|appDir
init|=
operator|new
name|Path
argument_list|(
name|appCacheDir
argument_list|,
name|appIdStr
argument_list|)
decl_stmt|;
name|Path
name|containerDir
init|=
operator|new
name|Path
argument_list|(
name|appDir
argument_list|,
name|containerIdStr
argument_list|)
decl_stmt|;
name|createDir
argument_list|(
name|containerDir
argument_list|,
name|dirPerm
argument_list|,
literal|true
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
comment|// Create the container log-dirs on all disks
name|createContainerLogDirs
argument_list|(
name|appIdStr
argument_list|,
name|containerIdStr
argument_list|,
name|logDirs
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|Path
name|tmpDir
init|=
operator|new
name|Path
argument_list|(
name|containerWorkDir
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_CONTAINER_TEMP_DIR
argument_list|)
decl_stmt|;
name|createDir
argument_list|(
name|tmpDir
argument_list|,
name|dirPerm
argument_list|,
literal|false
argument_list|,
name|user
argument_list|)
expr_stmt|;
comment|// copy container tokens to work dir
name|Path
name|tokenDst
init|=
operator|new
name|Path
argument_list|(
name|containerWorkDir
argument_list|,
name|ContainerLaunch
operator|.
name|FINAL_CONTAINER_TOKENS_FILE
argument_list|)
decl_stmt|;
name|copyFile
argument_list|(
name|nmPrivateTokensPath
argument_list|,
name|tokenDst
argument_list|,
name|user
argument_list|)
expr_stmt|;
comment|// copy launch script to work dir
name|Path
name|launchDst
init|=
operator|new
name|Path
argument_list|(
name|containerWorkDir
argument_list|,
name|ContainerLaunch
operator|.
name|CONTAINER_SCRIPT
argument_list|)
decl_stmt|;
name|copyFile
argument_list|(
name|nmPrivateContainerScriptPath
argument_list|,
name|launchDst
argument_list|,
name|user
argument_list|)
expr_stmt|;
comment|// Create new local launch wrapper script
name|LocalWrapperScriptBuilder
name|sb
init|=
name|getLocalWrapperScriptBuilder
argument_list|(
name|containerIdStr
argument_list|,
name|containerWorkDir
argument_list|)
decl_stmt|;
comment|// Fail fast if attempting to launch the wrapper script would fail due to
comment|// Windows path length limitation.
if|if
condition|(
name|Shell
operator|.
name|WINDOWS
operator|&&
name|sb
operator|.
name|getWrapperScriptPath
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|length
argument_list|()
operator|>
name|WIN_MAX_PATH
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Cannot launch container using script at path %s, because it exceeds "
operator|+
literal|"the maximum supported path length of %d characters.  Consider "
operator|+
literal|"configuring shorter directories in %s."
argument_list|,
name|sb
operator|.
name|getWrapperScriptPath
argument_list|()
argument_list|,
name|WIN_MAX_PATH
argument_list|,
name|YarnConfiguration
operator|.
name|NM_LOCAL_DIRS
argument_list|)
argument_list|)
throw|;
block|}
name|Path
name|pidFile
init|=
name|getPidFilePath
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|pidFile
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|writeLocalWrapperScript
argument_list|(
name|launchDst
argument_list|,
name|pidFile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Container "
operator|+
name|containerIdStr
operator|+
literal|" pid file not set. Returning terminated error"
argument_list|)
expr_stmt|;
return|return
name|ExitCode
operator|.
name|TERMINATED
operator|.
name|getExitCode
argument_list|()
return|;
block|}
comment|// create log dir under app
comment|// fork script
name|Shell
operator|.
name|CommandExecutor
name|shExec
init|=
literal|null
decl_stmt|;
try|try
block|{
name|setScriptExecutable
argument_list|(
name|launchDst
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|setScriptExecutable
argument_list|(
name|sb
operator|.
name|getWrapperScriptPath
argument_list|()
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|shExec
operator|=
name|buildCommandExecutor
argument_list|(
name|sb
operator|.
name|getWrapperScriptPath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|containerIdStr
argument_list|,
name|user
argument_list|,
name|pidFile
argument_list|,
name|container
operator|.
name|getResource
argument_list|()
argument_list|,
operator|new
name|File
argument_list|(
name|containerWorkDir
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|,
name|container
operator|.
name|getLaunchContext
argument_list|()
operator|.
name|getEnvironment
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|isContainerActive
argument_list|(
name|containerId
argument_list|)
condition|)
block|{
name|shExec
operator|.
name|execute
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Container "
operator|+
name|containerIdStr
operator|+
literal|" was marked as inactive. Returning terminated error"
argument_list|)
expr_stmt|;
return|return
name|ExitCode
operator|.
name|TERMINATED
operator|.
name|getExitCode
argument_list|()
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|shExec
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|int
name|exitCode
init|=
name|shExec
operator|.
name|getExitCode
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exit code from container "
operator|+
name|containerId
operator|+
literal|" is : "
operator|+
name|exitCode
argument_list|)
expr_stmt|;
comment|// 143 (SIGTERM) and 137 (SIGKILL) exit codes means the container was
comment|// terminated/killed forcefully. In all other cases, log the
comment|// container-executor's output
if|if
condition|(
name|exitCode
operator|!=
name|ExitCode
operator|.
name|FORCE_KILLED
operator|.
name|getExitCode
argument_list|()
operator|&&
name|exitCode
operator|!=
name|ExitCode
operator|.
name|TERMINATED
operator|.
name|getExitCode
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception from container-launch with container ID: "
operator|+
name|containerId
operator|+
literal|" and exit code: "
operator|+
name|exitCode
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"Exception from container-launch.\n"
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"Container id: "
argument_list|)
operator|.
name|append
argument_list|(
name|containerId
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"Exit code: "
argument_list|)
operator|.
name|append
argument_list|(
name|exitCode
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Optional
operator|.
name|fromNullable
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
operator|.
name|or
argument_list|(
literal|""
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"Exception message: "
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|shExec
operator|.
name|getOutput
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"Shell output: "
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|shExec
operator|.
name|getOutput
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|String
name|diagnostics
init|=
name|builder
operator|.
name|toString
argument_list|()
decl_stmt|;
name|logOutput
argument_list|(
name|diagnostics
argument_list|)
expr_stmt|;
name|container
operator|.
name|handle
argument_list|(
operator|new
name|ContainerDiagnosticsUpdateEvent
argument_list|(
name|containerId
argument_list|,
name|diagnostics
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|container
operator|.
name|handle
argument_list|(
operator|new
name|ContainerDiagnosticsUpdateEvent
argument_list|(
name|containerId
argument_list|,
literal|"Container killed on request. Exit code is "
operator|+
name|exitCode
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|exitCode
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|shExec
operator|!=
literal|null
condition|)
name|shExec
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|relaunchContainer (ContainerStartContext ctx)
specifier|public
name|int
name|relaunchContainer
parameter_list|(
name|ContainerStartContext
name|ctx
parameter_list|)
throws|throws
name|IOException
throws|,
name|ConfigurationException
block|{
return|return
name|launchContainer
argument_list|(
name|ctx
argument_list|)
return|;
block|}
comment|/**    * Create a new {@link ShellCommandExecutor} using the parameters.    *    * @param wrapperScriptPath the path to the script to execute    * @param containerIdStr the container ID    * @param user the application owner's username    * @param pidFile the path to the container's PID file    * @param resource this parameter controls memory and CPU limits.    * @param workDir If not-null, specifies the directory which should be set    * as the current working directory for the command. If null,    * the current working directory is not modified.    * @param environment the container environment    * @return the new {@link ShellCommandExecutor}    * @see ShellCommandExecutor    */
DECL|method|buildCommandExecutor (String wrapperScriptPath, String containerIdStr, String user, Path pidFile, Resource resource, File workDir, Map<String, String> environment)
specifier|protected
name|CommandExecutor
name|buildCommandExecutor
parameter_list|(
name|String
name|wrapperScriptPath
parameter_list|,
name|String
name|containerIdStr
parameter_list|,
name|String
name|user
parameter_list|,
name|Path
name|pidFile
parameter_list|,
name|Resource
name|resource
parameter_list|,
name|File
name|workDir
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|environment
parameter_list|)
block|{
name|String
index|[]
name|command
init|=
name|getRunCommand
argument_list|(
name|wrapperScriptPath
argument_list|,
name|containerIdStr
argument_list|,
name|user
argument_list|,
name|pidFile
argument_list|,
name|this
operator|.
name|getConf
argument_list|()
argument_list|,
name|resource
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"launchContainer: "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|command
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|ShellCommandExecutor
argument_list|(
name|command
argument_list|,
name|workDir
argument_list|,
name|environment
argument_list|,
literal|0L
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Create a {@link LocalWrapperScriptBuilder} for the given container ID    * and path that is appropriate to the current platform.    *    * @param containerIdStr the container ID    * @param containerWorkDir the container's working directory    * @return a new {@link LocalWrapperScriptBuilder}    */
DECL|method|getLocalWrapperScriptBuilder ( String containerIdStr, Path containerWorkDir)
specifier|protected
name|LocalWrapperScriptBuilder
name|getLocalWrapperScriptBuilder
parameter_list|(
name|String
name|containerIdStr
parameter_list|,
name|Path
name|containerWorkDir
parameter_list|)
block|{
return|return
name|Shell
operator|.
name|WINDOWS
condition|?
operator|new
name|WindowsLocalWrapperScriptBuilder
argument_list|(
name|containerIdStr
argument_list|,
name|containerWorkDir
argument_list|)
else|:
operator|new
name|UnixLocalWrapperScriptBuilder
argument_list|(
name|containerWorkDir
argument_list|)
return|;
block|}
comment|/**    * This class is a utility to create a wrapper script that is platform    * appropriate.    */
DECL|class|LocalWrapperScriptBuilder
specifier|protected
specifier|abstract
class|class
name|LocalWrapperScriptBuilder
block|{
DECL|field|wrapperScriptPath
specifier|private
specifier|final
name|Path
name|wrapperScriptPath
decl_stmt|;
comment|/**      * Return the path for the wrapper script.      *      * @return the path for the wrapper script      */
DECL|method|getWrapperScriptPath ()
specifier|public
name|Path
name|getWrapperScriptPath
parameter_list|()
block|{
return|return
name|wrapperScriptPath
return|;
block|}
comment|/**      * Write out the wrapper script for the container launch script. This method      * will create the script at the configured wrapper script path.      *      * @param launchDst the script to launch      * @param pidFile the file that will hold the PID      * @throws IOException if the wrapper script cannot be created      * @see #getWrapperScriptPath      */
DECL|method|writeLocalWrapperScript (Path launchDst, Path pidFile)
specifier|public
name|void
name|writeLocalWrapperScript
parameter_list|(
name|Path
name|launchDst
parameter_list|,
name|Path
name|pidFile
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|DataOutputStream
name|out
init|=
name|lfs
operator|.
name|create
argument_list|(
name|wrapperScriptPath
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|CREATE
argument_list|,
name|OVERWRITE
argument_list|)
argument_list|)
init|;
name|PrintStream
name|pout
operator|=
operator|new
name|PrintStream
argument_list|(
name|out
argument_list|,
literal|false
argument_list|,
literal|"UTF-8"
argument_list|)
init|)
block|{
name|writeLocalWrapperScript
argument_list|(
name|launchDst
argument_list|,
name|pidFile
argument_list|,
name|pout
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Write out the wrapper script for the container launch script.      *      * @param launchDst the script to launch      * @param pidFile the file that will hold the PID      * @param pout the stream to use to write out the wrapper script      */
DECL|method|writeLocalWrapperScript (Path launchDst, Path pidFile, PrintStream pout)
specifier|protected
specifier|abstract
name|void
name|writeLocalWrapperScript
parameter_list|(
name|Path
name|launchDst
parameter_list|,
name|Path
name|pidFile
parameter_list|,
name|PrintStream
name|pout
parameter_list|)
function_decl|;
comment|/**      * Create an instance for the given container working directory.      *      * @param containerWorkDir the working directory for the container      */
DECL|method|LocalWrapperScriptBuilder (Path containerWorkDir)
specifier|protected
name|LocalWrapperScriptBuilder
parameter_list|(
name|Path
name|containerWorkDir
parameter_list|)
block|{
name|this
operator|.
name|wrapperScriptPath
operator|=
operator|new
name|Path
argument_list|(
name|containerWorkDir
argument_list|,
name|Shell
operator|.
name|appendScriptExtension
argument_list|(
literal|"default_container_executor"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This class is an instance of {@link LocalWrapperScriptBuilder} for    * non-Windows hosts.    */
DECL|class|UnixLocalWrapperScriptBuilder
specifier|private
specifier|final
class|class
name|UnixLocalWrapperScriptBuilder
extends|extends
name|LocalWrapperScriptBuilder
block|{
DECL|field|sessionScriptPath
specifier|private
specifier|final
name|Path
name|sessionScriptPath
decl_stmt|;
comment|/**      * Create an instance for the given container path.      *      * @param containerWorkDir the container's working directory      */
DECL|method|UnixLocalWrapperScriptBuilder (Path containerWorkDir)
specifier|public
name|UnixLocalWrapperScriptBuilder
parameter_list|(
name|Path
name|containerWorkDir
parameter_list|)
block|{
name|super
argument_list|(
name|containerWorkDir
argument_list|)
expr_stmt|;
name|this
operator|.
name|sessionScriptPath
operator|=
operator|new
name|Path
argument_list|(
name|containerWorkDir
argument_list|,
name|Shell
operator|.
name|appendScriptExtension
argument_list|(
literal|"default_container_executor_session"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeLocalWrapperScript (Path launchDst, Path pidFile)
specifier|public
name|void
name|writeLocalWrapperScript
parameter_list|(
name|Path
name|launchDst
parameter_list|,
name|Path
name|pidFile
parameter_list|)
throws|throws
name|IOException
block|{
name|writeSessionScript
argument_list|(
name|launchDst
argument_list|,
name|pidFile
argument_list|)
expr_stmt|;
name|super
operator|.
name|writeLocalWrapperScript
argument_list|(
name|launchDst
argument_list|,
name|pidFile
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeLocalWrapperScript (Path launchDst, Path pidFile, PrintStream pout)
specifier|public
name|void
name|writeLocalWrapperScript
parameter_list|(
name|Path
name|launchDst
parameter_list|,
name|Path
name|pidFile
parameter_list|,
name|PrintStream
name|pout
parameter_list|)
block|{
name|String
name|exitCodeFile
init|=
name|ContainerLaunch
operator|.
name|getExitCodeFile
argument_list|(
name|pidFile
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|tmpFile
init|=
name|exitCodeFile
operator|+
literal|".tmp"
decl_stmt|;
name|pout
operator|.
name|println
argument_list|(
literal|"#!/bin/bash"
argument_list|)
expr_stmt|;
name|pout
operator|.
name|println
argument_list|(
literal|"/bin/bash \""
operator|+
name|sessionScriptPath
operator|.
name|toString
argument_list|()
operator|+
literal|"\""
argument_list|)
expr_stmt|;
name|pout
operator|.
name|println
argument_list|(
literal|"rc=$?"
argument_list|)
expr_stmt|;
name|pout
operator|.
name|println
argument_list|(
literal|"echo $rc> \""
operator|+
name|tmpFile
operator|+
literal|"\""
argument_list|)
expr_stmt|;
name|pout
operator|.
name|println
argument_list|(
literal|"/bin/mv -f \""
operator|+
name|tmpFile
operator|+
literal|"\" \""
operator|+
name|exitCodeFile
operator|+
literal|"\""
argument_list|)
expr_stmt|;
name|pout
operator|.
name|println
argument_list|(
literal|"exit $rc"
argument_list|)
expr_stmt|;
block|}
DECL|method|writeSessionScript (Path launchDst, Path pidFile)
specifier|private
name|void
name|writeSessionScript
parameter_list|(
name|Path
name|launchDst
parameter_list|,
name|Path
name|pidFile
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|DataOutputStream
name|out
init|=
name|lfs
operator|.
name|create
argument_list|(
name|sessionScriptPath
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|CREATE
argument_list|,
name|OVERWRITE
argument_list|)
argument_list|)
init|;
name|PrintStream
name|pout
operator|=
operator|new
name|PrintStream
argument_list|(
name|out
argument_list|,
literal|false
argument_list|,
literal|"UTF-8"
argument_list|)
init|)
block|{
comment|// We need to do a move as writing to a file is not atomic
comment|// Process reading a file being written to may get garbled data
comment|// hence write pid to tmp file first followed by a mv
name|pout
operator|.
name|println
argument_list|(
literal|"#!/bin/bash"
argument_list|)
expr_stmt|;
name|pout
operator|.
name|println
argument_list|()
expr_stmt|;
name|pout
operator|.
name|println
argument_list|(
literal|"echo $$> "
operator|+
name|pidFile
operator|.
name|toString
argument_list|()
operator|+
literal|".tmp"
argument_list|)
expr_stmt|;
name|pout
operator|.
name|println
argument_list|(
literal|"/bin/mv -f "
operator|+
name|pidFile
operator|.
name|toString
argument_list|()
operator|+
literal|".tmp "
operator|+
name|pidFile
argument_list|)
expr_stmt|;
name|String
name|exec
init|=
name|Shell
operator|.
name|isSetsidAvailable
condition|?
literal|"exec setsid"
else|:
literal|"exec"
decl_stmt|;
name|pout
operator|.
name|printf
argument_list|(
literal|"%s /bin/bash \"%s\""
argument_list|,
name|exec
argument_list|,
name|launchDst
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|lfs
operator|.
name|setPermission
argument_list|(
name|sessionScriptPath
argument_list|,
name|ContainerExecutor
operator|.
name|TASK_LAUNCH_SCRIPT_PERMISSION
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This class is an instance of {@link LocalWrapperScriptBuilder} for    * Windows hosts.    */
DECL|class|WindowsLocalWrapperScriptBuilder
specifier|private
specifier|final
class|class
name|WindowsLocalWrapperScriptBuilder
extends|extends
name|LocalWrapperScriptBuilder
block|{
DECL|field|containerIdStr
specifier|private
specifier|final
name|String
name|containerIdStr
decl_stmt|;
comment|/**      * Create an instance for the given container and working directory.      *      * @param containerIdStr the container ID      * @param containerWorkDir the container's working directory      */
DECL|method|WindowsLocalWrapperScriptBuilder (String containerIdStr, Path containerWorkDir)
specifier|public
name|WindowsLocalWrapperScriptBuilder
parameter_list|(
name|String
name|containerIdStr
parameter_list|,
name|Path
name|containerWorkDir
parameter_list|)
block|{
name|super
argument_list|(
name|containerWorkDir
argument_list|)
expr_stmt|;
name|this
operator|.
name|containerIdStr
operator|=
name|containerIdStr
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeLocalWrapperScript (Path launchDst, Path pidFile, PrintStream pout)
specifier|public
name|void
name|writeLocalWrapperScript
parameter_list|(
name|Path
name|launchDst
parameter_list|,
name|Path
name|pidFile
parameter_list|,
name|PrintStream
name|pout
parameter_list|)
block|{
comment|// TODO: exit code script for Windows
comment|// On Windows, the pid is the container ID, so that it can also serve as
comment|// the name of the job object created by winutils for task management.
comment|// Write to temp file followed by atomic move.
name|String
name|normalizedPidFile
init|=
operator|new
name|File
argument_list|(
name|pidFile
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|pout
operator|.
name|println
argument_list|(
literal|"@echo "
operator|+
name|containerIdStr
operator|+
literal|"> "
operator|+
name|normalizedPidFile
operator|+
literal|".tmp"
argument_list|)
expr_stmt|;
name|pout
operator|.
name|println
argument_list|(
literal|"@move /Y "
operator|+
name|normalizedPidFile
operator|+
literal|".tmp "
operator|+
name|normalizedPidFile
argument_list|)
expr_stmt|;
name|pout
operator|.
name|println
argument_list|(
literal|"@call "
operator|+
name|launchDst
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|signalContainer (ContainerSignalContext ctx)
specifier|public
name|boolean
name|signalContainer
parameter_list|(
name|ContainerSignalContext
name|ctx
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|user
init|=
name|ctx
operator|.
name|getUser
argument_list|()
decl_stmt|;
name|String
name|pid
init|=
name|ctx
operator|.
name|getPid
argument_list|()
decl_stmt|;
name|Signal
name|signal
init|=
name|ctx
operator|.
name|getSignal
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sending signal "
operator|+
name|signal
operator|.
name|getValue
argument_list|()
operator|+
literal|" to pid "
operator|+
name|pid
operator|+
literal|" as user "
operator|+
name|user
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|containerIsAlive
argument_list|(
name|pid
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
try|try
block|{
name|killContainer
argument_list|(
name|pid
argument_list|,
name|signal
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|containerIsAlive
argument_list|(
name|pid
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
throw|throw
name|e
throw|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * No-op for reaping containers within the DefaultContainerExecutor.    *    * @param ctx Encapsulates information necessary for reaping containers.    * @return true given no operations are needed.    */
annotation|@
name|Override
DECL|method|reapContainer (ContainerReapContext ctx)
specifier|public
name|boolean
name|reapContainer
parameter_list|(
name|ContainerReapContext
name|ctx
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|isContainerAlive (ContainerLivenessContext ctx)
specifier|public
name|boolean
name|isContainerAlive
parameter_list|(
name|ContainerLivenessContext
name|ctx
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|pid
init|=
name|ctx
operator|.
name|getPid
argument_list|()
decl_stmt|;
return|return
name|containerIsAlive
argument_list|(
name|pid
argument_list|)
return|;
block|}
comment|/**    * Returns true if the process with the specified pid is alive.    *     * @param pid String pid    * @return boolean true if the process is alive    * @throws IOException if the command to test process liveliness fails    */
annotation|@
name|VisibleForTesting
DECL|method|containerIsAlive (String pid)
specifier|public
specifier|static
name|boolean
name|containerIsAlive
parameter_list|(
name|String
name|pid
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
operator|new
name|ShellCommandExecutor
argument_list|(
name|Shell
operator|.
name|getCheckProcessIsAliveCommand
argument_list|(
name|pid
argument_list|)
argument_list|)
operator|.
name|execute
argument_list|()
expr_stmt|;
comment|// successful execution means process is alive
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|ExitCodeException
name|e
parameter_list|)
block|{
comment|// failure (non-zero exit code) means process is not alive
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Send a specified signal to the specified pid    *    * @param pid the pid of the process [group] to signal.    * @param signal signal to send    * @throws IOException if the command to kill the process fails    */
DECL|method|killContainer (String pid, Signal signal)
specifier|protected
name|void
name|killContainer
parameter_list|(
name|String
name|pid
parameter_list|,
name|Signal
name|signal
parameter_list|)
throws|throws
name|IOException
block|{
operator|new
name|ShellCommandExecutor
argument_list|(
name|Shell
operator|.
name|getSignalKillCommand
argument_list|(
name|signal
operator|.
name|getValue
argument_list|()
argument_list|,
name|pid
argument_list|)
argument_list|)
operator|.
name|execute
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|deleteAsUser (DeletionAsUserContext ctx)
specifier|public
name|void
name|deleteAsUser
parameter_list|(
name|DeletionAsUserContext
name|ctx
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|Path
name|subDir
init|=
name|ctx
operator|.
name|getSubDir
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|baseDirs
init|=
name|ctx
operator|.
name|getBasedirs
argument_list|()
decl_stmt|;
if|if
condition|(
name|baseDirs
operator|==
literal|null
operator|||
name|baseDirs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleting absolute path : "
operator|+
name|subDir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lfs
operator|.
name|delete
argument_list|(
name|subDir
argument_list|,
literal|true
argument_list|)
condition|)
block|{
comment|//Maybe retry
name|LOG
operator|.
name|warn
argument_list|(
literal|"delete returned false for path: ["
operator|+
name|subDir
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
for|for
control|(
name|Path
name|baseDir
range|:
name|baseDirs
control|)
block|{
name|Path
name|del
init|=
name|subDir
operator|==
literal|null
condition|?
name|baseDir
else|:
operator|new
name|Path
argument_list|(
name|baseDir
argument_list|,
name|subDir
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleting path : "
operator|+
name|del
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|lfs
operator|.
name|delete
argument_list|(
name|del
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"delete returned false for path: ["
operator|+
name|del
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
continue|continue;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|symLink (String target, String symlink)
specifier|public
name|void
name|symLink
parameter_list|(
name|String
name|target
parameter_list|,
name|String
name|symlink
parameter_list|)
throws|throws
name|IOException
block|{
name|FileUtil
operator|.
name|symLink
argument_list|(
name|target
argument_list|,
name|symlink
argument_list|)
expr_stmt|;
block|}
comment|/**    * Permissions for user dir.    * $local.dir/usercache/$user    */
DECL|field|USER_PERM
specifier|static
specifier|final
name|short
name|USER_PERM
init|=
operator|(
name|short
operator|)
literal|0750
decl_stmt|;
comment|/**    * Permissions for user appcache dir.    * $local.dir/usercache/$user/appcache    */
DECL|field|APPCACHE_PERM
specifier|static
specifier|final
name|short
name|APPCACHE_PERM
init|=
operator|(
name|short
operator|)
literal|0710
decl_stmt|;
comment|/**    * Permissions for user filecache dir.    * $local.dir/usercache/$user/filecache    */
DECL|field|FILECACHE_PERM
specifier|static
specifier|final
name|short
name|FILECACHE_PERM
init|=
operator|(
name|short
operator|)
literal|0710
decl_stmt|;
comment|/**    * Permissions for user app dir.    * $local.dir/usercache/$user/appcache/$appId    */
DECL|field|APPDIR_PERM
specifier|static
specifier|final
name|short
name|APPDIR_PERM
init|=
operator|(
name|short
operator|)
literal|0710
decl_stmt|;
DECL|method|getDiskFreeSpace (Path base)
specifier|private
name|long
name|getDiskFreeSpace
parameter_list|(
name|Path
name|base
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|lfs
operator|.
name|getFsStatus
argument_list|(
name|base
argument_list|)
operator|.
name|getRemaining
argument_list|()
return|;
block|}
DECL|method|getApplicationDir (Path base, String user, String appId)
specifier|private
name|Path
name|getApplicationDir
parameter_list|(
name|Path
name|base
parameter_list|,
name|String
name|user
parameter_list|,
name|String
name|appId
parameter_list|)
block|{
return|return
operator|new
name|Path
argument_list|(
name|getAppcacheDir
argument_list|(
name|base
argument_list|,
name|user
argument_list|)
argument_list|,
name|appId
argument_list|)
return|;
block|}
DECL|method|getUserCacheDir (Path base, String user)
specifier|private
name|Path
name|getUserCacheDir
parameter_list|(
name|Path
name|base
parameter_list|,
name|String
name|user
parameter_list|)
block|{
return|return
operator|new
name|Path
argument_list|(
operator|new
name|Path
argument_list|(
name|base
argument_list|,
name|ContainerLocalizer
operator|.
name|USERCACHE
argument_list|)
argument_list|,
name|user
argument_list|)
return|;
block|}
DECL|method|getAppcacheDir (Path base, String user)
specifier|private
name|Path
name|getAppcacheDir
parameter_list|(
name|Path
name|base
parameter_list|,
name|String
name|user
parameter_list|)
block|{
return|return
operator|new
name|Path
argument_list|(
name|getUserCacheDir
argument_list|(
name|base
argument_list|,
name|user
argument_list|)
argument_list|,
name|ContainerLocalizer
operator|.
name|APPCACHE
argument_list|)
return|;
block|}
DECL|method|getFileCacheDir (Path base, String user)
specifier|private
name|Path
name|getFileCacheDir
parameter_list|(
name|Path
name|base
parameter_list|,
name|String
name|user
parameter_list|)
block|{
return|return
operator|new
name|Path
argument_list|(
name|getUserCacheDir
argument_list|(
name|base
argument_list|,
name|user
argument_list|)
argument_list|,
name|ContainerLocalizer
operator|.
name|FILECACHE
argument_list|)
return|;
block|}
comment|/**    * Return a randomly chosen application directory from a list of local storage    * directories. The probability of selecting a directory is proportional to    * its size.    *    * @param localDirs the target directories from which to select    * @param user the user who owns the application    * @param appId the application ID    * @return the selected directory    * @throws IOException if no application directories for the user can be    * found    */
DECL|method|getWorkingDir (List<String> localDirs, String user, String appId)
specifier|protected
name|Path
name|getWorkingDir
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|localDirs
parameter_list|,
name|String
name|user
parameter_list|,
name|String
name|appId
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|totalAvailable
init|=
literal|0L
decl_stmt|;
name|long
index|[]
name|availableOnDisk
init|=
operator|new
name|long
index|[
name|localDirs
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|// randomly choose the app directory
comment|// the chance of picking a directory is proportional to
comment|// the available space on the directory.
comment|// firstly calculate the sum of all available space on these directories
for|for
control|(
name|String
name|localDir
range|:
name|localDirs
control|)
block|{
name|Path
name|curBase
init|=
name|getApplicationDir
argument_list|(
operator|new
name|Path
argument_list|(
name|localDir
argument_list|)
argument_list|,
name|user
argument_list|,
name|appId
argument_list|)
decl_stmt|;
name|long
name|space
init|=
literal|0L
decl_stmt|;
try|try
block|{
name|space
operator|=
name|getDiskFreeSpace
argument_list|(
name|curBase
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to get Free Space for "
operator|+
name|curBase
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|availableOnDisk
index|[
name|i
operator|++
index|]
operator|=
name|space
expr_stmt|;
name|totalAvailable
operator|+=
name|space
expr_stmt|;
block|}
comment|// throw an IOException if totalAvailable is 0.
if|if
condition|(
name|totalAvailable
operator|<=
literal|0L
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not able to find a working directory for "
operator|+
name|user
argument_list|)
throw|;
block|}
comment|// make probability to pick a directory proportional to
comment|// the available space on the directory.
name|long
name|randomPosition
init|=
name|RandomUtils
operator|.
name|nextLong
argument_list|()
operator|%
name|totalAvailable
decl_stmt|;
name|int
name|dir
init|=
name|pickDirectory
argument_list|(
name|randomPosition
argument_list|,
name|availableOnDisk
argument_list|)
decl_stmt|;
return|return
name|getApplicationDir
argument_list|(
operator|new
name|Path
argument_list|(
name|localDirs
operator|.
name|get
argument_list|(
name|dir
argument_list|)
argument_list|)
argument_list|,
name|user
argument_list|,
name|appId
argument_list|)
return|;
block|}
comment|/**    * Picks a directory based on the input random number and    * available size at each dir.    */
annotation|@
name|Private
annotation|@
name|VisibleForTesting
DECL|method|pickDirectory (long randomPosition, final long[] availableOnDisk)
name|int
name|pickDirectory
parameter_list|(
name|long
name|randomPosition
parameter_list|,
specifier|final
name|long
index|[]
name|availableOnDisk
parameter_list|)
block|{
name|int
name|dir
init|=
literal|0
decl_stmt|;
comment|// skip zero available space directory,
comment|// because totalAvailable is greater than 0 and randomPosition
comment|// is less than totalAvailable, we can find a valid directory
comment|// with nonzero available space.
while|while
condition|(
name|availableOnDisk
index|[
name|dir
index|]
operator|==
literal|0L
condition|)
block|{
name|dir
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|randomPosition
operator|>=
name|availableOnDisk
index|[
name|dir
index|]
condition|)
block|{
name|randomPosition
operator|-=
name|availableOnDisk
index|[
name|dir
operator|++
index|]
expr_stmt|;
block|}
return|return
name|dir
return|;
block|}
comment|/**    * Use the {@link #lfs} {@link FileContext} to create the target directory.    *    * @param dirPath the target directory    * @param perms the target permissions for the target directory    * @param createParent whether the parent directories should also be created    * @param user the user as whom the target directory should be created.    * Used only on secure Windows hosts.    * @throws IOException if there's a failure performing a file operation    * @see WindowsSecureContainerExecutor    */
DECL|method|createDir (Path dirPath, FsPermission perms, boolean createParent, String user)
specifier|protected
name|void
name|createDir
parameter_list|(
name|Path
name|dirPath
parameter_list|,
name|FsPermission
name|perms
parameter_list|,
name|boolean
name|createParent
parameter_list|,
name|String
name|user
parameter_list|)
throws|throws
name|IOException
block|{
name|lfs
operator|.
name|mkdir
argument_list|(
name|dirPath
argument_list|,
name|perms
argument_list|,
name|createParent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|perms
operator|.
name|equals
argument_list|(
name|perms
operator|.
name|applyUMask
argument_list|(
name|lfs
operator|.
name|getUMask
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
name|lfs
operator|.
name|setPermission
argument_list|(
name|dirPath
argument_list|,
name|perms
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Initialize the local directories for a particular user.    *<ul>.mkdir    *<li>$local.dir/usercache/$user</li>    *</ul>    *    * @param localDirs the target directories to create    * @param user the user whose local cache directories should be initialized    * @throws IOException if there's an issue initializing the user local    * directories    */
DECL|method|createUserLocalDirs (List<String> localDirs, String user)
name|void
name|createUserLocalDirs
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|localDirs
parameter_list|,
name|String
name|user
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|userDirStatus
init|=
literal|false
decl_stmt|;
name|FsPermission
name|userperms
init|=
operator|new
name|FsPermission
argument_list|(
name|USER_PERM
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|localDir
range|:
name|localDirs
control|)
block|{
comment|// create $local.dir/usercache/$user and its immediate parent
try|try
block|{
name|createDir
argument_list|(
name|getUserCacheDir
argument_list|(
operator|new
name|Path
argument_list|(
name|localDir
argument_list|)
argument_list|,
name|user
argument_list|)
argument_list|,
name|userperms
argument_list|,
literal|true
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to create the user directory : "
operator|+
name|localDir
argument_list|,
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|userDirStatus
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|userDirStatus
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not able to initialize user directories "
operator|+
literal|"in any of the configured local directories for user "
operator|+
name|user
argument_list|)
throw|;
block|}
block|}
comment|/**    * Initialize the local cache directories for a particular user.    *<ul>    *<li>$local.dir/usercache/$user</li>    *<li>$local.dir/usercache/$user/appcache</li>    *<li>$local.dir/usercache/$user/filecache</li>    *</ul>    *    * @param localDirs the target directories to create    * @param user the user whose local cache directories should be initialized    * @throws IOException if there's an issue initializing the cache    * directories    */
DECL|method|createUserCacheDirs (List<String> localDirs, String user)
name|void
name|createUserCacheDirs
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|localDirs
parameter_list|,
name|String
name|user
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Initializing user "
operator|+
name|user
argument_list|)
expr_stmt|;
name|boolean
name|appcacheDirStatus
init|=
literal|false
decl_stmt|;
name|boolean
name|distributedCacheDirStatus
init|=
literal|false
decl_stmt|;
name|FsPermission
name|appCachePerms
init|=
operator|new
name|FsPermission
argument_list|(
name|APPCACHE_PERM
argument_list|)
decl_stmt|;
name|FsPermission
name|fileperms
init|=
operator|new
name|FsPermission
argument_list|(
name|FILECACHE_PERM
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|localDir
range|:
name|localDirs
control|)
block|{
comment|// create $local.dir/usercache/$user/appcache
name|Path
name|localDirPath
init|=
operator|new
name|Path
argument_list|(
name|localDir
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|appDir
init|=
name|getAppcacheDir
argument_list|(
name|localDirPath
argument_list|,
name|user
argument_list|)
decl_stmt|;
try|try
block|{
name|createDir
argument_list|(
name|appDir
argument_list|,
name|appCachePerms
argument_list|,
literal|true
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|appcacheDirStatus
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to create app cache directory : "
operator|+
name|appDir
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// create $local.dir/usercache/$user/filecache
specifier|final
name|Path
name|distDir
init|=
name|getFileCacheDir
argument_list|(
name|localDirPath
argument_list|,
name|user
argument_list|)
decl_stmt|;
try|try
block|{
name|createDir
argument_list|(
name|distDir
argument_list|,
name|fileperms
argument_list|,
literal|true
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|distributedCacheDirStatus
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to create file cache directory : "
operator|+
name|distDir
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|appcacheDirStatus
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not able to initialize app-cache directories "
operator|+
literal|"in any of the configured local directories for user "
operator|+
name|user
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|distributedCacheDirStatus
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not able to initialize distributed-cache directories "
operator|+
literal|"in any of the configured local directories for user "
operator|+
name|user
argument_list|)
throw|;
block|}
block|}
comment|/**    * Initialize the local directories for a particular user.    *<ul>    *<li>$local.dir/usercache/$user/appcache/$appid</li>    *</ul>    *    * @param localDirs the target directories to create    * @param user the user whose local cache directories should be initialized    * @param appId the application ID    * @throws IOException if there's an issue initializing the application    * directories    */
DECL|method|createAppDirs (List<String> localDirs, String user, String appId)
name|void
name|createAppDirs
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|localDirs
parameter_list|,
name|String
name|user
parameter_list|,
name|String
name|appId
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|initAppDirStatus
init|=
literal|false
decl_stmt|;
name|FsPermission
name|appperms
init|=
operator|new
name|FsPermission
argument_list|(
name|APPDIR_PERM
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|localDir
range|:
name|localDirs
control|)
block|{
name|Path
name|fullAppDir
init|=
name|getApplicationDir
argument_list|(
operator|new
name|Path
argument_list|(
name|localDir
argument_list|)
argument_list|,
name|user
argument_list|,
name|appId
argument_list|)
decl_stmt|;
comment|// create $local.dir/usercache/$user/appcache/$appId
try|try
block|{
name|createDir
argument_list|(
name|fullAppDir
argument_list|,
name|appperms
argument_list|,
literal|true
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|initAppDirStatus
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to create app directory "
operator|+
name|fullAppDir
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|initAppDirStatus
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not able to initialize app directories "
operator|+
literal|"in any of the configured local directories for app "
operator|+
name|appId
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Create application log directories on all disks.    *    * @param appId the application ID    * @param logDirs the target directories to create    * @param user the user whose local cache directories should be initialized    * @throws IOException if there's an issue initializing the application log    * directories    */
DECL|method|createAppLogDirs (String appId, List<String> logDirs, String user)
name|void
name|createAppLogDirs
parameter_list|(
name|String
name|appId
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|logDirs
parameter_list|,
name|String
name|user
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|appLogDirStatus
init|=
literal|false
decl_stmt|;
name|FsPermission
name|appLogDirPerms
init|=
operator|new
name|FsPermission
argument_list|(
name|getLogDirPermissions
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|rootLogDir
range|:
name|logDirs
control|)
block|{
comment|// create $log.dir/$appid
name|Path
name|appLogDir
init|=
operator|new
name|Path
argument_list|(
name|rootLogDir
argument_list|,
name|appId
argument_list|)
decl_stmt|;
try|try
block|{
name|createDir
argument_list|(
name|appLogDir
argument_list|,
name|appLogDirPerms
argument_list|,
literal|true
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to create the app-log directory : "
operator|+
name|appLogDir
argument_list|,
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|appLogDirStatus
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|appLogDirStatus
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not able to initialize app-log directories "
operator|+
literal|"in any of the configured local directories for app "
operator|+
name|appId
argument_list|)
throw|;
block|}
block|}
comment|/**    * Create application log directories on all disks.    *    * @param appId the application ID    * @param containerId the container ID    * @param logDirs the target directories to create    * @param user the user as whom the directories should be created.    * Used only on secure Windows hosts.    * @throws IOException if there's an issue initializing the container log    * directories    */
DECL|method|createContainerLogDirs (String appId, String containerId, List<String> logDirs, String user)
name|void
name|createContainerLogDirs
parameter_list|(
name|String
name|appId
parameter_list|,
name|String
name|containerId
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|logDirs
parameter_list|,
name|String
name|user
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|containerLogDirStatus
init|=
literal|false
decl_stmt|;
name|FsPermission
name|containerLogDirPerms
init|=
operator|new
name|FsPermission
argument_list|(
name|getLogDirPermissions
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|rootLogDir
range|:
name|logDirs
control|)
block|{
comment|// create $log.dir/$appid/$containerid
name|Path
name|appLogDir
init|=
operator|new
name|Path
argument_list|(
name|rootLogDir
argument_list|,
name|appId
argument_list|)
decl_stmt|;
name|Path
name|containerLogDir
init|=
operator|new
name|Path
argument_list|(
name|appLogDir
argument_list|,
name|containerId
argument_list|)
decl_stmt|;
try|try
block|{
name|createDir
argument_list|(
name|containerLogDir
argument_list|,
name|containerLogDirPerms
argument_list|,
literal|true
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to create the container-log directory : "
operator|+
name|appLogDir
argument_list|,
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|containerLogDirStatus
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|containerLogDirStatus
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Not able to initialize container-log directories "
operator|+
literal|"in any of the configured local directories for container "
operator|+
name|containerId
argument_list|)
throw|;
block|}
block|}
comment|/**    * Return the default container log directory permissions.    *    * @return the default container log directory permissions    */
annotation|@
name|VisibleForTesting
DECL|method|getLogDirPermissions ()
specifier|public
name|String
name|getLogDirPermissions
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|logDirPermissions
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|logDirPermissions
operator|=
name|getConf
argument_list|()
operator|.
name|get
argument_list|(
name|YarnConfiguration
operator|.
name|NM_DEFAULT_CONTAINER_EXECUTOR_LOG_DIRS_PERMISSIONS
argument_list|,
name|YarnConfiguration
operator|.
name|NM_DEFAULT_CONTAINER_EXECUTOR_LOG_DIRS_PERMISSIONS_DEFAULT
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|logDirPermissions
return|;
block|}
comment|/**    * Clear the internal variable for repeatable testing.    */
annotation|@
name|VisibleForTesting
DECL|method|clearLogDirPermissions ()
specifier|public
name|void
name|clearLogDirPermissions
parameter_list|()
block|{
name|this
operator|.
name|logDirPermissions
operator|=
literal|null
expr_stmt|;
block|}
comment|/**    *    * @param ctx Encapsulates information necessary for exec containers.    * @return the input/output stream of interactive docker shell.    * @throws ContainerExecutionException    */
annotation|@
name|Override
DECL|method|execContainer (ContainerExecContext ctx)
specifier|public
name|IOStreamPair
name|execContainer
parameter_list|(
name|ContainerExecContext
name|ctx
parameter_list|)
throws|throws
name|ContainerExecutionException
block|{
return|return
literal|null
return|;
block|}
comment|/**    * Return the list of paths of given local directories.    *    * @return the list of paths of given local directories    */
DECL|method|getPaths (List<String> dirs)
specifier|private
specifier|static
name|List
argument_list|<
name|Path
argument_list|>
name|getPaths
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|dirs
parameter_list|)
block|{
name|List
argument_list|<
name|Path
argument_list|>
name|paths
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|dirs
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dirs
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|paths
operator|.
name|add
argument_list|(
operator|new
name|Path
argument_list|(
name|dirs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|paths
return|;
block|}
block|}
end_class

end_unit

