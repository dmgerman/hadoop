begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.nodemanager.containermanager.queuing
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|queuing
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentLinkedQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|StartContainerRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerExitStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerLaunchContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ExecutionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ResourceUtilization
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|event
operator|.
name|EventHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|security
operator|.
name|ContainerTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|security
operator|.
name|NMTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|ContainerExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|DeletionService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|LocalDirsHandlerService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|NodeStatusUpdater
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|ContainerManagerImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|application
operator|.
name|ApplicationContainerFinishedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|application
operator|.
name|ApplicationEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|application
operator|.
name|ApplicationEventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|container
operator|.
name|Container
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|monitor
operator|.
name|ContainersMonitorImpl
operator|.
name|ProcessTreeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|metrics
operator|.
name|NodeManagerMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|recovery
operator|.
name|NMStateStoreService
operator|.
name|RecoveredContainerState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|recovery
operator|.
name|NMStateStoreService
operator|.
name|RecoveredContainerStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|utils
operator|.
name|BuilderUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * Class extending {@link ContainerManagerImpl} and is used when queuing at the  * NM is enabled.  */
end_comment

begin_class
DECL|class|QueuingContainerManagerImpl
specifier|public
class|class
name|QueuingContainerManagerImpl
extends|extends
name|ContainerManagerImpl
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|QueuingContainerManagerImpl
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|private
name|ConcurrentMap
argument_list|<
name|ContainerId
argument_list|,
name|AllocatedContainerInfo
argument_list|>
DECL|field|allocatedGuaranteedContainers
name|allocatedGuaranteedContainers
decl_stmt|;
specifier|private
name|ConcurrentMap
argument_list|<
name|ContainerId
argument_list|,
name|AllocatedContainerInfo
argument_list|>
DECL|field|allocatedOpportunisticContainers
name|allocatedOpportunisticContainers
decl_stmt|;
DECL|field|queuedGuaranteedContainers
specifier|private
name|Queue
argument_list|<
name|AllocatedContainerInfo
argument_list|>
name|queuedGuaranteedContainers
decl_stmt|;
DECL|field|queuedOpportunisticContainers
specifier|private
name|Queue
argument_list|<
name|AllocatedContainerInfo
argument_list|>
name|queuedOpportunisticContainers
decl_stmt|;
DECL|field|opportunisticContainersToKill
specifier|private
name|Set
argument_list|<
name|ContainerId
argument_list|>
name|opportunisticContainersToKill
decl_stmt|;
DECL|method|QueuingContainerManagerImpl (Context context, ContainerExecutor exec, DeletionService deletionContext, NodeStatusUpdater nodeStatusUpdater, NodeManagerMetrics metrics, LocalDirsHandlerService dirsHandler)
specifier|public
name|QueuingContainerManagerImpl
parameter_list|(
name|Context
name|context
parameter_list|,
name|ContainerExecutor
name|exec
parameter_list|,
name|DeletionService
name|deletionContext
parameter_list|,
name|NodeStatusUpdater
name|nodeStatusUpdater
parameter_list|,
name|NodeManagerMetrics
name|metrics
parameter_list|,
name|LocalDirsHandlerService
name|dirsHandler
parameter_list|)
block|{
name|super
argument_list|(
name|context
argument_list|,
name|exec
argument_list|,
name|deletionContext
argument_list|,
name|nodeStatusUpdater
argument_list|,
name|metrics
argument_list|,
name|dirsHandler
argument_list|)
expr_stmt|;
name|this
operator|.
name|allocatedGuaranteedContainers
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|allocatedOpportunisticContainers
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|queuedGuaranteedContainers
operator|=
operator|new
name|ConcurrentLinkedQueue
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|queuedOpportunisticContainers
operator|=
operator|new
name|ConcurrentLinkedQueue
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|opportunisticContainersToKill
operator|=
name|Collections
operator|.
name|synchronizedSet
argument_list|(
operator|new
name|HashSet
argument_list|<
name|ContainerId
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|createApplicationEventDispatcher ()
specifier|protected
name|EventHandler
argument_list|<
name|ApplicationEvent
argument_list|>
name|createApplicationEventDispatcher
parameter_list|()
block|{
return|return
operator|new
name|QueuingApplicationEventDispatcher
argument_list|(
name|super
operator|.
name|createApplicationEventDispatcher
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|startContainerInternal ( ContainerTokenIdentifier containerTokenIdentifier, StartContainerRequest request)
specifier|protected
name|void
name|startContainerInternal
parameter_list|(
name|ContainerTokenIdentifier
name|containerTokenIdentifier
parameter_list|,
name|StartContainerRequest
name|request
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|this
operator|.
name|context
operator|.
name|getQueuingContext
argument_list|()
operator|.
name|getQueuedContainers
argument_list|()
operator|.
name|put
argument_list|(
name|containerTokenIdentifier
operator|.
name|getContainerID
argument_list|()
argument_list|,
name|containerTokenIdentifier
argument_list|)
expr_stmt|;
name|AllocatedContainerInfo
name|allocatedContInfo
init|=
operator|new
name|AllocatedContainerInfo
argument_list|(
name|containerTokenIdentifier
argument_list|,
name|request
argument_list|,
name|containerTokenIdentifier
operator|.
name|getExecutionType
argument_list|()
argument_list|,
name|containerTokenIdentifier
operator|.
name|getResource
argument_list|()
argument_list|,
name|getConfig
argument_list|()
argument_list|)
decl_stmt|;
comment|// If there are already free resources for the container to start, and
comment|// there are no queued containers waiting to be executed, start this
comment|// container immediately.
if|if
condition|(
name|queuedGuaranteedContainers
operator|.
name|isEmpty
argument_list|()
operator|&&
name|queuedOpportunisticContainers
operator|.
name|isEmpty
argument_list|()
operator|&&
name|getContainersMonitor
argument_list|()
operator|.
name|hasResourcesAvailable
argument_list|(
name|allocatedContInfo
operator|.
name|getPti
argument_list|()
argument_list|)
condition|)
block|{
name|startAllocatedContainer
argument_list|(
name|allocatedContInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|context
operator|.
name|getNMStateStore
argument_list|()
operator|.
name|storeContainer
argument_list|(
name|containerTokenIdentifier
operator|.
name|getContainerID
argument_list|()
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|this
operator|.
name|context
operator|.
name|getNMStateStore
argument_list|()
operator|.
name|storeContainerQueued
argument_list|(
name|containerTokenIdentifier
operator|.
name|getContainerID
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocatedContInfo
operator|.
name|getExecutionType
argument_list|()
operator|==
name|ExecutionType
operator|.
name|GUARANTEED
condition|)
block|{
name|queuedGuaranteedContainers
operator|.
name|add
argument_list|(
name|allocatedContInfo
argument_list|)
expr_stmt|;
comment|// Kill running opportunistic containers to make space for
comment|// guaranteed container.
name|killOpportunisticContainers
argument_list|(
name|allocatedContInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|queuedOpportunisticContainers
operator|.
name|add
argument_list|(
name|allocatedContInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|stopContainerInternal (ContainerId containerID)
specifier|protected
name|void
name|stopContainerInternal
parameter_list|(
name|ContainerId
name|containerID
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|Container
name|container
init|=
name|this
operator|.
name|context
operator|.
name|getContainers
argument_list|()
operator|.
name|get
argument_list|(
name|containerID
argument_list|)
decl_stmt|;
comment|// If container is null and distributed scheduling is enabled, container
comment|// might be queued. Otherwise, container might not be handled by this NM.
if|if
condition|(
name|container
operator|==
literal|null
operator|&&
name|this
operator|.
name|context
operator|.
name|getQueuingContext
argument_list|()
operator|.
name|getQueuedContainers
argument_list|()
operator|.
name|containsKey
argument_list|(
name|containerID
argument_list|)
condition|)
block|{
name|ContainerTokenIdentifier
name|containerTokenId
init|=
name|this
operator|.
name|context
operator|.
name|getQueuingContext
argument_list|()
operator|.
name|getQueuedContainers
argument_list|()
operator|.
name|remove
argument_list|(
name|containerID
argument_list|)
decl_stmt|;
name|boolean
name|foundInQueue
init|=
name|removeQueuedContainer
argument_list|(
name|containerID
argument_list|,
name|containerTokenId
operator|.
name|getExecutionType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|foundInQueue
condition|)
block|{
name|this
operator|.
name|context
operator|.
name|getQueuingContext
argument_list|()
operator|.
name|getKilledQueuedContainers
argument_list|()
operator|.
name|put
argument_list|(
name|containerTokenId
argument_list|,
literal|"Queued container request removed by ApplicationMaster."
argument_list|)
expr_stmt|;
name|this
operator|.
name|context
operator|.
name|getNMStateStore
argument_list|()
operator|.
name|storeContainerKilled
argument_list|(
name|containerID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The container started execution in the meanwhile.
try|try
block|{
name|stopContainerInternalIfRunning
argument_list|(
name|containerID
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|YarnException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Container did not get removed successfully."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|nodeStatusUpdater
operator|.
name|sendOutofBandHeartBeat
argument_list|()
expr_stmt|;
block|}
name|super
operator|.
name|stopContainerInternal
argument_list|(
name|containerID
argument_list|)
expr_stmt|;
block|}
comment|/**    * Start the execution of the given container. Also add it to the allocated    * containers, and update allocated resource utilization.    */
DECL|method|startAllocatedContainer ( AllocatedContainerInfo allocatedContainerInfo)
specifier|private
name|void
name|startAllocatedContainer
parameter_list|(
name|AllocatedContainerInfo
name|allocatedContainerInfo
parameter_list|)
block|{
name|ProcessTreeInfo
name|pti
init|=
name|allocatedContainerInfo
operator|.
name|getPti
argument_list|()
decl_stmt|;
if|if
condition|(
name|allocatedContainerInfo
operator|.
name|getExecutionType
argument_list|()
operator|==
name|ExecutionType
operator|.
name|GUARANTEED
condition|)
block|{
name|allocatedGuaranteedContainers
operator|.
name|put
argument_list|(
name|pti
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|allocatedContainerInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allocatedOpportunisticContainers
operator|.
name|put
argument_list|(
name|pti
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|allocatedContainerInfo
argument_list|)
expr_stmt|;
block|}
name|getContainersMonitor
argument_list|()
operator|.
name|increaseContainersAllocation
argument_list|(
name|pti
argument_list|)
expr_stmt|;
comment|// Start execution of container.
name|ContainerId
name|containerId
init|=
name|allocatedContainerInfo
operator|.
name|getContainerTokenIdentifier
argument_list|()
operator|.
name|getContainerID
argument_list|()
decl_stmt|;
name|this
operator|.
name|context
operator|.
name|getQueuingContext
argument_list|()
operator|.
name|getQueuedContainers
argument_list|()
operator|.
name|remove
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
try|try
block|{
name|super
operator|.
name|startContainerInternal
argument_list|(
name|allocatedContainerInfo
operator|.
name|getContainerTokenIdentifier
argument_list|()
argument_list|,
name|allocatedContainerInfo
operator|.
name|getStartRequest
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|YarnException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|containerFailedToStart
argument_list|(
name|pti
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|allocatedContainerInfo
operator|.
name|getContainerTokenIdentifier
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Container failed to start."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|containerFailedToStart (ContainerId containerId, ContainerTokenIdentifier containerTokenId)
specifier|private
name|void
name|containerFailedToStart
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|ContainerTokenIdentifier
name|containerTokenId
parameter_list|)
block|{
name|this
operator|.
name|context
operator|.
name|getQueuingContext
argument_list|()
operator|.
name|getQueuedContainers
argument_list|()
operator|.
name|remove
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
name|removeAllocatedContainer
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
name|this
operator|.
name|context
operator|.
name|getQueuingContext
argument_list|()
operator|.
name|getKilledQueuedContainers
argument_list|()
operator|.
name|put
argument_list|(
name|containerTokenId
argument_list|,
literal|"Container removed from queue as it failed to start."
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove the given container from the container queues.    *    * @return true if the container was found in one of the queues.    */
DECL|method|removeQueuedContainer (ContainerId containerId, ExecutionType executionType)
specifier|private
name|boolean
name|removeQueuedContainer
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|ExecutionType
name|executionType
parameter_list|)
block|{
name|Queue
argument_list|<
name|AllocatedContainerInfo
argument_list|>
name|queue
init|=
operator|(
name|executionType
operator|==
name|ExecutionType
operator|.
name|GUARANTEED
operator|)
condition|?
name|queuedGuaranteedContainers
else|:
name|queuedOpportunisticContainers
decl_stmt|;
name|boolean
name|foundInQueue
init|=
literal|false
decl_stmt|;
name|Iterator
argument_list|<
name|AllocatedContainerInfo
argument_list|>
name|iter
init|=
name|queue
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
operator|&&
operator|!
name|foundInQueue
condition|)
block|{
if|if
condition|(
name|iter
operator|.
name|next
argument_list|()
operator|.
name|getPti
argument_list|()
operator|.
name|getContainerId
argument_list|()
operator|.
name|equals
argument_list|(
name|containerId
argument_list|)
condition|)
block|{
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
name|foundInQueue
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|foundInQueue
return|;
block|}
comment|/**    * Remove the given container from the allocated containers, and update    * allocated container utilization accordingly.    */
DECL|method|removeAllocatedContainer (ContainerId containerId)
specifier|private
name|void
name|removeAllocatedContainer
parameter_list|(
name|ContainerId
name|containerId
parameter_list|)
block|{
name|AllocatedContainerInfo
name|contToRemove
init|=
literal|null
decl_stmt|;
name|contToRemove
operator|=
name|allocatedGuaranteedContainers
operator|.
name|remove
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
if|if
condition|(
name|contToRemove
operator|==
literal|null
condition|)
block|{
name|contToRemove
operator|=
name|allocatedOpportunisticContainers
operator|.
name|remove
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
block|}
comment|// If container was indeed running, update allocated resource utilization.
if|if
condition|(
name|contToRemove
operator|!=
literal|null
condition|)
block|{
name|getContainersMonitor
argument_list|()
operator|.
name|decreaseContainersAllocation
argument_list|(
name|contToRemove
operator|.
name|getPti
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Stop a container only if it is currently running. If queued, do not stop    * it.    */
DECL|method|stopContainerInternalIfRunning (ContainerId containerID)
specifier|private
name|void
name|stopContainerInternalIfRunning
parameter_list|(
name|ContainerId
name|containerID
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|context
operator|.
name|getContainers
argument_list|()
operator|.
name|containsKey
argument_list|(
name|containerID
argument_list|)
condition|)
block|{
name|stopContainerInternal
argument_list|(
name|containerID
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Kill opportunistic containers to free up resources for running the given    * container.    *    * @param allocatedContInfo    *          the container whose execution needs to start by freeing up    *          resources occupied by opportunistic containers.    */
DECL|method|killOpportunisticContainers ( AllocatedContainerInfo allocatedContInfo)
specifier|private
name|void
name|killOpportunisticContainers
parameter_list|(
name|AllocatedContainerInfo
name|allocatedContInfo
parameter_list|)
block|{
name|ContainerId
name|containerToStartId
init|=
name|allocatedContInfo
operator|.
name|getPti
argument_list|()
operator|.
name|getContainerId
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ContainerId
argument_list|>
name|extraOpportContainersToKill
init|=
name|pickOpportunisticContainersToKill
argument_list|(
name|containerToStartId
argument_list|)
decl_stmt|;
comment|// Kill the opportunistic containers that were chosen.
for|for
control|(
name|ContainerId
name|contIdToKill
range|:
name|extraOpportContainersToKill
control|)
block|{
try|try
block|{
name|stopContainerInternalIfRunning
argument_list|(
name|contIdToKill
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|YarnException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Container did not get removed successfully."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Opportunistic container {} will be killed in order to start the "
operator|+
literal|"execution of guaranteed container {}."
argument_list|,
name|contIdToKill
argument_list|,
name|containerToStartId
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Choose the opportunistic containers to kill in order to free up resources    * for running the given container.    *    * @param containerToStartId    *          the container whose execution needs to start by freeing up    *          resources occupied by opportunistic containers.    * @return the additional opportunistic containers that need to be killed.    */
DECL|method|pickOpportunisticContainersToKill ( ContainerId containerToStartId)
specifier|protected
name|List
argument_list|<
name|ContainerId
argument_list|>
name|pickOpportunisticContainersToKill
parameter_list|(
name|ContainerId
name|containerToStartId
parameter_list|)
block|{
comment|// The additional opportunistic containers that need to be killed for the
comment|// given container to start.
name|List
argument_list|<
name|ContainerId
argument_list|>
name|extraOpportContainersToKill
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Track resources that need to be freed.
name|ResourceUtilization
name|resourcesToFreeUp
init|=
name|resourcesToFreeUp
argument_list|(
name|containerToStartId
argument_list|)
decl_stmt|;
comment|// Go over the running opportunistic containers. Avoid containers that have
comment|// already been marked for killing.
name|boolean
name|hasSufficientResources
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ContainerId
argument_list|,
name|AllocatedContainerInfo
argument_list|>
name|runningOpportCont
range|:
name|allocatedOpportunisticContainers
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ContainerId
name|runningOpportContId
init|=
name|runningOpportCont
operator|.
name|getKey
argument_list|()
decl_stmt|;
comment|// If there are sufficient resources to execute the given container, do
comment|// not kill more opportunistic containers.
if|if
condition|(
name|resourcesToFreeUp
operator|.
name|getPhysicalMemory
argument_list|()
operator|<=
literal|0
operator|&&
name|resourcesToFreeUp
operator|.
name|getVirtualMemory
argument_list|()
operator|<=
literal|0
operator|&&
name|resourcesToFreeUp
operator|.
name|getCPU
argument_list|()
operator|<=
literal|0.0f
condition|)
block|{
name|hasSufficientResources
operator|=
literal|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|opportunisticContainersToKill
operator|.
name|contains
argument_list|(
name|runningOpportContId
argument_list|)
condition|)
block|{
name|extraOpportContainersToKill
operator|.
name|add
argument_list|(
name|runningOpportContId
argument_list|)
expr_stmt|;
name|opportunisticContainersToKill
operator|.
name|add
argument_list|(
name|runningOpportContId
argument_list|)
expr_stmt|;
name|getContainersMonitor
argument_list|()
operator|.
name|decreaseResourceUtilization
argument_list|(
name|resourcesToFreeUp
argument_list|,
name|runningOpportCont
operator|.
name|getValue
argument_list|()
operator|.
name|getPti
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hasSufficientResources
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"There are no sufficient resources to start guaranteed {} even after "
operator|+
literal|"attempting to kill any running opportunistic containers."
argument_list|,
name|containerToStartId
argument_list|)
expr_stmt|;
block|}
return|return
name|extraOpportContainersToKill
return|;
block|}
comment|/**    * Calculates the amount of resources that need to be freed up (by killing    * opportunistic containers) in order for the given guaranteed container to    * start its execution. Resource allocation to be freed up =    *<code>containersAllocation</code> -    *   allocation of<code>opportunisticContainersToKill</code> +    *   allocation of<code>queuedGuaranteedContainers</code> that will start    *     before the given container +    *   allocation of given container -    *   total resources of node.    *    * @param containerToStartId    *          the ContainerId of the guaranteed container for which we need to    *          free resources, so that its execution can start.    * @return the resources that need to be freed up for the given guaranteed    *         container to start.    */
DECL|method|resourcesToFreeUp ( ContainerId containerToStartId)
specifier|private
name|ResourceUtilization
name|resourcesToFreeUp
parameter_list|(
name|ContainerId
name|containerToStartId
parameter_list|)
block|{
comment|// Get allocation of currently allocated containers.
name|ResourceUtilization
name|resourceAllocationToFreeUp
init|=
name|ResourceUtilization
operator|.
name|newInstance
argument_list|(
name|getContainersMonitor
argument_list|()
operator|.
name|getContainersAllocation
argument_list|()
argument_list|)
decl_stmt|;
comment|// Subtract from the allocation the allocation of the opportunistic
comment|// containers that are marked for killing.
for|for
control|(
name|ContainerId
name|opportContId
range|:
name|opportunisticContainersToKill
control|)
block|{
if|if
condition|(
name|allocatedOpportunisticContainers
operator|.
name|containsKey
argument_list|(
name|opportContId
argument_list|)
condition|)
block|{
name|getContainersMonitor
argument_list|()
operator|.
name|decreaseResourceUtilization
argument_list|(
name|resourceAllocationToFreeUp
argument_list|,
name|allocatedOpportunisticContainers
operator|.
name|get
argument_list|(
name|opportContId
argument_list|)
operator|.
name|getPti
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Add to the allocation the allocation of the pending guaranteed
comment|// containers that will start before the current container will be started.
for|for
control|(
name|AllocatedContainerInfo
name|guarContInfo
range|:
name|queuedGuaranteedContainers
control|)
block|{
name|getContainersMonitor
argument_list|()
operator|.
name|increaseResourceUtilization
argument_list|(
name|resourceAllocationToFreeUp
argument_list|,
name|guarContInfo
operator|.
name|getPti
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|guarContInfo
operator|.
name|getPti
argument_list|()
operator|.
name|getContainerId
argument_list|()
operator|.
name|equals
argument_list|(
name|containerToStartId
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
comment|// Subtract the overall node resources.
name|getContainersMonitor
argument_list|()
operator|.
name|subtractNodeResourcesFromResourceUtilization
argument_list|(
name|resourceAllocationToFreeUp
argument_list|)
expr_stmt|;
return|return
name|resourceAllocationToFreeUp
return|;
block|}
comment|/**    * If there are available resources, try to start as many pending containers    * as possible.    */
DECL|method|startPendingContainers ()
specifier|private
name|void
name|startPendingContainers
parameter_list|()
block|{
comment|// Start pending guaranteed containers, if resources available.
name|boolean
name|resourcesAvailable
init|=
name|startContainersFromQueue
argument_list|(
name|queuedGuaranteedContainers
argument_list|)
decl_stmt|;
comment|// Start opportunistic containers, if resources available.
if|if
condition|(
name|resourcesAvailable
condition|)
block|{
name|startContainersFromQueue
argument_list|(
name|queuedOpportunisticContainers
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|startContainersFromQueue ( Queue<AllocatedContainerInfo> queuedContainers)
specifier|private
name|boolean
name|startContainersFromQueue
parameter_list|(
name|Queue
argument_list|<
name|AllocatedContainerInfo
argument_list|>
name|queuedContainers
parameter_list|)
block|{
name|Iterator
argument_list|<
name|AllocatedContainerInfo
argument_list|>
name|guarIter
init|=
name|queuedContainers
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|boolean
name|resourcesAvailable
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|guarIter
operator|.
name|hasNext
argument_list|()
operator|&&
name|resourcesAvailable
condition|)
block|{
name|AllocatedContainerInfo
name|allocatedContInfo
init|=
name|guarIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|getContainersMonitor
argument_list|()
operator|.
name|hasResourcesAvailable
argument_list|(
name|allocatedContInfo
operator|.
name|getPti
argument_list|()
argument_list|)
condition|)
block|{
name|startAllocatedContainer
argument_list|(
name|allocatedContInfo
argument_list|)
expr_stmt|;
name|guarIter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|resourcesAvailable
operator|=
literal|false
expr_stmt|;
block|}
block|}
return|return
name|resourcesAvailable
return|;
block|}
annotation|@
name|Override
DECL|method|getContainerStatusInternal (ContainerId containerID, NMTokenIdentifier nmTokenIdentifier)
specifier|protected
name|ContainerStatus
name|getContainerStatusInternal
parameter_list|(
name|ContainerId
name|containerID
parameter_list|,
name|NMTokenIdentifier
name|nmTokenIdentifier
parameter_list|)
throws|throws
name|YarnException
block|{
name|Container
name|container
init|=
name|this
operator|.
name|context
operator|.
name|getContainers
argument_list|()
operator|.
name|get
argument_list|(
name|containerID
argument_list|)
decl_stmt|;
if|if
condition|(
name|container
operator|==
literal|null
condition|)
block|{
name|ContainerTokenIdentifier
name|containerTokenId
init|=
name|this
operator|.
name|context
operator|.
name|getQueuingContext
argument_list|()
operator|.
name|getQueuedContainers
argument_list|()
operator|.
name|get
argument_list|(
name|containerID
argument_list|)
decl_stmt|;
if|if
condition|(
name|containerTokenId
operator|!=
literal|null
condition|)
block|{
name|ExecutionType
name|executionType
init|=
name|this
operator|.
name|context
operator|.
name|getQueuingContext
argument_list|()
operator|.
name|getQueuedContainers
argument_list|()
operator|.
name|get
argument_list|(
name|containerID
argument_list|)
operator|.
name|getExecutionType
argument_list|()
decl_stmt|;
return|return
name|BuilderUtils
operator|.
name|newContainerStatus
argument_list|(
name|containerID
argument_list|,
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerState
operator|.
name|QUEUED
argument_list|,
literal|""
argument_list|,
name|ContainerExitStatus
operator|.
name|INVALID
argument_list|,
name|this
operator|.
name|context
operator|.
name|getQueuingContext
argument_list|()
operator|.
name|getQueuedContainers
argument_list|()
operator|.
name|get
argument_list|(
name|containerID
argument_list|)
operator|.
name|getResource
argument_list|()
argument_list|,
name|executionType
argument_list|)
return|;
block|}
block|}
return|return
name|super
operator|.
name|getContainerStatusInternal
argument_list|(
name|containerID
argument_list|,
name|nmTokenIdentifier
argument_list|)
return|;
block|}
comment|/**    * Recover running or queued container.    */
annotation|@
name|Override
DECL|method|recoverActiveContainer ( ContainerLaunchContext launchContext, ContainerTokenIdentifier token, RecoveredContainerState rcs)
specifier|protected
name|void
name|recoverActiveContainer
parameter_list|(
name|ContainerLaunchContext
name|launchContext
parameter_list|,
name|ContainerTokenIdentifier
name|token
parameter_list|,
name|RecoveredContainerState
name|rcs
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|rcs
operator|.
name|getStatus
argument_list|()
operator|==
name|RecoveredContainerStatus
operator|.
name|QUEUED
operator|&&
operator|!
name|rcs
operator|.
name|getKilled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|token
operator|.
name|getContainerID
argument_list|()
operator|+
literal|"will be added to the queued containers."
argument_list|)
expr_stmt|;
name|AllocatedContainerInfo
name|allocatedContInfo
init|=
operator|new
name|AllocatedContainerInfo
argument_list|(
name|token
argument_list|,
name|rcs
operator|.
name|getStartRequest
argument_list|()
argument_list|,
name|token
operator|.
name|getExecutionType
argument_list|()
argument_list|,
name|token
operator|.
name|getResource
argument_list|()
argument_list|,
name|getConfig
argument_list|()
argument_list|)
decl_stmt|;
name|this
operator|.
name|context
operator|.
name|getQueuingContext
argument_list|()
operator|.
name|getQueuedContainers
argument_list|()
operator|.
name|put
argument_list|(
name|token
operator|.
name|getContainerID
argument_list|()
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocatedContInfo
operator|.
name|getExecutionType
argument_list|()
operator|==
name|ExecutionType
operator|.
name|GUARANTEED
condition|)
block|{
name|queuedGuaranteedContainers
operator|.
name|add
argument_list|(
name|allocatedContInfo
argument_list|)
expr_stmt|;
comment|// Kill running opportunistic containers to make space for
comment|// guaranteed container.
name|killOpportunisticContainers
argument_list|(
name|allocatedContInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|queuedOpportunisticContainers
operator|.
name|add
argument_list|(
name|allocatedContInfo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|super
operator|.
name|recoverActiveContainer
argument_list|(
name|launchContext
argument_list|,
name|token
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getNumAllocatedGuaranteedContainers ()
specifier|public
name|int
name|getNumAllocatedGuaranteedContainers
parameter_list|()
block|{
return|return
name|allocatedGuaranteedContainers
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getNumAllocatedOpportunisticContainers ()
specifier|public
name|int
name|getNumAllocatedOpportunisticContainers
parameter_list|()
block|{
return|return
name|allocatedOpportunisticContainers
operator|.
name|size
argument_list|()
return|;
block|}
DECL|class|QueuingApplicationEventDispatcher
class|class
name|QueuingApplicationEventDispatcher
implements|implements
name|EventHandler
argument_list|<
name|ApplicationEvent
argument_list|>
block|{
DECL|field|applicationEventDispatcher
specifier|private
name|EventHandler
argument_list|<
name|ApplicationEvent
argument_list|>
name|applicationEventDispatcher
decl_stmt|;
DECL|method|QueuingApplicationEventDispatcher ( EventHandler<ApplicationEvent> applicationEventDispatcher)
specifier|public
name|QueuingApplicationEventDispatcher
parameter_list|(
name|EventHandler
argument_list|<
name|ApplicationEvent
argument_list|>
name|applicationEventDispatcher
parameter_list|)
block|{
name|this
operator|.
name|applicationEventDispatcher
operator|=
name|applicationEventDispatcher
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|handle (ApplicationEvent event)
specifier|public
name|void
name|handle
parameter_list|(
name|ApplicationEvent
name|event
parameter_list|)
block|{
if|if
condition|(
name|event
operator|.
name|getType
argument_list|()
operator|==
name|ApplicationEventType
operator|.
name|APPLICATION_CONTAINER_FINISHED
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|event
operator|instanceof
name|ApplicationContainerFinishedEvent
operator|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unexpected event type: "
operator|+
name|event
argument_list|)
throw|;
block|}
name|ApplicationContainerFinishedEvent
name|finishEvent
init|=
operator|(
name|ApplicationContainerFinishedEvent
operator|)
name|event
decl_stmt|;
comment|// Remove finished container from the allocated containers, and
comment|// attempt to start new containers.
name|ContainerId
name|contIdToRemove
init|=
name|finishEvent
operator|.
name|getContainerID
argument_list|()
decl_stmt|;
name|removeAllocatedContainer
argument_list|(
name|contIdToRemove
argument_list|)
expr_stmt|;
name|opportunisticContainersToKill
operator|.
name|remove
argument_list|(
name|contIdToRemove
argument_list|)
expr_stmt|;
name|startPendingContainers
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|applicationEventDispatcher
operator|.
name|handle
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|AllocatedContainerInfo
specifier|static
class|class
name|AllocatedContainerInfo
block|{
DECL|field|containerTokenIdentifier
specifier|private
specifier|final
name|ContainerTokenIdentifier
name|containerTokenIdentifier
decl_stmt|;
DECL|field|startRequest
specifier|private
specifier|final
name|StartContainerRequest
name|startRequest
decl_stmt|;
DECL|field|executionType
specifier|private
specifier|final
name|ExecutionType
name|executionType
decl_stmt|;
DECL|field|pti
specifier|private
specifier|final
name|ProcessTreeInfo
name|pti
decl_stmt|;
DECL|method|AllocatedContainerInfo (ContainerTokenIdentifier containerTokenIdentifier, StartContainerRequest startRequest, ExecutionType executionType, Resource resource, Configuration conf)
name|AllocatedContainerInfo
parameter_list|(
name|ContainerTokenIdentifier
name|containerTokenIdentifier
parameter_list|,
name|StartContainerRequest
name|startRequest
parameter_list|,
name|ExecutionType
name|executionType
parameter_list|,
name|Resource
name|resource
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|containerTokenIdentifier
operator|=
name|containerTokenIdentifier
expr_stmt|;
name|this
operator|.
name|startRequest
operator|=
name|startRequest
expr_stmt|;
name|this
operator|.
name|executionType
operator|=
name|executionType
expr_stmt|;
name|this
operator|.
name|pti
operator|=
name|createProcessTreeInfo
argument_list|(
name|containerTokenIdentifier
operator|.
name|getContainerID
argument_list|()
argument_list|,
name|resource
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
DECL|method|getContainerTokenIdentifier ()
specifier|private
name|ContainerTokenIdentifier
name|getContainerTokenIdentifier
parameter_list|()
block|{
return|return
name|this
operator|.
name|containerTokenIdentifier
return|;
block|}
DECL|method|getStartRequest ()
specifier|private
name|StartContainerRequest
name|getStartRequest
parameter_list|()
block|{
return|return
name|this
operator|.
name|startRequest
return|;
block|}
DECL|method|getExecutionType ()
specifier|private
name|ExecutionType
name|getExecutionType
parameter_list|()
block|{
return|return
name|this
operator|.
name|executionType
return|;
block|}
DECL|method|getPti ()
specifier|protected
name|ProcessTreeInfo
name|getPti
parameter_list|()
block|{
return|return
name|this
operator|.
name|pti
return|;
block|}
DECL|method|createProcessTreeInfo (ContainerId containerId, Resource resource, Configuration conf)
specifier|private
name|ProcessTreeInfo
name|createProcessTreeInfo
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|Resource
name|resource
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|long
name|pmemBytes
init|=
name|resource
operator|.
name|getMemory
argument_list|()
operator|*
literal|1024
operator|*
literal|1024L
decl_stmt|;
name|float
name|pmemRatio
init|=
name|conf
operator|.
name|getFloat
argument_list|(
name|YarnConfiguration
operator|.
name|NM_VMEM_PMEM_RATIO
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_NM_VMEM_PMEM_RATIO
argument_list|)
decl_stmt|;
name|long
name|vmemBytes
init|=
call|(
name|long
call|)
argument_list|(
name|pmemRatio
operator|*
name|pmemBytes
argument_list|)
decl_stmt|;
name|int
name|cpuVcores
init|=
name|resource
operator|.
name|getVirtualCores
argument_list|()
decl_stmt|;
return|return
operator|new
name|ProcessTreeInfo
argument_list|(
name|containerId
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|vmemBytes
argument_list|,
name|pmemBytes
argument_list|,
name|cpuVcores
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object obj)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
name|boolean
name|equal
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|obj
operator|instanceof
name|AllocatedContainerInfo
condition|)
block|{
name|AllocatedContainerInfo
name|otherContInfo
init|=
operator|(
name|AllocatedContainerInfo
operator|)
name|obj
decl_stmt|;
name|equal
operator|=
name|this
operator|.
name|getPti
argument_list|()
operator|.
name|getContainerId
argument_list|()
operator|.
name|equals
argument_list|(
name|otherContInfo
operator|.
name|getPti
argument_list|()
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|equal
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|this
operator|.
name|getPti
argument_list|()
operator|.
name|getContainerId
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

