begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
DECL|package|containermanager.linux.runtime
name|containermanager
operator|.
name|linux
operator|.
name|runtime
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|Groups
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|linux
operator|.
name|privileged
operator|.
name|PrivilegedOperationExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|runtime
operator|.
name|ContainerExecutionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|runtime
operator|.
name|ContainerRuntimeContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilePermission
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|DirectoryStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Paths
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|attribute
operator|.
name|FileAttribute
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|attribute
operator|.
name|PosixFilePermission
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|attribute
operator|.
name|PosixFilePermissions
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AllPermission
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Formatter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
operator|.
name|SEPARATOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
operator|.
name|SYSPROP_HADOOP_HOME_DIR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|ApplicationConstants
operator|.
name|Environment
operator|.
name|JAVA_HOME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|linux
operator|.
name|runtime
operator|.
name|LinuxContainerRuntimeConstants
operator|.
name|CONTAINER_ID_STR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|linux
operator|.
name|runtime
operator|.
name|LinuxContainerRuntimeConstants
operator|.
name|CONTAINER_LOCAL_DIRS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|linux
operator|.
name|runtime
operator|.
name|LinuxContainerRuntimeConstants
operator|.
name|CONTAINER_RUN_CMDS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|linux
operator|.
name|runtime
operator|.
name|LinuxContainerRuntimeConstants
operator|.
name|LOCALIZED_RESOURCES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|linux
operator|.
name|runtime
operator|.
name|LinuxContainerRuntimeConstants
operator|.
name|USER
import|;
end_import

begin_comment
comment|/**  *<p>This class extends the {@link DefaultLinuxContainerRuntime} specifically  * for containers which run Java commands.  It generates a new java security  * policy file per container and modifies the java command to enable the  * Java Security Manager with the generated policy.</p>  *  * The behavior of the {@link JavaSandboxLinuxContainerRuntime} can be modified  * using the following settings:  *  *<ul>  *<li>  *     {@value YarnConfiguration#YARN_CONTAINER_SANDBOX} :  *     This yarn-site.xml setting has three options:  *<ul>  *<li>disabled - Default behavior. {@link LinuxContainerRuntime}  *     is disabled</li>  *<li>permissive - JVM containers will run with Java Security Manager  *     enabled.  Non-JVM containers will run normally</li>  *<li>enforcing - JVM containers will run with Java Security Manager  *     enabled.  Non-JVM containers will be prevented from executing and an  *     {@link ContainerExecutionException} will be thrown.</li>  *</ul>  *</li>  *<li>  *     {@value YarnConfiguration#YARN_CONTAINER_SANDBOX_FILE_PERMISSIONS} :  *     Determines the file permissions for the application directories.  The  *     permissions come in the form of comma separated values  *     (e.g. read,write,execute,delete). Defaults to {@code read} for read-only.  *</li>  *<li>  *     {@value YarnConfiguration#YARN_CONTAINER_SANDBOX_POLICY} :  *     Accepts canonical path to a java policy file on the local filesystem.  *     This file will be loaded as the base policy, any additional container  *     grants will be appended to this base file.  If not specified, the default  *     java.policy   file provided with hadoop resources will be used.  *</li>  *<li>  *     {@value YarnConfiguration#YARN_CONTAINER_SANDBOX_WHITELIST_GROUP} :  *     Optional setting to specify a YARN queue which will be exempt from the  *     sand-boxing process.  *</li>  *</ul>  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|JavaSandboxLinuxContainerRuntime
specifier|public
class|class
name|JavaSandboxLinuxContainerRuntime
extends|extends
name|DefaultLinuxContainerRuntime
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|DefaultLinuxContainerRuntime
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|configuration
specifier|private
name|Configuration
name|configuration
decl_stmt|;
DECL|field|sandboxMode
specifier|private
name|SandboxMode
name|sandboxMode
decl_stmt|;
DECL|field|POLICY_FILE_DIR
specifier|public
specifier|static
specifier|final
name|String
name|POLICY_FILE_DIR
init|=
literal|"nm-sandbox-policies"
decl_stmt|;
DECL|field|policyFileDir
specifier|private
specifier|static
name|Path
name|policyFileDir
decl_stmt|;
DECL|field|POLICY_ATTR
specifier|private
specifier|static
specifier|final
name|FileAttribute
argument_list|<
name|Set
argument_list|<
name|PosixFilePermission
argument_list|>
argument_list|>
name|POLICY_ATTR
init|=
name|PosixFilePermissions
operator|.
name|asFileAttribute
argument_list|(
name|PosixFilePermissions
operator|.
name|fromString
argument_list|(
literal|"rwxr-xr-x"
argument_list|)
argument_list|)
decl_stmt|;
DECL|field|containerPolicies
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Path
argument_list|>
name|containerPolicies
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Create an instance using the given {@link PrivilegedOperationExecutor}    * instance for performing operations.    *    * @param privilegedOperationExecutor the {@link PrivilegedOperationExecutor}    * instance    */
DECL|method|JavaSandboxLinuxContainerRuntime ( PrivilegedOperationExecutor privilegedOperationExecutor)
specifier|public
name|JavaSandboxLinuxContainerRuntime
parameter_list|(
name|PrivilegedOperationExecutor
name|privilegedOperationExecutor
parameter_list|)
block|{
name|super
argument_list|(
name|privilegedOperationExecutor
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|initialize (Configuration conf)
specifier|public
name|void
name|initialize
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|ContainerExecutionException
block|{
name|this
operator|.
name|configuration
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|sandboxMode
operator|=
name|SandboxMode
operator|.
name|get
argument_list|(
name|this
operator|.
name|configuration
operator|.
name|get
argument_list|(
name|YarnConfiguration
operator|.
name|YARN_CONTAINER_SANDBOX
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_YARN_CONTAINER_SANDBOX
argument_list|)
argument_list|)
expr_stmt|;
name|initializePolicyDir
argument_list|()
expr_stmt|;
name|super
operator|.
name|initialize
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Initialize the Java Security Policy directory.  Either creates the    * directory if it doesn't exist, or clears the contents of the directory if    * already created.    * @throws ContainerExecutionException If unable to resolve policy directory    */
DECL|method|initializePolicyDir ()
specifier|private
name|void
name|initializePolicyDir
parameter_list|()
throws|throws
name|ContainerExecutionException
block|{
name|String
name|hadoopTempDir
init|=
name|configuration
operator|.
name|get
argument_list|(
literal|"hadoop.tmp.dir"
argument_list|)
decl_stmt|;
if|if
condition|(
name|hadoopTempDir
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ContainerExecutionException
argument_list|(
literal|"hadoop.tmp.dir not set!"
argument_list|)
throw|;
block|}
name|policyFileDir
operator|=
name|Paths
operator|.
name|get
argument_list|(
name|hadoopTempDir
argument_list|,
name|POLICY_FILE_DIR
argument_list|)
expr_stmt|;
comment|//Delete any existing policy files if the directory has already been created
if|if
condition|(
name|Files
operator|.
name|exists
argument_list|(
name|policyFileDir
argument_list|)
condition|)
block|{
try|try
init|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|stream
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|policyFileDir
argument_list|)
init|)
block|{
for|for
control|(
name|Path
name|policyFile
range|:
name|stream
control|)
block|{
name|Files
operator|.
name|delete
argument_list|(
name|policyFile
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ContainerExecutionException
argument_list|(
literal|"Unable to initialize policy "
operator|+
literal|"directory: "
operator|+
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
try|try
block|{
name|policyFileDir
operator|=
name|Files
operator|.
name|createDirectories
argument_list|(
name|Paths
operator|.
name|get
argument_list|(
name|hadoopTempDir
argument_list|,
name|POLICY_FILE_DIR
argument_list|)
argument_list|,
name|POLICY_ATTR
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ContainerExecutionException
argument_list|(
literal|"Unable to create policy file "
operator|+
literal|"directory: "
operator|+
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    *  Prior to environment from being written locally need to generate    *  policy file which limits container access to a small set of directories.    *  Additionally the container run command needs to be modified to include    *  flags to enable the java security manager with the generated policy.    *<br>    *  The Java Sandbox will be circumvented if the user is a member of the    *  group specified in:    *  {@value YarnConfiguration#YARN_CONTAINER_SANDBOX_WHITELIST_GROUP} and if    *  they do not include the JVM flag:    *  {@value NMContainerPolicyUtils#SECURITY_FLAG}    *    * @param ctx The {@link ContainerRuntimeContext} containing container    *            setup properties.    * @throws ContainerExecutionException Exception thrown if temporary policy    * file directory can't be created, or if any exceptions occur during policy    * file parsing and generation.    */
annotation|@
name|Override
DECL|method|prepareContainer (ContainerRuntimeContext ctx)
specifier|public
name|void
name|prepareContainer
parameter_list|(
name|ContainerRuntimeContext
name|ctx
parameter_list|)
throws|throws
name|ContainerExecutionException
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|String
argument_list|>
name|localDirs
init|=
name|ctx
operator|.
name|getExecutionAttribute
argument_list|(
name|CONTAINER_LOCAL_DIRS
argument_list|)
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Map
argument_list|<
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|resources
init|=
name|ctx
operator|.
name|getExecutionAttribute
argument_list|(
name|LOCALIZED_RESOURCES
argument_list|)
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|String
argument_list|>
name|commands
init|=
name|ctx
operator|.
name|getExecutionAttribute
argument_list|(
name|CONTAINER_RUN_CMDS
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
init|=
name|ctx
operator|.
name|getContainer
argument_list|()
operator|.
name|getLaunchContext
argument_list|()
operator|.
name|getEnvironment
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isSandboxContainerWhitelisted
argument_list|(
name|ctx
argument_list|,
name|commands
argument_list|)
condition|)
block|{
name|String
name|tmpDirBase
init|=
name|configuration
operator|.
name|get
argument_list|(
literal|"hadoop.tmp.dir"
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmpDirBase
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ContainerExecutionException
argument_list|(
literal|"hadoop.tmp.dir not set!"
argument_list|)
throw|;
block|}
name|OutputStream
name|policyOutputStream
init|=
literal|null
decl_stmt|;
try|try
block|{
name|String
name|containerID
init|=
name|ctx
operator|.
name|getExecutionAttribute
argument_list|(
name|CONTAINER_ID_STR
argument_list|)
decl_stmt|;
name|Path
name|policyFilePath
init|=
name|Files
operator|.
name|createFile
argument_list|(
name|Paths
operator|.
name|get
argument_list|(
name|policyFileDir
operator|.
name|toString
argument_list|()
argument_list|,
name|containerID
operator|+
literal|"-"
operator|+
name|NMContainerPolicyUtils
operator|.
name|POLICY_FILE
argument_list|)
argument_list|,
name|POLICY_ATTR
argument_list|)
decl_stmt|;
name|policyOutputStream
operator|=
name|Files
operator|.
name|newOutputStream
argument_list|(
name|policyFilePath
argument_list|)
expr_stmt|;
name|containerPolicies
operator|.
name|put
argument_list|(
name|containerID
argument_list|,
name|policyFilePath
argument_list|)
expr_stmt|;
name|NMContainerPolicyUtils
operator|.
name|generatePolicyFile
argument_list|(
name|policyOutputStream
argument_list|,
name|localDirs
argument_list|,
name|resources
argument_list|,
name|configuration
argument_list|)
expr_stmt|;
name|NMContainerPolicyUtils
operator|.
name|appendSecurityFlags
argument_list|(
name|commands
argument_list|,
name|env
argument_list|,
name|policyFilePath
argument_list|,
name|sandboxMode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ContainerExecutionException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|policyOutputStream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|launchContainer (ContainerRuntimeContext ctx)
specifier|public
name|void
name|launchContainer
parameter_list|(
name|ContainerRuntimeContext
name|ctx
parameter_list|)
throws|throws
name|ContainerExecutionException
block|{
try|try
block|{
name|super
operator|.
name|launchContainer
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|deletePolicyFiles
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Determine if JVMSandboxLinuxContainerRuntime should be used.  This is    * decided based on the value of    * {@value YarnConfiguration#YARN_CONTAINER_SANDBOX}    * @return true if Sandbox is requested, false otherwise    */
DECL|method|isSandboxContainerRequested ()
name|boolean
name|isSandboxContainerRequested
parameter_list|()
block|{
return|return
name|sandboxMode
operator|!=
name|SandboxMode
operator|.
name|disabled
return|;
block|}
comment|/**    * Determine if the container should be whitelisted (i.e. exempt from the    * Java Security Manager).    * @param ctx The container runtime context for the requested container    * @param commands The list of run commands for the container    * @return boolean value denoting whether the container should be whitelisted.    * @throws ContainerExecutionException If container user can not be resolved    */
DECL|method|isSandboxContainerWhitelisted (ContainerRuntimeContext ctx, List<String> commands)
specifier|private
name|boolean
name|isSandboxContainerWhitelisted
parameter_list|(
name|ContainerRuntimeContext
name|ctx
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|commands
parameter_list|)
throws|throws
name|ContainerExecutionException
block|{
name|String
name|whitelistGroup
init|=
name|configuration
operator|.
name|get
argument_list|(
name|YarnConfiguration
operator|.
name|YARN_CONTAINER_SANDBOX_WHITELIST_GROUP
argument_list|)
decl_stmt|;
name|Groups
name|groups
init|=
name|Groups
operator|.
name|getUserToGroupsMappingService
argument_list|(
name|configuration
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|userGroups
decl_stmt|;
name|boolean
name|isWhitelisted
init|=
literal|false
decl_stmt|;
try|try
block|{
name|userGroups
operator|=
name|groups
operator|.
name|getGroups
argument_list|(
name|ctx
operator|.
name|getExecutionAttribute
argument_list|(
name|USER
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ContainerExecutionException
argument_list|(
literal|"Container user does not exist"
argument_list|)
throw|;
block|}
if|if
condition|(
name|whitelistGroup
operator|!=
literal|null
operator|&&
name|userGroups
operator|.
name|contains
argument_list|(
name|whitelistGroup
argument_list|)
condition|)
block|{
comment|// If any command has security flag, whitelisting is disabled
for|for
control|(
name|String
name|cmd
range|:
name|commands
control|)
block|{
if|if
condition|(
name|cmd
operator|.
name|contains
argument_list|(
name|NMContainerPolicyUtils
operator|.
name|SECURITY_FLAG
argument_list|)
condition|)
block|{
name|isWhitelisted
operator|=
literal|false
expr_stmt|;
break|break;
block|}
else|else
block|{
name|isWhitelisted
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
return|return
name|isWhitelisted
return|;
block|}
comment|/**    * Deletes policy files for container specified by parameter.  Additionally    * this method will age off any stale policy files generated by    * {@link JavaSandboxLinuxContainerRuntime}    * @param ctx Container context for files to be deleted    * @throws ContainerExecutionException if unable to access or delete policy    * files or generated policy file directory    */
DECL|method|deletePolicyFiles (ContainerRuntimeContext ctx)
specifier|private
name|void
name|deletePolicyFiles
parameter_list|(
name|ContainerRuntimeContext
name|ctx
parameter_list|)
throws|throws
name|ContainerExecutionException
block|{
try|try
block|{
name|Files
operator|.
name|delete
argument_list|(
name|containerPolicies
operator|.
name|remove
argument_list|(
name|ctx
operator|.
name|getExecutionAttribute
argument_list|(
name|CONTAINER_ID_STR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ContainerExecutionException
argument_list|(
literal|"Unable to delete policy file: "
operator|+
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Enumeration of the modes the JavaSandboxLinuxContainerRuntime can use.    * See {@link JavaSandboxLinuxContainerRuntime} for details on the    * behavior of each setting.    */
DECL|enum|SandboxMode
specifier|public
enum|enum
name|SandboxMode
block|{
DECL|enumConstant|enforcing
name|enforcing
argument_list|(
literal|"enforcing"
argument_list|)
block|,
DECL|enumConstant|permissive
name|permissive
argument_list|(
literal|"permissive"
argument_list|)
block|,
DECL|enumConstant|disabled
name|disabled
argument_list|(
literal|"disabled"
argument_list|)
block|;
DECL|field|mode
specifier|private
specifier|final
name|String
name|mode
decl_stmt|;
DECL|method|SandboxMode (String mode)
name|SandboxMode
parameter_list|(
name|String
name|mode
parameter_list|)
block|{
name|this
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
block|}
DECL|method|get (String mode)
specifier|public
specifier|static
name|SandboxMode
name|get
parameter_list|(
name|String
name|mode
parameter_list|)
block|{
if|if
condition|(
name|enforcing
operator|.
name|mode
operator|.
name|equals
argument_list|(
name|mode
argument_list|)
condition|)
block|{
return|return
name|enforcing
return|;
block|}
elseif|else
if|if
condition|(
name|permissive
operator|.
name|mode
operator|.
name|equals
argument_list|(
name|mode
argument_list|)
condition|)
block|{
return|return
name|permissive
return|;
block|}
else|else
block|{
return|return
name|disabled
return|;
block|}
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|mode
return|;
block|}
block|}
comment|/**    * Static utility class defining String constants and static methods for the    * use of the {@link JavaSandboxLinuxContainerRuntime}.    */
DECL|class|NMContainerPolicyUtils
specifier|static
specifier|final
class|class
name|NMContainerPolicyUtils
block|{
DECL|field|POLICY_FILE
specifier|static
specifier|final
name|String
name|POLICY_FILE
init|=
literal|"java.policy"
decl_stmt|;
DECL|field|SECURITY_DEBUG
specifier|static
specifier|final
name|String
name|SECURITY_DEBUG
init|=
literal|" -Djava.security.debug=all"
decl_stmt|;
DECL|field|SECURITY_FLAG
specifier|static
specifier|final
name|String
name|SECURITY_FLAG
init|=
literal|"-Djava.security.manager"
decl_stmt|;
DECL|field|POLICY_APPEND_FLAG
specifier|static
specifier|final
name|String
name|POLICY_APPEND_FLAG
init|=
literal|"-Djava.security.policy="
decl_stmt|;
DECL|field|POLICY_FLAG
specifier|static
specifier|final
name|String
name|POLICY_FLAG
init|=
name|POLICY_APPEND_FLAG
operator|+
literal|"="
decl_stmt|;
DECL|field|JAVA_CMD
specifier|static
specifier|final
name|String
name|JAVA_CMD
init|=
literal|"/bin/java "
decl_stmt|;
DECL|field|JVM_SECURITY_CMD
specifier|static
specifier|final
name|String
name|JVM_SECURITY_CMD
init|=
name|JAVA_CMD
operator|+
name|SECURITY_FLAG
operator|+
literal|" "
operator|+
name|POLICY_FLAG
decl_stmt|;
DECL|field|STRIP_POLICY_FLAG
specifier|static
specifier|final
name|String
name|STRIP_POLICY_FLAG
init|=
name|POLICY_APPEND_FLAG
operator|+
literal|"[^ ]+"
decl_stmt|;
DECL|field|CONTAINS_JAVA_CMD
specifier|static
specifier|final
name|String
name|CONTAINS_JAVA_CMD
init|=
literal|"\\$"
operator|+
name|JAVA_HOME
operator|+
name|JAVA_CMD
operator|+
literal|".*"
decl_stmt|;
DECL|field|CHAINED_COMMAND_REGEX
specifier|static
specifier|final
name|String
name|CHAINED_COMMAND_REGEX
init|=
literal|"^.*(&&.+$)|(\\|\\|.+$).*$"
decl_stmt|;
comment|//Matches any occurrences of '||' or '&&'
DECL|field|CLEAN_CMD_REGEX
specifier|static
specifier|final
name|String
name|CLEAN_CMD_REGEX
init|=
literal|"("
operator|+
name|SECURITY_FLAG
operator|+
literal|")|"
operator|+
literal|"("
operator|+
name|STRIP_POLICY_FLAG
operator|+
literal|")"
decl_stmt|;
DECL|field|FILE_PERMISSION_FORMAT
specifier|static
specifier|final
name|String
name|FILE_PERMISSION_FORMAT
init|=
literal|"   permission "
operator|+
name|FilePermission
operator|.
name|class
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|" \"%1$s"
operator|+
name|SEPARATOR
operator|+
literal|"-\", \"%2$s\";%n"
decl_stmt|;
DECL|field|HADOOP_HOME_PERMISSION
specifier|static
specifier|final
name|String
name|HADOOP_HOME_PERMISSION
init|=
literal|"%ngrant codeBase \"file:"
operator|+
name|Paths
operator|.
name|get
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
name|SYSPROP_HADOOP_HOME_DIR
argument_list|)
argument_list|)
operator|+
name|SEPARATOR
operator|+
literal|"-\" {%n"
operator|+
literal|"  permission "
operator|+
name|AllPermission
operator|.
name|class
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|";%n};%n"
decl_stmt|;
DECL|field|LOG
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|Logger
operator|.
name|getLogger
argument_list|(
name|NMContainerPolicyUtils
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * Write new policy file to policyOutStream which will include read access      * to localize resources.  Optionally a default policyFilePath can be      * specified to append a custom policy implementation to the new policy file      * @param policyOutStream OutputStream pointing to java.policy file      * @param localDirs Container local directories      * @param resources List of local container resources      * @param conf YARN configuration      * @throws IOException - If policy file generation is unable to read the      * base policy file or if it is unable to create a new policy file.      */
DECL|method|generatePolicyFile (OutputStream policyOutStream, List<String> localDirs, Map<org.apache.hadoop.fs.Path, List<String>> resources, Configuration conf)
specifier|static
name|void
name|generatePolicyFile
parameter_list|(
name|OutputStream
name|policyOutStream
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|localDirs
parameter_list|,
name|Map
argument_list|<
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|resources
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|policyFilePath
init|=
name|conf
operator|.
name|get
argument_list|(
name|YarnConfiguration
operator|.
name|YARN_CONTAINER_SANDBOX_POLICY
argument_list|)
decl_stmt|;
name|String
name|filePermissions
init|=
name|conf
operator|.
name|get
argument_list|(
name|YarnConfiguration
operator|.
name|YARN_CONTAINER_SANDBOX_FILE_PERMISSIONS
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_YARN_CONTAINER_SANDBOX_FILE_PERMISSIONS
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|cacheDirs
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
name|path
range|:
name|resources
operator|.
name|keySet
argument_list|()
control|)
block|{
name|cacheDirs
operator|.
name|add
argument_list|(
name|path
operator|.
name|getParent
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|policyFilePath
operator|==
literal|null
condition|)
block|{
name|IOUtils
operator|.
name|copyBytes
argument_list|(
name|NMContainerPolicyUtils
operator|.
name|class
operator|.
name|getResourceAsStream
argument_list|(
literal|"/"
operator|+
name|POLICY_FILE
argument_list|)
argument_list|,
name|policyOutStream
argument_list|,
name|conf
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Files
operator|.
name|copy
argument_list|(
name|Paths
operator|.
name|get
argument_list|(
name|policyFilePath
argument_list|)
argument_list|,
name|policyOutStream
argument_list|)
expr_stmt|;
name|policyOutStream
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
name|Formatter
name|filePermissionFormat
init|=
operator|new
name|Formatter
argument_list|(
name|policyOutStream
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
name|filePermissionFormat
operator|.
name|format
argument_list|(
name|HADOOP_HOME_PERMISSION
argument_list|)
expr_stmt|;
name|filePermissionFormat
operator|.
name|format
argument_list|(
literal|"grant {%n"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|localDir
range|:
name|localDirs
control|)
block|{
name|filePermissionFormat
operator|.
name|format
argument_list|(
name|FILE_PERMISSION_FORMAT
argument_list|,
name|localDir
argument_list|,
name|filePermissions
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|cacheDir
range|:
name|cacheDirs
control|)
block|{
name|filePermissionFormat
operator|.
name|format
argument_list|(
name|FILE_PERMISSION_FORMAT
argument_list|,
name|cacheDir
argument_list|,
name|filePermissions
argument_list|)
expr_stmt|;
block|}
name|filePermissionFormat
operator|.
name|format
argument_list|(
literal|"};%n"
argument_list|)
expr_stmt|;
name|filePermissionFormat
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**      * Modify command to enable the Java Security Manager and specify      * java.policy file.  Will modify the passed commands to strip any      * existing java security configurations.  Expects a java command to be the      * first and only executable provided in enforcing mode.  In passive mode      * any commands with '||' or '&&' will not be modified.      * @param commands List of container commands      * @param env Container environment variables      * @param policyPath Path to the container specific policy file      * @param sandboxMode (enforcing, permissive, disabled) Determines      *          whether non-java containers will be launched      * @throws ContainerExecutionException - Exception thrown if      * JVM Sandbox enabled in 'enforcing' mode and a non-java command is      * provided in the list of commands      */
DECL|method|appendSecurityFlags (List<String> commands, Map<String, String> env, Path policyPath, SandboxMode sandboxMode)
specifier|static
name|void
name|appendSecurityFlags
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|commands
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
parameter_list|,
name|Path
name|policyPath
parameter_list|,
name|SandboxMode
name|sandboxMode
parameter_list|)
throws|throws
name|ContainerExecutionException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|commands
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|command
init|=
name|commands
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|validateJavaHome
argument_list|(
name|env
operator|.
name|get
argument_list|(
name|JAVA_HOME
operator|.
name|name
argument_list|()
argument_list|)
argument_list|)
operator|&&
name|command
operator|.
name|matches
argument_list|(
name|CONTAINS_JAVA_CMD
argument_list|)
operator|&&
operator|!
name|command
operator|.
name|matches
argument_list|(
name|CHAINED_COMMAND_REGEX
argument_list|)
condition|)
block|{
name|command
operator|=
name|command
operator|.
name|replaceAll
argument_list|(
name|CLEAN_CMD_REGEX
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|String
name|securityString
init|=
name|JVM_SECURITY_CMD
operator|+
name|policyPath
operator|+
literal|" "
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|securityString
operator|+=
name|SECURITY_DEBUG
expr_stmt|;
block|}
name|commands
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|command
operator|.
name|replaceFirst
argument_list|(
name|JAVA_CMD
argument_list|,
name|securityString
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sandboxMode
operator|==
name|SandboxMode
operator|.
name|enforcing
condition|)
block|{
throw|throw
operator|new
name|ContainerExecutionException
argument_list|(
literal|"Only JVM containers permitted in YARN sandbox mode (enforcing). "
operator|+
literal|"The following command can not be executed securely: "
operator|+
name|command
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|sandboxMode
operator|==
name|SandboxMode
operator|.
name|permissive
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The container will run without the java security manager"
operator|+
literal|" due to an unsupported container command.  The command"
operator|+
literal|" will be permitted to run in Sandbox permissive mode: "
operator|+
name|command
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|validateJavaHome (String containerJavaHome)
specifier|private
specifier|static
name|boolean
name|validateJavaHome
parameter_list|(
name|String
name|containerJavaHome
parameter_list|)
throws|throws
name|ContainerExecutionException
block|{
if|if
condition|(
name|System
operator|.
name|getenv
argument_list|(
name|JAVA_HOME
operator|.
name|name
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ContainerExecutionException
argument_list|(
literal|"JAVA_HOME is not set for NodeManager"
argument_list|)
throw|;
block|}
if|if
condition|(
name|containerJavaHome
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ContainerExecutionException
argument_list|(
literal|"JAVA_HOME is not set for container"
argument_list|)
throw|;
block|}
return|return
name|System
operator|.
name|getenv
argument_list|(
name|JAVA_HOME
operator|.
name|name
argument_list|()
argument_list|)
operator|.
name|equals
argument_list|(
name|containerJavaHome
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

