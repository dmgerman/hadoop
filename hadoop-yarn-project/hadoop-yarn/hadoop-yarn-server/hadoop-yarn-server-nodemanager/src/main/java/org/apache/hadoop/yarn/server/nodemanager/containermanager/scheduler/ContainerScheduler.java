begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.nodemanager.containermanager.scheduler
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|scheduler
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|AbstractService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerExitStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ExecutionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ResourceUtilization
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|event
operator|.
name|AsyncDispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|event
operator|.
name|EventHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerQueuingLimit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|api
operator|.
name|records
operator|.
name|OpportunisticContainersStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|container
operator|.
name|Container
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|monitor
operator|.
name|ContainersMonitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|metrics
operator|.
name|NodeManagerMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * The ContainerScheduler manages a collection of runnable containers. It  * ensures that a container is launched only if all its launch criteria are  * met. It also ensures that OPPORTUNISTIC containers are killed to make  * room for GUARANTEED containers.  */
end_comment

begin_class
DECL|class|ContainerScheduler
specifier|public
class|class
name|ContainerScheduler
extends|extends
name|AbstractService
implements|implements
name|EventHandler
argument_list|<
name|ContainerSchedulerEvent
argument_list|>
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ContainerScheduler
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|context
specifier|private
specifier|final
name|Context
name|context
decl_stmt|;
DECL|field|maxOppQueueLength
specifier|private
specifier|final
name|int
name|maxOppQueueLength
decl_stmt|;
comment|// Queue of Guaranteed Containers waiting for resources to run
specifier|private
specifier|final
name|LinkedHashMap
argument_list|<
name|ContainerId
argument_list|,
name|Container
argument_list|>
DECL|field|queuedGuaranteedContainers
name|queuedGuaranteedContainers
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Queue of Opportunistic Containers waiting for resources to run
specifier|private
specifier|final
name|LinkedHashMap
argument_list|<
name|ContainerId
argument_list|,
name|Container
argument_list|>
DECL|field|queuedOpportunisticContainers
name|queuedOpportunisticContainers
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Used to keep track of containers that have been marked to be killed
comment|// to make room for a guaranteed container.
DECL|field|oppContainersToKill
specifier|private
specifier|final
name|Map
argument_list|<
name|ContainerId
argument_list|,
name|Container
argument_list|>
name|oppContainersToKill
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Containers launched by the Scheduler will take a while to actually
comment|// move to the RUNNING state, but should still be fair game for killing
comment|// by the scheduler to make room for guaranteed containers. This holds
comment|// containers that are in RUNNING as well as those in SCHEDULED state that
comment|// have been marked to run, but not yet RUNNING.
DECL|field|runningContainers
specifier|private
specifier|final
name|LinkedHashMap
argument_list|<
name|ContainerId
argument_list|,
name|Container
argument_list|>
name|runningContainers
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|queuingLimit
specifier|private
specifier|final
name|ContainerQueuingLimit
name|queuingLimit
init|=
name|ContainerQueuingLimit
operator|.
name|newInstance
argument_list|()
decl_stmt|;
DECL|field|opportunisticContainersStatus
specifier|private
specifier|final
name|OpportunisticContainersStatus
name|opportunisticContainersStatus
decl_stmt|;
comment|// Resource Utilization Tracker that decides how utilization of the cluster
comment|// increases / decreases based on container start / finish
DECL|field|utilizationTracker
specifier|private
name|ResourceUtilizationTracker
name|utilizationTracker
decl_stmt|;
DECL|field|dispatcher
specifier|private
specifier|final
name|AsyncDispatcher
name|dispatcher
decl_stmt|;
DECL|field|metrics
specifier|private
specifier|final
name|NodeManagerMetrics
name|metrics
decl_stmt|;
comment|/**    * Instantiate a Container Scheduler.    * @param context NodeManager Context.    * @param dispatcher AsyncDispatcher.    * @param metrics NodeManagerMetrics.    */
DECL|method|ContainerScheduler (Context context, AsyncDispatcher dispatcher, NodeManagerMetrics metrics)
specifier|public
name|ContainerScheduler
parameter_list|(
name|Context
name|context
parameter_list|,
name|AsyncDispatcher
name|dispatcher
parameter_list|,
name|NodeManagerMetrics
name|metrics
parameter_list|)
block|{
name|this
argument_list|(
name|context
argument_list|,
name|dispatcher
argument_list|,
name|metrics
argument_list|,
name|context
operator|.
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|YarnConfiguration
operator|.
name|NM_OPPORTUNISTIC_CONTAINERS_MAX_QUEUE_LENGTH
argument_list|,
name|YarnConfiguration
operator|.
name|NM_OPPORTUNISTIC_CONTAINERS_MAX_QUEUE_LENGTH_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|ContainerScheduler (Context context, AsyncDispatcher dispatcher, NodeManagerMetrics metrics, int qLength)
specifier|public
name|ContainerScheduler
parameter_list|(
name|Context
name|context
parameter_list|,
name|AsyncDispatcher
name|dispatcher
parameter_list|,
name|NodeManagerMetrics
name|metrics
parameter_list|,
name|int
name|qLength
parameter_list|)
block|{
name|super
argument_list|(
name|ContainerScheduler
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|this
operator|.
name|dispatcher
operator|=
name|dispatcher
expr_stmt|;
name|this
operator|.
name|metrics
operator|=
name|metrics
expr_stmt|;
name|this
operator|.
name|maxOppQueueLength
operator|=
operator|(
name|qLength
operator|<=
literal|0
operator|)
condition|?
literal|0
else|:
name|qLength
expr_stmt|;
name|this
operator|.
name|utilizationTracker
operator|=
operator|new
name|AllocationBasedResourceUtilizationTracker
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|opportunisticContainersStatus
operator|=
name|OpportunisticContainersStatus
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
comment|/**    * Handle ContainerSchedulerEvents.    * @param event ContainerSchedulerEvent.    */
annotation|@
name|Override
DECL|method|handle (ContainerSchedulerEvent event)
specifier|public
name|void
name|handle
parameter_list|(
name|ContainerSchedulerEvent
name|event
parameter_list|)
block|{
switch|switch
condition|(
name|event
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|SCHEDULE_CONTAINER
case|:
name|scheduleContainer
argument_list|(
name|event
operator|.
name|getContainer
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONTAINER_COMPLETED
case|:
name|onContainerCompleted
argument_list|(
name|event
operator|.
name|getContainer
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHED_QUEUED_CONTAINERS
case|:
name|shedQueuedOpportunisticContainers
argument_list|()
expr_stmt|;
break|break;
default|default:
name|LOG
operator|.
name|error
argument_list|(
literal|"Unknown event arrived at ContainerScheduler: "
operator|+
name|event
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Return number of queued containers.    * @return Number of queued containers.    */
DECL|method|getNumQueuedContainers ()
specifier|public
name|int
name|getNumQueuedContainers
parameter_list|()
block|{
return|return
name|this
operator|.
name|queuedGuaranteedContainers
operator|.
name|size
argument_list|()
operator|+
name|this
operator|.
name|queuedOpportunisticContainers
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getNumQueuedGuaranteedContainers ()
specifier|public
name|int
name|getNumQueuedGuaranteedContainers
parameter_list|()
block|{
return|return
name|this
operator|.
name|queuedGuaranteedContainers
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getNumQueuedOpportunisticContainers ()
specifier|public
name|int
name|getNumQueuedOpportunisticContainers
parameter_list|()
block|{
return|return
name|this
operator|.
name|queuedOpportunisticContainers
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|getOpportunisticContainersStatus ()
specifier|public
name|OpportunisticContainersStatus
name|getOpportunisticContainersStatus
parameter_list|()
block|{
name|this
operator|.
name|opportunisticContainersStatus
operator|.
name|setQueuedOpportContainers
argument_list|(
name|getNumQueuedOpportunisticContainers
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|opportunisticContainersStatus
operator|.
name|setWaitQueueLength
argument_list|(
name|getNumQueuedContainers
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|opportunisticContainersStatus
operator|.
name|setOpportMemoryUsed
argument_list|(
name|metrics
operator|.
name|getAllocatedOpportunisticGB
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|opportunisticContainersStatus
operator|.
name|setOpportCoresUsed
argument_list|(
name|metrics
operator|.
name|getAllocatedOpportunisticVCores
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|opportunisticContainersStatus
operator|.
name|setRunningOpportContainers
argument_list|(
name|metrics
operator|.
name|getRunningOpportunisticContainers
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|this
operator|.
name|opportunisticContainersStatus
return|;
block|}
DECL|method|onContainerCompleted (Container container)
specifier|private
name|void
name|onContainerCompleted
parameter_list|(
name|Container
name|container
parameter_list|)
block|{
name|oppContainersToKill
operator|.
name|remove
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
comment|// This could be killed externally for eg. by the ContainerManager,
comment|// in which case, the container might still be queued.
name|Container
name|queued
init|=
name|queuedOpportunisticContainers
operator|.
name|remove
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|queued
operator|==
literal|null
condition|)
block|{
name|queuedGuaranteedContainers
operator|.
name|remove
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// decrement only if it was a running container
name|Container
name|completedContainer
init|=
name|runningContainers
operator|.
name|remove
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|completedContainer
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|utilizationTracker
operator|.
name|subtractContainerResource
argument_list|(
name|container
argument_list|)
expr_stmt|;
if|if
condition|(
name|container
operator|.
name|getContainerTokenIdentifier
argument_list|()
operator|.
name|getExecutionType
argument_list|()
operator|==
name|ExecutionType
operator|.
name|OPPORTUNISTIC
condition|)
block|{
name|this
operator|.
name|metrics
operator|.
name|completeOpportunisticContainer
argument_list|(
name|container
operator|.
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|startPendingContainers
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|startPendingContainers ()
specifier|private
name|void
name|startPendingContainers
parameter_list|()
block|{
comment|// Start pending guaranteed containers, if resources available.
name|boolean
name|resourcesAvailable
init|=
name|startContainersFromQueue
argument_list|(
name|queuedGuaranteedContainers
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
comment|// Start opportunistic containers, if resources available.
if|if
condition|(
name|resourcesAvailable
condition|)
block|{
name|startContainersFromQueue
argument_list|(
name|queuedOpportunisticContainers
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|startContainersFromQueue ( Collection<Container> queuedContainers)
specifier|private
name|boolean
name|startContainersFromQueue
parameter_list|(
name|Collection
argument_list|<
name|Container
argument_list|>
name|queuedContainers
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Container
argument_list|>
name|cIter
init|=
name|queuedContainers
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|boolean
name|resourcesAvailable
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|cIter
operator|.
name|hasNext
argument_list|()
operator|&&
name|resourcesAvailable
condition|)
block|{
name|Container
name|container
init|=
name|cIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|utilizationTracker
operator|.
name|hasResourcesAvailable
argument_list|(
name|container
argument_list|)
condition|)
block|{
name|startAllocatedContainer
argument_list|(
name|container
argument_list|)
expr_stmt|;
name|cIter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|resourcesAvailable
operator|=
literal|false
expr_stmt|;
block|}
block|}
return|return
name|resourcesAvailable
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|scheduleContainer (Container container)
specifier|protected
name|void
name|scheduleContainer
parameter_list|(
name|Container
name|container
parameter_list|)
block|{
if|if
condition|(
name|maxOppQueueLength
operator|<=
literal|0
condition|)
block|{
name|startAllocatedContainer
argument_list|(
name|container
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|queuedGuaranteedContainers
operator|.
name|isEmpty
argument_list|()
operator|&&
name|queuedOpportunisticContainers
operator|.
name|isEmpty
argument_list|()
operator|&&
name|this
operator|.
name|utilizationTracker
operator|.
name|hasResourcesAvailable
argument_list|(
name|container
argument_list|)
condition|)
block|{
name|startAllocatedContainer
argument_list|(
name|container
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No available resources for container {} to start its execution "
operator|+
literal|"immediately."
argument_list|,
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|isQueued
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|container
operator|.
name|getContainerTokenIdentifier
argument_list|()
operator|.
name|getExecutionType
argument_list|()
operator|==
name|ExecutionType
operator|.
name|GUARANTEED
condition|)
block|{
name|queuedGuaranteedContainers
operator|.
name|put
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|container
argument_list|)
expr_stmt|;
comment|// Kill running opportunistic containers to make space for
comment|// guaranteed container.
name|killOpportunisticContainers
argument_list|(
name|container
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|queuedOpportunisticContainers
operator|.
name|size
argument_list|()
operator|<=
name|maxOppQueueLength
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Opportunistic container {} will be queued at the NM."
argument_list|,
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
name|queuedOpportunisticContainers
operator|.
name|put
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isQueued
operator|=
literal|false
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Opportunistic container [{}] will not be queued at the NM"
operator|+
literal|"since max queue length [{}] has been reached"
argument_list|,
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|maxOppQueueLength
argument_list|)
expr_stmt|;
name|container
operator|.
name|sendKillEvent
argument_list|(
name|ContainerExitStatus
operator|.
name|KILLED_BY_CONTAINER_SCHEDULER
argument_list|,
literal|"Opportunistic container queue is full."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isQueued
condition|)
block|{
try|try
block|{
name|this
operator|.
name|context
operator|.
name|getNMStateStore
argument_list|()
operator|.
name|storeContainerQueued
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not store container ["
operator|+
name|container
operator|.
name|getContainerId
argument_list|()
operator|+
literal|"] state. The Container has been queued."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|killOpportunisticContainers (Container container)
specifier|private
name|void
name|killOpportunisticContainers
parameter_list|(
name|Container
name|container
parameter_list|)
block|{
name|List
argument_list|<
name|Container
argument_list|>
name|extraOpportContainersToKill
init|=
name|pickOpportunisticContainersToKill
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|)
decl_stmt|;
comment|// Kill the opportunistic containers that were chosen.
for|for
control|(
name|Container
name|contToKill
range|:
name|extraOpportContainersToKill
control|)
block|{
name|contToKill
operator|.
name|sendKillEvent
argument_list|(
name|ContainerExitStatus
operator|.
name|KILLED_BY_CONTAINER_SCHEDULER
argument_list|,
literal|"Container Killed to make room for Guaranteed Container."
argument_list|)
expr_stmt|;
name|oppContainersToKill
operator|.
name|put
argument_list|(
name|contToKill
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|contToKill
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Opportunistic container {} will be killed in order to start the "
operator|+
literal|"execution of guaranteed container {}."
argument_list|,
name|contToKill
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|startAllocatedContainer (Container container)
specifier|private
name|void
name|startAllocatedContainer
parameter_list|(
name|Container
name|container
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting container ["
operator|+
name|container
operator|.
name|getContainerId
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
name|runningContainers
operator|.
name|put
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|container
argument_list|)
expr_stmt|;
name|this
operator|.
name|utilizationTracker
operator|.
name|addContainerResources
argument_list|(
name|container
argument_list|)
expr_stmt|;
if|if
condition|(
name|container
operator|.
name|getContainerTokenIdentifier
argument_list|()
operator|.
name|getExecutionType
argument_list|()
operator|==
name|ExecutionType
operator|.
name|OPPORTUNISTIC
condition|)
block|{
name|this
operator|.
name|metrics
operator|.
name|startOpportunisticContainer
argument_list|(
name|container
operator|.
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|container
operator|.
name|sendLaunchEvent
argument_list|()
expr_stmt|;
block|}
DECL|method|pickOpportunisticContainersToKill ( ContainerId containerToStartId)
specifier|private
name|List
argument_list|<
name|Container
argument_list|>
name|pickOpportunisticContainersToKill
parameter_list|(
name|ContainerId
name|containerToStartId
parameter_list|)
block|{
comment|// The opportunistic containers that need to be killed for the
comment|// given container to start.
name|List
argument_list|<
name|Container
argument_list|>
name|extraOpportContainersToKill
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Track resources that need to be freed.
name|ResourceUtilization
name|resourcesToFreeUp
init|=
name|resourcesToFreeUp
argument_list|(
name|containerToStartId
argument_list|)
decl_stmt|;
comment|// Go over the running opportunistic containers.
comment|// Use a descending iterator to kill more recently started containers.
name|Iterator
argument_list|<
name|Container
argument_list|>
name|lifoIterator
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|(
name|runningContainers
operator|.
name|values
argument_list|()
argument_list|)
operator|.
name|descendingIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|lifoIterator
operator|.
name|hasNext
argument_list|()
operator|&&
operator|!
name|hasSufficientResources
argument_list|(
name|resourcesToFreeUp
argument_list|)
condition|)
block|{
name|Container
name|runningCont
init|=
name|lifoIterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|runningCont
operator|.
name|getContainerTokenIdentifier
argument_list|()
operator|.
name|getExecutionType
argument_list|()
operator|==
name|ExecutionType
operator|.
name|OPPORTUNISTIC
condition|)
block|{
if|if
condition|(
name|oppContainersToKill
operator|.
name|containsKey
argument_list|(
name|runningCont
operator|.
name|getContainerId
argument_list|()
argument_list|)
condition|)
block|{
comment|// These containers have already been marked to be killed.
comment|// So exclude them..
continue|continue;
block|}
name|extraOpportContainersToKill
operator|.
name|add
argument_list|(
name|runningCont
argument_list|)
expr_stmt|;
name|ContainersMonitor
operator|.
name|decreaseResourceUtilization
argument_list|(
name|getContainersMonitor
argument_list|()
argument_list|,
name|resourcesToFreeUp
argument_list|,
name|runningCont
operator|.
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hasSufficientResources
argument_list|(
name|resourcesToFreeUp
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"There are no sufficient resources to start guaranteed [{}]"
operator|+
literal|"at the moment. Opportunistic containers are in the process of"
operator|+
literal|"being killed to make room."
argument_list|,
name|containerToStartId
argument_list|)
expr_stmt|;
block|}
return|return
name|extraOpportContainersToKill
return|;
block|}
DECL|method|hasSufficientResources ( ResourceUtilization resourcesToFreeUp)
specifier|private
name|boolean
name|hasSufficientResources
parameter_list|(
name|ResourceUtilization
name|resourcesToFreeUp
parameter_list|)
block|{
return|return
name|resourcesToFreeUp
operator|.
name|getPhysicalMemory
argument_list|()
operator|<=
literal|0
operator|&&
name|resourcesToFreeUp
operator|.
name|getVirtualMemory
argument_list|()
operator|<=
literal|0
operator|&&
name|resourcesToFreeUp
operator|.
name|getCPU
argument_list|()
operator|<=
literal|0.0f
return|;
block|}
DECL|method|resourcesToFreeUp ( ContainerId containerToStartId)
specifier|private
name|ResourceUtilization
name|resourcesToFreeUp
parameter_list|(
name|ContainerId
name|containerToStartId
parameter_list|)
block|{
comment|// Get allocation of currently allocated containers.
name|ResourceUtilization
name|resourceAllocationToFreeUp
init|=
name|ResourceUtilization
operator|.
name|newInstance
argument_list|(
name|this
operator|.
name|utilizationTracker
operator|.
name|getCurrentUtilization
argument_list|()
argument_list|)
decl_stmt|;
comment|// Add to the allocation the allocation of the pending guaranteed
comment|// containers that will start before the current container will be started.
for|for
control|(
name|Container
name|container
range|:
name|queuedGuaranteedContainers
operator|.
name|values
argument_list|()
control|)
block|{
name|ContainersMonitor
operator|.
name|increaseResourceUtilization
argument_list|(
name|getContainersMonitor
argument_list|()
argument_list|,
name|resourceAllocationToFreeUp
argument_list|,
name|container
operator|.
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|container
operator|.
name|getContainerId
argument_list|()
operator|.
name|equals
argument_list|(
name|containerToStartId
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
comment|// These resources are being freed, likely at the behest of another
comment|// guaranteed container..
for|for
control|(
name|Container
name|container
range|:
name|oppContainersToKill
operator|.
name|values
argument_list|()
control|)
block|{
name|ContainersMonitor
operator|.
name|decreaseResourceUtilization
argument_list|(
name|getContainersMonitor
argument_list|()
argument_list|,
name|resourceAllocationToFreeUp
argument_list|,
name|container
operator|.
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Subtract the overall node resources.
name|getContainersMonitor
argument_list|()
operator|.
name|subtractNodeResourcesFromResourceUtilization
argument_list|(
name|resourceAllocationToFreeUp
argument_list|)
expr_stmt|;
return|return
name|resourceAllocationToFreeUp
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|updateQueuingLimit (ContainerQueuingLimit limit)
specifier|public
name|void
name|updateQueuingLimit
parameter_list|(
name|ContainerQueuingLimit
name|limit
parameter_list|)
block|{
name|this
operator|.
name|queuingLimit
operator|.
name|setMaxQueueLength
argument_list|(
name|limit
operator|.
name|getMaxQueueLength
argument_list|()
argument_list|)
expr_stmt|;
comment|// YARN-2886 should add support for wait-times. Include wait time as
comment|// well once it is implemented
if|if
condition|(
operator|(
name|queuingLimit
operator|.
name|getMaxQueueLength
argument_list|()
operator|>
operator|-
literal|1
operator|)
operator|&&
operator|(
name|queuingLimit
operator|.
name|getMaxQueueLength
argument_list|()
operator|<
name|queuedOpportunisticContainers
operator|.
name|size
argument_list|()
operator|)
condition|)
block|{
name|dispatcher
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|ContainerSchedulerEvent
argument_list|(
literal|null
argument_list|,
name|ContainerSchedulerEventType
operator|.
name|SHED_QUEUED_CONTAINERS
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|shedQueuedOpportunisticContainers ()
specifier|private
name|void
name|shedQueuedOpportunisticContainers
parameter_list|()
block|{
name|int
name|numAllowed
init|=
name|this
operator|.
name|queuingLimit
operator|.
name|getMaxQueueLength
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Container
argument_list|>
name|containerIter
init|=
name|queuedOpportunisticContainers
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|containerIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Container
name|container
init|=
name|containerIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|numAllowed
operator|<=
literal|0
condition|)
block|{
name|container
operator|.
name|sendKillEvent
argument_list|(
name|ContainerExitStatus
operator|.
name|KILLED_BY_CONTAINER_SCHEDULER
argument_list|,
literal|"Container De-queued to meet NM queuing limits."
argument_list|)
expr_stmt|;
name|containerIter
operator|.
name|remove
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Opportunistic container {} will be killed to meet NM queuing"
operator|+
literal|" limits."
argument_list|,
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|numAllowed
operator|--
expr_stmt|;
block|}
block|}
DECL|method|getContainersMonitor ()
specifier|public
name|ContainersMonitor
name|getContainersMonitor
parameter_list|()
block|{
return|return
name|this
operator|.
name|context
operator|.
name|getContainerManager
argument_list|()
operator|.
name|getContainersMonitor
argument_list|()
return|;
block|}
block|}
end_class

end_unit

