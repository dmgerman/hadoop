begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.nodemanager.containermanager.scheduler
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|scheduler
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|AbstractService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerExitStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ExecutionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ResourceUtilization
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|event
operator|.
name|AsyncDispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|event
operator|.
name|EventHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerQueuingLimit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|api
operator|.
name|records
operator|.
name|OpportunisticContainersStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|container
operator|.
name|Container
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|container
operator|.
name|ContainerImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|linux
operator|.
name|resources
operator|.
name|ResourceHandlerChain
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|linux
operator|.
name|resources
operator|.
name|ResourceHandlerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|linux
operator|.
name|resources
operator|.
name|ResourceHandlerModule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|monitor
operator|.
name|ChangeMonitoringContainerResourceEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|container
operator|.
name|ContainerState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|monitor
operator|.
name|ContainersMonitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|metrics
operator|.
name|NodeManagerMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|recovery
operator|.
name|NMStateStoreService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|recovery
operator|.
name|NMStateStoreService
operator|.
name|RecoveredContainerState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|recovery
operator|.
name|NMStateStoreService
operator|.
name|RecoveredContainerStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * The ContainerScheduler manages a collection of runnable containers. It  * ensures that a container is launched only if all its launch criteria are  * met. It also ensures that OPPORTUNISTIC containers are killed to make  * room for GUARANTEED containers.  */
end_comment

begin_class
DECL|class|ContainerScheduler
specifier|public
class|class
name|ContainerScheduler
extends|extends
name|AbstractService
implements|implements
name|EventHandler
argument_list|<
name|ContainerSchedulerEvent
argument_list|>
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ContainerScheduler
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|context
specifier|private
specifier|final
name|Context
name|context
decl_stmt|;
comment|// Capacity of the queue for opportunistic Containers.
DECL|field|maxOppQueueLength
specifier|private
specifier|final
name|int
name|maxOppQueueLength
decl_stmt|;
comment|// Queue of Guaranteed Containers waiting for resources to run
specifier|private
specifier|final
name|LinkedHashMap
argument_list|<
name|ContainerId
argument_list|,
name|Container
argument_list|>
DECL|field|queuedGuaranteedContainers
name|queuedGuaranteedContainers
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Queue of Opportunistic Containers waiting for resources to run
specifier|private
specifier|final
name|LinkedHashMap
argument_list|<
name|ContainerId
argument_list|,
name|Container
argument_list|>
DECL|field|queuedOpportunisticContainers
name|queuedOpportunisticContainers
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Used to keep track of containers that have been marked to be killed
comment|// or paused to make room for a guaranteed container.
DECL|field|oppContainersToKill
specifier|private
specifier|final
name|Map
argument_list|<
name|ContainerId
argument_list|,
name|Container
argument_list|>
name|oppContainersToKill
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Containers launched by the Scheduler will take a while to actually
comment|// move to the RUNNING state, but should still be fair game for killing
comment|// by the scheduler to make room for guaranteed containers. This holds
comment|// containers that are in RUNNING as well as those in SCHEDULED state that
comment|// have been marked to run, but not yet RUNNING.
DECL|field|runningContainers
specifier|private
specifier|final
name|LinkedHashMap
argument_list|<
name|ContainerId
argument_list|,
name|Container
argument_list|>
name|runningContainers
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|queuingLimit
specifier|private
specifier|final
name|ContainerQueuingLimit
name|queuingLimit
init|=
name|ContainerQueuingLimit
operator|.
name|newInstance
argument_list|()
decl_stmt|;
DECL|field|opportunisticContainersStatus
specifier|private
specifier|final
name|OpportunisticContainersStatus
name|opportunisticContainersStatus
decl_stmt|;
comment|// Resource Utilization Tracker that decides how utilization of the cluster
comment|// increases / decreases based on container start / finish
DECL|field|utilizationTracker
specifier|private
name|ResourceUtilizationTracker
name|utilizationTracker
decl_stmt|;
DECL|field|dispatcher
specifier|private
specifier|final
name|AsyncDispatcher
name|dispatcher
decl_stmt|;
DECL|field|metrics
specifier|private
specifier|final
name|NodeManagerMetrics
name|metrics
decl_stmt|;
DECL|field|usePauseEventForPreemption
specifier|private
name|Boolean
name|usePauseEventForPreemption
init|=
literal|false
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|resourceHandlerChain
name|ResourceHandlerChain
name|resourceHandlerChain
init|=
literal|null
decl_stmt|;
comment|/**    * Instantiate a Container Scheduler.    * @param context NodeManager Context.    * @param dispatcher AsyncDispatcher.    * @param metrics NodeManagerMetrics.    */
DECL|method|ContainerScheduler (Context context, AsyncDispatcher dispatcher, NodeManagerMetrics metrics)
specifier|public
name|ContainerScheduler
parameter_list|(
name|Context
name|context
parameter_list|,
name|AsyncDispatcher
name|dispatcher
parameter_list|,
name|NodeManagerMetrics
name|metrics
parameter_list|)
block|{
name|this
argument_list|(
name|context
argument_list|,
name|dispatcher
argument_list|,
name|metrics
argument_list|,
name|context
operator|.
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|YarnConfiguration
operator|.
name|NM_OPPORTUNISTIC_CONTAINERS_MAX_QUEUE_LENGTH
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_NM_OPPORTUNISTIC_CONTAINERS_MAX_QUEUE_LENGTH
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|serviceInit (Configuration conf)
specifier|public
name|void
name|serviceInit
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
name|super
operator|.
name|serviceInit
argument_list|(
name|conf
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|resourceHandlerChain
operator|==
literal|null
condition|)
block|{
name|resourceHandlerChain
operator|=
name|ResourceHandlerModule
operator|.
name|getConfiguredResourceHandlerChain
argument_list|(
name|conf
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Resource handler chain enabled = "
operator|+
operator|(
name|resourceHandlerChain
operator|!=
literal|null
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resourceHandlerChain
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Bootstrapping resource handler chain"
argument_list|)
expr_stmt|;
name|resourceHandlerChain
operator|.
name|bootstrap
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ResourceHandlerException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to bootstrap configured resource subsystems! "
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to bootstrap configured resource subsystems!"
argument_list|)
throw|;
block|}
name|this
operator|.
name|usePauseEventForPreemption
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|YarnConfiguration
operator|.
name|NM_CONTAINER_QUEUING_USE_PAUSE_FOR_PREEMPTION
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_NM_CONTAINER_QUEUING_USE_PAUSE_FOR_PREEMPTION
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|ContainerScheduler (Context context, AsyncDispatcher dispatcher, NodeManagerMetrics metrics, int qLength)
specifier|public
name|ContainerScheduler
parameter_list|(
name|Context
name|context
parameter_list|,
name|AsyncDispatcher
name|dispatcher
parameter_list|,
name|NodeManagerMetrics
name|metrics
parameter_list|,
name|int
name|qLength
parameter_list|)
block|{
name|super
argument_list|(
name|ContainerScheduler
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|this
operator|.
name|dispatcher
operator|=
name|dispatcher
expr_stmt|;
name|this
operator|.
name|metrics
operator|=
name|metrics
expr_stmt|;
name|this
operator|.
name|maxOppQueueLength
operator|=
operator|(
name|qLength
operator|<=
literal|0
operator|)
condition|?
literal|0
else|:
name|qLength
expr_stmt|;
name|this
operator|.
name|utilizationTracker
operator|=
operator|new
name|AllocationBasedResourceUtilizationTracker
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|opportunisticContainersStatus
operator|=
name|OpportunisticContainersStatus
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
comment|/**    * Handle ContainerSchedulerEvents.    * @param event ContainerSchedulerEvent.    */
annotation|@
name|Override
DECL|method|handle (ContainerSchedulerEvent event)
specifier|public
name|void
name|handle
parameter_list|(
name|ContainerSchedulerEvent
name|event
parameter_list|)
block|{
switch|switch
condition|(
name|event
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|SCHEDULE_CONTAINER
case|:
name|scheduleContainer
argument_list|(
name|event
operator|.
name|getContainer
argument_list|()
argument_list|)
expr_stmt|;
break|break;
comment|// NOTE: Is sent only after container state has changed to PAUSED...
case|case
name|CONTAINER_PAUSED
case|:
comment|// NOTE: Is sent only after container state has changed to DONE...
case|case
name|CONTAINER_COMPLETED
case|:
name|onResourcesReclaimed
argument_list|(
name|event
operator|.
name|getContainer
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|UPDATE_CONTAINER
case|:
if|if
condition|(
name|event
operator|instanceof
name|UpdateContainerSchedulerEvent
condition|)
block|{
name|onUpdateContainer
argument_list|(
operator|(
name|UpdateContainerSchedulerEvent
operator|)
name|event
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unknown event type on UpdateCOntainer: "
operator|+
name|event
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SHED_QUEUED_CONTAINERS
case|:
name|shedQueuedOpportunisticContainers
argument_list|()
expr_stmt|;
break|break;
case|case
name|RECOVERY_COMPLETED
case|:
name|startPendingContainers
argument_list|(
name|maxOppQueueLength
operator|<=
literal|0
argument_list|)
expr_stmt|;
default|default:
name|LOG
operator|.
name|error
argument_list|(
literal|"Unknown event arrived at ContainerScheduler: "
operator|+
name|event
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * We assume that the ContainerManager has already figured out what kind    * of update this is.    */
DECL|method|onUpdateContainer (UpdateContainerSchedulerEvent updateEvent)
specifier|private
name|void
name|onUpdateContainer
parameter_list|(
name|UpdateContainerSchedulerEvent
name|updateEvent
parameter_list|)
block|{
name|ContainerId
name|containerId
init|=
name|updateEvent
operator|.
name|getContainer
argument_list|()
operator|.
name|getContainerId
argument_list|()
decl_stmt|;
if|if
condition|(
name|updateEvent
operator|.
name|isResourceChange
argument_list|()
condition|)
block|{
if|if
condition|(
name|runningContainers
operator|.
name|containsKey
argument_list|(
name|containerId
argument_list|)
condition|)
block|{
name|this
operator|.
name|utilizationTracker
operator|.
name|subtractContainerResource
argument_list|(
operator|new
name|ContainerImpl
argument_list|(
name|getConfig
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|updateEvent
operator|.
name|getOriginalToken
argument_list|()
argument_list|,
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|utilizationTracker
operator|.
name|addContainerResources
argument_list|(
name|updateEvent
operator|.
name|getContainer
argument_list|()
argument_list|)
expr_stmt|;
name|getContainersMonitor
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|ChangeMonitoringContainerResourceEvent
argument_list|(
name|containerId
argument_list|,
name|updateEvent
operator|.
name|getUpdatedToken
argument_list|()
operator|.
name|getResource
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|updateEvent
operator|.
name|isExecTypeUpdate
argument_list|()
condition|)
block|{
comment|// Promotion or not (Increase signifies either a promotion
comment|// or container size increase)
if|if
condition|(
name|updateEvent
operator|.
name|isIncrease
argument_list|()
condition|)
block|{
comment|// Promotion of queued container..
if|if
condition|(
name|queuedOpportunisticContainers
operator|.
name|remove
argument_list|(
name|containerId
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|queuedGuaranteedContainers
operator|.
name|put
argument_list|(
name|containerId
argument_list|,
name|updateEvent
operator|.
name|getContainer
argument_list|()
argument_list|)
expr_stmt|;
comment|//Kill/pause opportunistic containers if any to make room for
comment|// promotion request
name|reclaimOpportunisticContainerResources
argument_list|(
name|updateEvent
operator|.
name|getContainer
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Demotion of queued container.. Should not happen too often
comment|// since you should not find too many queued guaranteed
comment|// containers
if|if
condition|(
name|queuedGuaranteedContainers
operator|.
name|remove
argument_list|(
name|containerId
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|queuedOpportunisticContainers
operator|.
name|put
argument_list|(
name|containerId
argument_list|,
name|updateEvent
operator|.
name|getContainer
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
try|try
block|{
name|resourceHandlerChain
operator|.
name|updateContainer
argument_list|(
name|updateEvent
operator|.
name|getContainer
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Could not update resources on "
operator|+
literal|"continer update of %s"
argument_list|,
name|containerId
argument_list|)
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|startPendingContainers
argument_list|(
name|maxOppQueueLength
operator|<=
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Populates auxiliary data structures used by the ContainerScheduler on    * recovery.    * @param container container recovered    * @param rcs Recovered Container status    */
DECL|method|recoverActiveContainer (Container container, RecoveredContainerState rcs)
specifier|public
name|void
name|recoverActiveContainer
parameter_list|(
name|Container
name|container
parameter_list|,
name|RecoveredContainerState
name|rcs
parameter_list|)
block|{
name|ExecutionType
name|execType
init|=
name|container
operator|.
name|getContainerTokenIdentifier
argument_list|()
operator|.
name|getExecutionType
argument_list|()
decl_stmt|;
if|if
condition|(
name|rcs
operator|.
name|getStatus
argument_list|()
operator|==
name|RecoveredContainerStatus
operator|.
name|QUEUED
operator|||
name|rcs
operator|.
name|getStatus
argument_list|()
operator|==
name|RecoveredContainerStatus
operator|.
name|PAUSED
condition|)
block|{
if|if
condition|(
name|execType
operator|==
name|ExecutionType
operator|.
name|GUARANTEED
condition|)
block|{
name|queuedGuaranteedContainers
operator|.
name|put
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|execType
operator|==
name|ExecutionType
operator|.
name|OPPORTUNISTIC
condition|)
block|{
name|queuedOpportunisticContainers
operator|.
name|put
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"UnKnown execution type received "
operator|+
name|container
operator|.
name|getContainerId
argument_list|()
operator|+
literal|", execType "
operator|+
name|execType
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rcs
operator|.
name|getStatus
argument_list|()
operator|==
name|RecoveredContainerStatus
operator|.
name|LAUNCHED
condition|)
block|{
name|runningContainers
operator|.
name|put
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|container
argument_list|)
expr_stmt|;
name|utilizationTracker
operator|.
name|addContainerResources
argument_list|(
name|container
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rcs
operator|.
name|getStatus
argument_list|()
operator|!=
name|RecoveredContainerStatus
operator|.
name|COMPLETED
operator|&&
name|rcs
operator|.
name|getCapability
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|launchedContainer
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|allocateContainer
argument_list|(
name|rcs
operator|.
name|getCapability
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Return number of queued containers.    * @return Number of queued containers.    */
DECL|method|getNumQueuedContainers ()
specifier|public
name|int
name|getNumQueuedContainers
parameter_list|()
block|{
return|return
name|this
operator|.
name|queuedGuaranteedContainers
operator|.
name|size
argument_list|()
operator|+
name|this
operator|.
name|queuedOpportunisticContainers
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Return the capacity of the queue for opportunistic containers    * on this node.    * @return queue capacity.    */
DECL|method|getOpportunisticQueueCapacity ()
specifier|public
name|int
name|getOpportunisticQueueCapacity
parameter_list|()
block|{
return|return
name|this
operator|.
name|maxOppQueueLength
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getNumQueuedGuaranteedContainers ()
specifier|public
name|int
name|getNumQueuedGuaranteedContainers
parameter_list|()
block|{
return|return
name|this
operator|.
name|queuedGuaranteedContainers
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getNumQueuedOpportunisticContainers ()
specifier|public
name|int
name|getNumQueuedOpportunisticContainers
parameter_list|()
block|{
return|return
name|this
operator|.
name|queuedOpportunisticContainers
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getNumRunningContainers ()
specifier|public
name|int
name|getNumRunningContainers
parameter_list|()
block|{
return|return
name|this
operator|.
name|runningContainers
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setUsePauseEventForPreemption ( boolean usePauseEventForPreemption)
specifier|public
name|void
name|setUsePauseEventForPreemption
parameter_list|(
name|boolean
name|usePauseEventForPreemption
parameter_list|)
block|{
name|this
operator|.
name|usePauseEventForPreemption
operator|=
name|usePauseEventForPreemption
expr_stmt|;
block|}
DECL|method|getOpportunisticContainersStatus ()
specifier|public
name|OpportunisticContainersStatus
name|getOpportunisticContainersStatus
parameter_list|()
block|{
name|this
operator|.
name|opportunisticContainersStatus
operator|.
name|setQueuedOpportContainers
argument_list|(
name|getNumQueuedOpportunisticContainers
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|opportunisticContainersStatus
operator|.
name|setWaitQueueLength
argument_list|(
name|getNumQueuedContainers
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|opportunisticContainersStatus
operator|.
name|setOpportMemoryUsed
argument_list|(
name|metrics
operator|.
name|getAllocatedOpportunisticGB
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|opportunisticContainersStatus
operator|.
name|setOpportCoresUsed
argument_list|(
name|metrics
operator|.
name|getAllocatedOpportunisticVCores
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|opportunisticContainersStatus
operator|.
name|setRunningOpportContainers
argument_list|(
name|metrics
operator|.
name|getRunningOpportunisticContainers
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|opportunisticContainersStatus
operator|.
name|setOpportQueueCapacity
argument_list|(
name|getOpportunisticQueueCapacity
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|this
operator|.
name|opportunisticContainersStatus
return|;
block|}
DECL|method|onResourcesReclaimed (Container container)
specifier|private
name|void
name|onResourcesReclaimed
parameter_list|(
name|Container
name|container
parameter_list|)
block|{
name|oppContainersToKill
operator|.
name|remove
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
comment|// This could be killed externally for eg. by the ContainerManager,
comment|// in which case, the container might still be queued.
name|Container
name|queued
init|=
name|queuedOpportunisticContainers
operator|.
name|remove
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|queued
operator|==
literal|null
condition|)
block|{
name|queuedGuaranteedContainers
operator|.
name|remove
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Requeue PAUSED containers
if|if
condition|(
name|container
operator|.
name|getContainerState
argument_list|()
operator|==
name|ContainerState
operator|.
name|PAUSED
condition|)
block|{
if|if
condition|(
name|container
operator|.
name|getContainerTokenIdentifier
argument_list|()
operator|.
name|getExecutionType
argument_list|()
operator|==
name|ExecutionType
operator|.
name|GUARANTEED
condition|)
block|{
name|queuedGuaranteedContainers
operator|.
name|put
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|queuedOpportunisticContainers
operator|.
name|put
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
block|}
comment|// decrement only if it was a running container
name|Container
name|completedContainer
init|=
name|runningContainers
operator|.
name|remove
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|)
decl_stmt|;
comment|// only a running container releases resources upon completion
name|boolean
name|resourceReleased
init|=
name|completedContainer
operator|!=
literal|null
decl_stmt|;
if|if
condition|(
name|resourceReleased
condition|)
block|{
name|this
operator|.
name|utilizationTracker
operator|.
name|subtractContainerResource
argument_list|(
name|container
argument_list|)
expr_stmt|;
if|if
condition|(
name|container
operator|.
name|getContainerTokenIdentifier
argument_list|()
operator|.
name|getExecutionType
argument_list|()
operator|==
name|ExecutionType
operator|.
name|OPPORTUNISTIC
condition|)
block|{
name|this
operator|.
name|metrics
operator|.
name|completeOpportunisticContainer
argument_list|(
name|container
operator|.
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|boolean
name|forceStartGuaranteedContainers
init|=
operator|(
name|maxOppQueueLength
operator|<=
literal|0
operator|)
decl_stmt|;
name|startPendingContainers
argument_list|(
name|forceStartGuaranteedContainers
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Start pending containers in the queue.    * @param forceStartGuaranteedContaieners When this is true, start guaranteed    *        container without looking at available resource    */
DECL|method|startPendingContainers (boolean forceStartGuaranteedContaieners)
specifier|private
name|void
name|startPendingContainers
parameter_list|(
name|boolean
name|forceStartGuaranteedContaieners
parameter_list|)
block|{
comment|// Start guaranteed containers that are paused, if resources available.
name|boolean
name|resourcesAvailable
init|=
name|startContainers
argument_list|(
name|queuedGuaranteedContainers
operator|.
name|values
argument_list|()
argument_list|,
name|forceStartGuaranteedContaieners
argument_list|)
decl_stmt|;
comment|// Start opportunistic containers, if resources available.
if|if
condition|(
name|resourcesAvailable
condition|)
block|{
name|startContainers
argument_list|(
name|queuedOpportunisticContainers
operator|.
name|values
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|startContainers ( Collection<Container> containersToBeStarted, boolean force)
specifier|private
name|boolean
name|startContainers
parameter_list|(
name|Collection
argument_list|<
name|Container
argument_list|>
name|containersToBeStarted
parameter_list|,
name|boolean
name|force
parameter_list|)
block|{
name|Iterator
argument_list|<
name|Container
argument_list|>
name|cIter
init|=
name|containersToBeStarted
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|boolean
name|resourcesAvailable
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|cIter
operator|.
name|hasNext
argument_list|()
operator|&&
name|resourcesAvailable
condition|)
block|{
name|Container
name|container
init|=
name|cIter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|tryStartContainer
argument_list|(
name|container
argument_list|,
name|force
argument_list|)
condition|)
block|{
name|cIter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|resourcesAvailable
operator|=
literal|false
expr_stmt|;
block|}
block|}
return|return
name|resourcesAvailable
return|;
block|}
DECL|method|tryStartContainer (Container container, boolean force)
specifier|private
name|boolean
name|tryStartContainer
parameter_list|(
name|Container
name|container
parameter_list|,
name|boolean
name|force
parameter_list|)
block|{
name|boolean
name|containerStarted
init|=
literal|false
decl_stmt|;
comment|// call startContainer without checking available resource when force==true
if|if
condition|(
name|force
operator|||
name|resourceAvailableToStartContainer
argument_list|(
name|container
argument_list|)
condition|)
block|{
name|startContainer
argument_list|(
name|container
argument_list|)
expr_stmt|;
name|containerStarted
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|containerStarted
return|;
block|}
comment|/**    * Check if there is resource available to start a given container    * immediately. (This can be extended to include overallocated resources)    * @param container the container to start    * @return true if container can be launched directly    */
DECL|method|resourceAvailableToStartContainer (Container container)
specifier|private
name|boolean
name|resourceAvailableToStartContainer
parameter_list|(
name|Container
name|container
parameter_list|)
block|{
return|return
name|this
operator|.
name|utilizationTracker
operator|.
name|hasResourcesAvailable
argument_list|(
name|container
argument_list|)
return|;
block|}
DECL|method|enqueueContainer (Container container)
specifier|private
name|boolean
name|enqueueContainer
parameter_list|(
name|Container
name|container
parameter_list|)
block|{
name|boolean
name|isGuaranteedContainer
init|=
name|container
operator|.
name|getContainerTokenIdentifier
argument_list|()
operator|.
name|getExecutionType
argument_list|()
operator|==
name|ExecutionType
operator|.
name|GUARANTEED
decl_stmt|;
name|boolean
name|isQueued
decl_stmt|;
if|if
condition|(
name|isGuaranteedContainer
condition|)
block|{
name|queuedGuaranteedContainers
operator|.
name|put
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|container
argument_list|)
expr_stmt|;
name|isQueued
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|queuedOpportunisticContainers
operator|.
name|size
argument_list|()
operator|<
name|maxOppQueueLength
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Opportunistic container {} will be queued at the NM."
argument_list|,
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
name|queuedOpportunisticContainers
operator|.
name|put
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|container
argument_list|)
expr_stmt|;
name|isQueued
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Opportunistic container [{}] will not be queued at the NM"
operator|+
literal|"since max queue length [{}] has been reached"
argument_list|,
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|maxOppQueueLength
argument_list|)
expr_stmt|;
name|container
operator|.
name|sendKillEvent
argument_list|(
name|ContainerExitStatus
operator|.
name|KILLED_BY_CONTAINER_SCHEDULER
argument_list|,
literal|"Opportunistic container queue is full."
argument_list|)
expr_stmt|;
name|isQueued
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isQueued
condition|)
block|{
try|try
block|{
name|this
operator|.
name|context
operator|.
name|getNMStateStore
argument_list|()
operator|.
name|storeContainerQueued
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not store container ["
operator|+
name|container
operator|.
name|getContainerId
argument_list|()
operator|+
literal|"] state. The Container has been queued."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|isQueued
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|scheduleContainer (Container container)
specifier|protected
name|void
name|scheduleContainer
parameter_list|(
name|Container
name|container
parameter_list|)
block|{
name|boolean
name|isGuaranteedContainer
init|=
name|container
operator|.
name|getContainerTokenIdentifier
argument_list|()
operator|.
name|getExecutionType
argument_list|()
operator|==
name|ExecutionType
operator|.
name|GUARANTEED
decl_stmt|;
comment|// Given a guaranteed container, we enqueue it first and then try to start
comment|// as many queuing guaranteed containers as possible followed by queuing
comment|// opportunistic containers based on remaining resources available. If the
comment|// container still stays in the queue afterwards, we need to preempt just
comment|// enough number of opportunistic containers.
if|if
condition|(
name|isGuaranteedContainer
condition|)
block|{
name|enqueueContainer
argument_list|(
name|container
argument_list|)
expr_stmt|;
comment|// When opportunistic container not allowed (which is determined by
comment|// max-queue length of pending opportunistic containers<= 0), start
comment|// guaranteed containers without looking at available resources.
name|boolean
name|forceStartGuaranteedContainers
init|=
operator|(
name|maxOppQueueLength
operator|<=
literal|0
operator|)
decl_stmt|;
name|startPendingContainers
argument_list|(
name|forceStartGuaranteedContainers
argument_list|)
expr_stmt|;
comment|// if the guaranteed container is queued, we need to preempt opportunistic
comment|// containers for make room for it
if|if
condition|(
name|queuedGuaranteedContainers
operator|.
name|containsKey
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|)
condition|)
block|{
name|reclaimOpportunisticContainerResources
argument_list|(
name|container
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Given an opportunistic container, we first try to start as many queuing
comment|// guaranteed containers as possible followed by queuing opportunistic
comment|// containers based on remaining resource available, then enqueue the
comment|// opportunistic container. If the container is enqueued, we do another
comment|// pass to try to start the newly enqueued opportunistic container.
name|startPendingContainers
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|boolean
name|containerQueued
init|=
name|enqueueContainer
argument_list|(
name|container
argument_list|)
decl_stmt|;
comment|// container may not get queued because the max opportunistic container
comment|// queue length is reached. If so, there is no point doing another pass
if|if
condition|(
name|containerQueued
condition|)
block|{
name|startPendingContainers
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|reclaimOpportunisticContainerResources (Container container)
specifier|private
name|void
name|reclaimOpportunisticContainerResources
parameter_list|(
name|Container
name|container
parameter_list|)
block|{
name|List
argument_list|<
name|Container
argument_list|>
name|extraOppContainersToReclaim
init|=
name|pickOpportunisticContainersToReclaimResources
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|)
decl_stmt|;
comment|// Kill the opportunistic containers that were chosen.
for|for
control|(
name|Container
name|contToReclaim
range|:
name|extraOppContainersToReclaim
control|)
block|{
name|String
name|preemptionAction
init|=
name|usePauseEventForPreemption
operator|==
literal|true
condition|?
literal|"paused"
else|:
literal|"killed"
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Container {} will be {} to start the "
operator|+
literal|"execution of guaranteed container {}."
argument_list|,
name|contToReclaim
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|preemptionAction
argument_list|,
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|usePauseEventForPreemption
condition|)
block|{
name|contToReclaim
operator|.
name|sendPauseEvent
argument_list|(
literal|"Container Paused to make room for Guaranteed Container"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|contToReclaim
operator|.
name|sendKillEvent
argument_list|(
name|ContainerExitStatus
operator|.
name|KILLED_BY_CONTAINER_SCHEDULER
argument_list|,
literal|"Container Killed to make room for Guaranteed Container."
argument_list|)
expr_stmt|;
block|}
name|oppContainersToKill
operator|.
name|put
argument_list|(
name|contToReclaim
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|contToReclaim
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|startContainer (Container container)
specifier|private
name|void
name|startContainer
parameter_list|(
name|Container
name|container
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting container ["
operator|+
name|container
operator|.
name|getContainerId
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
comment|// Skip to put into runningContainers and addUtilization when recover
if|if
condition|(
operator|!
name|runningContainers
operator|.
name|containsKey
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|)
condition|)
block|{
name|runningContainers
operator|.
name|put
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|container
argument_list|)
expr_stmt|;
name|this
operator|.
name|utilizationTracker
operator|.
name|addContainerResources
argument_list|(
name|container
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|container
operator|.
name|getContainerTokenIdentifier
argument_list|()
operator|.
name|getExecutionType
argument_list|()
operator|==
name|ExecutionType
operator|.
name|OPPORTUNISTIC
condition|)
block|{
name|this
operator|.
name|metrics
operator|.
name|startOpportunisticContainer
argument_list|(
name|container
operator|.
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|container
operator|.
name|sendLaunchEvent
argument_list|()
expr_stmt|;
block|}
DECL|method|pickOpportunisticContainersToReclaimResources ( ContainerId containerToStartId)
specifier|private
name|List
argument_list|<
name|Container
argument_list|>
name|pickOpportunisticContainersToReclaimResources
parameter_list|(
name|ContainerId
name|containerToStartId
parameter_list|)
block|{
comment|// The opportunistic containers that need to be killed for the
comment|// given container to start.
name|List
argument_list|<
name|Container
argument_list|>
name|extraOpportContainersToKill
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Track resources that need to be freed.
name|ResourceUtilization
name|resourcesToFreeUp
init|=
name|resourcesToFreeUp
argument_list|(
name|containerToStartId
argument_list|)
decl_stmt|;
comment|// Go over the running opportunistic containers.
comment|// Use a descending iterator to kill more recently started containers.
name|Iterator
argument_list|<
name|Container
argument_list|>
name|lifoIterator
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|(
name|runningContainers
operator|.
name|values
argument_list|()
argument_list|)
operator|.
name|descendingIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|lifoIterator
operator|.
name|hasNext
argument_list|()
operator|&&
operator|!
name|hasSufficientResources
argument_list|(
name|resourcesToFreeUp
argument_list|)
condition|)
block|{
name|Container
name|runningCont
init|=
name|lifoIterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|runningCont
operator|.
name|getContainerTokenIdentifier
argument_list|()
operator|.
name|getExecutionType
argument_list|()
operator|==
name|ExecutionType
operator|.
name|OPPORTUNISTIC
condition|)
block|{
if|if
condition|(
name|oppContainersToKill
operator|.
name|containsKey
argument_list|(
name|runningCont
operator|.
name|getContainerId
argument_list|()
argument_list|)
condition|)
block|{
comment|// These containers have already been marked to be killed.
comment|// So exclude them..
continue|continue;
block|}
name|extraOpportContainersToKill
operator|.
name|add
argument_list|(
name|runningCont
argument_list|)
expr_stmt|;
name|ContainersMonitor
operator|.
name|decreaseResourceUtilization
argument_list|(
name|getContainersMonitor
argument_list|()
argument_list|,
name|resourcesToFreeUp
argument_list|,
name|runningCont
operator|.
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|hasSufficientResources
argument_list|(
name|resourcesToFreeUp
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"There are no sufficient resources to start guaranteed [{}]"
operator|+
literal|"at the moment. Opportunistic containers are in the process of"
operator|+
literal|"being killed to make room."
argument_list|,
name|containerToStartId
argument_list|)
expr_stmt|;
block|}
return|return
name|extraOpportContainersToKill
return|;
block|}
DECL|method|hasSufficientResources ( ResourceUtilization resourcesToFreeUp)
specifier|private
name|boolean
name|hasSufficientResources
parameter_list|(
name|ResourceUtilization
name|resourcesToFreeUp
parameter_list|)
block|{
return|return
name|resourcesToFreeUp
operator|.
name|getPhysicalMemory
argument_list|()
operator|<=
literal|0
operator|&&
name|resourcesToFreeUp
operator|.
name|getVirtualMemory
argument_list|()
operator|<=
literal|0
operator|&&
name|resourcesToFreeUp
operator|.
name|getCPU
argument_list|()
operator|<=
literal|0
return|;
block|}
DECL|method|resourcesToFreeUp ( ContainerId containerToStartId)
specifier|private
name|ResourceUtilization
name|resourcesToFreeUp
parameter_list|(
name|ContainerId
name|containerToStartId
parameter_list|)
block|{
comment|// Get allocation of currently allocated containers.
name|ResourceUtilization
name|resourceAllocationToFreeUp
init|=
name|ResourceUtilization
operator|.
name|newInstance
argument_list|(
name|this
operator|.
name|utilizationTracker
operator|.
name|getCurrentUtilization
argument_list|()
argument_list|)
decl_stmt|;
comment|// Add to the allocation the allocation of the pending guaranteed
comment|// containers that will start before the current container will be started.
for|for
control|(
name|Container
name|container
range|:
name|queuedGuaranteedContainers
operator|.
name|values
argument_list|()
control|)
block|{
name|ContainersMonitor
operator|.
name|increaseResourceUtilization
argument_list|(
name|getContainersMonitor
argument_list|()
argument_list|,
name|resourceAllocationToFreeUp
argument_list|,
name|container
operator|.
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|container
operator|.
name|getContainerId
argument_list|()
operator|.
name|equals
argument_list|(
name|containerToStartId
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
comment|// These resources are being freed, likely at the behest of another
comment|// guaranteed container..
for|for
control|(
name|Container
name|container
range|:
name|oppContainersToKill
operator|.
name|values
argument_list|()
control|)
block|{
name|ContainersMonitor
operator|.
name|decreaseResourceUtilization
argument_list|(
name|getContainersMonitor
argument_list|()
argument_list|,
name|resourceAllocationToFreeUp
argument_list|,
name|container
operator|.
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Subtract the overall node resources.
name|getContainersMonitor
argument_list|()
operator|.
name|subtractNodeResourcesFromResourceUtilization
argument_list|(
name|resourceAllocationToFreeUp
argument_list|)
expr_stmt|;
return|return
name|resourceAllocationToFreeUp
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|updateQueuingLimit (ContainerQueuingLimit limit)
specifier|public
name|void
name|updateQueuingLimit
parameter_list|(
name|ContainerQueuingLimit
name|limit
parameter_list|)
block|{
name|this
operator|.
name|queuingLimit
operator|.
name|setMaxQueueLength
argument_list|(
name|limit
operator|.
name|getMaxQueueLength
argument_list|()
argument_list|)
expr_stmt|;
comment|// YARN-2886 should add support for wait-times. Include wait time as
comment|// well once it is implemented
if|if
condition|(
operator|(
name|queuingLimit
operator|.
name|getMaxQueueLength
argument_list|()
operator|>
operator|-
literal|1
operator|)
operator|&&
operator|(
name|queuingLimit
operator|.
name|getMaxQueueLength
argument_list|()
operator|<
name|queuedOpportunisticContainers
operator|.
name|size
argument_list|()
operator|)
condition|)
block|{
name|dispatcher
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|ContainerSchedulerEvent
argument_list|(
literal|null
argument_list|,
name|ContainerSchedulerEventType
operator|.
name|SHED_QUEUED_CONTAINERS
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|shedQueuedOpportunisticContainers ()
specifier|private
name|void
name|shedQueuedOpportunisticContainers
parameter_list|()
block|{
name|int
name|numAllowed
init|=
name|this
operator|.
name|queuingLimit
operator|.
name|getMaxQueueLength
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Container
argument_list|>
name|containerIter
init|=
name|queuedOpportunisticContainers
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|containerIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Container
name|container
init|=
name|containerIter
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// Do not shed PAUSED containers
if|if
condition|(
name|container
operator|.
name|getContainerState
argument_list|()
operator|!=
name|ContainerState
operator|.
name|PAUSED
condition|)
block|{
if|if
condition|(
name|numAllowed
operator|<=
literal|0
condition|)
block|{
name|container
operator|.
name|sendKillEvent
argument_list|(
name|ContainerExitStatus
operator|.
name|KILLED_BY_CONTAINER_SCHEDULER
argument_list|,
literal|"Container De-queued to meet NM queuing limits."
argument_list|)
expr_stmt|;
name|containerIter
operator|.
name|remove
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Opportunistic container {} will be killed to meet NM queuing"
operator|+
literal|" limits."
argument_list|,
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|numAllowed
operator|--
expr_stmt|;
block|}
block|}
block|}
DECL|method|getContainersMonitor ()
specifier|public
name|ContainersMonitor
name|getContainersMonitor
parameter_list|()
block|{
return|return
name|this
operator|.
name|context
operator|.
name|getContainerManager
argument_list|()
operator|.
name|getContainersMonitor
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getCurrentUtilization ()
specifier|public
name|ResourceUtilization
name|getCurrentUtilization
parameter_list|()
block|{
return|return
name|this
operator|.
name|utilizationTracker
operator|.
name|getCurrentUtilization
argument_list|()
return|;
block|}
block|}
end_class

end_unit

