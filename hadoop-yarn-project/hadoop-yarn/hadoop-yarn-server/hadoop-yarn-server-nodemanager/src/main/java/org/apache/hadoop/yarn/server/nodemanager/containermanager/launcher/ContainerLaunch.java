begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/** * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.nodemanager.containermanager.launcher
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|launcher
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CreateFlag
operator|.
name|CREATE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CreateFlag
operator|.
name|OVERWRITE
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocalDirAllocator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|Credentials
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|ApplicationConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|ApplicationConstants
operator|.
name|Environment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerExitStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerLaunchContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|SignalContainerCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|event
operator|.
name|Dispatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|ConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|ipc
operator|.
name|RPCUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|ContainerExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|ContainerExecutor
operator|.
name|DelayedProcessKiller
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|ContainerExecutor
operator|.
name|ExitCode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|ContainerExecutor
operator|.
name|Signal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|LocalDirsHandlerService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|WindowsSecureContainerExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|ContainerManagerImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|application
operator|.
name|Application
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|container
operator|.
name|Container
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|container
operator|.
name|ContainerDiagnosticsUpdateEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|container
operator|.
name|ContainerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|container
operator|.
name|ContainerEventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|container
operator|.
name|ContainerExitEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|container
operator|.
name|ContainerKillEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|container
operator|.
name|ContainerState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|linux
operator|.
name|runtime
operator|.
name|DockerLinuxContainerRuntime
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|localizer
operator|.
name|ContainerLocalizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|localizer
operator|.
name|ResourceLocalizationService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|executor
operator|.
name|ContainerPrepareContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|executor
operator|.
name|ContainerReapContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|executor
operator|.
name|ContainerSignalContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|executor
operator|.
name|ContainerStartContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|util
operator|.
name|ProcessIdFileReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|Apps
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|AuxiliaryServiceHelper
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
DECL|class|ContainerLaunch
specifier|public
class|class
name|ContainerLaunch
implements|implements
name|Callable
argument_list|<
name|Integer
argument_list|>
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ContainerLaunch
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|CONTAINER_PRE_LAUNCH_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|CONTAINER_PRE_LAUNCH_PREFIX
init|=
literal|"prelaunch"
decl_stmt|;
DECL|field|CONTAINER_PRE_LAUNCH_STDOUT
specifier|public
specifier|static
specifier|final
name|String
name|CONTAINER_PRE_LAUNCH_STDOUT
init|=
name|CONTAINER_PRE_LAUNCH_PREFIX
operator|+
literal|".out"
decl_stmt|;
DECL|field|CONTAINER_PRE_LAUNCH_STDERR
specifier|public
specifier|static
specifier|final
name|String
name|CONTAINER_PRE_LAUNCH_STDERR
init|=
name|CONTAINER_PRE_LAUNCH_PREFIX
operator|+
literal|".err"
decl_stmt|;
DECL|field|CONTAINER_SCRIPT
specifier|public
specifier|static
specifier|final
name|String
name|CONTAINER_SCRIPT
init|=
name|Shell
operator|.
name|appendScriptExtension
argument_list|(
literal|"launch_container"
argument_list|)
decl_stmt|;
DECL|field|FINAL_CONTAINER_TOKENS_FILE
specifier|public
specifier|static
specifier|final
name|String
name|FINAL_CONTAINER_TOKENS_FILE
init|=
literal|"container_tokens"
decl_stmt|;
DECL|field|PID_FILE_NAME_FMT
specifier|private
specifier|static
specifier|final
name|String
name|PID_FILE_NAME_FMT
init|=
literal|"%s.pid"
decl_stmt|;
DECL|field|EXIT_CODE_FILE_SUFFIX
specifier|private
specifier|static
specifier|final
name|String
name|EXIT_CODE_FILE_SUFFIX
init|=
literal|".exitcode"
decl_stmt|;
DECL|field|dispatcher
specifier|protected
specifier|final
name|Dispatcher
name|dispatcher
decl_stmt|;
DECL|field|exec
specifier|protected
specifier|final
name|ContainerExecutor
name|exec
decl_stmt|;
DECL|field|app
specifier|protected
specifier|final
name|Application
name|app
decl_stmt|;
DECL|field|container
specifier|protected
specifier|final
name|Container
name|container
decl_stmt|;
DECL|field|conf
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
DECL|field|context
specifier|private
specifier|final
name|Context
name|context
decl_stmt|;
DECL|field|containerManager
specifier|private
specifier|final
name|ContainerManagerImpl
name|containerManager
decl_stmt|;
DECL|field|containerAlreadyLaunched
specifier|protected
name|AtomicBoolean
name|containerAlreadyLaunched
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|field|shouldPauseContainer
specifier|protected
name|AtomicBoolean
name|shouldPauseContainer
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|field|completed
specifier|protected
name|AtomicBoolean
name|completed
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|field|killedBeforeStart
specifier|private
specifier|volatile
name|boolean
name|killedBeforeStart
init|=
literal|false
decl_stmt|;
DECL|field|sleepDelayBeforeSigKill
specifier|private
name|long
name|sleepDelayBeforeSigKill
init|=
literal|250
decl_stmt|;
DECL|field|maxKillWaitTime
specifier|private
name|long
name|maxKillWaitTime
init|=
literal|2000
decl_stmt|;
DECL|field|pidFilePath
specifier|protected
name|Path
name|pidFilePath
init|=
literal|null
decl_stmt|;
DECL|field|dirsHandler
specifier|protected
specifier|final
name|LocalDirsHandlerService
name|dirsHandler
decl_stmt|;
DECL|method|ContainerLaunch (Context context, Configuration configuration, Dispatcher dispatcher, ContainerExecutor exec, Application app, Container container, LocalDirsHandlerService dirsHandler, ContainerManagerImpl containerManager)
specifier|public
name|ContainerLaunch
parameter_list|(
name|Context
name|context
parameter_list|,
name|Configuration
name|configuration
parameter_list|,
name|Dispatcher
name|dispatcher
parameter_list|,
name|ContainerExecutor
name|exec
parameter_list|,
name|Application
name|app
parameter_list|,
name|Container
name|container
parameter_list|,
name|LocalDirsHandlerService
name|dirsHandler
parameter_list|,
name|ContainerManagerImpl
name|containerManager
parameter_list|)
block|{
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|configuration
expr_stmt|;
name|this
operator|.
name|app
operator|=
name|app
expr_stmt|;
name|this
operator|.
name|exec
operator|=
name|exec
expr_stmt|;
name|this
operator|.
name|container
operator|=
name|container
expr_stmt|;
name|this
operator|.
name|dispatcher
operator|=
name|dispatcher
expr_stmt|;
name|this
operator|.
name|dirsHandler
operator|=
name|dirsHandler
expr_stmt|;
name|this
operator|.
name|containerManager
operator|=
name|containerManager
expr_stmt|;
name|this
operator|.
name|sleepDelayBeforeSigKill
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|YarnConfiguration
operator|.
name|NM_SLEEP_DELAY_BEFORE_SIGKILL_MS
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_NM_SLEEP_DELAY_BEFORE_SIGKILL_MS
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxKillWaitTime
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|YarnConfiguration
operator|.
name|NM_PROCESS_KILL_WAIT_MS
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_NM_PROCESS_KILL_WAIT_MS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|expandEnvironment (String var, Path containerLogDir)
specifier|public
specifier|static
name|String
name|expandEnvironment
parameter_list|(
name|String
name|var
parameter_list|,
name|Path
name|containerLogDir
parameter_list|)
block|{
name|var
operator|=
name|var
operator|.
name|replace
argument_list|(
name|ApplicationConstants
operator|.
name|LOG_DIR_EXPANSION_VAR
argument_list|,
name|containerLogDir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|var
operator|=
name|var
operator|.
name|replace
argument_list|(
name|ApplicationConstants
operator|.
name|CLASS_PATH_SEPARATOR
argument_list|,
name|File
operator|.
name|pathSeparator
argument_list|)
expr_stmt|;
comment|// replace parameter expansion marker. e.g. {{VAR}} on Windows is replaced
comment|// as %VAR% and on Linux replaced as "$VAR"
if|if
condition|(
name|Shell
operator|.
name|WINDOWS
condition|)
block|{
name|var
operator|=
name|var
operator|.
name|replaceAll
argument_list|(
literal|"(\\{\\{)|(\\}\\})"
argument_list|,
literal|"%"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|var
operator|=
name|var
operator|.
name|replace
argument_list|(
name|ApplicationConstants
operator|.
name|PARAMETER_EXPANSION_LEFT
argument_list|,
literal|"$"
argument_list|)
expr_stmt|;
name|var
operator|=
name|var
operator|.
name|replace
argument_list|(
name|ApplicationConstants
operator|.
name|PARAMETER_EXPANSION_RIGHT
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
return|return
name|var
return|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// dispatcher not typed
DECL|method|call ()
specifier|public
name|Integer
name|call
parameter_list|()
block|{
if|if
condition|(
operator|!
name|validateContainerState
argument_list|()
condition|)
block|{
return|return
literal|0
return|;
block|}
specifier|final
name|ContainerLaunchContext
name|launchContext
init|=
name|container
operator|.
name|getLaunchContext
argument_list|()
decl_stmt|;
name|ContainerId
name|containerID
init|=
name|container
operator|.
name|getContainerId
argument_list|()
decl_stmt|;
name|String
name|containerIdStr
init|=
name|containerID
operator|.
name|toString
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|command
init|=
name|launchContext
operator|.
name|getCommands
argument_list|()
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|Path
name|containerLogDir
decl_stmt|;
try|try
block|{
name|Map
argument_list|<
name|Path
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|localResources
init|=
name|getLocalizedResources
argument_list|()
decl_stmt|;
specifier|final
name|String
name|user
init|=
name|container
operator|.
name|getUser
argument_list|()
decl_stmt|;
comment|// /////////////////////////// Variable expansion
comment|// Before the container script gets written out.
name|List
argument_list|<
name|String
argument_list|>
name|newCmds
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|command
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|appIdStr
init|=
name|app
operator|.
name|getAppId
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|relativeContainerLogDir
init|=
name|ContainerLaunch
operator|.
name|getRelativeContainerLogDir
argument_list|(
name|appIdStr
argument_list|,
name|containerIdStr
argument_list|)
decl_stmt|;
name|containerLogDir
operator|=
name|dirsHandler
operator|.
name|getLogPathForWrite
argument_list|(
name|relativeContainerLogDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|recordContainerLogDir
argument_list|(
name|containerID
argument_list|,
name|containerLogDir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|str
range|:
name|command
control|)
block|{
comment|// TODO: Should we instead work via symlinks without this grammar?
name|newCmds
operator|.
name|add
argument_list|(
name|expandEnvironment
argument_list|(
name|str
argument_list|,
name|containerLogDir
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|launchContext
operator|.
name|setCommands
argument_list|(
name|newCmds
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|environment
init|=
name|launchContext
operator|.
name|getEnvironment
argument_list|()
decl_stmt|;
comment|// Make a copy of env to iterate& do variable expansion
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|environment
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|value
operator|=
name|expandEnvironment
argument_list|(
name|value
argument_list|,
name|containerLogDir
argument_list|)
expr_stmt|;
name|entry
operator|.
name|setValue
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
comment|// /////////////////////////// End of variable expansion
name|FileContext
name|lfs
init|=
name|FileContext
operator|.
name|getLocalFSFileContext
argument_list|()
decl_stmt|;
name|Path
name|nmPrivateContainerScriptPath
init|=
name|dirsHandler
operator|.
name|getLocalPathForWrite
argument_list|(
name|getContainerPrivateDir
argument_list|(
name|appIdStr
argument_list|,
name|containerIdStr
argument_list|)
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|CONTAINER_SCRIPT
argument_list|)
decl_stmt|;
name|Path
name|nmPrivateTokensPath
init|=
name|dirsHandler
operator|.
name|getLocalPathForWrite
argument_list|(
name|getContainerPrivateDir
argument_list|(
name|appIdStr
argument_list|,
name|containerIdStr
argument_list|)
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|String
operator|.
name|format
argument_list|(
name|ContainerLocalizer
operator|.
name|TOKEN_FILE_NAME_FMT
argument_list|,
name|containerIdStr
argument_list|)
argument_list|)
decl_stmt|;
name|Path
name|nmPrivateClasspathJarDir
init|=
name|dirsHandler
operator|.
name|getLocalPathForWrite
argument_list|(
name|getContainerPrivateDir
argument_list|(
name|appIdStr
argument_list|,
name|containerIdStr
argument_list|)
argument_list|)
decl_stmt|;
comment|// Select the working directory for the container
name|Path
name|containerWorkDir
init|=
name|deriveContainerWorkDir
argument_list|()
decl_stmt|;
name|recordContainerWorkDir
argument_list|(
name|containerID
argument_list|,
name|containerWorkDir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|pidFileSubpath
init|=
name|getPidFileSubpath
argument_list|(
name|appIdStr
argument_list|,
name|containerIdStr
argument_list|)
decl_stmt|;
comment|// pid file should be in nm private dir so that it is not
comment|// accessible by users
name|pidFilePath
operator|=
name|dirsHandler
operator|.
name|getLocalPathForWrite
argument_list|(
name|pidFileSubpath
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|localDirs
init|=
name|dirsHandler
operator|.
name|getLocalDirs
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|logDirs
init|=
name|dirsHandler
operator|.
name|getLogDirs
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|filecacheDirs
init|=
name|getNMFilecacheDirs
argument_list|(
name|localDirs
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|userLocalDirs
init|=
name|getUserLocalDirs
argument_list|(
name|localDirs
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|containerLocalDirs
init|=
name|getContainerLocalDirs
argument_list|(
name|localDirs
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|containerLogDirs
init|=
name|getContainerLogDirs
argument_list|(
name|logDirs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dirsHandler
operator|.
name|areDisksHealthy
argument_list|()
condition|)
block|{
name|ret
operator|=
name|ContainerExitStatus
operator|.
name|DISKS_FAILED
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Most of the disks failed. "
operator|+
name|dirsHandler
operator|.
name|getDisksHealthReport
argument_list|(
literal|false
argument_list|)
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|Path
argument_list|>
name|appDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|(
name|localDirs
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|localDir
range|:
name|localDirs
control|)
block|{
name|Path
name|usersdir
init|=
operator|new
name|Path
argument_list|(
name|localDir
argument_list|,
name|ContainerLocalizer
operator|.
name|USERCACHE
argument_list|)
decl_stmt|;
name|Path
name|userdir
init|=
operator|new
name|Path
argument_list|(
name|usersdir
argument_list|,
name|user
argument_list|)
decl_stmt|;
name|Path
name|appsdir
init|=
operator|new
name|Path
argument_list|(
name|userdir
argument_list|,
name|ContainerLocalizer
operator|.
name|APPCACHE
argument_list|)
decl_stmt|;
name|appDirs
operator|.
name|add
argument_list|(
operator|new
name|Path
argument_list|(
name|appsdir
argument_list|,
name|appIdStr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Set the token location too.
name|environment
operator|.
name|put
argument_list|(
name|ApplicationConstants
operator|.
name|CONTAINER_TOKEN_FILE_ENV_NAME
argument_list|,
operator|new
name|Path
argument_list|(
name|containerWorkDir
argument_list|,
name|FINAL_CONTAINER_TOKENS_FILE
argument_list|)
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
comment|// /////////// Write out the container-script in the nmPrivate space.
try|try
init|(
name|DataOutputStream
name|containerScriptOutStream
init|=
name|lfs
operator|.
name|create
argument_list|(
name|nmPrivateContainerScriptPath
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|CREATE
argument_list|,
name|OVERWRITE
argument_list|)
argument_list|)
init|)
block|{
comment|// Sanitize the container's environment
name|sanitizeEnv
argument_list|(
name|environment
argument_list|,
name|containerWorkDir
argument_list|,
name|appDirs
argument_list|,
name|userLocalDirs
argument_list|,
name|containerLogDirs
argument_list|,
name|localResources
argument_list|,
name|nmPrivateClasspathJarDir
argument_list|)
expr_stmt|;
name|prepareContainer
argument_list|(
name|localResources
argument_list|,
name|containerLocalDirs
argument_list|)
expr_stmt|;
comment|// Write out the environment
name|exec
operator|.
name|writeLaunchEnv
argument_list|(
name|containerScriptOutStream
argument_list|,
name|environment
argument_list|,
name|localResources
argument_list|,
name|launchContext
operator|.
name|getCommands
argument_list|()
argument_list|,
operator|new
name|Path
argument_list|(
name|containerLogDirs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
comment|// /////////// End of writing out container-script
comment|// /////////// Write out the container-tokens in the nmPrivate space.
try|try
init|(
name|DataOutputStream
name|tokensOutStream
init|=
name|lfs
operator|.
name|create
argument_list|(
name|nmPrivateTokensPath
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|CREATE
argument_list|,
name|OVERWRITE
argument_list|)
argument_list|)
init|)
block|{
name|Credentials
name|creds
init|=
name|container
operator|.
name|getCredentials
argument_list|()
decl_stmt|;
name|creds
operator|.
name|writeTokenStorageToStream
argument_list|(
name|tokensOutStream
argument_list|)
expr_stmt|;
block|}
comment|// /////////// End of writing out container-tokens
name|ret
operator|=
name|launchContainer
argument_list|(
operator|new
name|ContainerStartContext
operator|.
name|Builder
argument_list|()
operator|.
name|setContainer
argument_list|(
name|container
argument_list|)
operator|.
name|setLocalizedResources
argument_list|(
name|localResources
argument_list|)
operator|.
name|setNmPrivateContainerScriptPath
argument_list|(
name|nmPrivateContainerScriptPath
argument_list|)
operator|.
name|setNmPrivateTokensPath
argument_list|(
name|nmPrivateTokensPath
argument_list|)
operator|.
name|setUser
argument_list|(
name|user
argument_list|)
operator|.
name|setAppId
argument_list|(
name|appIdStr
argument_list|)
operator|.
name|setContainerWorkDir
argument_list|(
name|containerWorkDir
argument_list|)
operator|.
name|setLocalDirs
argument_list|(
name|localDirs
argument_list|)
operator|.
name|setLogDirs
argument_list|(
name|logDirs
argument_list|)
operator|.
name|setFilecacheDirs
argument_list|(
name|filecacheDirs
argument_list|)
operator|.
name|setUserLocalDirs
argument_list|(
name|userLocalDirs
argument_list|)
operator|.
name|setContainerLocalDirs
argument_list|(
name|containerLocalDirs
argument_list|)
operator|.
name|setContainerLogDirs
argument_list|(
name|containerLogDirs
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ConfigurationException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to launch container due to configuration error."
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|dispatcher
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|ContainerExitEvent
argument_list|(
name|containerID
argument_list|,
name|ContainerEventType
operator|.
name|CONTAINER_EXITED_WITH_FAILURE
argument_list|,
name|ret
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Mark the node as unhealthy
name|context
operator|.
name|getNodeStatusUpdater
argument_list|()
operator|.
name|reportException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to launch container."
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|dispatcher
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|ContainerExitEvent
argument_list|(
name|containerID
argument_list|,
name|ContainerEventType
operator|.
name|CONTAINER_EXITED_WITH_FAILURE
argument_list|,
name|ret
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
finally|finally
block|{
name|setContainerCompletedStatus
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
name|handleContainerExitCode
argument_list|(
name|ret
argument_list|,
name|containerLogDir
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
DECL|method|deriveContainerWorkDir ()
specifier|private
name|Path
name|deriveContainerWorkDir
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|String
name|containerWorkDirPath
init|=
name|ContainerLocalizer
operator|.
name|USERCACHE
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|container
operator|.
name|getUser
argument_list|()
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|ContainerLocalizer
operator|.
name|APPCACHE
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|app
operator|.
name|getAppId
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|container
operator|.
name|getContainerId
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|containerWorkDir
init|=
name|dirsHandler
operator|.
name|getLocalPathForWrite
argument_list|(
name|containerWorkDirPath
argument_list|,
name|LocalDirAllocator
operator|.
name|SIZE_UNKNOWN
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|containerWorkDir
return|;
block|}
DECL|method|prepareContainer (Map<Path, List<String>> localResources, List<String> containerLocalDirs)
specifier|private
name|void
name|prepareContainer
parameter_list|(
name|Map
argument_list|<
name|Path
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|localResources
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|containerLocalDirs
parameter_list|)
throws|throws
name|IOException
block|{
name|exec
operator|.
name|prepareContainer
argument_list|(
operator|new
name|ContainerPrepareContext
operator|.
name|Builder
argument_list|()
operator|.
name|setContainer
argument_list|(
name|container
argument_list|)
operator|.
name|setLocalizedResources
argument_list|(
name|localResources
argument_list|)
operator|.
name|setUser
argument_list|(
name|container
operator|.
name|getUser
argument_list|()
argument_list|)
operator|.
name|setContainerLocalDirs
argument_list|(
name|containerLocalDirs
argument_list|)
operator|.
name|setCommands
argument_list|(
name|container
operator|.
name|getLaunchContext
argument_list|()
operator|.
name|getCommands
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|validateContainerState ()
specifier|protected
name|boolean
name|validateContainerState
parameter_list|()
block|{
comment|// CONTAINER_KILLED_ON_REQUEST should not be missed if the container
comment|// is already at KILLING
if|if
condition|(
name|container
operator|.
name|getContainerState
argument_list|()
operator|==
name|ContainerState
operator|.
name|KILLING
condition|)
block|{
name|dispatcher
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|ContainerExitEvent
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|ContainerEventType
operator|.
name|CONTAINER_KILLED_ON_REQUEST
argument_list|,
name|Shell
operator|.
name|WINDOWS
condition|?
name|ExitCode
operator|.
name|FORCE_KILLED
operator|.
name|getExitCode
argument_list|()
else|:
name|ExitCode
operator|.
name|TERMINATED
operator|.
name|getExitCode
argument_list|()
argument_list|,
literal|"Container terminated before launch."
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|getContainerLogDirs (List<String> logDirs)
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getContainerLogDirs
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|logDirs
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|containerLogDirs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|logDirs
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|appIdStr
init|=
name|app
operator|.
name|getAppId
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|containerIdStr
init|=
name|container
operator|.
name|getContainerId
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|relativeContainerLogDir
init|=
name|ContainerLaunch
operator|.
name|getRelativeContainerLogDir
argument_list|(
name|appIdStr
argument_list|,
name|containerIdStr
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|logDir
range|:
name|logDirs
control|)
block|{
name|containerLogDirs
operator|.
name|add
argument_list|(
name|logDir
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|relativeContainerLogDir
argument_list|)
expr_stmt|;
block|}
return|return
name|containerLogDirs
return|;
block|}
DECL|method|getContainerLocalDirs (List<String> localDirs)
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getContainerLocalDirs
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|localDirs
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|containerLocalDirs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|localDirs
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|user
init|=
name|container
operator|.
name|getUser
argument_list|()
decl_stmt|;
name|String
name|appIdStr
init|=
name|app
operator|.
name|getAppId
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|relativeContainerLocalDir
init|=
name|ContainerLocalizer
operator|.
name|USERCACHE
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|user
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|ContainerLocalizer
operator|.
name|APPCACHE
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|appIdStr
operator|+
name|Path
operator|.
name|SEPARATOR
decl_stmt|;
for|for
control|(
name|String
name|localDir
range|:
name|localDirs
control|)
block|{
name|containerLocalDirs
operator|.
name|add
argument_list|(
name|localDir
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|relativeContainerLocalDir
argument_list|)
expr_stmt|;
block|}
return|return
name|containerLocalDirs
return|;
block|}
DECL|method|getUserLocalDirs (List<String> localDirs)
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getUserLocalDirs
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|localDirs
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|userLocalDirs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|localDirs
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|user
init|=
name|container
operator|.
name|getUser
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|localDir
range|:
name|localDirs
control|)
block|{
name|String
name|userLocalDir
init|=
name|localDir
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|ContainerLocalizer
operator|.
name|USERCACHE
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|user
operator|+
name|Path
operator|.
name|SEPARATOR
decl_stmt|;
name|userLocalDirs
operator|.
name|add
argument_list|(
name|userLocalDir
argument_list|)
expr_stmt|;
block|}
return|return
name|userLocalDirs
return|;
block|}
DECL|method|getNMFilecacheDirs (List<String> localDirs)
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getNMFilecacheDirs
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|localDirs
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|filecacheDirs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|localDirs
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|localDir
range|:
name|localDirs
control|)
block|{
name|String
name|filecacheDir
init|=
name|localDir
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|ContainerLocalizer
operator|.
name|FILECACHE
decl_stmt|;
name|filecacheDirs
operator|.
name|add
argument_list|(
name|filecacheDir
argument_list|)
expr_stmt|;
block|}
return|return
name|filecacheDirs
return|;
block|}
DECL|method|getLocalizedResources ()
specifier|protected
name|Map
argument_list|<
name|Path
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|getLocalizedResources
parameter_list|()
throws|throws
name|YarnException
block|{
name|Map
argument_list|<
name|Path
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|localResources
init|=
name|container
operator|.
name|getLocalizedResources
argument_list|()
decl_stmt|;
if|if
condition|(
name|localResources
operator|==
literal|null
condition|)
block|{
throw|throw
name|RPCUtil
operator|.
name|getRemoteException
argument_list|(
literal|"Unable to get local resources when Container "
operator|+
name|container
operator|+
literal|" is at "
operator|+
name|container
operator|.
name|getContainerState
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|localResources
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|launchContainer (ContainerStartContext ctx)
specifier|protected
name|int
name|launchContainer
parameter_list|(
name|ContainerStartContext
name|ctx
parameter_list|)
throws|throws
name|IOException
throws|,
name|ConfigurationException
block|{
name|ContainerId
name|containerId
init|=
name|container
operator|.
name|getContainerId
argument_list|()
decl_stmt|;
if|if
condition|(
name|container
operator|.
name|isMarkedForKilling
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Container "
operator|+
name|containerId
operator|+
literal|" not launched as it has already "
operator|+
literal|"been marked for Killing"
argument_list|)
expr_stmt|;
name|this
operator|.
name|killedBeforeStart
operator|=
literal|true
expr_stmt|;
return|return
name|ExitCode
operator|.
name|TERMINATED
operator|.
name|getExitCode
argument_list|()
return|;
block|}
comment|// LaunchContainer is a blocking call. We are here almost means the
comment|// container is launched, so send out the event.
name|dispatcher
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|ContainerEvent
argument_list|(
name|containerId
argument_list|,
name|ContainerEventType
operator|.
name|CONTAINER_LAUNCHED
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|getNMStateStore
argument_list|()
operator|.
name|storeContainerLaunched
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
comment|// Check if the container is signalled to be killed.
if|if
condition|(
operator|!
name|containerAlreadyLaunched
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Container "
operator|+
name|containerId
operator|+
literal|" not launched as "
operator|+
literal|"cleanup already called"
argument_list|)
expr_stmt|;
return|return
name|ExitCode
operator|.
name|TERMINATED
operator|.
name|getExitCode
argument_list|()
return|;
block|}
else|else
block|{
name|exec
operator|.
name|activateContainer
argument_list|(
name|containerId
argument_list|,
name|pidFilePath
argument_list|)
expr_stmt|;
return|return
name|exec
operator|.
name|launchContainer
argument_list|(
name|ctx
argument_list|)
return|;
block|}
block|}
DECL|method|setContainerCompletedStatus (int exitCode)
specifier|protected
name|void
name|setContainerCompletedStatus
parameter_list|(
name|int
name|exitCode
parameter_list|)
block|{
name|ContainerId
name|containerId
init|=
name|container
operator|.
name|getContainerId
argument_list|()
decl_stmt|;
name|completed
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|exec
operator|.
name|deactivateContainer
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|container
operator|.
name|shouldRetry
argument_list|(
name|exitCode
argument_list|)
condition|)
block|{
name|context
operator|.
name|getNMStateStore
argument_list|()
operator|.
name|storeContainerCompleted
argument_list|(
name|containerId
argument_list|,
name|exitCode
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to set exit code for container "
operator|+
name|containerId
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|handleContainerExitCode (int exitCode, Path containerLogDir)
specifier|protected
name|void
name|handleContainerExitCode
parameter_list|(
name|int
name|exitCode
parameter_list|,
name|Path
name|containerLogDir
parameter_list|)
block|{
name|ContainerId
name|containerId
init|=
name|container
operator|.
name|getContainerId
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Container "
operator|+
name|containerId
operator|+
literal|" completed with exit code "
operator|+
name|exitCode
argument_list|)
expr_stmt|;
block|}
name|StringBuilder
name|diagnosticInfo
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"Container exited with a non-zero exit code "
argument_list|)
decl_stmt|;
name|diagnosticInfo
operator|.
name|append
argument_list|(
name|exitCode
argument_list|)
expr_stmt|;
name|diagnosticInfo
operator|.
name|append
argument_list|(
literal|". "
argument_list|)
expr_stmt|;
if|if
condition|(
name|exitCode
operator|==
name|ExitCode
operator|.
name|FORCE_KILLED
operator|.
name|getExitCode
argument_list|()
operator|||
name|exitCode
operator|==
name|ExitCode
operator|.
name|TERMINATED
operator|.
name|getExitCode
argument_list|()
condition|)
block|{
comment|// If the process was killed, Send container_cleanedup_after_kill and
comment|// just break out of this method.
comment|// If Container was killed before starting... NO need to do this.
if|if
condition|(
operator|!
name|killedBeforeStart
condition|)
block|{
name|dispatcher
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|ContainerExitEvent
argument_list|(
name|containerId
argument_list|,
name|ContainerEventType
operator|.
name|CONTAINER_KILLED_ON_REQUEST
argument_list|,
name|exitCode
argument_list|,
name|diagnosticInfo
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|exitCode
operator|!=
literal|0
condition|)
block|{
name|handleContainerExitWithFailure
argument_list|(
name|containerId
argument_list|,
name|exitCode
argument_list|,
name|containerLogDir
argument_list|,
name|diagnosticInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Container "
operator|+
name|containerId
operator|+
literal|" succeeded "
argument_list|)
expr_stmt|;
name|dispatcher
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|ContainerEvent
argument_list|(
name|containerId
argument_list|,
name|ContainerEventType
operator|.
name|CONTAINER_EXITED_WITH_SUCCESS
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Tries to tail and fetch TAIL_SIZE_IN_BYTES of data from the error log.    * ErrorLog filename is not fixed and depends upon app, hence file name    * pattern is used.    *    * @param containerID    * @param ret    * @param containerLogDir    * @param diagnosticInfo    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|handleContainerExitWithFailure (ContainerId containerID, int ret, Path containerLogDir, StringBuilder diagnosticInfo)
specifier|protected
name|void
name|handleContainerExitWithFailure
parameter_list|(
name|ContainerId
name|containerID
parameter_list|,
name|int
name|ret
parameter_list|,
name|Path
name|containerLogDir
parameter_list|,
name|StringBuilder
name|diagnosticInfo
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Container launch failed : "
operator|+
name|diagnosticInfo
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|FileSystem
name|fileSystem
init|=
literal|null
decl_stmt|;
name|long
name|tailSizeInBytes
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|YarnConfiguration
operator|.
name|NM_CONTAINER_STDERR_BYTES
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_NM_CONTAINER_STDERR_BYTES
argument_list|)
decl_stmt|;
comment|// Append container prelaunch stderr to diagnostics
try|try
block|{
name|fileSystem
operator|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
operator|.
name|getRaw
argument_list|()
expr_stmt|;
name|FileStatus
name|preLaunchErrorFileStatus
init|=
name|fileSystem
operator|.
name|getFileStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|containerLogDir
argument_list|,
name|ContainerLaunch
operator|.
name|CONTAINER_PRE_LAUNCH_STDERR
argument_list|)
argument_list|)
decl_stmt|;
name|Path
name|errorFile
init|=
name|preLaunchErrorFileStatus
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|long
name|fileSize
init|=
name|preLaunchErrorFileStatus
operator|.
name|getLen
argument_list|()
decl_stmt|;
name|diagnosticInfo
operator|.
name|append
argument_list|(
literal|"Error file: "
argument_list|)
operator|.
name|append
argument_list|(
name|ContainerLaunch
operator|.
name|CONTAINER_PRE_LAUNCH_STDERR
argument_list|)
operator|.
name|append
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
empty_stmt|;
name|byte
index|[]
name|tailBuffer
init|=
name|tailFile
argument_list|(
name|errorFile
argument_list|,
name|fileSize
argument_list|,
name|tailSizeInBytes
argument_list|)
decl_stmt|;
name|diagnosticInfo
operator|.
name|append
argument_list|(
literal|"Last "
argument_list|)
operator|.
name|append
argument_list|(
name|tailSizeInBytes
argument_list|)
operator|.
name|append
argument_list|(
literal|" bytes of "
argument_list|)
operator|.
name|append
argument_list|(
name|errorFile
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" :\n"
argument_list|)
operator|.
name|append
argument_list|(
operator|new
name|String
argument_list|(
name|tailBuffer
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to get tail of the container's prelaunch error log file"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// Append container stderr to diagnostics
name|String
name|errorFileNamePattern
init|=
name|conf
operator|.
name|get
argument_list|(
name|YarnConfiguration
operator|.
name|NM_CONTAINER_STDERR_PATTERN
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_NM_CONTAINER_STDERR_PATTERN
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|fileSystem
operator|==
literal|null
condition|)
block|{
name|fileSystem
operator|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
operator|.
name|getRaw
argument_list|()
expr_stmt|;
block|}
name|FileStatus
index|[]
name|errorFileStatuses
init|=
name|fileSystem
operator|.
name|globStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|containerLogDir
argument_list|,
name|errorFileNamePattern
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|errorFileStatuses
operator|!=
literal|null
operator|&&
name|errorFileStatuses
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|Path
name|errorFile
init|=
name|errorFileStatuses
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|long
name|fileSize
init|=
name|errorFileStatuses
index|[
literal|0
index|]
operator|.
name|getLen
argument_list|()
decl_stmt|;
comment|// if more than one file matches the stderr pattern, take the latest
comment|// modified file, and also append the file names in the diagnosticInfo
if|if
condition|(
name|errorFileStatuses
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|String
index|[]
name|errorFileNames
init|=
operator|new
name|String
index|[
name|errorFileStatuses
operator|.
name|length
index|]
decl_stmt|;
name|long
name|latestModifiedTime
init|=
name|errorFileStatuses
index|[
literal|0
index|]
operator|.
name|getModificationTime
argument_list|()
decl_stmt|;
name|errorFileNames
index|[
literal|0
index|]
operator|=
name|errorFileStatuses
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|errorFileStatuses
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|errorFileNames
index|[
name|i
index|]
operator|=
name|errorFileStatuses
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
if|if
condition|(
name|errorFileStatuses
index|[
name|i
index|]
operator|.
name|getModificationTime
argument_list|()
operator|>
name|latestModifiedTime
condition|)
block|{
name|latestModifiedTime
operator|=
name|errorFileStatuses
index|[
name|i
index|]
operator|.
name|getModificationTime
argument_list|()
expr_stmt|;
name|errorFile
operator|=
name|errorFileStatuses
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
expr_stmt|;
name|fileSize
operator|=
name|errorFileStatuses
index|[
name|i
index|]
operator|.
name|getLen
argument_list|()
expr_stmt|;
block|}
block|}
name|diagnosticInfo
operator|.
name|append
argument_list|(
literal|"Error files: "
argument_list|)
operator|.
name|append
argument_list|(
name|StringUtils
operator|.
name|join
argument_list|(
literal|", "
argument_list|,
name|errorFileNames
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|tailBuffer
init|=
name|tailFile
argument_list|(
name|errorFile
argument_list|,
name|fileSize
argument_list|,
name|tailSizeInBytes
argument_list|)
decl_stmt|;
name|String
name|tailBufferMsg
init|=
operator|new
name|String
argument_list|(
name|tailBuffer
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
decl_stmt|;
name|diagnosticInfo
operator|.
name|append
argument_list|(
literal|"Last "
argument_list|)
operator|.
name|append
argument_list|(
name|tailSizeInBytes
argument_list|)
operator|.
name|append
argument_list|(
literal|" bytes of "
argument_list|)
operator|.
name|append
argument_list|(
name|errorFile
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" :\n"
argument_list|)
operator|.
name|append
argument_list|(
name|tailBufferMsg
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
operator|.
name|append
argument_list|(
name|analysesErrorMsgOfContainerExitWithFailure
argument_list|(
name|tailBufferMsg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to get tail of the container's error log file"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|dispatcher
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|ContainerExitEvent
argument_list|(
name|containerID
argument_list|,
name|ContainerEventType
operator|.
name|CONTAINER_EXITED_WITH_FAILURE
argument_list|,
name|ret
argument_list|,
name|diagnosticInfo
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|tailFile (Path filePath, long fileSize, long tailSizeInBytes)
specifier|private
name|byte
index|[]
name|tailFile
parameter_list|(
name|Path
name|filePath
parameter_list|,
name|long
name|fileSize
parameter_list|,
name|long
name|tailSizeInBytes
parameter_list|)
throws|throws
name|IOException
block|{
name|FSDataInputStream
name|errorFileIS
init|=
literal|null
decl_stmt|;
name|FileSystem
name|fileSystem
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
operator|.
name|getRaw
argument_list|()
decl_stmt|;
try|try
block|{
name|long
name|startPosition
init|=
operator|(
name|fileSize
operator|<
name|tailSizeInBytes
operator|)
condition|?
literal|0
else|:
name|fileSize
operator|-
name|tailSizeInBytes
decl_stmt|;
name|int
name|bufferSize
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|fileSize
operator|<
name|tailSizeInBytes
operator|)
condition|?
name|fileSize
else|:
name|tailSizeInBytes
argument_list|)
decl_stmt|;
name|byte
index|[]
name|tailBuffer
init|=
operator|new
name|byte
index|[
name|bufferSize
index|]
decl_stmt|;
name|errorFileIS
operator|=
name|fileSystem
operator|.
name|open
argument_list|(
name|filePath
argument_list|)
expr_stmt|;
name|errorFileIS
operator|.
name|readFully
argument_list|(
name|startPosition
argument_list|,
name|tailBuffer
argument_list|)
expr_stmt|;
return|return
name|tailBuffer
return|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|cleanupWithLogger
argument_list|(
name|LOG
argument_list|,
name|errorFileIS
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|analysesErrorMsgOfContainerExitWithFailure (String errorMsg)
specifier|private
name|String
name|analysesErrorMsgOfContainerExitWithFailure
parameter_list|(
name|String
name|errorMsg
parameter_list|)
block|{
name|StringBuilder
name|analysis
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|errorMsg
operator|.
name|indexOf
argument_list|(
literal|"Error: Could not find or load main class"
operator|+
literal|" org.apache.hadoop.mapreduce"
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|analysis
operator|.
name|append
argument_list|(
literal|"Please check whether your etc/hadoop/mapred-site.xml "
operator|+
literal|"contains the below configuration:\n"
argument_list|)
expr_stmt|;
name|analysis
operator|.
name|append
argument_list|(
literal|"<property>\n"
argument_list|)
operator|.
name|append
argument_list|(
literal|"<name>yarn.app.mapreduce.am.env</name>\n"
argument_list|)
operator|.
name|append
argument_list|(
literal|"<value>HADOOP_MAPRED_HOME=${full path of your hadoop "
operator|+
literal|"distribution directory}</value>\n"
argument_list|)
operator|.
name|append
argument_list|(
literal|"</property>\n<property>\n"
argument_list|)
operator|.
name|append
argument_list|(
literal|"<name>mapreduce.map.env</name>\n"
argument_list|)
operator|.
name|append
argument_list|(
literal|"<value>HADOOP_MAPRED_HOME=${full path of your hadoop "
operator|+
literal|"distribution directory}</value>\n"
argument_list|)
operator|.
name|append
argument_list|(
literal|"</property>\n<property>\n"
argument_list|)
operator|.
name|append
argument_list|(
literal|"<name>mapreduce.reduce.env</name>\n"
argument_list|)
operator|.
name|append
argument_list|(
literal|"<value>HADOOP_MAPRED_HOME=${full path of your hadoop "
operator|+
literal|"distribution directory}</value>\n"
argument_list|)
operator|.
name|append
argument_list|(
literal|"</property>\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|analysis
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|getPidFileSubpath (String appIdStr, String containerIdStr)
specifier|protected
name|String
name|getPidFileSubpath
parameter_list|(
name|String
name|appIdStr
parameter_list|,
name|String
name|containerIdStr
parameter_list|)
block|{
return|return
name|getContainerPrivateDir
argument_list|(
name|appIdStr
argument_list|,
name|containerIdStr
argument_list|)
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|String
operator|.
name|format
argument_list|(
name|ContainerLaunch
operator|.
name|PID_FILE_NAME_FMT
argument_list|,
name|containerIdStr
argument_list|)
return|;
block|}
comment|/**    * Cleanup the container.    * Cancels the launch if launch has not started yet or signals    * the executor to not execute the process if not already done so.    * Also, sends a SIGTERM followed by a SIGKILL to the process if    * the process id is available.    * @throws IOException    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// dispatcher not typed
DECL|method|cleanupContainer ()
specifier|public
name|void
name|cleanupContainer
parameter_list|()
throws|throws
name|IOException
block|{
name|ContainerId
name|containerId
init|=
name|container
operator|.
name|getContainerId
argument_list|()
decl_stmt|;
name|String
name|containerIdStr
init|=
name|containerId
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Cleaning up container "
operator|+
name|containerIdStr
argument_list|)
expr_stmt|;
try|try
block|{
name|context
operator|.
name|getNMStateStore
argument_list|()
operator|.
name|storeContainerKilled
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to mark container "
operator|+
name|containerId
operator|+
literal|" killed in store"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// launch flag will be set to true if process already launched
name|boolean
name|alreadyLaunched
init|=
operator|!
name|containerAlreadyLaunched
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|alreadyLaunched
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Container "
operator|+
name|containerIdStr
operator|+
literal|" not launched."
operator|+
literal|" No cleanup needed to be done"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Marking container "
operator|+
name|containerIdStr
operator|+
literal|" as inactive"
argument_list|)
expr_stmt|;
block|}
comment|// this should ensure that if the container process has not launched
comment|// by this time, it will never be launched
name|exec
operator|.
name|deactivateContainer
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Getting pid for container "
operator|+
name|containerIdStr
operator|+
literal|" to kill"
operator|+
literal|" from pid file "
operator|+
operator|(
name|pidFilePath
operator|!=
literal|null
condition|?
name|pidFilePath
operator|.
name|toString
argument_list|()
else|:
literal|"null"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|// however the container process may have already started
try|try
block|{
comment|// get process id from pid file if available
comment|// else if shell is still active, get it from the shell
name|String
name|processId
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|pidFilePath
operator|!=
literal|null
condition|)
block|{
name|processId
operator|=
name|getContainerPid
argument_list|(
name|pidFilePath
argument_list|)
expr_stmt|;
block|}
comment|// kill process
name|String
name|user
init|=
name|container
operator|.
name|getUser
argument_list|()
decl_stmt|;
if|if
condition|(
name|processId
operator|!=
literal|null
condition|)
block|{
name|signalProcess
argument_list|(
name|processId
argument_list|,
name|user
argument_list|,
name|containerIdStr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Normally this means that the process was notified about
comment|// deactivateContainer above and did not start.
comment|// Since we already set the state to RUNNING or REINITIALIZING
comment|// we have to send a killed event to continue.
if|if
condition|(
operator|!
name|completed
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Container clean up before pid file created "
operator|+
name|containerIdStr
argument_list|)
expr_stmt|;
name|dispatcher
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|ContainerExitEvent
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|ContainerEventType
operator|.
name|CONTAINER_KILLED_ON_REQUEST
argument_list|,
name|Shell
operator|.
name|WINDOWS
condition|?
name|ExitCode
operator|.
name|FORCE_KILLED
operator|.
name|getExitCode
argument_list|()
else|:
name|ExitCode
operator|.
name|TERMINATED
operator|.
name|getExitCode
argument_list|()
argument_list|,
literal|"Container terminated before pid file created."
argument_list|)
argument_list|)
expr_stmt|;
comment|// There is a possibility that the launch grabbed the file name before
comment|// the deactivateContainer above but it was slow enough to avoid
comment|// getContainerPid.
comment|// Increasing YarnConfiguration.NM_PROCESS_KILL_WAIT_MS
comment|// reduces the likelihood of this race condition and process leak.
block|}
comment|// The Docker container may not have fully started, reap the container.
if|if
condition|(
name|DockerLinuxContainerRuntime
operator|.
name|isDockerContainerRequested
argument_list|(
name|container
operator|.
name|getLaunchContext
argument_list|()
operator|.
name|getEnvironment
argument_list|()
argument_list|)
condition|)
block|{
name|reapDockerContainerNoPid
argument_list|(
name|user
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|String
name|message
init|=
literal|"Exception when trying to cleanup container "
operator|+
name|containerIdStr
operator|+
literal|": "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|dispatcher
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|ContainerDiagnosticsUpdateEvent
argument_list|(
name|containerId
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// cleanup pid file if present
if|if
condition|(
name|pidFilePath
operator|!=
literal|null
condition|)
block|{
name|FileContext
name|lfs
init|=
name|FileContext
operator|.
name|getLocalFSFileContext
argument_list|()
decl_stmt|;
name|lfs
operator|.
name|delete
argument_list|(
name|pidFilePath
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|lfs
operator|.
name|delete
argument_list|(
name|pidFilePath
operator|.
name|suffix
argument_list|(
name|EXIT_CODE_FILE_SUFFIX
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|int
name|sleepMsec
init|=
literal|100
decl_stmt|;
name|int
name|msecLeft
init|=
literal|2000
decl_stmt|;
if|if
condition|(
name|pidFilePath
operator|!=
literal|null
condition|)
block|{
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|getExitCodeFile
argument_list|(
name|pidFilePath
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
operator|&&
name|msecLeft
operator|>=
literal|0
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepMsec
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{         }
name|msecLeft
operator|-=
name|sleepMsec
expr_stmt|;
block|}
if|if
condition|(
name|msecLeft
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Timeout while waiting for the exit code file:  "
operator|+
name|file
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Reap the container
name|boolean
name|result
init|=
name|exec
operator|.
name|reapContainer
argument_list|(
operator|new
name|ContainerReapContext
operator|.
name|Builder
argument_list|()
operator|.
name|setContainer
argument_list|(
name|container
argument_list|)
operator|.
name|setUser
argument_list|(
name|container
operator|.
name|getUser
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Reap container failed for container "
operator|+
name|containerIdStr
argument_list|)
throw|;
block|}
block|}
comment|/**    * Send a signal to the container.    *    *    * @throws IOException    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// dispatcher not typed
DECL|method|signalContainer (SignalContainerCommand command)
specifier|public
name|void
name|signalContainer
parameter_list|(
name|SignalContainerCommand
name|command
parameter_list|)
throws|throws
name|IOException
block|{
name|ContainerId
name|containerId
init|=
name|container
operator|.
name|getContainerTokenIdentifier
argument_list|()
operator|.
name|getContainerID
argument_list|()
decl_stmt|;
name|String
name|containerIdStr
init|=
name|containerId
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|user
init|=
name|container
operator|.
name|getUser
argument_list|()
decl_stmt|;
name|Signal
name|signal
init|=
name|translateCommandToSignal
argument_list|(
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
name|signal
operator|.
name|equals
argument_list|(
name|Signal
operator|.
name|NULL
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"ignore signal command "
operator|+
name|command
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Sending signal "
operator|+
name|command
operator|+
literal|" to container "
operator|+
name|containerIdStr
argument_list|)
expr_stmt|;
name|boolean
name|alreadyLaunched
init|=
operator|!
name|containerAlreadyLaunched
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|alreadyLaunched
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Container "
operator|+
name|containerIdStr
operator|+
literal|" not launched."
operator|+
literal|" Not sending the signal"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Getting pid for container "
operator|+
name|containerIdStr
operator|+
literal|" to send signal to from pid file "
operator|+
operator|(
name|pidFilePath
operator|!=
literal|null
condition|?
name|pidFilePath
operator|.
name|toString
argument_list|()
else|:
literal|"null"
operator|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
comment|// get process id from pid file if available
comment|// else if shell is still active, get it from the shell
name|String
name|processId
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|pidFilePath
operator|!=
literal|null
condition|)
block|{
name|processId
operator|=
name|getContainerPid
argument_list|(
name|pidFilePath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|processId
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sending signal to pid "
operator|+
name|processId
operator|+
literal|" as user "
operator|+
name|user
operator|+
literal|" for container "
operator|+
name|containerIdStr
argument_list|)
expr_stmt|;
block|}
name|boolean
name|result
init|=
name|exec
operator|.
name|signalContainer
argument_list|(
operator|new
name|ContainerSignalContext
operator|.
name|Builder
argument_list|()
operator|.
name|setContainer
argument_list|(
name|container
argument_list|)
operator|.
name|setUser
argument_list|(
name|user
argument_list|)
operator|.
name|setPid
argument_list|(
name|processId
argument_list|)
operator|.
name|setSignal
argument_list|(
name|signal
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|diagnostics
init|=
literal|"Sent signal "
operator|+
name|command
operator|+
literal|" ("
operator|+
name|signal
operator|+
literal|") to pid "
operator|+
name|processId
operator|+
literal|" as user "
operator|+
name|user
operator|+
literal|" for container "
operator|+
name|containerIdStr
operator|+
literal|", result="
operator|+
operator|(
name|result
condition|?
literal|"success"
else|:
literal|"failed"
operator|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|diagnostics
argument_list|)
expr_stmt|;
name|dispatcher
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|ContainerDiagnosticsUpdateEvent
argument_list|(
name|containerId
argument_list|,
name|diagnostics
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|String
name|message
init|=
literal|"Exception when sending signal to container "
operator|+
name|containerIdStr
operator|+
literal|": "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|sendSignal (String user, String processId, Signal signal)
specifier|private
name|boolean
name|sendSignal
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|processId
parameter_list|,
name|Signal
name|signal
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|exec
operator|.
name|signalContainer
argument_list|(
operator|new
name|ContainerSignalContext
operator|.
name|Builder
argument_list|()
operator|.
name|setContainer
argument_list|(
name|container
argument_list|)
operator|.
name|setUser
argument_list|(
name|user
argument_list|)
operator|.
name|setPid
argument_list|(
name|processId
argument_list|)
operator|.
name|setSignal
argument_list|(
name|signal
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
DECL|method|signalProcess (String processId, String user, String containerIdStr)
specifier|private
name|void
name|signalProcess
parameter_list|(
name|String
name|processId
parameter_list|,
name|String
name|user
parameter_list|,
name|String
name|containerIdStr
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sending signal to pid "
operator|+
name|processId
operator|+
literal|" as user "
operator|+
name|user
operator|+
literal|" for container "
operator|+
name|containerIdStr
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Signal
name|signal
init|=
name|sleepDelayBeforeSigKill
operator|>
literal|0
condition|?
name|Signal
operator|.
name|TERM
else|:
name|Signal
operator|.
name|KILL
decl_stmt|;
name|boolean
name|result
init|=
name|sendSignal
argument_list|(
name|user
argument_list|,
name|processId
argument_list|,
name|signal
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sent signal "
operator|+
name|signal
operator|+
literal|" to pid "
operator|+
name|processId
operator|+
literal|" as user "
operator|+
name|user
operator|+
literal|" for container "
operator|+
name|containerIdStr
operator|+
literal|", result="
operator|+
operator|(
name|result
condition|?
literal|"success"
else|:
literal|"failed"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sleepDelayBeforeSigKill
operator|>
literal|0
condition|)
block|{
operator|new
name|DelayedProcessKiller
argument_list|(
name|container
argument_list|,
name|user
argument_list|,
name|processId
argument_list|,
name|sleepDelayBeforeSigKill
argument_list|,
name|Signal
operator|.
name|KILL
argument_list|,
name|exec
argument_list|)
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|reapDockerContainerNoPid (String user)
specifier|private
name|void
name|reapDockerContainerNoPid
parameter_list|(
name|String
name|user
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|containerIdStr
init|=
name|container
operator|.
name|getContainerTokenIdentifier
argument_list|()
operator|.
name|getContainerID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Unable to obtain pid, but docker container request detected. "
operator|+
literal|"Attempting to reap container "
operator|+
name|containerIdStr
argument_list|)
expr_stmt|;
name|boolean
name|result
init|=
name|exec
operator|.
name|reapContainer
argument_list|(
operator|new
name|ContainerReapContext
operator|.
name|Builder
argument_list|()
operator|.
name|setContainer
argument_list|(
name|container
argument_list|)
operator|.
name|setUser
argument_list|(
name|container
operator|.
name|getUser
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Sent signal to docker container "
operator|+
name|containerIdStr
operator|+
literal|" as user "
operator|+
name|user
operator|+
literal|", result="
operator|+
operator|(
name|result
condition|?
literal|"success"
else|:
literal|"failed"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|translateCommandToSignal ( SignalContainerCommand command)
specifier|public
specifier|static
name|Signal
name|translateCommandToSignal
parameter_list|(
name|SignalContainerCommand
name|command
parameter_list|)
block|{
name|Signal
name|signal
init|=
name|Signal
operator|.
name|NULL
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|OUTPUT_THREAD_DUMP
case|:
comment|// TODO for windows support.
name|signal
operator|=
name|Shell
operator|.
name|WINDOWS
condition|?
name|Signal
operator|.
name|NULL
else|:
name|Signal
operator|.
name|QUIT
expr_stmt|;
break|break;
case|case
name|GRACEFUL_SHUTDOWN
case|:
name|signal
operator|=
name|Signal
operator|.
name|TERM
expr_stmt|;
break|break;
case|case
name|FORCEFUL_SHUTDOWN
case|:
name|signal
operator|=
name|Signal
operator|.
name|KILL
expr_stmt|;
break|break;
block|}
return|return
name|signal
return|;
block|}
comment|/**    * Pause the container.    * Cancels the launch if the container isn't launched yet. Otherwise asks the    * executor to pause the container.    * @throws IOException in case of errors.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// dispatcher not typed
DECL|method|pauseContainer ()
specifier|public
name|void
name|pauseContainer
parameter_list|()
throws|throws
name|IOException
block|{
name|ContainerId
name|containerId
init|=
name|container
operator|.
name|getContainerId
argument_list|()
decl_stmt|;
name|String
name|containerIdStr
init|=
name|containerId
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Pausing the container "
operator|+
name|containerIdStr
argument_list|)
expr_stmt|;
comment|// The pause event is only handled if the container is in the running state
comment|// (the container state machine), so we don't check for
comment|// shouldLaunchContainer over here
if|if
condition|(
operator|!
name|shouldPauseContainer
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Container "
operator|+
name|containerId
operator|+
literal|" not paused as "
operator|+
literal|"resume already called"
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
comment|// Pause the container
name|exec
operator|.
name|pauseContainer
argument_list|(
name|container
argument_list|)
expr_stmt|;
comment|// PauseContainer is a blocking call. We are here almost means the
comment|// container is paused, so send out the event.
name|dispatcher
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|ContainerEvent
argument_list|(
name|containerId
argument_list|,
name|ContainerEventType
operator|.
name|CONTAINER_PAUSED
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|context
operator|.
name|getNMStateStore
argument_list|()
operator|.
name|storeContainerPaused
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not store container ["
operator|+
name|container
operator|.
name|getContainerId
argument_list|()
operator|+
literal|"] state. The Container has been paused."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|String
name|message
init|=
literal|"Exception when trying to pause container "
operator|+
name|containerIdStr
operator|+
literal|": "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|container
operator|.
name|handle
argument_list|(
operator|new
name|ContainerKillEvent
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|ContainerExitStatus
operator|.
name|PREEMPTED
argument_list|,
literal|"Container preempted as there was "
operator|+
literal|" an exception in pausing it."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Resume the container.    * Cancels the launch if the container isn't launched yet. Otherwise asks the    * executor to pause the container.    * @throws IOException in case of error.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// dispatcher not typed
DECL|method|resumeContainer ()
specifier|public
name|void
name|resumeContainer
parameter_list|()
throws|throws
name|IOException
block|{
name|ContainerId
name|containerId
init|=
name|container
operator|.
name|getContainerId
argument_list|()
decl_stmt|;
name|String
name|containerIdStr
init|=
name|containerId
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Resuming the container "
operator|+
name|containerIdStr
argument_list|)
expr_stmt|;
comment|// The resume event is only handled if the container is in a paused state
comment|// so we don't check for the launched flag here.
comment|// paused flag will be set to true if process already paused
name|boolean
name|alreadyPaused
init|=
operator|!
name|shouldPauseContainer
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|alreadyPaused
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Container "
operator|+
name|containerIdStr
operator|+
literal|" not paused."
operator|+
literal|" No resume necessary"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// If the container has already started
try|try
block|{
name|exec
operator|.
name|resumeContainer
argument_list|(
name|container
argument_list|)
expr_stmt|;
comment|// ResumeContainer is a blocking call. We are here almost means the
comment|// container is resumed, so send out the event.
name|dispatcher
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|ContainerEvent
argument_list|(
name|containerId
argument_list|,
name|ContainerEventType
operator|.
name|CONTAINER_RESUMED
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|this
operator|.
name|context
operator|.
name|getNMStateStore
argument_list|()
operator|.
name|removeContainerPaused
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not store container ["
operator|+
name|container
operator|.
name|getContainerId
argument_list|()
operator|+
literal|"] state. The Container has been resumed."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|String
name|message
init|=
literal|"Exception when trying to resume container "
operator|+
name|containerIdStr
operator|+
literal|": "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|container
operator|.
name|handle
argument_list|(
operator|new
name|ContainerKillEvent
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|ContainerExitStatus
operator|.
name|PREEMPTED
argument_list|,
literal|"Container preempted as there was "
operator|+
literal|" an exception in pausing it."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Loop through for a time-bounded interval waiting to    * read the process id from a file generated by a running process.    * @param pidFilePath File from which to read the process id    * @return Process ID    * @throws Exception    */
DECL|method|getContainerPid (Path pidFilePath)
specifier|private
name|String
name|getContainerPid
parameter_list|(
name|Path
name|pidFilePath
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|containerIdStr
init|=
name|container
operator|.
name|getContainerId
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|processId
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Accessing pid for container "
operator|+
name|containerIdStr
operator|+
literal|" from pid file "
operator|+
name|pidFilePath
argument_list|)
expr_stmt|;
block|}
name|int
name|sleepCounter
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|sleepInterval
init|=
literal|100
decl_stmt|;
comment|// loop waiting for pid file to show up
comment|// until our timer expires in which case we admit defeat
while|while
condition|(
literal|true
condition|)
block|{
name|processId
operator|=
name|ProcessIdFileReader
operator|.
name|getProcessId
argument_list|(
name|pidFilePath
argument_list|)
expr_stmt|;
if|if
condition|(
name|processId
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got pid "
operator|+
name|processId
operator|+
literal|" for container "
operator|+
name|containerIdStr
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|sleepCounter
operator|*
name|sleepInterval
operator|)
operator|>
name|maxKillWaitTime
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Could not get pid for "
operator|+
name|containerIdStr
operator|+
literal|". Waited for "
operator|+
name|maxKillWaitTime
operator|+
literal|" ms."
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
operator|++
name|sleepCounter
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepInterval
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|processId
return|;
block|}
DECL|method|getRelativeContainerLogDir (String appIdStr, String containerIdStr)
specifier|public
specifier|static
name|String
name|getRelativeContainerLogDir
parameter_list|(
name|String
name|appIdStr
parameter_list|,
name|String
name|containerIdStr
parameter_list|)
block|{
return|return
name|appIdStr
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|containerIdStr
return|;
block|}
DECL|method|getContainerPrivateDir (String appIdStr, String containerIdStr)
specifier|protected
name|String
name|getContainerPrivateDir
parameter_list|(
name|String
name|appIdStr
parameter_list|,
name|String
name|containerIdStr
parameter_list|)
block|{
return|return
name|getAppPrivateDir
argument_list|(
name|appIdStr
argument_list|)
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|containerIdStr
operator|+
name|Path
operator|.
name|SEPARATOR
return|;
block|}
DECL|method|getAppPrivateDir (String appIdStr)
specifier|private
name|String
name|getAppPrivateDir
parameter_list|(
name|String
name|appIdStr
parameter_list|)
block|{
return|return
name|ResourceLocalizationService
operator|.
name|NM_PRIVATE_DIR
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|appIdStr
return|;
block|}
DECL|method|getContext ()
name|Context
name|getContext
parameter_list|()
block|{
return|return
name|context
return|;
block|}
DECL|class|ShellScriptBuilder
specifier|public
specifier|static
specifier|abstract
class|class
name|ShellScriptBuilder
block|{
DECL|method|create ()
specifier|public
specifier|static
name|ShellScriptBuilder
name|create
parameter_list|()
block|{
return|return
name|Shell
operator|.
name|WINDOWS
condition|?
operator|new
name|WindowsShellScriptBuilder
argument_list|()
else|:
operator|new
name|UnixShellScriptBuilder
argument_list|()
return|;
block|}
DECL|field|LINE_SEPARATOR
specifier|private
specifier|static
specifier|final
name|String
name|LINE_SEPARATOR
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
decl_stmt|;
DECL|field|sb
specifier|private
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
DECL|method|command (List<String> command)
specifier|public
specifier|abstract
name|void
name|command
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|command
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|field|ENV_PRELAUNCH_STDOUT
specifier|protected
specifier|static
specifier|final
name|String
name|ENV_PRELAUNCH_STDOUT
init|=
literal|"PRELAUNCH_OUT"
decl_stmt|;
DECL|field|ENV_PRELAUNCH_STDERR
specifier|protected
specifier|static
specifier|final
name|String
name|ENV_PRELAUNCH_STDERR
init|=
literal|"PRELAUNCH_ERR"
decl_stmt|;
DECL|field|redirectStdOut
specifier|private
name|boolean
name|redirectStdOut
init|=
literal|false
decl_stmt|;
DECL|field|redirectStdErr
specifier|private
name|boolean
name|redirectStdErr
init|=
literal|false
decl_stmt|;
comment|/**      * Set stdout for the shell script      * @param stdoutDir stdout must be an absolute path      * @param stdOutFile stdout file name      * @throws IOException thrown when stdout path is not absolute      */
DECL|method|stdout (Path stdoutDir, String stdOutFile)
specifier|public
specifier|final
name|void
name|stdout
parameter_list|(
name|Path
name|stdoutDir
parameter_list|,
name|String
name|stdOutFile
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|stdoutDir
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stdout path must be absolute"
argument_list|)
throw|;
block|}
name|redirectStdOut
operator|=
literal|true
expr_stmt|;
name|setStdOut
argument_list|(
operator|new
name|Path
argument_list|(
name|stdoutDir
argument_list|,
name|stdOutFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Set stderr for the shell script      * @param stderrDir stderr must be an absolute path      * @param stdErrFile stderr file name      * @throws IOException thrown when stderr path is not absolute      */
DECL|method|stderr (Path stderrDir, String stdErrFile)
specifier|public
specifier|final
name|void
name|stderr
parameter_list|(
name|Path
name|stderrDir
parameter_list|,
name|String
name|stdErrFile
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|stderrDir
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stdout path must be absolute"
argument_list|)
throw|;
block|}
name|redirectStdErr
operator|=
literal|true
expr_stmt|;
name|setStdErr
argument_list|(
operator|new
name|Path
argument_list|(
name|stderrDir
argument_list|,
name|stdErrFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|setStdOut (Path stdout)
specifier|protected
specifier|abstract
name|void
name|setStdOut
parameter_list|(
name|Path
name|stdout
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|setStdErr (Path stdout)
specifier|protected
specifier|abstract
name|void
name|setStdErr
parameter_list|(
name|Path
name|stdout
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|env (String key, String value)
specifier|public
specifier|abstract
name|void
name|env
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|value
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|echo (String echoStr)
specifier|public
specifier|abstract
name|void
name|echo
parameter_list|(
name|String
name|echoStr
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|symlink (Path src, Path dst)
specifier|public
specifier|final
name|void
name|symlink
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|src
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Source must be absolute"
argument_list|)
throw|;
block|}
if|if
condition|(
name|dst
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Destination must be relative"
argument_list|)
throw|;
block|}
if|if
condition|(
name|dst
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
operator|.
name|indexOf
argument_list|(
literal|'/'
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|mkdir
argument_list|(
name|dst
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|link
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
comment|/**      * Method to copy files that are useful for debugging container failures.      * This method will be called by ContainerExecutor when setting up the      * container launch script. The method should take care to make sure files      * are read-able by the yarn user if the files are to undergo      * log-aggregation.      * @param src path to the source file      * @param dst path to the destination file - should be absolute      * @throws IOException      */
DECL|method|copyDebugInformation (Path src, Path dst)
specifier|public
specifier|abstract
name|void
name|copyDebugInformation
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Method to dump debug information to a target file. This method will      * be called by ContainerExecutor when setting up the container launch      * script.      * @param output the file to which debug information is to be written      * @throws IOException      */
DECL|method|listDebugInformation (Path output)
specifier|public
specifier|abstract
name|void
name|listDebugInformation
parameter_list|(
name|Path
name|output
parameter_list|)
throws|throws
name|IOException
function_decl|;
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|write (PrintStream out)
specifier|public
specifier|final
name|void
name|write
parameter_list|(
name|PrintStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|append
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
DECL|method|buildCommand (String... command)
specifier|protected
specifier|final
name|void
name|buildCommand
parameter_list|(
name|String
modifier|...
name|command
parameter_list|)
block|{
for|for
control|(
name|String
name|s
range|:
name|command
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|linebreak (String... command)
specifier|protected
specifier|final
name|void
name|linebreak
parameter_list|(
name|String
modifier|...
name|command
parameter_list|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|LINE_SEPARATOR
argument_list|)
expr_stmt|;
block|}
DECL|method|line (String... command)
specifier|protected
specifier|final
name|void
name|line
parameter_list|(
name|String
modifier|...
name|command
parameter_list|)
block|{
name|buildCommand
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|linebreak
argument_list|()
expr_stmt|;
block|}
DECL|method|setExitOnFailure ()
specifier|public
name|void
name|setExitOnFailure
parameter_list|()
block|{
comment|// Dummy implementation
block|}
DECL|method|link (Path src, Path dst)
specifier|protected
specifier|abstract
name|void
name|link
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|mkdir (Path path)
specifier|protected
specifier|abstract
name|void
name|mkdir
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|doRedirectStdOut ()
name|boolean
name|doRedirectStdOut
parameter_list|()
block|{
return|return
name|redirectStdOut
return|;
block|}
DECL|method|doRedirectStdErr ()
name|boolean
name|doRedirectStdErr
parameter_list|()
block|{
return|return
name|redirectStdErr
return|;
block|}
block|}
DECL|class|UnixShellScriptBuilder
specifier|private
specifier|static
specifier|final
class|class
name|UnixShellScriptBuilder
extends|extends
name|ShellScriptBuilder
block|{
DECL|method|errorCheck ()
specifier|private
name|void
name|errorCheck
parameter_list|()
block|{
name|line
argument_list|(
literal|"hadoop_shell_errorcode=$?"
argument_list|)
expr_stmt|;
name|line
argument_list|(
literal|"if [[ \"$hadoop_shell_errorcode\" -ne 0 ]]"
argument_list|)
expr_stmt|;
name|line
argument_list|(
literal|"then"
argument_list|)
expr_stmt|;
name|line
argument_list|(
literal|"  exit $hadoop_shell_errorcode"
argument_list|)
expr_stmt|;
name|line
argument_list|(
literal|"fi"
argument_list|)
expr_stmt|;
block|}
DECL|method|UnixShellScriptBuilder ()
specifier|public
name|UnixShellScriptBuilder
parameter_list|()
block|{
name|line
argument_list|(
literal|"#!/bin/bash"
argument_list|)
expr_stmt|;
name|line
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|command (List<String> command)
specifier|public
name|void
name|command
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|command
parameter_list|)
block|{
name|line
argument_list|(
literal|"exec /bin/bash -c \""
argument_list|,
name|StringUtils
operator|.
name|join
argument_list|(
literal|" "
argument_list|,
name|command
argument_list|)
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setStdOut (final Path stdout)
specifier|public
name|void
name|setStdOut
parameter_list|(
specifier|final
name|Path
name|stdout
parameter_list|)
throws|throws
name|IOException
block|{
name|line
argument_list|(
literal|"export "
argument_list|,
name|ENV_PRELAUNCH_STDOUT
argument_list|,
literal|"=\""
argument_list|,
name|stdout
operator|.
name|toString
argument_list|()
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
comment|// tee is needed for DefaultContainerExecutor error propagation to stdout
comment|// Close stdout of subprocess to prevent it from writing to the stdout file
name|line
argument_list|(
literal|"exec>\"${"
operator|+
name|ENV_PRELAUNCH_STDOUT
operator|+
literal|"}\""
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setStdErr (final Path stderr)
specifier|public
name|void
name|setStdErr
parameter_list|(
specifier|final
name|Path
name|stderr
parameter_list|)
throws|throws
name|IOException
block|{
name|line
argument_list|(
literal|"export "
argument_list|,
name|ENV_PRELAUNCH_STDERR
argument_list|,
literal|"=\""
argument_list|,
name|stderr
operator|.
name|toString
argument_list|()
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
comment|// tee is needed for DefaultContainerExecutor error propagation to stderr
comment|// Close stdout of subprocess to prevent it from writing to the stdout file
name|line
argument_list|(
literal|"exec 2>\"${"
operator|+
name|ENV_PRELAUNCH_STDERR
operator|+
literal|"}\""
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|env (String key, String value)
specifier|public
name|void
name|env
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|line
argument_list|(
literal|"export "
argument_list|,
name|key
argument_list|,
literal|"=\""
argument_list|,
name|value
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|echo (final String echoStr)
specifier|public
name|void
name|echo
parameter_list|(
specifier|final
name|String
name|echoStr
parameter_list|)
throws|throws
name|IOException
block|{
name|line
argument_list|(
literal|"echo \""
operator|+
name|echoStr
operator|+
literal|"\""
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|link (Path src, Path dst)
specifier|protected
name|void
name|link
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
name|line
argument_list|(
literal|"ln -sf \""
argument_list|,
name|src
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
literal|"\" \""
argument_list|,
name|dst
operator|.
name|toString
argument_list|()
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|mkdir (Path path)
specifier|protected
name|void
name|mkdir
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|line
argument_list|(
literal|"mkdir -p "
argument_list|,
name|path
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|copyDebugInformation (Path src, Path dest)
specifier|public
name|void
name|copyDebugInformation
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dest
parameter_list|)
throws|throws
name|IOException
block|{
name|line
argument_list|(
literal|"# Creating copy of launch script"
argument_list|)
expr_stmt|;
name|line
argument_list|(
literal|"cp \""
argument_list|,
name|src
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
literal|"\" \""
argument_list|,
name|dest
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
comment|// set permissions to 640 because we need to be able to run
comment|// log aggregation in secure mode as well
if|if
condition|(
name|dest
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
name|line
argument_list|(
literal|"chmod 640 \""
argument_list|,
name|dest
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|listDebugInformation (Path output)
specifier|public
name|void
name|listDebugInformation
parameter_list|(
name|Path
name|output
parameter_list|)
throws|throws
name|IOException
block|{
name|line
argument_list|(
literal|"# Determining directory contents"
argument_list|)
expr_stmt|;
name|line
argument_list|(
literal|"echo \"ls -l:\" 1>\""
argument_list|,
name|output
operator|.
name|toString
argument_list|()
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|line
argument_list|(
literal|"ls -l 1>>\""
argument_list|,
name|output
operator|.
name|toString
argument_list|()
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
comment|// don't run error check because if there are loops
comment|// find will exit with an error causing container launch to fail
comment|// find will follow symlinks outside the work dir if such sylimks exist
comment|// (like public/app local resources)
name|line
argument_list|(
literal|"echo \"find -L . -maxdepth 5 -ls:\" 1>>\""
argument_list|,
name|output
operator|.
name|toString
argument_list|()
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|line
argument_list|(
literal|"find -L . -maxdepth 5 -ls 1>>\""
argument_list|,
name|output
operator|.
name|toString
argument_list|()
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|line
argument_list|(
literal|"echo \"broken symlinks(find -L . -maxdepth 5 -type l -ls):\" 1>>\""
argument_list|,
name|output
operator|.
name|toString
argument_list|()
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|line
argument_list|(
literal|"find -L . -maxdepth 5 -type l -ls 1>>\""
argument_list|,
name|output
operator|.
name|toString
argument_list|()
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setExitOnFailure ()
specifier|public
name|void
name|setExitOnFailure
parameter_list|()
block|{
name|line
argument_list|(
literal|"set -o pipefail -e"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|WindowsShellScriptBuilder
specifier|private
specifier|static
specifier|final
class|class
name|WindowsShellScriptBuilder
extends|extends
name|ShellScriptBuilder
block|{
DECL|method|errorCheck ()
specifier|private
name|void
name|errorCheck
parameter_list|()
block|{
name|line
argument_list|(
literal|"@if %errorlevel% neq 0 exit /b %errorlevel%"
argument_list|)
expr_stmt|;
block|}
DECL|method|lineWithLenCheck (String... commands)
specifier|private
name|void
name|lineWithLenCheck
parameter_list|(
name|String
modifier|...
name|commands
parameter_list|)
throws|throws
name|IOException
block|{
name|Shell
operator|.
name|checkWindowsCommandLineLength
argument_list|(
name|commands
argument_list|)
expr_stmt|;
name|line
argument_list|(
name|commands
argument_list|)
expr_stmt|;
block|}
DECL|method|WindowsShellScriptBuilder ()
specifier|public
name|WindowsShellScriptBuilder
parameter_list|()
block|{
name|line
argument_list|(
literal|"@setlocal"
argument_list|)
expr_stmt|;
name|line
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|command (List<String> command)
specifier|public
name|void
name|command
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|command
parameter_list|)
throws|throws
name|IOException
block|{
name|lineWithLenCheck
argument_list|(
literal|"@call "
argument_list|,
name|StringUtils
operator|.
name|join
argument_list|(
literal|" "
argument_list|,
name|command
argument_list|)
argument_list|)
expr_stmt|;
name|errorCheck
argument_list|()
expr_stmt|;
block|}
comment|//Dummy implementation
annotation|@
name|Override
DECL|method|setStdOut (final Path stdout)
specifier|protected
name|void
name|setStdOut
parameter_list|(
specifier|final
name|Path
name|stdout
parameter_list|)
throws|throws
name|IOException
block|{     }
comment|//Dummy implementation
annotation|@
name|Override
DECL|method|setStdErr (final Path stderr)
specifier|protected
name|void
name|setStdErr
parameter_list|(
specifier|final
name|Path
name|stderr
parameter_list|)
throws|throws
name|IOException
block|{     }
annotation|@
name|Override
DECL|method|env (String key, String value)
specifier|public
name|void
name|env
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|lineWithLenCheck
argument_list|(
literal|"@set "
argument_list|,
name|key
argument_list|,
literal|"="
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|errorCheck
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|echo (final String echoStr)
specifier|public
name|void
name|echo
parameter_list|(
specifier|final
name|String
name|echoStr
parameter_list|)
throws|throws
name|IOException
block|{
name|lineWithLenCheck
argument_list|(
literal|"@echo \""
argument_list|,
name|echoStr
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|link (Path src, Path dst)
specifier|protected
name|void
name|link
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|srcFile
init|=
operator|new
name|File
argument_list|(
name|src
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|srcFileStr
init|=
name|srcFile
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|String
name|dstFileStr
init|=
operator|new
name|File
argument_list|(
name|dst
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|lineWithLenCheck
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"@%s symlink \"%s\" \"%s\""
argument_list|,
name|Shell
operator|.
name|getWinUtilsPath
argument_list|()
argument_list|,
name|dstFileStr
argument_list|,
name|srcFileStr
argument_list|)
argument_list|)
expr_stmt|;
name|errorCheck
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|mkdir (Path path)
specifier|protected
name|void
name|mkdir
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|lineWithLenCheck
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"@if not exist \"%s\" mkdir \"%s\""
argument_list|,
name|path
operator|.
name|toString
argument_list|()
argument_list|,
name|path
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|errorCheck
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|copyDebugInformation (Path src, Path dest)
specifier|public
name|void
name|copyDebugInformation
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dest
parameter_list|)
throws|throws
name|IOException
block|{
comment|// no need to worry about permissions - in secure mode
comment|// WindowsSecureContainerExecutor will set permissions
comment|// to allow NM to read the file
name|line
argument_list|(
literal|"rem Creating copy of launch script"
argument_list|)
expr_stmt|;
name|lineWithLenCheck
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"copy \"%s\" \"%s\""
argument_list|,
name|src
operator|.
name|toString
argument_list|()
argument_list|,
name|dest
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|listDebugInformation (Path output)
specifier|public
name|void
name|listDebugInformation
parameter_list|(
name|Path
name|output
parameter_list|)
throws|throws
name|IOException
block|{
name|line
argument_list|(
literal|"rem Determining directory contents"
argument_list|)
expr_stmt|;
name|lineWithLenCheck
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"@echo \"dir:\"> \"%s\""
argument_list|,
name|output
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|lineWithLenCheck
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"dir>> \"%s\""
argument_list|,
name|output
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|putEnvIfNotNull ( Map<String, String> environment, String variable, String value)
specifier|private
specifier|static
name|void
name|putEnvIfNotNull
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|environment
parameter_list|,
name|String
name|variable
parameter_list|,
name|String
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
name|environment
operator|.
name|put
argument_list|(
name|variable
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|putEnvIfAbsent ( Map<String, String> environment, String variable)
specifier|private
specifier|static
name|void
name|putEnvIfAbsent
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|environment
parameter_list|,
name|String
name|variable
parameter_list|)
block|{
if|if
condition|(
name|environment
operator|.
name|get
argument_list|(
name|variable
argument_list|)
operator|==
literal|null
condition|)
block|{
name|putEnvIfNotNull
argument_list|(
name|environment
argument_list|,
name|variable
argument_list|,
name|System
operator|.
name|getenv
argument_list|(
name|variable
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|sanitizeEnv (Map<String, String> environment, Path pwd, List<Path> appDirs, List<String> userLocalDirs, List<String> containerLogDirs, Map<Path, List<String>> resources, Path nmPrivateClasspathJarDir)
specifier|public
name|void
name|sanitizeEnv
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|environment
parameter_list|,
name|Path
name|pwd
parameter_list|,
name|List
argument_list|<
name|Path
argument_list|>
name|appDirs
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|userLocalDirs
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|containerLogDirs
parameter_list|,
name|Map
argument_list|<
name|Path
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|resources
parameter_list|,
name|Path
name|nmPrivateClasspathJarDir
parameter_list|)
throws|throws
name|IOException
block|{
comment|/**      * Non-modifiable environment variables      */
name|environment
operator|.
name|put
argument_list|(
name|Environment
operator|.
name|CONTAINER_ID
operator|.
name|name
argument_list|()
argument_list|,
name|container
operator|.
name|getContainerId
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|environment
operator|.
name|put
argument_list|(
name|Environment
operator|.
name|NM_PORT
operator|.
name|name
argument_list|()
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|this
operator|.
name|context
operator|.
name|getNodeId
argument_list|()
operator|.
name|getPort
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|environment
operator|.
name|put
argument_list|(
name|Environment
operator|.
name|NM_HOST
operator|.
name|name
argument_list|()
argument_list|,
name|this
operator|.
name|context
operator|.
name|getNodeId
argument_list|()
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
name|environment
operator|.
name|put
argument_list|(
name|Environment
operator|.
name|NM_HTTP_PORT
operator|.
name|name
argument_list|()
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|this
operator|.
name|context
operator|.
name|getHttpPort
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|environment
operator|.
name|put
argument_list|(
name|Environment
operator|.
name|LOCAL_DIRS
operator|.
name|name
argument_list|()
argument_list|,
name|StringUtils
operator|.
name|join
argument_list|(
literal|","
argument_list|,
name|appDirs
argument_list|)
argument_list|)
expr_stmt|;
name|environment
operator|.
name|put
argument_list|(
name|Environment
operator|.
name|LOCAL_USER_DIRS
operator|.
name|name
argument_list|()
argument_list|,
name|StringUtils
operator|.
name|join
argument_list|(
literal|","
argument_list|,
name|userLocalDirs
argument_list|)
argument_list|)
expr_stmt|;
name|environment
operator|.
name|put
argument_list|(
name|Environment
operator|.
name|LOG_DIRS
operator|.
name|name
argument_list|()
argument_list|,
name|StringUtils
operator|.
name|join
argument_list|(
literal|","
argument_list|,
name|containerLogDirs
argument_list|)
argument_list|)
expr_stmt|;
name|environment
operator|.
name|put
argument_list|(
name|Environment
operator|.
name|USER
operator|.
name|name
argument_list|()
argument_list|,
name|container
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
name|environment
operator|.
name|put
argument_list|(
name|Environment
operator|.
name|LOGNAME
operator|.
name|name
argument_list|()
argument_list|,
name|container
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
name|environment
operator|.
name|put
argument_list|(
name|Environment
operator|.
name|HOME
operator|.
name|name
argument_list|()
argument_list|,
name|conf
operator|.
name|get
argument_list|(
name|YarnConfiguration
operator|.
name|NM_USER_HOME_DIR
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_NM_USER_HOME_DIR
argument_list|)
argument_list|)
expr_stmt|;
name|environment
operator|.
name|put
argument_list|(
name|Environment
operator|.
name|PWD
operator|.
name|name
argument_list|()
argument_list|,
name|pwd
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|putEnvIfAbsent
argument_list|(
name|environment
argument_list|,
name|Environment
operator|.
name|HADOOP_CONF_DIR
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Shell
operator|.
name|WINDOWS
condition|)
block|{
name|environment
operator|.
name|put
argument_list|(
literal|"JVM_PID"
argument_list|,
literal|"$$"
argument_list|)
expr_stmt|;
block|}
comment|// variables here will be forced in, even if the container has specified them.
name|Apps
operator|.
name|setEnvFromInputString
argument_list|(
name|environment
argument_list|,
name|conf
operator|.
name|get
argument_list|(
name|YarnConfiguration
operator|.
name|NM_ADMIN_USER_ENV
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_NM_ADMIN_USER_ENV
argument_list|)
argument_list|,
name|File
operator|.
name|pathSeparator
argument_list|)
expr_stmt|;
comment|// TODO: Remove Windows check and use this approach on all platforms after
comment|// additional testing.  See YARN-358.
if|if
condition|(
name|Shell
operator|.
name|WINDOWS
condition|)
block|{
name|sanitizeWindowsEnv
argument_list|(
name|environment
argument_list|,
name|pwd
argument_list|,
name|resources
argument_list|,
name|nmPrivateClasspathJarDir
argument_list|)
expr_stmt|;
block|}
comment|// put AuxiliaryService data to environment
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|ByteBuffer
argument_list|>
name|meta
range|:
name|containerManager
operator|.
name|getAuxServiceMetaData
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|AuxiliaryServiceHelper
operator|.
name|setServiceDataIntoEnv
argument_list|(
name|meta
operator|.
name|getKey
argument_list|()
argument_list|,
name|meta
operator|.
name|getValue
argument_list|()
argument_list|,
name|environment
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|sanitizeWindowsEnv (Map<String, String> environment, Path pwd, Map<Path, List<String>> resources, Path nmPrivateClasspathJarDir)
specifier|private
name|void
name|sanitizeWindowsEnv
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|environment
parameter_list|,
name|Path
name|pwd
parameter_list|,
name|Map
argument_list|<
name|Path
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|resources
parameter_list|,
name|Path
name|nmPrivateClasspathJarDir
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|inputClassPath
init|=
name|environment
operator|.
name|get
argument_list|(
name|Environment
operator|.
name|CLASSPATH
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|inputClassPath
operator|!=
literal|null
operator|&&
operator|!
name|inputClassPath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//On non-windows, localized resources
comment|//from distcache are available via the classpath as they were placed
comment|//there but on windows they are not available when the classpath
comment|//jar is created and so they "are lost" and have to be explicitly
comment|//added to the classpath instead.  This also means that their position
comment|//is lost relative to other non-distcache classpath entries which will
comment|//break things like mapreduce.job.user.classpath.first.  An environment
comment|//variable can be set to indicate that distcache entries should come
comment|//first
name|boolean
name|preferLocalizedJars
init|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|environment
operator|.
name|get
argument_list|(
name|Environment
operator|.
name|CLASSPATH_PREPEND_DISTCACHE
operator|.
name|name
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|boolean
name|needsSeparator
init|=
literal|false
decl_stmt|;
name|StringBuilder
name|newClassPath
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|preferLocalizedJars
condition|)
block|{
name|newClassPath
operator|.
name|append
argument_list|(
name|inputClassPath
argument_list|)
expr_stmt|;
name|needsSeparator
operator|=
literal|true
expr_stmt|;
block|}
comment|// Localized resources do not exist at the desired paths yet, because the
comment|// container launch script has not run to create symlinks yet.  This
comment|// means that FileUtil.createJarWithClassPath can't automatically expand
comment|// wildcards to separate classpath entries for each file in the manifest.
comment|// To resolve this, append classpath entries explicitly for each
comment|// resource.
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Path
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|resources
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|boolean
name|targetIsDirectory
init|=
operator|new
name|File
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
operator|.
name|isDirectory
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|linkName
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
comment|// Append resource.
if|if
condition|(
name|needsSeparator
condition|)
block|{
name|newClassPath
operator|.
name|append
argument_list|(
name|File
operator|.
name|pathSeparator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|needsSeparator
operator|=
literal|true
expr_stmt|;
block|}
name|newClassPath
operator|.
name|append
argument_list|(
name|pwd
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
operator|.
name|append
argument_list|(
name|linkName
argument_list|)
expr_stmt|;
comment|// FileUtil.createJarWithClassPath must use File.toURI to convert
comment|// each file to a URI to write into the manifest's classpath.  For
comment|// directories, the classpath must have a trailing '/', but
comment|// File.toURI only appends the trailing '/' if it is a directory that
comment|// already exists.  To resolve this, add the classpath entries with
comment|// explicit trailing '/' here for any localized resource that targets
comment|// a directory.  Then, FileUtil.createJarWithClassPath will guarantee
comment|// that the resulting entry in the manifest's classpath will have a
comment|// trailing '/', and thus refer to a directory instead of a file.
if|if
condition|(
name|targetIsDirectory
condition|)
block|{
name|newClassPath
operator|.
name|append
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|preferLocalizedJars
condition|)
block|{
if|if
condition|(
name|needsSeparator
condition|)
block|{
name|newClassPath
operator|.
name|append
argument_list|(
name|File
operator|.
name|pathSeparator
argument_list|)
expr_stmt|;
block|}
name|newClassPath
operator|.
name|append
argument_list|(
name|inputClassPath
argument_list|)
expr_stmt|;
block|}
comment|// When the container launches, it takes the parent process's environment
comment|// and then adds/overwrites with the entries from the container launch
comment|// context.  Do the same thing here for correct substitution of
comment|// environment variables in the classpath jar manifest.
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mergedEnv
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|System
operator|.
name|getenv
argument_list|()
argument_list|)
decl_stmt|;
name|mergedEnv
operator|.
name|putAll
argument_list|(
name|environment
argument_list|)
expr_stmt|;
comment|// this is hacky and temporary - it's to preserve the windows secure
comment|// behavior but enable non-secure windows to properly build the class
comment|// path for access to job.jar/lib/xyz and friends (see YARN-2803)
name|Path
name|jarDir
decl_stmt|;
if|if
condition|(
name|exec
operator|instanceof
name|WindowsSecureContainerExecutor
condition|)
block|{
name|jarDir
operator|=
name|nmPrivateClasspathJarDir
expr_stmt|;
block|}
else|else
block|{
name|jarDir
operator|=
name|pwd
expr_stmt|;
block|}
name|String
index|[]
name|jarCp
init|=
name|FileUtil
operator|.
name|createJarWithClassPath
argument_list|(
name|newClassPath
operator|.
name|toString
argument_list|()
argument_list|,
name|jarDir
argument_list|,
name|pwd
argument_list|,
name|mergedEnv
argument_list|)
decl_stmt|;
comment|// In a secure cluster the classpath jar must be localized to grant access
name|Path
name|localizedClassPathJar
init|=
name|exec
operator|.
name|localizeClasspathJar
argument_list|(
operator|new
name|Path
argument_list|(
name|jarCp
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|pwd
argument_list|,
name|container
operator|.
name|getUser
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|replacementClassPath
init|=
name|localizedClassPathJar
operator|.
name|toString
argument_list|()
operator|+
name|jarCp
index|[
literal|1
index|]
decl_stmt|;
name|environment
operator|.
name|put
argument_list|(
name|Environment
operator|.
name|CLASSPATH
operator|.
name|name
argument_list|()
argument_list|,
name|replacementClassPath
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getExitCodeFile (String pidFile)
specifier|public
specifier|static
name|String
name|getExitCodeFile
parameter_list|(
name|String
name|pidFile
parameter_list|)
block|{
return|return
name|pidFile
operator|+
name|EXIT_CODE_FILE_SUFFIX
return|;
block|}
DECL|method|recordContainerLogDir (ContainerId containerId, String logDir)
specifier|private
name|void
name|recordContainerLogDir
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|String
name|logDir
parameter_list|)
throws|throws
name|IOException
block|{
name|container
operator|.
name|setLogDir
argument_list|(
name|logDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|container
operator|.
name|isRetryContextSet
argument_list|()
condition|)
block|{
name|context
operator|.
name|getNMStateStore
argument_list|()
operator|.
name|storeContainerLogDir
argument_list|(
name|containerId
argument_list|,
name|logDir
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|recordContainerWorkDir (ContainerId containerId, String workDir)
specifier|private
name|void
name|recordContainerWorkDir
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|String
name|workDir
parameter_list|)
throws|throws
name|IOException
block|{
name|container
operator|.
name|setWorkDir
argument_list|(
name|workDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|container
operator|.
name|isRetryContextSet
argument_list|()
condition|)
block|{
name|context
operator|.
name|getNMStateStore
argument_list|()
operator|.
name|storeContainerWorkDir
argument_list|(
name|containerId
argument_list|,
name|workDir
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

