begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *<p>  * http://www.apache.org/licenses/LICENSE-2.0  *<p>  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.nodemanager.containermanager.resourceplugin.fpga
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|resourceplugin
operator|.
name|fpga
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|linux
operator|.
name|resources
operator|.
name|fpga
operator|.
name|FpgaResourceAllocator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|linux
operator|.
name|resources
operator|.
name|fpga
operator|.
name|FpgaResourceAllocator
operator|.
name|FpgaDevice
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_comment
comment|/**  * Intel FPGA for OpenCL plugin.  * The key points are:  * 1. It uses Intel's toolchain "aocl" to discover devices/reprogram IP  *    to the device before container launch to achieve a quickest  *    reprogramming path  * 2. It avoids reprogramming by maintaining a mapping of device to FPGA IP ID  * 3. It assume IP file is distributed to container directory  */
end_comment

begin_class
DECL|class|IntelFpgaOpenclPlugin
specifier|public
class|class
name|IntelFpgaOpenclPlugin
implements|implements
name|AbstractFpgaVendorPlugin
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|IntelFpgaOpenclPlugin
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|initialized
specifier|private
name|boolean
name|initialized
init|=
literal|false
decl_stmt|;
DECL|field|shell
specifier|private
name|InnerShellExecutor
name|shell
decl_stmt|;
DECL|field|DEFAULT_BINARY_NAME
specifier|private
specifier|static
specifier|final
name|String
name|DEFAULT_BINARY_NAME
init|=
literal|"aocl"
decl_stmt|;
DECL|field|ALTERAOCLSDKROOT_NAME
specifier|private
specifier|static
specifier|final
name|String
name|ALTERAOCLSDKROOT_NAME
init|=
literal|"ALTERAOCLSDKROOT"
decl_stmt|;
DECL|field|envProvider
specifier|private
name|Function
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|envProvider
init|=
name|System
operator|::
name|getenv
decl_stmt|;
DECL|field|pathToExecutable
specifier|private
name|String
name|pathToExecutable
init|=
literal|null
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|method|setInnerShellExecutor (InnerShellExecutor shellExecutor)
name|void
name|setInnerShellExecutor
parameter_list|(
name|InnerShellExecutor
name|shellExecutor
parameter_list|)
block|{
name|this
operator|.
name|shell
operator|=
name|shellExecutor
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getPathToExecutable ()
name|String
name|getPathToExecutable
parameter_list|()
block|{
return|return
name|pathToExecutable
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setEnvProvider (Function<String, String> envProvider)
name|void
name|setEnvProvider
parameter_list|(
name|Function
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|envProvider
parameter_list|)
block|{
name|this
operator|.
name|envProvider
operator|=
name|envProvider
expr_stmt|;
block|}
DECL|method|IntelFpgaOpenclPlugin ()
specifier|public
name|IntelFpgaOpenclPlugin
parameter_list|()
block|{
name|this
operator|.
name|shell
operator|=
operator|new
name|InnerShellExecutor
argument_list|()
expr_stmt|;
block|}
DECL|method|getDefaultPathToExecutable ()
specifier|public
name|String
name|getDefaultPathToExecutable
parameter_list|()
block|{
return|return
name|envProvider
operator|.
name|apply
argument_list|(
name|ALTERAOCLSDKROOT_NAME
argument_list|)
return|;
block|}
comment|/**    * Check the Intel FPGA for OpenCL toolchain.    * */
annotation|@
name|Override
DECL|method|initPlugin (Configuration config)
specifier|public
name|boolean
name|initPlugin
parameter_list|(
name|Configuration
name|config
parameter_list|)
block|{
if|if
condition|(
name|initialized
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// Find the proper toolchain, mainly aocl
name|String
name|pluginDefaultBinaryName
init|=
name|DEFAULT_BINARY_NAME
decl_stmt|;
name|String
name|executable
init|=
name|config
operator|.
name|get
argument_list|(
name|YarnConfiguration
operator|.
name|NM_FPGA_PATH_TO_EXEC
argument_list|,
name|pluginDefaultBinaryName
argument_list|)
decl_stmt|;
comment|// Validate file existence
name|File
name|binaryPath
init|=
operator|new
name|File
argument_list|(
name|executable
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|binaryPath
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|// When binary not exist, fail
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to find FPGA discoverer executable configured in "
operator|+
name|YarnConfiguration
operator|.
name|NM_FPGA_PATH_TO_EXEC
operator|+
literal|", please check! Try default path"
argument_list|)
expr_stmt|;
name|executable
operator|=
name|pluginDefaultBinaryName
expr_stmt|;
comment|// Try to find in plugin's preferred path
name|String
name|pluginDefaultPreferredPath
init|=
name|getDefaultPathToExecutable
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|pluginDefaultPreferredPath
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to find FPGA discoverer executable from system "
operator|+
literal|" environment "
operator|+
name|ALTERAOCLSDKROOT_NAME
operator|+
literal|", please check your environment!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|binaryPath
operator|=
operator|new
name|File
argument_list|(
name|pluginDefaultPreferredPath
operator|+
literal|"/bin"
argument_list|,
name|pluginDefaultBinaryName
argument_list|)
expr_stmt|;
if|if
condition|(
name|binaryPath
operator|.
name|exists
argument_list|()
condition|)
block|{
name|executable
operator|=
name|binaryPath
operator|.
name|getAbsolutePath
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Succeed in finding FPGA discoverer executable: "
operator|+
name|executable
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|executable
operator|=
name|pluginDefaultBinaryName
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to find FPGA discoverer executable in "
operator|+
name|pluginDefaultPreferredPath
operator|+
literal|", file doesn't exists! Use default binary"
operator|+
name|executable
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|pathToExecutable
operator|=
name|executable
expr_stmt|;
if|if
condition|(
operator|!
name|diagnose
argument_list|(
literal|10
operator|*
literal|1000
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Intel FPGA for OpenCL diagnose failed!"
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|initialized
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|initialized
return|;
block|}
annotation|@
name|Override
DECL|method|discover (int timeout)
specifier|public
name|List
argument_list|<
name|FpgaResourceAllocator
operator|.
name|FpgaDevice
argument_list|>
name|discover
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|List
argument_list|<
name|FpgaResourceAllocator
operator|.
name|FpgaDevice
argument_list|>
name|list
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|String
name|output
decl_stmt|;
name|output
operator|=
name|getDiagnoseInfo
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|==
name|output
condition|)
block|{
return|return
name|list
return|;
block|}
name|list
operator|=
name|AoclDiagnosticOutputParser
operator|.
name|parseDiagnosticOutput
argument_list|(
name|output
argument_list|,
name|shell
argument_list|,
name|getFpgaType
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
comment|/**    *  Helper class to run aocl diagnose&amp; determine major/minor numbers.    */
DECL|class|InnerShellExecutor
specifier|public
specifier|static
class|class
name|InnerShellExecutor
block|{
comment|// ls /dev/<devName>
comment|// return a string in format<major:minor>
DECL|method|getMajorAndMinorNumber (String devName)
specifier|public
name|String
name|getMajorAndMinorNumber
parameter_list|(
name|String
name|devName
parameter_list|)
block|{
name|String
name|output
init|=
literal|null
decl_stmt|;
name|Shell
operator|.
name|ShellCommandExecutor
name|shexec
init|=
operator|new
name|Shell
operator|.
name|ShellCommandExecutor
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"stat"
block|,
literal|"-c"
block|,
literal|"%t:%T"
block|,
literal|"/dev/"
operator|+
name|devName
block|}
argument_list|)
decl_stmt|;
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Get FPGA major-minor numbers from /dev/{}"
argument_list|,
name|devName
argument_list|)
expr_stmt|;
name|shexec
operator|.
name|execute
argument_list|()
expr_stmt|;
name|String
index|[]
name|strs
init|=
name|shexec
operator|.
name|getOutput
argument_list|()
operator|.
name|trim
argument_list|()
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"stat output:{}"
argument_list|,
name|shexec
operator|.
name|getOutput
argument_list|()
argument_list|)
expr_stmt|;
name|output
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|strs
index|[
literal|0
index|]
argument_list|,
literal|16
argument_list|)
operator|+
literal|":"
operator|+
name|Integer
operator|.
name|parseInt
argument_list|(
name|strs
index|[
literal|1
index|]
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to get major-minor number from reading /dev/"
operator|+
name|devName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Command output:"
operator|+
name|shexec
operator|.
name|getOutput
argument_list|()
operator|+
literal|", exit code: "
operator|+
name|shexec
operator|.
name|getExitCode
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
DECL|method|runDiagnose (String binary, int timeout)
specifier|public
name|String
name|runDiagnose
parameter_list|(
name|String
name|binary
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|String
name|output
init|=
literal|null
decl_stmt|;
name|Shell
operator|.
name|ShellCommandExecutor
name|shexec
init|=
operator|new
name|Shell
operator|.
name|ShellCommandExecutor
argument_list|(
operator|new
name|String
index|[]
block|{
name|binary
block|,
literal|"diagnose"
block|}
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|timeout
argument_list|)
decl_stmt|;
try|try
block|{
name|shexec
operator|.
name|execute
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// aocl diagnose exit code is 1 even it success.
comment|// we ignore it because we only wants the output
name|String
name|msg
init|=
literal|"Failed to execute "
operator|+
name|binary
operator|+
literal|" diagnose, exception message:"
operator|+
name|e
operator|.
name|getMessage
argument_list|()
operator|+
literal|", output:"
operator|+
name|output
operator|+
literal|", continue ..."
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}"
argument_list|,
name|shexec
operator|.
name|getOutput
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|shexec
operator|.
name|getOutput
argument_list|()
return|;
block|}
block|}
DECL|method|getDiagnoseInfo (int timeout)
specifier|public
name|String
name|getDiagnoseInfo
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
return|return
name|this
operator|.
name|shell
operator|.
name|runDiagnose
argument_list|(
name|this
operator|.
name|pathToExecutable
argument_list|,
name|timeout
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|diagnose (int timeout)
specifier|public
name|boolean
name|diagnose
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|String
name|output
init|=
name|getDiagnoseInfo
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|output
operator|&&
name|output
operator|.
name|contains
argument_list|(
literal|"DIAGNOSTIC_PASSED"
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * this is actually the opencl platform type    * */
annotation|@
name|Override
DECL|method|getFpgaType ()
specifier|public
name|String
name|getFpgaType
parameter_list|()
block|{
return|return
literal|"IntelOpenCL"
return|;
block|}
annotation|@
name|Override
DECL|method|retrieveIPfilePath (String id, String dstDir, Map<Path, List<String>> localizedResources)
specifier|public
name|String
name|retrieveIPfilePath
parameter_list|(
name|String
name|id
parameter_list|,
name|String
name|dstDir
parameter_list|,
name|Map
argument_list|<
name|Path
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|localizedResources
parameter_list|)
block|{
comment|// Assume .aocx IP file is distributed by DS to local dir
name|String
name|ipFilePath
init|=
literal|null
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Got environment: "
operator|+
name|id
operator|+
literal|", search IP file in localized resources"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|==
name|id
operator|||
name|id
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"IP_ID environment is empty, skip downloading"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|localizedResources
operator|!=
literal|null
condition|)
block|{
name|Optional
argument_list|<
name|Path
argument_list|>
name|aocxPath
init|=
name|localizedResources
operator|.
name|keySet
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|path
lambda|->
name|matchesIpid
argument_list|(
name|path
argument_list|,
name|id
argument_list|)
argument_list|)
operator|.
name|findFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|aocxPath
operator|.
name|isPresent
argument_list|()
condition|)
block|{
name|ipFilePath
operator|=
name|aocxPath
operator|.
name|get
argument_list|()
operator|.
name|toUri
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found: {}"
argument_list|,
name|ipFilePath
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Localized resource is null!"
argument_list|)
expr_stmt|;
block|}
return|return
name|ipFilePath
return|;
block|}
DECL|method|matchesIpid (Path p, String id)
specifier|private
name|boolean
name|matchesIpid
parameter_list|(
name|Path
name|p
parameter_list|,
name|String
name|id
parameter_list|)
block|{
return|return
name|p
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|.
name|equals
argument_list|(
name|id
operator|.
name|toLowerCase
argument_list|()
argument_list|)
operator|&&
name|p
operator|.
name|getName
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|".aocx"
argument_list|)
return|;
block|}
comment|/**    * Program one device.    * It's ok for the offline "aocl program" failed because the application will    * always invoke API to program.    * The reason we do offline reprogramming is to make the application's    * program process faster.    * @param ipPath the absolute path to the aocx IP file    * @param device Fpga device object which represents the card    * @return false if programming the card fails    * */
annotation|@
name|Override
DECL|method|configureIP (String ipPath, FpgaDevice device)
specifier|public
name|boolean
name|configureIP
parameter_list|(
name|String
name|ipPath
parameter_list|,
name|FpgaDevice
name|device
parameter_list|)
block|{
comment|// perform offline program the IP to get a quickest reprogramming sequence
comment|// we need a mapping of "major:minor" to "acl0" to
comment|// issue command "aocl program<acl0><ipPath>"
name|Shell
operator|.
name|ShellCommandExecutor
name|shexec
decl_stmt|;
name|String
name|aclName
decl_stmt|;
name|aclName
operator|=
name|device
operator|.
name|getAliasDevName
argument_list|()
expr_stmt|;
name|shexec
operator|=
operator|new
name|Shell
operator|.
name|ShellCommandExecutor
argument_list|(
operator|new
name|String
index|[]
block|{
name|this
operator|.
name|pathToExecutable
block|,
literal|"program"
block|,
name|aclName
block|,
name|ipPath
block|}
argument_list|)
expr_stmt|;
try|try
block|{
name|shexec
operator|.
name|execute
argument_list|()
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|shexec
operator|.
name|getExitCode
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}"
argument_list|,
name|shexec
operator|.
name|getOutput
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Intel aocl program "
operator|+
name|ipPath
operator|+
literal|" to "
operator|+
name|aclName
operator|+
literal|" successfully"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Device programming failed, aocl output is:"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|shexec
operator|.
name|getOutput
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Intel aocl program "
operator|+
name|ipPath
operator|+
literal|" to "
operator|+
name|aclName
operator|+
literal|" failed!"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Aocl output: "
operator|+
name|shexec
operator|.
name|getOutput
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
block|}
end_class

end_unit

