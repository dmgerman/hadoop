begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *<p>  * http://www.apache.org/licenses/LICENSE-2.0  *<p>  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.nodemanager.containermanager.linux.resources.fpga
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|linux
operator|.
name|resources
operator|.
name|fpga
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|container
operator|.
name|Container
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|linux
operator|.
name|resources
operator|.
name|ResourceHandlerException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ResourceInformation
operator|.
name|FPGA_URI
import|;
end_import

begin_comment
comment|/**  * This FPGA resource allocator tends to be used by different FPGA vendor's plugin  * A "type" parameter is taken into consideration when allocation  * */
end_comment

begin_class
DECL|class|FpgaResourceAllocator
specifier|public
class|class
name|FpgaResourceAllocator
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|FpgaResourceAllocator
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|allowedFpgas
specifier|private
name|List
argument_list|<
name|FpgaDevice
argument_list|>
name|allowedFpgas
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
comment|//key is resource type of FPGA, vendor plugin supported ID
DECL|field|availableFpgas
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|FpgaDevice
argument_list|>
argument_list|>
name|availableFpgas
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|//key is the container ID
DECL|field|containerToFpgaMapping
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|FpgaDevice
argument_list|>
argument_list|>
name|containerToFpgaMapping
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|nmContext
specifier|private
name|Context
name|nmContext
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|method|getAvailableFpga ()
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|FpgaDevice
argument_list|>
argument_list|>
name|getAvailableFpga
parameter_list|()
block|{
return|return
name|availableFpgas
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getAllowedFpga ()
name|List
argument_list|<
name|FpgaDevice
argument_list|>
name|getAllowedFpga
parameter_list|()
block|{
return|return
name|allowedFpgas
return|;
block|}
DECL|method|FpgaResourceAllocator (Context ctx)
specifier|public
name|FpgaResourceAllocator
parameter_list|(
name|Context
name|ctx
parameter_list|)
block|{
name|this
operator|.
name|nmContext
operator|=
name|ctx
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getAvailableFpgaCount ()
name|int
name|getAvailableFpgaCount
parameter_list|()
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|count
operator|=
name|availableFpgas
operator|.
name|values
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|mapToInt
argument_list|(
name|i
lambda|->
name|i
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|sum
argument_list|()
expr_stmt|;
return|return
name|count
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getUsedFpga ()
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|FpgaDevice
argument_list|>
argument_list|>
name|getUsedFpga
parameter_list|()
block|{
return|return
name|containerToFpgaMapping
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getUsedFpgaCount ()
name|int
name|getUsedFpgaCount
parameter_list|()
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|count
operator|=
name|containerToFpgaMapping
operator|.
name|values
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|mapToInt
argument_list|(
name|i
lambda|->
name|i
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|sum
argument_list|()
expr_stmt|;
return|return
name|count
return|;
block|}
DECL|class|FpgaAllocation
specifier|public
specifier|static
class|class
name|FpgaAllocation
block|{
DECL|field|allowed
specifier|private
name|List
argument_list|<
name|FpgaDevice
argument_list|>
name|allowed
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
DECL|field|denied
specifier|private
name|List
argument_list|<
name|FpgaDevice
argument_list|>
name|denied
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
DECL|method|FpgaAllocation (List<FpgaDevice> allowed, List<FpgaDevice> denied)
name|FpgaAllocation
parameter_list|(
name|List
argument_list|<
name|FpgaDevice
argument_list|>
name|allowed
parameter_list|,
name|List
argument_list|<
name|FpgaDevice
argument_list|>
name|denied
parameter_list|)
block|{
if|if
condition|(
name|allowed
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|allowed
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|allowed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|denied
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|denied
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|denied
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getAllowed ()
specifier|public
name|List
argument_list|<
name|FpgaDevice
argument_list|>
name|getAllowed
parameter_list|()
block|{
return|return
name|allowed
return|;
block|}
DECL|method|getDenied ()
specifier|public
name|List
argument_list|<
name|FpgaDevice
argument_list|>
name|getDenied
parameter_list|()
block|{
return|return
name|denied
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\nFpgaAllocation\n\tAllowed:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|FpgaDevice
name|device
range|:
name|allowed
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\t\t"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|device
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"\tDenied\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|FpgaDevice
name|device
range|:
name|denied
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\t\t"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|device
operator|+
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/** A class that represents an FPGA card. */
DECL|class|FpgaDevice
specifier|public
specifier|static
class|class
name|FpgaDevice
implements|implements
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
operator|-
literal|4678487141824092751L
decl_stmt|;
DECL|field|type
specifier|private
specifier|final
name|String
name|type
decl_stmt|;
DECL|field|major
specifier|private
specifier|final
name|int
name|major
decl_stmt|;
DECL|field|minor
specifier|private
specifier|final
name|int
name|minor
decl_stmt|;
comment|// the alias device name. Intel use acl number acl0 to acl31
DECL|field|aliasDevName
specifier|private
specifier|final
name|String
name|aliasDevName
decl_stmt|;
comment|// IP file identifier. matrix multiplication for instance (mutable)
DECL|field|IPID
specifier|private
name|String
name|IPID
decl_stmt|;
comment|// SHA-256 hash of the uploaded aocx file (mutable)
DECL|field|aocxHash
specifier|private
name|String
name|aocxHash
decl_stmt|;
comment|// cached hash value
DECL|field|hashCode
specifier|private
name|Integer
name|hashCode
decl_stmt|;
DECL|method|getType ()
specifier|public
name|String
name|getType
parameter_list|()
block|{
return|return
name|type
return|;
block|}
DECL|method|getMajor ()
specifier|public
name|int
name|getMajor
parameter_list|()
block|{
return|return
name|major
return|;
block|}
DECL|method|getMinor ()
specifier|public
name|int
name|getMinor
parameter_list|()
block|{
return|return
name|minor
return|;
block|}
DECL|method|getIPID ()
specifier|public
name|String
name|getIPID
parameter_list|()
block|{
return|return
name|IPID
return|;
block|}
DECL|method|getAocxHash ()
specifier|public
name|String
name|getAocxHash
parameter_list|()
block|{
return|return
name|aocxHash
return|;
block|}
DECL|method|setAocxHash (String hash)
specifier|public
name|void
name|setAocxHash
parameter_list|(
name|String
name|hash
parameter_list|)
block|{
name|this
operator|.
name|aocxHash
operator|=
name|hash
expr_stmt|;
block|}
DECL|method|setIPID (String IPID)
specifier|public
name|void
name|setIPID
parameter_list|(
name|String
name|IPID
parameter_list|)
block|{
name|this
operator|.
name|IPID
operator|=
name|IPID
expr_stmt|;
block|}
DECL|method|getAliasDevName ()
specifier|public
name|String
name|getAliasDevName
parameter_list|()
block|{
return|return
name|aliasDevName
return|;
block|}
DECL|method|FpgaDevice (String type, int major, int minor, String aliasDevName)
specifier|public
name|FpgaDevice
parameter_list|(
name|String
name|type
parameter_list|,
name|int
name|major
parameter_list|,
name|int
name|minor
parameter_list|,
name|String
name|aliasDevName
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|type
argument_list|,
literal|"type must not be null"
argument_list|)
expr_stmt|;
name|this
operator|.
name|major
operator|=
name|major
expr_stmt|;
name|this
operator|.
name|minor
operator|=
name|minor
expr_stmt|;
name|this
operator|.
name|aliasDevName
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|aliasDevName
argument_list|,
literal|"aliasDevName must not be null"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|equals (Object obj)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|getClass
argument_list|()
operator|!=
name|obj
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|FpgaDevice
name|other
init|=
operator|(
name|FpgaDevice
operator|)
name|obj
decl_stmt|;
if|if
condition|(
name|aliasDevName
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|other
operator|.
name|aliasDevName
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|aliasDevName
operator|.
name|equals
argument_list|(
name|other
operator|.
name|aliasDevName
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|major
operator|!=
name|other
operator|.
name|major
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|minor
operator|!=
name|other
operator|.
name|minor
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|type
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|other
operator|.
name|type
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|type
operator|.
name|equals
argument_list|(
name|other
operator|.
name|type
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
if|if
condition|(
name|hashCode
operator|==
literal|null
condition|)
block|{
specifier|final
name|int
name|prime
init|=
literal|31
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
name|result
operator|=
name|prime
operator|*
name|result
operator|+
name|major
expr_stmt|;
name|result
operator|=
name|prime
operator|*
name|result
operator|+
name|type
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|result
operator|=
name|prime
operator|*
name|result
operator|+
name|minor
expr_stmt|;
name|result
operator|=
name|prime
operator|*
name|result
operator|+
name|aliasDevName
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|hashCode
operator|=
name|result
expr_stmt|;
block|}
return|return
name|hashCode
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"FPGA Device:(Type: "
operator|+
name|this
operator|.
name|type
operator|+
literal|", Major: "
operator|+
name|this
operator|.
name|major
operator|+
literal|", Minor: "
operator|+
name|this
operator|.
name|minor
operator|+
literal|", IPID: "
operator|+
name|this
operator|.
name|IPID
operator|+
literal|", Hash: "
operator|+
name|this
operator|.
name|aocxHash
operator|+
literal|")"
return|;
block|}
block|}
comment|// called once during initialization
DECL|method|addFpgaDevices (String type, List<FpgaDevice> list)
specifier|public
specifier|synchronized
name|void
name|addFpgaDevices
parameter_list|(
name|String
name|type
parameter_list|,
name|List
argument_list|<
name|FpgaDevice
argument_list|>
name|list
parameter_list|)
block|{
name|availableFpgas
operator|.
name|putIfAbsent
argument_list|(
name|type
argument_list|,
operator|new
name|LinkedList
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|FpgaDevice
argument_list|>
name|fpgaDevices
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|FpgaDevice
name|device
range|:
name|list
control|)
block|{
if|if
condition|(
operator|!
name|allowedFpgas
operator|.
name|contains
argument_list|(
name|device
argument_list|)
condition|)
block|{
name|fpgaDevices
operator|.
name|add
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|availableFpgas
operator|.
name|get
argument_list|(
name|type
argument_list|)
operator|.
name|add
argument_list|(
name|device
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Duplicate device found: "
operator|+
name|device
operator|+
literal|". Ignored"
argument_list|)
expr_stmt|;
block|}
block|}
name|allowedFpgas
operator|=
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|fpgaDevices
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Added a list of FPGA Devices: "
operator|+
name|allowedFpgas
argument_list|)
expr_stmt|;
block|}
DECL|method|updateFpga (String requestor, FpgaDevice device, String newIPID, String newHash)
specifier|public
specifier|synchronized
name|void
name|updateFpga
parameter_list|(
name|String
name|requestor
parameter_list|,
name|FpgaDevice
name|device
parameter_list|,
name|String
name|newIPID
parameter_list|,
name|String
name|newHash
parameter_list|)
block|{
name|device
operator|.
name|setIPID
argument_list|(
name|newIPID
argument_list|)
expr_stmt|;
name|device
operator|.
name|setAocxHash
argument_list|(
name|newHash
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Update IPID to "
operator|+
name|newIPID
operator|+
literal|" for this allocated device: "
operator|+
name|device
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Update IP hash to "
operator|+
name|newHash
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assign {@link FpgaAllocation} with preferred IPID, if no, with random FPGAs    * @param type vendor plugin supported FPGA device type    * @param count requested FPGA slot count    * @param container container id    * @param ipidHash hash of the localized aocx file    * @return Instance consists two List of allowed and denied {@link FpgaDevice}    * @throws ResourceHandlerException When failed to allocate or write state store    * */
DECL|method|assignFpga (String type, long count, Container container, String ipidHash)
specifier|public
specifier|synchronized
name|FpgaAllocation
name|assignFpga
parameter_list|(
name|String
name|type
parameter_list|,
name|long
name|count
parameter_list|,
name|Container
name|container
parameter_list|,
name|String
name|ipidHash
parameter_list|)
throws|throws
name|ResourceHandlerException
block|{
name|List
argument_list|<
name|FpgaDevice
argument_list|>
name|currentAvailableFpga
init|=
name|availableFpgas
operator|.
name|get
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|String
name|requestor
init|=
name|container
operator|.
name|getContainerId
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|currentAvailableFpga
condition|)
block|{
throw|throw
operator|new
name|ResourceHandlerException
argument_list|(
literal|"No such type of FPGA resource available: "
operator|+
name|type
argument_list|)
throw|;
block|}
if|if
condition|(
name|count
argument_list|<
literal|0
operator|||
name|count
argument_list|>
name|currentAvailableFpga
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ResourceHandlerException
argument_list|(
literal|"Invalid FPGA request count or not enough, requested:"
operator|+
name|count
operator|+
literal|", available:"
operator|+
name|getAvailableFpgaCount
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
comment|// Allocate devices with matching IP first, then any device is ok
name|List
argument_list|<
name|FpgaDevice
argument_list|>
name|assignedFpgas
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|matchIPCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|currentAvailableFpga
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|deviceIPIDhash
init|=
name|currentAvailableFpga
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getAocxHash
argument_list|()
decl_stmt|;
if|if
condition|(
name|deviceIPIDhash
operator|!=
literal|null
operator|&&
name|deviceIPIDhash
operator|.
name|equalsIgnoreCase
argument_list|(
name|ipidHash
argument_list|)
condition|)
block|{
name|assignedFpgas
operator|.
name|add
argument_list|(
name|currentAvailableFpga
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|currentAvailableFpga
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|matchIPCount
operator|++
expr_stmt|;
block|}
block|}
name|int
name|remaining
init|=
operator|(
name|int
operator|)
name|count
operator|-
name|matchIPCount
decl_stmt|;
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
name|assignedFpgas
operator|.
name|add
argument_list|(
name|currentAvailableFpga
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|remaining
operator|--
expr_stmt|;
block|}
comment|// Record in state store if we allocated anything
if|if
condition|(
operator|!
name|assignedFpgas
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|nmContext
operator|.
name|getNMStateStore
argument_list|()
operator|.
name|storeAssignedResources
argument_list|(
name|container
argument_list|,
name|FPGA_URI
argument_list|,
operator|new
name|LinkedList
argument_list|<>
argument_list|(
name|assignedFpgas
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// failed, give the allocation back
name|currentAvailableFpga
operator|.
name|addAll
argument_list|(
name|assignedFpgas
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ResourceHandlerException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// update state store success, update internal used FPGAs
name|containerToFpgaMapping
operator|.
name|putIfAbsent
argument_list|(
name|requestor
argument_list|,
operator|new
name|LinkedList
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
name|containerToFpgaMapping
operator|.
name|get
argument_list|(
name|requestor
argument_list|)
operator|.
name|addAll
argument_list|(
name|assignedFpgas
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|FpgaAllocation
argument_list|(
name|assignedFpgas
argument_list|,
name|currentAvailableFpga
argument_list|)
return|;
block|}
return|return
operator|new
name|FpgaAllocation
argument_list|(
literal|null
argument_list|,
name|allowedFpgas
argument_list|)
return|;
block|}
DECL|method|recoverAssignedFpgas (ContainerId containerId)
specifier|public
specifier|synchronized
name|void
name|recoverAssignedFpgas
parameter_list|(
name|ContainerId
name|containerId
parameter_list|)
throws|throws
name|ResourceHandlerException
block|{
name|Container
name|c
init|=
name|nmContext
operator|.
name|getContainers
argument_list|()
operator|.
name|get
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|c
condition|)
block|{
throw|throw
operator|new
name|ResourceHandlerException
argument_list|(
literal|"This shouldn't happen, cannot find container with id="
operator|+
name|containerId
argument_list|)
throw|;
block|}
for|for
control|(
name|Serializable
name|fpgaDevice
range|:
name|c
operator|.
name|getResourceMappings
argument_list|()
operator|.
name|getAssignedResources
argument_list|(
name|FPGA_URI
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|fpgaDevice
operator|instanceof
name|FpgaDevice
operator|)
condition|)
block|{
throw|throw
operator|new
name|ResourceHandlerException
argument_list|(
literal|"Trying to recover allocated FPGA devices, however it"
operator|+
literal|" is not FpgaDevice type, this shouldn't happen"
argument_list|)
throw|;
block|}
comment|// Make sure it is in allowed FPGA device.
if|if
condition|(
operator|!
name|allowedFpgas
operator|.
name|contains
argument_list|(
name|fpgaDevice
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ResourceHandlerException
argument_list|(
literal|"Try to recover FpgaDevice = "
operator|+
name|fpgaDevice
operator|+
literal|" however it is not in allowed device list:"
operator|+
name|StringUtils
operator|.
name|join
argument_list|(
literal|";"
argument_list|,
name|allowedFpgas
argument_list|)
argument_list|)
throw|;
block|}
comment|// Make sure it is not occupied by anybody else
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|FpgaDevice
argument_list|>
argument_list|>
argument_list|>
name|iterator
init|=
name|getUsedFpga
argument_list|()
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|iterator
operator|.
name|next
argument_list|()
operator|.
name|getValue
argument_list|()
operator|.
name|contains
argument_list|(
name|fpgaDevice
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ResourceHandlerException
argument_list|(
literal|"Try to recover FpgaDevice = "
operator|+
name|fpgaDevice
operator|+
literal|" however it is already assigned to others"
argument_list|)
throw|;
block|}
block|}
name|getUsedFpga
argument_list|()
operator|.
name|putIfAbsent
argument_list|(
name|containerId
operator|.
name|toString
argument_list|()
argument_list|,
operator|new
name|LinkedList
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
name|getUsedFpga
argument_list|()
operator|.
name|get
argument_list|(
name|containerId
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
operator|(
name|FpgaDevice
operator|)
name|fpgaDevice
argument_list|)
expr_stmt|;
comment|// remove them from available list
name|getAvailableFpga
argument_list|()
operator|.
name|get
argument_list|(
operator|(
operator|(
name|FpgaDevice
operator|)
name|fpgaDevice
operator|)
operator|.
name|getType
argument_list|()
argument_list|)
operator|.
name|remove
argument_list|(
name|fpgaDevice
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|cleanupAssignFpgas (String requestor)
specifier|public
specifier|synchronized
name|void
name|cleanupAssignFpgas
parameter_list|(
name|String
name|requestor
parameter_list|)
block|{
name|List
argument_list|<
name|FpgaDevice
argument_list|>
name|usedFpgas
init|=
name|containerToFpgaMapping
operator|.
name|get
argument_list|(
name|requestor
argument_list|)
decl_stmt|;
if|if
condition|(
name|usedFpgas
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|FpgaDevice
name|device
range|:
name|usedFpgas
control|)
block|{
comment|// Add back to availableFpga
name|availableFpgas
operator|.
name|get
argument_list|(
name|device
operator|.
name|getType
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|device
argument_list|)
expr_stmt|;
block|}
name|containerToFpgaMapping
operator|.
name|remove
argument_list|(
name|requestor
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

