begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.nodemanager.containermanager.linux.resources
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|linux
operator|.
name|resources
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|ApplicationConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnRuntimeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|Clock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|MonotonicClock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|DEFAULT_NM_ELASTIC_MEMORY_CONTROL_OOM_TIMEOUT_SEC
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|NM_ELASTIC_MEMORY_CONTROL_ENABLED
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|NM_ELASTIC_MEMORY_CONTROL_OOM_TIMEOUT_SEC
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|NM_PMEM_CHECK_ENABLED
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|NM_VMEM_CHECK_ENABLED
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|linux
operator|.
name|resources
operator|.
name|CGroupsHandler
operator|.
name|CGROUP_PARAM_MEMORY_HARD_LIMIT_BYTES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|linux
operator|.
name|resources
operator|.
name|CGroupsHandler
operator|.
name|CGROUP_PARAM_MEMORY_OOM_CONTROL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|linux
operator|.
name|resources
operator|.
name|CGroupsHandler
operator|.
name|CGROUP_PARAM_MEMORY_SWAP_HARD_LIMIT_BYTES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|nodemanager
operator|.
name|containermanager
operator|.
name|linux
operator|.
name|resources
operator|.
name|CGroupsHandler
operator|.
name|CGROUP_NO_LIMIT
import|;
end_import

begin_comment
comment|/**  * This thread controls memory usage using cgroups. It listens to out of memory  * events of all the containers together, and if we go over the limit picks  * a container to kill. The algorithm that picks the container is a plugin.  */
end_comment

begin_class
DECL|class|CGroupElasticMemoryController
specifier|public
class|class
name|CGroupElasticMemoryController
extends|extends
name|Thread
block|{
DECL|field|LOG
specifier|protected
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|CGroupElasticMemoryController
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|clock
specifier|private
specifier|final
name|Clock
name|clock
init|=
operator|new
name|MonotonicClock
argument_list|()
decl_stmt|;
DECL|field|yarnCGroupPath
specifier|private
name|String
name|yarnCGroupPath
decl_stmt|;
DECL|field|oomListenerPath
specifier|private
name|String
name|oomListenerPath
decl_stmt|;
DECL|field|oomHandler
specifier|private
name|Runnable
name|oomHandler
decl_stmt|;
DECL|field|cgroups
specifier|private
name|CGroupsHandler
name|cgroups
decl_stmt|;
DECL|field|controlPhysicalMemory
specifier|private
name|boolean
name|controlPhysicalMemory
decl_stmt|;
DECL|field|controlVirtualMemory
specifier|private
name|boolean
name|controlVirtualMemory
decl_stmt|;
DECL|field|limit
specifier|private
name|long
name|limit
decl_stmt|;
DECL|field|process
specifier|private
name|Process
name|process
init|=
literal|null
decl_stmt|;
DECL|field|stopped
specifier|private
name|boolean
name|stopped
init|=
literal|false
decl_stmt|;
DECL|field|timeoutMS
specifier|private
name|int
name|timeoutMS
decl_stmt|;
comment|/**    * Default constructor.    * @param conf Yarn configuration to use    * @param context Node manager context to out of memory handler    * @param cgroups Cgroups handler configured    * @param controlPhysicalMemory Whether to listen to physical memory OOM    * @param controlVirtualMemory Whether to listen to virtual memory OOM    * @param limit memory limit in bytes    * @param oomHandlerOverride optional OOM handler    * @exception YarnException Could not instantiate class    */
annotation|@
name|VisibleForTesting
DECL|method|CGroupElasticMemoryController (Configuration conf, Context context, CGroupsHandler cgroups, boolean controlPhysicalMemory, boolean controlVirtualMemory, long limit, Runnable oomHandlerOverride)
name|CGroupElasticMemoryController
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Context
name|context
parameter_list|,
name|CGroupsHandler
name|cgroups
parameter_list|,
name|boolean
name|controlPhysicalMemory
parameter_list|,
name|boolean
name|controlVirtualMemory
parameter_list|,
name|long
name|limit
parameter_list|,
name|Runnable
name|oomHandlerOverride
parameter_list|)
throws|throws
name|YarnException
block|{
name|super
argument_list|(
literal|"CGroupElasticMemoryController"
argument_list|)
expr_stmt|;
name|boolean
name|controlVirtual
init|=
name|controlVirtualMemory
operator|&&
operator|!
name|controlPhysicalMemory
decl_stmt|;
name|Runnable
name|oomHandlerTemp
init|=
name|getDefaultOOMHandler
argument_list|(
name|conf
argument_list|,
name|context
argument_list|,
name|oomHandlerOverride
argument_list|,
name|controlVirtual
argument_list|)
decl_stmt|;
if|if
condition|(
name|controlPhysicalMemory
operator|&&
name|controlVirtualMemory
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|NM_ELASTIC_MEMORY_CONTROL_ENABLED
operator|+
literal|" is on. "
operator|+
literal|"We cannot control both virtual and physical "
operator|+
literal|"memory at the same time. Enforcing virtual memory. "
operator|+
literal|"If swapping is enabled set "
operator|+
literal|"only "
operator|+
name|NM_PMEM_CHECK_ENABLED
operator|+
literal|" to true otherwise set "
operator|+
literal|"only "
operator|+
name|NM_VMEM_CHECK_ENABLED
operator|+
literal|" to true."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|controlPhysicalMemory
operator|&&
operator|!
name|controlVirtualMemory
condition|)
block|{
throw|throw
operator|new
name|YarnException
argument_list|(
name|NM_ELASTIC_MEMORY_CONTROL_ENABLED
operator|+
literal|" is on. "
operator|+
literal|"We need either virtual or physical memory check requested. "
operator|+
literal|"If swapping is enabled set "
operator|+
literal|"only "
operator|+
name|NM_PMEM_CHECK_ENABLED
operator|+
literal|" to true otherwise set "
operator|+
literal|"only "
operator|+
name|NM_VMEM_CHECK_ENABLED
operator|+
literal|" to true."
argument_list|)
throw|;
block|}
comment|// We are safe at this point that no more exceptions can be thrown
name|this
operator|.
name|timeoutMS
operator|=
literal|1000
operator|*
name|conf
operator|.
name|getInt
argument_list|(
name|NM_ELASTIC_MEMORY_CONTROL_OOM_TIMEOUT_SEC
argument_list|,
name|DEFAULT_NM_ELASTIC_MEMORY_CONTROL_OOM_TIMEOUT_SEC
argument_list|)
expr_stmt|;
name|this
operator|.
name|oomListenerPath
operator|=
name|getOOMListenerExecutablePath
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|oomHandler
operator|=
name|oomHandlerTemp
expr_stmt|;
name|this
operator|.
name|cgroups
operator|=
name|cgroups
expr_stmt|;
name|this
operator|.
name|controlPhysicalMemory
operator|=
operator|!
name|controlVirtual
expr_stmt|;
name|this
operator|.
name|controlVirtualMemory
operator|=
name|controlVirtual
expr_stmt|;
name|this
operator|.
name|yarnCGroupPath
operator|=
name|this
operator|.
name|cgroups
operator|.
name|getPathForCGroup
argument_list|(
name|CGroupsHandler
operator|.
name|CGroupController
operator|.
name|MEMORY
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|this
operator|.
name|limit
operator|=
name|limit
expr_stmt|;
block|}
comment|/**    * Get the configured OOM handler.    * @param conf configuration    * @param context context to pass to constructor    * @param oomHandlerLocal Default override    * @param controlVirtual Control physical or virtual memory    * @return The configured or overridden OOM handler.    * @throws YarnException in case the constructor failed    */
DECL|method|getDefaultOOMHandler ( Configuration conf, Context context, Runnable oomHandlerLocal, boolean controlVirtual)
specifier|private
name|Runnable
name|getDefaultOOMHandler
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Context
name|context
parameter_list|,
name|Runnable
name|oomHandlerLocal
parameter_list|,
name|boolean
name|controlVirtual
parameter_list|)
throws|throws
name|YarnException
block|{
name|Class
name|oomHandlerClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|YarnConfiguration
operator|.
name|NM_ELASTIC_MEMORY_CONTROL_OOM_HANDLER
argument_list|,
name|DefaultOOMHandler
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|oomHandlerLocal
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|Constructor
name|constr
init|=
name|oomHandlerClass
operator|.
name|getConstructor
argument_list|(
name|Context
operator|.
name|class
argument_list|,
name|boolean
operator|.
name|class
argument_list|)
decl_stmt|;
name|oomHandlerLocal
operator|=
operator|(
name|Runnable
operator|)
name|constr
operator|.
name|newInstance
argument_list|(
name|context
argument_list|,
name|controlVirtual
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|YarnException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
return|return
name|oomHandlerLocal
return|;
block|}
comment|/**    * Default constructor.    * @param conf Yarn configuration to use    * @param context Node manager context to out of memory handler    * @param cgroups Cgroups handler configured    * @param controlPhysicalMemory Whether to listen to physical memory OOM    * @param controlVirtualMemory Whether to listen to virtual memory OOM    * @param limit memory limit in bytes    * @exception YarnException Could not instantiate class    */
DECL|method|CGroupElasticMemoryController (Configuration conf, Context context, CGroupsHandler cgroups, boolean controlPhysicalMemory, boolean controlVirtualMemory, long limit)
specifier|public
name|CGroupElasticMemoryController
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Context
name|context
parameter_list|,
name|CGroupsHandler
name|cgroups
parameter_list|,
name|boolean
name|controlPhysicalMemory
parameter_list|,
name|boolean
name|controlVirtualMemory
parameter_list|,
name|long
name|limit
parameter_list|)
throws|throws
name|YarnException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|context
argument_list|,
name|cgroups
argument_list|,
name|controlPhysicalMemory
argument_list|,
name|controlVirtualMemory
argument_list|,
name|limit
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Exception thrown if the OOM situation is not resolved.    */
DECL|class|OOMNotResolvedException
specifier|static
specifier|private
class|class
name|OOMNotResolvedException
extends|extends
name|YarnRuntimeException
block|{
DECL|method|OOMNotResolvedException (String message, Exception parent)
name|OOMNotResolvedException
parameter_list|(
name|String
name|message
parameter_list|,
name|Exception
name|parent
parameter_list|)
block|{
name|super
argument_list|(
name|message
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Stop listening to the cgroup.    */
DECL|method|stopListening ()
specifier|public
specifier|synchronized
name|void
name|stopListening
parameter_list|()
block|{
name|stopped
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|process
operator|!=
literal|null
condition|)
block|{
name|process
operator|.
name|destroyForcibly
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Trying to stop listening, when listening is not running"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Checks if the CGroupElasticMemoryController is available on this system.    * This assumes that Linux container executor is already initialized.    * We need to have CGroups enabled.    *    * @return True if CGroupElasticMemoryController is available.    * False otherwise.    */
DECL|method|isAvailable ()
specifier|public
specifier|static
name|boolean
name|isAvailable
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
operator|!
name|Shell
operator|.
name|LINUX
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"CGroupElasticMemoryController currently is supported only "
operator|+
literal|"on Linux."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|ResourceHandlerModule
operator|.
name|getCGroupsHandler
argument_list|()
operator|==
literal|null
operator|||
name|ResourceHandlerModule
operator|.
name|getMemoryResourceHandler
argument_list|()
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"CGroupElasticMemoryController requires enabling "
operator|+
literal|"memory CGroups with"
operator|+
name|YarnConfiguration
operator|.
name|NM_MEMORY_RESOURCE_ENABLED
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|SecurityException
name|se
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to get Operating System name. "
operator|+
name|se
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Main OOM listening thread. It uses an external process to listen to    * Linux events. The external process does not need to run as root, so    * it is not related to container-executor. We do not use JNI for security    * reasons.    */
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|ExecutorService
name|executor
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// Disable OOM killer and set a limit.
comment|// This has to be set first, so that we get notified about valid events.
comment|// We will be notified about events even, if they happened before
comment|// oom-listener started
name|setCGroupParameters
argument_list|()
expr_stmt|;
comment|// Start a listener process
name|ProcessBuilder
name|oomListener
init|=
operator|new
name|ProcessBuilder
argument_list|()
decl_stmt|;
name|oomListener
operator|.
name|command
argument_list|(
name|oomListenerPath
argument_list|,
name|yarnCGroupPath
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
operator|!
name|stopped
condition|)
block|{
name|process
operator|=
name|oomListener
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|resetCGroupParameters
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Listener stopped before starting"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Listening on %s with %s"
argument_list|,
name|yarnCGroupPath
argument_list|,
name|oomListenerPath
argument_list|)
argument_list|)
expr_stmt|;
comment|// We need 1 thread for the error stream and a few others
comment|// as a watchdog for the OOM killer
name|executor
operator|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|// Listen to any errors in the background. We do not expect this to
comment|// be large in size, so it will fit into a string.
name|Future
argument_list|<
name|String
argument_list|>
name|errorListener
init|=
name|executor
operator|.
name|submit
argument_list|(
parameter_list|()
lambda|->
name|IOUtils
operator|.
name|toString
argument_list|(
name|process
operator|.
name|getErrorStream
argument_list|()
argument_list|,
name|Charset
operator|.
name|defaultCharset
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// We get Linux event increments (8 bytes) forwarded from the event stream
comment|// The events cannot be split, so it is safe to read them as a whole
comment|// There is no race condition with the cgroup
comment|// running out of memory. If oom is 1 at startup
comment|// oom_listener will send an initial notification
name|InputStream
name|events
init|=
name|process
operator|.
name|getInputStream
argument_list|()
decl_stmt|;
name|byte
index|[]
name|event
init|=
operator|new
name|byte
index|[
literal|8
index|]
decl_stmt|;
name|int
name|read
decl_stmt|;
comment|// This loop can be exited by terminating the process
comment|// with stopListening()
while|while
condition|(
operator|(
name|read
operator|=
name|events
operator|.
name|read
argument_list|(
name|event
argument_list|)
operator|)
operator|==
name|event
operator|.
name|length
condition|)
block|{
comment|// An OOM event has occurred
name|resolveOOM
argument_list|(
name|executor
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read
operator|!=
operator|-
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Characters returned from event hander: %d"
argument_list|,
name|read
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// If the input stream is closed, we wait for exit or process terminated.
name|int
name|exitCode
init|=
name|process
operator|.
name|waitFor
argument_list|()
decl_stmt|;
name|String
name|error
init|=
name|errorListener
operator|.
name|get
argument_list|()
decl_stmt|;
name|process
operator|=
literal|null
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"OOM listener exited %d %s"
argument_list|,
name|exitCode
argument_list|,
name|error
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|OOMNotResolvedException
name|ex
parameter_list|)
block|{
comment|// We could mark the node unhealthy but it shuts down the node anyways.
comment|// Let's just bring down the node manager all containers are frozen.
throw|throw
operator|new
name|YarnRuntimeException
argument_list|(
literal|"Could not resolve OOM"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
operator|!
name|stopped
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"OOM Listener exiting."
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
comment|// Make sure we do not leak the child process,
comment|// especially if process.waitFor() did not finish.
if|if
condition|(
name|process
operator|!=
literal|null
operator|&&
name|process
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|process
operator|.
name|destroyForcibly
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|executor
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|executor
operator|.
name|awaitTermination
argument_list|(
literal|6
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exiting without processing all OOM events."
argument_list|)
expr_stmt|;
block|}
name|executor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
name|resetCGroupParameters
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Resolve an OOM event.    * Listen to the handler timeouts.    * @param executor Executor to create watchdog with.    * @throws InterruptedException interrupted    * @throws java.util.concurrent.ExecutionException cannot launch watchdog    */
DECL|method|resolveOOM (ExecutorService executor)
specifier|private
name|void
name|resolveOOM
parameter_list|(
name|ExecutorService
name|executor
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
block|{
comment|// Just log, when we are still in OOM after a couple of seconds
specifier|final
name|long
name|start
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|Future
argument_list|<
name|Boolean
argument_list|>
name|watchdog
init|=
name|executor
operator|.
name|submit
argument_list|(
parameter_list|()
lambda|->
name|watchAndLogOOMState
argument_list|(
name|start
argument_list|)
argument_list|)
decl_stmt|;
comment|// Kill something to resolve the issue
try|try
block|{
name|oomHandler
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|ex
parameter_list|)
block|{
name|watchdog
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|OOMNotResolvedException
argument_list|(
literal|"OOM handler failed"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|watchdog
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// If we are still in OOM,
comment|// the watchdog will trigger stop
comment|// listening to exit this loop
throw|throw
operator|new
name|OOMNotResolvedException
argument_list|(
literal|"OOM handler timed out"
argument_list|,
literal|null
argument_list|)
throw|;
block|}
block|}
comment|/**    * Just watch until we are in OOM and log. Send an update log every second.    * @return if the OOM was resolved successfully    */
DECL|method|watchAndLogOOMState (long start)
specifier|private
name|boolean
name|watchAndLogOOMState
parameter_list|(
name|long
name|start
parameter_list|)
block|{
name|long
name|lastLog
init|=
name|start
decl_stmt|;
try|try
block|{
name|long
name|end
init|=
name|start
decl_stmt|;
comment|// Throw an error, if we are still in OOM after 5 seconds
while|while
condition|(
name|end
operator|-
name|start
operator|<
name|timeoutMS
condition|)
block|{
name|end
operator|=
name|clock
operator|.
name|getTime
argument_list|()
expr_stmt|;
name|String
name|underOOM
init|=
name|cgroups
operator|.
name|getCGroupParam
argument_list|(
name|CGroupsHandler
operator|.
name|CGroupController
operator|.
name|MEMORY
argument_list|,
literal|""
argument_list|,
name|CGROUP_PARAM_MEMORY_OOM_CONTROL
argument_list|)
decl_stmt|;
if|if
condition|(
name|underOOM
operator|.
name|contains
argument_list|(
name|CGroupsHandler
operator|.
name|UNDER_OOM
argument_list|)
condition|)
block|{
if|if
condition|(
name|end
operator|-
name|lastLog
operator|>
literal|1000
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"OOM not resolved in %d ms"
argument_list|,
name|end
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|lastLog
operator|=
name|end
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Resolved OOM in %d ms"
argument_list|,
name|end
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// We do not want to saturate the CPU
comment|// leaving the resources to the actual OOM killer
comment|// but we want to be fast, too.
name|Thread
operator|.
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Watchdog interrupted"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception running logging thread"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"OOM was not resolved in %d ms"
argument_list|,
name|clock
operator|.
name|getTime
argument_list|()
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|stopListening
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|/**    * Update root memory cgroup. This contains all containers.    * The physical limit has to be set first then the virtual limit.    */
DECL|method|setCGroupParameters ()
specifier|private
name|void
name|setCGroupParameters
parameter_list|()
throws|throws
name|ResourceHandlerException
block|{
comment|// Disable the OOM killer
name|cgroups
operator|.
name|updateCGroupParam
argument_list|(
name|CGroupsHandler
operator|.
name|CGroupController
operator|.
name|MEMORY
argument_list|,
literal|""
argument_list|,
name|CGROUP_PARAM_MEMORY_OOM_CONTROL
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|controlPhysicalMemory
operator|&&
operator|!
name|controlVirtualMemory
condition|)
block|{
try|try
block|{
comment|// Ignore virtual memory limits, since we do not know what it is set to
name|cgroups
operator|.
name|updateCGroupParam
argument_list|(
name|CGroupsHandler
operator|.
name|CGroupController
operator|.
name|MEMORY
argument_list|,
literal|""
argument_list|,
name|CGROUP_PARAM_MEMORY_SWAP_HARD_LIMIT_BYTES
argument_list|,
name|CGROUP_NO_LIMIT
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ResourceHandlerException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Swap monitoring is turned off in the kernel"
argument_list|)
expr_stmt|;
block|}
comment|// Set physical memory limits
name|cgroups
operator|.
name|updateCGroupParam
argument_list|(
name|CGroupsHandler
operator|.
name|CGroupController
operator|.
name|MEMORY
argument_list|,
literal|""
argument_list|,
name|CGROUP_PARAM_MEMORY_HARD_LIMIT_BYTES
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|limit
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|controlVirtualMemory
operator|&&
operator|!
name|controlPhysicalMemory
condition|)
block|{
comment|// Ignore virtual memory limits, since we do not know what it is set to
name|cgroups
operator|.
name|updateCGroupParam
argument_list|(
name|CGroupsHandler
operator|.
name|CGroupController
operator|.
name|MEMORY
argument_list|,
literal|""
argument_list|,
name|CGROUP_PARAM_MEMORY_SWAP_HARD_LIMIT_BYTES
argument_list|,
name|CGROUP_NO_LIMIT
argument_list|)
expr_stmt|;
comment|// Set physical limits to no more than virtual limits
name|cgroups
operator|.
name|updateCGroupParam
argument_list|(
name|CGroupsHandler
operator|.
name|CGroupController
operator|.
name|MEMORY
argument_list|,
literal|""
argument_list|,
name|CGROUP_PARAM_MEMORY_HARD_LIMIT_BYTES
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|limit
argument_list|)
argument_list|)
expr_stmt|;
comment|// Set virtual memory limits
comment|// Important: it has to be set after physical limit is set
name|cgroups
operator|.
name|updateCGroupParam
argument_list|(
name|CGroupsHandler
operator|.
name|CGroupController
operator|.
name|MEMORY
argument_list|,
literal|""
argument_list|,
name|CGROUP_PARAM_MEMORY_SWAP_HARD_LIMIT_BYTES
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|limit
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|ResourceHandlerException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unsupported scenario physical:%b virtual:%b"
argument_list|,
name|controlPhysicalMemory
argument_list|,
name|controlVirtualMemory
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|/**    * Reset root memory cgroup to OS defaults. This controls all containers.    */
DECL|method|resetCGroupParameters ()
specifier|private
name|void
name|resetCGroupParameters
parameter_list|()
block|{
try|try
block|{
try|try
block|{
comment|// Disable memory limits
name|cgroups
operator|.
name|updateCGroupParam
argument_list|(
name|CGroupsHandler
operator|.
name|CGroupController
operator|.
name|MEMORY
argument_list|,
literal|""
argument_list|,
name|CGROUP_PARAM_MEMORY_SWAP_HARD_LIMIT_BYTES
argument_list|,
name|CGROUP_NO_LIMIT
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ResourceHandlerException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Swap monitoring is turned off in the kernel"
argument_list|)
expr_stmt|;
block|}
name|cgroups
operator|.
name|updateCGroupParam
argument_list|(
name|CGroupsHandler
operator|.
name|CGroupController
operator|.
name|MEMORY
argument_list|,
literal|""
argument_list|,
name|CGROUP_PARAM_MEMORY_HARD_LIMIT_BYTES
argument_list|,
name|CGROUP_NO_LIMIT
argument_list|)
expr_stmt|;
comment|// Enable the OOM killer
name|cgroups
operator|.
name|updateCGroupParam
argument_list|(
name|CGroupsHandler
operator|.
name|CGroupController
operator|.
name|MEMORY
argument_list|,
literal|""
argument_list|,
name|CGROUP_PARAM_MEMORY_OOM_CONTROL
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ResourceHandlerException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error in cleanup"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getOOMListenerExecutablePath (Configuration conf)
specifier|private
specifier|static
name|String
name|getOOMListenerExecutablePath
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|yarnHomeEnvVar
init|=
name|System
operator|.
name|getenv
argument_list|(
name|ApplicationConstants
operator|.
name|Environment
operator|.
name|HADOOP_YARN_HOME
operator|.
name|key
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|yarnHomeEnvVar
operator|==
literal|null
condition|)
block|{
name|yarnHomeEnvVar
operator|=
literal|"."
expr_stmt|;
block|}
name|File
name|hadoopBin
init|=
operator|new
name|File
argument_list|(
name|yarnHomeEnvVar
argument_list|,
literal|"bin"
argument_list|)
decl_stmt|;
name|String
name|defaultPath
init|=
operator|new
name|File
argument_list|(
name|hadoopBin
argument_list|,
literal|"oom-listener"
argument_list|)
operator|.
name|getAbsolutePath
argument_list|()
decl_stmt|;
specifier|final
name|String
name|path
init|=
name|conf
operator|.
name|get
argument_list|(
name|YarnConfiguration
operator|.
name|NM_ELASTIC_MEMORY_CONTROL_OOM_LISTENER_PATH
argument_list|,
name|defaultPath
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"oom-listener path: %s %s"
argument_list|,
name|path
argument_list|,
name|defaultPath
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
block|}
end_class

end_unit

