begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
operator|.
name|ReadLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
operator|.
name|WriteLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|Private
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|nodelabels
operator|.
name|RMNodeLabelsManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|AbstractUsersManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|QueueMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|ResourceUsage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|ResourceCalculator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|Resources
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * {@link UsersManager} tracks users in the system and its respective data  * structures.  */
end_comment

begin_class
annotation|@
name|Private
DECL|class|UsersManager
specifier|public
class|class
name|UsersManager
implements|implements
name|AbstractUsersManager
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|UsersManager
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/*    * Member declaration for UsersManager class.    */
DECL|field|lQueue
specifier|private
specifier|final
name|LeafQueue
name|lQueue
decl_stmt|;
DECL|field|labelManager
specifier|private
specifier|final
name|RMNodeLabelsManager
name|labelManager
decl_stmt|;
DECL|field|resourceCalculator
specifier|private
specifier|final
name|ResourceCalculator
name|resourceCalculator
decl_stmt|;
DECL|field|scheduler
specifier|private
specifier|final
name|CapacitySchedulerContext
name|scheduler
decl_stmt|;
DECL|field|users
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|User
argument_list|>
name|users
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|totalResUsageForActiveUsers
specifier|private
name|ResourceUsage
name|totalResUsageForActiveUsers
init|=
operator|new
name|ResourceUsage
argument_list|()
decl_stmt|;
DECL|field|totalResUsageForNonActiveUsers
specifier|private
name|ResourceUsage
name|totalResUsageForNonActiveUsers
init|=
operator|new
name|ResourceUsage
argument_list|()
decl_stmt|;
DECL|field|activeUsersSet
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|activeUsersSet
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|nonActiveUsersSet
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|nonActiveUsersSet
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// Summation of consumed ratios for all users in queue
DECL|field|qUsageRatios
specifier|private
name|UsageRatios
name|qUsageRatios
decl_stmt|;
comment|// To detect whether there is a change in user count for every user-limit
comment|// calculation.
DECL|field|latestVersionOfUsersState
specifier|private
name|AtomicLong
name|latestVersionOfUsersState
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|localVersionOfActiveUsersState
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|SchedulingMode
argument_list|,
name|Long
argument_list|>
argument_list|>
name|localVersionOfActiveUsersState
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|SchedulingMode
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|localVersionOfAllUsersState
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|SchedulingMode
argument_list|,
name|Long
argument_list|>
argument_list|>
name|localVersionOfAllUsersState
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|SchedulingMode
argument_list|,
name|Long
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|userLimit
specifier|private
specifier|volatile
name|int
name|userLimit
decl_stmt|;
DECL|field|userLimitFactor
specifier|private
specifier|volatile
name|float
name|userLimitFactor
decl_stmt|;
DECL|field|writeLock
specifier|private
name|WriteLock
name|writeLock
decl_stmt|;
DECL|field|readLock
specifier|private
name|ReadLock
name|readLock
decl_stmt|;
DECL|field|metrics
specifier|private
specifier|final
name|QueueMetrics
name|metrics
decl_stmt|;
DECL|field|activeUsers
specifier|private
name|AtomicInteger
name|activeUsers
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|usersApplications
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|ApplicationId
argument_list|>
argument_list|>
name|usersApplications
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|ApplicationId
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// Pre-computed list of user-limits.
DECL|field|preComputedActiveUserLimit
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|SchedulingMode
argument_list|,
name|Resource
argument_list|>
argument_list|>
name|preComputedActiveUserLimit
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|preComputedAllUserLimit
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|SchedulingMode
argument_list|,
name|Resource
argument_list|>
argument_list|>
name|preComputedAllUserLimit
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * UsageRatios will store the total used resources ratio across all users of    * the queue.    */
DECL|class|UsageRatios
specifier|static
specifier|private
class|class
name|UsageRatios
block|{
DECL|field|usageRatios
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|usageRatios
decl_stmt|;
DECL|field|readLock
specifier|private
name|ReadLock
name|readLock
decl_stmt|;
DECL|field|writeLock
specifier|private
name|WriteLock
name|writeLock
decl_stmt|;
DECL|method|UsageRatios ()
specifier|public
name|UsageRatios
parameter_list|()
block|{
name|ReentrantReadWriteLock
name|lock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
name|readLock
operator|=
name|lock
operator|.
name|readLock
argument_list|()
expr_stmt|;
name|writeLock
operator|=
name|lock
operator|.
name|writeLock
argument_list|()
expr_stmt|;
name|usageRatios
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
argument_list|()
expr_stmt|;
block|}
DECL|method|incUsageRatio (String label, float delta)
specifier|private
name|void
name|incUsageRatio
parameter_list|(
name|String
name|label
parameter_list|,
name|float
name|delta
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|float
name|usage
init|=
literal|0f
decl_stmt|;
if|if
condition|(
name|usageRatios
operator|.
name|containsKey
argument_list|(
name|label
argument_list|)
condition|)
block|{
name|usage
operator|=
name|usageRatios
operator|.
name|get
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
name|usage
operator|+=
name|delta
expr_stmt|;
name|usageRatios
operator|.
name|put
argument_list|(
name|label
argument_list|,
name|usage
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getUsageRatio (String label)
specifier|private
name|float
name|getUsageRatio
parameter_list|(
name|String
name|label
parameter_list|)
block|{
try|try
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|Float
name|f
init|=
name|usageRatios
operator|.
name|get
argument_list|(
name|label
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|f
condition|)
block|{
return|return
literal|0.0f
return|;
block|}
return|return
name|f
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|setUsageRatio (String label, float ratio)
specifier|private
name|void
name|setUsageRatio
parameter_list|(
name|String
name|label
parameter_list|,
name|float
name|ratio
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|usageRatios
operator|.
name|put
argument_list|(
name|label
argument_list|,
name|ratio
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/* End of UserRatios class */
comment|/**    * User class stores all user related resource usage, application details.    */
annotation|@
name|VisibleForTesting
DECL|class|User
specifier|public
specifier|static
class|class
name|User
block|{
DECL|field|userResourceUsage
name|ResourceUsage
name|userResourceUsage
init|=
operator|new
name|ResourceUsage
argument_list|()
decl_stmt|;
DECL|field|userName
name|String
name|userName
init|=
literal|null
decl_stmt|;
DECL|field|userResourceLimit
specifier|volatile
name|Resource
name|userResourceLimit
init|=
name|Resource
operator|.
name|newInstance
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
DECL|field|pendingApplications
specifier|private
specifier|volatile
name|AtomicInteger
name|pendingApplications
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|activeApplications
specifier|private
specifier|volatile
name|AtomicInteger
name|activeApplications
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|userUsageRatios
specifier|private
name|UsageRatios
name|userUsageRatios
init|=
operator|new
name|UsageRatios
argument_list|()
decl_stmt|;
DECL|field|writeLock
specifier|private
name|WriteLock
name|writeLock
decl_stmt|;
DECL|method|User (String name)
specifier|public
name|User
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|ReentrantReadWriteLock
name|lock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
comment|// Nobody uses read-lock now, will add it when necessary
name|writeLock
operator|=
name|lock
operator|.
name|writeLock
argument_list|()
expr_stmt|;
name|this
operator|.
name|userName
operator|=
name|name
expr_stmt|;
block|}
DECL|method|getResourceUsage ()
specifier|public
name|ResourceUsage
name|getResourceUsage
parameter_list|()
block|{
return|return
name|userResourceUsage
return|;
block|}
DECL|method|setAndUpdateUsageRatio (ResourceCalculator resourceCalculator, Resource resource, String nodePartition)
specifier|public
name|float
name|setAndUpdateUsageRatio
parameter_list|(
name|ResourceCalculator
name|resourceCalculator
parameter_list|,
name|Resource
name|resource
parameter_list|,
name|String
name|nodePartition
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|userUsageRatios
operator|.
name|setUsageRatio
argument_list|(
name|nodePartition
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|updateUsageRatio
argument_list|(
name|resourceCalculator
argument_list|,
name|resource
argument_list|,
name|nodePartition
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|updateUsageRatio (ResourceCalculator resourceCalculator, Resource resource, String nodePartition)
specifier|public
name|float
name|updateUsageRatio
parameter_list|(
name|ResourceCalculator
name|resourceCalculator
parameter_list|,
name|Resource
name|resource
parameter_list|,
name|String
name|nodePartition
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|float
name|delta
decl_stmt|;
name|float
name|newRatio
init|=
name|Resources
operator|.
name|ratio
argument_list|(
name|resourceCalculator
argument_list|,
name|getUsed
argument_list|(
name|nodePartition
argument_list|)
argument_list|,
name|resource
argument_list|)
decl_stmt|;
name|delta
operator|=
name|newRatio
operator|-
name|userUsageRatios
operator|.
name|getUsageRatio
argument_list|(
name|nodePartition
argument_list|)
expr_stmt|;
name|userUsageRatios
operator|.
name|setUsageRatio
argument_list|(
name|nodePartition
argument_list|,
name|newRatio
argument_list|)
expr_stmt|;
return|return
name|delta
return|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getUsed ()
specifier|public
name|Resource
name|getUsed
parameter_list|()
block|{
return|return
name|userResourceUsage
operator|.
name|getUsed
argument_list|()
return|;
block|}
DECL|method|getAllUsed ()
specifier|public
name|Resource
name|getAllUsed
parameter_list|()
block|{
return|return
name|userResourceUsage
operator|.
name|getAllUsed
argument_list|()
return|;
block|}
DECL|method|getUsed (String label)
specifier|public
name|Resource
name|getUsed
parameter_list|(
name|String
name|label
parameter_list|)
block|{
return|return
name|userResourceUsage
operator|.
name|getUsed
argument_list|(
name|label
argument_list|)
return|;
block|}
DECL|method|getPendingApplications ()
specifier|public
name|int
name|getPendingApplications
parameter_list|()
block|{
return|return
name|pendingApplications
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|getActiveApplications ()
specifier|public
name|int
name|getActiveApplications
parameter_list|()
block|{
return|return
name|activeApplications
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|getConsumedAMResources ()
specifier|public
name|Resource
name|getConsumedAMResources
parameter_list|()
block|{
return|return
name|userResourceUsage
operator|.
name|getAMUsed
argument_list|()
return|;
block|}
DECL|method|getConsumedAMResources (String label)
specifier|public
name|Resource
name|getConsumedAMResources
parameter_list|(
name|String
name|label
parameter_list|)
block|{
return|return
name|userResourceUsage
operator|.
name|getAMUsed
argument_list|(
name|label
argument_list|)
return|;
block|}
DECL|method|getTotalApplications ()
specifier|public
name|int
name|getTotalApplications
parameter_list|()
block|{
return|return
name|getPendingApplications
argument_list|()
operator|+
name|getActiveApplications
argument_list|()
return|;
block|}
DECL|method|submitApplication ()
specifier|public
name|void
name|submitApplication
parameter_list|()
block|{
name|pendingApplications
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
DECL|method|activateApplication ()
specifier|public
name|void
name|activateApplication
parameter_list|()
block|{
name|pendingApplications
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
name|activeApplications
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
DECL|method|finishApplication (boolean wasActive)
specifier|public
name|void
name|finishApplication
parameter_list|(
name|boolean
name|wasActive
parameter_list|)
block|{
if|if
condition|(
name|wasActive
condition|)
block|{
name|activeApplications
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|pendingApplications
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getUserResourceLimit ()
specifier|public
name|Resource
name|getUserResourceLimit
parameter_list|()
block|{
return|return
name|userResourceLimit
return|;
block|}
DECL|method|setUserResourceLimit (Resource userResourceLimit)
specifier|public
name|void
name|setUserResourceLimit
parameter_list|(
name|Resource
name|userResourceLimit
parameter_list|)
block|{
name|this
operator|.
name|userResourceLimit
operator|=
name|userResourceLimit
expr_stmt|;
block|}
DECL|method|getUserName ()
specifier|public
name|String
name|getUserName
parameter_list|()
block|{
return|return
name|this
operator|.
name|userName
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setResourceUsage (ResourceUsage resourceUsage)
specifier|public
name|void
name|setResourceUsage
parameter_list|(
name|ResourceUsage
name|resourceUsage
parameter_list|)
block|{
name|this
operator|.
name|userResourceUsage
operator|=
name|resourceUsage
expr_stmt|;
block|}
block|}
comment|/* End of User class */
comment|/**    * UsersManager Constructor.    *    * @param metrics    *          Queue Metrics    * @param lQueue    *          Leaf Queue Object    * @param labelManager    *          Label Manager instance    * @param scheduler    *          Capacity Scheduler Context    * @param resourceCalculator    *          rc    */
DECL|method|UsersManager (QueueMetrics metrics, LeafQueue lQueue, RMNodeLabelsManager labelManager, CapacitySchedulerContext scheduler, ResourceCalculator resourceCalculator)
specifier|public
name|UsersManager
parameter_list|(
name|QueueMetrics
name|metrics
parameter_list|,
name|LeafQueue
name|lQueue
parameter_list|,
name|RMNodeLabelsManager
name|labelManager
parameter_list|,
name|CapacitySchedulerContext
name|scheduler
parameter_list|,
name|ResourceCalculator
name|resourceCalculator
parameter_list|)
block|{
name|ReentrantReadWriteLock
name|lock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
name|this
operator|.
name|lQueue
operator|=
name|lQueue
expr_stmt|;
name|this
operator|.
name|scheduler
operator|=
name|scheduler
expr_stmt|;
name|this
operator|.
name|labelManager
operator|=
name|labelManager
expr_stmt|;
name|this
operator|.
name|resourceCalculator
operator|=
name|resourceCalculator
expr_stmt|;
name|this
operator|.
name|qUsageRatios
operator|=
operator|new
name|UsageRatios
argument_list|()
expr_stmt|;
name|this
operator|.
name|metrics
operator|=
name|metrics
expr_stmt|;
name|this
operator|.
name|writeLock
operator|=
name|lock
operator|.
name|writeLock
argument_list|()
expr_stmt|;
name|this
operator|.
name|readLock
operator|=
name|lock
operator|.
name|readLock
argument_list|()
expr_stmt|;
block|}
comment|/**    * Get configured user-limit.    * @return user limit    */
DECL|method|getUserLimit ()
specifier|public
name|int
name|getUserLimit
parameter_list|()
block|{
return|return
name|userLimit
return|;
block|}
comment|/**    * Set configured user-limit.    * @param userLimit user limit    */
DECL|method|setUserLimit (int userLimit)
specifier|public
name|void
name|setUserLimit
parameter_list|(
name|int
name|userLimit
parameter_list|)
block|{
name|this
operator|.
name|userLimit
operator|=
name|userLimit
expr_stmt|;
block|}
comment|/**    * Get configured user-limit factor.    * @return user-limit factor    */
DECL|method|getUserLimitFactor ()
specifier|public
name|float
name|getUserLimitFactor
parameter_list|()
block|{
return|return
name|userLimitFactor
return|;
block|}
comment|/**    * Set configured user-limit factor.    * @param userLimitFactor User Limit factor.    */
DECL|method|setUserLimitFactor (float userLimitFactor)
specifier|public
name|void
name|setUserLimitFactor
parameter_list|(
name|float
name|userLimitFactor
parameter_list|)
block|{
name|this
operator|.
name|userLimitFactor
operator|=
name|userLimitFactor
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getUsageRatio (String label)
specifier|public
name|float
name|getUsageRatio
parameter_list|(
name|String
name|label
parameter_list|)
block|{
return|return
name|qUsageRatios
operator|.
name|getUsageRatio
argument_list|(
name|label
argument_list|)
return|;
block|}
comment|/**    * Force UsersManager to recompute userlimit.    */
DECL|method|userLimitNeedsRecompute ()
specifier|public
name|void
name|userLimitNeedsRecompute
parameter_list|()
block|{
comment|// If latestVersionOfUsersState is negative due to overflow, ideally we need
comment|// to reset it. This method is invoked from UsersManager and LeafQueue and
comment|// all is happening within write/readLock. Below logic can help to set 0.
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|long
name|value
init|=
name|latestVersionOfUsersState
operator|.
name|incrementAndGet
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
name|latestVersionOfUsersState
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * Get all users of queue.    */
DECL|method|getUsers ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|User
argument_list|>
name|getUsers
parameter_list|()
block|{
return|return
name|users
return|;
block|}
comment|/**    * Get user object for given user name.    *    * @param userName    *          User Name    * @return User object    */
DECL|method|getUser (String userName)
specifier|public
name|User
name|getUser
parameter_list|(
name|String
name|userName
parameter_list|)
block|{
return|return
name|users
operator|.
name|get
argument_list|(
name|userName
argument_list|)
return|;
block|}
comment|/**    * Remove user.    *    * @param userName    *          User Name    */
DECL|method|removeUser (String userName)
specifier|public
name|void
name|removeUser
parameter_list|(
name|String
name|userName
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|this
operator|.
name|users
operator|.
name|remove
argument_list|(
name|userName
argument_list|)
expr_stmt|;
comment|// Remove user from active/non-active list as well.
name|activeUsersSet
operator|.
name|remove
argument_list|(
name|userName
argument_list|)
expr_stmt|;
name|nonActiveUsersSet
operator|.
name|remove
argument_list|(
name|userName
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get and add user if absent.    *    * @param userName    *          User Name    * @return User object    */
DECL|method|getUserAndAddIfAbsent (String userName)
specifier|public
name|User
name|getUserAndAddIfAbsent
parameter_list|(
name|String
name|userName
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|User
name|u
init|=
name|getUser
argument_list|(
name|userName
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|u
condition|)
block|{
name|u
operator|=
operator|new
name|User
argument_list|(
name|userName
argument_list|)
expr_stmt|;
name|addUser
argument_list|(
name|userName
argument_list|,
name|u
argument_list|)
expr_stmt|;
comment|// Add to nonActive list so that resourceUsage could be tracked
if|if
condition|(
operator|!
name|nonActiveUsersSet
operator|.
name|contains
argument_list|(
name|userName
argument_list|)
condition|)
block|{
name|nonActiveUsersSet
operator|.
name|add
argument_list|(
name|userName
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|u
return|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * Add a new user    */
DECL|method|addUser (String userName, User user)
specifier|private
name|void
name|addUser
parameter_list|(
name|String
name|userName
parameter_list|,
name|User
name|user
parameter_list|)
block|{
name|this
operator|.
name|users
operator|.
name|put
argument_list|(
name|userName
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return an ArrayList of UserInfo objects who are active in this queue    */
DECL|method|getUsersInfo ()
specifier|public
name|ArrayList
argument_list|<
name|UserInfo
argument_list|>
name|getUsersInfo
parameter_list|()
block|{
try|try
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|ArrayList
argument_list|<
name|UserInfo
argument_list|>
name|usersToReturn
init|=
operator|new
name|ArrayList
argument_list|<
name|UserInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|User
argument_list|>
name|entry
range|:
name|getUsers
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|User
name|user
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|usersToReturn
operator|.
name|add
argument_list|(
operator|new
name|UserInfo
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|Resources
operator|.
name|clone
argument_list|(
name|user
operator|.
name|getAllUsed
argument_list|()
argument_list|)
argument_list|,
name|user
operator|.
name|getActiveApplications
argument_list|()
argument_list|,
name|user
operator|.
name|getPendingApplications
argument_list|()
argument_list|,
name|Resources
operator|.
name|clone
argument_list|(
name|user
operator|.
name|getConsumedAMResources
argument_list|()
argument_list|)
argument_list|,
name|Resources
operator|.
name|clone
argument_list|(
name|user
operator|.
name|getUserResourceLimit
argument_list|()
argument_list|)
argument_list|,
name|user
operator|.
name|getResourceUsage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|usersToReturn
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Get computed user-limit for all ACTIVE users in this queue. If cached data    * is invalidated due to resource change, this method also enforce to    * recompute user-limit.    *    * @param userName    *          Name of user who has submitted one/more app to given queue.    * @param clusterResource    *          total cluster resource    * @param nodePartition    *          partition name    * @param schedulingMode    *          scheduling mode    *          RESPECT_PARTITION_EXCLUSIVITY/IGNORE_PARTITION_EXCLUSIVITY    * @return Computed User Limit    */
DECL|method|getComputedResourceLimitForActiveUsers (String userName, Resource clusterResource, String nodePartition, SchedulingMode schedulingMode)
specifier|public
name|Resource
name|getComputedResourceLimitForActiveUsers
parameter_list|(
name|String
name|userName
parameter_list|,
name|Resource
name|clusterResource
parameter_list|,
name|String
name|nodePartition
parameter_list|,
name|SchedulingMode
name|schedulingMode
parameter_list|)
block|{
name|Map
argument_list|<
name|SchedulingMode
argument_list|,
name|Resource
argument_list|>
name|userLimitPerSchedulingMode
init|=
name|preComputedActiveUserLimit
operator|.
name|get
argument_list|(
name|nodePartition
argument_list|)
decl_stmt|;
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|isRecomputeNeeded
argument_list|(
name|schedulingMode
argument_list|,
name|nodePartition
argument_list|,
literal|true
argument_list|)
condition|)
block|{
comment|// recompute
name|userLimitPerSchedulingMode
operator|=
name|reComputeUserLimits
argument_list|(
name|userName
argument_list|,
name|nodePartition
argument_list|,
name|clusterResource
argument_list|,
name|schedulingMode
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// update user count to cache so that we can avoid recompute if no major
comment|// changes.
name|setLocalVersionOfUsersState
argument_list|(
name|nodePartition
argument_list|,
name|schedulingMode
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"userLimit is fetched. userLimit = "
operator|+
name|userLimitPerSchedulingMode
operator|.
name|get
argument_list|(
name|schedulingMode
argument_list|)
operator|+
literal|", schedulingMode="
operator|+
name|schedulingMode
operator|+
literal|", partition="
operator|+
name|nodePartition
argument_list|)
expr_stmt|;
block|}
return|return
name|userLimitPerSchedulingMode
operator|.
name|get
argument_list|(
name|schedulingMode
argument_list|)
return|;
block|}
comment|/**    * Get computed user-limit for all users in this queue. If cached data is    * invalidated due to resource change, this method also enforce to recompute    * user-limit.    *    * @param userName    *          Name of user who has submitted one/more app to given queue.    * @param clusterResource    *          total cluster resource    * @param nodePartition    *          partition name    * @param schedulingMode    *          scheduling mode    *          RESPECT_PARTITION_EXCLUSIVITY/IGNORE_PARTITION_EXCLUSIVITY    * @return Computed User Limit    */
DECL|method|getComputedResourceLimitForAllUsers (String userName, Resource clusterResource, String nodePartition, SchedulingMode schedulingMode)
specifier|public
name|Resource
name|getComputedResourceLimitForAllUsers
parameter_list|(
name|String
name|userName
parameter_list|,
name|Resource
name|clusterResource
parameter_list|,
name|String
name|nodePartition
parameter_list|,
name|SchedulingMode
name|schedulingMode
parameter_list|)
block|{
name|Map
argument_list|<
name|SchedulingMode
argument_list|,
name|Resource
argument_list|>
name|userLimitPerSchedulingMode
init|=
name|preComputedAllUserLimit
operator|.
name|get
argument_list|(
name|nodePartition
argument_list|)
decl_stmt|;
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|isRecomputeNeeded
argument_list|(
name|schedulingMode
argument_list|,
name|nodePartition
argument_list|,
literal|false
argument_list|)
condition|)
block|{
comment|// recompute
name|userLimitPerSchedulingMode
operator|=
name|reComputeUserLimits
argument_list|(
name|userName
argument_list|,
name|nodePartition
argument_list|,
name|clusterResource
argument_list|,
name|schedulingMode
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// update user count to cache so that we can avoid recompute if no major
comment|// changes.
name|setLocalVersionOfUsersState
argument_list|(
name|nodePartition
argument_list|,
name|schedulingMode
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"userLimit is fetched. userLimit = "
operator|+
name|userLimitPerSchedulingMode
operator|.
name|get
argument_list|(
name|schedulingMode
argument_list|)
operator|+
literal|", schedulingMode="
operator|+
name|schedulingMode
operator|+
literal|", partition="
operator|+
name|nodePartition
argument_list|)
expr_stmt|;
block|}
return|return
name|userLimitPerSchedulingMode
operator|.
name|get
argument_list|(
name|schedulingMode
argument_list|)
return|;
block|}
comment|/*    * Recompute user-limit under following conditions: 1. cached user-limit does    * not exist in local map. 2. Total User count doesn't match with local cached    * version.    */
DECL|method|isRecomputeNeeded (SchedulingMode schedulingMode, String nodePartition, boolean isActive)
specifier|private
name|boolean
name|isRecomputeNeeded
parameter_list|(
name|SchedulingMode
name|schedulingMode
parameter_list|,
name|String
name|nodePartition
parameter_list|,
name|boolean
name|isActive
parameter_list|)
block|{
return|return
operator|(
name|getLocalVersionOfUsersState
argument_list|(
name|nodePartition
argument_list|,
name|schedulingMode
argument_list|,
name|isActive
argument_list|)
operator|!=
name|latestVersionOfUsersState
operator|.
name|get
argument_list|()
operator|)
return|;
block|}
comment|/*    * Set Local version of user count per label to invalidate cache if needed.    */
DECL|method|setLocalVersionOfUsersState (String nodePartition, SchedulingMode schedulingMode, boolean isActive)
specifier|private
name|void
name|setLocalVersionOfUsersState
parameter_list|(
name|String
name|nodePartition
parameter_list|,
name|SchedulingMode
name|schedulingMode
parameter_list|,
name|boolean
name|isActive
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|SchedulingMode
argument_list|,
name|Long
argument_list|>
argument_list|>
name|localVersionOfUsersState
init|=
operator|(
name|isActive
operator|)
condition|?
name|localVersionOfActiveUsersState
else|:
name|localVersionOfAllUsersState
decl_stmt|;
name|Map
argument_list|<
name|SchedulingMode
argument_list|,
name|Long
argument_list|>
name|localVersion
init|=
name|localVersionOfUsersState
operator|.
name|get
argument_list|(
name|nodePartition
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|localVersion
condition|)
block|{
name|localVersion
operator|=
operator|new
name|HashMap
argument_list|<
name|SchedulingMode
argument_list|,
name|Long
argument_list|>
argument_list|()
expr_stmt|;
name|localVersionOfUsersState
operator|.
name|put
argument_list|(
name|nodePartition
argument_list|,
name|localVersion
argument_list|)
expr_stmt|;
block|}
name|localVersion
operator|.
name|put
argument_list|(
name|schedulingMode
argument_list|,
name|latestVersionOfUsersState
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * Get Local version of user count per label to invalidate cache if needed.    */
DECL|method|getLocalVersionOfUsersState (String nodePartition, SchedulingMode schedulingMode, boolean isActive)
specifier|private
name|long
name|getLocalVersionOfUsersState
parameter_list|(
name|String
name|nodePartition
parameter_list|,
name|SchedulingMode
name|schedulingMode
parameter_list|,
name|boolean
name|isActive
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|SchedulingMode
argument_list|,
name|Long
argument_list|>
argument_list|>
name|localVersionOfUsersState
init|=
operator|(
name|isActive
operator|)
condition|?
name|localVersionOfActiveUsersState
else|:
name|localVersionOfAllUsersState
decl_stmt|;
if|if
condition|(
operator|!
name|localVersionOfUsersState
operator|.
name|containsKey
argument_list|(
name|nodePartition
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|Map
argument_list|<
name|SchedulingMode
argument_list|,
name|Long
argument_list|>
name|localVersion
init|=
name|localVersionOfUsersState
operator|.
name|get
argument_list|(
name|nodePartition
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|localVersion
operator|.
name|containsKey
argument_list|(
name|schedulingMode
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|localVersion
operator|.
name|get
argument_list|(
name|schedulingMode
argument_list|)
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|reComputeUserLimits (String userName, String nodePartition, Resource clusterResource, SchedulingMode schedulingMode, boolean activeMode)
specifier|private
name|Map
argument_list|<
name|SchedulingMode
argument_list|,
name|Resource
argument_list|>
name|reComputeUserLimits
parameter_list|(
name|String
name|userName
parameter_list|,
name|String
name|nodePartition
parameter_list|,
name|Resource
name|clusterResource
parameter_list|,
name|SchedulingMode
name|schedulingMode
parameter_list|,
name|boolean
name|activeMode
parameter_list|)
block|{
comment|// preselect stored map as per active user-limit or all user computation.
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|SchedulingMode
argument_list|,
name|Resource
argument_list|>
argument_list|>
name|computedMap
init|=
literal|null
decl_stmt|;
name|computedMap
operator|=
operator|(
name|activeMode
operator|)
condition|?
name|preComputedActiveUserLimit
else|:
name|preComputedAllUserLimit
expr_stmt|;
name|Map
argument_list|<
name|SchedulingMode
argument_list|,
name|Resource
argument_list|>
name|userLimitPerSchedulingMode
init|=
name|computedMap
operator|.
name|get
argument_list|(
name|nodePartition
argument_list|)
decl_stmt|;
if|if
condition|(
name|userLimitPerSchedulingMode
operator|==
literal|null
condition|)
block|{
name|userLimitPerSchedulingMode
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|computedMap
operator|.
name|put
argument_list|(
name|nodePartition
argument_list|,
name|userLimitPerSchedulingMode
argument_list|)
expr_stmt|;
block|}
comment|// compute user-limit per scheduling mode.
name|Resource
name|computedUserLimit
init|=
name|computeUserLimit
argument_list|(
name|userName
argument_list|,
name|clusterResource
argument_list|,
name|nodePartition
argument_list|,
name|schedulingMode
argument_list|,
name|activeMode
argument_list|)
decl_stmt|;
comment|// update in local storage
name|userLimitPerSchedulingMode
operator|.
name|put
argument_list|(
name|schedulingMode
argument_list|,
name|computedUserLimit
argument_list|)
expr_stmt|;
return|return
name|userLimitPerSchedulingMode
return|;
block|}
DECL|method|computeUserLimit (String userName, Resource clusterResource, String nodePartition, SchedulingMode schedulingMode, boolean activeUser)
specifier|private
name|Resource
name|computeUserLimit
parameter_list|(
name|String
name|userName
parameter_list|,
name|Resource
name|clusterResource
parameter_list|,
name|String
name|nodePartition
parameter_list|,
name|SchedulingMode
name|schedulingMode
parameter_list|,
name|boolean
name|activeUser
parameter_list|)
block|{
name|Resource
name|partitionResource
init|=
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|nodePartition
argument_list|,
name|clusterResource
argument_list|)
decl_stmt|;
comment|/*      * What is our current capacity?      * * It is equal to the max(required, queue-capacity) if we're running      * below capacity. The 'max' ensures that jobs in queues with miniscule      * capacity (< 1 slot) make progress      * * If we're running over capacity, then its (usedResources + required)      * (which extra resources we are allocating)      */
name|Resource
name|queueCapacity
init|=
name|Resources
operator|.
name|multiplyAndNormalizeUp
argument_list|(
name|resourceCalculator
argument_list|,
name|partitionResource
argument_list|,
name|lQueue
operator|.
name|getQueueCapacities
argument_list|()
operator|.
name|getAbsoluteCapacity
argument_list|(
name|nodePartition
argument_list|)
argument_list|,
name|lQueue
operator|.
name|getMinimumAllocation
argument_list|()
argument_list|)
decl_stmt|;
comment|/*      * Assume we have required resource equals to minimumAllocation, this can      * make sure user limit can continuously increase till queueMaxResource      * reached.      */
name|Resource
name|required
init|=
name|lQueue
operator|.
name|getMinimumAllocation
argument_list|()
decl_stmt|;
comment|// Allow progress for queues with miniscule capacity
name|queueCapacity
operator|=
name|Resources
operator|.
name|max
argument_list|(
name|resourceCalculator
argument_list|,
name|partitionResource
argument_list|,
name|queueCapacity
argument_list|,
name|required
argument_list|)
expr_stmt|;
comment|/*      * We want to base the userLimit calculation on max(queueCapacity,      * usedResources+required). However, we want usedResources to be based on      * the combined ratios of all the users in the queue so we use consumedRatio      * to calculate such. The calculation is dependent on how the      * resourceCalculator calculates the ratio between two Resources. DRF      * Example: If usedResources is greater than queueCapacity and users have      * the following [mem,cpu] usages: User1: [10%,20%] - Dominant resource is      * 20% User2: [30%,10%] - Dominant resource is 30% Then total consumedRatio      * is then 20+30=50%. Yes, this value can be larger than 100% but for the      * purposes of making sure all users are getting their fair share, it works.      */
name|Resource
name|consumed
init|=
name|Resources
operator|.
name|multiplyAndNormalizeUp
argument_list|(
name|resourceCalculator
argument_list|,
name|partitionResource
argument_list|,
name|getUsageRatio
argument_list|(
name|nodePartition
argument_list|)
argument_list|,
name|lQueue
operator|.
name|getMinimumAllocation
argument_list|()
argument_list|)
decl_stmt|;
name|Resource
name|currentCapacity
init|=
name|Resources
operator|.
name|lessThan
argument_list|(
name|resourceCalculator
argument_list|,
name|partitionResource
argument_list|,
name|consumed
argument_list|,
name|queueCapacity
argument_list|)
condition|?
name|queueCapacity
else|:
name|Resources
operator|.
name|add
argument_list|(
name|consumed
argument_list|,
name|required
argument_list|)
decl_stmt|;
comment|/*      * Never allow a single user to take more than the queue's configured      * capacity * user-limit-factor. Also, the queue's configured capacity      * should be higher than queue-hard-limit * ulMin      */
name|int
name|usersCount
init|=
name|getNumActiveUsers
argument_list|()
decl_stmt|;
name|Resource
name|resourceUsed
init|=
name|totalResUsageForActiveUsers
operator|.
name|getUsed
argument_list|(
name|nodePartition
argument_list|)
decl_stmt|;
comment|// For non-activeUser calculation, consider all users count.
if|if
condition|(
operator|!
name|activeUser
condition|)
block|{
name|resourceUsed
operator|=
name|currentCapacity
expr_stmt|;
name|usersCount
operator|=
name|users
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
comment|/*      * User limit resource is determined by: max{currentCapacity / #activeUsers,      * currentCapacity * user-limit-percentage%)      */
name|Resource
name|userLimitResource
init|=
name|Resources
operator|.
name|max
argument_list|(
name|resourceCalculator
argument_list|,
name|partitionResource
argument_list|,
name|Resources
operator|.
name|divideAndCeil
argument_list|(
name|resourceCalculator
argument_list|,
name|resourceUsed
argument_list|,
name|usersCount
argument_list|)
argument_list|,
name|Resources
operator|.
name|divideAndCeil
argument_list|(
name|resourceCalculator
argument_list|,
name|Resources
operator|.
name|multiplyAndRoundDown
argument_list|(
name|currentCapacity
argument_list|,
name|getUserLimit
argument_list|()
argument_list|)
argument_list|,
literal|100
argument_list|)
argument_list|)
decl_stmt|;
comment|// User limit is capped by maxUserLimit
comment|// - maxUserLimit = queueCapacity * user-limit-factor
comment|// (RESPECT_PARTITION_EXCLUSIVITY)
comment|// - maxUserLimit = total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)
comment|//
comment|// In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a
comment|// partition, its guaranteed resource on that partition is 0. And
comment|// user-limit-factor computation is based on queue's guaranteed capacity. So
comment|// we will not cap user-limit as well as used resource when doing
comment|// IGNORE_PARTITION_EXCLUSIVITY allocation.
name|Resource
name|maxUserLimit
init|=
name|Resources
operator|.
name|none
argument_list|()
decl_stmt|;
if|if
condition|(
name|schedulingMode
operator|==
name|SchedulingMode
operator|.
name|RESPECT_PARTITION_EXCLUSIVITY
condition|)
block|{
name|maxUserLimit
operator|=
name|Resources
operator|.
name|multiplyAndRoundDown
argument_list|(
name|queueCapacity
argument_list|,
name|getUserLimitFactor
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|schedulingMode
operator|==
name|SchedulingMode
operator|.
name|IGNORE_PARTITION_EXCLUSIVITY
condition|)
block|{
name|maxUserLimit
operator|=
name|partitionResource
expr_stmt|;
block|}
comment|// Cap final user limit with maxUserLimit
name|userLimitResource
operator|=
name|Resources
operator|.
name|roundUp
argument_list|(
name|resourceCalculator
argument_list|,
name|Resources
operator|.
name|min
argument_list|(
name|resourceCalculator
argument_list|,
name|partitionResource
argument_list|,
name|userLimitResource
argument_list|,
name|maxUserLimit
argument_list|)
argument_list|,
name|lQueue
operator|.
name|getMinimumAllocation
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"User limit computation for "
operator|+
name|userName
operator|+
literal|" in queue "
operator|+
name|lQueue
operator|.
name|getQueueName
argument_list|()
operator|+
literal|" userLimitPercent="
operator|+
name|lQueue
operator|.
name|getUserLimit
argument_list|()
operator|+
literal|" userLimitFactor="
operator|+
name|lQueue
operator|.
name|getUserLimitFactor
argument_list|()
operator|+
literal|" required: "
operator|+
name|required
operator|+
literal|" consumed: "
operator|+
name|consumed
operator|+
literal|" user-limit-resource: "
operator|+
name|userLimitResource
operator|+
literal|" queueCapacity: "
operator|+
name|queueCapacity
operator|+
literal|" qconsumed: "
operator|+
name|lQueue
operator|.
name|getQueueResourceUsage
argument_list|()
operator|.
name|getUsed
argument_list|()
operator|+
literal|" currentCapacity: "
operator|+
name|currentCapacity
operator|+
literal|" activeUsers: "
operator|+
name|usersCount
operator|+
literal|" clusterCapacity: "
operator|+
name|clusterResource
operator|+
literal|" resourceByLabel: "
operator|+
name|partitionResource
operator|+
literal|" usageratio: "
operator|+
name|getUsageRatio
argument_list|(
name|nodePartition
argument_list|)
operator|+
literal|" Partition: "
operator|+
name|nodePartition
argument_list|)
expr_stmt|;
block|}
name|getUser
argument_list|(
name|userName
argument_list|)
operator|.
name|setUserResourceLimit
argument_list|(
name|userLimitResource
argument_list|)
expr_stmt|;
return|return
name|userLimitResource
return|;
block|}
comment|/**    * Update new usage ratio.    *    * @param partition    *          Node partition    * @param clusterResource    *          Cluster Resource    */
DECL|method|updateUsageRatio (String partition, Resource clusterResource)
specifier|public
name|void
name|updateUsageRatio
parameter_list|(
name|String
name|partition
parameter_list|,
name|Resource
name|clusterResource
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|Resource
name|resourceByLabel
init|=
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|partition
argument_list|,
name|clusterResource
argument_list|)
decl_stmt|;
name|float
name|consumed
init|=
literal|0
decl_stmt|;
name|User
name|user
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|User
argument_list|>
name|entry
range|:
name|getUsers
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|user
operator|=
name|entry
operator|.
name|getValue
argument_list|()
expr_stmt|;
name|consumed
operator|+=
name|user
operator|.
name|setAndUpdateUsageRatio
argument_list|(
name|resourceCalculator
argument_list|,
name|resourceByLabel
argument_list|,
name|partition
argument_list|)
expr_stmt|;
block|}
name|qUsageRatios
operator|.
name|setUsageRatio
argument_list|(
name|partition
argument_list|,
name|consumed
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*    * Increment Queue Usage Ratio.    */
DECL|method|incQueueUsageRatio (String nodePartition, float delta)
specifier|private
name|void
name|incQueueUsageRatio
parameter_list|(
name|String
name|nodePartition
parameter_list|,
name|float
name|delta
parameter_list|)
block|{
name|qUsageRatios
operator|.
name|incUsageRatio
argument_list|(
name|nodePartition
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|activateApplication (String user, ApplicationId applicationId)
specifier|public
name|void
name|activateApplication
parameter_list|(
name|String
name|user
parameter_list|,
name|ApplicationId
name|applicationId
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|Set
argument_list|<
name|ApplicationId
argument_list|>
name|userApps
init|=
name|usersApplications
operator|.
name|get
argument_list|(
name|user
argument_list|)
decl_stmt|;
if|if
condition|(
name|userApps
operator|==
literal|null
condition|)
block|{
name|userApps
operator|=
operator|new
name|HashSet
argument_list|<
name|ApplicationId
argument_list|>
argument_list|()
expr_stmt|;
name|usersApplications
operator|.
name|put
argument_list|(
name|user
argument_list|,
name|userApps
argument_list|)
expr_stmt|;
name|activeUsers
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|incrActiveUsers
argument_list|()
expr_stmt|;
comment|// A user is added to active list. Invalidate user-limit cache.
name|userLimitNeedsRecompute
argument_list|()
expr_stmt|;
name|updateActiveUsersResourceUsage
argument_list|(
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"User "
operator|+
name|user
operator|+
literal|" added to activeUsers, currently: "
operator|+
name|activeUsers
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|userApps
operator|.
name|add
argument_list|(
name|applicationId
argument_list|)
condition|)
block|{
name|metrics
operator|.
name|activateApp
argument_list|(
name|user
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|deactivateApplication (String user, ApplicationId applicationId)
specifier|public
name|void
name|deactivateApplication
parameter_list|(
name|String
name|user
parameter_list|,
name|ApplicationId
name|applicationId
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|Set
argument_list|<
name|ApplicationId
argument_list|>
name|userApps
init|=
name|usersApplications
operator|.
name|get
argument_list|(
name|user
argument_list|)
decl_stmt|;
if|if
condition|(
name|userApps
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|userApps
operator|.
name|remove
argument_list|(
name|applicationId
argument_list|)
condition|)
block|{
name|metrics
operator|.
name|deactivateApp
argument_list|(
name|user
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|userApps
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|usersApplications
operator|.
name|remove
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|activeUsers
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|decrActiveUsers
argument_list|()
expr_stmt|;
comment|// A user is removed from active list. Invalidate user-limit cache.
name|userLimitNeedsRecompute
argument_list|()
expr_stmt|;
name|updateNonActiveUsersResourceUsage
argument_list|(
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"User "
operator|+
name|user
operator|+
literal|" removed from activeUsers, currently: "
operator|+
name|activeUsers
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getNumActiveUsers ()
specifier|public
name|int
name|getNumActiveUsers
parameter_list|()
block|{
return|return
name|activeUsers
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|updateActiveUsersResourceUsage (String userName)
specifier|private
name|void
name|updateActiveUsersResourceUsage
parameter_list|(
name|String
name|userName
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// For UT case: We might need to add the user to users list.
name|User
name|user
init|=
name|getUserAndAddIfAbsent
argument_list|(
name|userName
argument_list|)
decl_stmt|;
name|ResourceUsage
name|resourceUsage
init|=
name|user
operator|.
name|getResourceUsage
argument_list|()
decl_stmt|;
comment|// If User is moved to active list, moved resource usage from non-active
comment|// to active list.
if|if
condition|(
name|nonActiveUsersSet
operator|.
name|contains
argument_list|(
name|userName
argument_list|)
condition|)
block|{
name|nonActiveUsersSet
operator|.
name|remove
argument_list|(
name|userName
argument_list|)
expr_stmt|;
name|activeUsersSet
operator|.
name|add
argument_list|(
name|userName
argument_list|)
expr_stmt|;
comment|// Update total resource usage of active and non-active after user
comment|// is moved from non-active to active.
for|for
control|(
name|String
name|partition
range|:
name|resourceUsage
operator|.
name|getNodePartitionsSet
argument_list|()
control|)
block|{
name|totalResUsageForNonActiveUsers
operator|.
name|decUsed
argument_list|(
name|partition
argument_list|,
name|resourceUsage
operator|.
name|getUsed
argument_list|(
name|partition
argument_list|)
argument_list|)
expr_stmt|;
name|totalResUsageForActiveUsers
operator|.
name|incUsed
argument_list|(
name|partition
argument_list|,
name|resourceUsage
operator|.
name|getUsed
argument_list|(
name|partition
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"User '"
operator|+
name|userName
operator|+
literal|"' has become active. Hence move user to active list."
operator|+
literal|"Active users size = "
operator|+
name|activeUsersSet
operator|.
name|size
argument_list|()
operator|+
literal|"Non-active users size = "
operator|+
name|nonActiveUsersSet
operator|.
name|size
argument_list|()
operator|+
literal|"Total Resource usage for active users="
operator|+
name|totalResUsageForActiveUsers
operator|.
name|getAllUsed
argument_list|()
operator|+
literal|"."
operator|+
literal|"Total Resource usage for non-active users="
operator|+
name|totalResUsageForNonActiveUsers
operator|.
name|getAllUsed
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|updateNonActiveUsersResourceUsage (String userName)
specifier|private
name|void
name|updateNonActiveUsersResourceUsage
parameter_list|(
name|String
name|userName
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// For UT case: We might need to add the user to users list.
name|User
name|user
init|=
name|getUser
argument_list|(
name|userName
argument_list|)
decl_stmt|;
if|if
condition|(
name|user
operator|==
literal|null
condition|)
return|return;
name|ResourceUsage
name|resourceUsage
init|=
name|user
operator|.
name|getResourceUsage
argument_list|()
decl_stmt|;
comment|// If User is moved to non-active list, moved resource usage from
comment|// non-active to active list.
if|if
condition|(
name|activeUsersSet
operator|.
name|contains
argument_list|(
name|userName
argument_list|)
condition|)
block|{
name|activeUsersSet
operator|.
name|remove
argument_list|(
name|userName
argument_list|)
expr_stmt|;
name|nonActiveUsersSet
operator|.
name|add
argument_list|(
name|userName
argument_list|)
expr_stmt|;
comment|// Update total resource usage of active and non-active after user is
comment|// moved from active to non-active.
for|for
control|(
name|String
name|partition
range|:
name|resourceUsage
operator|.
name|getNodePartitionsSet
argument_list|()
control|)
block|{
name|totalResUsageForActiveUsers
operator|.
name|decUsed
argument_list|(
name|partition
argument_list|,
name|resourceUsage
operator|.
name|getUsed
argument_list|(
name|partition
argument_list|)
argument_list|)
expr_stmt|;
name|totalResUsageForNonActiveUsers
operator|.
name|incUsed
argument_list|(
name|partition
argument_list|,
name|resourceUsage
operator|.
name|getUsed
argument_list|(
name|partition
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"User '"
operator|+
name|userName
operator|+
literal|"' has become non-active.Hence move user to non-active list."
operator|+
literal|"Active users size = "
operator|+
name|activeUsersSet
operator|.
name|size
argument_list|()
operator|+
literal|"Non-active users size = "
operator|+
name|nonActiveUsersSet
operator|.
name|size
argument_list|()
operator|+
literal|"Total Resource usage for active users="
operator|+
name|totalResUsageForActiveUsers
operator|.
name|getAllUsed
argument_list|()
operator|+
literal|"."
operator|+
literal|"Total Resource usage for non-active users="
operator|+
name|totalResUsageForNonActiveUsers
operator|.
name|getAllUsed
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getTotalResourceUsagePerUser (String userName)
specifier|private
name|ResourceUsage
name|getTotalResourceUsagePerUser
parameter_list|(
name|String
name|userName
parameter_list|)
block|{
if|if
condition|(
name|nonActiveUsersSet
operator|.
name|contains
argument_list|(
name|userName
argument_list|)
condition|)
block|{
return|return
name|totalResUsageForNonActiveUsers
return|;
block|}
elseif|else
if|if
condition|(
name|activeUsersSet
operator|.
name|contains
argument_list|(
name|userName
argument_list|)
condition|)
block|{
return|return
name|totalResUsageForActiveUsers
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"User '"
operator|+
name|userName
operator|+
literal|"' is not present in active/non-active. This is highly unlikely."
operator|+
literal|"We can consider this user in non-active list in this case."
argument_list|)
expr_stmt|;
return|return
name|totalResUsageForNonActiveUsers
return|;
block|}
block|}
comment|/**    * During container allocate/release, ensure that all user specific data    * structures are updated.    *    * @param userName    *          Name of the user    * @param resource    *          Resource to increment/decrement    * @param nodePartition    *          Node label    * @param isAllocate    *          Indicate whether to allocate or release resource    * @return user    */
DECL|method|updateUserResourceUsage (String userName, Resource resource, String nodePartition, boolean isAllocate)
specifier|public
name|User
name|updateUserResourceUsage
parameter_list|(
name|String
name|userName
parameter_list|,
name|Resource
name|resource
parameter_list|,
name|String
name|nodePartition
parameter_list|,
name|boolean
name|isAllocate
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// TODO, should use getUser, use this method just to avoid UT failure
comment|// which is caused by wrong invoking order, will fix UT separately
name|User
name|user
init|=
name|getUserAndAddIfAbsent
argument_list|(
name|userName
argument_list|)
decl_stmt|;
comment|// New container is allocated. Invalidate user-limit.
name|updateResourceUsagePerUser
argument_list|(
name|user
argument_list|,
name|resource
argument_list|,
name|nodePartition
argument_list|,
name|isAllocate
argument_list|)
expr_stmt|;
name|userLimitNeedsRecompute
argument_list|()
expr_stmt|;
comment|// Update usage ratios
name|Resource
name|resourceByLabel
init|=
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|nodePartition
argument_list|,
name|scheduler
operator|.
name|getClusterResource
argument_list|()
argument_list|)
decl_stmt|;
name|incQueueUsageRatio
argument_list|(
name|nodePartition
argument_list|,
name|user
operator|.
name|updateUsageRatio
argument_list|(
name|resourceCalculator
argument_list|,
name|resourceByLabel
argument_list|,
name|nodePartition
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|user
return|;
block|}
finally|finally
block|{
name|this
operator|.
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|updateResourceUsagePerUser (User user, Resource resource, String nodePartition, boolean isAllocate)
specifier|private
name|void
name|updateResourceUsagePerUser
parameter_list|(
name|User
name|user
parameter_list|,
name|Resource
name|resource
parameter_list|,
name|String
name|nodePartition
parameter_list|,
name|boolean
name|isAllocate
parameter_list|)
block|{
name|ResourceUsage
name|totalResourceUsageForUsers
init|=
name|getTotalResourceUsagePerUser
argument_list|(
name|user
operator|.
name|userName
argument_list|)
decl_stmt|;
if|if
condition|(
name|isAllocate
condition|)
block|{
name|user
operator|.
name|getResourceUsage
argument_list|()
operator|.
name|incUsed
argument_list|(
name|nodePartition
argument_list|,
name|resource
argument_list|)
expr_stmt|;
name|totalResourceUsageForUsers
operator|.
name|incUsed
argument_list|(
name|nodePartition
argument_list|,
name|resource
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|user
operator|.
name|getResourceUsage
argument_list|()
operator|.
name|decUsed
argument_list|(
name|nodePartition
argument_list|,
name|resource
argument_list|)
expr_stmt|;
name|totalResourceUsageForUsers
operator|.
name|decUsed
argument_list|(
name|nodePartition
argument_list|,
name|resource
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"User resource is updated."
operator|+
literal|"Total Resource usage for active users="
operator|+
name|totalResUsageForActiveUsers
operator|.
name|getAllUsed
argument_list|()
operator|+
literal|"."
operator|+
literal|"Total Resource usage for non-active users="
operator|+
name|totalResUsageForNonActiveUsers
operator|.
name|getAllUsed
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

