begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.resourcemanager.scheduler.distributed
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|distributed
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|NodeId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerQueuingLimit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|distributed
operator|.
name|NodeQueueLoadMonitor
operator|.
name|ClusterNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|distributed
operator|.
name|NodeQueueLoadMonitor
operator|.
name|LoadComparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_comment
comment|/**  * This class interacts with the NodeQueueLoadMonitor to keep track of the  * mean and standard deviation of the configured metrics (queue length or queue  * wait time) used to characterize the queue load of a specific node.  * The NodeQueueLoadMonitor triggers an update (by calling the  *<code>update()</code> method) every time it performs a re-ordering of  * all nodes.  */
end_comment

begin_class
DECL|class|QueueLimitCalculator
specifier|public
class|class
name|QueueLimitCalculator
block|{
DECL|class|Stats
class|class
name|Stats
block|{
DECL|field|mean
specifier|private
specifier|final
name|AtomicInteger
name|mean
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|stdev
specifier|private
specifier|final
name|AtomicInteger
name|stdev
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/**      * Not thread safe. Caller should synchronize on sorted nodes list.      */
DECL|method|update ()
name|void
name|update
parameter_list|()
block|{
name|List
argument_list|<
name|NodeId
argument_list|>
name|sortedNodes
init|=
name|nodeSelector
operator|.
name|getSortedNodes
argument_list|()
decl_stmt|;
if|if
condition|(
name|sortedNodes
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Calculate mean
name|int
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|NodeId
name|n
range|:
name|sortedNodes
control|)
block|{
name|sum
operator|+=
name|getMetric
argument_list|(
name|getNode
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mean
operator|.
name|set
argument_list|(
name|sum
operator|/
name|sortedNodes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Calculate stdev
name|int
name|sqrSumMean
init|=
literal|0
decl_stmt|;
for|for
control|(
name|NodeId
name|n
range|:
name|sortedNodes
control|)
block|{
name|int
name|val
init|=
name|getMetric
argument_list|(
name|getNode
argument_list|(
name|n
argument_list|)
argument_list|)
decl_stmt|;
name|sqrSumMean
operator|+=
name|Math
operator|.
name|pow
argument_list|(
name|val
operator|-
name|mean
operator|.
name|get
argument_list|()
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|stdev
operator|.
name|set
argument_list|(
operator|(
name|int
operator|)
name|Math
operator|.
name|round
argument_list|(
name|Math
operator|.
name|sqrt
argument_list|(
name|sqrSumMean
operator|/
operator|(
name|float
operator|)
name|sortedNodes
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getNode (NodeId nId)
specifier|private
name|ClusterNode
name|getNode
parameter_list|(
name|NodeId
name|nId
parameter_list|)
block|{
return|return
name|nodeSelector
operator|.
name|getClusterNodes
argument_list|()
operator|.
name|get
argument_list|(
name|nId
argument_list|)
return|;
block|}
DECL|method|getMetric (ClusterNode cn)
specifier|private
name|int
name|getMetric
parameter_list|(
name|ClusterNode
name|cn
parameter_list|)
block|{
return|return
operator|(
name|cn
operator|!=
literal|null
operator|)
condition|?
operator|(
operator|(
name|LoadComparator
operator|)
name|nodeSelector
operator|.
name|getComparator
argument_list|()
operator|)
operator|.
name|getMetric
argument_list|(
name|cn
argument_list|)
else|:
literal|0
return|;
block|}
DECL|method|getMean ()
specifier|public
name|int
name|getMean
parameter_list|()
block|{
return|return
name|mean
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|getStdev ()
specifier|public
name|int
name|getStdev
parameter_list|()
block|{
return|return
name|stdev
operator|.
name|get
argument_list|()
return|;
block|}
block|}
DECL|field|nodeSelector
specifier|private
specifier|final
name|NodeQueueLoadMonitor
name|nodeSelector
decl_stmt|;
DECL|field|sigma
specifier|private
specifier|final
name|float
name|sigma
decl_stmt|;
DECL|field|rangeMin
specifier|private
specifier|final
name|int
name|rangeMin
decl_stmt|;
DECL|field|rangeMax
specifier|private
specifier|final
name|int
name|rangeMax
decl_stmt|;
DECL|field|stats
specifier|private
specifier|final
name|Stats
name|stats
init|=
operator|new
name|Stats
argument_list|()
decl_stmt|;
DECL|method|QueueLimitCalculator (NodeQueueLoadMonitor selector, float sigma, int rangeMin, int rangeMax)
name|QueueLimitCalculator
parameter_list|(
name|NodeQueueLoadMonitor
name|selector
parameter_list|,
name|float
name|sigma
parameter_list|,
name|int
name|rangeMin
parameter_list|,
name|int
name|rangeMax
parameter_list|)
block|{
name|this
operator|.
name|nodeSelector
operator|=
name|selector
expr_stmt|;
name|this
operator|.
name|sigma
operator|=
name|sigma
expr_stmt|;
name|this
operator|.
name|rangeMax
operator|=
name|rangeMax
expr_stmt|;
name|this
operator|.
name|rangeMin
operator|=
name|rangeMin
expr_stmt|;
block|}
DECL|method|determineThreshold ()
specifier|private
name|int
name|determineThreshold
parameter_list|()
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|stats
operator|.
name|getMean
argument_list|()
operator|+
name|sigma
operator|*
name|stats
operator|.
name|getStdev
argument_list|()
argument_list|)
return|;
block|}
DECL|method|update ()
name|void
name|update
parameter_list|()
block|{
name|this
operator|.
name|stats
operator|.
name|update
argument_list|()
expr_stmt|;
block|}
DECL|method|getThreshold ()
specifier|private
name|int
name|getThreshold
parameter_list|()
block|{
name|int
name|thres
init|=
name|determineThreshold
argument_list|()
decl_stmt|;
return|return
name|Math
operator|.
name|min
argument_list|(
name|rangeMax
argument_list|,
name|Math
operator|.
name|max
argument_list|(
name|rangeMin
argument_list|,
name|thres
argument_list|)
argument_list|)
return|;
block|}
DECL|method|createContainerQueuingLimit ()
specifier|public
name|ContainerQueuingLimit
name|createContainerQueuingLimit
parameter_list|()
block|{
name|ContainerQueuingLimit
name|containerQueuingLimit
init|=
name|ContainerQueuingLimit
operator|.
name|newInstance
argument_list|()
decl_stmt|;
if|if
condition|(
name|nodeSelector
operator|.
name|getComparator
argument_list|()
operator|==
name|LoadComparator
operator|.
name|QUEUE_WAIT_TIME
condition|)
block|{
name|containerQueuingLimit
operator|.
name|setMaxQueueWaitTimeInMs
argument_list|(
name|getThreshold
argument_list|()
argument_list|)
expr_stmt|;
name|containerQueuingLimit
operator|.
name|setMaxQueueLength
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|containerQueuingLimit
operator|.
name|setMaxQueueWaitTimeInMs
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|containerQueuingLimit
operator|.
name|setMaxQueueLength
argument_list|(
name|getThreshold
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|containerQueuingLimit
return|;
block|}
block|}
end_class

end_unit

