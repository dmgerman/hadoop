begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.resourcemanager.reservation.planning
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|reservation
operator|.
name|planning
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ReservationDefinition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ReservationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ReservationRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ReservationRequestInterpreter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|reservation
operator|.
name|Plan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|reservation
operator|.
name|RLESparseResourceAllocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|reservation
operator|.
name|ReservationAllocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|reservation
operator|.
name|ReservationInterval
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|reservation
operator|.
name|exceptions
operator|.
name|ContractValidationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|Resources
import|;
end_import

begin_comment
comment|/**  * A planning algorithm consisting of two main phases. The algorithm iterates  * over the job stages in descending order. For each stage, the algorithm: 1.  * Determines an interval [stageArrivalTime, stageDeadline) in which the stage  * is allocated. 2. Computes an allocation for the stage inside the interval.  *  * For ANY and ALL jobs, phase 1 sets the allocation window of each stage to be  * [jobArrival, jobDeadline]. For ORDER and ORDER_NO_GAP jobs, the deadline of  * each stage is set as succcessorStartTime - the starting time of its  * succeeding stage (or jobDeadline if it is the last stage).  *  * The phases are set using the two functions: 1. setAlgEarliestStartTime 2.  * setAlgComputeStageAllocation  */
end_comment

begin_class
DECL|class|IterativePlanner
specifier|public
class|class
name|IterativePlanner
extends|extends
name|PlanningAlgorithm
block|{
comment|// Modifications performed by the algorithm that are not been reflected in the
comment|// actual plan while a request is still pending.
DECL|field|planModifications
specifier|private
name|RLESparseResourceAllocation
name|planModifications
decl_stmt|;
comment|// Data extracted from plan
DECL|field|planLoads
specifier|private
name|Map
argument_list|<
name|Long
argument_list|,
name|Resource
argument_list|>
name|planLoads
decl_stmt|;
DECL|field|capacity
specifier|private
name|Resource
name|capacity
decl_stmt|;
DECL|field|step
specifier|private
name|long
name|step
decl_stmt|;
comment|// Job parameters
DECL|field|jobType
specifier|private
name|ReservationRequestInterpreter
name|jobType
decl_stmt|;
DECL|field|jobArrival
specifier|private
name|long
name|jobArrival
decl_stmt|;
DECL|field|jobDeadline
specifier|private
name|long
name|jobDeadline
decl_stmt|;
comment|// Phase algorithms
DECL|field|algStageEarliestStart
specifier|private
name|StageEarliestStart
name|algStageEarliestStart
init|=
literal|null
decl_stmt|;
DECL|field|algStageAllocator
specifier|private
name|StageAllocator
name|algStageAllocator
init|=
literal|null
decl_stmt|;
comment|// Constructor
DECL|method|IterativePlanner (StageEarliestStart algEarliestStartTime, StageAllocator algStageAllocator)
specifier|public
name|IterativePlanner
parameter_list|(
name|StageEarliestStart
name|algEarliestStartTime
parameter_list|,
name|StageAllocator
name|algStageAllocator
parameter_list|)
block|{
name|setAlgStageEarliestStart
argument_list|(
name|algEarliestStartTime
argument_list|)
expr_stmt|;
name|setAlgStageAllocator
argument_list|(
name|algStageAllocator
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|computeJobAllocation (Plan plan, ReservationId reservationId, ReservationDefinition reservation)
specifier|public
name|RLESparseResourceAllocation
name|computeJobAllocation
parameter_list|(
name|Plan
name|plan
parameter_list|,
name|ReservationId
name|reservationId
parameter_list|,
name|ReservationDefinition
name|reservation
parameter_list|)
throws|throws
name|ContractValidationException
block|{
comment|// Initialize
name|initialize
argument_list|(
name|plan
argument_list|,
name|reservation
argument_list|)
expr_stmt|;
comment|// If the job has been previously reserved, logically remove its allocation
name|ReservationAllocation
name|oldReservation
init|=
name|plan
operator|.
name|getReservationById
argument_list|(
name|reservationId
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldReservation
operator|!=
literal|null
condition|)
block|{
name|ignoreOldAllocation
argument_list|(
name|oldReservation
argument_list|)
expr_stmt|;
block|}
comment|// Create the allocations data structure
name|RLESparseResourceAllocation
name|allocations
init|=
operator|new
name|RLESparseResourceAllocation
argument_list|(
name|plan
operator|.
name|getResourceCalculator
argument_list|()
argument_list|)
decl_stmt|;
comment|// Get a reverse iterator for the set of stages
name|ListIterator
argument_list|<
name|ReservationRequest
argument_list|>
name|li
init|=
name|reservation
operator|.
name|getReservationRequests
argument_list|()
operator|.
name|getReservationResources
argument_list|()
operator|.
name|listIterator
argument_list|(
name|reservation
operator|.
name|getReservationRequests
argument_list|()
operator|.
name|getReservationResources
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// Current stage
name|ReservationRequest
name|currentReservationStage
decl_stmt|;
comment|// Index, points on the current node
name|int
name|index
init|=
name|reservation
operator|.
name|getReservationRequests
argument_list|()
operator|.
name|getReservationResources
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// Stage deadlines
name|long
name|stageDeadline
init|=
name|stepRoundDown
argument_list|(
name|reservation
operator|.
name|getDeadline
argument_list|()
argument_list|,
name|step
argument_list|)
decl_stmt|;
name|long
name|successorStartingTime
init|=
operator|-
literal|1
decl_stmt|;
comment|// Iterate the stages in reverse order
while|while
condition|(
name|li
operator|.
name|hasPrevious
argument_list|()
condition|)
block|{
comment|// Get current stage
name|currentReservationStage
operator|=
name|li
operator|.
name|previous
argument_list|()
expr_stmt|;
name|index
operator|-=
literal|1
expr_stmt|;
comment|// Validate that the ReservationRequest respects basic constraints
name|validateInputStage
argument_list|(
name|plan
argument_list|,
name|currentReservationStage
argument_list|)
expr_stmt|;
comment|// Compute an adjusted earliestStart for this resource
comment|// (we need this to provision some space for the ORDER contracts)
name|long
name|stageArrivalTime
init|=
name|reservation
operator|.
name|getArrival
argument_list|()
decl_stmt|;
if|if
condition|(
name|jobType
operator|==
name|ReservationRequestInterpreter
operator|.
name|R_ORDER
operator|||
name|jobType
operator|==
name|ReservationRequestInterpreter
operator|.
name|R_ORDER_NO_GAP
condition|)
block|{
name|stageArrivalTime
operator|=
name|computeEarliestStartingTime
argument_list|(
name|plan
argument_list|,
name|reservation
argument_list|,
name|index
argument_list|,
name|currentReservationStage
argument_list|,
name|stageDeadline
argument_list|)
expr_stmt|;
block|}
name|stageArrivalTime
operator|=
name|stepRoundUp
argument_list|(
name|stageArrivalTime
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|stageArrivalTime
operator|=
name|Math
operator|.
name|max
argument_list|(
name|stageArrivalTime
argument_list|,
name|reservation
operator|.
name|getArrival
argument_list|()
argument_list|)
expr_stmt|;
comment|// Compute the allocation of a single stage
name|Map
argument_list|<
name|ReservationInterval
argument_list|,
name|Resource
argument_list|>
name|curAlloc
init|=
name|computeStageAllocation
argument_list|(
name|plan
argument_list|,
name|currentReservationStage
argument_list|,
name|stageArrivalTime
argument_list|,
name|stageDeadline
argument_list|)
decl_stmt|;
comment|// If we did not find an allocation, return NULL
comment|// (unless it's an ANY job, then we simply continue).
if|if
condition|(
name|curAlloc
operator|==
literal|null
condition|)
block|{
comment|// If it's an ANY job, we can move to the next possible request
if|if
condition|(
name|jobType
operator|==
name|ReservationRequestInterpreter
operator|.
name|R_ANY
condition|)
block|{
continue|continue;
block|}
comment|// Otherwise, the job cannot be allocated
return|return
literal|null
return|;
block|}
comment|// Get the start& end time of the current allocation
name|Long
name|stageStartTime
init|=
name|findEarliestTime
argument_list|(
name|curAlloc
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|Long
name|stageEndTime
init|=
name|findLatestTime
argument_list|(
name|curAlloc
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
comment|// If we did find an allocation for the stage, add it
for|for
control|(
name|Entry
argument_list|<
name|ReservationInterval
argument_list|,
name|Resource
argument_list|>
name|entry
range|:
name|curAlloc
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|allocations
operator|.
name|addInterval
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// If this is an ANY clause, we have finished
if|if
condition|(
name|jobType
operator|==
name|ReservationRequestInterpreter
operator|.
name|R_ANY
condition|)
block|{
break|break;
block|}
comment|// If ORDER job, set the stageDeadline of the next stage to be processed
if|if
condition|(
name|jobType
operator|==
name|ReservationRequestInterpreter
operator|.
name|R_ORDER
operator|||
name|jobType
operator|==
name|ReservationRequestInterpreter
operator|.
name|R_ORDER_NO_GAP
condition|)
block|{
comment|// Verify that there is no gap, in case the job is ORDER_NO_GAP
if|if
condition|(
name|jobType
operator|==
name|ReservationRequestInterpreter
operator|.
name|R_ORDER_NO_GAP
operator|&&
name|successorStartingTime
operator|!=
operator|-
literal|1
operator|&&
name|successorStartingTime
operator|>
name|stageEndTime
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Store the stageStartTime and set the new stageDeadline
name|successorStartingTime
operator|=
name|stageStartTime
expr_stmt|;
name|stageDeadline
operator|=
name|stageStartTime
expr_stmt|;
block|}
block|}
comment|// If the allocation is empty, return an error
if|if
condition|(
name|allocations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|allocations
return|;
block|}
DECL|method|initialize (Plan plan, ReservationDefinition reservation)
specifier|protected
name|void
name|initialize
parameter_list|(
name|Plan
name|plan
parameter_list|,
name|ReservationDefinition
name|reservation
parameter_list|)
block|{
comment|// Get plan step& capacity
name|capacity
operator|=
name|plan
operator|.
name|getTotalCapacity
argument_list|()
expr_stmt|;
name|step
operator|=
name|plan
operator|.
name|getStep
argument_list|()
expr_stmt|;
comment|// Get job parameters (type, arrival time& deadline)
name|jobType
operator|=
name|reservation
operator|.
name|getReservationRequests
argument_list|()
operator|.
name|getInterpreter
argument_list|()
expr_stmt|;
name|jobArrival
operator|=
name|stepRoundUp
argument_list|(
name|reservation
operator|.
name|getArrival
argument_list|()
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|jobDeadline
operator|=
name|stepRoundDown
argument_list|(
name|reservation
operator|.
name|getDeadline
argument_list|()
argument_list|,
name|step
argument_list|)
expr_stmt|;
comment|// Dirty read of plan load
name|planLoads
operator|=
name|getAllLoadsInInterval
argument_list|(
name|plan
argument_list|,
name|jobArrival
argument_list|,
name|jobDeadline
argument_list|)
expr_stmt|;
comment|// Initialize the plan modifications
name|planModifications
operator|=
operator|new
name|RLESparseResourceAllocation
argument_list|(
name|plan
operator|.
name|getResourceCalculator
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|getAllLoadsInInterval (Plan plan, long startTime, long endTime)
specifier|private
name|Map
argument_list|<
name|Long
argument_list|,
name|Resource
argument_list|>
name|getAllLoadsInInterval
parameter_list|(
name|Plan
name|plan
parameter_list|,
name|long
name|startTime
parameter_list|,
name|long
name|endTime
parameter_list|)
block|{
comment|// Create map
name|Map
argument_list|<
name|Long
argument_list|,
name|Resource
argument_list|>
name|loads
init|=
operator|new
name|HashMap
argument_list|<
name|Long
argument_list|,
name|Resource
argument_list|>
argument_list|()
decl_stmt|;
comment|// Calculate the load for every time slot between [start,end)
for|for
control|(
name|long
name|t
init|=
name|startTime
init|;
name|t
operator|<
name|endTime
condition|;
name|t
operator|+=
name|step
control|)
block|{
name|Resource
name|load
init|=
name|plan
operator|.
name|getTotalCommittedResources
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|loads
operator|.
name|put
argument_list|(
name|t
argument_list|,
name|load
argument_list|)
expr_stmt|;
block|}
comment|// Return map
return|return
name|loads
return|;
block|}
DECL|method|ignoreOldAllocation (ReservationAllocation oldReservation)
specifier|private
name|void
name|ignoreOldAllocation
parameter_list|(
name|ReservationAllocation
name|oldReservation
parameter_list|)
block|{
comment|// If there is no old reservation, return
if|if
condition|(
name|oldReservation
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// Subtract each allocation interval from the planModifications
for|for
control|(
name|Entry
argument_list|<
name|ReservationInterval
argument_list|,
name|Resource
argument_list|>
name|entry
range|:
name|oldReservation
operator|.
name|getAllocationRequests
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// Read the entry
name|ReservationInterval
name|interval
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Resource
name|resource
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// Find the actual request
name|Resource
name|negativeResource
init|=
name|Resources
operator|.
name|multiply
argument_list|(
name|resource
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|// Insert it into planModifications as a 'negative' request, to
comment|// represent available resources
name|planModifications
operator|.
name|addInterval
argument_list|(
name|interval
argument_list|,
name|negativeResource
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|validateInputStage (Plan plan, ReservationRequest rr)
specifier|private
name|void
name|validateInputStage
parameter_list|(
name|Plan
name|plan
parameter_list|,
name|ReservationRequest
name|rr
parameter_list|)
throws|throws
name|ContractValidationException
block|{
comment|// Validate concurrency
if|if
condition|(
name|rr
operator|.
name|getConcurrency
argument_list|()
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|ContractValidationException
argument_list|(
literal|"Gang Size should be>= 1"
argument_list|)
throw|;
block|}
comment|// Validate number of containers
if|if
condition|(
name|rr
operator|.
name|getNumContainers
argument_list|()
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|ContractValidationException
argument_list|(
literal|"Num containers should be> 0"
argument_list|)
throw|;
block|}
comment|// Check that gangSize and numContainers are compatible
if|if
condition|(
name|rr
operator|.
name|getNumContainers
argument_list|()
operator|%
name|rr
operator|.
name|getConcurrency
argument_list|()
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|ContractValidationException
argument_list|(
literal|"Parallelism must be an exact multiple of gang size"
argument_list|)
throw|;
block|}
comment|// Check that the largest container request does not exceed the cluster-wide
comment|// limit for container sizes
if|if
condition|(
name|Resources
operator|.
name|greaterThan
argument_list|(
name|plan
operator|.
name|getResourceCalculator
argument_list|()
argument_list|,
name|capacity
argument_list|,
name|rr
operator|.
name|getCapability
argument_list|()
argument_list|,
name|plan
operator|.
name|getMaximumAllocation
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ContractValidationException
argument_list|(
literal|"Individual capability requests should not exceed cluster's "
operator|+
literal|"maxAlloc"
argument_list|)
throw|;
block|}
block|}
comment|// Call algEarliestStartTime()
DECL|method|computeEarliestStartingTime (Plan plan, ReservationDefinition reservation, int index, ReservationRequest currentReservationStage, long stageDeadline)
specifier|protected
name|long
name|computeEarliestStartingTime
parameter_list|(
name|Plan
name|plan
parameter_list|,
name|ReservationDefinition
name|reservation
parameter_list|,
name|int
name|index
parameter_list|,
name|ReservationRequest
name|currentReservationStage
parameter_list|,
name|long
name|stageDeadline
parameter_list|)
block|{
return|return
name|algStageEarliestStart
operator|.
name|setEarliestStartTime
argument_list|(
name|plan
argument_list|,
name|reservation
argument_list|,
name|index
argument_list|,
name|currentReservationStage
argument_list|,
name|stageDeadline
argument_list|)
return|;
block|}
comment|// Call algStageAllocator
DECL|method|computeStageAllocation ( Plan plan, ReservationRequest rr, long stageArrivalTime, long stageDeadline)
specifier|protected
name|Map
argument_list|<
name|ReservationInterval
argument_list|,
name|Resource
argument_list|>
name|computeStageAllocation
parameter_list|(
name|Plan
name|plan
parameter_list|,
name|ReservationRequest
name|rr
parameter_list|,
name|long
name|stageArrivalTime
parameter_list|,
name|long
name|stageDeadline
parameter_list|)
block|{
return|return
name|algStageAllocator
operator|.
name|computeStageAllocation
argument_list|(
name|plan
argument_list|,
name|planLoads
argument_list|,
name|planModifications
argument_list|,
name|rr
argument_list|,
name|stageArrivalTime
argument_list|,
name|stageDeadline
argument_list|)
return|;
block|}
comment|// Set the algorithm: algStageEarliestStart
DECL|method|setAlgStageEarliestStart (StageEarliestStart alg)
specifier|public
name|IterativePlanner
name|setAlgStageEarliestStart
parameter_list|(
name|StageEarliestStart
name|alg
parameter_list|)
block|{
name|this
operator|.
name|algStageEarliestStart
operator|=
name|alg
expr_stmt|;
return|return
name|this
return|;
comment|// To allow concatenation of setAlg() functions
block|}
comment|// Set the algorithm: algStageAllocator
DECL|method|setAlgStageAllocator (StageAllocator alg)
specifier|public
name|IterativePlanner
name|setAlgStageAllocator
parameter_list|(
name|StageAllocator
name|alg
parameter_list|)
block|{
name|this
operator|.
name|algStageAllocator
operator|=
name|alg
expr_stmt|;
return|return
name|this
return|;
comment|// To allow concatenation of setAlg() functions
block|}
block|}
end_class

end_unit

