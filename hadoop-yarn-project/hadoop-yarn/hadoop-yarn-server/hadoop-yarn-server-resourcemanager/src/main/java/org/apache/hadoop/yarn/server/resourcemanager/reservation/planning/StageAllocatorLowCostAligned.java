begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.resourcemanager.reservation.planning
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|reservation
operator|.
name|planning
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ReservationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ReservationRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|reservation
operator|.
name|Plan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|reservation
operator|.
name|RLESparseResourceAllocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|reservation
operator|.
name|RLESparseResourceAllocation
operator|.
name|RLEOperator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|reservation
operator|.
name|ReservationInterval
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|reservation
operator|.
name|exceptions
operator|.
name|PlanningException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|ResourceCalculator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|Resources
import|;
end_import

begin_comment
comment|/**  * A stage allocator that iteratively allocates containers in the  * {@link DurationInterval} with lowest overall cost. The algorithm only  * considers non-overlapping intervals of length 'duration'. This guarantees  * that the allocations are aligned. If 'allocateLeft == true', the intervals  * considered by the algorithm are aligned to stageArrival; otherwise, they are  * aligned to stageDeadline. The smoothnessFactor parameter controls the number  * of containers that are simultaneously allocated in each iteration of the  * algorithm.  */
end_comment

begin_class
DECL|class|StageAllocatorLowCostAligned
specifier|public
class|class
name|StageAllocatorLowCostAligned
implements|implements
name|StageAllocator
block|{
DECL|field|allocateLeft
specifier|private
specifier|final
name|boolean
name|allocateLeft
decl_stmt|;
comment|// Smoothness factor
DECL|field|smoothnessFactor
specifier|private
name|int
name|smoothnessFactor
init|=
literal|10
decl_stmt|;
comment|// Constructor
DECL|method|StageAllocatorLowCostAligned (boolean allocateLeft)
specifier|public
name|StageAllocatorLowCostAligned
parameter_list|(
name|boolean
name|allocateLeft
parameter_list|)
block|{
name|this
operator|.
name|allocateLeft
operator|=
name|allocateLeft
expr_stmt|;
block|}
comment|// Constructor
DECL|method|StageAllocatorLowCostAligned (int smoothnessFactor, boolean allocateLeft)
specifier|public
name|StageAllocatorLowCostAligned
parameter_list|(
name|int
name|smoothnessFactor
parameter_list|,
name|boolean
name|allocateLeft
parameter_list|)
block|{
name|this
operator|.
name|allocateLeft
operator|=
name|allocateLeft
expr_stmt|;
name|this
operator|.
name|smoothnessFactor
operator|=
name|smoothnessFactor
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|computeStageAllocation (Plan plan, RLESparseResourceAllocation planLoads, RLESparseResourceAllocation planModifications, ReservationRequest rr, long stageArrival, long stageDeadline, long period, String user, ReservationId oldId)
specifier|public
name|Map
argument_list|<
name|ReservationInterval
argument_list|,
name|Resource
argument_list|>
name|computeStageAllocation
parameter_list|(
name|Plan
name|plan
parameter_list|,
name|RLESparseResourceAllocation
name|planLoads
parameter_list|,
name|RLESparseResourceAllocation
name|planModifications
parameter_list|,
name|ReservationRequest
name|rr
parameter_list|,
name|long
name|stageArrival
parameter_list|,
name|long
name|stageDeadline
parameter_list|,
name|long
name|period
parameter_list|,
name|String
name|user
parameter_list|,
name|ReservationId
name|oldId
parameter_list|)
throws|throws
name|PlanningException
block|{
comment|// Initialize
name|ResourceCalculator
name|resCalc
init|=
name|plan
operator|.
name|getResourceCalculator
argument_list|()
decl_stmt|;
name|Resource
name|capacity
init|=
name|plan
operator|.
name|getTotalCapacity
argument_list|()
decl_stmt|;
name|RLESparseResourceAllocation
name|netRLERes
init|=
name|plan
operator|.
name|getAvailableResourceOverTime
argument_list|(
name|user
argument_list|,
name|oldId
argument_list|,
name|stageArrival
argument_list|,
name|stageDeadline
argument_list|,
name|period
argument_list|)
decl_stmt|;
name|long
name|step
init|=
name|plan
operator|.
name|getStep
argument_list|()
decl_stmt|;
comment|// Create allocationRequestsearlies
name|RLESparseResourceAllocation
name|allocationRequests
init|=
operator|new
name|RLESparseResourceAllocation
argument_list|(
name|plan
operator|.
name|getResourceCalculator
argument_list|()
argument_list|)
decl_stmt|;
comment|// Initialize parameters
name|long
name|duration
init|=
name|stepRoundUp
argument_list|(
name|rr
operator|.
name|getDuration
argument_list|()
argument_list|,
name|step
argument_list|)
decl_stmt|;
name|int
name|windowSizeInDurations
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|stageDeadline
operator|-
name|stageArrival
operator|)
operator|/
name|duration
argument_list|)
decl_stmt|;
name|int
name|totalGangs
init|=
name|rr
operator|.
name|getNumContainers
argument_list|()
operator|/
name|rr
operator|.
name|getConcurrency
argument_list|()
decl_stmt|;
name|int
name|numContainersPerGang
init|=
name|rr
operator|.
name|getConcurrency
argument_list|()
decl_stmt|;
name|Resource
name|gang
init|=
name|Resources
operator|.
name|multiply
argument_list|(
name|rr
operator|.
name|getCapability
argument_list|()
argument_list|,
name|numContainersPerGang
argument_list|)
decl_stmt|;
comment|// Set maxGangsPerUnit
name|int
name|maxGangsPerUnit
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|max
argument_list|(
name|Math
operator|.
name|floor
argument_list|(
operator|(
operator|(
name|double
operator|)
name|totalGangs
operator|)
operator|/
name|windowSizeInDurations
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|maxGangsPerUnit
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxGangsPerUnit
operator|/
name|smoothnessFactor
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// If window size is too small, return null
if|if
condition|(
name|windowSizeInDurations
operator|<=
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|int
name|preferLeft
init|=
name|allocateLeft
condition|?
literal|1
else|:
operator|-
literal|1
decl_stmt|;
comment|// Initialize tree sorted by costs
name|TreeSet
argument_list|<
name|DurationInterval
argument_list|>
name|durationIntervalsSortedByCost
init|=
operator|new
name|TreeSet
argument_list|<
name|DurationInterval
argument_list|>
argument_list|(
operator|new
name|Comparator
argument_list|<
name|DurationInterval
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|DurationInterval
name|val1
parameter_list|,
name|DurationInterval
name|val2
parameter_list|)
block|{
name|int
name|cmp
init|=
name|Double
operator|.
name|compare
argument_list|(
name|val1
operator|.
name|getTotalCost
argument_list|()
argument_list|,
name|val2
operator|.
name|getTotalCost
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
return|return
name|cmp
return|;
block|}
return|return
name|preferLeft
operator|*
name|Long
operator|.
name|compare
argument_list|(
name|val1
operator|.
name|getEndTime
argument_list|()
argument_list|,
name|val2
operator|.
name|getEndTime
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Long
argument_list|>
name|intervalEndTimes
init|=
name|computeIntervalEndTimes
argument_list|(
name|stageArrival
argument_list|,
name|stageDeadline
argument_list|,
name|duration
argument_list|)
decl_stmt|;
comment|// Add durationIntervals that end at (endTime - n*duration) for some n.
for|for
control|(
name|long
name|intervalEnd
range|:
name|intervalEndTimes
control|)
block|{
name|long
name|intervalStart
init|=
name|intervalEnd
operator|-
name|duration
decl_stmt|;
comment|// Get duration interval [intervalStart,intervalEnd)
name|DurationInterval
name|durationInterval
init|=
name|getDurationInterval
argument_list|(
name|intervalStart
argument_list|,
name|intervalEnd
argument_list|,
name|planLoads
argument_list|,
name|planModifications
argument_list|,
name|capacity
argument_list|,
name|netRLERes
argument_list|,
name|resCalc
argument_list|,
name|step
argument_list|,
name|gang
argument_list|)
decl_stmt|;
comment|// If the interval can fit a gang, add it to the tree
if|if
condition|(
name|durationInterval
operator|.
name|canAllocate
argument_list|()
condition|)
block|{
name|durationIntervalsSortedByCost
operator|.
name|add
argument_list|(
name|durationInterval
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Allocate
name|int
name|remainingGangs
init|=
name|totalGangs
decl_stmt|;
while|while
condition|(
name|remainingGangs
operator|>
literal|0
condition|)
block|{
comment|// If no durationInterval can fit a gang, break and return null
if|if
condition|(
name|durationIntervalsSortedByCost
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
break|break;
block|}
comment|// Get best duration interval
name|DurationInterval
name|bestDurationInterval
init|=
name|durationIntervalsSortedByCost
operator|.
name|first
argument_list|()
decl_stmt|;
name|int
name|numGangsToAllocate
init|=
name|Math
operator|.
name|min
argument_list|(
name|maxGangsPerUnit
argument_list|,
name|remainingGangs
argument_list|)
decl_stmt|;
name|numGangsToAllocate
operator|=
name|Math
operator|.
name|min
argument_list|(
name|numGangsToAllocate
argument_list|,
name|bestDurationInterval
operator|.
name|numCanFit
argument_list|()
argument_list|)
expr_stmt|;
comment|// Add it
name|remainingGangs
operator|-=
name|numGangsToAllocate
expr_stmt|;
name|ReservationInterval
name|reservationInt
init|=
operator|new
name|ReservationInterval
argument_list|(
name|bestDurationInterval
operator|.
name|getStartTime
argument_list|()
argument_list|,
name|bestDurationInterval
operator|.
name|getEndTime
argument_list|()
argument_list|)
decl_stmt|;
name|Resource
name|reservationRes
init|=
name|Resources
operator|.
name|multiply
argument_list|(
name|rr
operator|.
name|getCapability
argument_list|()
argument_list|,
name|rr
operator|.
name|getConcurrency
argument_list|()
operator|*
name|numGangsToAllocate
argument_list|)
decl_stmt|;
name|planModifications
operator|.
name|addInterval
argument_list|(
name|reservationInt
argument_list|,
name|reservationRes
argument_list|)
expr_stmt|;
name|allocationRequests
operator|.
name|addInterval
argument_list|(
name|reservationInt
argument_list|,
name|reservationRes
argument_list|)
expr_stmt|;
comment|// Remove from tree
name|durationIntervalsSortedByCost
operator|.
name|remove
argument_list|(
name|bestDurationInterval
argument_list|)
expr_stmt|;
comment|// Get updated interval
name|DurationInterval
name|updatedDurationInterval
init|=
name|getDurationInterval
argument_list|(
name|bestDurationInterval
operator|.
name|getStartTime
argument_list|()
argument_list|,
name|bestDurationInterval
operator|.
name|getStartTime
argument_list|()
operator|+
name|duration
argument_list|,
name|planLoads
argument_list|,
name|planModifications
argument_list|,
name|capacity
argument_list|,
name|netRLERes
argument_list|,
name|resCalc
argument_list|,
name|step
argument_list|,
name|gang
argument_list|)
decl_stmt|;
comment|// Add to tree, if possible
if|if
condition|(
name|updatedDurationInterval
operator|.
name|canAllocate
argument_list|()
condition|)
block|{
name|durationIntervalsSortedByCost
operator|.
name|add
argument_list|(
name|updatedDurationInterval
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Get the final allocation
name|Map
argument_list|<
name|ReservationInterval
argument_list|,
name|Resource
argument_list|>
name|allocations
init|=
name|allocationRequests
operator|.
name|toIntervalMap
argument_list|()
decl_stmt|;
comment|// If no gangs are left to place we succeed and return the allocation
if|if
condition|(
name|remainingGangs
operator|<=
literal|0
condition|)
block|{
return|return
name|allocations
return|;
block|}
else|else
block|{
comment|// If we are here is because we did not manage to satisfy this
comment|// request.
comment|// We remove unwanted side-effect from planModifications (needed for
comment|// ANY).
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ReservationInterval
argument_list|,
name|Resource
argument_list|>
name|tempAllocation
range|:
name|allocations
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|planModifications
operator|.
name|removeInterval
argument_list|(
name|tempAllocation
operator|.
name|getKey
argument_list|()
argument_list|,
name|tempAllocation
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Return null to signal failure in this allocation
return|return
literal|null
return|;
block|}
block|}
DECL|method|computeIntervalEndTimes (long stageEarliestStart, long stageDeadline, long duration)
specifier|private
name|List
argument_list|<
name|Long
argument_list|>
name|computeIntervalEndTimes
parameter_list|(
name|long
name|stageEarliestStart
parameter_list|,
name|long
name|stageDeadline
parameter_list|,
name|long
name|duration
parameter_list|)
block|{
name|List
argument_list|<
name|Long
argument_list|>
name|intervalEndTimes
init|=
operator|new
name|ArrayList
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|allocateLeft
condition|)
block|{
for|for
control|(
name|long
name|intervalEnd
init|=
name|stageDeadline
init|;
name|intervalEnd
operator|>=
name|stageEarliestStart
operator|+
name|duration
condition|;
name|intervalEnd
operator|-=
name|duration
control|)
block|{
name|intervalEndTimes
operator|.
name|add
argument_list|(
name|intervalEnd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|long
name|intervalStart
init|=
name|stageEarliestStart
init|;
name|intervalStart
operator|<=
name|stageDeadline
operator|-
name|duration
condition|;
name|intervalStart
operator|+=
name|duration
control|)
block|{
name|intervalEndTimes
operator|.
name|add
argument_list|(
name|intervalStart
operator|+
name|duration
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|intervalEndTimes
return|;
block|}
DECL|method|getDurationInterval (long startTime, long endTime, RLESparseResourceAllocation planLoads, RLESparseResourceAllocation planModifications, Resource capacity, RLESparseResourceAllocation netRLERes, ResourceCalculator resCalc, long step, Resource requestedResources)
specifier|protected
specifier|static
name|DurationInterval
name|getDurationInterval
parameter_list|(
name|long
name|startTime
parameter_list|,
name|long
name|endTime
parameter_list|,
name|RLESparseResourceAllocation
name|planLoads
parameter_list|,
name|RLESparseResourceAllocation
name|planModifications
parameter_list|,
name|Resource
name|capacity
parameter_list|,
name|RLESparseResourceAllocation
name|netRLERes
parameter_list|,
name|ResourceCalculator
name|resCalc
parameter_list|,
name|long
name|step
parameter_list|,
name|Resource
name|requestedResources
parameter_list|)
throws|throws
name|PlanningException
block|{
comment|// Get the total cost associated with the duration interval
name|double
name|totalCost
init|=
name|getDurationIntervalTotalCost
argument_list|(
name|startTime
argument_list|,
name|endTime
argument_list|,
name|planLoads
argument_list|,
name|planModifications
argument_list|,
name|capacity
argument_list|,
name|resCalc
argument_list|,
name|step
argument_list|)
decl_stmt|;
comment|// Calculate how many gangs can fit, i.e., how many times can 'capacity'
comment|// be allocated within the duration interval [startTime, endTime)
name|int
name|gangsCanFit
init|=
name|getDurationIntervalGangsCanFit
argument_list|(
name|startTime
argument_list|,
name|endTime
argument_list|,
name|planModifications
argument_list|,
name|capacity
argument_list|,
name|netRLERes
argument_list|,
name|resCalc
argument_list|,
name|requestedResources
argument_list|)
decl_stmt|;
comment|// Return the desired durationInterval
return|return
operator|new
name|DurationInterval
argument_list|(
name|startTime
argument_list|,
name|endTime
argument_list|,
name|totalCost
argument_list|,
name|gangsCanFit
argument_list|)
return|;
block|}
DECL|method|getDurationIntervalTotalCost (long startTime, long endTime, RLESparseResourceAllocation planLoads, RLESparseResourceAllocation planModifications, Resource capacity, ResourceCalculator resCalc, long step)
specifier|protected
specifier|static
name|double
name|getDurationIntervalTotalCost
parameter_list|(
name|long
name|startTime
parameter_list|,
name|long
name|endTime
parameter_list|,
name|RLESparseResourceAllocation
name|planLoads
parameter_list|,
name|RLESparseResourceAllocation
name|planModifications
parameter_list|,
name|Resource
name|capacity
parameter_list|,
name|ResourceCalculator
name|resCalc
parameter_list|,
name|long
name|step
parameter_list|)
throws|throws
name|PlanningException
block|{
comment|// Compute the current resource load within the interval [startTime,endTime)
comment|// by adding planLoads (existing load) and planModifications (load that
comment|// corresponds to the current job).
name|RLESparseResourceAllocation
name|currentLoad
init|=
name|RLESparseResourceAllocation
operator|.
name|merge
argument_list|(
name|resCalc
argument_list|,
name|capacity
argument_list|,
name|planLoads
argument_list|,
name|planModifications
argument_list|,
name|RLEOperator
operator|.
name|add
argument_list|,
name|startTime
argument_list|,
name|endTime
argument_list|)
decl_stmt|;
comment|// Convert load from RLESparseResourceAllocation to a Map representation
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|Resource
argument_list|>
name|mapCurrentLoad
init|=
name|currentLoad
operator|.
name|getCumulative
argument_list|()
decl_stmt|;
comment|// Initialize auxiliary variables
name|double
name|totalCost
init|=
literal|0.0
decl_stmt|;
name|Long
name|tPrev
init|=
operator|-
literal|1L
decl_stmt|;
name|Resource
name|loadPrev
init|=
name|Resources
operator|.
name|none
argument_list|()
decl_stmt|;
name|double
name|cost
init|=
literal|0.0
decl_stmt|;
comment|// Iterate over time points. For each point 't', accumulate the total cost
comment|// that corresponds to the interval [tPrev, t). The cost associated within
comment|// this interval is fixed for each of the time steps, therefore the cost of
comment|// a single step is multiplied by (t - tPrev) / step.
for|for
control|(
name|Entry
argument_list|<
name|Long
argument_list|,
name|Resource
argument_list|>
name|e
range|:
name|mapCurrentLoad
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Long
name|t
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Resource
name|load
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|tPrev
operator|!=
operator|-
literal|1L
condition|)
block|{
name|tPrev
operator|=
name|Math
operator|.
name|max
argument_list|(
name|tPrev
argument_list|,
name|startTime
argument_list|)
expr_stmt|;
name|cost
operator|=
name|calcCostOfLoad
argument_list|(
name|loadPrev
argument_list|,
name|capacity
argument_list|,
name|resCalc
argument_list|)
expr_stmt|;
name|totalCost
operator|=
name|totalCost
operator|+
name|cost
operator|*
operator|(
name|t
operator|-
name|tPrev
operator|)
operator|/
name|step
expr_stmt|;
block|}
name|tPrev
operator|=
name|t
expr_stmt|;
name|loadPrev
operator|=
name|load
expr_stmt|;
block|}
comment|// Add the cost associated with the last interval (the for loop does not
comment|// calculate it).
if|if
condition|(
name|loadPrev
operator|!=
literal|null
condition|)
block|{
comment|// This takes care of the corner case of a single entry
name|tPrev
operator|=
name|Math
operator|.
name|max
argument_list|(
name|tPrev
argument_list|,
name|startTime
argument_list|)
expr_stmt|;
name|cost
operator|=
name|calcCostOfLoad
argument_list|(
name|loadPrev
argument_list|,
name|capacity
argument_list|,
name|resCalc
argument_list|)
expr_stmt|;
name|totalCost
operator|=
name|totalCost
operator|+
name|cost
operator|*
operator|(
name|endTime
operator|-
name|tPrev
operator|)
operator|/
name|step
expr_stmt|;
block|}
comment|// Return the overall cost
return|return
name|totalCost
return|;
block|}
DECL|method|getDurationIntervalGangsCanFit (long startTime, long endTime, RLESparseResourceAllocation planModifications, Resource capacity, RLESparseResourceAllocation netRLERes, ResourceCalculator resCalc, Resource requestedResources)
specifier|protected
specifier|static
name|int
name|getDurationIntervalGangsCanFit
parameter_list|(
name|long
name|startTime
parameter_list|,
name|long
name|endTime
parameter_list|,
name|RLESparseResourceAllocation
name|planModifications
parameter_list|,
name|Resource
name|capacity
parameter_list|,
name|RLESparseResourceAllocation
name|netRLERes
parameter_list|,
name|ResourceCalculator
name|resCalc
parameter_list|,
name|Resource
name|requestedResources
parameter_list|)
throws|throws
name|PlanningException
block|{
comment|// Initialize auxiliary variables
name|int
name|gangsCanFit
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
name|int
name|curGangsCanFit
decl_stmt|;
comment|// Calculate the total amount of available resources between startTime
comment|// and endTime, by subtracting planModifications from netRLERes
name|RLESparseResourceAllocation
name|netAvailableResources
init|=
name|RLESparseResourceAllocation
operator|.
name|merge
argument_list|(
name|resCalc
argument_list|,
name|capacity
argument_list|,
name|netRLERes
argument_list|,
name|planModifications
argument_list|,
name|RLEOperator
operator|.
name|subtractTestNonNegative
argument_list|,
name|startTime
argument_list|,
name|endTime
argument_list|)
decl_stmt|;
comment|// Convert result to a map
name|NavigableMap
argument_list|<
name|Long
argument_list|,
name|Resource
argument_list|>
name|mapAvailableCapacity
init|=
name|netAvailableResources
operator|.
name|getCumulative
argument_list|()
decl_stmt|;
comment|// Iterate over the map representation.
comment|// At each point, calculate how many times does 'requestedResources' fit.
comment|// The result is the minimum over all time points.
for|for
control|(
name|Entry
argument_list|<
name|Long
argument_list|,
name|Resource
argument_list|>
name|e
range|:
name|mapAvailableCapacity
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Long
name|t
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Resource
name|curAvailable
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|>=
name|endTime
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|curAvailable
operator|==
literal|null
condition|)
block|{
name|gangsCanFit
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|curGangsCanFit
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|Resources
operator|.
name|divide
argument_list|(
name|resCalc
argument_list|,
name|capacity
argument_list|,
name|curAvailable
argument_list|,
name|requestedResources
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|curGangsCanFit
operator|<
name|gangsCanFit
condition|)
block|{
name|gangsCanFit
operator|=
name|curGangsCanFit
expr_stmt|;
block|}
block|}
block|}
return|return
name|gangsCanFit
return|;
block|}
DECL|method|calcCostOfInterval (long startTime, long endTime, RLESparseResourceAllocation planLoads, RLESparseResourceAllocation planModifications, Resource capacity, ResourceCalculator resCalc, long step)
specifier|protected
name|double
name|calcCostOfInterval
parameter_list|(
name|long
name|startTime
parameter_list|,
name|long
name|endTime
parameter_list|,
name|RLESparseResourceAllocation
name|planLoads
parameter_list|,
name|RLESparseResourceAllocation
name|planModifications
parameter_list|,
name|Resource
name|capacity
parameter_list|,
name|ResourceCalculator
name|resCalc
parameter_list|,
name|long
name|step
parameter_list|)
block|{
comment|// Sum costs in the interval [startTime,endTime)
name|double
name|totalCost
init|=
literal|0.0
decl_stmt|;
for|for
control|(
name|long
name|t
init|=
name|startTime
init|;
name|t
operator|<
name|endTime
condition|;
name|t
operator|+=
name|step
control|)
block|{
name|totalCost
operator|+=
name|calcCostOfTimeSlot
argument_list|(
name|t
argument_list|,
name|planLoads
argument_list|,
name|planModifications
argument_list|,
name|capacity
argument_list|,
name|resCalc
argument_list|)
expr_stmt|;
block|}
comment|// Return sum
return|return
name|totalCost
return|;
block|}
DECL|method|calcCostOfTimeSlot (long t, RLESparseResourceAllocation planLoads, RLESparseResourceAllocation planModifications, Resource capacity, ResourceCalculator resCalc)
specifier|protected
name|double
name|calcCostOfTimeSlot
parameter_list|(
name|long
name|t
parameter_list|,
name|RLESparseResourceAllocation
name|planLoads
parameter_list|,
name|RLESparseResourceAllocation
name|planModifications
parameter_list|,
name|Resource
name|capacity
parameter_list|,
name|ResourceCalculator
name|resCalc
parameter_list|)
block|{
comment|// Get the current load at time t
name|Resource
name|load
init|=
name|getLoadAtTime
argument_list|(
name|t
argument_list|,
name|planLoads
argument_list|,
name|planModifications
argument_list|)
decl_stmt|;
comment|// Return cost
return|return
name|calcCostOfLoad
argument_list|(
name|load
argument_list|,
name|capacity
argument_list|,
name|resCalc
argument_list|)
return|;
block|}
DECL|method|getLoadAtTime (long t, RLESparseResourceAllocation planLoads, RLESparseResourceAllocation planModifications)
specifier|protected
name|Resource
name|getLoadAtTime
parameter_list|(
name|long
name|t
parameter_list|,
name|RLESparseResourceAllocation
name|planLoads
parameter_list|,
name|RLESparseResourceAllocation
name|planModifications
parameter_list|)
block|{
name|Resource
name|planLoad
init|=
name|planLoads
operator|.
name|getCapacityAtTime
argument_list|(
name|t
argument_list|)
decl_stmt|;
return|return
name|Resources
operator|.
name|add
argument_list|(
name|planLoad
argument_list|,
name|planModifications
operator|.
name|getCapacityAtTime
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
DECL|method|calcCostOfLoad (Resource load, Resource capacity, ResourceCalculator resCalc)
specifier|protected
specifier|static
name|double
name|calcCostOfLoad
parameter_list|(
name|Resource
name|load
parameter_list|,
name|Resource
name|capacity
parameter_list|,
name|ResourceCalculator
name|resCalc
parameter_list|)
block|{
return|return
name|resCalc
operator|.
name|ratio
argument_list|(
name|load
argument_list|,
name|capacity
argument_list|)
return|;
block|}
DECL|method|stepRoundDown (long t, long step)
specifier|protected
specifier|static
name|long
name|stepRoundDown
parameter_list|(
name|long
name|t
parameter_list|,
name|long
name|step
parameter_list|)
block|{
return|return
operator|(
name|t
operator|/
name|step
operator|)
operator|*
name|step
return|;
block|}
DECL|method|stepRoundUp (long t, long step)
specifier|protected
specifier|static
name|long
name|stepRoundUp
parameter_list|(
name|long
name|t
parameter_list|,
name|long
name|step
parameter_list|)
block|{
return|return
operator|(
operator|(
name|t
operator|+
name|step
operator|-
literal|1
operator|)
operator|/
name|step
operator|)
operator|*
name|step
return|;
block|}
comment|/**    * An inner class that represents an interval, typically of length duration.    * The class holds the total cost of the interval and the maximal load inside    * the interval in each dimension (both calculated externally).    */
DECL|class|DurationInterval
specifier|protected
specifier|static
class|class
name|DurationInterval
block|{
DECL|field|startTime
specifier|private
name|long
name|startTime
decl_stmt|;
DECL|field|endTime
specifier|private
name|long
name|endTime
decl_stmt|;
DECL|field|cost
specifier|private
name|double
name|cost
decl_stmt|;
DECL|field|gangsCanFit
specifier|private
specifier|final
name|int
name|gangsCanFit
decl_stmt|;
comment|// Constructor
DECL|method|DurationInterval (long startTime, long endTime, double cost, int gangsCanfit)
specifier|public
name|DurationInterval
parameter_list|(
name|long
name|startTime
parameter_list|,
name|long
name|endTime
parameter_list|,
name|double
name|cost
parameter_list|,
name|int
name|gangsCanfit
parameter_list|)
block|{
name|this
operator|.
name|startTime
operator|=
name|startTime
expr_stmt|;
name|this
operator|.
name|endTime
operator|=
name|endTime
expr_stmt|;
name|this
operator|.
name|cost
operator|=
name|cost
expr_stmt|;
name|this
operator|.
name|gangsCanFit
operator|=
name|gangsCanfit
expr_stmt|;
block|}
comment|// canAllocate() - boolean function, returns whether requestedResources
comment|// can be allocated during the durationInterval without
comment|// violating capacity constraints
DECL|method|canAllocate ()
specifier|public
name|boolean
name|canAllocate
parameter_list|()
block|{
return|return
operator|(
name|gangsCanFit
operator|>
literal|0
operator|)
return|;
block|}
comment|// numCanFit() - returns the maximal number of requestedResources can be
comment|// allocated during the durationInterval without violating
comment|// capacity constraints
DECL|method|numCanFit ()
specifier|public
name|int
name|numCanFit
parameter_list|()
block|{
return|return
name|gangsCanFit
return|;
block|}
DECL|method|getStartTime ()
specifier|public
name|long
name|getStartTime
parameter_list|()
block|{
return|return
name|this
operator|.
name|startTime
return|;
block|}
DECL|method|setStartTime (long value)
specifier|public
name|void
name|setStartTime
parameter_list|(
name|long
name|value
parameter_list|)
block|{
name|this
operator|.
name|startTime
operator|=
name|value
expr_stmt|;
block|}
DECL|method|getEndTime ()
specifier|public
name|long
name|getEndTime
parameter_list|()
block|{
return|return
name|this
operator|.
name|endTime
return|;
block|}
DECL|method|setEndTime (long value)
specifier|public
name|void
name|setEndTime
parameter_list|(
name|long
name|value
parameter_list|)
block|{
name|this
operator|.
name|endTime
operator|=
name|value
expr_stmt|;
block|}
DECL|method|getTotalCost ()
specifier|public
name|double
name|getTotalCost
parameter_list|()
block|{
return|return
name|this
operator|.
name|cost
return|;
block|}
DECL|method|setTotalCost (double value)
specifier|public
name|void
name|setTotalCost
parameter_list|(
name|double
name|value
parameter_list|)
block|{
name|this
operator|.
name|cost
operator|=
name|value
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|" start: "
operator|+
name|startTime
argument_list|)
operator|.
name|append
argument_list|(
literal|" end: "
operator|+
name|endTime
argument_list|)
operator|.
name|append
argument_list|(
literal|" cost: "
operator|+
name|cost
argument_list|)
operator|.
name|append
argument_list|(
literal|" gangsCanFit: "
operator|+
name|gangsCanFit
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

