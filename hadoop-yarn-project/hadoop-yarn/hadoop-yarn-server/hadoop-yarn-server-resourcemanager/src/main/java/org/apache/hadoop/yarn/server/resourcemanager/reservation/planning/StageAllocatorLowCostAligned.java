begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.resourcemanager.reservation.planning
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|reservation
operator|.
name|planning
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ReservationRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|reservation
operator|.
name|Plan
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|reservation
operator|.
name|RLESparseResourceAllocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|reservation
operator|.
name|ReservationInterval
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|ResourceCalculator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|Resources
import|;
end_import

begin_comment
comment|/**  * A stage allocator that iteratively allocates containers in the  * {@link DurationInterval} with lowest overall cost. The algorithm only  * considers intervals of the form: [stageDeadline - (n+1)*duration,  * stageDeadline - n*duration) for an integer n. This guarantees that the  * allocations are aligned (as opposed to overlapping duration intervals).  *  * The smoothnessFactor parameter controls the number of containers that are  * simultaneously allocated in each iteration of the algorithm.  */
end_comment

begin_class
DECL|class|StageAllocatorLowCostAligned
specifier|public
class|class
name|StageAllocatorLowCostAligned
implements|implements
name|StageAllocator
block|{
comment|// Smoothness factor
DECL|field|smoothnessFactor
specifier|private
name|int
name|smoothnessFactor
init|=
literal|10
decl_stmt|;
comment|// Constructor
DECL|method|StageAllocatorLowCostAligned ()
specifier|public
name|StageAllocatorLowCostAligned
parameter_list|()
block|{   }
comment|// Constructor
DECL|method|StageAllocatorLowCostAligned (int smoothnessFactor)
specifier|public
name|StageAllocatorLowCostAligned
parameter_list|(
name|int
name|smoothnessFactor
parameter_list|)
block|{
name|this
operator|.
name|smoothnessFactor
operator|=
name|smoothnessFactor
expr_stmt|;
block|}
comment|// computeJobAllocation()
annotation|@
name|Override
DECL|method|computeStageAllocation ( Plan plan, Map<Long, Resource> planLoads, RLESparseResourceAllocation planModifications, ReservationRequest rr, long stageEarliestStart, long stageDeadline)
specifier|public
name|Map
argument_list|<
name|ReservationInterval
argument_list|,
name|Resource
argument_list|>
name|computeStageAllocation
parameter_list|(
name|Plan
name|plan
parameter_list|,
name|Map
argument_list|<
name|Long
argument_list|,
name|Resource
argument_list|>
name|planLoads
parameter_list|,
name|RLESparseResourceAllocation
name|planModifications
parameter_list|,
name|ReservationRequest
name|rr
parameter_list|,
name|long
name|stageEarliestStart
parameter_list|,
name|long
name|stageDeadline
parameter_list|)
block|{
comment|// Initialize
name|ResourceCalculator
name|resCalc
init|=
name|plan
operator|.
name|getResourceCalculator
argument_list|()
decl_stmt|;
name|Resource
name|capacity
init|=
name|plan
operator|.
name|getTotalCapacity
argument_list|()
decl_stmt|;
name|long
name|step
init|=
name|plan
operator|.
name|getStep
argument_list|()
decl_stmt|;
comment|// Create allocationRequestsearlies
name|RLESparseResourceAllocation
name|allocationRequests
init|=
operator|new
name|RLESparseResourceAllocation
argument_list|(
name|plan
operator|.
name|getResourceCalculator
argument_list|()
argument_list|)
decl_stmt|;
comment|// Initialize parameters
name|long
name|duration
init|=
name|stepRoundUp
argument_list|(
name|rr
operator|.
name|getDuration
argument_list|()
argument_list|,
name|step
argument_list|)
decl_stmt|;
name|int
name|windowSizeInDurations
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|stageDeadline
operator|-
name|stageEarliestStart
operator|)
operator|/
name|duration
argument_list|)
decl_stmt|;
name|int
name|totalGangs
init|=
name|rr
operator|.
name|getNumContainers
argument_list|()
operator|/
name|rr
operator|.
name|getConcurrency
argument_list|()
decl_stmt|;
name|int
name|numContainersPerGang
init|=
name|rr
operator|.
name|getConcurrency
argument_list|()
decl_stmt|;
name|Resource
name|gang
init|=
name|Resources
operator|.
name|multiply
argument_list|(
name|rr
operator|.
name|getCapability
argument_list|()
argument_list|,
name|numContainersPerGang
argument_list|)
decl_stmt|;
comment|// Set maxGangsPerUnit
name|int
name|maxGangsPerUnit
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|max
argument_list|(
name|Math
operator|.
name|floor
argument_list|(
operator|(
operator|(
name|double
operator|)
name|totalGangs
operator|)
operator|/
name|windowSizeInDurations
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|maxGangsPerUnit
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxGangsPerUnit
operator|/
name|smoothnessFactor
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// If window size is too small, return null
if|if
condition|(
name|windowSizeInDurations
operator|<=
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Initialize tree sorted by costs
name|TreeSet
argument_list|<
name|DurationInterval
argument_list|>
name|durationIntervalsSortedByCost
init|=
operator|new
name|TreeSet
argument_list|<
name|DurationInterval
argument_list|>
argument_list|(
operator|new
name|Comparator
argument_list|<
name|DurationInterval
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|DurationInterval
name|val1
parameter_list|,
name|DurationInterval
name|val2
parameter_list|)
block|{
name|int
name|cmp
init|=
name|Double
operator|.
name|compare
argument_list|(
name|val1
operator|.
name|getTotalCost
argument_list|()
argument_list|,
name|val2
operator|.
name|getTotalCost
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|!=
literal|0
condition|)
block|{
return|return
name|cmp
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
operator|*
name|Long
operator|.
name|compare
argument_list|(
name|val1
operator|.
name|getEndTime
argument_list|()
argument_list|,
name|val2
operator|.
name|getEndTime
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
comment|// Add durationIntervals that end at (endTime - n*duration) for some n.
for|for
control|(
name|long
name|intervalEnd
init|=
name|stageDeadline
init|;
name|intervalEnd
operator|>=
name|stageEarliestStart
operator|+
name|duration
condition|;
name|intervalEnd
operator|-=
name|duration
control|)
block|{
name|long
name|intervalStart
init|=
name|intervalEnd
operator|-
name|duration
decl_stmt|;
comment|// Get duration interval [intervalStart,intervalEnd)
name|DurationInterval
name|durationInterval
init|=
name|getDurationInterval
argument_list|(
name|intervalStart
argument_list|,
name|intervalEnd
argument_list|,
name|planLoads
argument_list|,
name|planModifications
argument_list|,
name|capacity
argument_list|,
name|resCalc
argument_list|,
name|step
argument_list|)
decl_stmt|;
comment|// If the interval can fit a gang, add it to the tree
if|if
condition|(
name|durationInterval
operator|.
name|canAllocate
argument_list|(
name|gang
argument_list|,
name|capacity
argument_list|,
name|resCalc
argument_list|)
condition|)
block|{
name|durationIntervalsSortedByCost
operator|.
name|add
argument_list|(
name|durationInterval
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Allocate
name|int
name|remainingGangs
init|=
name|totalGangs
decl_stmt|;
while|while
condition|(
name|remainingGangs
operator|>
literal|0
condition|)
block|{
comment|// If no durationInterval can fit a gang, break and return null
if|if
condition|(
name|durationIntervalsSortedByCost
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
break|break;
block|}
comment|// Get best duration interval
name|DurationInterval
name|bestDurationInterval
init|=
name|durationIntervalsSortedByCost
operator|.
name|first
argument_list|()
decl_stmt|;
name|int
name|numGangsToAllocate
init|=
name|Math
operator|.
name|min
argument_list|(
name|maxGangsPerUnit
argument_list|,
name|remainingGangs
argument_list|)
decl_stmt|;
comment|// Add it
name|remainingGangs
operator|-=
name|numGangsToAllocate
expr_stmt|;
name|ReservationInterval
name|reservationInt
init|=
operator|new
name|ReservationInterval
argument_list|(
name|bestDurationInterval
operator|.
name|getStartTime
argument_list|()
argument_list|,
name|bestDurationInterval
operator|.
name|getEndTime
argument_list|()
argument_list|)
decl_stmt|;
name|Resource
name|reservationRes
init|=
name|Resources
operator|.
name|multiply
argument_list|(
name|rr
operator|.
name|getCapability
argument_list|()
argument_list|,
name|rr
operator|.
name|getConcurrency
argument_list|()
operator|*
name|numGangsToAllocate
argument_list|)
decl_stmt|;
name|planModifications
operator|.
name|addInterval
argument_list|(
name|reservationInt
argument_list|,
name|reservationRes
argument_list|)
expr_stmt|;
name|allocationRequests
operator|.
name|addInterval
argument_list|(
name|reservationInt
argument_list|,
name|reservationRes
argument_list|)
expr_stmt|;
comment|// Remove from tree
name|durationIntervalsSortedByCost
operator|.
name|remove
argument_list|(
name|bestDurationInterval
argument_list|)
expr_stmt|;
comment|// Get updated interval
name|DurationInterval
name|updatedDurationInterval
init|=
name|getDurationInterval
argument_list|(
name|bestDurationInterval
operator|.
name|getStartTime
argument_list|()
argument_list|,
name|bestDurationInterval
operator|.
name|getStartTime
argument_list|()
operator|+
name|duration
argument_list|,
name|planLoads
argument_list|,
name|planModifications
argument_list|,
name|capacity
argument_list|,
name|resCalc
argument_list|,
name|step
argument_list|)
decl_stmt|;
comment|// Add to tree, if possible
if|if
condition|(
name|updatedDurationInterval
operator|.
name|canAllocate
argument_list|(
name|gang
argument_list|,
name|capacity
argument_list|,
name|resCalc
argument_list|)
condition|)
block|{
name|durationIntervalsSortedByCost
operator|.
name|add
argument_list|(
name|updatedDurationInterval
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Get the final allocation
name|Map
argument_list|<
name|ReservationInterval
argument_list|,
name|Resource
argument_list|>
name|allocations
init|=
name|allocationRequests
operator|.
name|toIntervalMap
argument_list|()
decl_stmt|;
comment|// If no gangs are left to place we succeed and return the allocation
if|if
condition|(
name|remainingGangs
operator|<=
literal|0
condition|)
block|{
return|return
name|allocations
return|;
block|}
else|else
block|{
comment|// If we are here is because we did not manage to satisfy this request.
comment|// We remove unwanted side-effect from planModifications (needed for ANY).
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ReservationInterval
argument_list|,
name|Resource
argument_list|>
name|tempAllocation
range|:
name|allocations
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|planModifications
operator|.
name|removeInterval
argument_list|(
name|tempAllocation
operator|.
name|getKey
argument_list|()
argument_list|,
name|tempAllocation
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Return null to signal failure in this allocation
return|return
literal|null
return|;
block|}
block|}
DECL|method|getDurationInterval (long startTime, long endTime, Map<Long, Resource> planLoads, RLESparseResourceAllocation planModifications, Resource capacity, ResourceCalculator resCalc, long step)
specifier|protected
name|DurationInterval
name|getDurationInterval
parameter_list|(
name|long
name|startTime
parameter_list|,
name|long
name|endTime
parameter_list|,
name|Map
argument_list|<
name|Long
argument_list|,
name|Resource
argument_list|>
name|planLoads
parameter_list|,
name|RLESparseResourceAllocation
name|planModifications
parameter_list|,
name|Resource
name|capacity
parameter_list|,
name|ResourceCalculator
name|resCalc
parameter_list|,
name|long
name|step
parameter_list|)
block|{
comment|// Initialize the dominant loads structure
name|Resource
name|dominantResources
init|=
name|Resource
operator|.
name|newInstance
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// Calculate totalCost and maxLoad
name|double
name|totalCost
init|=
literal|0.0
decl_stmt|;
for|for
control|(
name|long
name|t
init|=
name|startTime
init|;
name|t
operator|<
name|endTime
condition|;
name|t
operator|+=
name|step
control|)
block|{
comment|// Get the load
name|Resource
name|load
init|=
name|getLoadAtTime
argument_list|(
name|t
argument_list|,
name|planLoads
argument_list|,
name|planModifications
argument_list|)
decl_stmt|;
comment|// Increase the total cost
name|totalCost
operator|+=
name|calcCostOfLoad
argument_list|(
name|load
argument_list|,
name|capacity
argument_list|,
name|resCalc
argument_list|)
expr_stmt|;
comment|// Update the dominant resources
name|dominantResources
operator|=
name|Resources
operator|.
name|componentwiseMax
argument_list|(
name|dominantResources
argument_list|,
name|load
argument_list|)
expr_stmt|;
block|}
comment|// Return the corresponding durationInterval
return|return
operator|new
name|DurationInterval
argument_list|(
name|startTime
argument_list|,
name|endTime
argument_list|,
name|totalCost
argument_list|,
name|dominantResources
argument_list|)
return|;
block|}
DECL|method|calcCostOfInterval (long startTime, long endTime, Map<Long, Resource> planLoads, RLESparseResourceAllocation planModifications, Resource capacity, ResourceCalculator resCalc, long step)
specifier|protected
name|double
name|calcCostOfInterval
parameter_list|(
name|long
name|startTime
parameter_list|,
name|long
name|endTime
parameter_list|,
name|Map
argument_list|<
name|Long
argument_list|,
name|Resource
argument_list|>
name|planLoads
parameter_list|,
name|RLESparseResourceAllocation
name|planModifications
parameter_list|,
name|Resource
name|capacity
parameter_list|,
name|ResourceCalculator
name|resCalc
parameter_list|,
name|long
name|step
parameter_list|)
block|{
comment|// Sum costs in the interval [startTime,endTime)
name|double
name|totalCost
init|=
literal|0.0
decl_stmt|;
for|for
control|(
name|long
name|t
init|=
name|startTime
init|;
name|t
operator|<
name|endTime
condition|;
name|t
operator|+=
name|step
control|)
block|{
name|totalCost
operator|+=
name|calcCostOfTimeSlot
argument_list|(
name|t
argument_list|,
name|planLoads
argument_list|,
name|planModifications
argument_list|,
name|capacity
argument_list|,
name|resCalc
argument_list|)
expr_stmt|;
block|}
comment|// Return sum
return|return
name|totalCost
return|;
block|}
DECL|method|calcCostOfTimeSlot (long t, Map<Long, Resource> planLoads, RLESparseResourceAllocation planModifications, Resource capacity, ResourceCalculator resCalc)
specifier|protected
name|double
name|calcCostOfTimeSlot
parameter_list|(
name|long
name|t
parameter_list|,
name|Map
argument_list|<
name|Long
argument_list|,
name|Resource
argument_list|>
name|planLoads
parameter_list|,
name|RLESparseResourceAllocation
name|planModifications
parameter_list|,
name|Resource
name|capacity
parameter_list|,
name|ResourceCalculator
name|resCalc
parameter_list|)
block|{
comment|// Get the current load at time t
name|Resource
name|load
init|=
name|getLoadAtTime
argument_list|(
name|t
argument_list|,
name|planLoads
argument_list|,
name|planModifications
argument_list|)
decl_stmt|;
comment|// Return cost
return|return
name|calcCostOfLoad
argument_list|(
name|load
argument_list|,
name|capacity
argument_list|,
name|resCalc
argument_list|)
return|;
block|}
DECL|method|getLoadAtTime (long t, Map<Long, Resource> planLoads, RLESparseResourceAllocation planModifications)
specifier|protected
name|Resource
name|getLoadAtTime
parameter_list|(
name|long
name|t
parameter_list|,
name|Map
argument_list|<
name|Long
argument_list|,
name|Resource
argument_list|>
name|planLoads
parameter_list|,
name|RLESparseResourceAllocation
name|planModifications
parameter_list|)
block|{
name|Resource
name|planLoad
init|=
name|planLoads
operator|.
name|get
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|planLoad
operator|=
operator|(
name|planLoad
operator|==
literal|null
operator|)
condition|?
name|Resource
operator|.
name|newInstance
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
else|:
name|planLoad
expr_stmt|;
return|return
name|Resources
operator|.
name|add
argument_list|(
name|planLoad
argument_list|,
name|planModifications
operator|.
name|getCapacityAtTime
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
DECL|method|calcCostOfLoad (Resource load, Resource capacity, ResourceCalculator resCalc)
specifier|protected
name|double
name|calcCostOfLoad
parameter_list|(
name|Resource
name|load
parameter_list|,
name|Resource
name|capacity
parameter_list|,
name|ResourceCalculator
name|resCalc
parameter_list|)
block|{
return|return
name|resCalc
operator|.
name|ratio
argument_list|(
name|load
argument_list|,
name|capacity
argument_list|)
return|;
block|}
DECL|method|stepRoundDown (long t, long step)
specifier|protected
specifier|static
name|long
name|stepRoundDown
parameter_list|(
name|long
name|t
parameter_list|,
name|long
name|step
parameter_list|)
block|{
return|return
operator|(
name|t
operator|/
name|step
operator|)
operator|*
name|step
return|;
block|}
DECL|method|stepRoundUp (long t, long step)
specifier|protected
specifier|static
name|long
name|stepRoundUp
parameter_list|(
name|long
name|t
parameter_list|,
name|long
name|step
parameter_list|)
block|{
return|return
operator|(
operator|(
name|t
operator|+
name|step
operator|-
literal|1
operator|)
operator|/
name|step
operator|)
operator|*
name|step
return|;
block|}
comment|/**    * An inner class that represents an interval, typically of length duration.    * The class holds the total cost of the interval and the maximal load inside    * the interval in each dimension (both calculated externally).    */
DECL|class|DurationInterval
specifier|protected
specifier|static
class|class
name|DurationInterval
block|{
DECL|field|startTime
specifier|private
name|long
name|startTime
decl_stmt|;
DECL|field|endTime
specifier|private
name|long
name|endTime
decl_stmt|;
DECL|field|cost
specifier|private
name|double
name|cost
decl_stmt|;
DECL|field|maxLoad
specifier|private
name|Resource
name|maxLoad
decl_stmt|;
comment|// Constructor
DECL|method|DurationInterval (long startTime, long endTime, double cost, Resource maxLoad)
specifier|public
name|DurationInterval
parameter_list|(
name|long
name|startTime
parameter_list|,
name|long
name|endTime
parameter_list|,
name|double
name|cost
parameter_list|,
name|Resource
name|maxLoad
parameter_list|)
block|{
name|this
operator|.
name|startTime
operator|=
name|startTime
expr_stmt|;
name|this
operator|.
name|endTime
operator|=
name|endTime
expr_stmt|;
name|this
operator|.
name|cost
operator|=
name|cost
expr_stmt|;
name|this
operator|.
name|maxLoad
operator|=
name|maxLoad
expr_stmt|;
block|}
comment|// canAllocate() - boolean function, returns whether requestedResources
comment|// can be allocated during the durationInterval without
comment|// violating capacity constraints
DECL|method|canAllocate (Resource requestedResources, Resource capacity, ResourceCalculator resCalc)
specifier|public
name|boolean
name|canAllocate
parameter_list|(
name|Resource
name|requestedResources
parameter_list|,
name|Resource
name|capacity
parameter_list|,
name|ResourceCalculator
name|resCalc
parameter_list|)
block|{
name|Resource
name|updatedMaxLoad
init|=
name|Resources
operator|.
name|add
argument_list|(
name|maxLoad
argument_list|,
name|requestedResources
argument_list|)
decl_stmt|;
return|return
operator|(
name|resCalc
operator|.
name|compare
argument_list|(
name|capacity
argument_list|,
name|updatedMaxLoad
argument_list|,
name|capacity
argument_list|)
operator|<=
literal|0
operator|)
return|;
block|}
comment|// numCanFit() - returns the maximal number of requestedResources can be
comment|// allocated during the durationInterval without violating
comment|// capacity constraints
DECL|method|numCanFit (Resource requestedResources, Resource capacity, ResourceCalculator resCalc)
specifier|public
name|int
name|numCanFit
parameter_list|(
name|Resource
name|requestedResources
parameter_list|,
name|Resource
name|capacity
parameter_list|,
name|ResourceCalculator
name|resCalc
parameter_list|)
block|{
comment|// Represents the largest resource demand that can be satisfied throughout
comment|// the entire DurationInterval (i.e., during [startTime,endTime))
name|Resource
name|availableResources
init|=
name|Resources
operator|.
name|subtract
argument_list|(
name|capacity
argument_list|,
name|maxLoad
argument_list|)
decl_stmt|;
comment|// Maximal number of requestedResources that fit inside the interval
return|return
operator|(
name|int
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|Resources
operator|.
name|divide
argument_list|(
name|resCalc
argument_list|,
name|capacity
argument_list|,
name|availableResources
argument_list|,
name|requestedResources
argument_list|)
argument_list|)
return|;
block|}
DECL|method|getStartTime ()
specifier|public
name|long
name|getStartTime
parameter_list|()
block|{
return|return
name|this
operator|.
name|startTime
return|;
block|}
DECL|method|setStartTime (long value)
specifier|public
name|void
name|setStartTime
parameter_list|(
name|long
name|value
parameter_list|)
block|{
name|this
operator|.
name|startTime
operator|=
name|value
expr_stmt|;
block|}
DECL|method|getEndTime ()
specifier|public
name|long
name|getEndTime
parameter_list|()
block|{
return|return
name|this
operator|.
name|endTime
return|;
block|}
DECL|method|setEndTime (long value)
specifier|public
name|void
name|setEndTime
parameter_list|(
name|long
name|value
parameter_list|)
block|{
name|this
operator|.
name|endTime
operator|=
name|value
expr_stmt|;
block|}
DECL|method|getMaxLoad ()
specifier|public
name|Resource
name|getMaxLoad
parameter_list|()
block|{
return|return
name|this
operator|.
name|maxLoad
return|;
block|}
DECL|method|setMaxLoad (Resource value)
specifier|public
name|void
name|setMaxLoad
parameter_list|(
name|Resource
name|value
parameter_list|)
block|{
name|this
operator|.
name|maxLoad
operator|=
name|value
expr_stmt|;
block|}
DECL|method|getTotalCost ()
specifier|public
name|double
name|getTotalCost
parameter_list|()
block|{
return|return
name|this
operator|.
name|cost
return|;
block|}
DECL|method|setTotalCost (double value)
specifier|public
name|void
name|setTotalCost
parameter_list|(
name|double
name|value
parameter_list|)
block|{
name|this
operator|.
name|cost
operator|=
name|value
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

