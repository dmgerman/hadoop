begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/** * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.resourcemanager.scheduler
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|time
operator|.
name|DateUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|time
operator|.
name|FastDateFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|Private
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
operator|.
name|Stable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
operator|.
name|Unstable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationAttemptId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationResourceUsageReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationSubmissionContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Container
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerUpdateType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ExecutionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|LogAggregationContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|NMToken
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|NodeId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Priority
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ResourceInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ResourceRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|SchedulingRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|UpdateContainerError
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|nodelabels
operator|.
name|CommonNodeLabelsManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|api
operator|.
name|ContainerType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|RMContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|RMServerUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|nodelabels
operator|.
name|RMNodeLabelsManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|RMApp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|attempt
operator|.
name|AggregateAppResourceUsage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|attempt
operator|.
name|RMAppAttempt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|attempt
operator|.
name|RMAppAttemptState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainerEventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainerImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainerReservedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainerState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainerUpdatesAcquiredEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmnode
operator|.
name|RMNodeCleanContainerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmnode
operator|.
name|RMNodeUpdateContainerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|SchedulingMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|ContainerRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|PendingAsk
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|placement
operator|.
name|AppPlacementAllocator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|policy
operator|.
name|SchedulableEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|scheduler
operator|.
name|OpportunisticContainerContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|scheduler
operator|.
name|SchedulerRequestKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|state
operator|.
name|InvalidStateTransitionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|ResourceCalculator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|Resources
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ConcurrentHashMultiset
import|;
end_import

begin_comment
comment|/**  * Represents an application attempt from the viewpoint of the scheduler.  * Each running app attempt in the RM corresponds to one instance  * of this class.  */
end_comment

begin_class
annotation|@
name|Private
annotation|@
name|Unstable
DECL|class|SchedulerApplicationAttempt
specifier|public
class|class
name|SchedulerApplicationAttempt
implements|implements
name|SchedulableEntity
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SchedulerApplicationAttempt
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|fdf
specifier|private
name|FastDateFormat
name|fdf
init|=
name|FastDateFormat
operator|.
name|getInstance
argument_list|(
literal|"EEE MMM dd HH:mm:ss Z yyyy"
argument_list|)
decl_stmt|;
DECL|field|MEM_AGGREGATE_ALLOCATION_CACHE_MSECS
specifier|private
specifier|static
specifier|final
name|long
name|MEM_AGGREGATE_ALLOCATION_CACHE_MSECS
init|=
literal|3000
decl_stmt|;
DECL|field|lastMemoryAggregateAllocationUpdateTime
specifier|protected
name|long
name|lastMemoryAggregateAllocationUpdateTime
init|=
literal|0
decl_stmt|;
DECL|field|lastResourceSecondsMap
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|lastResourceSecondsMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|appSchedulingInfo
specifier|protected
specifier|final
name|AppSchedulingInfo
name|appSchedulingInfo
decl_stmt|;
DECL|field|attemptId
specifier|protected
name|ApplicationAttemptId
name|attemptId
decl_stmt|;
DECL|field|liveContainers
specifier|protected
name|Map
argument_list|<
name|ContainerId
argument_list|,
name|RMContainer
argument_list|>
name|liveContainers
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|protected
specifier|final
name|Map
argument_list|<
name|SchedulerRequestKey
argument_list|,
name|Map
argument_list|<
name|NodeId
argument_list|,
name|RMContainer
argument_list|>
argument_list|>
DECL|field|reservedContainers
name|reservedContainers
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|reReservations
specifier|private
specifier|final
name|ConcurrentHashMultiset
argument_list|<
name|SchedulerRequestKey
argument_list|>
name|reReservations
init|=
name|ConcurrentHashMultiset
operator|.
name|create
argument_list|()
decl_stmt|;
DECL|field|resourceLimit
specifier|private
specifier|volatile
name|Resource
name|resourceLimit
init|=
name|Resource
operator|.
name|newInstance
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
DECL|field|unmanagedAM
specifier|private
name|boolean
name|unmanagedAM
init|=
literal|true
decl_stmt|;
DECL|field|amRunning
specifier|private
name|boolean
name|amRunning
init|=
literal|false
decl_stmt|;
DECL|field|logAggregationContext
specifier|private
name|LogAggregationContext
name|logAggregationContext
decl_stmt|;
DECL|field|appPriority
specifier|private
specifier|volatile
name|Priority
name|appPriority
init|=
literal|null
decl_stmt|;
DECL|field|isAttemptRecovering
specifier|private
name|boolean
name|isAttemptRecovering
decl_stmt|;
DECL|field|attemptResourceUsage
specifier|protected
name|ResourceUsage
name|attemptResourceUsage
init|=
operator|new
name|ResourceUsage
argument_list|()
decl_stmt|;
comment|/** Resource usage of opportunistic containers. */
DECL|field|attemptOpportunisticResourceUsage
specifier|protected
name|ResourceUsage
name|attemptOpportunisticResourceUsage
init|=
operator|new
name|ResourceUsage
argument_list|()
decl_stmt|;
comment|/** Scheduled by a remote scheduler. */
DECL|field|attemptResourceUsageAllocatedRemotely
specifier|protected
name|ResourceUsage
name|attemptResourceUsageAllocatedRemotely
init|=
operator|new
name|ResourceUsage
argument_list|()
decl_stmt|;
DECL|field|firstAllocationRequestSentTime
specifier|private
name|AtomicLong
name|firstAllocationRequestSentTime
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|firstContainerAllocatedTime
specifier|private
name|AtomicLong
name|firstContainerAllocatedTime
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|newlyAllocatedContainers
specifier|protected
name|List
argument_list|<
name|RMContainer
argument_list|>
name|newlyAllocatedContainers
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|tempContainerToKill
specifier|protected
name|List
argument_list|<
name|RMContainer
argument_list|>
name|tempContainerToKill
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|newlyPromotedContainers
specifier|protected
name|Map
argument_list|<
name|ContainerId
argument_list|,
name|RMContainer
argument_list|>
name|newlyPromotedContainers
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|newlyDemotedContainers
specifier|protected
name|Map
argument_list|<
name|ContainerId
argument_list|,
name|RMContainer
argument_list|>
name|newlyDemotedContainers
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|newlyDecreasedContainers
specifier|protected
name|Map
argument_list|<
name|ContainerId
argument_list|,
name|RMContainer
argument_list|>
name|newlyDecreasedContainers
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|newlyIncreasedContainers
specifier|protected
name|Map
argument_list|<
name|ContainerId
argument_list|,
name|RMContainer
argument_list|>
name|newlyIncreasedContainers
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|updatedNMTokens
specifier|protected
name|Set
argument_list|<
name|NMToken
argument_list|>
name|updatedNMTokens
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|updateContainerErrors
specifier|protected
name|List
argument_list|<
name|UpdateContainerError
argument_list|>
name|updateContainerErrors
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|//Keeps track of recovered containers from previous attempt which haven't
comment|//been reported to the AM.
DECL|field|recoveredPreviousAttemptContainers
specifier|private
name|List
argument_list|<
name|Container
argument_list|>
name|recoveredPreviousAttemptContainers
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// This pendingRelease is used in work-preserving recovery scenario to keep
comment|// track of the AM's outstanding release requests. RM on recovery could
comment|// receive the release request form AM before it receives the container status
comment|// from NM for recovery. In this case, the to-be-recovered containers reported
comment|// by NM should not be recovered.
DECL|field|pendingRelease
specifier|private
name|Set
argument_list|<
name|ContainerId
argument_list|>
name|pendingRelease
init|=
literal|null
decl_stmt|;
DECL|field|oppContainerContext
specifier|private
name|OpportunisticContainerContext
name|oppContainerContext
decl_stmt|;
comment|/**    * Count how many times the application has been given an opportunity to    * schedule a task at each priority. Each time the scheduler asks the    * application for a task at this priority, it is incremented, and each time    * the application successfully schedules a task (at rack or node local), it    * is reset to 0.    */
DECL|field|schedulingOpportunities
specifier|private
name|ConcurrentHashMultiset
argument_list|<
name|SchedulerRequestKey
argument_list|>
name|schedulingOpportunities
init|=
name|ConcurrentHashMultiset
operator|.
name|create
argument_list|()
decl_stmt|;
comment|/**    * Count how many times the application has been given an opportunity to    * schedule a non-partitioned resource request at each priority. Each time the    * scheduler asks the application for a task at this priority, it is    * incremented, and each time the application successfully schedules a task,    * it is reset to 0 when schedule any task at corresponding priority.    */
specifier|private
name|ConcurrentHashMultiset
argument_list|<
name|SchedulerRequestKey
argument_list|>
DECL|field|missedNonPartitionedReqSchedulingOpportunity
name|missedNonPartitionedReqSchedulingOpportunity
init|=
name|ConcurrentHashMultiset
operator|.
name|create
argument_list|()
decl_stmt|;
comment|// Time of the last container scheduled at the current allowed level
DECL|field|lastScheduledContainer
specifier|protected
name|Map
argument_list|<
name|SchedulerRequestKey
argument_list|,
name|Long
argument_list|>
name|lastScheduledContainer
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|queue
specifier|protected
specifier|volatile
name|Queue
name|queue
decl_stmt|;
DECL|field|isStopped
specifier|protected
specifier|volatile
name|boolean
name|isStopped
init|=
literal|false
decl_stmt|;
DECL|field|appAMNodePartitionName
specifier|protected
name|String
name|appAMNodePartitionName
init|=
name|CommonNodeLabelsManager
operator|.
name|NO_LABEL
decl_stmt|;
DECL|field|rmContext
specifier|protected
specifier|final
name|RMContext
name|rmContext
decl_stmt|;
DECL|field|appAttempt
specifier|private
name|RMAppAttempt
name|appAttempt
decl_stmt|;
DECL|field|readLock
specifier|protected
name|ReentrantReadWriteLock
operator|.
name|ReadLock
name|readLock
decl_stmt|;
DECL|field|writeLock
specifier|protected
name|ReentrantReadWriteLock
operator|.
name|WriteLock
name|writeLock
decl_stmt|;
DECL|field|applicationSchedulingEnvs
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|applicationSchedulingEnvs
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Not confirmed allocation resource, will be used to avoid too many proposal
comment|// rejected because of duplicated allocation
DECL|field|unconfirmedAllocatedMem
specifier|private
name|AtomicLong
name|unconfirmedAllocatedMem
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|unconfirmedAllocatedVcores
specifier|private
name|AtomicInteger
name|unconfirmedAllocatedVcores
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|field|nodeLabelExpression
specifier|private
name|String
name|nodeLabelExpression
decl_stmt|;
DECL|method|SchedulerApplicationAttempt (ApplicationAttemptId applicationAttemptId, String user, Queue queue, AbstractUsersManager abstractUsersManager, RMContext rmContext)
specifier|public
name|SchedulerApplicationAttempt
parameter_list|(
name|ApplicationAttemptId
name|applicationAttemptId
parameter_list|,
name|String
name|user
parameter_list|,
name|Queue
name|queue
parameter_list|,
name|AbstractUsersManager
name|abstractUsersManager
parameter_list|,
name|RMContext
name|rmContext
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|rmContext
argument_list|,
literal|"RMContext should not be null"
argument_list|)
expr_stmt|;
name|this
operator|.
name|rmContext
operator|=
name|rmContext
expr_stmt|;
name|this
operator|.
name|queue
operator|=
name|queue
expr_stmt|;
name|this
operator|.
name|pendingRelease
operator|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|ConcurrentHashMap
argument_list|<
name|ContainerId
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|attemptId
operator|=
name|applicationAttemptId
expr_stmt|;
if|if
condition|(
name|rmContext
operator|.
name|getRMApps
argument_list|()
operator|!=
literal|null
operator|&&
name|rmContext
operator|.
name|getRMApps
argument_list|()
operator|.
name|containsKey
argument_list|(
name|applicationAttemptId
operator|.
name|getApplicationId
argument_list|()
argument_list|)
condition|)
block|{
name|RMApp
name|rmApp
init|=
name|rmContext
operator|.
name|getRMApps
argument_list|()
operator|.
name|get
argument_list|(
name|applicationAttemptId
operator|.
name|getApplicationId
argument_list|()
argument_list|)
decl_stmt|;
name|ApplicationSubmissionContext
name|appSubmissionContext
init|=
name|rmApp
operator|.
name|getApplicationSubmissionContext
argument_list|()
decl_stmt|;
name|appAttempt
operator|=
name|rmApp
operator|.
name|getCurrentAppAttempt
argument_list|()
expr_stmt|;
if|if
condition|(
name|appSubmissionContext
operator|!=
literal|null
condition|)
block|{
name|unmanagedAM
operator|=
name|appSubmissionContext
operator|.
name|getUnmanagedAM
argument_list|()
expr_stmt|;
name|this
operator|.
name|logAggregationContext
operator|=
name|appSubmissionContext
operator|.
name|getLogAggregationContext
argument_list|()
expr_stmt|;
name|this
operator|.
name|nodeLabelExpression
operator|=
name|appSubmissionContext
operator|.
name|getNodeLabelExpression
argument_list|()
expr_stmt|;
block|}
name|applicationSchedulingEnvs
operator|=
name|rmApp
operator|.
name|getApplicationSchedulingEnvs
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|appSchedulingInfo
operator|=
operator|new
name|AppSchedulingInfo
argument_list|(
name|applicationAttemptId
argument_list|,
name|user
argument_list|,
name|queue
argument_list|,
name|abstractUsersManager
argument_list|,
name|rmContext
operator|.
name|getEpoch
argument_list|()
argument_list|,
name|attemptResourceUsage
argument_list|,
name|applicationSchedulingEnvs
argument_list|,
name|rmContext
argument_list|)
expr_stmt|;
name|ReentrantReadWriteLock
name|lock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
name|readLock
operator|=
name|lock
operator|.
name|readLock
argument_list|()
expr_stmt|;
name|writeLock
operator|=
name|lock
operator|.
name|writeLock
argument_list|()
expr_stmt|;
block|}
DECL|method|setOpportunisticContainerContext ( OpportunisticContainerContext oppContext)
specifier|public
name|void
name|setOpportunisticContainerContext
parameter_list|(
name|OpportunisticContainerContext
name|oppContext
parameter_list|)
block|{
name|this
operator|.
name|oppContainerContext
operator|=
name|oppContext
expr_stmt|;
block|}
specifier|public
name|OpportunisticContainerContext
DECL|method|getOpportunisticContainerContext ()
name|getOpportunisticContainerContext
parameter_list|()
block|{
return|return
name|this
operator|.
name|oppContainerContext
return|;
block|}
comment|/**    * Get the live containers of the application.    * @return live containers of the application    */
DECL|method|getLiveContainers ()
specifier|public
name|Collection
argument_list|<
name|RMContainer
argument_list|>
name|getLiveContainers
parameter_list|()
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|liveContainers
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getAppSchedulingInfo ()
specifier|public
name|AppSchedulingInfo
name|getAppSchedulingInfo
parameter_list|()
block|{
return|return
name|this
operator|.
name|appSchedulingInfo
return|;
block|}
DECL|method|getUpdateContext ()
specifier|public
name|ContainerUpdateContext
name|getUpdateContext
parameter_list|()
block|{
return|return
name|this
operator|.
name|appSchedulingInfo
operator|.
name|getUpdateContext
argument_list|()
return|;
block|}
comment|/**    * Is this application pending?    * @return true if it is else false.    */
DECL|method|isPending ()
specifier|public
name|boolean
name|isPending
parameter_list|()
block|{
return|return
name|appSchedulingInfo
operator|.
name|isPending
argument_list|()
return|;
block|}
comment|/**    * Get {@link ApplicationAttemptId} of the application master.    * @return<code>ApplicationAttemptId</code> of the application master    */
DECL|method|getApplicationAttemptId ()
specifier|public
name|ApplicationAttemptId
name|getApplicationAttemptId
parameter_list|()
block|{
return|return
name|appSchedulingInfo
operator|.
name|getApplicationAttemptId
argument_list|()
return|;
block|}
DECL|method|getApplicationId ()
specifier|public
name|ApplicationId
name|getApplicationId
parameter_list|()
block|{
return|return
name|appSchedulingInfo
operator|.
name|getApplicationId
argument_list|()
return|;
block|}
DECL|method|getUser ()
specifier|public
name|String
name|getUser
parameter_list|()
block|{
return|return
name|appSchedulingInfo
operator|.
name|getUser
argument_list|()
return|;
block|}
DECL|method|getPendingRelease ()
specifier|public
name|Set
argument_list|<
name|ContainerId
argument_list|>
name|getPendingRelease
parameter_list|()
block|{
return|return
name|this
operator|.
name|pendingRelease
return|;
block|}
DECL|method|getNewContainerId ()
specifier|public
name|long
name|getNewContainerId
parameter_list|()
block|{
return|return
name|appSchedulingInfo
operator|.
name|getNewContainerId
argument_list|()
return|;
block|}
DECL|method|getSchedulerKeys ()
specifier|public
name|Collection
argument_list|<
name|SchedulerRequestKey
argument_list|>
name|getSchedulerKeys
parameter_list|()
block|{
return|return
name|appSchedulingInfo
operator|.
name|getSchedulerKeys
argument_list|()
return|;
block|}
DECL|method|getPendingAsk ( SchedulerRequestKey schedulerKey, String resourceName)
specifier|public
name|PendingAsk
name|getPendingAsk
parameter_list|(
name|SchedulerRequestKey
name|schedulerKey
parameter_list|,
name|String
name|resourceName
parameter_list|)
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|appSchedulingInfo
operator|.
name|getPendingAsk
argument_list|(
name|schedulerKey
argument_list|,
name|resourceName
argument_list|)
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getOutstandingAsksCount (SchedulerRequestKey schedulerKey)
specifier|public
name|int
name|getOutstandingAsksCount
parameter_list|(
name|SchedulerRequestKey
name|schedulerKey
parameter_list|)
block|{
return|return
name|getOutstandingAsksCount
argument_list|(
name|schedulerKey
argument_list|,
name|ResourceRequest
operator|.
name|ANY
argument_list|)
return|;
block|}
DECL|method|getOutstandingAsksCount (SchedulerRequestKey schedulerKey, String resourceName)
specifier|public
name|int
name|getOutstandingAsksCount
parameter_list|(
name|SchedulerRequestKey
name|schedulerKey
parameter_list|,
name|String
name|resourceName
parameter_list|)
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|AppPlacementAllocator
name|ap
init|=
name|appSchedulingInfo
operator|.
name|getAppPlacementAllocator
argument_list|(
name|schedulerKey
argument_list|)
decl_stmt|;
return|return
name|ap
operator|==
literal|null
condition|?
literal|0
else|:
name|ap
operator|.
name|getOutstandingAsksCount
argument_list|(
name|resourceName
argument_list|)
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getQueueName ()
specifier|public
name|String
name|getQueueName
parameter_list|()
block|{
return|return
name|appSchedulingInfo
operator|.
name|getQueueName
argument_list|()
return|;
block|}
DECL|method|getAMResource ()
specifier|public
name|Resource
name|getAMResource
parameter_list|()
block|{
return|return
name|attemptResourceUsage
operator|.
name|getAMUsed
argument_list|()
return|;
block|}
DECL|method|getAMResource (String label)
specifier|public
name|Resource
name|getAMResource
parameter_list|(
name|String
name|label
parameter_list|)
block|{
return|return
name|attemptResourceUsage
operator|.
name|getAMUsed
argument_list|(
name|label
argument_list|)
return|;
block|}
DECL|method|setAMResource (Resource amResource)
specifier|public
name|void
name|setAMResource
parameter_list|(
name|Resource
name|amResource
parameter_list|)
block|{
name|attemptResourceUsage
operator|.
name|setAMUsed
argument_list|(
name|amResource
argument_list|)
expr_stmt|;
block|}
DECL|method|setAMResource (String label, Resource amResource)
specifier|public
name|void
name|setAMResource
parameter_list|(
name|String
name|label
parameter_list|,
name|Resource
name|amResource
parameter_list|)
block|{
name|attemptResourceUsage
operator|.
name|setAMUsed
argument_list|(
name|label
argument_list|,
name|amResource
argument_list|)
expr_stmt|;
block|}
DECL|method|isAmRunning ()
specifier|public
name|boolean
name|isAmRunning
parameter_list|()
block|{
return|return
name|amRunning
return|;
block|}
DECL|method|setAmRunning (boolean bool)
specifier|public
name|void
name|setAmRunning
parameter_list|(
name|boolean
name|bool
parameter_list|)
block|{
name|amRunning
operator|=
name|bool
expr_stmt|;
block|}
DECL|method|getUnmanagedAM ()
specifier|public
name|boolean
name|getUnmanagedAM
parameter_list|()
block|{
return|return
name|unmanagedAM
return|;
block|}
DECL|method|getRMContainer (ContainerId id)
specifier|public
name|RMContainer
name|getRMContainer
parameter_list|(
name|ContainerId
name|id
parameter_list|)
block|{
return|return
name|liveContainers
operator|.
name|get
argument_list|(
name|id
argument_list|)
return|;
block|}
DECL|method|addRMContainer ( ContainerId id, RMContainer rmContainer)
specifier|public
name|void
name|addRMContainer
parameter_list|(
name|ContainerId
name|id
parameter_list|,
name|RMContainer
name|rmContainer
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|getApplicationAttemptId
argument_list|()
operator|.
name|equals
argument_list|(
name|rmContainer
operator|.
name|getApplicationAttemptId
argument_list|()
argument_list|)
operator|&&
operator|!
name|liveContainers
operator|.
name|containsKey
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"recovered container "
operator|+
name|id
operator|+
literal|" from previous attempt "
operator|+
name|rmContainer
operator|.
name|getApplicationAttemptId
argument_list|()
argument_list|)
expr_stmt|;
name|recoveredPreviousAttemptContainers
operator|.
name|add
argument_list|(
name|rmContainer
operator|.
name|getContainer
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|liveContainers
operator|.
name|put
argument_list|(
name|id
argument_list|,
name|rmContainer
argument_list|)
expr_stmt|;
if|if
condition|(
name|rmContainer
operator|.
name|getExecutionType
argument_list|()
operator|==
name|ExecutionType
operator|.
name|OPPORTUNISTIC
condition|)
block|{
name|this
operator|.
name|attemptOpportunisticResourceUsage
operator|.
name|incUsed
argument_list|(
name|rmContainer
operator|.
name|getAllocatedResource
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rmContainer
operator|.
name|isRemotelyAllocated
argument_list|()
condition|)
block|{
name|this
operator|.
name|attemptResourceUsageAllocatedRemotely
operator|.
name|incUsed
argument_list|(
name|rmContainer
operator|.
name|getAllocatedResource
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|removeRMContainer (ContainerId containerId)
specifier|public
name|void
name|removeRMContainer
parameter_list|(
name|ContainerId
name|containerId
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|RMContainer
name|rmContainer
init|=
name|liveContainers
operator|.
name|remove
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|rmContainer
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|rmContainer
operator|.
name|getExecutionType
argument_list|()
operator|==
name|ExecutionType
operator|.
name|OPPORTUNISTIC
condition|)
block|{
name|this
operator|.
name|attemptOpportunisticResourceUsage
operator|.
name|decUsed
argument_list|(
name|rmContainer
operator|.
name|getAllocatedResource
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rmContainer
operator|.
name|isRemotelyAllocated
argument_list|()
condition|)
block|{
name|this
operator|.
name|attemptResourceUsageAllocatedRemotely
operator|.
name|decUsed
argument_list|(
name|rmContainer
operator|.
name|getAllocatedResource
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|resetReReservations ( SchedulerRequestKey schedulerKey)
specifier|protected
name|void
name|resetReReservations
parameter_list|(
name|SchedulerRequestKey
name|schedulerKey
parameter_list|)
block|{
name|reReservations
operator|.
name|setCount
argument_list|(
name|schedulerKey
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|addReReservation ( SchedulerRequestKey schedulerKey)
specifier|protected
name|void
name|addReReservation
parameter_list|(
name|SchedulerRequestKey
name|schedulerKey
parameter_list|)
block|{
try|try
block|{
name|reReservations
operator|.
name|add
argument_list|(
name|schedulerKey
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// This happens when count = MAX_INT, ignore the exception
block|}
block|}
DECL|method|getReReservations (SchedulerRequestKey schedulerKey)
specifier|public
name|int
name|getReReservations
parameter_list|(
name|SchedulerRequestKey
name|schedulerKey
parameter_list|)
block|{
return|return
name|reReservations
operator|.
name|count
argument_list|(
name|schedulerKey
argument_list|)
return|;
block|}
comment|/**    * Get total current reservations.    * Used only by unit tests    * @return total current reservations    */
annotation|@
name|Stable
annotation|@
name|Private
DECL|method|getCurrentReservation ()
specifier|public
name|Resource
name|getCurrentReservation
parameter_list|()
block|{
return|return
name|attemptResourceUsage
operator|.
name|getReserved
argument_list|()
return|;
block|}
DECL|method|getQueue ()
specifier|public
name|Queue
name|getQueue
parameter_list|()
block|{
return|return
name|queue
return|;
block|}
DECL|method|updateResourceRequests ( List<ResourceRequest> requests)
specifier|public
name|boolean
name|updateResourceRequests
parameter_list|(
name|List
argument_list|<
name|ResourceRequest
argument_list|>
name|requests
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|isStopped
condition|)
block|{
return|return
name|appSchedulingInfo
operator|.
name|updateResourceRequests
argument_list|(
name|requests
argument_list|,
literal|false
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|updateSchedulingRequests ( List<SchedulingRequest> requests)
specifier|public
name|boolean
name|updateSchedulingRequests
parameter_list|(
name|List
argument_list|<
name|SchedulingRequest
argument_list|>
name|requests
parameter_list|)
block|{
if|if
condition|(
name|requests
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|isStopped
condition|)
block|{
return|return
name|appSchedulingInfo
operator|.
name|updateSchedulingRequests
argument_list|(
name|requests
argument_list|,
literal|false
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|recoverResourceRequestsForContainer ( ContainerRequest containerRequest)
specifier|public
name|void
name|recoverResourceRequestsForContainer
parameter_list|(
name|ContainerRequest
name|containerRequest
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|isStopped
condition|)
block|{
name|appSchedulingInfo
operator|.
name|updateResourceRequests
argument_list|(
name|containerRequest
operator|.
name|getResourceRequests
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|stop (RMAppAttemptState rmAppAttemptFinalState)
specifier|public
name|void
name|stop
parameter_list|(
name|RMAppAttemptState
name|rmAppAttemptFinalState
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Cleanup all scheduling information
name|isStopped
operator|=
literal|true
expr_stmt|;
name|appSchedulingInfo
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|isStopped ()
specifier|public
name|boolean
name|isStopped
parameter_list|()
block|{
return|return
name|isStopped
return|;
block|}
comment|/**    * Get the list of reserved containers    * @return All of the reserved containers.    */
DECL|method|getReservedContainers ()
specifier|public
name|List
argument_list|<
name|RMContainer
argument_list|>
name|getReservedContainers
parameter_list|()
block|{
name|List
argument_list|<
name|RMContainer
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|Entry
argument_list|<
name|SchedulerRequestKey
argument_list|,
name|Map
argument_list|<
name|NodeId
argument_list|,
name|RMContainer
argument_list|>
argument_list|>
name|e
range|:
name|this
operator|.
name|reservedContainers
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|list
operator|.
name|addAll
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|reserveIncreasedContainer (SchedulerNode node, SchedulerRequestKey schedulerKey, RMContainer rmContainer, Resource reservedResource)
specifier|public
name|boolean
name|reserveIncreasedContainer
parameter_list|(
name|SchedulerNode
name|node
parameter_list|,
name|SchedulerRequestKey
name|schedulerKey
parameter_list|,
name|RMContainer
name|rmContainer
parameter_list|,
name|Resource
name|reservedResource
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|commonReserve
argument_list|(
name|node
argument_list|,
name|schedulerKey
argument_list|,
name|rmContainer
argument_list|,
name|reservedResource
argument_list|)
condition|)
block|{
name|attemptResourceUsage
operator|.
name|incReserved
argument_list|(
name|node
operator|.
name|getPartition
argument_list|()
argument_list|,
name|reservedResource
argument_list|)
expr_stmt|;
comment|// succeeded
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|commonReserve (SchedulerNode node, SchedulerRequestKey schedulerKey, RMContainer rmContainer, Resource reservedResource)
specifier|private
name|boolean
name|commonReserve
parameter_list|(
name|SchedulerNode
name|node
parameter_list|,
name|SchedulerRequestKey
name|schedulerKey
parameter_list|,
name|RMContainer
name|rmContainer
parameter_list|,
name|Resource
name|reservedResource
parameter_list|)
block|{
try|try
block|{
name|rmContainer
operator|.
name|handle
argument_list|(
operator|new
name|RMContainerReservedEvent
argument_list|(
name|rmContainer
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|reservedResource
argument_list|,
name|node
operator|.
name|getNodeID
argument_list|()
argument_list|,
name|schedulerKey
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidStateTransitionException
name|e
parameter_list|)
block|{
comment|// We reach here could be caused by container already finished, return
comment|// false indicate it fails
return|return
literal|false
return|;
block|}
name|Map
argument_list|<
name|NodeId
argument_list|,
name|RMContainer
argument_list|>
name|reservedContainers
init|=
name|this
operator|.
name|reservedContainers
operator|.
name|get
argument_list|(
name|schedulerKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|reservedContainers
operator|==
literal|null
condition|)
block|{
name|reservedContainers
operator|=
operator|new
name|HashMap
argument_list|<
name|NodeId
argument_list|,
name|RMContainer
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|reservedContainers
operator|.
name|put
argument_list|(
name|schedulerKey
argument_list|,
name|reservedContainers
argument_list|)
expr_stmt|;
block|}
name|reservedContainers
operator|.
name|put
argument_list|(
name|node
operator|.
name|getNodeID
argument_list|()
argument_list|,
name|rmContainer
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Application attempt "
operator|+
name|getApplicationAttemptId
argument_list|()
operator|+
literal|" reserved container "
operator|+
name|rmContainer
operator|+
literal|" on node "
operator|+
name|node
operator|+
literal|". This attempt currently has "
operator|+
name|reservedContainers
operator|.
name|size
argument_list|()
operator|+
literal|" reserved containers at priority "
operator|+
name|schedulerKey
operator|.
name|getPriority
argument_list|()
operator|+
literal|"; currentReservation "
operator|+
name|reservedResource
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|reserve (SchedulerNode node, SchedulerRequestKey schedulerKey, RMContainer rmContainer, Container container)
specifier|public
name|RMContainer
name|reserve
parameter_list|(
name|SchedulerNode
name|node
parameter_list|,
name|SchedulerRequestKey
name|schedulerKey
parameter_list|,
name|RMContainer
name|rmContainer
parameter_list|,
name|Container
name|container
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Create RMContainer if necessary
if|if
condition|(
name|rmContainer
operator|==
literal|null
condition|)
block|{
name|rmContainer
operator|=
operator|new
name|RMContainerImpl
argument_list|(
name|container
argument_list|,
name|schedulerKey
argument_list|,
name|getApplicationAttemptId
argument_list|()
argument_list|,
name|node
operator|.
name|getNodeID
argument_list|()
argument_list|,
name|appSchedulingInfo
operator|.
name|getUser
argument_list|()
argument_list|,
name|rmContext
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rmContainer
operator|.
name|getState
argument_list|()
operator|==
name|RMContainerState
operator|.
name|NEW
condition|)
block|{
name|attemptResourceUsage
operator|.
name|incReserved
argument_list|(
name|node
operator|.
name|getPartition
argument_list|()
argument_list|,
name|container
operator|.
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
operator|(
operator|(
name|RMContainerImpl
operator|)
name|rmContainer
operator|)
operator|.
name|setQueueName
argument_list|(
name|this
operator|.
name|getQueueName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Reset the re-reservation count
name|resetReReservations
argument_list|(
name|schedulerKey
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Note down the re-reservation
name|addReReservation
argument_list|(
name|schedulerKey
argument_list|)
expr_stmt|;
block|}
name|commonReserve
argument_list|(
name|node
argument_list|,
name|schedulerKey
argument_list|,
name|rmContainer
argument_list|,
name|container
operator|.
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|rmContainer
return|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|setHeadroom (Resource globalLimit)
specifier|public
name|void
name|setHeadroom
parameter_list|(
name|Resource
name|globalLimit
parameter_list|)
block|{
name|this
operator|.
name|resourceLimit
operator|=
name|Resources
operator|.
name|componentwiseMax
argument_list|(
name|globalLimit
argument_list|,
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get available headroom in terms of resources for the application's user.    * @return available resource headroom    */
DECL|method|getHeadroom ()
specifier|public
name|Resource
name|getHeadroom
parameter_list|()
block|{
return|return
name|resourceLimit
return|;
block|}
DECL|method|getNumReservedContainers ( SchedulerRequestKey schedulerKey)
specifier|public
name|int
name|getNumReservedContainers
parameter_list|(
name|SchedulerRequestKey
name|schedulerKey
parameter_list|)
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|Map
argument_list|<
name|NodeId
argument_list|,
name|RMContainer
argument_list|>
name|map
init|=
name|this
operator|.
name|reservedContainers
operator|.
name|get
argument_list|(
name|schedulerKey
argument_list|)
decl_stmt|;
return|return
operator|(
name|map
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|map
operator|.
name|size
argument_list|()
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|containerLaunchedOnNode (ContainerId containerId, NodeId nodeId)
specifier|public
name|void
name|containerLaunchedOnNode
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|NodeId
name|nodeId
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Inform the container
name|RMContainer
name|rmContainer
init|=
name|getRMContainer
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|rmContainer
operator|==
literal|null
condition|)
block|{
comment|// Some unknown container sneaked into the system. Kill it.
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMNodeCleanContainerEvent
argument_list|(
name|nodeId
argument_list|,
name|containerId
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|rmContainer
operator|.
name|handle
argument_list|(
operator|new
name|RMContainerEvent
argument_list|(
name|containerId
argument_list|,
name|RMContainerEventType
operator|.
name|LAUNCHED
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|showRequests ()
specifier|public
name|void
name|showRequests
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|SchedulerRequestKey
name|schedulerKey
range|:
name|getSchedulerKeys
argument_list|()
control|)
block|{
name|AppPlacementAllocator
name|ap
init|=
name|getAppPlacementAllocator
argument_list|(
name|schedulerKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|ap
operator|!=
literal|null
operator|&&
name|ap
operator|.
name|getOutstandingAsksCount
argument_list|(
name|ResourceRequest
operator|.
name|ANY
argument_list|)
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"showRequests:"
operator|+
literal|" application="
operator|+
name|getApplicationId
argument_list|()
operator|+
literal|" headRoom="
operator|+
name|getHeadroom
argument_list|()
operator|+
literal|" currentConsumption="
operator|+
name|attemptResourceUsage
operator|.
name|getUsed
argument_list|()
operator|.
name|getMemorySize
argument_list|()
argument_list|)
expr_stmt|;
name|ap
operator|.
name|showRequests
argument_list|()
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|getCurrentConsumption ()
specifier|public
name|Resource
name|getCurrentConsumption
parameter_list|()
block|{
return|return
name|attemptResourceUsage
operator|.
name|getUsed
argument_list|()
return|;
block|}
DECL|method|updateContainerAndNMToken (RMContainer rmContainer, ContainerUpdateType updateType)
specifier|private
name|Container
name|updateContainerAndNMToken
parameter_list|(
name|RMContainer
name|rmContainer
parameter_list|,
name|ContainerUpdateType
name|updateType
parameter_list|)
block|{
name|Container
name|container
init|=
name|rmContainer
operator|.
name|getContainer
argument_list|()
decl_stmt|;
name|ContainerType
name|containerType
init|=
name|ContainerType
operator|.
name|TASK
decl_stmt|;
if|if
condition|(
name|updateType
operator|!=
literal|null
condition|)
block|{
name|container
operator|.
name|setVersion
argument_list|(
name|container
operator|.
name|getVersion
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// The working knowledge is that masterContainer for AM is null as it
comment|// itself is the master container.
if|if
condition|(
name|isWaitingForAMContainer
argument_list|()
condition|)
block|{
name|containerType
operator|=
name|ContainerType
operator|.
name|APPLICATION_MASTER
expr_stmt|;
block|}
try|try
block|{
comment|// create container token and NMToken altogether.
name|container
operator|.
name|setContainerToken
argument_list|(
name|rmContext
operator|.
name|getContainerTokenSecretManager
argument_list|()
operator|.
name|createContainerToken
argument_list|(
name|container
operator|.
name|getId
argument_list|()
argument_list|,
name|container
operator|.
name|getVersion
argument_list|()
argument_list|,
name|container
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|getUser
argument_list|()
argument_list|,
name|container
operator|.
name|getResource
argument_list|()
argument_list|,
name|container
operator|.
name|getPriority
argument_list|()
argument_list|,
name|rmContainer
operator|.
name|getCreationTime
argument_list|()
argument_list|,
name|this
operator|.
name|logAggregationContext
argument_list|,
name|rmContainer
operator|.
name|getNodeLabelExpression
argument_list|()
argument_list|,
name|containerType
argument_list|,
name|container
operator|.
name|getExecutionType
argument_list|()
argument_list|,
name|container
operator|.
name|getAllocationRequestId
argument_list|()
argument_list|,
name|rmContainer
operator|.
name|getAllocationTags
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|container
operator|.
name|setAllocationTags
argument_list|(
name|rmContainer
operator|.
name|getAllocationTags
argument_list|()
argument_list|)
expr_stmt|;
name|updateNMToken
argument_list|(
name|container
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// DNS might be down, skip returning this container.
name|LOG
operator|.
name|error
argument_list|(
literal|"Error trying to assign container token and NM token to"
operator|+
literal|" an updated container "
operator|+
name|container
operator|.
name|getId
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|updateType
operator|==
literal|null
condition|)
block|{
comment|// This is a newly allocated container
name|rmContainer
operator|.
name|handle
argument_list|(
operator|new
name|RMContainerEvent
argument_list|(
name|rmContainer
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|RMContainerEventType
operator|.
name|ACQUIRED
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Resource increase is handled as follows:
comment|// If the AM does not use the updated token to increase the container
comment|// for a configured period of time, the RM will automatically rollback
comment|// the update by performing a container decrease. This rollback (which
comment|// essentially is another resource decrease update) is notified to the
comment|// NM heartbeat response. If autoUpdate flag is set, then AM does not
comment|// need to do anything - same code path as resource decrease.
comment|//
comment|// Resource Decrease is always automatic: the AM never has to do
comment|// anything. It is always via NM heartbeat response.
comment|//
comment|// ExecutionType updates (both Promotion and Demotion) are either
comment|// always automatic (if the flag is set) or the AM has to explicitly
comment|// call updateContainer() on the NM. There is no expiry
name|boolean
name|autoUpdate
init|=
name|ContainerUpdateType
operator|.
name|DECREASE_RESOURCE
operator|==
name|updateType
operator|||
operator|(
operator|(
name|AbstractYarnScheduler
operator|)
name|rmContext
operator|.
name|getScheduler
argument_list|()
operator|)
operator|.
name|shouldContainersBeAutoUpdated
argument_list|()
decl_stmt|;
if|if
condition|(
name|autoUpdate
condition|)
block|{
name|this
operator|.
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMNodeUpdateContainerEvent
argument_list|(
name|rmContainer
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|Collections
operator|.
name|singletonMap
argument_list|(
name|rmContainer
operator|.
name|getContainer
argument_list|()
argument_list|,
name|updateType
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rmContainer
operator|.
name|handle
argument_list|(
operator|new
name|RMContainerUpdatesAcquiredEvent
argument_list|(
name|rmContainer
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|ContainerUpdateType
operator|.
name|INCREASE_RESOURCE
operator|==
name|updateType
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|container
return|;
block|}
DECL|method|updateNMTokens (Collection<Container> containers)
specifier|public
name|void
name|updateNMTokens
parameter_list|(
name|Collection
argument_list|<
name|Container
argument_list|>
name|containers
parameter_list|)
block|{
for|for
control|(
name|Container
name|container
range|:
name|containers
control|)
block|{
name|updateNMToken
argument_list|(
name|container
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|updateNMToken (Container container)
specifier|private
name|void
name|updateNMToken
parameter_list|(
name|Container
name|container
parameter_list|)
block|{
name|NMToken
name|nmToken
init|=
name|rmContext
operator|.
name|getNMTokenSecretManager
argument_list|()
operator|.
name|createAndGetNMToken
argument_list|(
name|getUser
argument_list|()
argument_list|,
name|getApplicationAttemptId
argument_list|()
argument_list|,
name|container
argument_list|)
decl_stmt|;
if|if
condition|(
name|nmToken
operator|!=
literal|null
condition|)
block|{
name|updatedNMTokens
operator|.
name|add
argument_list|(
name|nmToken
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Called when AM registers. These containers are reported to the AM in the    *<code>    * RegisterApplicationMasterResponse#containersFromPreviousAttempts    *</code>.    */
DECL|method|pullContainersToTransfer ()
name|List
argument_list|<
name|RMContainer
argument_list|>
name|pullContainersToTransfer
parameter_list|()
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|recoveredPreviousAttemptContainers
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|liveContainers
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Called when AM heartbeats. These containers were recovered by the RM after    * the AM had registered. They are reported to the AM in the    *<code>AllocateResponse#containersFromPreviousAttempts</code>.    */
DECL|method|pullPreviousAttemptContainers ()
specifier|public
name|List
argument_list|<
name|Container
argument_list|>
name|pullPreviousAttemptContainers
parameter_list|()
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|recoveredPreviousAttemptContainers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|Container
argument_list|>
name|returnContainerList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|recoveredPreviousAttemptContainers
argument_list|)
decl_stmt|;
name|recoveredPreviousAttemptContainers
operator|.
name|clear
argument_list|()
expr_stmt|;
name|updateNMTokens
argument_list|(
name|returnContainerList
argument_list|)
expr_stmt|;
return|return
name|returnContainerList
return|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Create container token and update NMToken altogether, if either of them fails for
comment|// some reason like DNS unavailable, do not return this container and keep it
comment|// in the newlyAllocatedContainers waiting to be refetched.
DECL|method|pullNewlyAllocatedContainers ()
specifier|public
name|List
argument_list|<
name|Container
argument_list|>
name|pullNewlyAllocatedContainers
parameter_list|()
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|List
argument_list|<
name|Container
argument_list|>
name|returnContainerList
init|=
operator|new
name|ArrayList
argument_list|<
name|Container
argument_list|>
argument_list|(
name|newlyAllocatedContainers
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|RMContainer
argument_list|>
name|i
init|=
name|newlyAllocatedContainers
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|RMContainer
name|rmContainer
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|Container
name|updatedContainer
init|=
name|updateContainerAndNMToken
argument_list|(
name|rmContainer
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// Only add container to return list when it's not null.
comment|// updatedContainer could be null when generate token failed, it can be
comment|// caused by DNS resolving failed.
if|if
condition|(
name|updatedContainer
operator|!=
literal|null
condition|)
block|{
name|returnContainerList
operator|.
name|add
argument_list|(
name|updatedContainer
argument_list|)
expr_stmt|;
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|returnContainerList
return|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|addToNewlyDemotedContainers (ContainerId containerId, RMContainer rmContainer)
specifier|public
specifier|synchronized
name|void
name|addToNewlyDemotedContainers
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|RMContainer
name|rmContainer
parameter_list|)
block|{
name|newlyDemotedContainers
operator|.
name|put
argument_list|(
name|containerId
argument_list|,
name|rmContainer
argument_list|)
expr_stmt|;
block|}
DECL|method|addToNewlyDecreasedContainers ( ContainerId containerId, RMContainer rmContainer)
specifier|public
specifier|synchronized
name|void
name|addToNewlyDecreasedContainers
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|RMContainer
name|rmContainer
parameter_list|)
block|{
name|newlyDecreasedContainers
operator|.
name|put
argument_list|(
name|containerId
argument_list|,
name|rmContainer
argument_list|)
expr_stmt|;
block|}
DECL|method|addToUpdateContainerErrors ( UpdateContainerError error)
specifier|protected
specifier|synchronized
name|void
name|addToUpdateContainerErrors
parameter_list|(
name|UpdateContainerError
name|error
parameter_list|)
block|{
name|updateContainerErrors
operator|.
name|add
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
DECL|method|addToNewlyAllocatedContainers ( SchedulerNode node, RMContainer rmContainer)
specifier|protected
specifier|synchronized
name|void
name|addToNewlyAllocatedContainers
parameter_list|(
name|SchedulerNode
name|node
parameter_list|,
name|RMContainer
name|rmContainer
parameter_list|)
block|{
name|ContainerId
name|matchedContainerId
init|=
name|getUpdateContext
argument_list|()
operator|.
name|matchContainerToOutstandingIncreaseReq
argument_list|(
name|node
argument_list|,
name|rmContainer
operator|.
name|getAllocatedSchedulerKey
argument_list|()
argument_list|,
name|rmContainer
argument_list|)
decl_stmt|;
if|if
condition|(
name|matchedContainerId
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|ContainerUpdateContext
operator|.
name|UNDEFINED
operator|==
name|matchedContainerId
condition|)
block|{
comment|// This is a spurious allocation (relaxLocality = false
comment|// resulted in the Container being allocated on an NM on the same host
comment|// but not on the NM running the container to be updated. Can
comment|// happen if more than one NM exists on the same host.. usually
comment|// occurs when using MiniYARNCluster to test).
name|tempContainerToKill
operator|.
name|add
argument_list|(
name|rmContainer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RMContainer
name|existingContainer
init|=
name|getRMContainer
argument_list|(
name|matchedContainerId
argument_list|)
decl_stmt|;
comment|// If this container was already GUARANTEED, then it is an
comment|// increase, else its a promotion
if|if
condition|(
name|existingContainer
operator|==
literal|null
operator|||
name|EnumSet
operator|.
name|of
argument_list|(
name|RMContainerState
operator|.
name|COMPLETED
argument_list|,
name|RMContainerState
operator|.
name|KILLED
argument_list|,
name|RMContainerState
operator|.
name|EXPIRED
argument_list|,
name|RMContainerState
operator|.
name|RELEASED
argument_list|)
operator|.
name|contains
argument_list|(
name|existingContainer
operator|.
name|getState
argument_list|()
argument_list|)
condition|)
block|{
name|tempContainerToKill
operator|.
name|add
argument_list|(
name|rmContainer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ExecutionType
operator|.
name|GUARANTEED
operator|==
name|existingContainer
operator|.
name|getExecutionType
argument_list|()
condition|)
block|{
name|newlyIncreasedContainers
operator|.
name|put
argument_list|(
name|matchedContainerId
argument_list|,
name|rmContainer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newlyPromotedContainers
operator|.
name|put
argument_list|(
name|matchedContainerId
argument_list|,
name|rmContainer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|newlyAllocatedContainers
operator|.
name|add
argument_list|(
name|rmContainer
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|pullNewlyPromotedContainers ()
specifier|public
name|List
argument_list|<
name|Container
argument_list|>
name|pullNewlyPromotedContainers
parameter_list|()
block|{
return|return
name|pullNewlyUpdatedContainers
argument_list|(
name|newlyPromotedContainers
argument_list|,
name|ContainerUpdateType
operator|.
name|PROMOTE_EXECUTION_TYPE
argument_list|)
return|;
block|}
DECL|method|pullNewlyDemotedContainers ()
specifier|public
name|List
argument_list|<
name|Container
argument_list|>
name|pullNewlyDemotedContainers
parameter_list|()
block|{
return|return
name|pullNewlyUpdatedContainers
argument_list|(
name|newlyDemotedContainers
argument_list|,
name|ContainerUpdateType
operator|.
name|DEMOTE_EXECUTION_TYPE
argument_list|)
return|;
block|}
DECL|method|pullNewlyIncreasedContainers ()
specifier|public
name|List
argument_list|<
name|Container
argument_list|>
name|pullNewlyIncreasedContainers
parameter_list|()
block|{
return|return
name|pullNewlyUpdatedContainers
argument_list|(
name|newlyIncreasedContainers
argument_list|,
name|ContainerUpdateType
operator|.
name|INCREASE_RESOURCE
argument_list|)
return|;
block|}
DECL|method|pullNewlyDecreasedContainers ()
specifier|public
name|List
argument_list|<
name|Container
argument_list|>
name|pullNewlyDecreasedContainers
parameter_list|()
block|{
return|return
name|pullNewlyUpdatedContainers
argument_list|(
name|newlyDecreasedContainers
argument_list|,
name|ContainerUpdateType
operator|.
name|DECREASE_RESOURCE
argument_list|)
return|;
block|}
DECL|method|pullUpdateContainerErrors ()
specifier|public
name|List
argument_list|<
name|UpdateContainerError
argument_list|>
name|pullUpdateContainerErrors
parameter_list|()
block|{
name|List
argument_list|<
name|UpdateContainerError
argument_list|>
name|errors
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|updateContainerErrors
argument_list|)
decl_stmt|;
name|updateContainerErrors
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|errors
return|;
block|}
comment|/**    * A container is promoted if its executionType is changed from    * OPPORTUNISTIC to GUARANTEED. It id demoted if the change is from    * GUARANTEED to OPPORTUNISTIC.    * @return Newly Promoted and Demoted containers    */
DECL|method|pullNewlyUpdatedContainers ( Map<ContainerId, RMContainer> newlyUpdatedContainers, ContainerUpdateType updateTpe)
specifier|private
name|List
argument_list|<
name|Container
argument_list|>
name|pullNewlyUpdatedContainers
parameter_list|(
name|Map
argument_list|<
name|ContainerId
argument_list|,
name|RMContainer
argument_list|>
name|newlyUpdatedContainers
parameter_list|,
name|ContainerUpdateType
name|updateTpe
parameter_list|)
block|{
name|List
argument_list|<
name|Container
argument_list|>
name|updatedContainers
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|oppContainerContext
operator|==
literal|null
operator|&&
operator|(
name|ContainerUpdateType
operator|.
name|DEMOTE_EXECUTION_TYPE
operator|==
name|updateTpe
operator|||
name|ContainerUpdateType
operator|.
name|PROMOTE_EXECUTION_TYPE
operator|==
name|updateTpe
operator|)
condition|)
block|{
return|return
name|updatedContainers
return|;
block|}
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|ContainerId
argument_list|,
name|RMContainer
argument_list|>
argument_list|>
name|i
init|=
name|newlyUpdatedContainers
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|ContainerId
argument_list|,
name|RMContainer
argument_list|>
name|entry
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|ContainerId
name|matchedContainerId
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|RMContainer
name|tempRMContainer
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|RMContainer
name|existingRMContainer
init|=
name|getRMContainer
argument_list|(
name|matchedContainerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingRMContainer
operator|!=
literal|null
condition|)
block|{
comment|// swap containers
name|existingRMContainer
operator|=
name|getUpdateContext
argument_list|()
operator|.
name|swapContainer
argument_list|(
name|tempRMContainer
argument_list|,
name|existingRMContainer
argument_list|,
name|updateTpe
argument_list|)
expr_stmt|;
name|getUpdateContext
argument_list|()
operator|.
name|removeFromOutstandingUpdate
argument_list|(
name|tempRMContainer
operator|.
name|getAllocatedSchedulerKey
argument_list|()
argument_list|,
name|existingRMContainer
operator|.
name|getContainer
argument_list|()
argument_list|)
expr_stmt|;
name|Container
name|updatedContainer
init|=
name|updateContainerAndNMToken
argument_list|(
name|existingRMContainer
argument_list|,
name|updateTpe
argument_list|)
decl_stmt|;
name|updatedContainers
operator|.
name|add
argument_list|(
name|updatedContainer
argument_list|)
expr_stmt|;
block|}
name|tempContainerToKill
operator|.
name|add
argument_list|(
name|tempRMContainer
argument_list|)
expr_stmt|;
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
comment|// Release all temporary containers
name|Iterator
argument_list|<
name|RMContainer
argument_list|>
name|tempIter
init|=
name|tempContainerToKill
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|tempIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|RMContainer
name|c
init|=
name|tempIter
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// Mark container for release (set RRs to null, so RM does not think
comment|// it is a recoverable container)
operator|(
operator|(
name|RMContainerImpl
operator|)
name|c
operator|)
operator|.
name|setContainerRequest
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// Release this container async-ly so as to prevent
comment|// 'LeafQueue::completedContainer()' from trying to acquire a lock
comment|// on the app and queue which can contended for in the reverse order
comment|// by the Scheduler thread.
operator|(
operator|(
name|AbstractYarnScheduler
operator|)
name|rmContext
operator|.
name|getScheduler
argument_list|()
operator|)
operator|.
name|asyncContainerRelease
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|tempIter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
return|return
name|updatedContainers
return|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|pullUpdatedNMTokens ()
specifier|public
name|List
argument_list|<
name|NMToken
argument_list|>
name|pullUpdatedNMTokens
parameter_list|()
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|List
argument_list|<
name|NMToken
argument_list|>
name|returnList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|updatedNMTokens
argument_list|)
decl_stmt|;
name|updatedNMTokens
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|returnList
return|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|isWaitingForAMContainer ()
specifier|public
name|boolean
name|isWaitingForAMContainer
parameter_list|()
block|{
comment|// The working knowledge is that masterContainer for AM is null as it
comment|// itself is the master container.
return|return
operator|(
operator|!
name|unmanagedAM
operator|&&
name|appAttempt
operator|.
name|getMasterContainer
argument_list|()
operator|==
literal|null
operator|)
return|;
block|}
DECL|method|updateBlacklist (List<String> blacklistAdditions, List<String> blacklistRemovals)
specifier|public
name|void
name|updateBlacklist
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|blacklistAdditions
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|blacklistRemovals
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|isStopped
condition|)
block|{
if|if
condition|(
name|isWaitingForAMContainer
argument_list|()
condition|)
block|{
comment|// The request is for the AM-container, and the AM-container is
comment|// launched by the system. So, update the places that are blacklisted
comment|// by system (as opposed to those blacklisted by the application).
name|this
operator|.
name|appSchedulingInfo
operator|.
name|updatePlacesBlacklistedBySystem
argument_list|(
name|blacklistAdditions
argument_list|,
name|blacklistRemovals
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|appSchedulingInfo
operator|.
name|updatePlacesBlacklistedByApp
argument_list|(
name|blacklistAdditions
argument_list|,
name|blacklistRemovals
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|isPlaceBlacklisted (String resourceName)
specifier|public
name|boolean
name|isPlaceBlacklisted
parameter_list|(
name|String
name|resourceName
parameter_list|)
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|boolean
name|forAMContainer
init|=
name|isWaitingForAMContainer
argument_list|()
decl_stmt|;
return|return
name|this
operator|.
name|appSchedulingInfo
operator|.
name|isPlaceBlacklisted
argument_list|(
name|resourceName
argument_list|,
name|forAMContainer
argument_list|)
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|addMissedNonPartitionedRequestSchedulingOpportunity ( SchedulerRequestKey schedulerKey)
specifier|public
name|int
name|addMissedNonPartitionedRequestSchedulingOpportunity
parameter_list|(
name|SchedulerRequestKey
name|schedulerKey
parameter_list|)
block|{
try|try
block|{
return|return
name|missedNonPartitionedReqSchedulingOpportunity
operator|.
name|add
argument_list|(
name|schedulerKey
argument_list|,
literal|1
argument_list|)
operator|+
literal|1
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// This happens when count = MAX_INT, ignore the exception
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
block|}
specifier|public
name|void
DECL|method|resetMissedNonPartitionedRequestSchedulingOpportunity ( SchedulerRequestKey schedulerKey)
name|resetMissedNonPartitionedRequestSchedulingOpportunity
parameter_list|(
name|SchedulerRequestKey
name|schedulerKey
parameter_list|)
block|{
name|missedNonPartitionedReqSchedulingOpportunity
operator|.
name|setCount
argument_list|(
name|schedulerKey
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|addSchedulingOpportunity ( SchedulerRequestKey schedulerKey)
specifier|public
name|void
name|addSchedulingOpportunity
parameter_list|(
name|SchedulerRequestKey
name|schedulerKey
parameter_list|)
block|{
try|try
block|{
name|schedulingOpportunities
operator|.
name|add
argument_list|(
name|schedulerKey
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// This happens when count = MAX_INT, ignore the exception
block|}
block|}
DECL|method|subtractSchedulingOpportunity ( SchedulerRequestKey schedulerKey)
specifier|public
name|void
name|subtractSchedulingOpportunity
parameter_list|(
name|SchedulerRequestKey
name|schedulerKey
parameter_list|)
block|{
name|this
operator|.
name|schedulingOpportunities
operator|.
name|removeExactly
argument_list|(
name|schedulerKey
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return the number of times the application has been given an opportunity    * to schedule a task at the given priority since the last time it    * successfully did so.    * @param schedulerKey Scheduler Key    * @return number of scheduling opportunities    */
DECL|method|getSchedulingOpportunities ( SchedulerRequestKey schedulerKey)
specifier|public
name|int
name|getSchedulingOpportunities
parameter_list|(
name|SchedulerRequestKey
name|schedulerKey
parameter_list|)
block|{
return|return
name|schedulingOpportunities
operator|.
name|count
argument_list|(
name|schedulerKey
argument_list|)
return|;
block|}
comment|/**    * Should be called when an application has successfully scheduled a    * container, or when the scheduling locality threshold is relaxed.    * Reset various internal counters which affect delay scheduling    *    * @param schedulerKey The priority of the container scheduled.    */
DECL|method|resetSchedulingOpportunities ( SchedulerRequestKey schedulerKey)
specifier|public
name|void
name|resetSchedulingOpportunities
parameter_list|(
name|SchedulerRequestKey
name|schedulerKey
parameter_list|)
block|{
name|resetSchedulingOpportunities
argument_list|(
name|schedulerKey
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// used for continuous scheduling
DECL|method|resetSchedulingOpportunities (SchedulerRequestKey schedulerKey, long currentTimeMs)
specifier|public
name|void
name|resetSchedulingOpportunities
parameter_list|(
name|SchedulerRequestKey
name|schedulerKey
parameter_list|,
name|long
name|currentTimeMs
parameter_list|)
block|{
name|lastScheduledContainer
operator|.
name|put
argument_list|(
name|schedulerKey
argument_list|,
name|currentTimeMs
argument_list|)
expr_stmt|;
name|schedulingOpportunities
operator|.
name|setCount
argument_list|(
name|schedulerKey
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setSchedulingOpportunities (SchedulerRequestKey schedulerKey, int count)
name|void
name|setSchedulingOpportunities
parameter_list|(
name|SchedulerRequestKey
name|schedulerKey
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|schedulingOpportunities
operator|.
name|setCount
argument_list|(
name|schedulerKey
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
DECL|method|getRunningAggregateAppResourceUsage ()
specifier|private
name|AggregateAppResourceUsage
name|getRunningAggregateAppResourceUsage
parameter_list|()
block|{
name|long
name|currentTimeMillis
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// Don't walk the whole container list if the resources were computed
comment|// recently.
if|if
condition|(
operator|(
name|currentTimeMillis
operator|-
name|lastMemoryAggregateAllocationUpdateTime
operator|)
operator|>
name|MEM_AGGREGATE_ALLOCATION_CACHE_MSECS
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|resourceSecondsMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RMContainer
name|rmContainer
range|:
name|this
operator|.
name|liveContainers
operator|.
name|values
argument_list|()
control|)
block|{
name|long
name|usedMillis
init|=
name|currentTimeMillis
operator|-
name|rmContainer
operator|.
name|getCreationTime
argument_list|()
decl_stmt|;
name|Resource
name|resource
init|=
name|rmContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getResource
argument_list|()
decl_stmt|;
for|for
control|(
name|ResourceInformation
name|entry
range|:
name|resource
operator|.
name|getResources
argument_list|()
control|)
block|{
name|long
name|value
init|=
name|RMServerUtils
operator|.
name|getOrDefault
argument_list|(
name|resourceSecondsMap
argument_list|,
name|entry
operator|.
name|getName
argument_list|()
argument_list|,
literal|0L
argument_list|)
decl_stmt|;
name|value
operator|+=
name|entry
operator|.
name|getValue
argument_list|()
operator|*
name|usedMillis
operator|/
name|DateUtils
operator|.
name|MILLIS_PER_SECOND
expr_stmt|;
name|resourceSecondsMap
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getName
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
name|lastMemoryAggregateAllocationUpdateTime
operator|=
name|currentTimeMillis
expr_stmt|;
name|lastResourceSecondsMap
operator|=
name|resourceSecondsMap
expr_stmt|;
block|}
return|return
operator|new
name|AggregateAppResourceUsage
argument_list|(
name|lastResourceSecondsMap
argument_list|)
return|;
block|}
DECL|method|getResourceUsageReport ()
specifier|public
name|ApplicationResourceUsageReport
name|getResourceUsageReport
parameter_list|()
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|AggregateAppResourceUsage
name|runningResourceUsage
init|=
name|getRunningAggregateAppResourceUsage
argument_list|()
decl_stmt|;
name|Resource
name|usedResourceClone
init|=
name|Resources
operator|.
name|clone
argument_list|(
name|attemptResourceUsage
operator|.
name|getAllUsed
argument_list|()
argument_list|)
decl_stmt|;
name|Resource
name|reservedResourceClone
init|=
name|Resources
operator|.
name|clone
argument_list|(
name|attemptResourceUsage
operator|.
name|getReserved
argument_list|()
argument_list|)
decl_stmt|;
name|Resource
name|cluster
init|=
name|rmContext
operator|.
name|getScheduler
argument_list|()
operator|.
name|getClusterResource
argument_list|()
decl_stmt|;
name|ResourceCalculator
name|calc
init|=
name|rmContext
operator|.
name|getScheduler
argument_list|()
operator|.
name|getResourceCalculator
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|preemptedResourceSecondsMaps
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|preemptedResourceSecondsMaps
operator|.
name|put
argument_list|(
name|ResourceInformation
operator|.
name|MEMORY_MB
operator|.
name|getName
argument_list|()
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|preemptedResourceSecondsMaps
operator|.
name|put
argument_list|(
name|ResourceInformation
operator|.
name|VCORES
operator|.
name|getName
argument_list|()
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|float
name|queueUsagePerc
init|=
literal|0.0f
decl_stmt|;
name|float
name|clusterUsagePerc
init|=
literal|0.0f
decl_stmt|;
if|if
condition|(
operator|!
name|calc
operator|.
name|isInvalidDivisor
argument_list|(
name|cluster
argument_list|)
condition|)
block|{
name|float
name|queueCapacityPerc
init|=
name|queue
operator|.
name|getQueueInfo
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|)
operator|.
name|getCapacity
argument_list|()
decl_stmt|;
name|queueUsagePerc
operator|=
name|calc
operator|.
name|divide
argument_list|(
name|cluster
argument_list|,
name|usedResourceClone
argument_list|,
name|Resources
operator|.
name|multiply
argument_list|(
name|cluster
argument_list|,
name|queueCapacityPerc
argument_list|)
argument_list|)
operator|*
literal|100
expr_stmt|;
if|if
condition|(
name|Float
operator|.
name|isNaN
argument_list|(
name|queueUsagePerc
argument_list|)
operator|||
name|Float
operator|.
name|isInfinite
argument_list|(
name|queueUsagePerc
argument_list|)
condition|)
block|{
name|queueUsagePerc
operator|=
literal|0.0f
expr_stmt|;
block|}
name|clusterUsagePerc
operator|=
name|calc
operator|.
name|divide
argument_list|(
name|cluster
argument_list|,
name|usedResourceClone
argument_list|,
name|cluster
argument_list|)
operator|*
literal|100
expr_stmt|;
block|}
return|return
name|ApplicationResourceUsageReport
operator|.
name|newInstance
argument_list|(
name|liveContainers
operator|.
name|size
argument_list|()
argument_list|,
name|reservedContainers
operator|.
name|size
argument_list|()
argument_list|,
name|usedResourceClone
argument_list|,
name|reservedResourceClone
argument_list|,
name|Resources
operator|.
name|add
argument_list|(
name|usedResourceClone
argument_list|,
name|reservedResourceClone
argument_list|)
argument_list|,
name|runningResourceUsage
operator|.
name|getResourceUsageSecondsMap
argument_list|()
argument_list|,
name|queueUsagePerc
argument_list|,
name|clusterUsagePerc
argument_list|,
name|preemptedResourceSecondsMaps
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getLiveContainersMap ()
specifier|public
name|Map
argument_list|<
name|ContainerId
argument_list|,
name|RMContainer
argument_list|>
name|getLiveContainersMap
parameter_list|()
block|{
return|return
name|this
operator|.
name|liveContainers
return|;
block|}
specifier|public
name|Map
argument_list|<
name|SchedulerRequestKey
argument_list|,
name|Long
argument_list|>
DECL|method|getLastScheduledContainer ()
name|getLastScheduledContainer
parameter_list|()
block|{
return|return
name|this
operator|.
name|lastScheduledContainer
return|;
block|}
DECL|method|transferStateFromPreviousAttempt ( SchedulerApplicationAttempt appAttempt)
specifier|public
name|void
name|transferStateFromPreviousAttempt
parameter_list|(
name|SchedulerApplicationAttempt
name|appAttempt
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|this
operator|.
name|liveContainers
operator|=
name|appAttempt
operator|.
name|getLiveContainersMap
argument_list|()
expr_stmt|;
comment|// this.reReservations = appAttempt.reReservations;
name|this
operator|.
name|attemptResourceUsage
operator|.
name|copyAllUsed
argument_list|(
name|appAttempt
operator|.
name|attemptResourceUsage
argument_list|)
expr_stmt|;
name|this
operator|.
name|setHeadroom
argument_list|(
name|appAttempt
operator|.
name|resourceLimit
argument_list|)
expr_stmt|;
comment|// this.currentReservation = appAttempt.currentReservation;
comment|// this.newlyAllocatedContainers = appAttempt.newlyAllocatedContainers;
comment|// this.schedulingOpportunities = appAttempt.schedulingOpportunities;
name|this
operator|.
name|lastScheduledContainer
operator|=
name|appAttempt
operator|.
name|getLastScheduledContainer
argument_list|()
expr_stmt|;
name|this
operator|.
name|appSchedulingInfo
operator|.
name|transferStateFromPreviousAppSchedulingInfo
argument_list|(
name|appAttempt
operator|.
name|appSchedulingInfo
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|move (Queue newQueue)
specifier|public
name|void
name|move
parameter_list|(
name|Queue
name|newQueue
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|QueueMetrics
name|oldMetrics
init|=
name|queue
operator|.
name|getMetrics
argument_list|()
decl_stmt|;
name|QueueMetrics
name|newMetrics
init|=
name|newQueue
operator|.
name|getMetrics
argument_list|()
decl_stmt|;
name|String
name|newQueueName
init|=
name|newQueue
operator|.
name|getQueueName
argument_list|()
decl_stmt|;
name|String
name|user
init|=
name|getUser
argument_list|()
decl_stmt|;
for|for
control|(
name|RMContainer
name|liveContainer
range|:
name|liveContainers
operator|.
name|values
argument_list|()
control|)
block|{
name|Resource
name|resource
init|=
name|liveContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getResource
argument_list|()
decl_stmt|;
operator|(
operator|(
name|RMContainerImpl
operator|)
name|liveContainer
operator|)
operator|.
name|setQueueName
argument_list|(
name|newQueueName
argument_list|)
expr_stmt|;
name|oldMetrics
operator|.
name|releaseResources
argument_list|(
name|liveContainer
operator|.
name|getNodeLabelExpression
argument_list|()
argument_list|,
name|user
argument_list|,
literal|1
argument_list|,
name|resource
argument_list|)
expr_stmt|;
name|newMetrics
operator|.
name|allocateResources
argument_list|(
name|liveContainer
operator|.
name|getNodeLabelExpression
argument_list|()
argument_list|,
name|user
argument_list|,
literal|1
argument_list|,
name|resource
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
argument_list|<
name|NodeId
argument_list|,
name|RMContainer
argument_list|>
name|map
range|:
name|reservedContainers
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|RMContainer
name|reservedContainer
range|:
name|map
operator|.
name|values
argument_list|()
control|)
block|{
operator|(
operator|(
name|RMContainerImpl
operator|)
name|reservedContainer
operator|)
operator|.
name|setQueueName
argument_list|(
name|newQueueName
argument_list|)
expr_stmt|;
name|Resource
name|resource
init|=
name|reservedContainer
operator|.
name|getReservedResource
argument_list|()
decl_stmt|;
name|oldMetrics
operator|.
name|unreserveResource
argument_list|(
name|reservedContainer
operator|.
name|getNodeLabelExpression
argument_list|()
argument_list|,
name|user
argument_list|,
name|resource
argument_list|)
expr_stmt|;
name|newMetrics
operator|.
name|reserveResource
argument_list|(
name|reservedContainer
operator|.
name|getNodeLabelExpression
argument_list|()
argument_list|,
name|user
argument_list|,
name|resource
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|isStopped
condition|)
block|{
name|appSchedulingInfo
operator|.
name|move
argument_list|(
name|newQueue
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|queue
operator|=
name|newQueue
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|recoverContainer (SchedulerNode node, RMContainer rmContainer)
specifier|public
name|void
name|recoverContainer
parameter_list|(
name|SchedulerNode
name|node
parameter_list|,
name|RMContainer
name|rmContainer
parameter_list|)
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// recover app scheduling info
name|appSchedulingInfo
operator|.
name|recoverContainer
argument_list|(
name|rmContainer
argument_list|,
name|node
operator|.
name|getPartition
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|rmContainer
operator|.
name|getState
argument_list|()
operator|.
name|equals
argument_list|(
name|RMContainerState
operator|.
name|COMPLETED
argument_list|)
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"SchedulerAttempt "
operator|+
name|getApplicationAttemptId
argument_list|()
operator|+
literal|" is recovering container "
operator|+
name|rmContainer
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
name|addRMContainer
argument_list|(
name|rmContainer
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|rmContainer
argument_list|)
expr_stmt|;
if|if
condition|(
name|rmContainer
operator|.
name|getExecutionType
argument_list|()
operator|==
name|ExecutionType
operator|.
name|GUARANTEED
condition|)
block|{
name|attemptResourceUsage
operator|.
name|incUsed
argument_list|(
name|node
operator|.
name|getPartition
argument_list|()
argument_list|,
name|rmContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// resourceLimit: updated when LeafQueue#recoverContainer#allocateResource
comment|// is called.
comment|// newlyAllocatedContainers.add(rmContainer);
comment|// schedulingOpportunities
comment|// lastScheduledContainer
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|incNumAllocatedContainers (NodeType containerType, NodeType requestType)
specifier|public
name|void
name|incNumAllocatedContainers
parameter_list|(
name|NodeType
name|containerType
parameter_list|,
name|NodeType
name|requestType
parameter_list|)
block|{
if|if
condition|(
name|containerType
operator|==
literal|null
operator|||
name|requestType
operator|==
literal|null
condition|)
block|{
comment|// Sanity check
return|return;
block|}
name|RMApp
name|app
init|=
name|rmContext
operator|.
name|getRMApps
argument_list|()
operator|.
name|get
argument_list|(
name|attemptId
operator|.
name|getApplicationId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|app
operator|!=
literal|null
condition|)
block|{
name|RMAppAttempt
name|attempt
init|=
name|app
operator|.
name|getCurrentAppAttempt
argument_list|()
decl_stmt|;
if|if
condition|(
name|attempt
operator|!=
literal|null
condition|)
block|{
name|attempt
operator|.
name|getRMAppAttemptMetrics
argument_list|()
operator|.
name|incNumAllocatedContainers
argument_list|(
name|containerType
argument_list|,
name|requestType
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|setApplicationHeadroomForMetrics (Resource headroom)
specifier|public
name|void
name|setApplicationHeadroomForMetrics
parameter_list|(
name|Resource
name|headroom
parameter_list|)
block|{
name|RMAppAttempt
name|attempt
init|=
name|rmContext
operator|.
name|getRMApps
argument_list|()
operator|.
name|get
argument_list|(
name|attemptId
operator|.
name|getApplicationId
argument_list|()
argument_list|)
operator|.
name|getCurrentAppAttempt
argument_list|()
decl_stmt|;
if|if
condition|(
name|attempt
operator|!=
literal|null
condition|)
block|{
name|attempt
operator|.
name|getRMAppAttemptMetrics
argument_list|()
operator|.
name|setApplicationAttemptHeadRoom
argument_list|(
name|Resources
operator|.
name|clone
argument_list|(
name|headroom
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|recordContainerRequestTime (long value)
specifier|public
name|void
name|recordContainerRequestTime
parameter_list|(
name|long
name|value
parameter_list|)
block|{
name|firstAllocationRequestSentTime
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
DECL|method|recordContainerAllocationTime (long value)
specifier|public
name|void
name|recordContainerAllocationTime
parameter_list|(
name|long
name|value
parameter_list|)
block|{
if|if
condition|(
name|firstContainerAllocatedTime
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
name|value
argument_list|)
condition|)
block|{
name|long
name|timediff
init|=
name|firstContainerAllocatedTime
operator|.
name|longValue
argument_list|()
operator|-
name|firstAllocationRequestSentTime
operator|.
name|longValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|timediff
operator|>
literal|0
condition|)
block|{
name|queue
operator|.
name|getMetrics
argument_list|()
operator|.
name|addAppAttemptFirstContainerAllocationDelay
argument_list|(
name|timediff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getBlacklistedNodes ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getBlacklistedNodes
parameter_list|()
block|{
return|return
name|this
operator|.
name|appSchedulingInfo
operator|.
name|getBlackListCopy
argument_list|()
return|;
block|}
annotation|@
name|Private
DECL|method|hasPendingResourceRequest (String nodePartition, SchedulingMode schedulingMode)
specifier|public
name|boolean
name|hasPendingResourceRequest
parameter_list|(
name|String
name|nodePartition
parameter_list|,
name|SchedulingMode
name|schedulingMode
parameter_list|)
block|{
comment|// We need to consider unconfirmed allocations
if|if
condition|(
name|schedulingMode
operator|==
name|SchedulingMode
operator|.
name|IGNORE_PARTITION_EXCLUSIVITY
condition|)
block|{
name|nodePartition
operator|=
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
expr_stmt|;
block|}
name|Resource
name|pending
init|=
name|attemptResourceUsage
operator|.
name|getPending
argument_list|(
name|nodePartition
argument_list|)
decl_stmt|;
comment|// TODO, need consider node partition here
comment|// To avoid too many allocation-proposals rejected for non-default
comment|// partition allocation
if|if
condition|(
name|StringUtils
operator|.
name|equals
argument_list|(
name|nodePartition
argument_list|,
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|)
condition|)
block|{
name|pending
operator|=
name|Resources
operator|.
name|subtractNonNegative
argument_list|(
name|pending
argument_list|,
name|Resources
operator|.
name|createResource
argument_list|(
name|unconfirmedAllocatedMem
operator|.
name|get
argument_list|()
argument_list|,
name|unconfirmedAllocatedVcores
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|!
name|Resources
operator|.
name|isNone
argument_list|(
name|pending
argument_list|)
return|;
block|}
comment|/*    * Note that the behavior of appAttemptResourceUsage is different from queue's    * For queue, used = actual-used + reserved    * For app, used = actual-used.    *    * TODO (wangda): Need to make behaviors of queue/app's resource usage    * consistent    */
annotation|@
name|VisibleForTesting
DECL|method|getAppAttemptResourceUsage ()
specifier|public
name|ResourceUsage
name|getAppAttemptResourceUsage
parameter_list|()
block|{
return|return
name|this
operator|.
name|attemptResourceUsage
return|;
block|}
annotation|@
name|Override
DECL|method|getPriority ()
specifier|public
name|Priority
name|getPriority
parameter_list|()
block|{
return|return
name|appPriority
return|;
block|}
DECL|method|setPriority (Priority appPriority)
specifier|public
name|void
name|setPriority
parameter_list|(
name|Priority
name|appPriority
parameter_list|)
block|{
name|this
operator|.
name|appPriority
operator|=
name|appPriority
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getId ()
specifier|public
name|String
name|getId
parameter_list|()
block|{
return|return
name|getApplicationId
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|compareInputOrderTo (SchedulableEntity other)
specifier|public
name|int
name|compareInputOrderTo
parameter_list|(
name|SchedulableEntity
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|instanceof
name|SchedulerApplicationAttempt
condition|)
block|{
return|return
name|getApplicationId
argument_list|()
operator|.
name|compareTo
argument_list|(
operator|(
operator|(
name|SchedulerApplicationAttempt
operator|)
name|other
operator|)
operator|.
name|getApplicationId
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|1
return|;
comment|//let other types go before this, if any
block|}
annotation|@
name|Override
DECL|method|getSchedulingResourceUsage ()
specifier|public
name|ResourceUsage
name|getSchedulingResourceUsage
parameter_list|()
block|{
return|return
name|attemptResourceUsage
return|;
block|}
DECL|method|setAppAMNodePartitionName (String partitionName)
specifier|public
name|void
name|setAppAMNodePartitionName
parameter_list|(
name|String
name|partitionName
parameter_list|)
block|{
name|this
operator|.
name|appAMNodePartitionName
operator|=
name|partitionName
expr_stmt|;
block|}
DECL|method|getAppAMNodePartitionName ()
specifier|public
name|String
name|getAppAMNodePartitionName
parameter_list|()
block|{
return|return
name|appAMNodePartitionName
return|;
block|}
DECL|method|updateAMContainerDiagnostics (AMState state, String diagnosticMessage)
specifier|public
name|void
name|updateAMContainerDiagnostics
parameter_list|(
name|AMState
name|state
parameter_list|,
name|String
name|diagnosticMessage
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isWaitingForAMContainer
argument_list|()
condition|)
block|{
return|return;
block|}
name|StringBuilder
name|diagnosticMessageBldr
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|diagnosticMessageBldr
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
operator|.
name|append
argument_list|(
name|fdf
operator|.
name|format
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"] "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|INACTIVATED
case|:
name|diagnosticMessageBldr
operator|.
name|append
argument_list|(
name|state
operator|.
name|diagnosticMessage
argument_list|)
expr_stmt|;
if|if
condition|(
name|diagnosticMessage
operator|!=
literal|null
condition|)
block|{
name|diagnosticMessageBldr
operator|.
name|append
argument_list|(
name|diagnosticMessage
argument_list|)
expr_stmt|;
block|}
name|getPendingAppDiagnosticMessage
argument_list|(
name|diagnosticMessageBldr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTIVATED
case|:
name|diagnosticMessageBldr
operator|.
name|append
argument_list|(
name|state
operator|.
name|diagnosticMessage
argument_list|)
expr_stmt|;
if|if
condition|(
name|diagnosticMessage
operator|!=
literal|null
condition|)
block|{
name|diagnosticMessageBldr
operator|.
name|append
argument_list|(
name|diagnosticMessage
argument_list|)
expr_stmt|;
block|}
name|getActivedAppDiagnosticMessage
argument_list|(
name|diagnosticMessageBldr
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// UNMANAGED , ASSIGNED
name|diagnosticMessageBldr
operator|.
name|append
argument_list|(
name|state
operator|.
name|diagnosticMessage
argument_list|)
expr_stmt|;
break|break;
block|}
name|appAttempt
operator|.
name|updateAMLaunchDiagnostics
argument_list|(
name|diagnosticMessageBldr
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|getPendingAppDiagnosticMessage ( StringBuilder diagnosticMessage)
specifier|protected
name|void
name|getPendingAppDiagnosticMessage
parameter_list|(
name|StringBuilder
name|diagnosticMessage
parameter_list|)
block|{
comment|// Give the specific information which might be applicable for the
comment|// respective scheduler
comment|// like partitionAMResourcelimit,UserAMResourceLimit, queue'AMResourceLimit
block|}
DECL|method|getActivedAppDiagnosticMessage ( StringBuilder diagnosticMessage)
specifier|protected
name|void
name|getActivedAppDiagnosticMessage
parameter_list|(
name|StringBuilder
name|diagnosticMessage
parameter_list|)
block|{
comment|// Give the specific information which might be applicable for the
comment|// respective scheduler
comment|// queue's resource usage for specific partition
block|}
DECL|method|getWriteLock ()
specifier|public
name|ReentrantReadWriteLock
operator|.
name|WriteLock
name|getWriteLock
parameter_list|()
block|{
return|return
name|writeLock
return|;
block|}
annotation|@
name|Override
DECL|method|isRecovering ()
specifier|public
name|boolean
name|isRecovering
parameter_list|()
block|{
return|return
name|isAttemptRecovering
return|;
block|}
DECL|method|setAttemptRecovering (boolean isRecovering)
specifier|protected
name|void
name|setAttemptRecovering
parameter_list|(
name|boolean
name|isRecovering
parameter_list|)
block|{
name|this
operator|.
name|isAttemptRecovering
operator|=
name|isRecovering
expr_stmt|;
block|}
DECL|method|getAppPlacementAllocator ( SchedulerRequestKey schedulerRequestKey)
specifier|public
parameter_list|<
name|N
extends|extends
name|SchedulerNode
parameter_list|>
name|AppPlacementAllocator
argument_list|<
name|N
argument_list|>
name|getAppPlacementAllocator
parameter_list|(
name|SchedulerRequestKey
name|schedulerRequestKey
parameter_list|)
block|{
return|return
name|appSchedulingInfo
operator|.
name|getAppPlacementAllocator
argument_list|(
name|schedulerRequestKey
argument_list|)
return|;
block|}
DECL|method|incUnconfirmedRes (Resource res)
specifier|public
name|void
name|incUnconfirmedRes
parameter_list|(
name|Resource
name|res
parameter_list|)
block|{
name|unconfirmedAllocatedMem
operator|.
name|addAndGet
argument_list|(
name|res
operator|.
name|getMemorySize
argument_list|()
argument_list|)
expr_stmt|;
name|unconfirmedAllocatedVcores
operator|.
name|addAndGet
argument_list|(
name|res
operator|.
name|getVirtualCores
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|decUnconfirmedRes (Resource res)
specifier|public
name|void
name|decUnconfirmedRes
parameter_list|(
name|Resource
name|res
parameter_list|)
block|{
name|unconfirmedAllocatedMem
operator|.
name|addAndGet
argument_list|(
operator|-
name|res
operator|.
name|getMemorySize
argument_list|()
argument_list|)
expr_stmt|;
name|unconfirmedAllocatedVcores
operator|.
name|addAndGet
argument_list|(
operator|-
name|res
operator|.
name|getVirtualCores
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|getApplicationAttemptId
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|SchedulerApplicationAttempt
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|SchedulerApplicationAttempt
name|other
init|=
operator|(
name|SchedulerApplicationAttempt
operator|)
name|o
decl_stmt|;
return|return
operator|(
name|this
operator|==
name|other
operator|||
name|this
operator|.
name|getApplicationAttemptId
argument_list|()
operator|.
name|equals
argument_list|(
name|other
operator|.
name|getApplicationAttemptId
argument_list|()
argument_list|)
operator|)
return|;
block|}
comment|/**    * Different state for Application Master, user can see this state from web UI    */
DECL|enum|AMState
specifier|public
enum|enum
name|AMState
block|{
DECL|enumConstant|UNMANAGED
name|UNMANAGED
argument_list|(
literal|"User launched the Application Master, since it's unmanaged. "
argument_list|)
block|,
DECL|enumConstant|INACTIVATED
name|INACTIVATED
argument_list|(
literal|"Application is added to the scheduler and is not yet activated. "
argument_list|)
block|,
DECL|enumConstant|ACTIVATED
name|ACTIVATED
argument_list|(
literal|"Application is Activated, waiting for resources to be assigned for AM. "
argument_list|)
block|,
DECL|enumConstant|ASSIGNED
name|ASSIGNED
argument_list|(
literal|"Scheduler has assigned a container for AM, waiting for AM "
operator|+
literal|"container to be launched"
argument_list|)
block|,
DECL|enumConstant|LAUNCHED
name|LAUNCHED
argument_list|(
literal|"AM container is launched, waiting for AM container to Register "
operator|+
literal|"with RM"
argument_list|)
block|;
DECL|field|diagnosticMessage
specifier|private
name|String
name|diagnosticMessage
decl_stmt|;
DECL|method|AMState (String diagnosticMessage)
name|AMState
parameter_list|(
name|String
name|diagnosticMessage
parameter_list|)
block|{
name|this
operator|.
name|diagnosticMessage
operator|=
name|diagnosticMessage
expr_stmt|;
block|}
DECL|method|getDiagnosticMessage ()
specifier|public
name|String
name|getDiagnosticMessage
parameter_list|()
block|{
return|return
name|diagnosticMessage
return|;
block|}
block|}
DECL|method|getApplicationSchedulingEnvs ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getApplicationSchedulingEnvs
parameter_list|()
block|{
return|return
name|this
operator|.
name|applicationSchedulingEnvs
return|;
block|}
annotation|@
name|Override
DECL|method|getPartition ()
specifier|public
name|String
name|getPartition
parameter_list|()
block|{
return|return
name|nodeLabelExpression
operator|==
literal|null
condition|?
literal|""
else|:
name|nodeLabelExpression
return|;
block|}
block|}
end_class

end_unit

