begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.resourcemanager.recovery
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|recovery
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|CuratorFramework
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|Private
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
operator|.
name|Unstable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ZKUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|curator
operator|.
name|ZKCuratorManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|curator
operator|.
name|ZKCuratorManager
operator|.
name|SafeTransaction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationAttemptId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ReservationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|HAUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnRuntimeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|proto
operator|.
name|YarnServerCommonProtos
operator|.
name|VersionProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|proto
operator|.
name|YarnServerResourceManagerRecoveryProtos
operator|.
name|AMRMTokenSecretManagerStateProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|proto
operator|.
name|YarnServerResourceManagerRecoveryProtos
operator|.
name|ApplicationAttemptStateDataProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|proto
operator|.
name|YarnServerResourceManagerRecoveryProtos
operator|.
name|ApplicationStateDataProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|proto
operator|.
name|YarnServerResourceManagerRecoveryProtos
operator|.
name|EpochProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|proto
operator|.
name|YarnProtos
operator|.
name|ReservationAllocationStateProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|security
operator|.
name|client
operator|.
name|RMDelegationTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|records
operator|.
name|Version
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|records
operator|.
name|impl
operator|.
name|pb
operator|.
name|VersionPBImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|recovery
operator|.
name|records
operator|.
name|AMRMTokenSecretManagerState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|recovery
operator|.
name|records
operator|.
name|ApplicationAttemptStateData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|recovery
operator|.
name|records
operator|.
name|ApplicationStateData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|recovery
operator|.
name|records
operator|.
name|Epoch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|recovery
operator|.
name|records
operator|.
name|RMDelegationTokenIdentifierData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|recovery
operator|.
name|records
operator|.
name|impl
operator|.
name|pb
operator|.
name|AMRMTokenSecretManagerStatePBImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|recovery
operator|.
name|records
operator|.
name|impl
operator|.
name|pb
operator|.
name|ApplicationAttemptStateDataPBImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|recovery
operator|.
name|records
operator|.
name|impl
operator|.
name|pb
operator|.
name|ApplicationStateDataPBImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|recovery
operator|.
name|records
operator|.
name|impl
operator|.
name|pb
operator|.
name|EpochPBImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|CreateMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|ZooDefs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|ACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Id
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Stat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|server
operator|.
name|auth
operator|.
name|DigestAuthenticationProvider
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchAlgorithmException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * {@link RMStateStore} implementation backed by ZooKeeper.  *  * The znode structure is as follows:  * ROOT_DIR_PATH  * |--- VERSION_INFO  * |--- EPOCH_NODE  * |--- RM_ZK_FENCING_LOCK  * |--- RM_APP_ROOT  * |     |----- HIERARCHIES  * |     |        |----- 1  * |     |        |      |----- (#ApplicationId barring last character)  * |     |        |      |       |----- (#Last character of ApplicationId)  * |     |        |      |       |       |----- (#ApplicationAttemptIds)  * |     |        |      ....  * |     |        |  * |     |        |----- 2  * |     |        |      |----- (#ApplicationId barring last 2 characters)  * |     |        |      |       |----- (#Last 2 characters of ApplicationId)  * |     |        |      |       |       |----- (#ApplicationAttemptIds)  * |     |        |      ....  * |     |        |  * |     |        |----- 3  * |     |        |      |----- (#ApplicationId barring last 3 characters)  * |     |        |      |       |----- (#Last 3 characters of ApplicationId)  * |     |        |      |       |       |----- (#ApplicationAttemptIds)  * |     |        |      ....  * |     |        |  * |     |        |----- 4  * |     |        |      |----- (#ApplicationId barring last 4 characters)  * |     |        |      |       |----- (#Last 4 characters of ApplicationId)  * |     |        |      |       |       |----- (#ApplicationAttemptIds)  * |     |        |      ....  * |     |        |  * |     |----- (#ApplicationId1)  * |     |        |----- (#ApplicationAttemptIds)  * |     |  * |     |----- (#ApplicationId2)  * |     |       |----- (#ApplicationAttemptIds)  * |     ....  * |  * |--- RM_DT_SECRET_MANAGER_ROOT  *        |----- RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME  *        |----- RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME  *        |       |----- 1  *        |       |      |----- (#TokenId barring last character)  *        |       |      |       |----- (#Last character of TokenId)  *        |       |      ....  *        |       |----- 2  *        |       |      |----- (#TokenId barring last 2 characters)  *        |       |      |       |----- (#Last 2 characters of TokenId)  *        |       |      ....  *        |       |----- 3  *        |       |      |----- (#TokenId barring last 3 characters)  *        |       |      |       |----- (#Last 3 characters of TokenId)  *        |       |      ....  *        |       |----- 4  *        |       |      |----- (#TokenId barring last 4 characters)  *        |       |      |       |----- (#Last 4 characters of TokenId)  *        |       |      ....  *        |       |----- Token_1  *        |       |----- Token_2  *        |       ....  *        |  *        |----- RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME  *        |      |----- Key_1  *        |      |----- Key_2  *                ....  * |--- AMRMTOKEN_SECRET_MANAGER_ROOT  *        |----- currentMasterKey  *        |----- nextMasterKey  *  * |-- RESERVATION_SYSTEM_ROOT  *        |------PLAN_1  *        |      |------ RESERVATION_1  *        |      |------ RESERVATION_2  *        |      ....  *        |------PLAN_2  *        ....  * Note: Changes from 1.1 to 1.2 - AMRMTokenSecretManager state has been saved  * separately. The currentMasterkey and nextMasterkey have been stored.  * Also, AMRMToken has been removed from ApplicationAttemptState.  *  * Changes from 1.2 to 1.3, Addition of ReservationSystem state.  *  * Changes from 1.3 to 1.4 - Change the structure of application znode by  * splitting it in 2 parts, depending on a configurable split index. This limits  * the number of application znodes returned in a single call while loading  * app state.  *  * Changes from 1.4 to 1.5 - Change the structure of delegation token znode by  * splitting it in 2 parts, depending on a configurable split index. This limits  * the number of delegation token znodes returned in a single call while loading  * tokens state.  */
end_comment

begin_class
annotation|@
name|Private
annotation|@
name|Unstable
DECL|class|ZKRMStateStore
specifier|public
class|class
name|ZKRMStateStore
extends|extends
name|RMStateStore
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ZKRMStateStore
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME
specifier|private
specifier|static
specifier|final
name|String
name|RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME
init|=
literal|"RMDelegationTokensRoot"
decl_stmt|;
DECL|field|RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME
specifier|private
specifier|static
specifier|final
name|String
name|RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME
init|=
literal|"RMDTSequentialNumber"
decl_stmt|;
DECL|field|RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME
specifier|private
specifier|static
specifier|final
name|String
name|RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME
init|=
literal|"RMDTMasterKeysRoot"
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|ROOT_ZNODE_NAME
specifier|public
specifier|static
specifier|final
name|String
name|ROOT_ZNODE_NAME
init|=
literal|"ZKRMStateRoot"
decl_stmt|;
DECL|field|CURRENT_VERSION_INFO
specifier|protected
specifier|static
specifier|final
name|Version
name|CURRENT_VERSION_INFO
init|=
name|Version
operator|.
name|newInstance
argument_list|(
literal|1
argument_list|,
literal|5
argument_list|)
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|RM_APP_ROOT_HIERARCHIES
specifier|public
specifier|static
specifier|final
name|String
name|RM_APP_ROOT_HIERARCHIES
init|=
literal|"HIERARCHIES"
decl_stmt|;
comment|/* Znode paths */
DECL|field|zkRootNodePath
specifier|private
name|String
name|zkRootNodePath
decl_stmt|;
DECL|field|rmAppRoot
specifier|private
name|String
name|rmAppRoot
decl_stmt|;
DECL|field|rmAppRootHierarchies
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|rmAppRootHierarchies
decl_stmt|;
DECL|field|rmDelegationTokenHierarchies
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|rmDelegationTokenHierarchies
decl_stmt|;
DECL|field|rmDTSecretManagerRoot
specifier|private
name|String
name|rmDTSecretManagerRoot
decl_stmt|;
DECL|field|dtMasterKeysRootPath
specifier|private
name|String
name|dtMasterKeysRootPath
decl_stmt|;
DECL|field|delegationTokensRootPath
specifier|private
name|String
name|delegationTokensRootPath
decl_stmt|;
DECL|field|dtSequenceNumberPath
specifier|private
name|String
name|dtSequenceNumberPath
decl_stmt|;
DECL|field|amrmTokenSecretManagerRoot
specifier|private
name|String
name|amrmTokenSecretManagerRoot
decl_stmt|;
DECL|field|reservationRoot
specifier|private
name|String
name|reservationRoot
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|znodeWorkingPath
specifier|protected
name|String
name|znodeWorkingPath
decl_stmt|;
DECL|field|appIdNodeSplitIndex
specifier|private
name|int
name|appIdNodeSplitIndex
init|=
literal|0
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|delegationTokenNodeSplitIndex
specifier|protected
name|int
name|delegationTokenNodeSplitIndex
init|=
literal|0
decl_stmt|;
comment|/* Fencing related variables */
DECL|field|FENCING_LOCK
specifier|private
specifier|static
specifier|final
name|String
name|FENCING_LOCK
init|=
literal|"RM_ZK_FENCING_LOCK"
decl_stmt|;
DECL|field|fencingNodePath
specifier|private
name|String
name|fencingNodePath
decl_stmt|;
DECL|field|verifyActiveStatusThread
specifier|private
name|Thread
name|verifyActiveStatusThread
decl_stmt|;
DECL|field|zkSessionTimeout
specifier|private
name|int
name|zkSessionTimeout
decl_stmt|;
DECL|field|zknodeLimit
specifier|private
name|int
name|zknodeLimit
decl_stmt|;
comment|/* ACL and auth info */
DECL|field|zkAcl
specifier|private
name|List
argument_list|<
name|ACL
argument_list|>
name|zkAcl
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|zkRootNodeAcl
name|List
argument_list|<
name|ACL
argument_list|>
name|zkRootNodeAcl
decl_stmt|;
DECL|field|zkRootNodeUsername
specifier|private
name|String
name|zkRootNodeUsername
decl_stmt|;
DECL|field|CREATE_DELETE_PERMS
specifier|private
specifier|static
specifier|final
name|int
name|CREATE_DELETE_PERMS
init|=
name|ZooDefs
operator|.
name|Perms
operator|.
name|CREATE
operator||
name|ZooDefs
operator|.
name|Perms
operator|.
name|DELETE
decl_stmt|;
DECL|field|zkRootNodeAuthScheme
specifier|private
specifier|final
name|String
name|zkRootNodeAuthScheme
init|=
operator|new
name|DigestAuthenticationProvider
argument_list|()
operator|.
name|getScheme
argument_list|()
decl_stmt|;
comment|/** Manager for the ZooKeeper connection. */
DECL|field|zkManager
specifier|private
name|ZKCuratorManager
name|zkManager
decl_stmt|;
comment|/*    * Indicates different app attempt state store operations.    */
DECL|enum|AppAttemptOp
specifier|private
enum|enum
name|AppAttemptOp
block|{
DECL|enumConstant|STORE
name|STORE
block|,
DECL|enumConstant|UPDATE
name|UPDATE
block|,
DECL|enumConstant|REMOVE
name|REMOVE
block|}
empty_stmt|;
comment|/**    * Encapsulates znode path and corresponding split index for hierarchical    * znode layouts.    */
DECL|class|ZnodeSplitInfo
specifier|private
specifier|final
specifier|static
class|class
name|ZnodeSplitInfo
block|{
DECL|field|path
specifier|private
specifier|final
name|String
name|path
decl_stmt|;
DECL|field|splitIndex
specifier|private
specifier|final
name|int
name|splitIndex
decl_stmt|;
DECL|method|ZnodeSplitInfo (String path, int splitIndex)
name|ZnodeSplitInfo
parameter_list|(
name|String
name|path
parameter_list|,
name|int
name|splitIndex
parameter_list|)
block|{
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|splitIndex
operator|=
name|splitIndex
expr_stmt|;
block|}
block|}
comment|/**    * Given the {@link Configuration} and {@link ACL}s used (sourceACLs) for    * ZooKeeper access, construct the {@link ACL}s for the store's root node.    * In the constructed {@link ACL}, all the users allowed by sourceACLs are    * given read-write-admin access, while the current RM has exclusive    * create-delete access.    *    * To be called only when HA is enabled and the configuration doesn't set an    * ACL for the root node.    * @param conf the configuration    * @param sourceACLs the source ACLs    * @return ACLs for the store's root node    * @throws java.security.NoSuchAlgorithmException thrown if the digest    * algorithm used by Zookeeper cannot be found    */
annotation|@
name|VisibleForTesting
annotation|@
name|Private
annotation|@
name|Unstable
DECL|method|constructZkRootNodeACL (Configuration conf, List<ACL> sourceACLs)
specifier|protected
name|List
argument_list|<
name|ACL
argument_list|>
name|constructZkRootNodeACL
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|List
argument_list|<
name|ACL
argument_list|>
name|sourceACLs
parameter_list|)
throws|throws
name|NoSuchAlgorithmException
block|{
name|List
argument_list|<
name|ACL
argument_list|>
name|zkRootNodeAclList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ACL
name|acl
range|:
name|sourceACLs
control|)
block|{
name|zkRootNodeAclList
operator|.
name|add
argument_list|(
operator|new
name|ACL
argument_list|(
name|ZKUtil
operator|.
name|removeSpecificPerms
argument_list|(
name|acl
operator|.
name|getPerms
argument_list|()
argument_list|,
name|CREATE_DELETE_PERMS
argument_list|)
argument_list|,
name|acl
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zkRootNodeUsername
operator|=
name|HAUtil
operator|.
name|getConfValueForRMInstance
argument_list|(
name|YarnConfiguration
operator|.
name|RM_ADDRESS
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_RM_ADDRESS
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|Id
name|rmId
init|=
operator|new
name|Id
argument_list|(
name|zkRootNodeAuthScheme
argument_list|,
name|DigestAuthenticationProvider
operator|.
name|generateDigest
argument_list|(
name|zkRootNodeUsername
operator|+
literal|":"
operator|+
name|resourceManager
operator|.
name|getZkRootNodePassword
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|zkRootNodeAclList
operator|.
name|add
argument_list|(
operator|new
name|ACL
argument_list|(
name|CREATE_DELETE_PERMS
argument_list|,
name|rmId
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|zkRootNodeAclList
return|;
block|}
annotation|@
name|Override
DECL|method|initInternal (Configuration conf)
specifier|public
specifier|synchronized
name|void
name|initInternal
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|NoSuchAlgorithmException
block|{
comment|/* Initialize fencing related paths, acls, and ops */
name|znodeWorkingPath
operator|=
name|conf
operator|.
name|get
argument_list|(
name|YarnConfiguration
operator|.
name|ZK_RM_STATE_STORE_PARENT_PATH
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_ZK_RM_STATE_STORE_PARENT_PATH
argument_list|)
expr_stmt|;
name|zkRootNodePath
operator|=
name|getNodePath
argument_list|(
name|znodeWorkingPath
argument_list|,
name|ROOT_ZNODE_NAME
argument_list|)
expr_stmt|;
name|rmAppRoot
operator|=
name|getNodePath
argument_list|(
name|zkRootNodePath
argument_list|,
name|RM_APP_ROOT
argument_list|)
expr_stmt|;
name|String
name|hierarchiesPath
init|=
name|getNodePath
argument_list|(
name|rmAppRoot
argument_list|,
name|RM_APP_ROOT_HIERARCHIES
argument_list|)
decl_stmt|;
name|rmAppRootHierarchies
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|rmAppRootHierarchies
operator|.
name|put
argument_list|(
literal|0
argument_list|,
name|rmAppRoot
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|splitIndex
init|=
literal|1
init|;
name|splitIndex
operator|<=
literal|4
condition|;
name|splitIndex
operator|++
control|)
block|{
name|rmAppRootHierarchies
operator|.
name|put
argument_list|(
name|splitIndex
argument_list|,
name|getNodePath
argument_list|(
name|hierarchiesPath
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|splitIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fencingNodePath
operator|=
name|getNodePath
argument_list|(
name|zkRootNodePath
argument_list|,
name|FENCING_LOCK
argument_list|)
expr_stmt|;
name|zkSessionTimeout
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|YarnConfiguration
operator|.
name|RM_ZK_TIMEOUT_MS
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_RM_ZK_TIMEOUT_MS
argument_list|)
expr_stmt|;
name|zknodeLimit
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|YarnConfiguration
operator|.
name|RM_ZK_ZNODE_SIZE_LIMIT_BYTES
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_RM_ZK_ZNODE_SIZE_LIMIT_BYTES
argument_list|)
expr_stmt|;
name|appIdNodeSplitIndex
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|YarnConfiguration
operator|.
name|ZK_APPID_NODE_SPLIT_INDEX
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_ZK_APPID_NODE_SPLIT_INDEX
argument_list|)
expr_stmt|;
if|if
condition|(
name|appIdNodeSplitIndex
argument_list|<
literal|0
operator|||
name|appIdNodeSplitIndex
argument_list|>
literal|4
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Invalid value "
operator|+
name|appIdNodeSplitIndex
operator|+
literal|" for config "
operator|+
name|YarnConfiguration
operator|.
name|ZK_APPID_NODE_SPLIT_INDEX
operator|+
literal|" specified. "
operator|+
literal|"Resetting it to "
operator|+
name|YarnConfiguration
operator|.
name|DEFAULT_ZK_APPID_NODE_SPLIT_INDEX
argument_list|)
expr_stmt|;
name|appIdNodeSplitIndex
operator|=
name|YarnConfiguration
operator|.
name|DEFAULT_ZK_APPID_NODE_SPLIT_INDEX
expr_stmt|;
block|}
name|zkAcl
operator|=
name|ZKCuratorManager
operator|.
name|getZKAcls
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAUtil
operator|.
name|isHAEnabled
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|String
name|zkRootNodeAclConf
init|=
name|HAUtil
operator|.
name|getConfValueForRMInstance
argument_list|(
name|YarnConfiguration
operator|.
name|ZK_RM_STATE_STORE_ROOT_NODE_ACL
argument_list|,
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|zkRootNodeAclConf
operator|!=
literal|null
condition|)
block|{
name|zkRootNodeAclConf
operator|=
name|ZKUtil
operator|.
name|resolveConfIndirection
argument_list|(
name|zkRootNodeAclConf
argument_list|)
expr_stmt|;
try|try
block|{
name|zkRootNodeAcl
operator|=
name|ZKUtil
operator|.
name|parseACLs
argument_list|(
name|zkRootNodeAclConf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ZKUtil
operator|.
name|BadAclFormatException
name|bafe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid format for "
operator|+
name|YarnConfiguration
operator|.
name|ZK_RM_STATE_STORE_ROOT_NODE_ACL
argument_list|)
expr_stmt|;
throw|throw
name|bafe
throw|;
block|}
block|}
else|else
block|{
name|zkRootNodeAcl
operator|=
name|constructZkRootNodeACL
argument_list|(
name|conf
argument_list|,
name|zkAcl
argument_list|)
expr_stmt|;
block|}
block|}
name|rmDTSecretManagerRoot
operator|=
name|getNodePath
argument_list|(
name|zkRootNodePath
argument_list|,
name|RM_DT_SECRET_MANAGER_ROOT
argument_list|)
expr_stmt|;
name|dtMasterKeysRootPath
operator|=
name|getNodePath
argument_list|(
name|rmDTSecretManagerRoot
argument_list|,
name|RM_DT_MASTER_KEYS_ROOT_ZNODE_NAME
argument_list|)
expr_stmt|;
name|delegationTokensRootPath
operator|=
name|getNodePath
argument_list|(
name|rmDTSecretManagerRoot
argument_list|,
name|RM_DELEGATION_TOKENS_ROOT_ZNODE_NAME
argument_list|)
expr_stmt|;
name|rmDelegationTokenHierarchies
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|rmDelegationTokenHierarchies
operator|.
name|put
argument_list|(
literal|0
argument_list|,
name|delegationTokensRootPath
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|splitIndex
init|=
literal|1
init|;
name|splitIndex
operator|<=
literal|4
condition|;
name|splitIndex
operator|++
control|)
block|{
name|rmDelegationTokenHierarchies
operator|.
name|put
argument_list|(
name|splitIndex
argument_list|,
name|getNodePath
argument_list|(
name|delegationTokensRootPath
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|splitIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dtSequenceNumberPath
operator|=
name|getNodePath
argument_list|(
name|rmDTSecretManagerRoot
argument_list|,
name|RM_DT_SEQUENTIAL_NUMBER_ZNODE_NAME
argument_list|)
expr_stmt|;
name|amrmTokenSecretManagerRoot
operator|=
name|getNodePath
argument_list|(
name|zkRootNodePath
argument_list|,
name|AMRMTOKEN_SECRET_MANAGER_ROOT
argument_list|)
expr_stmt|;
name|reservationRoot
operator|=
name|getNodePath
argument_list|(
name|zkRootNodePath
argument_list|,
name|RESERVATION_SYSTEM_ROOT
argument_list|)
expr_stmt|;
name|zkManager
operator|=
name|resourceManager
operator|.
name|getZKManager
argument_list|()
expr_stmt|;
if|if
condition|(
name|zkManager
operator|==
literal|null
condition|)
block|{
name|zkManager
operator|=
name|resourceManager
operator|.
name|createAndStartZKManager
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
name|delegationTokenNodeSplitIndex
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|YarnConfiguration
operator|.
name|ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX
argument_list|)
expr_stmt|;
if|if
condition|(
name|delegationTokenNodeSplitIndex
argument_list|<
literal|0
operator|||
name|delegationTokenNodeSplitIndex
argument_list|>
literal|4
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Invalid value "
operator|+
name|delegationTokenNodeSplitIndex
operator|+
literal|" for config "
operator|+
name|YarnConfiguration
operator|.
name|ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX
operator|+
literal|" specified.  Resetting it to "
operator|+
name|YarnConfiguration
operator|.
name|DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX
argument_list|)
expr_stmt|;
name|delegationTokenNodeSplitIndex
operator|=
name|YarnConfiguration
operator|.
name|DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|startInternal ()
specifier|public
specifier|synchronized
name|void
name|startInternal
parameter_list|()
throws|throws
name|Exception
block|{
comment|// ensure root dirs exist
name|zkManager
operator|.
name|createRootDirRecursively
argument_list|(
name|znodeWorkingPath
argument_list|)
expr_stmt|;
name|create
argument_list|(
name|zkRootNodePath
argument_list|)
expr_stmt|;
name|setRootNodeAcls
argument_list|()
expr_stmt|;
name|delete
argument_list|(
name|fencingNodePath
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAUtil
operator|.
name|isHAEnabled
argument_list|(
name|getConfig
argument_list|()
argument_list|)
operator|&&
operator|!
name|HAUtil
operator|.
name|isAutomaticFailoverEnabled
argument_list|(
name|getConfig
argument_list|()
argument_list|)
condition|)
block|{
name|verifyActiveStatusThread
operator|=
operator|new
name|VerifyActiveStatusThread
argument_list|()
expr_stmt|;
name|verifyActiveStatusThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|create
argument_list|(
name|rmAppRoot
argument_list|)
expr_stmt|;
name|create
argument_list|(
name|getNodePath
argument_list|(
name|rmAppRoot
argument_list|,
name|RM_APP_ROOT_HIERARCHIES
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|splitIndex
init|=
literal|1
init|;
name|splitIndex
operator|<=
literal|4
condition|;
name|splitIndex
operator|++
control|)
block|{
name|create
argument_list|(
name|rmAppRootHierarchies
operator|.
name|get
argument_list|(
name|splitIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|create
argument_list|(
name|rmDTSecretManagerRoot
argument_list|)
expr_stmt|;
name|create
argument_list|(
name|dtMasterKeysRootPath
argument_list|)
expr_stmt|;
name|create
argument_list|(
name|delegationTokensRootPath
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|splitIndex
init|=
literal|1
init|;
name|splitIndex
operator|<=
literal|4
condition|;
name|splitIndex
operator|++
control|)
block|{
name|create
argument_list|(
name|rmDelegationTokenHierarchies
operator|.
name|get
argument_list|(
name|splitIndex
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|create
argument_list|(
name|dtSequenceNumberPath
argument_list|)
expr_stmt|;
name|create
argument_list|(
name|amrmTokenSecretManagerRoot
argument_list|)
expr_stmt|;
name|create
argument_list|(
name|reservationRoot
argument_list|)
expr_stmt|;
block|}
DECL|method|logRootNodeAcls (String prefix)
specifier|private
name|void
name|logRootNodeAcls
parameter_list|(
name|String
name|prefix
parameter_list|)
throws|throws
name|Exception
block|{
name|Stat
name|getStat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ACL
argument_list|>
name|getAcls
init|=
name|getACL
argument_list|(
name|zkRootNodePath
argument_list|)
decl_stmt|;
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
for|for
control|(
name|ACL
name|acl
range|:
name|getAcls
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|acl
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|append
argument_list|(
name|getStat
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|builder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|setRootNodeAcls ()
specifier|private
name|void
name|setRootNodeAcls
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logRootNodeAcls
argument_list|(
literal|"Before setting ACLs'\n"
argument_list|)
expr_stmt|;
block|}
name|CuratorFramework
name|curatorFramework
init|=
name|zkManager
operator|.
name|getCurator
argument_list|()
decl_stmt|;
if|if
condition|(
name|HAUtil
operator|.
name|isHAEnabled
argument_list|(
name|getConfig
argument_list|()
argument_list|)
condition|)
block|{
name|curatorFramework
operator|.
name|setACL
argument_list|()
operator|.
name|withACL
argument_list|(
name|zkRootNodeAcl
argument_list|)
operator|.
name|forPath
argument_list|(
name|zkRootNodePath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|curatorFramework
operator|.
name|setACL
argument_list|()
operator|.
name|withACL
argument_list|(
name|zkAcl
argument_list|)
operator|.
name|forPath
argument_list|(
name|zkRootNodePath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logRootNodeAcls
argument_list|(
literal|"After setting ACLs'\n"
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|closeInternal ()
specifier|protected
specifier|synchronized
name|void
name|closeInternal
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|verifyActiveStatusThread
operator|!=
literal|null
condition|)
block|{
name|verifyActiveStatusThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|verifyActiveStatusThread
operator|.
name|join
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|HAUtil
operator|.
name|isHAEnabled
argument_list|(
name|getConfig
argument_list|()
argument_list|)
condition|)
block|{
name|CuratorFramework
name|curatorFramework
init|=
name|zkManager
operator|.
name|getCurator
argument_list|()
decl_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|curatorFramework
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getCurrentVersion ()
specifier|protected
name|Version
name|getCurrentVersion
parameter_list|()
block|{
return|return
name|CURRENT_VERSION_INFO
return|;
block|}
annotation|@
name|Override
DECL|method|storeVersion ()
specifier|protected
specifier|synchronized
name|void
name|storeVersion
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|versionNodePath
init|=
name|getNodePath
argument_list|(
name|zkRootNodePath
argument_list|,
name|VERSION_NODE
argument_list|)
decl_stmt|;
name|byte
index|[]
name|data
init|=
operator|(
operator|(
name|VersionPBImpl
operator|)
name|CURRENT_VERSION_INFO
operator|)
operator|.
name|getProto
argument_list|()
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
if|if
condition|(
name|exists
argument_list|(
name|versionNodePath
argument_list|)
condition|)
block|{
name|zkManager
operator|.
name|safeSetData
argument_list|(
name|versionNodePath
argument_list|,
name|data
argument_list|,
operator|-
literal|1
argument_list|,
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zkManager
operator|.
name|safeCreate
argument_list|(
name|versionNodePath
argument_list|,
name|data
argument_list|,
name|zkAcl
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|,
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|loadVersion ()
specifier|protected
specifier|synchronized
name|Version
name|loadVersion
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|versionNodePath
init|=
name|getNodePath
argument_list|(
name|zkRootNodePath
argument_list|,
name|VERSION_NODE
argument_list|)
decl_stmt|;
if|if
condition|(
name|exists
argument_list|(
name|versionNodePath
argument_list|)
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|getData
argument_list|(
name|versionNodePath
argument_list|)
decl_stmt|;
return|return
operator|new
name|VersionPBImpl
argument_list|(
name|VersionProto
operator|.
name|parseFrom
argument_list|(
name|data
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|getAndIncrementEpoch ()
specifier|public
specifier|synchronized
name|long
name|getAndIncrementEpoch
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|epochNodePath
init|=
name|getNodePath
argument_list|(
name|zkRootNodePath
argument_list|,
name|EPOCH_NODE
argument_list|)
decl_stmt|;
name|long
name|currentEpoch
init|=
name|baseEpoch
decl_stmt|;
if|if
condition|(
name|exists
argument_list|(
name|epochNodePath
argument_list|)
condition|)
block|{
comment|// load current epoch
name|byte
index|[]
name|data
init|=
name|getData
argument_list|(
name|epochNodePath
argument_list|)
decl_stmt|;
name|Epoch
name|epoch
init|=
operator|new
name|EpochPBImpl
argument_list|(
name|EpochProto
operator|.
name|parseFrom
argument_list|(
name|data
argument_list|)
argument_list|)
decl_stmt|;
name|currentEpoch
operator|=
name|epoch
operator|.
name|getEpoch
argument_list|()
expr_stmt|;
comment|// increment epoch and store it
name|byte
index|[]
name|storeData
init|=
name|Epoch
operator|.
name|newInstance
argument_list|(
name|currentEpoch
operator|+
literal|1
argument_list|)
operator|.
name|getProto
argument_list|()
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|zkManager
operator|.
name|safeSetData
argument_list|(
name|epochNodePath
argument_list|,
name|storeData
argument_list|,
operator|-
literal|1
argument_list|,
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// initialize epoch node with 1 for the next time.
name|byte
index|[]
name|storeData
init|=
name|Epoch
operator|.
name|newInstance
argument_list|(
name|currentEpoch
operator|+
literal|1
argument_list|)
operator|.
name|getProto
argument_list|()
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|zkManager
operator|.
name|safeCreate
argument_list|(
name|epochNodePath
argument_list|,
name|storeData
argument_list|,
name|zkAcl
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|,
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
expr_stmt|;
block|}
return|return
name|currentEpoch
return|;
block|}
annotation|@
name|Override
DECL|method|loadState ()
specifier|public
specifier|synchronized
name|RMState
name|loadState
parameter_list|()
throws|throws
name|Exception
block|{
name|RMState
name|rmState
init|=
operator|new
name|RMState
argument_list|()
decl_stmt|;
comment|// recover DelegationTokenSecretManager
name|loadRMDTSecretManagerState
argument_list|(
name|rmState
argument_list|)
expr_stmt|;
comment|// recover RM applications
name|loadRMAppState
argument_list|(
name|rmState
argument_list|)
expr_stmt|;
comment|// recover AMRMTokenSecretManager
name|loadAMRMTokenSecretManagerState
argument_list|(
name|rmState
argument_list|)
expr_stmt|;
comment|// recover reservation state
name|loadReservationSystemState
argument_list|(
name|rmState
argument_list|)
expr_stmt|;
return|return
name|rmState
return|;
block|}
DECL|method|loadReservationSystemState (RMState rmState)
specifier|private
name|void
name|loadReservationSystemState
parameter_list|(
name|RMState
name|rmState
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|String
argument_list|>
name|planNodes
init|=
name|getChildren
argument_list|(
name|reservationRoot
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|planName
range|:
name|planNodes
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Loading plan from znode: "
operator|+
name|planName
argument_list|)
expr_stmt|;
block|}
name|String
name|planNodePath
init|=
name|getNodePath
argument_list|(
name|reservationRoot
argument_list|,
name|planName
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|reservationNodes
init|=
name|getChildren
argument_list|(
name|planNodePath
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|reservationNodeName
range|:
name|reservationNodes
control|)
block|{
name|String
name|reservationNodePath
init|=
name|getNodePath
argument_list|(
name|planNodePath
argument_list|,
name|reservationNodeName
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Loading reservation from znode: "
operator|+
name|reservationNodePath
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|reservationData
init|=
name|getData
argument_list|(
name|reservationNodePath
argument_list|)
decl_stmt|;
name|ReservationAllocationStateProto
name|allocationState
init|=
name|ReservationAllocationStateProto
operator|.
name|parseFrom
argument_list|(
name|reservationData
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rmState
operator|.
name|getReservationState
argument_list|()
operator|.
name|containsKey
argument_list|(
name|planName
argument_list|)
condition|)
block|{
name|rmState
operator|.
name|getReservationState
argument_list|()
operator|.
name|put
argument_list|(
name|planName
argument_list|,
operator|new
name|HashMap
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ReservationId
name|reservationId
init|=
name|ReservationId
operator|.
name|parseReservationId
argument_list|(
name|reservationNodeName
argument_list|)
decl_stmt|;
name|rmState
operator|.
name|getReservationState
argument_list|()
operator|.
name|get
argument_list|(
name|planName
argument_list|)
operator|.
name|put
argument_list|(
name|reservationId
argument_list|,
name|allocationState
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|loadAMRMTokenSecretManagerState (RMState rmState)
specifier|private
name|void
name|loadAMRMTokenSecretManagerState
parameter_list|(
name|RMState
name|rmState
parameter_list|)
throws|throws
name|Exception
block|{
name|byte
index|[]
name|data
init|=
name|getData
argument_list|(
name|amrmTokenSecretManagerRoot
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"There is no data saved"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AMRMTokenSecretManagerStatePBImpl
name|stateData
init|=
operator|new
name|AMRMTokenSecretManagerStatePBImpl
argument_list|(
name|AMRMTokenSecretManagerStateProto
operator|.
name|parseFrom
argument_list|(
name|data
argument_list|)
argument_list|)
decl_stmt|;
name|rmState
operator|.
name|amrmTokenSecretManagerState
operator|=
name|AMRMTokenSecretManagerState
operator|.
name|newInstance
argument_list|(
name|stateData
operator|.
name|getCurrentMasterKey
argument_list|()
argument_list|,
name|stateData
operator|.
name|getNextMasterKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|loadRMDTSecretManagerState (RMState rmState)
specifier|private
specifier|synchronized
name|void
name|loadRMDTSecretManagerState
parameter_list|(
name|RMState
name|rmState
parameter_list|)
throws|throws
name|Exception
block|{
name|loadRMDelegationKeyState
argument_list|(
name|rmState
argument_list|)
expr_stmt|;
name|loadRMSequentialNumberState
argument_list|(
name|rmState
argument_list|)
expr_stmt|;
name|loadRMDelegationTokenState
argument_list|(
name|rmState
argument_list|)
expr_stmt|;
block|}
DECL|method|loadRMDelegationKeyState (RMState rmState)
specifier|private
name|void
name|loadRMDelegationKeyState
parameter_list|(
name|RMState
name|rmState
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|String
argument_list|>
name|childNodes
init|=
name|getChildren
argument_list|(
name|dtMasterKeysRootPath
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|childNodeName
range|:
name|childNodes
control|)
block|{
name|String
name|childNodePath
init|=
name|getNodePath
argument_list|(
name|dtMasterKeysRootPath
argument_list|,
name|childNodeName
argument_list|)
decl_stmt|;
name|byte
index|[]
name|childData
init|=
name|getData
argument_list|(
name|childNodePath
argument_list|)
decl_stmt|;
if|if
condition|(
name|childData
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Content of "
operator|+
name|childNodePath
operator|+
literal|" is broken."
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ByteArrayInputStream
name|is
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|childData
argument_list|)
decl_stmt|;
try|try
init|(
name|DataInputStream
name|fsIn
init|=
operator|new
name|DataInputStream
argument_list|(
name|is
argument_list|)
init|)
block|{
if|if
condition|(
name|childNodeName
operator|.
name|startsWith
argument_list|(
name|DELEGATION_KEY_PREFIX
argument_list|)
condition|)
block|{
name|DelegationKey
name|key
init|=
operator|new
name|DelegationKey
argument_list|()
decl_stmt|;
name|key
operator|.
name|readFields
argument_list|(
name|fsIn
argument_list|)
expr_stmt|;
name|rmState
operator|.
name|rmSecretManagerState
operator|.
name|masterKeyState
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Loaded delegation key: keyId="
operator|+
name|key
operator|.
name|getKeyId
argument_list|()
operator|+
literal|", expirationDate="
operator|+
name|key
operator|.
name|getExpiryDate
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|method|loadRMSequentialNumberState (RMState rmState)
specifier|private
name|void
name|loadRMSequentialNumberState
parameter_list|(
name|RMState
name|rmState
parameter_list|)
throws|throws
name|Exception
block|{
name|byte
index|[]
name|seqData
init|=
name|getData
argument_list|(
name|dtSequenceNumberPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|seqData
operator|!=
literal|null
condition|)
block|{
name|ByteArrayInputStream
name|seqIs
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|seqData
argument_list|)
decl_stmt|;
try|try
init|(
name|DataInputStream
name|seqIn
init|=
operator|new
name|DataInputStream
argument_list|(
name|seqIs
argument_list|)
init|)
block|{
name|rmState
operator|.
name|rmSecretManagerState
operator|.
name|dtSequenceNumber
operator|=
name|seqIn
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|loadRMDelegationTokenState (RMState rmState)
specifier|private
name|void
name|loadRMDelegationTokenState
parameter_list|(
name|RMState
name|rmState
parameter_list|)
throws|throws
name|Exception
block|{
for|for
control|(
name|int
name|splitIndex
init|=
literal|0
init|;
name|splitIndex
operator|<=
literal|4
condition|;
name|splitIndex
operator|++
control|)
block|{
name|String
name|tokenRoot
init|=
name|rmDelegationTokenHierarchies
operator|.
name|get
argument_list|(
name|splitIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokenRoot
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|childNodes
init|=
name|getChildren
argument_list|(
name|tokenRoot
argument_list|)
decl_stmt|;
name|boolean
name|dtNodeFound
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|childNodeName
range|:
name|childNodes
control|)
block|{
if|if
condition|(
name|childNodeName
operator|.
name|startsWith
argument_list|(
name|DELEGATION_TOKEN_PREFIX
argument_list|)
condition|)
block|{
name|dtNodeFound
operator|=
literal|true
expr_stmt|;
name|String
name|parentNodePath
init|=
name|getNodePath
argument_list|(
name|tokenRoot
argument_list|,
name|childNodeName
argument_list|)
decl_stmt|;
if|if
condition|(
name|splitIndex
operator|==
literal|0
condition|)
block|{
name|loadDelegationTokenFromNode
argument_list|(
name|rmState
argument_list|,
name|parentNodePath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If znode is partitioned.
name|List
argument_list|<
name|String
argument_list|>
name|leafNodes
init|=
name|getChildren
argument_list|(
name|parentNodePath
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|leafNodeName
range|:
name|leafNodes
control|)
block|{
name|loadDelegationTokenFromNode
argument_list|(
name|rmState
argument_list|,
name|getNodePath
argument_list|(
name|parentNodePath
argument_list|,
name|leafNodeName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|splitIndex
operator|==
literal|0
operator|&&
operator|!
operator|(
name|childNodeName
operator|.
name|equals
argument_list|(
literal|"1"
argument_list|)
operator|||
name|childNodeName
operator|.
name|equals
argument_list|(
literal|"2"
argument_list|)
operator|||
name|childNodeName
operator|.
name|equals
argument_list|(
literal|"3"
argument_list|)
operator|||
name|childNodeName
operator|.
name|equals
argument_list|(
literal|"4"
argument_list|)
operator|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unknown child node with name "
operator|+
name|childNodeName
operator|+
literal|" under"
operator|+
name|tokenRoot
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|splitIndex
operator|!=
name|delegationTokenNodeSplitIndex
operator|&&
operator|!
name|dtNodeFound
condition|)
block|{
comment|// If no loaded delegation token exists for a particular split index and
comment|// the split index for which tokens are being loaded is not the one
comment|// configured, then we do not need to keep track of this hierarchy for
comment|// storing/updating/removing delegation token znodes.
name|rmDelegationTokenHierarchies
operator|.
name|remove
argument_list|(
name|splitIndex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|loadDelegationTokenFromNode (RMState rmState, String path)
specifier|private
name|void
name|loadDelegationTokenFromNode
parameter_list|(
name|RMState
name|rmState
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|Exception
block|{
name|byte
index|[]
name|data
init|=
name|getData
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Content of "
operator|+
name|path
operator|+
literal|" is broken."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ByteArrayInputStream
name|is
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|data
argument_list|)
decl_stmt|;
try|try
init|(
name|DataInputStream
name|fsIn
init|=
operator|new
name|DataInputStream
argument_list|(
name|is
argument_list|)
init|)
block|{
name|RMDelegationTokenIdentifierData
name|identifierData
init|=
name|RMStateStoreUtils
operator|.
name|readRMDelegationTokenIdentifierData
argument_list|(
name|fsIn
argument_list|)
decl_stmt|;
name|RMDelegationTokenIdentifier
name|identifier
init|=
name|identifierData
operator|.
name|getTokenIdentifier
argument_list|()
decl_stmt|;
name|long
name|renewDate
init|=
name|identifierData
operator|.
name|getRenewDate
argument_list|()
decl_stmt|;
name|rmState
operator|.
name|rmSecretManagerState
operator|.
name|delegationTokenState
operator|.
name|put
argument_list|(
name|identifier
argument_list|,
name|renewDate
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Loaded RMDelegationTokenIdentifier: "
operator|+
name|identifier
operator|+
literal|" renewDate="
operator|+
name|renewDate
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|loadRMAppStateFromAppNode (RMState rmState, String appNodePath, String appIdStr)
specifier|private
name|void
name|loadRMAppStateFromAppNode
parameter_list|(
name|RMState
name|rmState
parameter_list|,
name|String
name|appNodePath
parameter_list|,
name|String
name|appIdStr
parameter_list|)
throws|throws
name|Exception
block|{
name|byte
index|[]
name|appData
init|=
name|getData
argument_list|(
name|appNodePath
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Loading application from znode: "
operator|+
name|appNodePath
argument_list|)
expr_stmt|;
block|}
name|ApplicationId
name|appId
init|=
name|ApplicationId
operator|.
name|fromString
argument_list|(
name|appIdStr
argument_list|)
decl_stmt|;
name|ApplicationStateDataPBImpl
name|appState
init|=
operator|new
name|ApplicationStateDataPBImpl
argument_list|(
name|ApplicationStateDataProto
operator|.
name|parseFrom
argument_list|(
name|appData
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|appId
operator|.
name|equals
argument_list|(
name|appState
operator|.
name|getApplicationSubmissionContext
argument_list|()
operator|.
name|getApplicationId
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|YarnRuntimeException
argument_list|(
literal|"The node name is different from the "
operator|+
literal|"application id"
argument_list|)
throw|;
block|}
name|rmState
operator|.
name|appState
operator|.
name|put
argument_list|(
name|appId
argument_list|,
name|appState
argument_list|)
expr_stmt|;
name|loadApplicationAttemptState
argument_list|(
name|appState
argument_list|,
name|appNodePath
argument_list|)
expr_stmt|;
block|}
DECL|method|loadRMAppState (RMState rmState)
specifier|private
specifier|synchronized
name|void
name|loadRMAppState
parameter_list|(
name|RMState
name|rmState
parameter_list|)
throws|throws
name|Exception
block|{
for|for
control|(
name|int
name|splitIndex
init|=
literal|0
init|;
name|splitIndex
operator|<=
literal|4
condition|;
name|splitIndex
operator|++
control|)
block|{
name|String
name|appRoot
init|=
name|rmAppRootHierarchies
operator|.
name|get
argument_list|(
name|splitIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|appRoot
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|childNodes
init|=
name|getChildren
argument_list|(
name|appRoot
argument_list|)
decl_stmt|;
name|boolean
name|appNodeFound
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|childNodeName
range|:
name|childNodes
control|)
block|{
if|if
condition|(
name|childNodeName
operator|.
name|startsWith
argument_list|(
name|ApplicationId
operator|.
name|appIdStrPrefix
argument_list|)
condition|)
block|{
name|appNodeFound
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|splitIndex
operator|==
literal|0
condition|)
block|{
name|loadRMAppStateFromAppNode
argument_list|(
name|rmState
argument_list|,
name|getNodePath
argument_list|(
name|appRoot
argument_list|,
name|childNodeName
argument_list|)
argument_list|,
name|childNodeName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If AppId Node is partitioned.
name|String
name|parentNodePath
init|=
name|getNodePath
argument_list|(
name|appRoot
argument_list|,
name|childNodeName
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|leafNodes
init|=
name|getChildren
argument_list|(
name|parentNodePath
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|leafNodeName
range|:
name|leafNodes
control|)
block|{
name|String
name|appIdStr
init|=
name|childNodeName
operator|+
name|leafNodeName
decl_stmt|;
name|loadRMAppStateFromAppNode
argument_list|(
name|rmState
argument_list|,
name|getNodePath
argument_list|(
name|parentNodePath
argument_list|,
name|leafNodeName
argument_list|)
argument_list|,
name|appIdStr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|childNodeName
operator|.
name|equals
argument_list|(
name|RM_APP_ROOT_HIERARCHIES
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unknown child node with name "
operator|+
name|childNodeName
operator|+
literal|" under"
operator|+
name|appRoot
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|splitIndex
operator|!=
name|appIdNodeSplitIndex
operator|&&
operator|!
name|appNodeFound
condition|)
block|{
comment|// If no loaded app exists for a particular split index and the split
comment|// index for which apps are being loaded is not the one configured, then
comment|// we do not need to keep track of this hierarchy for storing/updating/
comment|// removing app/app attempt znodes.
name|rmAppRootHierarchies
operator|.
name|remove
argument_list|(
name|splitIndex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|loadApplicationAttemptState (ApplicationStateData appState, String appPath)
specifier|private
name|void
name|loadApplicationAttemptState
parameter_list|(
name|ApplicationStateData
name|appState
parameter_list|,
name|String
name|appPath
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|String
argument_list|>
name|attempts
init|=
name|getChildren
argument_list|(
name|appPath
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|attemptIDStr
range|:
name|attempts
control|)
block|{
if|if
condition|(
name|attemptIDStr
operator|.
name|startsWith
argument_list|(
name|ApplicationAttemptId
operator|.
name|appAttemptIdStrPrefix
argument_list|)
condition|)
block|{
name|String
name|attemptPath
init|=
name|getNodePath
argument_list|(
name|appPath
argument_list|,
name|attemptIDStr
argument_list|)
decl_stmt|;
name|byte
index|[]
name|attemptData
init|=
name|getData
argument_list|(
name|attemptPath
argument_list|)
decl_stmt|;
name|ApplicationAttemptStateDataPBImpl
name|attemptState
init|=
operator|new
name|ApplicationAttemptStateDataPBImpl
argument_list|(
name|ApplicationAttemptStateDataProto
operator|.
name|parseFrom
argument_list|(
name|attemptData
argument_list|)
argument_list|)
decl_stmt|;
name|appState
operator|.
name|attempts
operator|.
name|put
argument_list|(
name|attemptState
operator|.
name|getAttemptId
argument_list|()
argument_list|,
name|attemptState
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Done loading applications from ZK state store"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get znode path based on full path and split index supplied.    * @param path path for which parent needs to be returned.    * @param splitIndex split index.    * @return parent app node path.    */
DECL|method|getSplitZnodeParent (String path, int splitIndex)
specifier|private
name|String
name|getSplitZnodeParent
parameter_list|(
name|String
name|path
parameter_list|,
name|int
name|splitIndex
parameter_list|)
block|{
comment|// Calculated as string up to index (path Length - split index - 1). We
comment|// deduct 1 to exclude path separator.
return|return
name|path
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|path
operator|.
name|length
argument_list|()
operator|-
name|splitIndex
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/**    * Checks if parent znode has no leaf nodes and if it does not have,    * removes it.    * @param path path of znode to be removed.    * @param splitIndex split index.    * @throws Exception if any problem occurs while performing ZK operation.    */
DECL|method|checkRemoveParentZnode (String path, int splitIndex)
specifier|private
name|void
name|checkRemoveParentZnode
parameter_list|(
name|String
name|path
parameter_list|,
name|int
name|splitIndex
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|splitIndex
operator|!=
literal|0
condition|)
block|{
name|String
name|parentZnode
init|=
name|getSplitZnodeParent
argument_list|(
name|path
argument_list|,
name|splitIndex
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|children
init|=
literal|null
decl_stmt|;
try|try
block|{
name|children
operator|=
name|getChildren
argument_list|(
name|parentZnode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|ke
parameter_list|)
block|{
comment|// It should be fine to swallow this exception as the parent znode we
comment|// intend to delete is already deleted.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unable to remove parent node "
operator|+
name|parentZnode
operator|+
literal|" as it does not exist."
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|// No apps stored under parent path.
if|if
condition|(
name|children
operator|!=
literal|null
operator|&&
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|zkManager
operator|.
name|safeDelete
argument_list|(
name|parentZnode
argument_list|,
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No leaf znode exists. Removing parent node "
operator|+
name|parentZnode
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NotEmptyException
name|ke
parameter_list|)
block|{
comment|// It should be fine to swallow this exception as the parent znode
comment|// has to be deleted only if it has no children. And this node has.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unable to remove app parent node "
operator|+
name|parentZnode
operator|+
literal|" as it has children."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|storeApplicationStateInternal (ApplicationId appId, ApplicationStateData appStateDataPB)
specifier|public
specifier|synchronized
name|void
name|storeApplicationStateInternal
parameter_list|(
name|ApplicationId
name|appId
parameter_list|,
name|ApplicationStateData
name|appStateDataPB
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|nodeCreatePath
init|=
name|getLeafAppIdNodePath
argument_list|(
name|appId
operator|.
name|toString
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Storing info for app: "
operator|+
name|appId
operator|+
literal|" at: "
operator|+
name|nodeCreatePath
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|appStateData
init|=
name|appStateDataPB
operator|.
name|getProto
argument_list|()
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
if|if
condition|(
name|appStateData
operator|.
name|length
operator|<=
name|zknodeLimit
condition|)
block|{
name|zkManager
operator|.
name|safeCreate
argument_list|(
name|nodeCreatePath
argument_list|,
name|appStateData
argument_list|,
name|zkAcl
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|,
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Application state data size for "
operator|+
name|appId
operator|+
literal|" is "
operator|+
name|appStateData
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|StoreLimitException
argument_list|(
literal|"Application "
operator|+
name|appId
operator|+
literal|" exceeds the maximum allowed size for application data. "
operator|+
literal|"See yarn.resourcemanager.zk-max-znode-size.bytes."
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|updateApplicationStateInternal ( ApplicationId appId, ApplicationStateData appStateDataPB)
specifier|protected
specifier|synchronized
name|void
name|updateApplicationStateInternal
parameter_list|(
name|ApplicationId
name|appId
parameter_list|,
name|ApplicationStateData
name|appStateDataPB
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|nodeUpdatePath
init|=
name|getLeafAppIdNodePath
argument_list|(
name|appId
operator|.
name|toString
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|boolean
name|pathExists
init|=
literal|true
decl_stmt|;
comment|// Look for paths based on other split indices if path as per split index
comment|// does not exist.
if|if
condition|(
operator|!
name|exists
argument_list|(
name|nodeUpdatePath
argument_list|)
condition|)
block|{
name|ZnodeSplitInfo
name|alternatePathInfo
init|=
name|getAlternateAppPath
argument_list|(
name|appId
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|alternatePathInfo
operator|!=
literal|null
condition|)
block|{
name|nodeUpdatePath
operator|=
name|alternatePathInfo
operator|.
name|path
expr_stmt|;
block|}
else|else
block|{
comment|// No alternate path exists. Create path as per configured split index.
name|pathExists
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|appIdNodeSplitIndex
operator|!=
literal|0
condition|)
block|{
name|String
name|rootNode
init|=
name|getSplitZnodeParent
argument_list|(
name|nodeUpdatePath
argument_list|,
name|appIdNodeSplitIndex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|exists
argument_list|(
name|rootNode
argument_list|)
condition|)
block|{
name|zkManager
operator|.
name|safeCreate
argument_list|(
name|rootNode
argument_list|,
literal|null
argument_list|,
name|zkAcl
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|,
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Storing final state info for app: "
operator|+
name|appId
operator|+
literal|" at: "
operator|+
name|nodeUpdatePath
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|appStateData
init|=
name|appStateDataPB
operator|.
name|getProto
argument_list|()
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
if|if
condition|(
name|pathExists
condition|)
block|{
name|zkManager
operator|.
name|safeSetData
argument_list|(
name|nodeUpdatePath
argument_list|,
name|appStateData
argument_list|,
operator|-
literal|1
argument_list|,
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zkManager
operator|.
name|safeCreate
argument_list|(
name|nodeUpdatePath
argument_list|,
name|appStateData
argument_list|,
name|zkAcl
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|,
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Path "
operator|+
name|nodeUpdatePath
operator|+
literal|" for "
operator|+
name|appId
operator|+
literal|" didn't "
operator|+
literal|"exist. Creating a new znode to update the application state."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*    * Handles store, update and remove application attempt state store    * operations.    */
DECL|method|handleApplicationAttemptStateOp ( ApplicationAttemptId appAttemptId, ApplicationAttemptStateData attemptStateDataPB, AppAttemptOp operation)
specifier|private
name|void
name|handleApplicationAttemptStateOp
parameter_list|(
name|ApplicationAttemptId
name|appAttemptId
parameter_list|,
name|ApplicationAttemptStateData
name|attemptStateDataPB
parameter_list|,
name|AppAttemptOp
name|operation
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|appId
init|=
name|appAttemptId
operator|.
name|getApplicationId
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|appDirPath
init|=
name|getLeafAppIdNodePath
argument_list|(
name|appId
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// Look for paths based on other split indices.
if|if
condition|(
operator|!
name|exists
argument_list|(
name|appDirPath
argument_list|)
condition|)
block|{
name|ZnodeSplitInfo
name|alternatePathInfo
init|=
name|getAlternateAppPath
argument_list|(
name|appId
argument_list|)
decl_stmt|;
if|if
condition|(
name|alternatePathInfo
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|operation
operator|==
name|AppAttemptOp
operator|.
name|REMOVE
condition|)
block|{
comment|// Unexpected. Assume that app attempt has been deleted.
return|return;
block|}
else|else
block|{
comment|// Store or Update operation
throw|throw
operator|new
name|YarnRuntimeException
argument_list|(
literal|"Unexpected Exception. App node for "
operator|+
literal|"app "
operator|+
name|appId
operator|+
literal|" not found"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|appDirPath
operator|=
name|alternatePathInfo
operator|.
name|path
expr_stmt|;
block|}
block|}
name|String
name|path
init|=
name|getNodePath
argument_list|(
name|appDirPath
argument_list|,
name|appAttemptId
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|byte
index|[]
name|attemptStateData
init|=
operator|(
name|attemptStateDataPB
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|attemptStateDataPB
operator|.
name|getProto
argument_list|()
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|operation
operator|+
literal|" info for attempt: "
operator|+
name|appAttemptId
operator|+
literal|" at: "
operator|+
name|path
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|UPDATE
case|:
if|if
condition|(
name|exists
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|zkManager
operator|.
name|safeSetData
argument_list|(
name|path
argument_list|,
name|attemptStateData
argument_list|,
operator|-
literal|1
argument_list|,
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zkManager
operator|.
name|safeCreate
argument_list|(
name|path
argument_list|,
name|attemptStateData
argument_list|,
name|zkAcl
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|,
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Path "
operator|+
name|path
operator|+
literal|" for "
operator|+
name|appAttemptId
operator|+
literal|" didn't exist."
operator|+
literal|" Created a new znode to update the application attempt state."
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|STORE
case|:
name|zkManager
operator|.
name|safeCreate
argument_list|(
name|path
argument_list|,
name|attemptStateData
argument_list|,
name|zkAcl
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|,
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
expr_stmt|;
break|break;
case|case
name|REMOVE
case|:
name|zkManager
operator|.
name|safeDelete
argument_list|(
name|path
argument_list|,
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
annotation|@
name|Override
DECL|method|storeApplicationAttemptStateInternal ( ApplicationAttemptId appAttemptId, ApplicationAttemptStateData attemptStateDataPB)
specifier|protected
specifier|synchronized
name|void
name|storeApplicationAttemptStateInternal
parameter_list|(
name|ApplicationAttemptId
name|appAttemptId
parameter_list|,
name|ApplicationAttemptStateData
name|attemptStateDataPB
parameter_list|)
throws|throws
name|Exception
block|{
name|handleApplicationAttemptStateOp
argument_list|(
name|appAttemptId
argument_list|,
name|attemptStateDataPB
argument_list|,
name|AppAttemptOp
operator|.
name|STORE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|updateApplicationAttemptStateInternal ( ApplicationAttemptId appAttemptId, ApplicationAttemptStateData attemptStateDataPB)
specifier|protected
specifier|synchronized
name|void
name|updateApplicationAttemptStateInternal
parameter_list|(
name|ApplicationAttemptId
name|appAttemptId
parameter_list|,
name|ApplicationAttemptStateData
name|attemptStateDataPB
parameter_list|)
throws|throws
name|Exception
block|{
name|handleApplicationAttemptStateOp
argument_list|(
name|appAttemptId
argument_list|,
name|attemptStateDataPB
argument_list|,
name|AppAttemptOp
operator|.
name|UPDATE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|removeApplicationAttemptInternal ( ApplicationAttemptId appAttemptId)
specifier|protected
specifier|synchronized
name|void
name|removeApplicationAttemptInternal
parameter_list|(
name|ApplicationAttemptId
name|appAttemptId
parameter_list|)
throws|throws
name|Exception
block|{
name|handleApplicationAttemptStateOp
argument_list|(
name|appAttemptId
argument_list|,
literal|null
argument_list|,
name|AppAttemptOp
operator|.
name|REMOVE
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|removeApplicationStateInternal ( ApplicationStateData appState)
specifier|protected
specifier|synchronized
name|void
name|removeApplicationStateInternal
parameter_list|(
name|ApplicationStateData
name|appState
parameter_list|)
throws|throws
name|Exception
block|{
name|removeApp
argument_list|(
name|appState
operator|.
name|getApplicationSubmissionContext
argument_list|()
operator|.
name|getApplicationId
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
literal|true
argument_list|,
name|appState
operator|.
name|attempts
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|removeApp (String removeAppId)
specifier|private
name|void
name|removeApp
parameter_list|(
name|String
name|removeAppId
parameter_list|)
throws|throws
name|Exception
block|{
name|removeApp
argument_list|(
name|removeAppId
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Remove application node and its attempt nodes.    *    * @param removeAppId Application Id to be removed.    * @param safeRemove Flag indicating if application and attempt nodes have to    *     be removed safely under a fencing or not.    * @param attempts list of attempts to be removed associated with this app.    *     Ignored if safeRemove flag is false as we recursively delete all the    *     child nodes directly.    * @throws Exception if any exception occurs during ZK operation.    */
DECL|method|removeApp (String removeAppId, boolean safeRemove, Set<ApplicationAttemptId> attempts)
specifier|private
name|void
name|removeApp
parameter_list|(
name|String
name|removeAppId
parameter_list|,
name|boolean
name|safeRemove
parameter_list|,
name|Set
argument_list|<
name|ApplicationAttemptId
argument_list|>
name|attempts
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|appIdRemovePath
init|=
name|getLeafAppIdNodePath
argument_list|(
name|removeAppId
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|splitIndex
init|=
name|appIdNodeSplitIndex
decl_stmt|;
comment|// Look for paths based on other split indices if path as per configured
comment|// split index does not exist.
if|if
condition|(
operator|!
name|exists
argument_list|(
name|appIdRemovePath
argument_list|)
condition|)
block|{
name|ZnodeSplitInfo
name|alternatePathInfo
init|=
name|getAlternateAppPath
argument_list|(
name|removeAppId
argument_list|)
decl_stmt|;
if|if
condition|(
name|alternatePathInfo
operator|!=
literal|null
condition|)
block|{
name|appIdRemovePath
operator|=
name|alternatePathInfo
operator|.
name|path
expr_stmt|;
name|splitIndex
operator|=
name|alternatePathInfo
operator|.
name|splitIndex
expr_stmt|;
block|}
else|else
block|{
comment|// Alternate path not found so return.
return|return;
block|}
block|}
if|if
condition|(
name|safeRemove
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing info for app: "
operator|+
name|removeAppId
operator|+
literal|" at: "
operator|+
name|appIdRemovePath
operator|+
literal|" and its attempts."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attempts
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ApplicationAttemptId
name|attemptId
range|:
name|attempts
control|)
block|{
name|String
name|attemptRemovePath
init|=
name|getNodePath
argument_list|(
name|appIdRemovePath
argument_list|,
name|attemptId
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|zkManager
operator|.
name|safeDelete
argument_list|(
name|attemptRemovePath
argument_list|,
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
expr_stmt|;
block|}
block|}
name|zkManager
operator|.
name|safeDelete
argument_list|(
name|appIdRemovePath
argument_list|,
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CuratorFramework
name|curatorFramework
init|=
name|zkManager
operator|.
name|getCurator
argument_list|()
decl_stmt|;
name|curatorFramework
operator|.
name|delete
argument_list|()
operator|.
name|deletingChildrenIfNeeded
argument_list|()
operator|.
name|forPath
argument_list|(
name|appIdRemovePath
argument_list|)
expr_stmt|;
block|}
comment|// Check if we should remove the parent app node as well.
name|checkRemoveParentZnode
argument_list|(
name|appIdRemovePath
argument_list|,
name|splitIndex
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|storeRMDelegationTokenState ( RMDelegationTokenIdentifier rmDTIdentifier, Long renewDate)
specifier|protected
specifier|synchronized
name|void
name|storeRMDelegationTokenState
parameter_list|(
name|RMDelegationTokenIdentifier
name|rmDTIdentifier
parameter_list|,
name|Long
name|renewDate
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|nodeCreatePath
init|=
name|getLeafDelegationTokenNodePath
argument_list|(
name|rmDTIdentifier
operator|.
name|getSequenceNumber
argument_list|()
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Storing "
operator|+
name|DELEGATION_TOKEN_PREFIX
operator|+
name|rmDTIdentifier
operator|.
name|getSequenceNumber
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|RMDelegationTokenIdentifierData
name|identifierData
init|=
operator|new
name|RMDelegationTokenIdentifierData
argument_list|(
name|rmDTIdentifier
argument_list|,
name|renewDate
argument_list|)
decl_stmt|;
name|ByteArrayOutputStream
name|seqOs
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
try|try
init|(
name|DataOutputStream
name|seqOut
init|=
operator|new
name|DataOutputStream
argument_list|(
name|seqOs
argument_list|)
init|)
block|{
name|SafeTransaction
name|trx
init|=
name|zkManager
operator|.
name|createTransaction
argument_list|(
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
decl_stmt|;
name|trx
operator|.
name|create
argument_list|(
name|nodeCreatePath
argument_list|,
name|identifierData
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|zkAcl
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|)
expr_stmt|;
comment|// Update Sequence number only while storing DT
name|seqOut
operator|.
name|writeInt
argument_list|(
name|rmDTIdentifier
operator|.
name|getSequenceNumber
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Storing "
operator|+
name|dtSequenceNumberPath
operator|+
literal|". SequenceNumber: "
operator|+
name|rmDTIdentifier
operator|.
name|getSequenceNumber
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|trx
operator|.
name|setData
argument_list|(
name|dtSequenceNumberPath
argument_list|,
name|seqOs
operator|.
name|toByteArray
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|trx
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|removeRMDelegationTokenState ( RMDelegationTokenIdentifier rmDTIdentifier)
specifier|protected
specifier|synchronized
name|void
name|removeRMDelegationTokenState
parameter_list|(
name|RMDelegationTokenIdentifier
name|rmDTIdentifier
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|nodeRemovePath
init|=
name|getLeafDelegationTokenNodePath
argument_list|(
name|rmDTIdentifier
operator|.
name|getSequenceNumber
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|int
name|splitIndex
init|=
name|delegationTokenNodeSplitIndex
decl_stmt|;
comment|// Look for paths based on other split indices if path as per configured
comment|// split index does not exist.
if|if
condition|(
operator|!
name|exists
argument_list|(
name|nodeRemovePath
argument_list|)
condition|)
block|{
name|ZnodeSplitInfo
name|alternatePathInfo
init|=
name|getAlternateDTPath
argument_list|(
name|rmDTIdentifier
operator|.
name|getSequenceNumber
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|alternatePathInfo
operator|!=
literal|null
condition|)
block|{
name|nodeRemovePath
operator|=
name|alternatePathInfo
operator|.
name|path
expr_stmt|;
name|splitIndex
operator|=
name|alternatePathInfo
operator|.
name|splitIndex
expr_stmt|;
block|}
else|else
block|{
comment|// Alternate path not found so return.
return|return;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing RMDelegationToken_"
operator|+
name|rmDTIdentifier
operator|.
name|getSequenceNumber
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|zkManager
operator|.
name|safeDelete
argument_list|(
name|nodeRemovePath
argument_list|,
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
expr_stmt|;
comment|// Check if we should remove the parent app node as well.
name|checkRemoveParentZnode
argument_list|(
name|nodeRemovePath
argument_list|,
name|splitIndex
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|updateRMDelegationTokenState ( RMDelegationTokenIdentifier rmDTIdentifier, Long renewDate)
specifier|protected
specifier|synchronized
name|void
name|updateRMDelegationTokenState
parameter_list|(
name|RMDelegationTokenIdentifier
name|rmDTIdentifier
parameter_list|,
name|Long
name|renewDate
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|nodeUpdatePath
init|=
name|getLeafDelegationTokenNodePath
argument_list|(
name|rmDTIdentifier
operator|.
name|getSequenceNumber
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|boolean
name|pathExists
init|=
literal|true
decl_stmt|;
comment|// Look for paths based on other split indices if path as per split index
comment|// does not exist.
if|if
condition|(
operator|!
name|exists
argument_list|(
name|nodeUpdatePath
argument_list|)
condition|)
block|{
name|ZnodeSplitInfo
name|alternatePathInfo
init|=
name|getAlternateDTPath
argument_list|(
name|rmDTIdentifier
operator|.
name|getSequenceNumber
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|alternatePathInfo
operator|!=
literal|null
condition|)
block|{
name|nodeUpdatePath
operator|=
name|alternatePathInfo
operator|.
name|path
expr_stmt|;
block|}
else|else
block|{
name|pathExists
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pathExists
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Updating "
operator|+
name|DELEGATION_TOKEN_PREFIX
operator|+
name|rmDTIdentifier
operator|.
name|getSequenceNumber
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|RMDelegationTokenIdentifierData
name|identifierData
init|=
operator|new
name|RMDelegationTokenIdentifierData
argument_list|(
name|rmDTIdentifier
argument_list|,
name|renewDate
argument_list|)
decl_stmt|;
name|zkManager
operator|.
name|safeSetData
argument_list|(
name|nodeUpdatePath
argument_list|,
name|identifierData
operator|.
name|toByteArray
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|storeRMDelegationTokenState
argument_list|(
name|rmDTIdentifier
argument_list|,
name|renewDate
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|storeRMDTMasterKeyState ( DelegationKey delegationKey)
specifier|protected
specifier|synchronized
name|void
name|storeRMDTMasterKeyState
parameter_list|(
name|DelegationKey
name|delegationKey
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|nodeCreatePath
init|=
name|getNodePath
argument_list|(
name|dtMasterKeysRootPath
argument_list|,
name|DELEGATION_KEY_PREFIX
operator|+
name|delegationKey
operator|.
name|getKeyId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Storing RMDelegationKey_"
operator|+
name|delegationKey
operator|.
name|getKeyId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ByteArrayOutputStream
name|os
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
try|try
init|(
name|DataOutputStream
name|fsOut
init|=
operator|new
name|DataOutputStream
argument_list|(
name|os
argument_list|)
init|)
block|{
name|delegationKey
operator|.
name|write
argument_list|(
name|fsOut
argument_list|)
expr_stmt|;
name|zkManager
operator|.
name|safeCreate
argument_list|(
name|nodeCreatePath
argument_list|,
name|os
operator|.
name|toByteArray
argument_list|()
argument_list|,
name|zkAcl
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|,
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|removeRMDTMasterKeyState ( DelegationKey delegationKey)
specifier|protected
specifier|synchronized
name|void
name|removeRMDTMasterKeyState
parameter_list|(
name|DelegationKey
name|delegationKey
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|nodeRemovePath
init|=
name|getNodePath
argument_list|(
name|dtMasterKeysRootPath
argument_list|,
name|DELEGATION_KEY_PREFIX
operator|+
name|delegationKey
operator|.
name|getKeyId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing RMDelegationKey_"
operator|+
name|delegationKey
operator|.
name|getKeyId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|zkManager
operator|.
name|safeDelete
argument_list|(
name|nodeRemovePath
argument_list|,
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|deleteStore ()
specifier|public
specifier|synchronized
name|void
name|deleteStore
parameter_list|()
throws|throws
name|Exception
block|{
name|delete
argument_list|(
name|zkRootNodePath
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|removeApplication (ApplicationId removeAppId)
specifier|public
specifier|synchronized
name|void
name|removeApplication
parameter_list|(
name|ApplicationId
name|removeAppId
parameter_list|)
throws|throws
name|Exception
block|{
name|removeApp
argument_list|(
name|removeAppId
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getNodePath (String root, String nodeName)
name|String
name|getNodePath
parameter_list|(
name|String
name|root
parameter_list|,
name|String
name|nodeName
parameter_list|)
block|{
return|return
operator|(
name|root
operator|+
literal|"/"
operator|+
name|nodeName
operator|)
return|;
block|}
annotation|@
name|Override
DECL|method|storeOrUpdateAMRMTokenSecretManagerState ( AMRMTokenSecretManagerState amrmTokenSecretManagerState, boolean isUpdate)
specifier|protected
specifier|synchronized
name|void
name|storeOrUpdateAMRMTokenSecretManagerState
parameter_list|(
name|AMRMTokenSecretManagerState
name|amrmTokenSecretManagerState
parameter_list|,
name|boolean
name|isUpdate
parameter_list|)
throws|throws
name|Exception
block|{
name|AMRMTokenSecretManagerState
name|data
init|=
name|AMRMTokenSecretManagerState
operator|.
name|newInstance
argument_list|(
name|amrmTokenSecretManagerState
argument_list|)
decl_stmt|;
name|byte
index|[]
name|stateData
init|=
name|data
operator|.
name|getProto
argument_list|()
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
name|zkManager
operator|.
name|safeSetData
argument_list|(
name|amrmTokenSecretManagerRoot
argument_list|,
name|stateData
argument_list|,
operator|-
literal|1
argument_list|,
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|removeReservationState (String planName, String reservationIdName)
specifier|protected
specifier|synchronized
name|void
name|removeReservationState
parameter_list|(
name|String
name|planName
parameter_list|,
name|String
name|reservationIdName
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|planNodePath
init|=
name|getNodePath
argument_list|(
name|reservationRoot
argument_list|,
name|planName
argument_list|)
decl_stmt|;
name|String
name|reservationPath
init|=
name|getNodePath
argument_list|(
name|planNodePath
argument_list|,
name|reservationIdName
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing reservationallocation "
operator|+
name|reservationIdName
operator|+
literal|" for"
operator|+
literal|" plan "
operator|+
name|planName
argument_list|)
expr_stmt|;
block|}
name|zkManager
operator|.
name|safeDelete
argument_list|(
name|reservationPath
argument_list|,
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|reservationNodes
init|=
name|getChildren
argument_list|(
name|planNodePath
argument_list|)
decl_stmt|;
if|if
condition|(
name|reservationNodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|zkManager
operator|.
name|safeDelete
argument_list|(
name|planNodePath
argument_list|,
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|storeReservationState ( ReservationAllocationStateProto reservationAllocation, String planName, String reservationIdName)
specifier|protected
specifier|synchronized
name|void
name|storeReservationState
parameter_list|(
name|ReservationAllocationStateProto
name|reservationAllocation
parameter_list|,
name|String
name|planName
parameter_list|,
name|String
name|reservationIdName
parameter_list|)
throws|throws
name|Exception
block|{
name|SafeTransaction
name|trx
init|=
name|zkManager
operator|.
name|createTransaction
argument_list|(
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
decl_stmt|;
name|addOrUpdateReservationState
argument_list|(
name|reservationAllocation
argument_list|,
name|planName
argument_list|,
name|reservationIdName
argument_list|,
name|trx
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|trx
operator|.
name|commit
argument_list|()
expr_stmt|;
block|}
DECL|method|addOrUpdateReservationState ( ReservationAllocationStateProto reservationAllocation, String planName, String reservationIdName, SafeTransaction trx, boolean isUpdate)
specifier|private
name|void
name|addOrUpdateReservationState
parameter_list|(
name|ReservationAllocationStateProto
name|reservationAllocation
parameter_list|,
name|String
name|planName
parameter_list|,
name|String
name|reservationIdName
parameter_list|,
name|SafeTransaction
name|trx
parameter_list|,
name|boolean
name|isUpdate
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|planCreatePath
init|=
name|getNodePath
argument_list|(
name|reservationRoot
argument_list|,
name|planName
argument_list|)
decl_stmt|;
name|String
name|reservationPath
init|=
name|getNodePath
argument_list|(
name|planCreatePath
argument_list|,
name|reservationIdName
argument_list|)
decl_stmt|;
name|byte
index|[]
name|reservationData
init|=
name|reservationAllocation
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|exists
argument_list|(
name|planCreatePath
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating plan node: "
operator|+
name|planName
operator|+
literal|" at: "
operator|+
name|planCreatePath
argument_list|)
expr_stmt|;
block|}
name|trx
operator|.
name|create
argument_list|(
name|planCreatePath
argument_list|,
literal|null
argument_list|,
name|zkAcl
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isUpdate
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Updating reservation: "
operator|+
name|reservationIdName
operator|+
literal|" in plan:"
operator|+
name|planName
operator|+
literal|" at: "
operator|+
name|reservationPath
argument_list|)
expr_stmt|;
block|}
name|trx
operator|.
name|setData
argument_list|(
name|reservationPath
argument_list|,
name|reservationData
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Storing reservation: "
operator|+
name|reservationIdName
operator|+
literal|" in plan:"
operator|+
name|planName
operator|+
literal|" at: "
operator|+
name|reservationPath
argument_list|)
expr_stmt|;
block|}
name|trx
operator|.
name|create
argument_list|(
name|reservationPath
argument_list|,
name|reservationData
argument_list|,
name|zkAcl
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get alternate path for app id if path according to configured split index    * does not exist. We look for path based on all possible split indices.    * @param appId    * @return a {@link ZnodeSplitInfo} object containing the path and split    *    index if it exists, null otherwise.    * @throws Exception if any problem occurs while performing ZK operation.    */
DECL|method|getAlternateAppPath (String appId)
specifier|private
name|ZnodeSplitInfo
name|getAlternateAppPath
parameter_list|(
name|String
name|appId
parameter_list|)
throws|throws
name|Exception
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|rmAppRootHierarchies
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// Look for other paths
name|int
name|splitIndex
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|splitIndex
operator|!=
name|appIdNodeSplitIndex
condition|)
block|{
name|String
name|alternatePath
init|=
name|getLeafZnodePath
argument_list|(
name|appId
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|splitIndex
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|exists
argument_list|(
name|alternatePath
argument_list|)
condition|)
block|{
return|return
operator|new
name|ZnodeSplitInfo
argument_list|(
name|alternatePath
argument_list|,
name|splitIndex
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Returns leaf znode path based on node name and passed split index. If the    * passed flag createParentIfNotExists is true, also creates the parent znode    * if it does not exist.    * @param nodeName the node name.    * @param rootNode app root node based on split index.    * @param splitIdx split index.    * @param createParentIfNotExists flag which determines if parent znode    *     needs to be created(as per split) if it does not exist.    * @return leaf znode path.    * @throws Exception if any problem occurs while performing ZK operation.    */
DECL|method|getLeafZnodePath (String nodeName, String rootNode, int splitIdx, boolean createParentIfNotExists)
specifier|private
name|String
name|getLeafZnodePath
parameter_list|(
name|String
name|nodeName
parameter_list|,
name|String
name|rootNode
parameter_list|,
name|int
name|splitIdx
parameter_list|,
name|boolean
name|createParentIfNotExists
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|splitIdx
operator|==
literal|0
condition|)
block|{
return|return
name|getNodePath
argument_list|(
name|rootNode
argument_list|,
name|nodeName
argument_list|)
return|;
block|}
name|int
name|split
init|=
name|nodeName
operator|.
name|length
argument_list|()
operator|-
name|splitIdx
decl_stmt|;
name|String
name|rootNodePath
init|=
name|getNodePath
argument_list|(
name|rootNode
argument_list|,
name|nodeName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|split
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|createParentIfNotExists
operator|&&
operator|!
name|exists
argument_list|(
name|rootNodePath
argument_list|)
condition|)
block|{
try|try
block|{
name|zkManager
operator|.
name|safeCreate
argument_list|(
name|rootNodePath
argument_list|,
literal|null
argument_list|,
name|zkAcl
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|,
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NodeExistsException
name|e
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unable to create app parent node "
operator|+
name|rootNodePath
operator|+
literal|" as it already exists."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|getNodePath
argument_list|(
name|rootNodePath
argument_list|,
name|nodeName
operator|.
name|substring
argument_list|(
name|split
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Returns leaf app node path based on app id and configured split index. If    * the passed flag createParentIfNotExists is true, also creates the parent    * app node if it does not exist.    * @param appId application id.    * @param createParentIfNotExists flag which determines if parent app node    *     needs to be created(as per split) if it does not exist.    * @return leaf app node path.    * @throws Exception if any problem occurs while performing ZK operation.    */
DECL|method|getLeafAppIdNodePath (String appId, boolean createParentIfNotExists)
specifier|private
name|String
name|getLeafAppIdNodePath
parameter_list|(
name|String
name|appId
parameter_list|,
name|boolean
name|createParentIfNotExists
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|getLeafZnodePath
argument_list|(
name|appId
argument_list|,
name|rmAppRootHierarchies
operator|.
name|get
argument_list|(
name|appIdNodeSplitIndex
argument_list|)
argument_list|,
name|appIdNodeSplitIndex
argument_list|,
name|createParentIfNotExists
argument_list|)
return|;
block|}
comment|/**    * Returns leaf delegation token node path based on sequence number and    * configured split index. If the passed flag createParentIfNotExists is true,    * also creates the parent znode if it does not exist.  The sequence number    * is padded to be at least 4 digits wide to ensure consistency with the split    * indexing.    * @param rmDTSequenceNumber delegation token sequence number.    * @param createParentIfNotExists flag which determines if parent znode    *     needs to be created(as per split) if it does not exist.    * @return leaf delegation token node path.    * @throws Exception if any problem occurs while performing ZK operation.    */
DECL|method|getLeafDelegationTokenNodePath (int rmDTSequenceNumber, boolean createParentIfNotExists)
specifier|private
name|String
name|getLeafDelegationTokenNodePath
parameter_list|(
name|int
name|rmDTSequenceNumber
parameter_list|,
name|boolean
name|createParentIfNotExists
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|getLeafDelegationTokenNodePath
argument_list|(
name|rmDTSequenceNumber
argument_list|,
name|createParentIfNotExists
argument_list|,
name|delegationTokenNodeSplitIndex
argument_list|)
return|;
block|}
comment|/**    * Returns leaf delegation token node path based on sequence number and    * passed split index. If the passed flag createParentIfNotExists is true,    * also creates the parent znode if it does not exist.  The sequence number    * is padded to be at least 4 digits wide to ensure consistency with the split    * indexing.    * @param rmDTSequenceNumber delegation token sequence number.    * @param createParentIfNotExists flag which determines if parent znode    *     needs to be created(as per split) if it does not exist.    * @param split the split index to use    * @return leaf delegation token node path.    * @throws Exception if any problem occurs while performing ZK operation.    */
DECL|method|getLeafDelegationTokenNodePath (int rmDTSequenceNumber, boolean createParentIfNotExists, int split)
specifier|private
name|String
name|getLeafDelegationTokenNodePath
parameter_list|(
name|int
name|rmDTSequenceNumber
parameter_list|,
name|boolean
name|createParentIfNotExists
parameter_list|,
name|int
name|split
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|nodeName
init|=
name|DELEGATION_TOKEN_PREFIX
decl_stmt|;
if|if
condition|(
name|split
operator|==
literal|0
condition|)
block|{
name|nodeName
operator|+=
name|rmDTSequenceNumber
expr_stmt|;
block|}
else|else
block|{
name|nodeName
operator|+=
name|String
operator|.
name|format
argument_list|(
literal|"%04d"
argument_list|,
name|rmDTSequenceNumber
argument_list|)
expr_stmt|;
block|}
return|return
name|getLeafZnodePath
argument_list|(
name|nodeName
argument_list|,
name|rmDelegationTokenHierarchies
operator|.
name|get
argument_list|(
name|split
argument_list|)
argument_list|,
name|split
argument_list|,
name|createParentIfNotExists
argument_list|)
return|;
block|}
comment|/**    * Get alternate path for delegation token if path according to configured    * split index does not exist. We look for path based on all possible split    * indices.    * @param rmDTSequenceNumber delegation token sequence number.    * @return a {@link ZnodeSplitInfo} object containing the path and split    *    index if it exists, null otherwise.    * @throws Exception if any problem occurs while performing ZK operation.    */
DECL|method|getAlternateDTPath (int rmDTSequenceNumber)
specifier|private
name|ZnodeSplitInfo
name|getAlternateDTPath
parameter_list|(
name|int
name|rmDTSequenceNumber
parameter_list|)
throws|throws
name|Exception
block|{
comment|// Check all possible paths until we find it
for|for
control|(
name|int
name|splitIndex
range|:
name|rmDelegationTokenHierarchies
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|splitIndex
operator|!=
name|delegationTokenNodeSplitIndex
condition|)
block|{
name|String
name|alternatePath
init|=
name|getLeafDelegationTokenNodePath
argument_list|(
name|rmDTSequenceNumber
argument_list|,
literal|false
argument_list|,
name|splitIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|exists
argument_list|(
name|alternatePath
argument_list|)
condition|)
block|{
return|return
operator|new
name|ZnodeSplitInfo
argument_list|(
name|alternatePath
argument_list|,
name|splitIndex
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getData (final String path)
name|byte
index|[]
name|getData
parameter_list|(
specifier|final
name|String
name|path
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|zkManager
operator|.
name|getData
argument_list|(
name|path
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getACL (final String path)
name|List
argument_list|<
name|ACL
argument_list|>
name|getACL
parameter_list|(
specifier|final
name|String
name|path
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|zkManager
operator|.
name|getACL
argument_list|(
name|path
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getChildren (final String path)
name|List
argument_list|<
name|String
argument_list|>
name|getChildren
parameter_list|(
specifier|final
name|String
name|path
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|zkManager
operator|.
name|getChildren
argument_list|(
name|path
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|exists (final String path)
name|boolean
name|exists
parameter_list|(
specifier|final
name|String
name|path
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|zkManager
operator|.
name|exists
argument_list|(
name|path
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|create (final String path)
name|void
name|create
parameter_list|(
specifier|final
name|String
name|path
parameter_list|)
throws|throws
name|Exception
block|{
name|zkManager
operator|.
name|create
argument_list|(
name|path
argument_list|,
name|zkAcl
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|delete (final String path)
name|void
name|delete
parameter_list|(
specifier|final
name|String
name|path
parameter_list|)
throws|throws
name|Exception
block|{
name|zkManager
operator|.
name|delete
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
comment|/**    * Helper class that periodically attempts creating a znode to ensure that    * this RM continues to be the Active.    */
DECL|class|VerifyActiveStatusThread
specifier|private
class|class
name|VerifyActiveStatusThread
extends|extends
name|Thread
block|{
DECL|method|VerifyActiveStatusThread ()
name|VerifyActiveStatusThread
parameter_list|()
block|{
name|super
argument_list|(
name|VerifyActiveStatusThread
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
while|while
condition|(
operator|!
name|isFencedState
argument_list|()
condition|)
block|{
comment|// Create and delete fencing node
name|zkManager
operator|.
name|createTransaction
argument_list|(
name|zkAcl
argument_list|,
name|fencingNodePath
argument_list|)
operator|.
name|commit
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|zkSessionTimeout
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|getName
argument_list|()
operator|+
literal|" thread interrupted! Exiting!"
argument_list|)
expr_stmt|;
name|interrupt
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|notifyStoreOperationFailed
argument_list|(
operator|new
name|StoreFencedException
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

