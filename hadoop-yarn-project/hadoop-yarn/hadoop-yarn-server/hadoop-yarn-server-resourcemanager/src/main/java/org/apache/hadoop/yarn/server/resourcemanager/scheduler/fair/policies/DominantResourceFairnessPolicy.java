begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair.policies
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|fair
operator|.
name|policies
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|Private
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
operator|.
name|Unstable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ResourceInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|fair
operator|.
name|FSContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|fair
operator|.
name|FSQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|fair
operator|.
name|Schedulable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|fair
operator|.
name|SchedulingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|DominantResourceCalculator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|ResourceCalculator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|Resources
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|ResourceUtils
import|;
end_import

begin_comment
comment|/**  * Makes scheduling decisions by trying to equalize dominant resource usage.  * A schedulable's dominant resource usage is the largest ratio of resource  * usage to capacity among the resource types it is using.  */
end_comment

begin_class
annotation|@
name|Private
annotation|@
name|Unstable
DECL|class|DominantResourceFairnessPolicy
specifier|public
class|class
name|DominantResourceFairnessPolicy
extends|extends
name|SchedulingPolicy
block|{
DECL|field|NAME
specifier|public
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"DRF"
decl_stmt|;
DECL|field|COMPARATOR
specifier|private
specifier|static
specifier|final
name|DominantResourceFairnessComparator
name|COMPARATOR
init|=
operator|new
name|DominantResourceFairnessComparator
argument_list|()
decl_stmt|;
DECL|field|CALCULATOR
specifier|private
specifier|static
specifier|final
name|DominantResourceCalculator
name|CALCULATOR
init|=
operator|new
name|DominantResourceCalculator
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|NAME
return|;
block|}
annotation|@
name|Override
DECL|method|getComparator ()
specifier|public
name|Comparator
argument_list|<
name|Schedulable
argument_list|>
name|getComparator
parameter_list|()
block|{
return|return
name|COMPARATOR
return|;
block|}
annotation|@
name|Override
DECL|method|getResourceCalculator ()
specifier|public
name|ResourceCalculator
name|getResourceCalculator
parameter_list|()
block|{
return|return
name|CALCULATOR
return|;
block|}
annotation|@
name|Override
DECL|method|computeShares (Collection<? extends Schedulable> schedulables, Resource totalResources)
specifier|public
name|void
name|computeShares
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|Schedulable
argument_list|>
name|schedulables
parameter_list|,
name|Resource
name|totalResources
parameter_list|)
block|{
for|for
control|(
name|ResourceInformation
name|info
range|:
name|ResourceUtils
operator|.
name|getResourceTypesArray
argument_list|()
control|)
block|{
name|ComputeFairShares
operator|.
name|computeShares
argument_list|(
name|schedulables
argument_list|,
name|totalResources
argument_list|,
name|info
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|computeSteadyShares (Collection<? extends FSQueue> queues, Resource totalResources)
specifier|public
name|void
name|computeSteadyShares
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|FSQueue
argument_list|>
name|queues
parameter_list|,
name|Resource
name|totalResources
parameter_list|)
block|{
for|for
control|(
name|ResourceInformation
name|info
range|:
name|ResourceUtils
operator|.
name|getResourceTypesArray
argument_list|()
control|)
block|{
name|ComputeFairShares
operator|.
name|computeSteadyShares
argument_list|(
name|queues
argument_list|,
name|totalResources
argument_list|,
name|info
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|checkIfUsageOverFairShare (Resource usage, Resource fairShare)
specifier|public
name|boolean
name|checkIfUsageOverFairShare
parameter_list|(
name|Resource
name|usage
parameter_list|,
name|Resource
name|fairShare
parameter_list|)
block|{
return|return
operator|!
name|Resources
operator|.
name|fitsIn
argument_list|(
name|usage
argument_list|,
name|fairShare
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getHeadroom (Resource queueFairShare, Resource queueUsage, Resource maxAvailable)
specifier|public
name|Resource
name|getHeadroom
parameter_list|(
name|Resource
name|queueFairShare
parameter_list|,
name|Resource
name|queueUsage
parameter_list|,
name|Resource
name|maxAvailable
parameter_list|)
block|{
name|long
name|queueAvailableMemory
init|=
name|Math
operator|.
name|max
argument_list|(
name|queueFairShare
operator|.
name|getMemorySize
argument_list|()
operator|-
name|queueUsage
operator|.
name|getMemorySize
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|queueAvailableCPU
init|=
name|Math
operator|.
name|max
argument_list|(
name|queueFairShare
operator|.
name|getVirtualCores
argument_list|()
operator|-
name|queueUsage
operator|.
name|getVirtualCores
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|Resource
name|headroom
init|=
name|Resources
operator|.
name|createResource
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|maxAvailable
operator|.
name|getMemorySize
argument_list|()
argument_list|,
name|queueAvailableMemory
argument_list|)
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|maxAvailable
operator|.
name|getVirtualCores
argument_list|()
argument_list|,
name|queueAvailableCPU
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|headroom
return|;
block|}
annotation|@
name|Override
DECL|method|initialize (FSContext fsContext)
specifier|public
name|void
name|initialize
parameter_list|(
name|FSContext
name|fsContext
parameter_list|)
block|{
name|COMPARATOR
operator|.
name|setFSContext
argument_list|(
name|fsContext
argument_list|)
expr_stmt|;
block|}
comment|/**    * This class compares two {@link Schedulable} instances according to the    * DRF policy. If neither instance is below min share, approximate fair share    * ratios are compared.    */
DECL|class|DominantResourceFairnessComparator
specifier|public
specifier|static
class|class
name|DominantResourceFairnessComparator
implements|implements
name|Comparator
argument_list|<
name|Schedulable
argument_list|>
block|{
DECL|field|fsContext
specifier|private
name|FSContext
name|fsContext
decl_stmt|;
DECL|method|setFSContext (FSContext fsContext)
specifier|public
name|void
name|setFSContext
parameter_list|(
name|FSContext
name|fsContext
parameter_list|)
block|{
name|this
operator|.
name|fsContext
operator|=
name|fsContext
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|compare (Schedulable s1, Schedulable s2)
specifier|public
name|int
name|compare
parameter_list|(
name|Schedulable
name|s1
parameter_list|,
name|Schedulable
name|s2
parameter_list|)
block|{
name|ResourceInformation
index|[]
name|info
init|=
name|ResourceUtils
operator|.
name|getResourceTypesArray
argument_list|()
decl_stmt|;
name|Resource
name|usage1
init|=
name|s1
operator|.
name|getResourceUsage
argument_list|()
decl_stmt|;
name|Resource
name|usage2
init|=
name|s2
operator|.
name|getResourceUsage
argument_list|()
decl_stmt|;
name|Resource
name|minShare1
init|=
name|s1
operator|.
name|getMinShare
argument_list|()
decl_stmt|;
name|Resource
name|minShare2
init|=
name|s2
operator|.
name|getMinShare
argument_list|()
decl_stmt|;
name|Resource
name|clusterCapacity
init|=
name|fsContext
operator|.
name|getClusterResource
argument_list|()
decl_stmt|;
comment|// These arrays hold the usage, fair, and min share ratios for each
comment|// resource type. ratios[0][x] are the usage ratios, ratios[1][x] are
comment|// the fair share ratios, and ratios[2][x] are the min share ratios.
name|float
index|[]
index|[]
name|ratios1
init|=
operator|new
name|float
index|[
name|info
operator|.
name|length
index|]
index|[
literal|3
index|]
decl_stmt|;
name|float
index|[]
index|[]
name|ratios2
init|=
operator|new
name|float
index|[
name|info
operator|.
name|length
index|]
index|[
literal|3
index|]
decl_stmt|;
comment|// Calculate cluster shares and approximate fair shares for each
comment|// resource type of both schedulables.
name|int
name|dominant1
init|=
name|calculateClusterAndFairRatios
argument_list|(
name|usage1
argument_list|,
name|clusterCapacity
argument_list|,
name|ratios1
argument_list|,
name|s1
operator|.
name|getWeight
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|dominant2
init|=
name|calculateClusterAndFairRatios
argument_list|(
name|usage2
argument_list|,
name|clusterCapacity
argument_list|,
name|ratios2
argument_list|,
name|s2
operator|.
name|getWeight
argument_list|()
argument_list|)
decl_stmt|;
comment|// A queue is needy for its min share if its dominant resource
comment|// (with respect to the cluster capacity) is below its configured min
comment|// share for that resource
name|boolean
name|s1Needy
init|=
name|usage1
operator|.
name|getResources
argument_list|()
index|[
name|dominant1
index|]
operator|.
name|getValue
argument_list|()
operator|<
name|minShare1
operator|.
name|getResources
argument_list|()
index|[
name|dominant1
index|]
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|boolean
name|s2Needy
init|=
name|usage2
operator|.
name|getResources
argument_list|()
index|[
name|dominant2
index|]
operator|.
name|getValue
argument_list|()
operator|<
name|minShare2
operator|.
name|getResources
argument_list|()
index|[
name|dominant2
index|]
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|s2Needy
operator|&&
operator|!
name|s1Needy
condition|)
block|{
comment|// Sort shares by usage ratio and compare them by approximate fair share
comment|// ratio
name|sortRatios
argument_list|(
name|ratios1
argument_list|,
name|ratios2
argument_list|)
expr_stmt|;
name|res
operator|=
name|compareRatios
argument_list|(
name|ratios1
argument_list|,
name|ratios2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s1Needy
operator|&&
operator|!
name|s2Needy
condition|)
block|{
name|res
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s2Needy
operator|&&
operator|!
name|s1Needy
condition|)
block|{
name|res
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|// both are needy below min share
comment|// Calculate the min share ratios, then sort by usage ratio, and compare
comment|// by min share ratio
name|calculateMinShareRatios
argument_list|(
name|usage1
argument_list|,
name|minShare1
argument_list|,
name|ratios1
argument_list|)
expr_stmt|;
name|calculateMinShareRatios
argument_list|(
name|usage2
argument_list|,
name|minShare2
argument_list|,
name|ratios2
argument_list|)
expr_stmt|;
name|sortRatios
argument_list|(
name|ratios1
argument_list|,
name|ratios2
argument_list|)
expr_stmt|;
name|res
operator|=
name|compareRatios
argument_list|(
name|ratios1
argument_list|,
name|ratios2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|==
literal|0
condition|)
block|{
comment|// Apps are tied in fairness ratio. Break the tie by submit time and job
comment|// name to get a deterministic ordering, which is useful for unit tests.
name|res
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|signum
argument_list|(
name|s1
operator|.
name|getStartTime
argument_list|()
operator|-
name|s2
operator|.
name|getStartTime
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
block|{
name|res
operator|=
name|s1
operator|.
name|getName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|s2
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
comment|/**      * Sort both ratios arrays according to the usage ratios (the      * first index of the inner arrays, e.g. {@code ratios1[x][0]}).      *      * @param ratios1 the first ratios array      * @param ratios2 the second ratios array      */
annotation|@
name|VisibleForTesting
DECL|method|sortRatios (float[][] ratios1, float[][]ratios2)
name|void
name|sortRatios
parameter_list|(
name|float
index|[]
index|[]
name|ratios1
parameter_list|,
name|float
index|[]
index|[]
name|ratios2
parameter_list|)
block|{
comment|// sort order descending by resource share
name|Arrays
operator|.
name|sort
argument_list|(
name|ratios1
argument_list|,
parameter_list|(
name|float
index|[]
name|o1
parameter_list|,
name|float
index|[]
name|o2
parameter_list|)
lambda|->
operator|(
name|int
operator|)
name|Math
operator|.
name|signum
argument_list|(
name|o2
index|[
literal|0
index|]
operator|-
name|o1
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|sort
argument_list|(
name|ratios2
argument_list|,
parameter_list|(
name|float
index|[]
name|o1
parameter_list|,
name|float
index|[]
name|o2
parameter_list|)
lambda|->
operator|(
name|int
operator|)
name|Math
operator|.
name|signum
argument_list|(
name|o2
index|[
literal|0
index|]
operator|-
name|o1
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Calculate a resource's usage ratio and approximate fair share ratio.      * The {@code shares} array will be populated with both the usage ratio      * and the approximate fair share ratio for each resource type. The usage      * ratio is calculated as {@code resource} divided by {@code cluster}.      * The approximate fair share ratio is calculated as the usage ratio      * divided by {@code weight}. If the cluster's resources are 100MB and      * 10 vcores, and the usage ({@code resource}) is 10 MB and 5 CPU, the      * usage ratios will be 0.1 and 0.5. If the weights are 2, the fair      * share ratios will be 0.05 and 0.25.      *      * The approximate fair share ratio is the usage divided by the      * approximate fair share, i.e. the cluster resources times the weight.      * The approximate fair share is an acceptable proxy for the fair share      * because when comparing resources, the resource with the higher weight      * will be assigned by the scheduler a proportionally higher fair share.      *      * The {@code shares} array must be at least<i>n</i> x 2, where<i>n</i>      * is the number of resource types. Only the first and second indices of      * the inner arrays in the {@code shares} array will be used, e.g.      * {@code shares[x][0]} and {@code shares[x][1]}.      *      * The return value will be the index of the dominant resource type in the      * {@code shares} array. The dominant resource is the resource type for      * which {@code resource} has the largest usage ratio.      *      * @param resource the resource for which to calculate ratios      * @param cluster the total cluster resources      * @param ratios the shares array to populate      * @param weight the resource weight      * @return the index of the resource type with the largest cluster share      */
annotation|@
name|VisibleForTesting
DECL|method|calculateClusterAndFairRatios (Resource resource, Resource cluster, float[][] ratios, float weight)
name|int
name|calculateClusterAndFairRatios
parameter_list|(
name|Resource
name|resource
parameter_list|,
name|Resource
name|cluster
parameter_list|,
name|float
index|[]
index|[]
name|ratios
parameter_list|,
name|float
name|weight
parameter_list|)
block|{
name|ResourceInformation
index|[]
name|resourceInfo
init|=
name|resource
operator|.
name|getResources
argument_list|()
decl_stmt|;
name|ResourceInformation
index|[]
name|clusterInfo
init|=
name|cluster
operator|.
name|getResources
argument_list|()
decl_stmt|;
name|int
name|max
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|clusterInfo
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// First calculate the cluster share
name|ratios
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
name|resourceInfo
index|[
name|i
index|]
operator|.
name|getValue
argument_list|()
operator|/
operator|(
name|float
operator|)
name|clusterInfo
index|[
name|i
index|]
operator|.
name|getValue
argument_list|()
expr_stmt|;
comment|// Use the cluster share to find the dominant resource
if|if
condition|(
name|ratios
index|[
name|i
index|]
index|[
literal|0
index|]
operator|>
name|ratios
index|[
name|max
index|]
index|[
literal|0
index|]
condition|)
block|{
name|max
operator|=
name|i
expr_stmt|;
block|}
comment|// Now divide by the weight to get the approximate fair share.
comment|// It's OK if the weight is zero, because the floating point division
comment|// will yield Infinity, i.e. this Schedulable will lose out to any
comment|// other Schedulable with non-zero weight.
name|ratios
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
name|ratios
index|[
name|i
index|]
index|[
literal|0
index|]
operator|/
name|weight
expr_stmt|;
block|}
return|return
name|max
return|;
block|}
comment|/**      * Calculate a resource's min share ratios. The {@code ratios} array will be      * populated with the {@code resource} divided by {@code minShare} for each      * resource type. If the min shares are 5 MB and 10 vcores, and the usage      * ({@code resource}) is 10 MB and 5 CPU, the ratios will be 2 and 0.5.      *      * The {@code ratios} array must be<i>n</i> x 3, where<i>n</i> is the      * number of resource types. Only the third index of the inner arrays in      * the {@code ratios} array will be used, e.g. {@code ratios[x][2]}.      *      * @param resource the resource for which to calculate min shares      * @param minShare the min share      * @param ratios the shares array to populate      */
annotation|@
name|VisibleForTesting
DECL|method|calculateMinShareRatios (Resource resource, Resource minShare, float[][] ratios)
name|void
name|calculateMinShareRatios
parameter_list|(
name|Resource
name|resource
parameter_list|,
name|Resource
name|minShare
parameter_list|,
name|float
index|[]
index|[]
name|ratios
parameter_list|)
block|{
name|ResourceInformation
index|[]
name|resourceInfo
init|=
name|resource
operator|.
name|getResources
argument_list|()
decl_stmt|;
name|ResourceInformation
index|[]
name|minShareInfo
init|=
name|minShare
operator|.
name|getResources
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|minShareInfo
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ratios
index|[
name|i
index|]
index|[
literal|2
index|]
operator|=
name|resourceInfo
index|[
name|i
index|]
operator|.
name|getValue
argument_list|()
operator|/
operator|(
name|float
operator|)
name|minShareInfo
index|[
name|i
index|]
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Compare the two ratios arrays and return -1, 0, or 1 if the first array      * is less than, equal to, or greater than the second array, respectively.      * The {@code index} parameter determines which index of the inner arrays      * will be used for the comparisons. 0 is for usage ratios, 1 is for      * fair share ratios, and 2 is for the min share ratios. The ratios arrays      * are assumed to be sorted in descending order by usage ratio.      *      * @param ratios1 the first shares array      * @param ratios2 the second shares array      * @param index the outer index of the ratios arrays to compare. 0 is for      * usage ratio, 1 is for approximate fair share ratios, and 1 is for min      * share ratios      * @return -1, 0, or 1 if the first array is less than, equal to, or      * greater than the second array, respectively      */
annotation|@
name|VisibleForTesting
DECL|method|compareRatios (float[][] ratios1, float[][] ratios2, int index)
name|int
name|compareRatios
parameter_list|(
name|float
index|[]
index|[]
name|ratios1
parameter_list|,
name|float
index|[]
index|[]
name|ratios2
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ratios1
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|signum
argument_list|(
name|ratios1
index|[
name|i
index|]
index|[
name|index
index|]
operator|-
name|ratios2
index|[
name|i
index|]
index|[
name|index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
block|}
return|return
name|ret
return|;
block|}
block|}
block|}
end_class

end_unit

