begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|LimitedPrivate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|Private
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
operator|.
name|Evolving
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configurable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|Groups
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationAttemptId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Container
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerExitStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|NodeId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueUserACLInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ReservationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ResourceOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ResourceRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnRuntimeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|proto
operator|.
name|YarnServiceProtos
operator|.
name|SchedulerResourceTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|security
operator|.
name|YarnAuthorizationProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|RMContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|nodelabels
operator|.
name|RMNodeLabelsManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|recovery
operator|.
name|RMStateStore
operator|.
name|RMState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|reservation
operator|.
name|ReservationConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|RMApp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|RMAppEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|RMAppEventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|RMAppRejectedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|RMAppState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|attempt
operator|.
name|RMAppAttemptEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|attempt
operator|.
name|RMAppAttemptEventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|attempt
operator|.
name|RMAppAttemptState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainerEventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainerState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmnode
operator|.
name|RMNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmnode
operator|.
name|UpdatedContainerInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|AbstractYarnScheduler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|Allocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|NodeType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|PreemptableResourceScheduler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|QueueMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|QueueNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|ResourceLimits
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|SchedulerApplication
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|SchedulerDynamicEditException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|SchedulerHealth
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|SchedulerUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|CapacitySchedulerConfiguration
operator|.
name|QueueMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|CapacitySchedulerConfiguration
operator|.
name|QueueMapping
operator|.
name|MappingType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|AssignmentInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|QueueEntitlement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|fica
operator|.
name|FiCaSchedulerApp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|fica
operator|.
name|FiCaSchedulerNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|AppAddedSchedulerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|AppAttemptAddedSchedulerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|AppAttemptRemovedSchedulerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|AppRemovedSchedulerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|ContainerExpiredSchedulerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|NodeAddedSchedulerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|NodeLabelsUpdateSchedulerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|NodeRemovedSchedulerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|NodeResourceUpdateSchedulerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|NodeUpdateSchedulerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|SchedulerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|security
operator|.
name|RMContainerTokenSecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|utils
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|DefaultResourceCalculator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|ResourceCalculator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|Resources
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_class
annotation|@
name|LimitedPrivate
argument_list|(
literal|"yarn"
argument_list|)
annotation|@
name|Evolving
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|class|CapacityScheduler
specifier|public
class|class
name|CapacityScheduler
extends|extends
name|AbstractYarnScheduler
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
implements|implements
name|PreemptableResourceScheduler
implements|,
name|CapacitySchedulerContext
implements|,
name|Configurable
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|CapacityScheduler
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|authorizer
specifier|private
name|YarnAuthorizationProvider
name|authorizer
decl_stmt|;
DECL|field|root
specifier|private
name|CSQueue
name|root
decl_stmt|;
comment|// timeout to join when we stop this service
DECL|field|THREAD_JOIN_TIMEOUT_MS
specifier|protected
specifier|final
name|long
name|THREAD_JOIN_TIMEOUT_MS
init|=
literal|1000
decl_stmt|;
DECL|field|nonPartitionedQueueComparator
specifier|static
specifier|final
name|Comparator
argument_list|<
name|CSQueue
argument_list|>
name|nonPartitionedQueueComparator
init|=
operator|new
name|Comparator
argument_list|<
name|CSQueue
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|CSQueue
name|q1
parameter_list|,
name|CSQueue
name|q2
parameter_list|)
block|{
if|if
condition|(
name|q1
operator|.
name|getUsedCapacity
argument_list|()
operator|<
name|q2
operator|.
name|getUsedCapacity
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|q1
operator|.
name|getUsedCapacity
argument_list|()
operator|>
name|q2
operator|.
name|getUsedCapacity
argument_list|()
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
name|q1
operator|.
name|getQueuePath
argument_list|()
operator|.
name|compareTo
argument_list|(
name|q2
operator|.
name|getQueuePath
argument_list|()
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|field|partitionedQueueComparator
specifier|static
specifier|final
name|PartitionedQueueComparator
name|partitionedQueueComparator
init|=
operator|new
name|PartitionedQueueComparator
argument_list|()
decl_stmt|;
DECL|field|applicationComparator
specifier|public
specifier|static
specifier|final
name|Comparator
argument_list|<
name|FiCaSchedulerApp
argument_list|>
name|applicationComparator
init|=
operator|new
name|Comparator
argument_list|<
name|FiCaSchedulerApp
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|FiCaSchedulerApp
name|a1
parameter_list|,
name|FiCaSchedulerApp
name|a2
parameter_list|)
block|{
return|return
name|a1
operator|.
name|getApplicationId
argument_list|()
operator|.
name|compareTo
argument_list|(
name|a2
operator|.
name|getApplicationId
argument_list|()
argument_list|)
return|;
block|}
block|}
decl_stmt|;
annotation|@
name|Override
DECL|method|setConf (Configuration conf)
specifier|public
name|void
name|setConf
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|yarnConf
operator|=
name|conf
expr_stmt|;
block|}
DECL|method|validateConf (Configuration conf)
specifier|private
name|void
name|validateConf
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
comment|// validate scheduler memory allocation setting
name|int
name|minMem
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_MINIMUM_ALLOCATION_MB
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_RM_SCHEDULER_MINIMUM_ALLOCATION_MB
argument_list|)
decl_stmt|;
name|int
name|maxMem
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_MAXIMUM_ALLOCATION_MB
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_RM_SCHEDULER_MAXIMUM_ALLOCATION_MB
argument_list|)
decl_stmt|;
if|if
condition|(
name|minMem
operator|<=
literal|0
operator|||
name|minMem
operator|>
name|maxMem
condition|)
block|{
throw|throw
operator|new
name|YarnRuntimeException
argument_list|(
literal|"Invalid resource scheduler memory"
operator|+
literal|" allocation configuration"
operator|+
literal|", "
operator|+
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_MINIMUM_ALLOCATION_MB
operator|+
literal|"="
operator|+
name|minMem
operator|+
literal|", "
operator|+
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_MAXIMUM_ALLOCATION_MB
operator|+
literal|"="
operator|+
name|maxMem
operator|+
literal|", min and max should be greater than 0"
operator|+
literal|", max should be no smaller than min."
argument_list|)
throw|;
block|}
comment|// validate scheduler vcores allocation setting
name|int
name|minVcores
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_MINIMUM_ALLOCATION_VCORES
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_RM_SCHEDULER_MINIMUM_ALLOCATION_VCORES
argument_list|)
decl_stmt|;
name|int
name|maxVcores
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_MAXIMUM_ALLOCATION_VCORES
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_RM_SCHEDULER_MAXIMUM_ALLOCATION_VCORES
argument_list|)
decl_stmt|;
if|if
condition|(
name|minVcores
operator|<=
literal|0
operator|||
name|minVcores
operator|>
name|maxVcores
condition|)
block|{
throw|throw
operator|new
name|YarnRuntimeException
argument_list|(
literal|"Invalid resource scheduler vcores"
operator|+
literal|" allocation configuration"
operator|+
literal|", "
operator|+
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_MINIMUM_ALLOCATION_VCORES
operator|+
literal|"="
operator|+
name|minVcores
operator|+
literal|", "
operator|+
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_MAXIMUM_ALLOCATION_VCORES
operator|+
literal|"="
operator|+
name|maxVcores
operator|+
literal|", min and max should be greater than 0"
operator|+
literal|", max should be no smaller than min."
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|getConf ()
specifier|public
name|Configuration
name|getConf
parameter_list|()
block|{
return|return
name|yarnConf
return|;
block|}
DECL|field|conf
specifier|private
name|CapacitySchedulerConfiguration
name|conf
decl_stmt|;
DECL|field|yarnConf
specifier|private
name|Configuration
name|yarnConf
decl_stmt|;
DECL|field|queues
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|queues
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|numNodeManagers
specifier|private
name|AtomicInteger
name|numNodeManagers
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|calculator
specifier|private
name|ResourceCalculator
name|calculator
decl_stmt|;
DECL|field|usePortForNodeName
specifier|private
name|boolean
name|usePortForNodeName
decl_stmt|;
DECL|field|scheduleAsynchronously
specifier|private
name|boolean
name|scheduleAsynchronously
decl_stmt|;
DECL|field|asyncSchedulerThread
specifier|private
name|AsyncScheduleThread
name|asyncSchedulerThread
decl_stmt|;
DECL|field|labelManager
specifier|private
name|RMNodeLabelsManager
name|labelManager
decl_stmt|;
DECL|field|schedulerHealth
specifier|private
name|SchedulerHealth
name|schedulerHealth
init|=
operator|new
name|SchedulerHealth
argument_list|()
decl_stmt|;
DECL|field|lastNodeUpdateTime
name|long
name|lastNodeUpdateTime
decl_stmt|;
comment|/**    * EXPERT    */
DECL|field|asyncScheduleInterval
specifier|private
name|long
name|asyncScheduleInterval
decl_stmt|;
DECL|field|ASYNC_SCHEDULER_INTERVAL
specifier|private
specifier|static
specifier|final
name|String
name|ASYNC_SCHEDULER_INTERVAL
init|=
name|CapacitySchedulerConfiguration
operator|.
name|SCHEDULE_ASYNCHRONOUSLY_PREFIX
operator|+
literal|".scheduling-interval-ms"
decl_stmt|;
DECL|field|DEFAULT_ASYNC_SCHEDULER_INTERVAL
specifier|private
specifier|static
specifier|final
name|long
name|DEFAULT_ASYNC_SCHEDULER_INTERVAL
init|=
literal|5
decl_stmt|;
DECL|field|overrideWithQueueMappings
specifier|private
name|boolean
name|overrideWithQueueMappings
init|=
literal|false
decl_stmt|;
DECL|field|mappings
specifier|private
name|List
argument_list|<
name|QueueMapping
argument_list|>
name|mappings
init|=
literal|null
decl_stmt|;
DECL|field|groups
specifier|private
name|Groups
name|groups
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|method|getMappedQueueForTest (String user)
specifier|public
specifier|synchronized
name|String
name|getMappedQueueForTest
parameter_list|(
name|String
name|user
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getMappedQueue
argument_list|(
name|user
argument_list|)
return|;
block|}
DECL|method|CapacityScheduler ()
specifier|public
name|CapacityScheduler
parameter_list|()
block|{
name|super
argument_list|(
name|CapacityScheduler
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getRootQueueMetrics ()
specifier|public
name|QueueMetrics
name|getRootQueueMetrics
parameter_list|()
block|{
return|return
name|root
operator|.
name|getMetrics
argument_list|()
return|;
block|}
DECL|method|getRootQueue ()
specifier|public
name|CSQueue
name|getRootQueue
parameter_list|()
block|{
return|return
name|root
return|;
block|}
annotation|@
name|Override
DECL|method|getConfiguration ()
specifier|public
name|CapacitySchedulerConfiguration
name|getConfiguration
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|RMContainerTokenSecretManager
DECL|method|getContainerTokenSecretManager ()
name|getContainerTokenSecretManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|rmContext
operator|.
name|getContainerTokenSecretManager
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getApplicationComparator ()
specifier|public
name|Comparator
argument_list|<
name|FiCaSchedulerApp
argument_list|>
name|getApplicationComparator
parameter_list|()
block|{
return|return
name|applicationComparator
return|;
block|}
annotation|@
name|Override
DECL|method|getResourceCalculator ()
specifier|public
name|ResourceCalculator
name|getResourceCalculator
parameter_list|()
block|{
return|return
name|calculator
return|;
block|}
annotation|@
name|Override
DECL|method|getNonPartitionedQueueComparator ()
specifier|public
name|Comparator
argument_list|<
name|CSQueue
argument_list|>
name|getNonPartitionedQueueComparator
parameter_list|()
block|{
return|return
name|nonPartitionedQueueComparator
return|;
block|}
annotation|@
name|Override
DECL|method|getPartitionedQueueComparator ()
specifier|public
name|PartitionedQueueComparator
name|getPartitionedQueueComparator
parameter_list|()
block|{
return|return
name|partitionedQueueComparator
return|;
block|}
annotation|@
name|Override
DECL|method|getNumClusterNodes ()
specifier|public
name|int
name|getNumClusterNodes
parameter_list|()
block|{
return|return
name|numNodeManagers
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getRMContext ()
specifier|public
specifier|synchronized
name|RMContext
name|getRMContext
parameter_list|()
block|{
return|return
name|this
operator|.
name|rmContext
return|;
block|}
annotation|@
name|Override
DECL|method|setRMContext (RMContext rmContext)
specifier|public
specifier|synchronized
name|void
name|setRMContext
parameter_list|(
name|RMContext
name|rmContext
parameter_list|)
block|{
name|this
operator|.
name|rmContext
operator|=
name|rmContext
expr_stmt|;
block|}
DECL|method|initScheduler (Configuration configuration)
specifier|private
specifier|synchronized
name|void
name|initScheduler
parameter_list|(
name|Configuration
name|configuration
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|conf
operator|=
name|loadCapacitySchedulerConfiguration
argument_list|(
name|configuration
argument_list|)
expr_stmt|;
name|validateConf
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|minimumAllocation
operator|=
name|this
operator|.
name|conf
operator|.
name|getMinimumAllocation
argument_list|()
expr_stmt|;
name|initMaximumResourceCapability
argument_list|(
name|this
operator|.
name|conf
operator|.
name|getMaximumAllocation
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|calculator
operator|=
name|this
operator|.
name|conf
operator|.
name|getResourceCalculator
argument_list|()
expr_stmt|;
name|this
operator|.
name|usePortForNodeName
operator|=
name|this
operator|.
name|conf
operator|.
name|getUsePortForNodeName
argument_list|()
expr_stmt|;
name|this
operator|.
name|applications
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|ApplicationId
argument_list|,
name|SchedulerApplication
argument_list|<
name|FiCaSchedulerApp
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|labelManager
operator|=
name|rmContext
operator|.
name|getNodeLabelManager
argument_list|()
expr_stmt|;
name|authorizer
operator|=
name|YarnAuthorizationProvider
operator|.
name|getInstance
argument_list|(
name|yarnConf
argument_list|)
expr_stmt|;
name|initializeQueues
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|scheduleAsynchronously
operator|=
name|this
operator|.
name|conf
operator|.
name|getScheduleAynschronously
argument_list|()
expr_stmt|;
name|asyncScheduleInterval
operator|=
name|this
operator|.
name|conf
operator|.
name|getLong
argument_list|(
name|ASYNC_SCHEDULER_INTERVAL
argument_list|,
name|DEFAULT_ASYNC_SCHEDULER_INTERVAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|scheduleAsynchronously
condition|)
block|{
name|asyncSchedulerThread
operator|=
operator|new
name|AsyncScheduleThread
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Initialized CapacityScheduler with "
operator|+
literal|"calculator="
operator|+
name|getResourceCalculator
argument_list|()
operator|.
name|getClass
argument_list|()
operator|+
literal|", "
operator|+
literal|"minimumAllocation=<"
operator|+
name|getMinimumResourceCapability
argument_list|()
operator|+
literal|">, "
operator|+
literal|"maximumAllocation=<"
operator|+
name|getMaximumResourceCapability
argument_list|()
operator|+
literal|">, "
operator|+
literal|"asynchronousScheduling="
operator|+
name|scheduleAsynchronously
operator|+
literal|", "
operator|+
literal|"asyncScheduleInterval="
operator|+
name|asyncScheduleInterval
operator|+
literal|"ms"
argument_list|)
expr_stmt|;
block|}
DECL|method|startSchedulerThreads ()
specifier|private
specifier|synchronized
name|void
name|startSchedulerThreads
parameter_list|()
block|{
if|if
condition|(
name|scheduleAsynchronously
condition|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|asyncSchedulerThread
argument_list|,
literal|"asyncSchedulerThread is null"
argument_list|)
expr_stmt|;
name|asyncSchedulerThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|serviceInit (Configuration conf)
specifier|public
name|void
name|serviceInit
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
name|Configuration
name|configuration
init|=
operator|new
name|Configuration
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|super
operator|.
name|serviceInit
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|initScheduler
argument_list|(
name|configuration
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|serviceStart ()
specifier|public
name|void
name|serviceStart
parameter_list|()
throws|throws
name|Exception
block|{
name|startSchedulerThreads
argument_list|()
expr_stmt|;
name|super
operator|.
name|serviceStart
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|serviceStop ()
specifier|public
name|void
name|serviceStop
parameter_list|()
throws|throws
name|Exception
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|scheduleAsynchronously
operator|&&
name|asyncSchedulerThread
operator|!=
literal|null
condition|)
block|{
name|asyncSchedulerThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|asyncSchedulerThread
operator|.
name|join
argument_list|(
name|THREAD_JOIN_TIMEOUT_MS
argument_list|)
expr_stmt|;
block|}
block|}
name|super
operator|.
name|serviceStop
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
DECL|method|reinitialize (Configuration conf, RMContext rmContext)
name|reinitialize
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|RMContext
name|rmContext
parameter_list|)
throws|throws
name|IOException
block|{
name|Configuration
name|configuration
init|=
operator|new
name|Configuration
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|CapacitySchedulerConfiguration
name|oldConf
init|=
name|this
operator|.
name|conf
decl_stmt|;
name|this
operator|.
name|conf
operator|=
name|loadCapacitySchedulerConfiguration
argument_list|(
name|configuration
argument_list|)
expr_stmt|;
name|validateConf
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Re-initializing queues..."
argument_list|)
expr_stmt|;
name|refreshMaximumAllocation
argument_list|(
name|this
operator|.
name|conf
operator|.
name|getMaximumAllocation
argument_list|()
argument_list|)
expr_stmt|;
name|reinitializeQueues
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|oldConf
expr_stmt|;
name|refreshMaximumAllocation
argument_list|(
name|this
operator|.
name|conf
operator|.
name|getMaximumAllocation
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to re-init queues"
argument_list|,
name|t
argument_list|)
throw|;
block|}
block|}
DECL|method|getAsyncScheduleInterval ()
name|long
name|getAsyncScheduleInterval
parameter_list|()
block|{
return|return
name|asyncScheduleInterval
return|;
block|}
DECL|field|random
specifier|private
specifier|final
specifier|static
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Schedule on all nodes by starting at a random point.    * @param cs    */
DECL|method|schedule (CapacityScheduler cs)
specifier|static
name|void
name|schedule
parameter_list|(
name|CapacityScheduler
name|cs
parameter_list|)
block|{
comment|// First randomize the start point
name|int
name|current
init|=
literal|0
decl_stmt|;
name|Collection
argument_list|<
name|FiCaSchedulerNode
argument_list|>
name|nodes
init|=
name|cs
operator|.
name|getAllNodes
argument_list|()
operator|.
name|values
argument_list|()
decl_stmt|;
name|int
name|start
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|nodes
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|FiCaSchedulerNode
name|node
range|:
name|nodes
control|)
block|{
if|if
condition|(
name|current
operator|++
operator|>=
name|start
condition|)
block|{
name|cs
operator|.
name|allocateContainersToNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Now, just get everyone to be safe
for|for
control|(
name|FiCaSchedulerNode
name|node
range|:
name|nodes
control|)
block|{
name|cs
operator|.
name|allocateContainersToNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|cs
operator|.
name|getAsyncScheduleInterval
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{}
block|}
DECL|class|AsyncScheduleThread
specifier|static
class|class
name|AsyncScheduleThread
extends|extends
name|Thread
block|{
DECL|field|cs
specifier|private
specifier|final
name|CapacityScheduler
name|cs
decl_stmt|;
DECL|field|runSchedules
specifier|private
name|AtomicBoolean
name|runSchedules
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|method|AsyncScheduleThread (CapacityScheduler cs)
specifier|public
name|AsyncScheduleThread
parameter_list|(
name|CapacityScheduler
name|cs
parameter_list|)
block|{
name|this
operator|.
name|cs
operator|=
name|cs
expr_stmt|;
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|!
name|runSchedules
operator|.
name|get
argument_list|()
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{}
block|}
else|else
block|{
name|schedule
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|beginSchedule ()
specifier|public
name|void
name|beginSchedule
parameter_list|()
block|{
name|runSchedules
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|suspendSchedule ()
specifier|public
name|void
name|suspendSchedule
parameter_list|()
block|{
name|runSchedules
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Private
DECL|field|ROOT_QUEUE
specifier|public
specifier|static
specifier|final
name|String
name|ROOT_QUEUE
init|=
name|CapacitySchedulerConfiguration
operator|.
name|PREFIX
operator|+
name|CapacitySchedulerConfiguration
operator|.
name|ROOT
decl_stmt|;
DECL|class|QueueHook
specifier|static
class|class
name|QueueHook
block|{
DECL|method|hook (CSQueue queue)
specifier|public
name|CSQueue
name|hook
parameter_list|(
name|CSQueue
name|queue
parameter_list|)
block|{
return|return
name|queue
return|;
block|}
block|}
DECL|field|noop
specifier|private
specifier|static
specifier|final
name|QueueHook
name|noop
init|=
operator|new
name|QueueHook
argument_list|()
decl_stmt|;
DECL|method|initializeQueueMappings ()
specifier|private
name|void
name|initializeQueueMappings
parameter_list|()
throws|throws
name|IOException
block|{
name|overrideWithQueueMappings
operator|=
name|conf
operator|.
name|getOverrideWithQueueMappings
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Initialized queue mappings, override: "
operator|+
name|overrideWithQueueMappings
argument_list|)
expr_stmt|;
comment|// Get new user/group mappings
name|List
argument_list|<
name|QueueMapping
argument_list|>
name|newMappings
init|=
name|conf
operator|.
name|getQueueMappings
argument_list|()
decl_stmt|;
comment|//check if mappings refer to valid queues
for|for
control|(
name|QueueMapping
name|mapping
range|:
name|newMappings
control|)
block|{
if|if
condition|(
operator|!
name|mapping
operator|.
name|queue
operator|.
name|equals
argument_list|(
name|CURRENT_USER_MAPPING
argument_list|)
operator|&&
operator|!
name|mapping
operator|.
name|queue
operator|.
name|equals
argument_list|(
name|PRIMARY_GROUP_MAPPING
argument_list|)
condition|)
block|{
name|CSQueue
name|queue
init|=
name|queues
operator|.
name|get
argument_list|(
name|mapping
operator|.
name|queue
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
operator|||
operator|!
operator|(
name|queue
operator|instanceof
name|LeafQueue
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"mapping contains invalid or non-leaf queue "
operator|+
name|mapping
operator|.
name|queue
argument_list|)
throw|;
block|}
block|}
block|}
comment|//apply the new mappings since they are valid
name|mappings
operator|=
name|newMappings
expr_stmt|;
comment|// initialize groups if mappings are present
if|if
condition|(
name|mappings
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|groups
operator|=
operator|new
name|Groups
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Lock
argument_list|(
name|CapacityScheduler
operator|.
name|class
argument_list|)
DECL|method|initializeQueues (CapacitySchedulerConfiguration conf)
specifier|private
name|void
name|initializeQueues
parameter_list|(
name|CapacitySchedulerConfiguration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|root
operator|=
name|parseQueue
argument_list|(
name|this
argument_list|,
name|conf
argument_list|,
literal|null
argument_list|,
name|CapacitySchedulerConfiguration
operator|.
name|ROOT
argument_list|,
name|queues
argument_list|,
name|queues
argument_list|,
name|noop
argument_list|)
expr_stmt|;
name|labelManager
operator|.
name|reinitializeQueueLabels
argument_list|(
name|getQueueToLabels
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Initialized root queue "
operator|+
name|root
argument_list|)
expr_stmt|;
name|initializeQueueMappings
argument_list|()
expr_stmt|;
name|setQueueAcls
argument_list|(
name|authorizer
argument_list|,
name|queues
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Lock
argument_list|(
name|CapacityScheduler
operator|.
name|class
argument_list|)
DECL|method|reinitializeQueues (CapacitySchedulerConfiguration conf)
specifier|private
name|void
name|reinitializeQueues
parameter_list|(
name|CapacitySchedulerConfiguration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Parse new queues
name|Map
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|newQueues
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
argument_list|()
decl_stmt|;
name|CSQueue
name|newRoot
init|=
name|parseQueue
argument_list|(
name|this
argument_list|,
name|conf
argument_list|,
literal|null
argument_list|,
name|CapacitySchedulerConfiguration
operator|.
name|ROOT
argument_list|,
name|newQueues
argument_list|,
name|queues
argument_list|,
name|noop
argument_list|)
decl_stmt|;
comment|// Ensure all existing queues are still present
name|validateExistingQueues
argument_list|(
name|queues
argument_list|,
name|newQueues
argument_list|)
expr_stmt|;
comment|// Add new queues
name|addNewQueues
argument_list|(
name|queues
argument_list|,
name|newQueues
argument_list|)
expr_stmt|;
comment|// Re-configure queues
name|root
operator|.
name|reinitialize
argument_list|(
name|newRoot
argument_list|,
name|clusterResource
argument_list|)
expr_stmt|;
name|initializeQueueMappings
argument_list|()
expr_stmt|;
comment|// Re-calculate headroom for active applications
name|root
operator|.
name|updateClusterResource
argument_list|(
name|clusterResource
argument_list|,
operator|new
name|ResourceLimits
argument_list|(
name|clusterResource
argument_list|)
argument_list|)
expr_stmt|;
name|labelManager
operator|.
name|reinitializeQueueLabels
argument_list|(
name|getQueueToLabels
argument_list|()
argument_list|)
expr_stmt|;
name|setQueueAcls
argument_list|(
name|authorizer
argument_list|,
name|queues
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setQueueAcls (YarnAuthorizationProvider authorizer, Map<String, CSQueue> queues)
specifier|public
specifier|static
name|void
name|setQueueAcls
parameter_list|(
name|YarnAuthorizationProvider
name|authorizer
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|queues
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|CSQueue
name|queue
range|:
name|queues
operator|.
name|values
argument_list|()
control|)
block|{
name|AbstractCSQueue
name|csQueue
init|=
operator|(
name|AbstractCSQueue
operator|)
name|queue
decl_stmt|;
name|authorizer
operator|.
name|setPermission
argument_list|(
name|csQueue
operator|.
name|getPrivilegedEntity
argument_list|()
argument_list|,
name|csQueue
operator|.
name|getACLs
argument_list|()
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getQueueToLabels ()
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|getQueueToLabels
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|queueToLabels
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|CSQueue
name|queue
range|:
name|queues
operator|.
name|values
argument_list|()
control|)
block|{
name|queueToLabels
operator|.
name|put
argument_list|(
name|queue
operator|.
name|getQueueName
argument_list|()
argument_list|,
name|queue
operator|.
name|getAccessibleNodeLabels
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|queueToLabels
return|;
block|}
comment|/**    * Ensure all existing queues are present. Queues cannot be deleted    * @param queues existing queues    * @param newQueues new queues    */
annotation|@
name|Lock
argument_list|(
name|CapacityScheduler
operator|.
name|class
argument_list|)
DECL|method|validateExistingQueues ( Map<String, CSQueue> queues, Map<String, CSQueue> newQueues)
specifier|private
name|void
name|validateExistingQueues
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|queues
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|newQueues
parameter_list|)
throws|throws
name|IOException
block|{
comment|// check that all static queues are included in the newQueues list
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|e
range|:
name|queues
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|e
operator|.
name|getValue
argument_list|()
operator|instanceof
name|ReservationQueue
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|newQueues
operator|.
name|containsKey
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
operator|+
literal|" cannot be found during refresh!"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**    * Add the new queues (only) to our list of queues...    * ... be careful, do not overwrite existing queues.    * @param queues    * @param newQueues    */
annotation|@
name|Lock
argument_list|(
name|CapacityScheduler
operator|.
name|class
argument_list|)
DECL|method|addNewQueues ( Map<String, CSQueue> queues, Map<String, CSQueue> newQueues)
specifier|private
name|void
name|addNewQueues
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|queues
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|newQueues
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|e
range|:
name|newQueues
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|queueName
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|CSQueue
name|queue
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|queues
operator|.
name|containsKey
argument_list|(
name|queueName
argument_list|)
condition|)
block|{
name|queues
operator|.
name|put
argument_list|(
name|queueName
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Lock
argument_list|(
name|CapacityScheduler
operator|.
name|class
argument_list|)
DECL|method|parseQueue ( CapacitySchedulerContext csContext, CapacitySchedulerConfiguration conf, CSQueue parent, String queueName, Map<String, CSQueue> queues, Map<String, CSQueue> oldQueues, QueueHook hook)
specifier|static
name|CSQueue
name|parseQueue
parameter_list|(
name|CapacitySchedulerContext
name|csContext
parameter_list|,
name|CapacitySchedulerConfiguration
name|conf
parameter_list|,
name|CSQueue
name|parent
parameter_list|,
name|String
name|queueName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|queues
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|oldQueues
parameter_list|,
name|QueueHook
name|hook
parameter_list|)
throws|throws
name|IOException
block|{
name|CSQueue
name|queue
decl_stmt|;
name|String
name|fullQueueName
init|=
operator|(
name|parent
operator|==
literal|null
operator|)
condition|?
name|queueName
else|:
operator|(
name|parent
operator|.
name|getQueuePath
argument_list|()
operator|+
literal|"."
operator|+
name|queueName
operator|)
decl_stmt|;
name|String
index|[]
name|childQueueNames
init|=
name|conf
operator|.
name|getQueues
argument_list|(
name|fullQueueName
argument_list|)
decl_stmt|;
name|boolean
name|isReservableQueue
init|=
name|conf
operator|.
name|isReservable
argument_list|(
name|fullQueueName
argument_list|)
decl_stmt|;
if|if
condition|(
name|childQueueNames
operator|==
literal|null
operator|||
name|childQueueNames
operator|.
name|length
operator|==
literal|0
condition|)
block|{
if|if
condition|(
literal|null
operator|==
name|parent
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Queue configuration missing child queue names for "
operator|+
name|queueName
argument_list|)
throw|;
block|}
comment|// Check if the queue will be dynamically managed by the Reservation
comment|// system
if|if
condition|(
name|isReservableQueue
condition|)
block|{
name|queue
operator|=
operator|new
name|PlanQueue
argument_list|(
name|csContext
argument_list|,
name|queueName
argument_list|,
name|parent
argument_list|,
name|oldQueues
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|queue
operator|=
operator|new
name|LeafQueue
argument_list|(
name|csContext
argument_list|,
name|queueName
argument_list|,
name|parent
argument_list|,
name|oldQueues
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
argument_list|)
expr_stmt|;
comment|// Used only for unit tests
name|queue
operator|=
name|hook
operator|.
name|hook
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|isReservableQueue
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Only Leaf Queues can be reservable for "
operator|+
name|queueName
argument_list|)
throw|;
block|}
name|ParentQueue
name|parentQueue
init|=
operator|new
name|ParentQueue
argument_list|(
name|csContext
argument_list|,
name|queueName
argument_list|,
name|parent
argument_list|,
name|oldQueues
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
argument_list|)
decl_stmt|;
comment|// Used only for unit tests
name|queue
operator|=
name|hook
operator|.
name|hook
argument_list|(
name|parentQueue
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|CSQueue
argument_list|>
name|childQueues
init|=
operator|new
name|ArrayList
argument_list|<
name|CSQueue
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|childQueueName
range|:
name|childQueueNames
control|)
block|{
name|CSQueue
name|childQueue
init|=
name|parseQueue
argument_list|(
name|csContext
argument_list|,
name|conf
argument_list|,
name|queue
argument_list|,
name|childQueueName
argument_list|,
name|queues
argument_list|,
name|oldQueues
argument_list|,
name|hook
argument_list|)
decl_stmt|;
name|childQueues
operator|.
name|add
argument_list|(
name|childQueue
argument_list|)
expr_stmt|;
block|}
name|parentQueue
operator|.
name|setChildQueues
argument_list|(
name|childQueues
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|queue
operator|instanceof
name|LeafQueue
operator|==
literal|true
operator|&&
name|queues
operator|.
name|containsKey
argument_list|(
name|queueName
argument_list|)
operator|&&
name|queues
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
operator|instanceof
name|LeafQueue
operator|==
literal|true
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Two leaf queues were named "
operator|+
name|queueName
operator|+
literal|". Leaf queue names must be distinct"
argument_list|)
throw|;
block|}
name|queues
operator|.
name|put
argument_list|(
name|queueName
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Initialized queue: "
operator|+
name|queue
argument_list|)
expr_stmt|;
return|return
name|queue
return|;
block|}
DECL|method|getQueue (String queueName)
specifier|public
name|CSQueue
name|getQueue
parameter_list|(
name|String
name|queueName
parameter_list|)
block|{
if|if
condition|(
name|queueName
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|queues
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
return|;
block|}
DECL|field|CURRENT_USER_MAPPING
specifier|private
specifier|static
specifier|final
name|String
name|CURRENT_USER_MAPPING
init|=
literal|"%user"
decl_stmt|;
DECL|field|PRIMARY_GROUP_MAPPING
specifier|private
specifier|static
specifier|final
name|String
name|PRIMARY_GROUP_MAPPING
init|=
literal|"%primary_group"
decl_stmt|;
DECL|method|getMappedQueue (String user)
specifier|private
name|String
name|getMappedQueue
parameter_list|(
name|String
name|user
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|QueueMapping
name|mapping
range|:
name|mappings
control|)
block|{
if|if
condition|(
name|mapping
operator|.
name|type
operator|==
name|MappingType
operator|.
name|USER
condition|)
block|{
if|if
condition|(
name|mapping
operator|.
name|source
operator|.
name|equals
argument_list|(
name|CURRENT_USER_MAPPING
argument_list|)
condition|)
block|{
if|if
condition|(
name|mapping
operator|.
name|queue
operator|.
name|equals
argument_list|(
name|CURRENT_USER_MAPPING
argument_list|)
condition|)
block|{
return|return
name|user
return|;
block|}
elseif|else
if|if
condition|(
name|mapping
operator|.
name|queue
operator|.
name|equals
argument_list|(
name|PRIMARY_GROUP_MAPPING
argument_list|)
condition|)
block|{
return|return
name|groups
operator|.
name|getGroups
argument_list|(
name|user
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|mapping
operator|.
name|queue
return|;
block|}
block|}
if|if
condition|(
name|user
operator|.
name|equals
argument_list|(
name|mapping
operator|.
name|source
argument_list|)
condition|)
block|{
return|return
name|mapping
operator|.
name|queue
return|;
block|}
block|}
if|if
condition|(
name|mapping
operator|.
name|type
operator|==
name|MappingType
operator|.
name|GROUP
condition|)
block|{
for|for
control|(
name|String
name|userGroups
range|:
name|groups
operator|.
name|getGroups
argument_list|(
name|user
argument_list|)
control|)
block|{
if|if
condition|(
name|userGroups
operator|.
name|equals
argument_list|(
name|mapping
operator|.
name|source
argument_list|)
condition|)
block|{
return|return
name|mapping
operator|.
name|queue
return|;
block|}
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|addApplication (ApplicationId applicationId, String queueName, String user, boolean isAppRecovering)
specifier|private
specifier|synchronized
name|void
name|addApplication
parameter_list|(
name|ApplicationId
name|applicationId
parameter_list|,
name|String
name|queueName
parameter_list|,
name|String
name|user
parameter_list|,
name|boolean
name|isAppRecovering
parameter_list|)
block|{
if|if
condition|(
name|mappings
operator|!=
literal|null
operator|&&
name|mappings
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|String
name|mappedQueue
init|=
name|getMappedQueue
argument_list|(
name|user
argument_list|)
decl_stmt|;
if|if
condition|(
name|mappedQueue
operator|!=
literal|null
condition|)
block|{
comment|// We have a mapping, should we use it?
if|if
condition|(
name|queueName
operator|.
name|equals
argument_list|(
name|YarnConfiguration
operator|.
name|DEFAULT_QUEUE_NAME
argument_list|)
operator|||
name|overrideWithQueueMappings
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Application "
operator|+
name|applicationId
operator|+
literal|" user "
operator|+
name|user
operator|+
literal|" mapping ["
operator|+
name|queueName
operator|+
literal|"] to ["
operator|+
name|mappedQueue
operator|+
literal|"] override "
operator|+
name|overrideWithQueueMappings
argument_list|)
expr_stmt|;
name|queueName
operator|=
name|mappedQueue
expr_stmt|;
name|RMApp
name|rmApp
init|=
name|rmContext
operator|.
name|getRMApps
argument_list|()
operator|.
name|get
argument_list|(
name|applicationId
argument_list|)
decl_stmt|;
name|rmApp
operator|.
name|setQueue
argument_list|(
name|queueName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioex
parameter_list|)
block|{
name|String
name|message
init|=
literal|"Failed to submit application "
operator|+
name|applicationId
operator|+
literal|" submitted by user "
operator|+
name|user
operator|+
literal|" reason: "
operator|+
name|ioex
operator|.
name|getMessage
argument_list|()
decl_stmt|;
name|this
operator|.
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMAppRejectedEvent
argument_list|(
name|applicationId
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// sanity checks.
name|CSQueue
name|queue
init|=
name|getQueue
argument_list|(
name|queueName
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
block|{
comment|//During a restart, this indicates a queue was removed, which is
comment|//not presently supported
if|if
condition|(
name|isAppRecovering
condition|)
block|{
name|String
name|queueErrorMsg
init|=
literal|"Queue named "
operator|+
name|queueName
operator|+
literal|" missing during application recovery."
operator|+
literal|" Queue removal during recovery is not presently supported by the"
operator|+
literal|" capacity scheduler, please restart with all queues configured"
operator|+
literal|" which were present before shutdown/restart."
decl_stmt|;
name|LOG
operator|.
name|fatal
argument_list|(
name|queueErrorMsg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|QueueNotFoundException
argument_list|(
name|queueErrorMsg
argument_list|)
throw|;
block|}
name|String
name|message
init|=
literal|"Application "
operator|+
name|applicationId
operator|+
literal|" submitted by user "
operator|+
name|user
operator|+
literal|" to unknown queue: "
operator|+
name|queueName
decl_stmt|;
name|this
operator|.
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMAppRejectedEvent
argument_list|(
name|applicationId
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|queue
operator|instanceof
name|LeafQueue
operator|)
condition|)
block|{
name|String
name|message
init|=
literal|"Application "
operator|+
name|applicationId
operator|+
literal|" submitted by user "
operator|+
name|user
operator|+
literal|" to non-leaf queue: "
operator|+
name|queueName
decl_stmt|;
name|this
operator|.
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMAppRejectedEvent
argument_list|(
name|applicationId
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Submit to the queue
try|try
block|{
name|queue
operator|.
name|submitApplication
argument_list|(
name|applicationId
argument_list|,
name|user
argument_list|,
name|queueName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|ace
parameter_list|)
block|{
comment|// Ignore the exception for recovered app as the app was previously accepted
if|if
condition|(
operator|!
name|isAppRecovering
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to submit application "
operator|+
name|applicationId
operator|+
literal|" to queue "
operator|+
name|queueName
operator|+
literal|" from user "
operator|+
name|user
argument_list|,
name|ace
argument_list|)
expr_stmt|;
name|this
operator|.
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMAppRejectedEvent
argument_list|(
name|applicationId
argument_list|,
name|ace
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// update the metrics
name|queue
operator|.
name|getMetrics
argument_list|()
operator|.
name|submitApp
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|SchedulerApplication
argument_list|<
name|FiCaSchedulerApp
argument_list|>
name|application
init|=
operator|new
name|SchedulerApplication
argument_list|<
name|FiCaSchedulerApp
argument_list|>
argument_list|(
name|queue
argument_list|,
name|user
argument_list|)
decl_stmt|;
name|applications
operator|.
name|put
argument_list|(
name|applicationId
argument_list|,
name|application
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Accepted application "
operator|+
name|applicationId
operator|+
literal|" from user: "
operator|+
name|user
operator|+
literal|", in queue: "
operator|+
name|queueName
argument_list|)
expr_stmt|;
if|if
condition|(
name|isAppRecovering
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|applicationId
operator|+
literal|" is recovering. Skip notifying APP_ACCEPTED"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMAppEvent
argument_list|(
name|applicationId
argument_list|,
name|RMAppEventType
operator|.
name|APP_ACCEPTED
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addApplicationAttempt ( ApplicationAttemptId applicationAttemptId, boolean transferStateFromPreviousAttempt, boolean isAttemptRecovering)
specifier|private
specifier|synchronized
name|void
name|addApplicationAttempt
parameter_list|(
name|ApplicationAttemptId
name|applicationAttemptId
parameter_list|,
name|boolean
name|transferStateFromPreviousAttempt
parameter_list|,
name|boolean
name|isAttemptRecovering
parameter_list|)
block|{
name|SchedulerApplication
argument_list|<
name|FiCaSchedulerApp
argument_list|>
name|application
init|=
name|applications
operator|.
name|get
argument_list|(
name|applicationAttemptId
operator|.
name|getApplicationId
argument_list|()
argument_list|)
decl_stmt|;
name|CSQueue
name|queue
init|=
operator|(
name|CSQueue
operator|)
name|application
operator|.
name|getQueue
argument_list|()
decl_stmt|;
name|FiCaSchedulerApp
name|attempt
init|=
operator|new
name|FiCaSchedulerApp
argument_list|(
name|applicationAttemptId
argument_list|,
name|application
operator|.
name|getUser
argument_list|()
argument_list|,
name|queue
argument_list|,
name|queue
operator|.
name|getActiveUsersManager
argument_list|()
argument_list|,
name|rmContext
argument_list|)
decl_stmt|;
if|if
condition|(
name|transferStateFromPreviousAttempt
condition|)
block|{
name|attempt
operator|.
name|transferStateFromPreviousAttempt
argument_list|(
name|application
operator|.
name|getCurrentAppAttempt
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|application
operator|.
name|setCurrentAppAttempt
argument_list|(
name|attempt
argument_list|)
expr_stmt|;
name|queue
operator|.
name|submitApplicationAttempt
argument_list|(
name|attempt
argument_list|,
name|application
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Added Application Attempt "
operator|+
name|applicationAttemptId
operator|+
literal|" to scheduler from user "
operator|+
name|application
operator|.
name|getUser
argument_list|()
operator|+
literal|" in queue "
operator|+
name|queue
operator|.
name|getQueueName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|isAttemptRecovering
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|applicationAttemptId
operator|+
literal|" is recovering. Skipping notifying ATTEMPT_ADDED"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMAppAttemptEvent
argument_list|(
name|applicationAttemptId
argument_list|,
name|RMAppAttemptEventType
operator|.
name|ATTEMPT_ADDED
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doneApplication (ApplicationId applicationId, RMAppState finalState)
specifier|private
specifier|synchronized
name|void
name|doneApplication
parameter_list|(
name|ApplicationId
name|applicationId
parameter_list|,
name|RMAppState
name|finalState
parameter_list|)
block|{
name|SchedulerApplication
argument_list|<
name|FiCaSchedulerApp
argument_list|>
name|application
init|=
name|applications
operator|.
name|get
argument_list|(
name|applicationId
argument_list|)
decl_stmt|;
if|if
condition|(
name|application
operator|==
literal|null
condition|)
block|{
comment|// The AppRemovedSchedulerEvent maybe sent on recovery for completed apps,
comment|// ignore it.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Couldn't find application "
operator|+
name|applicationId
argument_list|)
expr_stmt|;
return|return;
block|}
name|CSQueue
name|queue
init|=
operator|(
name|CSQueue
operator|)
name|application
operator|.
name|getQueue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|queue
operator|instanceof
name|LeafQueue
operator|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot finish application "
operator|+
literal|"from non-leaf queue: "
operator|+
name|queue
operator|.
name|getQueueName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|queue
operator|.
name|finishApplication
argument_list|(
name|applicationId
argument_list|,
name|application
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|application
operator|.
name|stop
argument_list|(
name|finalState
argument_list|)
expr_stmt|;
name|applications
operator|.
name|remove
argument_list|(
name|applicationId
argument_list|)
expr_stmt|;
block|}
DECL|method|doneApplicationAttempt ( ApplicationAttemptId applicationAttemptId, RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers)
specifier|private
specifier|synchronized
name|void
name|doneApplicationAttempt
parameter_list|(
name|ApplicationAttemptId
name|applicationAttemptId
parameter_list|,
name|RMAppAttemptState
name|rmAppAttemptFinalState
parameter_list|,
name|boolean
name|keepContainers
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Application Attempt "
operator|+
name|applicationAttemptId
operator|+
literal|" is done."
operator|+
literal|" finalState="
operator|+
name|rmAppAttemptFinalState
argument_list|)
expr_stmt|;
name|FiCaSchedulerApp
name|attempt
init|=
name|getApplicationAttempt
argument_list|(
name|applicationAttemptId
argument_list|)
decl_stmt|;
name|SchedulerApplication
argument_list|<
name|FiCaSchedulerApp
argument_list|>
name|application
init|=
name|applications
operator|.
name|get
argument_list|(
name|applicationAttemptId
operator|.
name|getApplicationId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|application
operator|==
literal|null
operator|||
name|attempt
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Unknown application "
operator|+
name|applicationAttemptId
operator|+
literal|" has completed!"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Release all the allocated, acquired, running containers
for|for
control|(
name|RMContainer
name|rmContainer
range|:
name|attempt
operator|.
name|getLiveContainers
argument_list|()
control|)
block|{
if|if
condition|(
name|keepContainers
operator|&&
name|rmContainer
operator|.
name|getState
argument_list|()
operator|.
name|equals
argument_list|(
name|RMContainerState
operator|.
name|RUNNING
argument_list|)
condition|)
block|{
comment|// do not kill the running container in the case of work-preserving AM
comment|// restart.
name|LOG
operator|.
name|info
argument_list|(
literal|"Skip killing "
operator|+
name|rmContainer
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|completedContainer
argument_list|(
name|rmContainer
argument_list|,
name|SchedulerUtils
operator|.
name|createAbnormalContainerStatus
argument_list|(
name|rmContainer
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|SchedulerUtils
operator|.
name|COMPLETED_APPLICATION
argument_list|)
argument_list|,
name|RMContainerEventType
operator|.
name|KILL
argument_list|)
expr_stmt|;
block|}
comment|// Release all reserved containers
for|for
control|(
name|RMContainer
name|rmContainer
range|:
name|attempt
operator|.
name|getReservedContainers
argument_list|()
control|)
block|{
name|completedContainer
argument_list|(
name|rmContainer
argument_list|,
name|SchedulerUtils
operator|.
name|createAbnormalContainerStatus
argument_list|(
name|rmContainer
operator|.
name|getContainerId
argument_list|()
argument_list|,
literal|"Application Complete"
argument_list|)
argument_list|,
name|RMContainerEventType
operator|.
name|KILL
argument_list|)
expr_stmt|;
block|}
comment|// Clean up pending requests, metrics etc.
name|attempt
operator|.
name|stop
argument_list|(
name|rmAppAttemptFinalState
argument_list|)
expr_stmt|;
comment|// Inform the queue
name|String
name|queueName
init|=
name|attempt
operator|.
name|getQueue
argument_list|()
operator|.
name|getQueueName
argument_list|()
decl_stmt|;
name|CSQueue
name|queue
init|=
name|queues
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|queue
operator|instanceof
name|LeafQueue
operator|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot finish application "
operator|+
literal|"from non-leaf queue: "
operator|+
name|queueName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|queue
operator|.
name|finishApplicationAttempt
argument_list|(
name|attempt
argument_list|,
name|queue
operator|.
name|getQueueName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|Lock
argument_list|(
name|Lock
operator|.
name|NoLock
operator|.
name|class
argument_list|)
DECL|method|allocate (ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals)
specifier|public
name|Allocation
name|allocate
parameter_list|(
name|ApplicationAttemptId
name|applicationAttemptId
parameter_list|,
name|List
argument_list|<
name|ResourceRequest
argument_list|>
name|ask
parameter_list|,
name|List
argument_list|<
name|ContainerId
argument_list|>
name|release
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|blacklistAdditions
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|blacklistRemovals
parameter_list|)
block|{
name|FiCaSchedulerApp
name|application
init|=
name|getApplicationAttempt
argument_list|(
name|applicationAttemptId
argument_list|)
decl_stmt|;
if|if
condition|(
name|application
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Calling allocate on removed "
operator|+
literal|"or non existant application "
operator|+
name|applicationAttemptId
argument_list|)
expr_stmt|;
return|return
name|EMPTY_ALLOCATION
return|;
block|}
comment|// Sanity check
name|SchedulerUtils
operator|.
name|normalizeRequests
argument_list|(
name|ask
argument_list|,
name|getResourceCalculator
argument_list|()
argument_list|,
name|getClusterResource
argument_list|()
argument_list|,
name|getMinimumResourceCapability
argument_list|()
argument_list|,
name|getMaximumResourceCapability
argument_list|()
argument_list|)
expr_stmt|;
comment|// Release containers
name|releaseContainers
argument_list|(
name|release
argument_list|,
name|application
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|application
init|)
block|{
comment|// make sure we aren't stopping/removing the application
comment|// when the allocate comes in
if|if
condition|(
name|application
operator|.
name|isStopped
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Calling allocate on a stopped "
operator|+
literal|"application "
operator|+
name|applicationAttemptId
argument_list|)
expr_stmt|;
return|return
name|EMPTY_ALLOCATION
return|;
block|}
if|if
condition|(
operator|!
name|ask
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"allocate: pre-update"
operator|+
literal|" applicationAttemptId="
operator|+
name|applicationAttemptId
operator|+
literal|" application="
operator|+
name|application
argument_list|)
expr_stmt|;
block|}
name|application
operator|.
name|showRequests
argument_list|()
expr_stmt|;
comment|// Update application requests
name|application
operator|.
name|updateResourceRequests
argument_list|(
name|ask
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"allocate: post-update"
argument_list|)
expr_stmt|;
name|application
operator|.
name|showRequests
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"allocate:"
operator|+
literal|" applicationAttemptId="
operator|+
name|applicationAttemptId
operator|+
literal|" #ask="
operator|+
name|ask
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|application
operator|.
name|updateBlacklist
argument_list|(
name|blacklistAdditions
argument_list|,
name|blacklistRemovals
argument_list|)
expr_stmt|;
return|return
name|application
operator|.
name|getAllocation
argument_list|(
name|getResourceCalculator
argument_list|()
argument_list|,
name|clusterResource
argument_list|,
name|getMinimumResourceCapability
argument_list|()
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|Lock
argument_list|(
name|Lock
operator|.
name|NoLock
operator|.
name|class
argument_list|)
DECL|method|getQueueInfo (String queueName, boolean includeChildQueues, boolean recursive)
specifier|public
name|QueueInfo
name|getQueueInfo
parameter_list|(
name|String
name|queueName
parameter_list|,
name|boolean
name|includeChildQueues
parameter_list|,
name|boolean
name|recursive
parameter_list|)
throws|throws
name|IOException
block|{
name|CSQueue
name|queue
init|=
literal|null
decl_stmt|;
name|queue
operator|=
name|this
operator|.
name|queues
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
expr_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown queue: "
operator|+
name|queueName
argument_list|)
throw|;
block|}
return|return
name|queue
operator|.
name|getQueueInfo
argument_list|(
name|includeChildQueues
argument_list|,
name|recursive
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|Lock
argument_list|(
name|Lock
operator|.
name|NoLock
operator|.
name|class
argument_list|)
DECL|method|getQueueUserAclInfo ()
specifier|public
name|List
argument_list|<
name|QueueUserACLInfo
argument_list|>
name|getQueueUserAclInfo
parameter_list|()
block|{
name|UserGroupInformation
name|user
init|=
literal|null
decl_stmt|;
try|try
block|{
name|user
operator|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// should never happen
return|return
operator|new
name|ArrayList
argument_list|<
name|QueueUserACLInfo
argument_list|>
argument_list|()
return|;
block|}
return|return
name|root
operator|.
name|getQueueUserAclInfo
argument_list|(
name|user
argument_list|)
return|;
block|}
DECL|method|nodeUpdate (RMNode nm)
specifier|private
specifier|synchronized
name|void
name|nodeUpdate
parameter_list|(
name|RMNode
name|nm
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"nodeUpdate: "
operator|+
name|nm
operator|+
literal|" clusterResources: "
operator|+
name|clusterResource
argument_list|)
expr_stmt|;
block|}
name|Resource
name|releaseResources
init|=
name|Resource
operator|.
name|newInstance
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|FiCaSchedulerNode
name|node
init|=
name|getNode
argument_list|(
name|nm
operator|.
name|getNodeID
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|UpdatedContainerInfo
argument_list|>
name|containerInfoList
init|=
name|nm
operator|.
name|pullContainerUpdates
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ContainerStatus
argument_list|>
name|newlyLaunchedContainers
init|=
operator|new
name|ArrayList
argument_list|<
name|ContainerStatus
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ContainerStatus
argument_list|>
name|completedContainers
init|=
operator|new
name|ArrayList
argument_list|<
name|ContainerStatus
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|UpdatedContainerInfo
name|containerInfo
range|:
name|containerInfoList
control|)
block|{
name|newlyLaunchedContainers
operator|.
name|addAll
argument_list|(
name|containerInfo
operator|.
name|getNewlyLaunchedContainers
argument_list|()
argument_list|)
expr_stmt|;
name|completedContainers
operator|.
name|addAll
argument_list|(
name|containerInfo
operator|.
name|getCompletedContainers
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Processing the newly launched containers
for|for
control|(
name|ContainerStatus
name|launchedContainer
range|:
name|newlyLaunchedContainers
control|)
block|{
name|containerLaunchedOnNode
argument_list|(
name|launchedContainer
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
comment|// Process completed containers
name|int
name|releasedContainers
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ContainerStatus
name|completedContainer
range|:
name|completedContainers
control|)
block|{
name|ContainerId
name|containerId
init|=
name|completedContainer
operator|.
name|getContainerId
argument_list|()
decl_stmt|;
name|RMContainer
name|container
init|=
name|getRMContainer
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Container FINISHED: "
operator|+
name|containerId
argument_list|)
expr_stmt|;
name|completedContainer
argument_list|(
name|container
argument_list|,
name|completedContainer
argument_list|,
name|RMContainerEventType
operator|.
name|FINISHED
argument_list|)
expr_stmt|;
if|if
condition|(
name|container
operator|!=
literal|null
condition|)
block|{
name|releasedContainers
operator|++
expr_stmt|;
name|Resource
name|rs
init|=
name|container
operator|.
name|getAllocatedResource
argument_list|()
decl_stmt|;
if|if
condition|(
name|rs
operator|!=
literal|null
condition|)
block|{
name|Resources
operator|.
name|addTo
argument_list|(
name|releaseResources
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
name|rs
operator|=
name|container
operator|.
name|getReservedResource
argument_list|()
expr_stmt|;
if|if
condition|(
name|rs
operator|!=
literal|null
condition|)
block|{
name|Resources
operator|.
name|addTo
argument_list|(
name|releaseResources
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|schedulerHealth
operator|.
name|updateSchedulerReleaseDetails
argument_list|(
name|lastNodeUpdateTime
argument_list|,
name|releaseResources
argument_list|)
expr_stmt|;
name|schedulerHealth
operator|.
name|updateSchedulerReleaseCounts
argument_list|(
name|releasedContainers
argument_list|)
expr_stmt|;
comment|// Now node data structures are upto date and ready for scheduling.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node being looked for scheduling "
operator|+
name|nm
operator|+
literal|" availableResource: "
operator|+
name|node
operator|.
name|getAvailableResource
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Process resource update on a node.    */
DECL|method|updateNodeAndQueueResource (RMNode nm, ResourceOption resourceOption)
specifier|private
specifier|synchronized
name|void
name|updateNodeAndQueueResource
parameter_list|(
name|RMNode
name|nm
parameter_list|,
name|ResourceOption
name|resourceOption
parameter_list|)
block|{
name|updateNodeResource
argument_list|(
name|nm
argument_list|,
name|resourceOption
argument_list|)
expr_stmt|;
name|root
operator|.
name|updateClusterResource
argument_list|(
name|clusterResource
argument_list|,
operator|new
name|ResourceLimits
argument_list|(
name|clusterResource
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Process node labels update on a node.    *     * TODO: Currently capacity scheduler will kill containers on a node when    * labels on the node changed. It is a simply solution to ensure guaranteed    * capacity on labels of queues. When YARN-2498 completed, we can let    * preemption policy to decide if such containers need to be killed or just    * keep them running.    */
DECL|method|updateLabelsOnNode (NodeId nodeId, Set<String> newLabels)
specifier|private
specifier|synchronized
name|void
name|updateLabelsOnNode
parameter_list|(
name|NodeId
name|nodeId
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|newLabels
parameter_list|)
block|{
name|FiCaSchedulerNode
name|node
init|=
name|nodes
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|node
condition|)
block|{
return|return;
block|}
comment|// labels is same, we don't need do update
if|if
condition|(
name|node
operator|.
name|getLabels
argument_list|()
operator|.
name|size
argument_list|()
operator|==
name|newLabels
operator|.
name|size
argument_list|()
operator|&&
name|node
operator|.
name|getLabels
argument_list|()
operator|.
name|containsAll
argument_list|(
name|newLabels
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Kill running containers since label is changed
for|for
control|(
name|RMContainer
name|rmContainer
range|:
name|node
operator|.
name|getRunningContainers
argument_list|()
control|)
block|{
name|ContainerId
name|containerId
init|=
name|rmContainer
operator|.
name|getContainerId
argument_list|()
decl_stmt|;
name|completedContainer
argument_list|(
name|rmContainer
argument_list|,
name|ContainerStatus
operator|.
name|newInstance
argument_list|(
name|containerId
argument_list|,
name|ContainerState
operator|.
name|COMPLETE
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"Container=%s killed since labels on the node=%s changed"
argument_list|,
name|containerId
operator|.
name|toString
argument_list|()
argument_list|,
name|nodeId
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|ContainerExitStatus
operator|.
name|KILLED_BY_RESOURCEMANAGER
argument_list|)
argument_list|,
name|RMContainerEventType
operator|.
name|KILL
argument_list|)
expr_stmt|;
block|}
comment|// Unreserve container on this node
name|RMContainer
name|reservedContainer
init|=
name|node
operator|.
name|getReservedContainer
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|reservedContainer
condition|)
block|{
name|dropContainerReservation
argument_list|(
name|reservedContainer
argument_list|)
expr_stmt|;
block|}
comment|// Update node labels after we've done this
name|node
operator|.
name|updateLabels
argument_list|(
name|newLabels
argument_list|)
expr_stmt|;
block|}
DECL|method|updateSchedulerHealth (long now, FiCaSchedulerNode node, CSAssignment assignment)
specifier|private
name|void
name|updateSchedulerHealth
parameter_list|(
name|long
name|now
parameter_list|,
name|FiCaSchedulerNode
name|node
parameter_list|,
name|CSAssignment
name|assignment
parameter_list|)
block|{
name|NodeId
name|nodeId
init|=
name|node
operator|.
name|getNodeID
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AssignmentInformation
operator|.
name|AssignmentDetails
argument_list|>
name|allocations
init|=
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getAllocationDetails
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AssignmentInformation
operator|.
name|AssignmentDetails
argument_list|>
name|reservations
init|=
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getReservationDetails
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|allocations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ContainerId
name|allocatedContainerId
init|=
name|allocations
operator|.
name|get
argument_list|(
name|allocations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|containerId
decl_stmt|;
name|String
name|allocatedQueue
init|=
name|allocations
operator|.
name|get
argument_list|(
name|allocations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|queue
decl_stmt|;
name|schedulerHealth
operator|.
name|updateAllocation
argument_list|(
name|now
argument_list|,
name|nodeId
argument_list|,
name|allocatedContainerId
argument_list|,
name|allocatedQueue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|reservations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ContainerId
name|reservedContainerId
init|=
name|reservations
operator|.
name|get
argument_list|(
name|reservations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|containerId
decl_stmt|;
name|String
name|reservedQueue
init|=
name|reservations
operator|.
name|get
argument_list|(
name|reservations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|queue
decl_stmt|;
name|schedulerHealth
operator|.
name|updateReservation
argument_list|(
name|now
argument_list|,
name|nodeId
argument_list|,
name|reservedContainerId
argument_list|,
name|reservedQueue
argument_list|)
expr_stmt|;
block|}
name|schedulerHealth
operator|.
name|updateSchedulerReservationCounts
argument_list|(
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getNumReservations
argument_list|()
argument_list|)
expr_stmt|;
name|schedulerHealth
operator|.
name|updateSchedulerAllocationCounts
argument_list|(
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getNumAllocations
argument_list|()
argument_list|)
expr_stmt|;
name|schedulerHealth
operator|.
name|updateSchedulerRunDetails
argument_list|(
name|now
argument_list|,
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getAllocated
argument_list|()
argument_list|,
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getReserved
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|allocateContainersToNode (FiCaSchedulerNode node)
specifier|private
specifier|synchronized
name|void
name|allocateContainersToNode
parameter_list|(
name|FiCaSchedulerNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|rmContext
operator|.
name|isWorkPreservingRecoveryEnabled
argument_list|()
operator|&&
operator|!
name|rmContext
operator|.
name|isSchedulerReadyForAllocatingContainers
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// reset allocation and reservation stats before we start doing any work
name|updateSchedulerHealth
argument_list|(
name|lastNodeUpdateTime
argument_list|,
name|node
argument_list|,
operator|new
name|CSAssignment
argument_list|(
name|Resources
operator|.
name|none
argument_list|()
argument_list|,
name|NodeType
operator|.
name|NODE_LOCAL
argument_list|)
argument_list|)
expr_stmt|;
name|CSAssignment
name|assignment
decl_stmt|;
comment|// Assign new containers...
comment|// 1. Check for reserved applications
comment|// 2. Schedule if there are no reservations
name|RMContainer
name|reservedContainer
init|=
name|node
operator|.
name|getReservedContainer
argument_list|()
decl_stmt|;
if|if
condition|(
name|reservedContainer
operator|!=
literal|null
condition|)
block|{
name|FiCaSchedulerApp
name|reservedApplication
init|=
name|getCurrentAttemptForContainer
argument_list|(
name|reservedContainer
operator|.
name|getContainerId
argument_list|()
argument_list|)
decl_stmt|;
comment|// Try to fulfill the reservation
name|LOG
operator|.
name|info
argument_list|(
literal|"Trying to fulfill reservation for application "
operator|+
name|reservedApplication
operator|.
name|getApplicationId
argument_list|()
operator|+
literal|" on node: "
operator|+
name|node
operator|.
name|getNodeID
argument_list|()
argument_list|)
expr_stmt|;
name|LeafQueue
name|queue
init|=
operator|(
operator|(
name|LeafQueue
operator|)
name|reservedApplication
operator|.
name|getQueue
argument_list|()
operator|)
decl_stmt|;
name|assignment
operator|=
name|queue
operator|.
name|assignContainers
argument_list|(
name|clusterResource
argument_list|,
name|node
argument_list|,
comment|// TODO, now we only consider limits for parent for non-labeled
comment|// resources, should consider labeled resources as well.
operator|new
name|ResourceLimits
argument_list|(
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|,
name|clusterResource
argument_list|)
argument_list|)
argument_list|,
name|SchedulingMode
operator|.
name|RESPECT_PARTITION_EXCLUSIVITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|assignment
operator|.
name|isFulfilledReservation
argument_list|()
condition|)
block|{
name|CSAssignment
name|tmp
init|=
operator|new
name|CSAssignment
argument_list|(
name|reservedContainer
operator|.
name|getReservedResource
argument_list|()
argument_list|,
name|assignment
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|Resources
operator|.
name|addTo
argument_list|(
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getAllocated
argument_list|()
argument_list|,
name|reservedContainer
operator|.
name|getReservedResource
argument_list|()
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|addAllocationDetails
argument_list|(
name|reservedContainer
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|queue
operator|.
name|getQueuePath
argument_list|()
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|incrAllocations
argument_list|()
expr_stmt|;
name|updateSchedulerHealth
argument_list|(
name|lastNodeUpdateTime
argument_list|,
name|node
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|schedulerHealth
operator|.
name|updateSchedulerFulfilledReservationCounts
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|RMContainer
name|excessReservation
init|=
name|assignment
operator|.
name|getExcessReservation
argument_list|()
decl_stmt|;
if|if
condition|(
name|excessReservation
operator|!=
literal|null
condition|)
block|{
name|Container
name|container
init|=
name|excessReservation
operator|.
name|getContainer
argument_list|()
decl_stmt|;
name|queue
operator|.
name|completedContainer
argument_list|(
name|clusterResource
argument_list|,
name|assignment
operator|.
name|getApplication
argument_list|()
argument_list|,
name|node
argument_list|,
name|excessReservation
argument_list|,
name|SchedulerUtils
operator|.
name|createAbnormalContainerStatus
argument_list|(
name|container
operator|.
name|getId
argument_list|()
argument_list|,
name|SchedulerUtils
operator|.
name|UNRESERVED_CONTAINER
argument_list|)
argument_list|,
name|RMContainerEventType
operator|.
name|RELEASED
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Try to schedule more if there are no reservations to fulfill
if|if
condition|(
name|node
operator|.
name|getReservedContainer
argument_list|()
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|calculator
operator|.
name|computeAvailableContainers
argument_list|(
name|node
operator|.
name|getAvailableResource
argument_list|()
argument_list|,
name|minimumAllocation
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying to schedule on node: "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|", available: "
operator|+
name|node
operator|.
name|getAvailableResource
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assignment
operator|=
name|root
operator|.
name|assignContainers
argument_list|(
name|clusterResource
argument_list|,
name|node
argument_list|,
comment|// TODO, now we only consider limits for parent for non-labeled
comment|// resources, should consider labeled resources as well.
operator|new
name|ResourceLimits
argument_list|(
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|,
name|clusterResource
argument_list|)
argument_list|)
argument_list|,
name|SchedulingMode
operator|.
name|RESPECT_PARTITION_EXCLUSIVITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|Resources
operator|.
name|greaterThan
argument_list|(
name|calculator
argument_list|,
name|clusterResource
argument_list|,
name|assignment
operator|.
name|getResource
argument_list|()
argument_list|,
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
condition|)
block|{
name|updateSchedulerHealth
argument_list|(
name|lastNodeUpdateTime
argument_list|,
name|node
argument_list|,
name|assignment
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Only do non-exclusive allocation when node has node-labels.
if|if
condition|(
name|StringUtils
operator|.
name|equals
argument_list|(
name|node
operator|.
name|getPartition
argument_list|()
argument_list|,
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Only do non-exclusive allocation when the node-label supports that
try|try
block|{
if|if
condition|(
name|rmContext
operator|.
name|getNodeLabelManager
argument_list|()
operator|.
name|isExclusiveNodeLabel
argument_list|(
name|node
operator|.
name|getPartition
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception when trying to get exclusivity of node label="
operator|+
name|node
operator|.
name|getPartition
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Try to use NON_EXCLUSIVE
name|assignment
operator|=
name|root
operator|.
name|assignContainers
argument_list|(
name|clusterResource
argument_list|,
name|node
argument_list|,
comment|// TODO, now we only consider limits for parent for non-labeled
comment|// resources, should consider labeled resources as well.
operator|new
name|ResourceLimits
argument_list|(
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|,
name|clusterResource
argument_list|)
argument_list|)
argument_list|,
name|SchedulingMode
operator|.
name|IGNORE_PARTITION_EXCLUSIVITY
argument_list|)
expr_stmt|;
name|updateSchedulerHealth
argument_list|(
name|lastNodeUpdateTime
argument_list|,
name|node
argument_list|,
name|assignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|Resources
operator|.
name|greaterThan
argument_list|(
name|calculator
argument_list|,
name|clusterResource
argument_list|,
name|assignment
operator|.
name|getResource
argument_list|()
argument_list|,
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skipping scheduling since node "
operator|+
name|node
operator|.
name|getNodeID
argument_list|()
operator|+
literal|" is reserved by application "
operator|+
name|node
operator|.
name|getReservedContainer
argument_list|()
operator|.
name|getContainerId
argument_list|()
operator|.
name|getApplicationAttemptId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|handle (SchedulerEvent event)
specifier|public
name|void
name|handle
parameter_list|(
name|SchedulerEvent
name|event
parameter_list|)
block|{
switch|switch
condition|(
name|event
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|NODE_ADDED
case|:
block|{
name|NodeAddedSchedulerEvent
name|nodeAddedEvent
init|=
operator|(
name|NodeAddedSchedulerEvent
operator|)
name|event
decl_stmt|;
name|addNode
argument_list|(
name|nodeAddedEvent
operator|.
name|getAddedRMNode
argument_list|()
argument_list|)
expr_stmt|;
name|recoverContainersOnNode
argument_list|(
name|nodeAddedEvent
operator|.
name|getContainerReports
argument_list|()
argument_list|,
name|nodeAddedEvent
operator|.
name|getAddedRMNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NODE_REMOVED
case|:
block|{
name|NodeRemovedSchedulerEvent
name|nodeRemovedEvent
init|=
operator|(
name|NodeRemovedSchedulerEvent
operator|)
name|event
decl_stmt|;
name|removeNode
argument_list|(
name|nodeRemovedEvent
operator|.
name|getRemovedRMNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NODE_RESOURCE_UPDATE
case|:
block|{
name|NodeResourceUpdateSchedulerEvent
name|nodeResourceUpdatedEvent
init|=
operator|(
name|NodeResourceUpdateSchedulerEvent
operator|)
name|event
decl_stmt|;
name|updateNodeAndQueueResource
argument_list|(
name|nodeResourceUpdatedEvent
operator|.
name|getRMNode
argument_list|()
argument_list|,
name|nodeResourceUpdatedEvent
operator|.
name|getResourceOption
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NODE_LABELS_UPDATE
case|:
block|{
name|NodeLabelsUpdateSchedulerEvent
name|labelUpdateEvent
init|=
operator|(
name|NodeLabelsUpdateSchedulerEvent
operator|)
name|event
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|NodeId
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|labelUpdateEvent
operator|.
name|getUpdatedNodeToLabels
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|NodeId
name|id
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|labels
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|updateLabelsOnNode
argument_list|(
name|id
argument_list|,
name|labels
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|NODE_UPDATE
case|:
block|{
name|NodeUpdateSchedulerEvent
name|nodeUpdatedEvent
init|=
operator|(
name|NodeUpdateSchedulerEvent
operator|)
name|event
decl_stmt|;
name|RMNode
name|node
init|=
name|nodeUpdatedEvent
operator|.
name|getRMNode
argument_list|()
decl_stmt|;
name|setLastNodeUpdateTime
argument_list|(
name|Time
operator|.
name|now
argument_list|()
argument_list|)
expr_stmt|;
name|nodeUpdate
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scheduleAsynchronously
condition|)
block|{
name|allocateContainersToNode
argument_list|(
name|getNode
argument_list|(
name|node
operator|.
name|getNodeID
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|APP_ADDED
case|:
block|{
name|AppAddedSchedulerEvent
name|appAddedEvent
init|=
operator|(
name|AppAddedSchedulerEvent
operator|)
name|event
decl_stmt|;
name|String
name|queueName
init|=
name|resolveReservationQueueName
argument_list|(
name|appAddedEvent
operator|.
name|getQueue
argument_list|()
argument_list|,
name|appAddedEvent
operator|.
name|getApplicationId
argument_list|()
argument_list|,
name|appAddedEvent
operator|.
name|getReservationID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|queueName
operator|!=
literal|null
condition|)
block|{
name|addApplication
argument_list|(
name|appAddedEvent
operator|.
name|getApplicationId
argument_list|()
argument_list|,
name|queueName
argument_list|,
name|appAddedEvent
operator|.
name|getUser
argument_list|()
argument_list|,
name|appAddedEvent
operator|.
name|getIsAppRecovering
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|APP_REMOVED
case|:
block|{
name|AppRemovedSchedulerEvent
name|appRemovedEvent
init|=
operator|(
name|AppRemovedSchedulerEvent
operator|)
name|event
decl_stmt|;
name|doneApplication
argument_list|(
name|appRemovedEvent
operator|.
name|getApplicationID
argument_list|()
argument_list|,
name|appRemovedEvent
operator|.
name|getFinalState
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|APP_ATTEMPT_ADDED
case|:
block|{
name|AppAttemptAddedSchedulerEvent
name|appAttemptAddedEvent
init|=
operator|(
name|AppAttemptAddedSchedulerEvent
operator|)
name|event
decl_stmt|;
name|addApplicationAttempt
argument_list|(
name|appAttemptAddedEvent
operator|.
name|getApplicationAttemptId
argument_list|()
argument_list|,
name|appAttemptAddedEvent
operator|.
name|getTransferStateFromPreviousAttempt
argument_list|()
argument_list|,
name|appAttemptAddedEvent
operator|.
name|getIsAttemptRecovering
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|APP_ATTEMPT_REMOVED
case|:
block|{
name|AppAttemptRemovedSchedulerEvent
name|appAttemptRemovedEvent
init|=
operator|(
name|AppAttemptRemovedSchedulerEvent
operator|)
name|event
decl_stmt|;
name|doneApplicationAttempt
argument_list|(
name|appAttemptRemovedEvent
operator|.
name|getApplicationAttemptID
argument_list|()
argument_list|,
name|appAttemptRemovedEvent
operator|.
name|getFinalAttemptState
argument_list|()
argument_list|,
name|appAttemptRemovedEvent
operator|.
name|getKeepContainersAcrossAppAttempts
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONTAINER_EXPIRED
case|:
block|{
name|ContainerExpiredSchedulerEvent
name|containerExpiredEvent
init|=
operator|(
name|ContainerExpiredSchedulerEvent
operator|)
name|event
decl_stmt|;
name|ContainerId
name|containerId
init|=
name|containerExpiredEvent
operator|.
name|getContainerId
argument_list|()
decl_stmt|;
name|completedContainer
argument_list|(
name|getRMContainer
argument_list|(
name|containerId
argument_list|)
argument_list|,
name|SchedulerUtils
operator|.
name|createAbnormalContainerStatus
argument_list|(
name|containerId
argument_list|,
name|SchedulerUtils
operator|.
name|EXPIRED_CONTAINER
argument_list|)
argument_list|,
name|RMContainerEventType
operator|.
name|EXPIRE
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid eventtype "
operator|+
name|event
operator|.
name|getType
argument_list|()
operator|+
literal|". Ignoring!"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addNode (RMNode nodeManager)
specifier|private
specifier|synchronized
name|void
name|addNode
parameter_list|(
name|RMNode
name|nodeManager
parameter_list|)
block|{
name|FiCaSchedulerNode
name|schedulerNode
init|=
operator|new
name|FiCaSchedulerNode
argument_list|(
name|nodeManager
argument_list|,
name|usePortForNodeName
argument_list|,
name|nodeManager
operator|.
name|getNodeLabels
argument_list|()
argument_list|)
decl_stmt|;
name|this
operator|.
name|nodes
operator|.
name|put
argument_list|(
name|nodeManager
operator|.
name|getNodeID
argument_list|()
argument_list|,
name|schedulerNode
argument_list|)
expr_stmt|;
name|Resources
operator|.
name|addTo
argument_list|(
name|clusterResource
argument_list|,
name|nodeManager
operator|.
name|getTotalCapability
argument_list|()
argument_list|)
expr_stmt|;
comment|// update this node to node label manager
if|if
condition|(
name|labelManager
operator|!=
literal|null
condition|)
block|{
name|labelManager
operator|.
name|activateNode
argument_list|(
name|nodeManager
operator|.
name|getNodeID
argument_list|()
argument_list|,
name|nodeManager
operator|.
name|getTotalCapability
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|root
operator|.
name|updateClusterResource
argument_list|(
name|clusterResource
argument_list|,
operator|new
name|ResourceLimits
argument_list|(
name|clusterResource
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|numNodes
init|=
name|numNodeManagers
operator|.
name|incrementAndGet
argument_list|()
decl_stmt|;
name|updateMaximumAllocation
argument_list|(
name|schedulerNode
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Added node "
operator|+
name|nodeManager
operator|.
name|getNodeAddress
argument_list|()
operator|+
literal|" clusterResource: "
operator|+
name|clusterResource
argument_list|)
expr_stmt|;
if|if
condition|(
name|scheduleAsynchronously
operator|&&
name|numNodes
operator|==
literal|1
condition|)
block|{
name|asyncSchedulerThread
operator|.
name|beginSchedule
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|removeNode (RMNode nodeInfo)
specifier|private
specifier|synchronized
name|void
name|removeNode
parameter_list|(
name|RMNode
name|nodeInfo
parameter_list|)
block|{
comment|// update this node to node label manager
if|if
condition|(
name|labelManager
operator|!=
literal|null
condition|)
block|{
name|labelManager
operator|.
name|deactivateNode
argument_list|(
name|nodeInfo
operator|.
name|getNodeID
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|FiCaSchedulerNode
name|node
init|=
name|nodes
operator|.
name|get
argument_list|(
name|nodeInfo
operator|.
name|getNodeID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|Resources
operator|.
name|subtractFrom
argument_list|(
name|clusterResource
argument_list|,
name|node
operator|.
name|getRMNode
argument_list|()
operator|.
name|getTotalCapability
argument_list|()
argument_list|)
expr_stmt|;
name|root
operator|.
name|updateClusterResource
argument_list|(
name|clusterResource
argument_list|,
operator|new
name|ResourceLimits
argument_list|(
name|clusterResource
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|numNodes
init|=
name|numNodeManagers
operator|.
name|decrementAndGet
argument_list|()
decl_stmt|;
if|if
condition|(
name|scheduleAsynchronously
operator|&&
name|numNodes
operator|==
literal|0
condition|)
block|{
name|asyncSchedulerThread
operator|.
name|suspendSchedule
argument_list|()
expr_stmt|;
block|}
comment|// Remove running containers
name|List
argument_list|<
name|RMContainer
argument_list|>
name|runningContainers
init|=
name|node
operator|.
name|getRunningContainers
argument_list|()
decl_stmt|;
for|for
control|(
name|RMContainer
name|container
range|:
name|runningContainers
control|)
block|{
name|completedContainer
argument_list|(
name|container
argument_list|,
name|SchedulerUtils
operator|.
name|createAbnormalContainerStatus
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|SchedulerUtils
operator|.
name|LOST_CONTAINER
argument_list|)
argument_list|,
name|RMContainerEventType
operator|.
name|KILL
argument_list|)
expr_stmt|;
block|}
comment|// Remove reservations, if any
name|RMContainer
name|reservedContainer
init|=
name|node
operator|.
name|getReservedContainer
argument_list|()
decl_stmt|;
if|if
condition|(
name|reservedContainer
operator|!=
literal|null
condition|)
block|{
name|completedContainer
argument_list|(
name|reservedContainer
argument_list|,
name|SchedulerUtils
operator|.
name|createAbnormalContainerStatus
argument_list|(
name|reservedContainer
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|SchedulerUtils
operator|.
name|LOST_CONTAINER
argument_list|)
argument_list|,
name|RMContainerEventType
operator|.
name|KILL
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|nodes
operator|.
name|remove
argument_list|(
name|nodeInfo
operator|.
name|getNodeID
argument_list|()
argument_list|)
expr_stmt|;
name|updateMaximumAllocation
argument_list|(
name|node
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Removed node "
operator|+
name|nodeInfo
operator|.
name|getNodeAddress
argument_list|()
operator|+
literal|" clusterResource: "
operator|+
name|clusterResource
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Lock
argument_list|(
name|CapacityScheduler
operator|.
name|class
argument_list|)
annotation|@
name|Override
DECL|method|completedContainer (RMContainer rmContainer, ContainerStatus containerStatus, RMContainerEventType event)
specifier|protected
specifier|synchronized
name|void
name|completedContainer
parameter_list|(
name|RMContainer
name|rmContainer
parameter_list|,
name|ContainerStatus
name|containerStatus
parameter_list|,
name|RMContainerEventType
name|event
parameter_list|)
block|{
if|if
condition|(
name|rmContainer
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Container "
operator|+
name|containerStatus
operator|.
name|getContainerId
argument_list|()
operator|+
literal|" completed with event "
operator|+
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
name|Container
name|container
init|=
name|rmContainer
operator|.
name|getContainer
argument_list|()
decl_stmt|;
comment|// Get the application for the finished container
name|FiCaSchedulerApp
name|application
init|=
name|getCurrentAttemptForContainer
argument_list|(
name|container
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|ApplicationId
name|appId
init|=
name|container
operator|.
name|getId
argument_list|()
operator|.
name|getApplicationAttemptId
argument_list|()
operator|.
name|getApplicationId
argument_list|()
decl_stmt|;
if|if
condition|(
name|application
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Container "
operator|+
name|container
operator|+
literal|" of"
operator|+
literal|" finished application "
operator|+
name|appId
operator|+
literal|" completed with event "
operator|+
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Get the node on which the container was allocated
name|FiCaSchedulerNode
name|node
init|=
name|getNode
argument_list|(
name|container
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
comment|// Inform the queue
name|LeafQueue
name|queue
init|=
operator|(
name|LeafQueue
operator|)
name|application
operator|.
name|getQueue
argument_list|()
decl_stmt|;
name|queue
operator|.
name|completedContainer
argument_list|(
name|clusterResource
argument_list|,
name|application
argument_list|,
name|node
argument_list|,
name|rmContainer
argument_list|,
name|containerStatus
argument_list|,
name|event
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Application attempt "
operator|+
name|application
operator|.
name|getApplicationAttemptId
argument_list|()
operator|+
literal|" released container "
operator|+
name|container
operator|.
name|getId
argument_list|()
operator|+
literal|" on node: "
operator|+
name|node
operator|+
literal|" with event: "
operator|+
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|containerStatus
operator|.
name|getExitStatus
argument_list|()
operator|==
name|ContainerExitStatus
operator|.
name|PREEMPTED
condition|)
block|{
name|schedulerHealth
operator|.
name|updatePreemption
argument_list|(
name|Time
operator|.
name|now
argument_list|()
argument_list|,
name|container
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|container
operator|.
name|getId
argument_list|()
argument_list|,
name|queue
operator|.
name|getQueuePath
argument_list|()
argument_list|)
expr_stmt|;
name|schedulerHealth
operator|.
name|updateSchedulerPreemptionCounts
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|schedulerHealth
operator|.
name|updateRelease
argument_list|(
name|lastNodeUpdateTime
argument_list|,
name|container
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|container
operator|.
name|getId
argument_list|()
argument_list|,
name|queue
operator|.
name|getQueuePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Lock
argument_list|(
name|Lock
operator|.
name|NoLock
operator|.
name|class
argument_list|)
annotation|@
name|VisibleForTesting
annotation|@
name|Override
DECL|method|getApplicationAttempt ( ApplicationAttemptId applicationAttemptId)
specifier|public
name|FiCaSchedulerApp
name|getApplicationAttempt
parameter_list|(
name|ApplicationAttemptId
name|applicationAttemptId
parameter_list|)
block|{
return|return
name|super
operator|.
name|getApplicationAttempt
argument_list|(
name|applicationAttemptId
argument_list|)
return|;
block|}
annotation|@
name|Lock
argument_list|(
name|Lock
operator|.
name|NoLock
operator|.
name|class
argument_list|)
DECL|method|getNode (NodeId nodeId)
specifier|public
name|FiCaSchedulerNode
name|getNode
parameter_list|(
name|NodeId
name|nodeId
parameter_list|)
block|{
return|return
name|nodes
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
return|;
block|}
annotation|@
name|Lock
argument_list|(
name|Lock
operator|.
name|NoLock
operator|.
name|class
argument_list|)
DECL|method|getAllNodes ()
name|Map
argument_list|<
name|NodeId
argument_list|,
name|FiCaSchedulerNode
argument_list|>
name|getAllNodes
parameter_list|()
block|{
return|return
name|nodes
return|;
block|}
annotation|@
name|Override
annotation|@
name|Lock
argument_list|(
name|Lock
operator|.
name|NoLock
operator|.
name|class
argument_list|)
DECL|method|recover (RMState state)
specifier|public
name|void
name|recover
parameter_list|(
name|RMState
name|state
parameter_list|)
throws|throws
name|Exception
block|{
comment|// NOT IMPLEMENTED
block|}
annotation|@
name|Override
DECL|method|dropContainerReservation (RMContainer container)
specifier|public
name|void
name|dropContainerReservation
parameter_list|(
name|RMContainer
name|container
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"DROP_RESERVATION:"
operator|+
name|container
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|completedContainer
argument_list|(
name|container
argument_list|,
name|SchedulerUtils
operator|.
name|createAbnormalContainerStatus
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|SchedulerUtils
operator|.
name|UNRESERVED_CONTAINER
argument_list|)
argument_list|,
name|RMContainerEventType
operator|.
name|KILL
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|preemptContainer (ApplicationAttemptId aid, RMContainer cont)
specifier|public
name|void
name|preemptContainer
parameter_list|(
name|ApplicationAttemptId
name|aid
parameter_list|,
name|RMContainer
name|cont
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"PREEMPT_CONTAINER: application:"
operator|+
name|aid
operator|.
name|toString
argument_list|()
operator|+
literal|" container: "
operator|+
name|cont
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|FiCaSchedulerApp
name|app
init|=
name|getApplicationAttempt
argument_list|(
name|aid
argument_list|)
decl_stmt|;
if|if
condition|(
name|app
operator|!=
literal|null
condition|)
block|{
name|app
operator|.
name|addPreemptContainer
argument_list|(
name|cont
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|killContainer (RMContainer cont)
specifier|public
name|void
name|killContainer
parameter_list|(
name|RMContainer
name|cont
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"KILL_CONTAINER: container"
operator|+
name|cont
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|recoverResourceRequestForContainer
argument_list|(
name|cont
argument_list|)
expr_stmt|;
name|completedContainer
argument_list|(
name|cont
argument_list|,
name|SchedulerUtils
operator|.
name|createPreemptedContainerStatus
argument_list|(
name|cont
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|SchedulerUtils
operator|.
name|PREEMPTED_CONTAINER
argument_list|)
argument_list|,
name|RMContainerEventType
operator|.
name|KILL
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|checkAccess (UserGroupInformation callerUGI, QueueACL acl, String queueName)
specifier|public
specifier|synchronized
name|boolean
name|checkAccess
parameter_list|(
name|UserGroupInformation
name|callerUGI
parameter_list|,
name|QueueACL
name|acl
parameter_list|,
name|String
name|queueName
parameter_list|)
block|{
name|CSQueue
name|queue
init|=
name|getQueue
argument_list|(
name|queueName
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ACL not found for queue access-type "
operator|+
name|acl
operator|+
literal|" for queue "
operator|+
name|queueName
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
return|return
name|queue
operator|.
name|hasAccess
argument_list|(
name|acl
argument_list|,
name|callerUGI
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getAppsInQueue (String queueName)
specifier|public
name|List
argument_list|<
name|ApplicationAttemptId
argument_list|>
name|getAppsInQueue
parameter_list|(
name|String
name|queueName
parameter_list|)
block|{
name|CSQueue
name|queue
init|=
name|queues
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|ApplicationAttemptId
argument_list|>
name|apps
init|=
operator|new
name|ArrayList
argument_list|<
name|ApplicationAttemptId
argument_list|>
argument_list|()
decl_stmt|;
name|queue
operator|.
name|collectSchedulerApplications
argument_list|(
name|apps
argument_list|)
expr_stmt|;
return|return
name|apps
return|;
block|}
DECL|method|loadCapacitySchedulerConfiguration ( Configuration configuration)
specifier|private
name|CapacitySchedulerConfiguration
name|loadCapacitySchedulerConfiguration
parameter_list|(
name|Configuration
name|configuration
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|InputStream
name|CSInputStream
init|=
name|this
operator|.
name|rmContext
operator|.
name|getConfigurationProvider
argument_list|()
operator|.
name|getConfigurationInputStream
argument_list|(
name|configuration
argument_list|,
name|YarnConfiguration
operator|.
name|CS_CONFIGURATION_FILE
argument_list|)
decl_stmt|;
if|if
condition|(
name|CSInputStream
operator|!=
literal|null
condition|)
block|{
name|configuration
operator|.
name|addResource
argument_list|(
name|CSInputStream
argument_list|)
expr_stmt|;
return|return
operator|new
name|CapacitySchedulerConfiguration
argument_list|(
name|configuration
argument_list|,
literal|false
argument_list|)
return|;
block|}
return|return
operator|new
name|CapacitySchedulerConfiguration
argument_list|(
name|configuration
argument_list|,
literal|true
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|resolveReservationQueueName (String queueName, ApplicationId applicationId, ReservationId reservationID)
specifier|private
specifier|synchronized
name|String
name|resolveReservationQueueName
parameter_list|(
name|String
name|queueName
parameter_list|,
name|ApplicationId
name|applicationId
parameter_list|,
name|ReservationId
name|reservationID
parameter_list|)
block|{
name|CSQueue
name|queue
init|=
name|getQueue
argument_list|(
name|queueName
argument_list|)
decl_stmt|;
comment|// Check if the queue is a plan queue
if|if
condition|(
operator|(
name|queue
operator|==
literal|null
operator|)
operator|||
operator|!
operator|(
name|queue
operator|instanceof
name|PlanQueue
operator|)
condition|)
block|{
return|return
name|queueName
return|;
block|}
if|if
condition|(
name|reservationID
operator|!=
literal|null
condition|)
block|{
name|String
name|resQName
init|=
name|reservationID
operator|.
name|toString
argument_list|()
decl_stmt|;
name|queue
operator|=
name|getQueue
argument_list|(
name|resQName
argument_list|)
expr_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
block|{
name|String
name|message
init|=
literal|"Application "
operator|+
name|applicationId
operator|+
literal|" submitted to a reservation which is not yet currently active: "
operator|+
name|resQName
decl_stmt|;
name|this
operator|.
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMAppRejectedEvent
argument_list|(
name|applicationId
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|queue
operator|.
name|getParent
argument_list|()
operator|.
name|getQueueName
argument_list|()
operator|.
name|equals
argument_list|(
name|queueName
argument_list|)
condition|)
block|{
name|String
name|message
init|=
literal|"Application: "
operator|+
name|applicationId
operator|+
literal|" submitted to a reservation "
operator|+
name|resQName
operator|+
literal|" which does not belong to the specified queue: "
operator|+
name|queueName
decl_stmt|;
name|this
operator|.
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMAppRejectedEvent
argument_list|(
name|applicationId
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// use the reservation queue to run the app
name|queueName
operator|=
name|resQName
expr_stmt|;
block|}
else|else
block|{
comment|// use the default child queue of the plan for unreserved apps
name|queueName
operator|=
name|queueName
operator|+
name|ReservationConstants
operator|.
name|DEFAULT_QUEUE_SUFFIX
expr_stmt|;
block|}
return|return
name|queueName
return|;
block|}
annotation|@
name|Override
DECL|method|removeQueue (String queueName)
specifier|public
specifier|synchronized
name|void
name|removeQueue
parameter_list|(
name|String
name|queueName
parameter_list|)
throws|throws
name|SchedulerDynamicEditException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing queue: "
operator|+
name|queueName
argument_list|)
expr_stmt|;
name|CSQueue
name|q
init|=
name|this
operator|.
name|getQueue
argument_list|(
name|queueName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|q
operator|instanceof
name|ReservationQueue
operator|)
condition|)
block|{
throw|throw
operator|new
name|SchedulerDynamicEditException
argument_list|(
literal|"The queue that we are asked "
operator|+
literal|"to remove ("
operator|+
name|queueName
operator|+
literal|") is not a ReservationQueue"
argument_list|)
throw|;
block|}
name|ReservationQueue
name|disposableLeafQueue
init|=
operator|(
name|ReservationQueue
operator|)
name|q
decl_stmt|;
comment|// at this point we should have no more apps
if|if
condition|(
name|disposableLeafQueue
operator|.
name|getNumApplications
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|SchedulerDynamicEditException
argument_list|(
literal|"The queue "
operator|+
name|queueName
operator|+
literal|" is not empty "
operator|+
name|disposableLeafQueue
operator|.
name|getApplications
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|" active apps "
operator|+
name|disposableLeafQueue
operator|.
name|pendingApplications
operator|.
name|size
argument_list|()
operator|+
literal|" pending apps"
argument_list|)
throw|;
block|}
operator|(
operator|(
name|PlanQueue
operator|)
name|disposableLeafQueue
operator|.
name|getParent
argument_list|()
operator|)
operator|.
name|removeChildQueue
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|this
operator|.
name|queues
operator|.
name|remove
argument_list|(
name|queueName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Removal of ReservationQueue "
operator|+
name|queueName
operator|+
literal|" has succeeded"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|addQueue (Queue queue)
specifier|public
specifier|synchronized
name|void
name|addQueue
parameter_list|(
name|Queue
name|queue
parameter_list|)
throws|throws
name|SchedulerDynamicEditException
block|{
if|if
condition|(
operator|!
operator|(
name|queue
operator|instanceof
name|ReservationQueue
operator|)
condition|)
block|{
throw|throw
operator|new
name|SchedulerDynamicEditException
argument_list|(
literal|"Queue "
operator|+
name|queue
operator|.
name|getQueueName
argument_list|()
operator|+
literal|" is not a ReservationQueue"
argument_list|)
throw|;
block|}
name|ReservationQueue
name|newQueue
init|=
operator|(
name|ReservationQueue
operator|)
name|queue
decl_stmt|;
if|if
condition|(
name|newQueue
operator|.
name|getParent
argument_list|()
operator|==
literal|null
operator|||
operator|!
operator|(
name|newQueue
operator|.
name|getParent
argument_list|()
operator|instanceof
name|PlanQueue
operator|)
condition|)
block|{
throw|throw
operator|new
name|SchedulerDynamicEditException
argument_list|(
literal|"ParentQueue for "
operator|+
name|newQueue
operator|.
name|getQueueName
argument_list|()
operator|+
literal|" is not properly set (should be set and be a PlanQueue)"
argument_list|)
throw|;
block|}
name|PlanQueue
name|parentPlan
init|=
operator|(
name|PlanQueue
operator|)
name|newQueue
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|String
name|queuename
init|=
name|newQueue
operator|.
name|getQueueName
argument_list|()
decl_stmt|;
name|parentPlan
operator|.
name|addChildQueue
argument_list|(
name|newQueue
argument_list|)
expr_stmt|;
name|this
operator|.
name|queues
operator|.
name|put
argument_list|(
name|queuename
argument_list|,
name|newQueue
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Creation of ReservationQueue "
operator|+
name|newQueue
operator|+
literal|" succeeded"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setEntitlement (String inQueue, QueueEntitlement entitlement)
specifier|public
specifier|synchronized
name|void
name|setEntitlement
parameter_list|(
name|String
name|inQueue
parameter_list|,
name|QueueEntitlement
name|entitlement
parameter_list|)
throws|throws
name|SchedulerDynamicEditException
throws|,
name|YarnException
block|{
name|LeafQueue
name|queue
init|=
name|getAndCheckLeafQueue
argument_list|(
name|inQueue
argument_list|)
decl_stmt|;
name|ParentQueue
name|parent
init|=
operator|(
name|ParentQueue
operator|)
name|queue
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|queue
operator|instanceof
name|ReservationQueue
operator|)
condition|)
block|{
throw|throw
operator|new
name|SchedulerDynamicEditException
argument_list|(
literal|"Entitlement can not be"
operator|+
literal|" modified dynamically since queue "
operator|+
name|inQueue
operator|+
literal|" is not a ReservationQueue"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
operator|(
name|parent
operator|instanceof
name|PlanQueue
operator|)
condition|)
block|{
throw|throw
operator|new
name|SchedulerDynamicEditException
argument_list|(
literal|"The parent of ReservationQueue "
operator|+
name|inQueue
operator|+
literal|" must be an PlanQueue"
argument_list|)
throw|;
block|}
name|ReservationQueue
name|newQueue
init|=
operator|(
name|ReservationQueue
operator|)
name|queue
decl_stmt|;
name|float
name|sumChilds
init|=
operator|(
operator|(
name|PlanQueue
operator|)
name|parent
operator|)
operator|.
name|sumOfChildCapacities
argument_list|()
decl_stmt|;
name|float
name|newChildCap
init|=
name|sumChilds
operator|-
name|queue
operator|.
name|getCapacity
argument_list|()
operator|+
name|entitlement
operator|.
name|getCapacity
argument_list|()
decl_stmt|;
if|if
condition|(
name|newChildCap
operator|>=
literal|0
operator|&&
name|newChildCap
operator|<
literal|1.0f
operator|+
name|CSQueueUtils
operator|.
name|EPSILON
condition|)
block|{
comment|// note: epsilon checks here are not ok, as the epsilons might accumulate
comment|// and become a problem in aggregate
if|if
condition|(
name|Math
operator|.
name|abs
argument_list|(
name|entitlement
operator|.
name|getCapacity
argument_list|()
operator|-
name|queue
operator|.
name|getCapacity
argument_list|()
argument_list|)
operator|==
literal|0
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|entitlement
operator|.
name|getMaxCapacity
argument_list|()
operator|-
name|queue
operator|.
name|getMaximumCapacity
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|newQueue
operator|.
name|setEntitlement
argument_list|(
name|entitlement
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SchedulerDynamicEditException
argument_list|(
literal|"Sum of child queues would exceed 100% for PlanQueue: "
operator|+
name|parent
operator|.
name|getQueueName
argument_list|()
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Set entitlement for ReservationQueue "
operator|+
name|inQueue
operator|+
literal|"  to "
operator|+
name|queue
operator|.
name|getCapacity
argument_list|()
operator|+
literal|" request was ("
operator|+
name|entitlement
operator|.
name|getCapacity
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|moveApplication (ApplicationId appId, String targetQueueName)
specifier|public
specifier|synchronized
name|String
name|moveApplication
parameter_list|(
name|ApplicationId
name|appId
parameter_list|,
name|String
name|targetQueueName
parameter_list|)
throws|throws
name|YarnException
block|{
name|FiCaSchedulerApp
name|app
init|=
name|getApplicationAttempt
argument_list|(
name|ApplicationAttemptId
operator|.
name|newInstance
argument_list|(
name|appId
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|sourceQueueName
init|=
name|app
operator|.
name|getQueue
argument_list|()
operator|.
name|getQueueName
argument_list|()
decl_stmt|;
name|LeafQueue
name|source
init|=
name|getAndCheckLeafQueue
argument_list|(
name|sourceQueueName
argument_list|)
decl_stmt|;
name|String
name|destQueueName
init|=
name|handleMoveToPlanQueue
argument_list|(
name|targetQueueName
argument_list|)
decl_stmt|;
name|LeafQueue
name|dest
init|=
name|getAndCheckLeafQueue
argument_list|(
name|destQueueName
argument_list|)
decl_stmt|;
comment|// Validation check - ACLs, submission limits for user& queue
name|String
name|user
init|=
name|app
operator|.
name|getUser
argument_list|()
decl_stmt|;
try|try
block|{
name|dest
operator|.
name|submitApplication
argument_list|(
name|appId
argument_list|,
name|user
argument_list|,
name|destQueueName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YarnException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// Move all live containers
for|for
control|(
name|RMContainer
name|rmContainer
range|:
name|app
operator|.
name|getLiveContainers
argument_list|()
control|)
block|{
name|source
operator|.
name|detachContainer
argument_list|(
name|clusterResource
argument_list|,
name|app
argument_list|,
name|rmContainer
argument_list|)
expr_stmt|;
comment|// attach the Container to another queue
name|dest
operator|.
name|attachContainer
argument_list|(
name|clusterResource
argument_list|,
name|app
argument_list|,
name|rmContainer
argument_list|)
expr_stmt|;
block|}
comment|// Detach the application..
name|source
operator|.
name|finishApplicationAttempt
argument_list|(
name|app
argument_list|,
name|sourceQueueName
argument_list|)
expr_stmt|;
name|source
operator|.
name|getParent
argument_list|()
operator|.
name|finishApplication
argument_list|(
name|appId
argument_list|,
name|app
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
comment|// Finish app& update metrics
name|app
operator|.
name|move
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|// Submit to a new queue
name|dest
operator|.
name|submitApplicationAttempt
argument_list|(
name|app
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|applications
operator|.
name|get
argument_list|(
name|appId
argument_list|)
operator|.
name|setQueue
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"App: "
operator|+
name|app
operator|.
name|getApplicationId
argument_list|()
operator|+
literal|" successfully moved from "
operator|+
name|sourceQueueName
operator|+
literal|" to: "
operator|+
name|destQueueName
argument_list|)
expr_stmt|;
return|return
name|targetQueueName
return|;
block|}
comment|/**    * Check that the String provided in input is the name of an existing,    * LeafQueue, if successful returns the queue.    *    * @param queue    * @return the LeafQueue    * @throws YarnException    */
DECL|method|getAndCheckLeafQueue (String queue)
specifier|private
name|LeafQueue
name|getAndCheckLeafQueue
parameter_list|(
name|String
name|queue
parameter_list|)
throws|throws
name|YarnException
block|{
name|CSQueue
name|ret
init|=
name|this
operator|.
name|getQueue
argument_list|(
name|queue
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|YarnException
argument_list|(
literal|"The specified Queue: "
operator|+
name|queue
operator|+
literal|" doesn't exist"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
operator|(
name|ret
operator|instanceof
name|LeafQueue
operator|)
condition|)
block|{
throw|throw
operator|new
name|YarnException
argument_list|(
literal|"The specified Queue: "
operator|+
name|queue
operator|+
literal|" is not a Leaf Queue. Move is supported only for Leaf Queues."
argument_list|)
throw|;
block|}
return|return
operator|(
name|LeafQueue
operator|)
name|ret
return|;
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
DECL|method|getSchedulingResourceTypes ()
specifier|public
name|EnumSet
argument_list|<
name|SchedulerResourceTypes
argument_list|>
name|getSchedulingResourceTypes
parameter_list|()
block|{
if|if
condition|(
name|calculator
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|DefaultResourceCalculator
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|EnumSet
operator|.
name|of
argument_list|(
name|SchedulerResourceTypes
operator|.
name|MEMORY
argument_list|)
return|;
block|}
return|return
name|EnumSet
operator|.
name|of
argument_list|(
name|SchedulerResourceTypes
operator|.
name|MEMORY
argument_list|,
name|SchedulerResourceTypes
operator|.
name|CPU
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getMaximumResourceCapability (String queueName)
specifier|public
name|Resource
name|getMaximumResourceCapability
parameter_list|(
name|String
name|queueName
parameter_list|)
block|{
name|CSQueue
name|queue
init|=
name|getQueue
argument_list|(
name|queueName
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unknown queue: "
operator|+
name|queueName
argument_list|)
expr_stmt|;
return|return
name|getMaximumResourceCapability
argument_list|()
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|queue
operator|instanceof
name|LeafQueue
operator|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"queue "
operator|+
name|queueName
operator|+
literal|" is not an leaf queue"
argument_list|)
expr_stmt|;
return|return
name|getMaximumResourceCapability
argument_list|()
return|;
block|}
return|return
operator|(
operator|(
name|LeafQueue
operator|)
name|queue
operator|)
operator|.
name|getMaximumAllocation
argument_list|()
return|;
block|}
DECL|method|handleMoveToPlanQueue (String targetQueueName)
specifier|private
name|String
name|handleMoveToPlanQueue
parameter_list|(
name|String
name|targetQueueName
parameter_list|)
block|{
name|CSQueue
name|dest
init|=
name|getQueue
argument_list|(
name|targetQueueName
argument_list|)
decl_stmt|;
if|if
condition|(
name|dest
operator|!=
literal|null
operator|&&
name|dest
operator|instanceof
name|PlanQueue
condition|)
block|{
comment|// use the default child reservation queue of the plan
name|targetQueueName
operator|=
name|targetQueueName
operator|+
name|ReservationConstants
operator|.
name|DEFAULT_QUEUE_SUFFIX
expr_stmt|;
block|}
return|return
name|targetQueueName
return|;
block|}
annotation|@
name|Override
DECL|method|getPlanQueues ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getPlanQueues
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|ret
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|l
range|:
name|queues
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|l
operator|.
name|getValue
argument_list|()
operator|instanceof
name|PlanQueue
condition|)
block|{
name|ret
operator|.
name|add
argument_list|(
name|l
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
DECL|method|getSchedulerHealth ()
specifier|public
name|SchedulerHealth
name|getSchedulerHealth
parameter_list|()
block|{
return|return
name|this
operator|.
name|schedulerHealth
return|;
block|}
DECL|method|setLastNodeUpdateTime (long time)
specifier|private
specifier|synchronized
name|void
name|setLastNodeUpdateTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
name|this
operator|.
name|lastNodeUpdateTime
operator|=
name|time
expr_stmt|;
block|}
block|}
end_class

end_unit

