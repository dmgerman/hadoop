begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|time
operator|.
name|DateUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|LimitedPrivate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
operator|.
name|Evolving
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configurable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationAttemptId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Container
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerExitStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ExecutionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|NodeId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Priority
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueUserACLInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ReservationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ResourceOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ResourceRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ResourceSizing
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|SchedulingRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnRuntimeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|proto
operator|.
name|YarnServiceProtos
operator|.
name|SchedulerResourceTypes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|RMContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|nodelabels
operator|.
name|RMNodeLabelsManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|placement
operator|.
name|AppNameMappingPlacementRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|placement
operator|.
name|ApplicationPlacementContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|placement
operator|.
name|PlacementFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|placement
operator|.
name|PlacementRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|placement
operator|.
name|UserGroupMappingPlacementRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|recovery
operator|.
name|RMStateStore
operator|.
name|RMState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|recovery
operator|.
name|records
operator|.
name|ApplicationStateData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|reservation
operator|.
name|ReservationConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|RMApp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|RMAppEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|RMAppEventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|RMAppState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|attempt
operator|.
name|RMAppAttemptEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|attempt
operator|.
name|RMAppAttemptEventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|attempt
operator|.
name|RMAppAttemptState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainerEventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainerImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainerState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmnode
operator|.
name|RMNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|AbstractYarnScheduler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|Allocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|AppSchedulingInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|ContainerUpdates
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|MutableConfScheduler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|MutableConfigurationProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|NodeType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|PreemptableResourceScheduler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|QueueInvalidException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|QueueMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|ResourceLimits
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|ResourceUsage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|SchedulerApplication
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|SchedulerApplicationAttempt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|SchedulerDynamicEditException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|SchedulerNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|SchedulerUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|activities
operator|.
name|ActivitiesLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|activities
operator|.
name|ActivitiesManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|activities
operator|.
name|ActivityDiagnosticConstant
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|activities
operator|.
name|ActivityState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|activities
operator|.
name|AllocationState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|conf
operator|.
name|CSConfigurationProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|conf
operator|.
name|FileBasedCSConfigurationProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|conf
operator|.
name|MutableCSConfigurationProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|preemption
operator|.
name|KillableContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|preemption
operator|.
name|PreemptionManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|AssignmentInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|ContainerAllocationProposal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|QueueEntitlement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|ResourceAllocationCommitter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|ResourceCommitRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|SchedulerContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|fica
operator|.
name|FiCaSchedulerApp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|fica
operator|.
name|FiCaSchedulerNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|constraint
operator|.
name|InvalidAllocationTagsQueryException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|constraint
operator|.
name|PlacementConstraintsUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|AppAddedSchedulerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|AppAttemptAddedSchedulerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|AppAttemptRemovedSchedulerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|AppRemovedSchedulerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|ContainerExpiredSchedulerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|ContainerPreemptEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|NodeAddedSchedulerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|NodeLabelsUpdateSchedulerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|NodeRemovedSchedulerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|NodeResourceUpdateSchedulerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|NodeUpdateSchedulerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|QueueManagementChangeEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|ReleaseContainerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|SchedulerEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|SchedulerEventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|placement
operator|.
name|CandidateNodeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|placement
operator|.
name|CandidateNodeSetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|placement
operator|.
name|SimpleCandidateNodeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|security
operator|.
name|AppPriorityACLsManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|security
operator|.
name|RMContainerTokenSecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|scheduler
operator|.
name|SchedulerRequestKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|utils
operator|.
name|BuilderUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|utils
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|DefaultResourceCalculator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|ResourceCalculator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|ResourceUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|Resources
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|SettableFuture
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|CapacitySchedulerConfiguration
operator|.
name|QUEUE_MAPPING
import|;
end_import

begin_class
annotation|@
name|LimitedPrivate
argument_list|(
literal|"yarn"
argument_list|)
annotation|@
name|Evolving
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|class|CapacityScheduler
specifier|public
class|class
name|CapacityScheduler
extends|extends
name|AbstractYarnScheduler
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
implements|implements
name|PreemptableResourceScheduler
implements|,
name|CapacitySchedulerContext
implements|,
name|Configurable
implements|,
name|ResourceAllocationCommitter
implements|,
name|MutableConfScheduler
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|CapacityScheduler
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|queueManager
specifier|private
name|CapacitySchedulerQueueManager
name|queueManager
decl_stmt|;
comment|// timeout to join when we stop this service
DECL|field|THREAD_JOIN_TIMEOUT_MS
specifier|protected
specifier|final
name|long
name|THREAD_JOIN_TIMEOUT_MS
init|=
literal|1000
decl_stmt|;
DECL|field|preemptionManager
specifier|private
name|PreemptionManager
name|preemptionManager
init|=
operator|new
name|PreemptionManager
argument_list|()
decl_stmt|;
DECL|field|isLazyPreemptionEnabled
specifier|private
specifier|volatile
name|boolean
name|isLazyPreemptionEnabled
init|=
literal|false
decl_stmt|;
DECL|field|offswitchPerHeartbeatLimit
specifier|private
name|int
name|offswitchPerHeartbeatLimit
decl_stmt|;
DECL|field|assignMultipleEnabled
specifier|private
name|boolean
name|assignMultipleEnabled
decl_stmt|;
DECL|field|maxAssignPerHeartbeat
specifier|private
name|int
name|maxAssignPerHeartbeat
decl_stmt|;
DECL|field|csConfProvider
specifier|private
name|CSConfigurationProvider
name|csConfProvider
decl_stmt|;
annotation|@
name|Override
DECL|method|setConf (Configuration conf)
specifier|public
name|void
name|setConf
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|yarnConf
operator|=
name|conf
expr_stmt|;
block|}
DECL|method|validateConf (Configuration conf)
specifier|private
name|void
name|validateConf
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
comment|// validate scheduler memory allocation setting
name|int
name|minMem
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_MINIMUM_ALLOCATION_MB
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_RM_SCHEDULER_MINIMUM_ALLOCATION_MB
argument_list|)
decl_stmt|;
name|int
name|maxMem
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_MAXIMUM_ALLOCATION_MB
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_RM_SCHEDULER_MAXIMUM_ALLOCATION_MB
argument_list|)
decl_stmt|;
if|if
condition|(
name|minMem
operator|<=
literal|0
operator|||
name|minMem
operator|>
name|maxMem
condition|)
block|{
throw|throw
operator|new
name|YarnRuntimeException
argument_list|(
literal|"Invalid resource scheduler memory"
operator|+
literal|" allocation configuration"
operator|+
literal|", "
operator|+
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_MINIMUM_ALLOCATION_MB
operator|+
literal|"="
operator|+
name|minMem
operator|+
literal|", "
operator|+
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_MAXIMUM_ALLOCATION_MB
operator|+
literal|"="
operator|+
name|maxMem
operator|+
literal|", min and max should be greater than 0"
operator|+
literal|", max should be no smaller than min."
argument_list|)
throw|;
block|}
comment|// validate scheduler vcores allocation setting
name|int
name|minVcores
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_MINIMUM_ALLOCATION_VCORES
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_RM_SCHEDULER_MINIMUM_ALLOCATION_VCORES
argument_list|)
decl_stmt|;
name|int
name|maxVcores
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_MAXIMUM_ALLOCATION_VCORES
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_RM_SCHEDULER_MAXIMUM_ALLOCATION_VCORES
argument_list|)
decl_stmt|;
if|if
condition|(
name|minVcores
operator|<=
literal|0
operator|||
name|minVcores
operator|>
name|maxVcores
condition|)
block|{
throw|throw
operator|new
name|YarnRuntimeException
argument_list|(
literal|"Invalid resource scheduler vcores"
operator|+
literal|" allocation configuration"
operator|+
literal|", "
operator|+
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_MINIMUM_ALLOCATION_VCORES
operator|+
literal|"="
operator|+
name|minVcores
operator|+
literal|", "
operator|+
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_MAXIMUM_ALLOCATION_VCORES
operator|+
literal|"="
operator|+
name|maxVcores
operator|+
literal|", min and max should be greater than 0"
operator|+
literal|", max should be no smaller than min."
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|getConf ()
specifier|public
name|Configuration
name|getConf
parameter_list|()
block|{
return|return
name|yarnConf
return|;
block|}
DECL|field|conf
specifier|private
name|CapacitySchedulerConfiguration
name|conf
decl_stmt|;
DECL|field|yarnConf
specifier|private
name|Configuration
name|yarnConf
decl_stmt|;
DECL|field|calculator
specifier|private
name|ResourceCalculator
name|calculator
decl_stmt|;
DECL|field|usePortForNodeName
specifier|private
name|boolean
name|usePortForNodeName
decl_stmt|;
DECL|field|scheduleAsynchronously
specifier|private
name|boolean
name|scheduleAsynchronously
decl_stmt|;
DECL|field|asyncSchedulerThreads
specifier|private
name|List
argument_list|<
name|AsyncScheduleThread
argument_list|>
name|asyncSchedulerThreads
decl_stmt|;
DECL|field|resourceCommitterService
specifier|private
name|ResourceCommitterService
name|resourceCommitterService
decl_stmt|;
DECL|field|labelManager
specifier|private
name|RMNodeLabelsManager
name|labelManager
decl_stmt|;
DECL|field|appPriorityACLManager
specifier|private
name|AppPriorityACLsManager
name|appPriorityACLManager
decl_stmt|;
DECL|field|printedVerboseLoggingForAsyncScheduling
specifier|private
specifier|static
name|boolean
name|printedVerboseLoggingForAsyncScheduling
init|=
literal|false
decl_stmt|;
comment|/**    * EXPERT    */
DECL|field|asyncScheduleInterval
specifier|private
name|long
name|asyncScheduleInterval
decl_stmt|;
DECL|field|ASYNC_SCHEDULER_INTERVAL
specifier|private
specifier|static
specifier|final
name|String
name|ASYNC_SCHEDULER_INTERVAL
init|=
name|CapacitySchedulerConfiguration
operator|.
name|SCHEDULE_ASYNCHRONOUSLY_PREFIX
operator|+
literal|".scheduling-interval-ms"
decl_stmt|;
DECL|field|DEFAULT_ASYNC_SCHEDULER_INTERVAL
specifier|private
specifier|static
specifier|final
name|long
name|DEFAULT_ASYNC_SCHEDULER_INTERVAL
init|=
literal|5
decl_stmt|;
DECL|field|asyncMaxPendingBacklogs
specifier|private
name|long
name|asyncMaxPendingBacklogs
decl_stmt|;
DECL|method|CapacityScheduler ()
specifier|public
name|CapacityScheduler
parameter_list|()
block|{
name|super
argument_list|(
name|CapacityScheduler
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getRootQueueMetrics ()
specifier|public
name|QueueMetrics
name|getRootQueueMetrics
parameter_list|()
block|{
return|return
name|getRootQueue
argument_list|()
operator|.
name|getMetrics
argument_list|()
return|;
block|}
DECL|method|getRootQueue ()
specifier|public
name|CSQueue
name|getRootQueue
parameter_list|()
block|{
return|return
name|queueManager
operator|.
name|getRootQueue
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getConfiguration ()
specifier|public
name|CapacitySchedulerConfiguration
name|getConfiguration
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
annotation|@
name|Override
DECL|method|getContainerTokenSecretManager ()
specifier|public
name|RMContainerTokenSecretManager
name|getContainerTokenSecretManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|rmContext
operator|.
name|getContainerTokenSecretManager
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getResourceCalculator ()
specifier|public
name|ResourceCalculator
name|getResourceCalculator
parameter_list|()
block|{
return|return
name|calculator
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setResourceCalculator (ResourceCalculator rc)
specifier|public
name|void
name|setResourceCalculator
parameter_list|(
name|ResourceCalculator
name|rc
parameter_list|)
block|{
name|this
operator|.
name|calculator
operator|=
name|rc
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getNumClusterNodes ()
specifier|public
name|int
name|getNumClusterNodes
parameter_list|()
block|{
return|return
name|nodeTracker
operator|.
name|nodeCount
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getRMContext ()
specifier|public
name|RMContext
name|getRMContext
parameter_list|()
block|{
return|return
name|this
operator|.
name|rmContext
return|;
block|}
annotation|@
name|Override
DECL|method|setRMContext (RMContext rmContext)
specifier|public
name|void
name|setRMContext
parameter_list|(
name|RMContext
name|rmContext
parameter_list|)
block|{
name|this
operator|.
name|rmContext
operator|=
name|rmContext
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|initScheduler (Configuration configuration)
name|void
name|initScheduler
parameter_list|(
name|Configuration
name|configuration
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|String
name|confProviderStr
init|=
name|configuration
operator|.
name|get
argument_list|(
name|YarnConfiguration
operator|.
name|SCHEDULER_CONFIGURATION_STORE_CLASS
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_CONFIGURATION_STORE
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|confProviderStr
condition|)
block|{
case|case
name|YarnConfiguration
operator|.
name|FILE_CONFIGURATION_STORE
case|:
name|this
operator|.
name|csConfProvider
operator|=
operator|new
name|FileBasedCSConfigurationProvider
argument_list|(
name|rmContext
argument_list|)
expr_stmt|;
break|break;
case|case
name|YarnConfiguration
operator|.
name|MEMORY_CONFIGURATION_STORE
case|:
case|case
name|YarnConfiguration
operator|.
name|LEVELDB_CONFIGURATION_STORE
case|:
case|case
name|YarnConfiguration
operator|.
name|ZK_CONFIGURATION_STORE
case|:
case|case
name|YarnConfiguration
operator|.
name|FS_CONFIGURATION_STORE
case|:
name|this
operator|.
name|csConfProvider
operator|=
operator|new
name|MutableCSConfigurationProvider
argument_list|(
name|rmContext
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid configuration store class: "
operator|+
name|confProviderStr
argument_list|)
throw|;
block|}
name|this
operator|.
name|csConfProvider
operator|.
name|init
argument_list|(
name|configuration
argument_list|)
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|this
operator|.
name|csConfProvider
operator|.
name|loadConfiguration
argument_list|(
name|configuration
argument_list|)
expr_stmt|;
name|validateConf
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|minimumAllocation
operator|=
name|super
operator|.
name|getMinimumAllocation
argument_list|()
expr_stmt|;
name|initMaximumResourceCapability
argument_list|(
name|super
operator|.
name|getMaximumAllocation
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|calculator
operator|=
name|this
operator|.
name|conf
operator|.
name|getResourceCalculator
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|calculator
operator|instanceof
name|DefaultResourceCalculator
operator|&&
name|ResourceUtils
operator|.
name|getNumberOfKnownResourceTypes
argument_list|()
operator|>
literal|2
condition|)
block|{
throw|throw
operator|new
name|YarnRuntimeException
argument_list|(
literal|"RM uses DefaultResourceCalculator which"
operator|+
literal|" used only memory as resource-type but invalid resource-types"
operator|+
literal|" specified "
operator|+
name|ResourceUtils
operator|.
name|getResourceTypes
argument_list|()
operator|+
literal|". Use"
operator|+
literal|" DomainantResourceCalculator instead to make effective use of"
operator|+
literal|" these resource-types"
argument_list|)
throw|;
block|}
name|this
operator|.
name|usePortForNodeName
operator|=
name|this
operator|.
name|conf
operator|.
name|getUsePortForNodeName
argument_list|()
expr_stmt|;
name|this
operator|.
name|applications
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|labelManager
operator|=
name|rmContext
operator|.
name|getNodeLabelManager
argument_list|()
expr_stmt|;
name|this
operator|.
name|appPriorityACLManager
operator|=
operator|new
name|AppPriorityACLsManager
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|queueManager
operator|=
operator|new
name|CapacitySchedulerQueueManager
argument_list|(
name|yarnConf
argument_list|,
name|this
operator|.
name|labelManager
argument_list|,
name|this
operator|.
name|appPriorityACLManager
argument_list|)
expr_stmt|;
name|this
operator|.
name|queueManager
operator|.
name|setCapacitySchedulerContext
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|activitiesManager
operator|=
operator|new
name|ActivitiesManager
argument_list|(
name|rmContext
argument_list|)
expr_stmt|;
name|activitiesManager
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|initializeQueues
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|isLazyPreemptionEnabled
operator|=
name|conf
operator|.
name|getLazyPreemptionEnabled
argument_list|()
expr_stmt|;
name|scheduleAsynchronously
operator|=
name|this
operator|.
name|conf
operator|.
name|getScheduleAynschronously
argument_list|()
expr_stmt|;
name|asyncScheduleInterval
operator|=
name|this
operator|.
name|conf
operator|.
name|getLong
argument_list|(
name|ASYNC_SCHEDULER_INTERVAL
argument_list|,
name|DEFAULT_ASYNC_SCHEDULER_INTERVAL
argument_list|)
expr_stmt|;
name|this
operator|.
name|assignMultipleEnabled
operator|=
name|this
operator|.
name|conf
operator|.
name|getAssignMultipleEnabled
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxAssignPerHeartbeat
operator|=
name|this
operator|.
name|conf
operator|.
name|getMaxAssignPerHeartbeat
argument_list|()
expr_stmt|;
comment|// number of threads for async scheduling
name|int
name|maxAsyncSchedulingThreads
init|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|maxAsyncSchedulingThreads
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxAsyncSchedulingThreads
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|scheduleAsynchronously
condition|)
block|{
name|asyncSchedulerThreads
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxAsyncSchedulingThreads
condition|;
name|i
operator|++
control|)
block|{
name|asyncSchedulerThreads
operator|.
name|add
argument_list|(
operator|new
name|AsyncScheduleThread
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|resourceCommitterService
operator|=
operator|new
name|ResourceCommitterService
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|asyncMaxPendingBacklogs
operator|=
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS
argument_list|,
name|CapacitySchedulerConfiguration
operator|.
name|DEFAULT_SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_PENDING_BACKLOGS
argument_list|)
expr_stmt|;
block|}
comment|// Setup how many containers we can allocate for each round
name|offswitchPerHeartbeatLimit
operator|=
name|this
operator|.
name|conf
operator|.
name|getOffSwitchPerHeartbeatLimit
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Initialized CapacityScheduler with "
operator|+
literal|"calculator="
operator|+
name|getResourceCalculator
argument_list|()
operator|.
name|getClass
argument_list|()
operator|+
literal|", "
operator|+
literal|"minimumAllocation=<"
operator|+
name|getMinimumResourceCapability
argument_list|()
operator|+
literal|">, "
operator|+
literal|"maximumAllocation=<"
operator|+
name|getMaximumResourceCapability
argument_list|()
operator|+
literal|">, "
operator|+
literal|"asynchronousScheduling="
operator|+
name|scheduleAsynchronously
operator|+
literal|", "
operator|+
literal|"asyncScheduleInterval="
operator|+
name|asyncScheduleInterval
operator|+
literal|"ms"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|startSchedulerThreads ()
specifier|private
name|void
name|startSchedulerThreads
parameter_list|()
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|activitiesManager
operator|.
name|start
argument_list|()
expr_stmt|;
if|if
condition|(
name|scheduleAsynchronously
condition|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|asyncSchedulerThreads
argument_list|,
literal|"asyncSchedulerThreads is null"
argument_list|)
expr_stmt|;
for|for
control|(
name|Thread
name|t
range|:
name|asyncSchedulerThreads
control|)
block|{
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|resourceCommitterService
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|serviceInit (Configuration conf)
specifier|public
name|void
name|serviceInit
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
name|Configuration
name|configuration
init|=
operator|new
name|Configuration
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|super
operator|.
name|serviceInit
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|initScheduler
argument_list|(
name|configuration
argument_list|)
expr_stmt|;
comment|// Initialize SchedulingMonitorManager
name|schedulingMonitorManager
operator|.
name|initialize
argument_list|(
name|rmContext
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|serviceStart ()
specifier|public
name|void
name|serviceStart
parameter_list|()
throws|throws
name|Exception
block|{
name|startSchedulerThreads
argument_list|()
expr_stmt|;
name|super
operator|.
name|serviceStart
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|serviceStop ()
specifier|public
name|void
name|serviceStop
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|scheduleAsynchronously
operator|&&
name|asyncSchedulerThreads
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Thread
name|t
range|:
name|asyncSchedulerThreads
control|)
block|{
name|t
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|t
operator|.
name|join
argument_list|(
name|THREAD_JOIN_TIMEOUT_MS
argument_list|)
expr_stmt|;
block|}
name|resourceCommitterService
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|resourceCommitterService
operator|.
name|join
argument_list|(
name|THREAD_JOIN_TIMEOUT_MS
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isConfigurationMutable
argument_list|()
condition|)
block|{
operator|(
operator|(
name|MutableConfigurationProvider
operator|)
name|csConfProvider
operator|)
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|super
operator|.
name|serviceStop
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|reinitialize (Configuration newConf, RMContext rmContext)
specifier|public
name|void
name|reinitialize
parameter_list|(
name|Configuration
name|newConf
parameter_list|,
name|RMContext
name|rmContext
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|Configuration
name|configuration
init|=
operator|new
name|Configuration
argument_list|(
name|newConf
argument_list|)
decl_stmt|;
name|CapacitySchedulerConfiguration
name|oldConf
init|=
name|this
operator|.
name|conf
decl_stmt|;
name|this
operator|.
name|conf
operator|=
name|csConfProvider
operator|.
name|loadConfiguration
argument_list|(
name|configuration
argument_list|)
expr_stmt|;
name|validateConf
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Re-initializing queues..."
argument_list|)
expr_stmt|;
name|refreshMaximumAllocation
argument_list|(
name|ResourceUtils
operator|.
name|fetchMaximumAllocationFromConfig
argument_list|(
name|this
operator|.
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|reinitializeQueues
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|oldConf
expr_stmt|;
name|refreshMaximumAllocation
argument_list|(
name|ResourceUtils
operator|.
name|fetchMaximumAllocationFromConfig
argument_list|(
name|this
operator|.
name|conf
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to re-init queues : "
operator|+
name|t
operator|.
name|getMessage
argument_list|()
argument_list|,
name|t
argument_list|)
throw|;
block|}
comment|// update lazy preemption
name|this
operator|.
name|isLazyPreemptionEnabled
operator|=
name|this
operator|.
name|conf
operator|.
name|getLazyPreemptionEnabled
argument_list|()
expr_stmt|;
comment|// Setup how many containers we can allocate for each round
name|offswitchPerHeartbeatLimit
operator|=
name|this
operator|.
name|conf
operator|.
name|getOffSwitchPerHeartbeatLimit
argument_list|()
expr_stmt|;
name|super
operator|.
name|reinitialize
argument_list|(
name|newConf
argument_list|,
name|rmContext
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getAsyncScheduleInterval ()
name|long
name|getAsyncScheduleInterval
parameter_list|()
block|{
return|return
name|asyncScheduleInterval
return|;
block|}
DECL|field|random
specifier|private
specifier|final
specifier|static
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
decl_stmt|;
DECL|method|shouldSkipNodeSchedule (FiCaSchedulerNode node, CapacityScheduler cs, boolean printVerboseLog)
specifier|private
specifier|static
name|boolean
name|shouldSkipNodeSchedule
parameter_list|(
name|FiCaSchedulerNode
name|node
parameter_list|,
name|CapacityScheduler
name|cs
parameter_list|,
name|boolean
name|printVerboseLog
parameter_list|)
block|{
comment|// Skip node which missed 2 heartbeats since the node might be dead and
comment|// we should not continue allocate containers on that.
name|long
name|timeElapsedFromLastHeartbeat
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|node
operator|.
name|getLastHeartbeatMonotonicTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|timeElapsedFromLastHeartbeat
operator|>
name|cs
operator|.
name|nmHeartbeatInterval
operator|*
literal|2
condition|)
block|{
if|if
condition|(
name|printVerboseLog
operator|&&
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skip scheduling on node because it haven't heartbeated for "
operator|+
name|timeElapsedFromLastHeartbeat
operator|/
literal|1000.0f
operator|+
literal|" secs"
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Schedule on all nodes by starting at a random point.    * @param cs    */
DECL|method|schedule (CapacityScheduler cs)
specifier|static
name|void
name|schedule
parameter_list|(
name|CapacityScheduler
name|cs
parameter_list|)
throws|throws
name|InterruptedException
block|{
comment|// First randomize the start point
name|int
name|current
init|=
literal|0
decl_stmt|;
name|Collection
argument_list|<
name|FiCaSchedulerNode
argument_list|>
name|nodes
init|=
name|cs
operator|.
name|nodeTracker
operator|.
name|getAllNodes
argument_list|()
decl_stmt|;
comment|// If nodes size is 0 (when there are no node managers registered,
comment|// we can return from here itself.
name|int
name|nodeSize
init|=
name|nodes
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|nodeSize
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|int
name|start
init|=
name|random
operator|.
name|nextInt
argument_list|(
name|nodeSize
argument_list|)
decl_stmt|;
comment|// To avoid too verbose DEBUG logging, only print debug log once for
comment|// every 10 secs.
name|boolean
name|printSkipedNodeLogging
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|/
literal|1000
operator|%
literal|10
operator|==
literal|0
condition|)
block|{
name|printSkipedNodeLogging
operator|=
operator|(
operator|!
name|printedVerboseLoggingForAsyncScheduling
operator|)
expr_stmt|;
block|}
else|else
block|{
name|printedVerboseLoggingForAsyncScheduling
operator|=
literal|false
expr_stmt|;
block|}
comment|// Allocate containers of node [start, end)
for|for
control|(
name|FiCaSchedulerNode
name|node
range|:
name|nodes
control|)
block|{
if|if
condition|(
name|current
operator|++
operator|>=
name|start
condition|)
block|{
if|if
condition|(
name|shouldSkipNodeSchedule
argument_list|(
name|node
argument_list|,
name|cs
argument_list|,
name|printSkipedNodeLogging
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|cs
operator|.
name|allocateContainersToNode
argument_list|(
name|node
operator|.
name|getNodeID
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
name|current
operator|=
literal|0
expr_stmt|;
comment|// Allocate containers of node [0, start)
for|for
control|(
name|FiCaSchedulerNode
name|node
range|:
name|nodes
control|)
block|{
if|if
condition|(
name|current
operator|++
operator|>
name|start
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|shouldSkipNodeSchedule
argument_list|(
name|node
argument_list|,
name|cs
argument_list|,
name|printSkipedNodeLogging
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|cs
operator|.
name|allocateContainersToNode
argument_list|(
name|node
operator|.
name|getNodeID
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|printSkipedNodeLogging
condition|)
block|{
name|printedVerboseLoggingForAsyncScheduling
operator|=
literal|true
expr_stmt|;
block|}
name|Thread
operator|.
name|sleep
argument_list|(
name|cs
operator|.
name|getAsyncScheduleInterval
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|class|AsyncScheduleThread
specifier|static
class|class
name|AsyncScheduleThread
extends|extends
name|Thread
block|{
DECL|field|cs
specifier|private
specifier|final
name|CapacityScheduler
name|cs
decl_stmt|;
DECL|field|runSchedules
specifier|private
name|AtomicBoolean
name|runSchedules
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|method|AsyncScheduleThread (CapacityScheduler cs)
specifier|public
name|AsyncScheduleThread
parameter_list|(
name|CapacityScheduler
name|cs
parameter_list|)
block|{
name|this
operator|.
name|cs
operator|=
name|cs
expr_stmt|;
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|int
name|debuggingLogCounter
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
try|try
block|{
if|if
condition|(
operator|!
name|runSchedules
operator|.
name|get
argument_list|()
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Don't run schedule if we have some pending backlogs already
if|if
condition|(
name|cs
operator|.
name|getAsyncSchedulingPendingBacklogs
argument_list|()
operator|>
name|cs
operator|.
name|asyncMaxPendingBacklogs
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|schedule
argument_list|(
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
comment|// Adding a debug log here to ensure that the thread is alive
comment|// and running fine.
if|if
condition|(
name|debuggingLogCounter
operator|++
operator|>
literal|10000
condition|)
block|{
name|debuggingLogCounter
operator|=
literal|0
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"AsyncScheduleThread["
operator|+
name|getName
argument_list|()
operator|+
literal|"] is running!"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// keep interrupt signal
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"AsyncScheduleThread["
operator|+
name|getName
argument_list|()
operator|+
literal|"] exited!"
argument_list|)
expr_stmt|;
block|}
DECL|method|beginSchedule ()
specifier|public
name|void
name|beginSchedule
parameter_list|()
block|{
name|runSchedules
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|suspendSchedule ()
specifier|public
name|void
name|suspendSchedule
parameter_list|()
block|{
name|runSchedules
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|ResourceCommitterService
specifier|static
class|class
name|ResourceCommitterService
extends|extends
name|Thread
block|{
DECL|field|cs
specifier|private
specifier|final
name|CapacityScheduler
name|cs
decl_stmt|;
specifier|private
name|BlockingQueue
argument_list|<
name|ResourceCommitRequest
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
argument_list|>
DECL|field|backlogs
name|backlogs
init|=
operator|new
name|LinkedBlockingQueue
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|ResourceCommitterService (CapacityScheduler cs)
specifier|public
name|ResourceCommitterService
parameter_list|(
name|CapacityScheduler
name|cs
parameter_list|)
block|{
name|this
operator|.
name|cs
operator|=
name|cs
expr_stmt|;
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
operator|!
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
try|try
block|{
name|ResourceCommitRequest
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
name|request
init|=
name|backlogs
operator|.
name|take
argument_list|()
decl_stmt|;
try|try
block|{
name|cs
operator|.
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|cs
operator|.
name|tryCommit
argument_list|(
name|cs
operator|.
name|getClusterResource
argument_list|()
argument_list|,
name|request
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|cs
operator|.
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"ResourceCommitterService exited!"
argument_list|)
expr_stmt|;
block|}
DECL|method|addNewCommitRequest ( ResourceCommitRequest<FiCaSchedulerApp, FiCaSchedulerNode> proposal)
specifier|public
name|void
name|addNewCommitRequest
parameter_list|(
name|ResourceCommitRequest
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
name|proposal
parameter_list|)
block|{
name|backlogs
operator|.
name|add
argument_list|(
name|proposal
argument_list|)
expr_stmt|;
block|}
DECL|method|getPendingBacklogs ()
specifier|public
name|int
name|getPendingBacklogs
parameter_list|()
block|{
return|return
name|backlogs
operator|.
name|size
argument_list|()
return|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getUserGroupMappingPlacementRule ()
specifier|public
name|PlacementRule
name|getUserGroupMappingPlacementRule
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|UserGroupMappingPlacementRule
name|ugRule
init|=
operator|new
name|UserGroupMappingPlacementRule
argument_list|()
decl_stmt|;
name|ugRule
operator|.
name|initialize
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|ugRule
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getAppNameMappingPlacementRule ()
specifier|public
name|PlacementRule
name|getAppNameMappingPlacementRule
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|AppNameMappingPlacementRule
name|anRule
init|=
operator|new
name|AppNameMappingPlacementRule
argument_list|()
decl_stmt|;
name|anRule
operator|.
name|initialize
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|anRule
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|updatePlacementRules ()
specifier|public
name|void
name|updatePlacementRules
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Initialize placement rules
name|Collection
argument_list|<
name|String
argument_list|>
name|placementRuleStrs
init|=
name|conf
operator|.
name|getStringCollection
argument_list|(
name|YarnConfiguration
operator|.
name|QUEUE_PLACEMENT_RULES
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|PlacementRule
argument_list|>
name|placementRules
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|distingushRuleSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// fail the case if we get duplicate placementRule add in
for|for
control|(
name|String
name|pls
range|:
name|placementRuleStrs
control|)
block|{
if|if
condition|(
operator|!
name|distingushRuleSet
operator|.
name|add
argument_list|(
name|pls
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid PlacementRule inputs which "
operator|+
literal|"contains duplicate rule strings"
argument_list|)
throw|;
block|}
block|}
comment|// add UserGroupMappingPlacementRule if absent
name|distingushRuleSet
operator|.
name|add
argument_list|(
name|YarnConfiguration
operator|.
name|USER_GROUP_PLACEMENT_RULE
argument_list|)
expr_stmt|;
name|placementRuleStrs
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|distingushRuleSet
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|placementRuleStr
range|:
name|placementRuleStrs
control|)
block|{
switch|switch
condition|(
name|placementRuleStr
condition|)
block|{
case|case
name|YarnConfiguration
operator|.
name|USER_GROUP_PLACEMENT_RULE
case|:
name|PlacementRule
name|ugRule
init|=
name|getUserGroupMappingPlacementRule
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|ugRule
condition|)
block|{
name|placementRules
operator|.
name|add
argument_list|(
name|ugRule
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|YarnConfiguration
operator|.
name|APP_NAME_PLACEMENT_RULE
case|:
name|PlacementRule
name|anRule
init|=
name|getAppNameMappingPlacementRule
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|anRule
condition|)
block|{
name|placementRules
operator|.
name|add
argument_list|(
name|anRule
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|boolean
name|isMappingNotEmpty
decl_stmt|;
try|try
block|{
name|PlacementRule
name|rule
init|=
name|PlacementFactory
operator|.
name|getPlacementRule
argument_list|(
name|placementRuleStr
argument_list|,
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|rule
condition|)
block|{
try|try
block|{
name|isMappingNotEmpty
operator|=
name|rule
operator|.
name|initialize
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
if|if
condition|(
name|isMappingNotEmpty
condition|)
block|{
name|placementRules
operator|.
name|add
argument_list|(
name|rule
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|cnfe
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|cnfe
argument_list|)
throw|;
block|}
block|}
block|}
name|rmContext
operator|.
name|getQueuePlacementManager
argument_list|()
operator|.
name|updateRules
argument_list|(
name|placementRules
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Lock
argument_list|(
name|CapacityScheduler
operator|.
name|class
argument_list|)
DECL|method|initializeQueues (CapacitySchedulerConfiguration conf)
specifier|private
name|void
name|initializeQueues
parameter_list|(
name|CapacitySchedulerConfiguration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|queueManager
operator|.
name|initializeQueues
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|updatePlacementRules
argument_list|()
expr_stmt|;
comment|// Notify Preemption Manager
name|preemptionManager
operator|.
name|refreshQueues
argument_list|(
literal|null
argument_list|,
name|this
operator|.
name|getRootQueue
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Lock
argument_list|(
name|CapacityScheduler
operator|.
name|class
argument_list|)
DECL|method|reinitializeQueues (CapacitySchedulerConfiguration newConf)
specifier|private
name|void
name|reinitializeQueues
parameter_list|(
name|CapacitySchedulerConfiguration
name|newConf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|queueManager
operator|.
name|reinitializeQueues
argument_list|(
name|newConf
argument_list|)
expr_stmt|;
name|updatePlacementRules
argument_list|()
expr_stmt|;
comment|// Notify Preemption Manager
name|preemptionManager
operator|.
name|refreshQueues
argument_list|(
literal|null
argument_list|,
name|this
operator|.
name|getRootQueue
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getQueue (String queueName)
specifier|public
name|CSQueue
name|getQueue
parameter_list|(
name|String
name|queueName
parameter_list|)
block|{
if|if
condition|(
name|queueName
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|this
operator|.
name|queueManager
operator|.
name|getQueue
argument_list|(
name|queueName
argument_list|)
return|;
block|}
DECL|method|addApplicationOnRecovery (ApplicationId applicationId, String queueName, String user, Priority priority, ApplicationPlacementContext placementContext)
specifier|private
name|void
name|addApplicationOnRecovery
parameter_list|(
name|ApplicationId
name|applicationId
parameter_list|,
name|String
name|queueName
parameter_list|,
name|String
name|user
parameter_list|,
name|Priority
name|priority
parameter_list|,
name|ApplicationPlacementContext
name|placementContext
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|//check if the queue needs to be auto-created during recovery
name|CSQueue
name|queue
init|=
name|getOrCreateQueueFromPlacementContext
argument_list|(
name|applicationId
argument_list|,
name|user
argument_list|,
name|queueName
argument_list|,
name|placementContext
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
block|{
comment|//During a restart, this indicates a queue was removed, which is
comment|//not presently supported
if|if
condition|(
operator|!
name|getConfiguration
argument_list|()
operator|.
name|shouldAppFailFast
argument_list|(
name|getConfig
argument_list|()
argument_list|)
condition|)
block|{
name|this
operator|.
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMAppEvent
argument_list|(
name|applicationId
argument_list|,
name|RMAppEventType
operator|.
name|KILL
argument_list|,
literal|"Application killed on recovery as it"
operator|+
literal|" was submitted to queue "
operator|+
name|queueName
operator|+
literal|" which no longer exists after restart."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|String
name|queueErrorMsg
init|=
literal|"Queue named "
operator|+
name|queueName
operator|+
literal|" missing "
operator|+
literal|"during application recovery."
operator|+
literal|" Queue removal during recovery is not presently "
operator|+
literal|"supported by the capacity scheduler, please "
operator|+
literal|"restart with all queues configured"
operator|+
literal|" which were present before shutdown/restart."
decl_stmt|;
name|LOG
operator|.
name|fatal
argument_list|(
name|queueErrorMsg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|QueueInvalidException
argument_list|(
name|queueErrorMsg
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|queue
operator|instanceof
name|LeafQueue
operator|)
condition|)
block|{
comment|// During RM restart, this means leaf queue was converted to a parent
comment|// queue, which is not supported for running apps.
if|if
condition|(
operator|!
name|getConfiguration
argument_list|()
operator|.
name|shouldAppFailFast
argument_list|(
name|getConfig
argument_list|()
argument_list|)
condition|)
block|{
name|this
operator|.
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMAppEvent
argument_list|(
name|applicationId
argument_list|,
name|RMAppEventType
operator|.
name|KILL
argument_list|,
literal|"Application killed on recovery as it was "
operator|+
literal|"submitted to queue "
operator|+
name|queueName
operator|+
literal|" which is no longer a leaf queue after restart."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|String
name|queueErrorMsg
init|=
literal|"Queue named "
operator|+
name|queueName
operator|+
literal|" is no longer a leaf queue during application recovery."
operator|+
literal|" Changing a leaf queue to a parent queue during recovery is"
operator|+
literal|" not presently supported by the capacity scheduler. Please"
operator|+
literal|" restart with leaf queues before shutdown/restart continuing"
operator|+
literal|" as leaf queues."
decl_stmt|;
name|LOG
operator|.
name|fatal
argument_list|(
name|queueErrorMsg
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|QueueInvalidException
argument_list|(
name|queueErrorMsg
argument_list|)
throw|;
block|}
block|}
comment|// When recovering apps in this queue but queue is in STOPPED state,
comment|// that means its previous state was DRAINING. So we auto transit
comment|// the state to DRAINING for recovery.
if|if
condition|(
name|queue
operator|.
name|getState
argument_list|()
operator|==
name|QueueState
operator|.
name|STOPPED
condition|)
block|{
operator|(
operator|(
name|LeafQueue
operator|)
name|queue
operator|)
operator|.
name|recoverDrainingState
argument_list|()
expr_stmt|;
block|}
comment|// Submit to the queue
try|try
block|{
name|queue
operator|.
name|submitApplication
argument_list|(
name|applicationId
argument_list|,
name|user
argument_list|,
name|queueName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|ace
parameter_list|)
block|{
comment|// Ignore the exception for recovered app as the app was previously
comment|// accepted.
block|}
name|queue
operator|.
name|getMetrics
argument_list|()
operator|.
name|submitApp
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|SchedulerApplication
argument_list|<
name|FiCaSchedulerApp
argument_list|>
name|application
init|=
operator|new
name|SchedulerApplication
argument_list|<
name|FiCaSchedulerApp
argument_list|>
argument_list|(
name|queue
argument_list|,
name|user
argument_list|,
name|priority
argument_list|)
decl_stmt|;
name|applications
operator|.
name|put
argument_list|(
name|applicationId
argument_list|,
name|application
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Accepted application "
operator|+
name|applicationId
operator|+
literal|" from user: "
operator|+
name|user
operator|+
literal|", in queue: "
operator|+
name|queueName
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|applicationId
operator|+
literal|" is recovering. Skip notifying APP_ACCEPTED"
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getOrCreateQueueFromPlacementContext (ApplicationId applicationId, String user, String queueName, ApplicationPlacementContext placementContext, boolean isRecovery)
specifier|private
name|CSQueue
name|getOrCreateQueueFromPlacementContext
parameter_list|(
name|ApplicationId
name|applicationId
parameter_list|,
name|String
name|user
parameter_list|,
name|String
name|queueName
parameter_list|,
name|ApplicationPlacementContext
name|placementContext
parameter_list|,
name|boolean
name|isRecovery
parameter_list|)
block|{
name|CSQueue
name|queue
init|=
name|getQueue
argument_list|(
name|queueName
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|placementContext
operator|!=
literal|null
operator|&&
name|placementContext
operator|.
name|hasParentQueue
argument_list|()
condition|)
block|{
try|try
block|{
return|return
name|autoCreateLeafQueue
argument_list|(
name|placementContext
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|YarnException
decl||
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isRecovery
condition|)
block|{
if|if
condition|(
operator|!
name|getConfiguration
argument_list|()
operator|.
name|shouldAppFailFast
argument_list|(
name|getConfig
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not auto-create leaf queue "
operator|+
name|queueName
operator|+
literal|" due to : "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|this
operator|.
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMAppEvent
argument_list|(
name|applicationId
argument_list|,
name|RMAppEventType
operator|.
name|KILL
argument_list|,
literal|"Application killed on recovery"
operator|+
literal|" as it was submitted to queue "
operator|+
name|queueName
operator|+
literal|" which could not be auto-created"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|queueErrorMsg
init|=
literal|"Queue named "
operator|+
name|queueName
operator|+
literal|" could not be "
operator|+
literal|"auto-created during application recovery."
decl_stmt|;
name|LOG
operator|.
name|fatal
argument_list|(
name|queueErrorMsg
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|QueueInvalidException
argument_list|(
name|queueErrorMsg
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not auto-create leaf queue due to : "
argument_list|,
name|e
argument_list|)
expr_stmt|;
specifier|final
name|String
name|message
init|=
literal|"Application "
operator|+
name|applicationId
operator|+
literal|" submission by user : "
operator|+
name|user
operator|+
literal|" to  queue : "
operator|+
name|queueName
operator|+
literal|" failed : "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
decl_stmt|;
name|this
operator|.
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMAppEvent
argument_list|(
name|applicationId
argument_list|,
name|RMAppEventType
operator|.
name|APP_REJECTED
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|queue
return|;
block|}
DECL|method|addApplication (ApplicationId applicationId, String queueName, String user, Priority priority, ApplicationPlacementContext placementContext)
specifier|private
name|void
name|addApplication
parameter_list|(
name|ApplicationId
name|applicationId
parameter_list|,
name|String
name|queueName
parameter_list|,
name|String
name|user
parameter_list|,
name|Priority
name|priority
parameter_list|,
name|ApplicationPlacementContext
name|placementContext
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|isSystemAppsLimitReached
argument_list|()
condition|)
block|{
name|String
name|message
init|=
literal|"Maximum system application limit reached,"
operator|+
literal|"cannot accept submission of application: "
operator|+
name|applicationId
decl_stmt|;
name|this
operator|.
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMAppEvent
argument_list|(
name|applicationId
argument_list|,
name|RMAppEventType
operator|.
name|APP_REJECTED
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|//Could be a potential auto-created leaf queue
name|CSQueue
name|queue
init|=
name|getOrCreateQueueFromPlacementContext
argument_list|(
name|applicationId
argument_list|,
name|user
argument_list|,
name|queueName
argument_list|,
name|placementContext
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
block|{
specifier|final
name|String
name|message
init|=
literal|"Application "
operator|+
name|applicationId
operator|+
literal|" submitted by user "
operator|+
name|user
operator|+
literal|" to unknown queue: "
operator|+
name|queueName
decl_stmt|;
name|this
operator|.
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMAppEvent
argument_list|(
name|applicationId
argument_list|,
name|RMAppEventType
operator|.
name|APP_REJECTED
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|queue
operator|instanceof
name|LeafQueue
operator|)
condition|)
block|{
name|String
name|message
init|=
literal|"Application "
operator|+
name|applicationId
operator|+
literal|" submitted by user : "
operator|+
name|user
operator|+
literal|" to non-leaf queue : "
operator|+
name|queueName
decl_stmt|;
name|this
operator|.
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMAppEvent
argument_list|(
name|applicationId
argument_list|,
name|RMAppEventType
operator|.
name|APP_REJECTED
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|queue
operator|instanceof
name|AutoCreatedLeafQueue
operator|&&
name|queue
operator|.
name|getParent
argument_list|()
operator|instanceof
name|ManagedParentQueue
condition|)
block|{
comment|//If queue already exists and auto-queue creation was not required,
comment|//placement context should not be null
if|if
condition|(
name|placementContext
operator|==
literal|null
condition|)
block|{
name|String
name|message
init|=
literal|"Application "
operator|+
name|applicationId
operator|+
literal|" submission by user : "
operator|+
name|user
operator|+
literal|" to specified queue : "
operator|+
name|queueName
operator|+
literal|"  is prohibited. "
operator|+
literal|"Verify automatic queue mapping for user exists in "
operator|+
name|QUEUE_MAPPING
decl_stmt|;
name|this
operator|.
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMAppEvent
argument_list|(
name|applicationId
argument_list|,
name|RMAppEventType
operator|.
name|APP_REJECTED
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
return|return;
comment|// For a queue which exists already and
comment|// not auto-created above, then its parent queue should match
comment|// the parent queue specified in queue mapping
block|}
elseif|else
if|if
condition|(
operator|!
name|queue
operator|.
name|getParent
argument_list|()
operator|.
name|getQueueName
argument_list|()
operator|.
name|equals
argument_list|(
name|placementContext
operator|.
name|getParentQueue
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|message
init|=
literal|"Auto created Leaf queue "
operator|+
name|placementContext
operator|.
name|getQueue
argument_list|()
operator|+
literal|" "
operator|+
literal|"already exists under queue : "
operator|+
name|queue
operator|.
name|getParent
argument_list|()
operator|.
name|getQueuePath
argument_list|()
operator|+
literal|".But Queue mapping configuration "
operator|+
name|CapacitySchedulerConfiguration
operator|.
name|QUEUE_MAPPING
operator|+
literal|" has been "
operator|+
literal|"updated to a different parent queue : "
operator|+
name|placementContext
operator|.
name|getParentQueue
argument_list|()
operator|+
literal|" for the specified user : "
operator|+
name|user
decl_stmt|;
name|this
operator|.
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMAppEvent
argument_list|(
name|applicationId
argument_list|,
name|RMAppEventType
operator|.
name|APP_REJECTED
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// Submit to the queue
try|try
block|{
name|queue
operator|.
name|submitApplication
argument_list|(
name|applicationId
argument_list|,
name|user
argument_list|,
name|queueName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|ace
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to submit application "
operator|+
name|applicationId
operator|+
literal|" to queue "
operator|+
name|queueName
operator|+
literal|" from user "
operator|+
name|user
argument_list|,
name|ace
argument_list|)
expr_stmt|;
name|this
operator|.
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMAppEvent
argument_list|(
name|applicationId
argument_list|,
name|RMAppEventType
operator|.
name|APP_REJECTED
argument_list|,
name|ace
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// update the metrics
name|queue
operator|.
name|getMetrics
argument_list|()
operator|.
name|submitApp
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|SchedulerApplication
argument_list|<
name|FiCaSchedulerApp
argument_list|>
name|application
init|=
operator|new
name|SchedulerApplication
argument_list|<
name|FiCaSchedulerApp
argument_list|>
argument_list|(
name|queue
argument_list|,
name|user
argument_list|,
name|priority
argument_list|)
decl_stmt|;
name|applications
operator|.
name|put
argument_list|(
name|applicationId
argument_list|,
name|application
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Accepted application "
operator|+
name|applicationId
operator|+
literal|" from user: "
operator|+
name|user
operator|+
literal|", in queue: "
operator|+
name|queueName
argument_list|)
expr_stmt|;
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMAppEvent
argument_list|(
name|applicationId
argument_list|,
name|RMAppEventType
operator|.
name|APP_ACCEPTED
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|addApplicationAttempt ( ApplicationAttemptId applicationAttemptId, boolean transferStateFromPreviousAttempt, boolean isAttemptRecovering)
specifier|private
name|void
name|addApplicationAttempt
parameter_list|(
name|ApplicationAttemptId
name|applicationAttemptId
parameter_list|,
name|boolean
name|transferStateFromPreviousAttempt
parameter_list|,
name|boolean
name|isAttemptRecovering
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|SchedulerApplication
argument_list|<
name|FiCaSchedulerApp
argument_list|>
name|application
init|=
name|applications
operator|.
name|get
argument_list|(
name|applicationAttemptId
operator|.
name|getApplicationId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|application
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Application "
operator|+
name|applicationAttemptId
operator|.
name|getApplicationId
argument_list|()
operator|+
literal|" cannot be found in scheduler."
argument_list|)
expr_stmt|;
return|return;
block|}
name|CSQueue
name|queue
init|=
operator|(
name|CSQueue
operator|)
name|application
operator|.
name|getQueue
argument_list|()
decl_stmt|;
name|FiCaSchedulerApp
name|attempt
init|=
operator|new
name|FiCaSchedulerApp
argument_list|(
name|applicationAttemptId
argument_list|,
name|application
operator|.
name|getUser
argument_list|()
argument_list|,
name|queue
argument_list|,
name|queue
operator|.
name|getAbstractUsersManager
argument_list|()
argument_list|,
name|rmContext
argument_list|,
name|application
operator|.
name|getPriority
argument_list|()
argument_list|,
name|isAttemptRecovering
argument_list|,
name|activitiesManager
argument_list|)
decl_stmt|;
if|if
condition|(
name|transferStateFromPreviousAttempt
condition|)
block|{
name|attempt
operator|.
name|transferStateFromPreviousAttempt
argument_list|(
name|application
operator|.
name|getCurrentAppAttempt
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|application
operator|.
name|setCurrentAppAttempt
argument_list|(
name|attempt
argument_list|)
expr_stmt|;
comment|// Update attempt priority to the latest to avoid race condition i.e
comment|// SchedulerApplicationAttempt is created with old priority but it is not
comment|// set to SchedulerApplication#setCurrentAppAttempt.
comment|// Scenario would occur is
comment|// 1. SchdulerApplicationAttempt is created with old priority.
comment|// 2. updateApplicationPriority() updates SchedulerApplication. Since
comment|// currentAttempt is null, it just return.
comment|// 3. ScheduelerApplcationAttempt is set in
comment|// SchedulerApplication#setCurrentAppAttempt.
name|attempt
operator|.
name|setPriority
argument_list|(
name|application
operator|.
name|getPriority
argument_list|()
argument_list|)
expr_stmt|;
name|queue
operator|.
name|submitApplicationAttempt
argument_list|(
name|attempt
argument_list|,
name|application
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Added Application Attempt "
operator|+
name|applicationAttemptId
operator|+
literal|" to scheduler from user "
operator|+
name|application
operator|.
name|getUser
argument_list|()
operator|+
literal|" in queue "
operator|+
name|queue
operator|.
name|getQueueName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|isAttemptRecovering
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|applicationAttemptId
operator|+
literal|" is recovering. Skipping notifying ATTEMPT_ADDED"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMAppAttemptEvent
argument_list|(
name|applicationAttemptId
argument_list|,
name|RMAppAttemptEventType
operator|.
name|ATTEMPT_ADDED
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|doneApplication (ApplicationId applicationId, RMAppState finalState)
specifier|private
name|void
name|doneApplication
parameter_list|(
name|ApplicationId
name|applicationId
parameter_list|,
name|RMAppState
name|finalState
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|SchedulerApplication
argument_list|<
name|FiCaSchedulerApp
argument_list|>
name|application
init|=
name|applications
operator|.
name|get
argument_list|(
name|applicationId
argument_list|)
decl_stmt|;
if|if
condition|(
name|application
operator|==
literal|null
condition|)
block|{
comment|// The AppRemovedSchedulerEvent maybe sent on recovery for completed
comment|// apps, ignore it.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Couldn't find application "
operator|+
name|applicationId
argument_list|)
expr_stmt|;
return|return;
block|}
name|CSQueue
name|queue
init|=
operator|(
name|CSQueue
operator|)
name|application
operator|.
name|getQueue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|queue
operator|instanceof
name|LeafQueue
operator|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot finish application "
operator|+
literal|"from non-leaf queue: "
operator|+
name|queue
operator|.
name|getQueueName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|queue
operator|.
name|finishApplication
argument_list|(
name|applicationId
argument_list|,
name|application
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|application
operator|.
name|stop
argument_list|(
name|finalState
argument_list|)
expr_stmt|;
name|applications
operator|.
name|remove
argument_list|(
name|applicationId
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|doneApplicationAttempt ( ApplicationAttemptId applicationAttemptId, RMAppAttemptState rmAppAttemptFinalState, boolean keepContainers)
specifier|private
name|void
name|doneApplicationAttempt
parameter_list|(
name|ApplicationAttemptId
name|applicationAttemptId
parameter_list|,
name|RMAppAttemptState
name|rmAppAttemptFinalState
parameter_list|,
name|boolean
name|keepContainers
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Application Attempt "
operator|+
name|applicationAttemptId
operator|+
literal|" is done."
operator|+
literal|" finalState="
operator|+
name|rmAppAttemptFinalState
argument_list|)
expr_stmt|;
name|FiCaSchedulerApp
name|attempt
init|=
name|getApplicationAttempt
argument_list|(
name|applicationAttemptId
argument_list|)
decl_stmt|;
name|SchedulerApplication
argument_list|<
name|FiCaSchedulerApp
argument_list|>
name|application
init|=
name|applications
operator|.
name|get
argument_list|(
name|applicationAttemptId
operator|.
name|getApplicationId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|application
operator|==
literal|null
operator|||
name|attempt
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Unknown application "
operator|+
name|applicationAttemptId
operator|+
literal|" has completed!"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Release all the allocated, acquired, running containers
for|for
control|(
name|RMContainer
name|rmContainer
range|:
name|attempt
operator|.
name|getLiveContainers
argument_list|()
control|)
block|{
if|if
condition|(
name|keepContainers
operator|&&
name|rmContainer
operator|.
name|getState
argument_list|()
operator|.
name|equals
argument_list|(
name|RMContainerState
operator|.
name|RUNNING
argument_list|)
condition|)
block|{
comment|// do not kill the running container in the case of work-preserving AM
comment|// restart.
name|LOG
operator|.
name|info
argument_list|(
literal|"Skip killing "
operator|+
name|rmContainer
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|super
operator|.
name|completedContainer
argument_list|(
name|rmContainer
argument_list|,
name|SchedulerUtils
operator|.
name|createAbnormalContainerStatus
argument_list|(
name|rmContainer
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|SchedulerUtils
operator|.
name|COMPLETED_APPLICATION
argument_list|)
argument_list|,
name|RMContainerEventType
operator|.
name|KILL
argument_list|)
expr_stmt|;
block|}
comment|// Release all reserved containers
for|for
control|(
name|RMContainer
name|rmContainer
range|:
name|attempt
operator|.
name|getReservedContainers
argument_list|()
control|)
block|{
name|super
operator|.
name|completedContainer
argument_list|(
name|rmContainer
argument_list|,
name|SchedulerUtils
operator|.
name|createAbnormalContainerStatus
argument_list|(
name|rmContainer
operator|.
name|getContainerId
argument_list|()
argument_list|,
literal|"Application Complete"
argument_list|)
argument_list|,
name|RMContainerEventType
operator|.
name|KILL
argument_list|)
expr_stmt|;
block|}
comment|// Clean up pending requests, metrics etc.
name|attempt
operator|.
name|stop
argument_list|(
name|rmAppAttemptFinalState
argument_list|)
expr_stmt|;
comment|// Inform the queue
name|String
name|queueName
init|=
name|attempt
operator|.
name|getQueue
argument_list|()
operator|.
name|getQueueName
argument_list|()
decl_stmt|;
name|CSQueue
name|queue
init|=
name|this
operator|.
name|getQueue
argument_list|(
name|queueName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|queue
operator|instanceof
name|LeafQueue
operator|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot finish application "
operator|+
literal|"from non-leaf queue: "
operator|+
name|queueName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|queue
operator|.
name|finishApplicationAttempt
argument_list|(
name|attempt
argument_list|,
name|queue
operator|.
name|getQueueName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Normalize a list of SchedulingRequest.    *    * @param asks scheduling request    */
DECL|method|normalizeSchedulingRequests (List<SchedulingRequest> asks)
specifier|private
name|void
name|normalizeSchedulingRequests
parameter_list|(
name|List
argument_list|<
name|SchedulingRequest
argument_list|>
name|asks
parameter_list|)
block|{
if|if
condition|(
name|asks
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|SchedulingRequest
name|ask
range|:
name|asks
control|)
block|{
name|ResourceSizing
name|sizing
init|=
name|ask
operator|.
name|getResourceSizing
argument_list|()
decl_stmt|;
if|if
condition|(
name|sizing
operator|!=
literal|null
operator|&&
name|sizing
operator|.
name|getResources
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|sizing
operator|.
name|setResources
argument_list|(
name|getNormalizedResource
argument_list|(
name|sizing
operator|.
name|getResources
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
annotation|@
name|Lock
argument_list|(
name|Lock
operator|.
name|NoLock
operator|.
name|class
argument_list|)
DECL|method|allocate (ApplicationAttemptId applicationAttemptId, List<ResourceRequest> ask, List<SchedulingRequest> schedulingRequests, List<ContainerId> release, List<String> blacklistAdditions, List<String> blacklistRemovals, ContainerUpdates updateRequests)
specifier|public
name|Allocation
name|allocate
parameter_list|(
name|ApplicationAttemptId
name|applicationAttemptId
parameter_list|,
name|List
argument_list|<
name|ResourceRequest
argument_list|>
name|ask
parameter_list|,
name|List
argument_list|<
name|SchedulingRequest
argument_list|>
name|schedulingRequests
parameter_list|,
name|List
argument_list|<
name|ContainerId
argument_list|>
name|release
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|blacklistAdditions
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|blacklistRemovals
parameter_list|,
name|ContainerUpdates
name|updateRequests
parameter_list|)
block|{
name|FiCaSchedulerApp
name|application
init|=
name|getApplicationAttempt
argument_list|(
name|applicationAttemptId
argument_list|)
decl_stmt|;
if|if
condition|(
name|application
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Calling allocate on removed or non existent application "
operator|+
name|applicationAttemptId
operator|.
name|getApplicationId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|EMPTY_ALLOCATION
return|;
block|}
comment|// The allocate may be the leftover from previous attempt, and it will
comment|// impact current attempt, such as confuse the request and allocation for
comment|// current attempt's AM container.
comment|// Note outside precondition check for the attempt id may be
comment|// outdated here, so double check it here is necessary.
if|if
condition|(
operator|!
name|application
operator|.
name|getApplicationAttemptId
argument_list|()
operator|.
name|equals
argument_list|(
name|applicationAttemptId
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Calling allocate on previous or removed "
operator|+
literal|"or non existent application attempt "
operator|+
name|applicationAttemptId
argument_list|)
expr_stmt|;
return|return
name|EMPTY_ALLOCATION
return|;
block|}
comment|// Handle all container updates
name|handleContainerUpdates
argument_list|(
name|application
argument_list|,
name|updateRequests
argument_list|)
expr_stmt|;
comment|// Release containers
name|releaseContainers
argument_list|(
name|release
argument_list|,
name|application
argument_list|)
expr_stmt|;
name|LeafQueue
name|updateDemandForQueue
init|=
literal|null
decl_stmt|;
comment|// Sanity check for new allocation requests
name|normalizeResourceRequests
argument_list|(
name|ask
argument_list|)
expr_stmt|;
comment|// Normalize scheduling requests
name|normalizeSchedulingRequests
argument_list|(
name|schedulingRequests
argument_list|)
expr_stmt|;
name|Allocation
name|allocation
decl_stmt|;
comment|// make sure we aren't stopping/removing the application
comment|// when the allocate comes in
try|try
block|{
name|application
operator|.
name|getWriteLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|application
operator|.
name|isStopped
argument_list|()
condition|)
block|{
return|return
name|EMPTY_ALLOCATION
return|;
block|}
comment|// Process resource requests
if|if
condition|(
operator|!
name|ask
operator|.
name|isEmpty
argument_list|()
operator|||
operator|(
name|schedulingRequests
operator|!=
literal|null
operator|&&
operator|!
name|schedulingRequests
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"allocate: pre-update "
operator|+
name|applicationAttemptId
operator|+
literal|" ask size ="
operator|+
name|ask
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|application
operator|.
name|showRequests
argument_list|()
expr_stmt|;
block|}
comment|// Update application requests
if|if
condition|(
name|application
operator|.
name|updateResourceRequests
argument_list|(
name|ask
argument_list|)
operator|||
name|application
operator|.
name|updateSchedulingRequests
argument_list|(
name|schedulingRequests
argument_list|)
condition|)
block|{
name|updateDemandForQueue
operator|=
operator|(
name|LeafQueue
operator|)
name|application
operator|.
name|getQueue
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"allocate: post-update"
argument_list|)
expr_stmt|;
name|application
operator|.
name|showRequests
argument_list|()
expr_stmt|;
block|}
block|}
name|application
operator|.
name|updateBlacklist
argument_list|(
name|blacklistAdditions
argument_list|,
name|blacklistRemovals
argument_list|)
expr_stmt|;
name|allocation
operator|=
name|application
operator|.
name|getAllocation
argument_list|(
name|getResourceCalculator
argument_list|()
argument_list|,
name|getClusterResource
argument_list|()
argument_list|,
name|getMinimumResourceCapability
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|application
operator|.
name|getWriteLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|updateDemandForQueue
operator|!=
literal|null
operator|&&
operator|!
name|application
operator|.
name|isWaitingForAMContainer
argument_list|()
condition|)
block|{
name|updateDemandForQueue
operator|.
name|getOrderingPolicy
argument_list|()
operator|.
name|demandUpdated
argument_list|(
name|application
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Allocation for application "
operator|+
name|applicationAttemptId
operator|+
literal|" : "
operator|+
name|allocation
operator|+
literal|" with cluster resource : "
operator|+
name|getClusterResource
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|allocation
return|;
block|}
annotation|@
name|Override
annotation|@
name|Lock
argument_list|(
name|Lock
operator|.
name|NoLock
operator|.
name|class
argument_list|)
DECL|method|getQueueInfo (String queueName, boolean includeChildQueues, boolean recursive)
specifier|public
name|QueueInfo
name|getQueueInfo
parameter_list|(
name|String
name|queueName
parameter_list|,
name|boolean
name|includeChildQueues
parameter_list|,
name|boolean
name|recursive
parameter_list|)
throws|throws
name|IOException
block|{
name|CSQueue
name|queue
init|=
literal|null
decl_stmt|;
name|queue
operator|=
name|this
operator|.
name|getQueue
argument_list|(
name|queueName
argument_list|)
expr_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown queue: "
operator|+
name|queueName
argument_list|)
throw|;
block|}
return|return
name|queue
operator|.
name|getQueueInfo
argument_list|(
name|includeChildQueues
argument_list|,
name|recursive
argument_list|)
return|;
block|}
annotation|@
name|Override
annotation|@
name|Lock
argument_list|(
name|Lock
operator|.
name|NoLock
operator|.
name|class
argument_list|)
DECL|method|getQueueUserAclInfo ()
specifier|public
name|List
argument_list|<
name|QueueUserACLInfo
argument_list|>
name|getQueueUserAclInfo
parameter_list|()
block|{
name|UserGroupInformation
name|user
init|=
literal|null
decl_stmt|;
try|try
block|{
name|user
operator|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// should never happen
return|return
operator|new
name|ArrayList
argument_list|<
name|QueueUserACLInfo
argument_list|>
argument_list|()
return|;
block|}
return|return
name|getRootQueue
argument_list|()
operator|.
name|getQueueUserAclInfo
argument_list|(
name|user
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|nodeUpdate (RMNode rmNode)
specifier|protected
name|void
name|nodeUpdate
parameter_list|(
name|RMNode
name|rmNode
parameter_list|)
block|{
name|long
name|begin
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
try|try
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|setLastNodeUpdateTime
argument_list|(
name|Time
operator|.
name|now
argument_list|()
argument_list|)
expr_stmt|;
name|super
operator|.
name|nodeUpdate
argument_list|(
name|rmNode
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// Try to do scheduling
if|if
condition|(
operator|!
name|scheduleAsynchronously
condition|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|ActivitiesLogger
operator|.
name|NODE
operator|.
name|startNodeUpdateRecording
argument_list|(
name|activitiesManager
argument_list|,
name|rmNode
operator|.
name|getNodeID
argument_list|()
argument_list|)
expr_stmt|;
comment|// reset allocation and reservation stats before we start doing any
comment|// work
name|updateSchedulerHealth
argument_list|(
name|lastNodeUpdateTime
argument_list|,
name|rmNode
operator|.
name|getNodeID
argument_list|()
argument_list|,
name|CSAssignment
operator|.
name|NULL_ASSIGNMENT
argument_list|)
expr_stmt|;
name|allocateContainersToNode
argument_list|(
name|rmNode
operator|.
name|getNodeID
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|ActivitiesLogger
operator|.
name|NODE
operator|.
name|finishNodeUpdateRecording
argument_list|(
name|activitiesManager
argument_list|,
name|rmNode
operator|.
name|getNodeID
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
name|long
name|latency
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|begin
decl_stmt|;
name|CapacitySchedulerMetrics
operator|.
name|getMetrics
argument_list|()
operator|.
name|addNodeUpdate
argument_list|(
name|latency
argument_list|)
expr_stmt|;
block|}
comment|/**    * Process resource update on a node.    */
DECL|method|updateNodeAndQueueResource (RMNode nm, ResourceOption resourceOption)
specifier|private
name|void
name|updateNodeAndQueueResource
parameter_list|(
name|RMNode
name|nm
parameter_list|,
name|ResourceOption
name|resourceOption
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|updateNodeResource
argument_list|(
name|nm
argument_list|,
name|resourceOption
argument_list|)
expr_stmt|;
name|Resource
name|clusterResource
init|=
name|getClusterResource
argument_list|()
decl_stmt|;
name|getRootQueue
argument_list|()
operator|.
name|updateClusterResource
argument_list|(
name|clusterResource
argument_list|,
operator|new
name|ResourceLimits
argument_list|(
name|clusterResource
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Process node labels update on a node.    */
DECL|method|updateLabelsOnNode (NodeId nodeId, Set<String> newLabels)
specifier|private
name|void
name|updateLabelsOnNode
parameter_list|(
name|NodeId
name|nodeId
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|newLabels
parameter_list|)
block|{
name|FiCaSchedulerNode
name|node
init|=
name|nodeTracker
operator|.
name|getNode
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|node
condition|)
block|{
return|return;
block|}
comment|// Get new partition, we have only one partition per node
name|String
name|newPartition
decl_stmt|;
if|if
condition|(
name|newLabels
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|newPartition
operator|=
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
expr_stmt|;
block|}
else|else
block|{
name|newPartition
operator|=
name|newLabels
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
comment|// old partition as well
name|String
name|oldPartition
init|=
name|node
operator|.
name|getPartition
argument_list|()
decl_stmt|;
comment|// Update resources of these containers
for|for
control|(
name|RMContainer
name|rmContainer
range|:
name|node
operator|.
name|getCopiedListOfRunningContainers
argument_list|()
control|)
block|{
name|FiCaSchedulerApp
name|application
init|=
name|getApplicationAttempt
argument_list|(
name|rmContainer
operator|.
name|getApplicationAttemptId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|application
condition|)
block|{
name|application
operator|.
name|nodePartitionUpdated
argument_list|(
name|rmContainer
argument_list|,
name|oldPartition
argument_list|,
name|newPartition
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"There's something wrong, some RMContainers running on"
operator|+
literal|" a node, but we cannot find SchedulerApplicationAttempt "
operator|+
literal|"for it. Node="
operator|+
name|node
operator|.
name|getNodeID
argument_list|()
operator|+
literal|" applicationAttemptId="
operator|+
name|rmContainer
operator|.
name|getApplicationAttemptId
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|// Unreserve container on this node
name|RMContainer
name|reservedContainer
init|=
name|node
operator|.
name|getReservedContainer
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|reservedContainer
condition|)
block|{
name|killReservedContainer
argument_list|(
name|reservedContainer
argument_list|)
expr_stmt|;
block|}
comment|// Update node labels after we've done this
name|node
operator|.
name|updateLabels
argument_list|(
name|newLabels
argument_list|)
expr_stmt|;
block|}
DECL|method|updateSchedulerHealth (long now, NodeId nodeId, CSAssignment assignment)
specifier|private
name|void
name|updateSchedulerHealth
parameter_list|(
name|long
name|now
parameter_list|,
name|NodeId
name|nodeId
parameter_list|,
name|CSAssignment
name|assignment
parameter_list|)
block|{
name|List
argument_list|<
name|AssignmentInformation
operator|.
name|AssignmentDetails
argument_list|>
name|allocations
init|=
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getAllocationDetails
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AssignmentInformation
operator|.
name|AssignmentDetails
argument_list|>
name|reservations
init|=
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getReservationDetails
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|allocations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ContainerId
name|allocatedContainerId
init|=
name|allocations
operator|.
name|get
argument_list|(
name|allocations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|containerId
decl_stmt|;
name|String
name|allocatedQueue
init|=
name|allocations
operator|.
name|get
argument_list|(
name|allocations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|queue
decl_stmt|;
name|schedulerHealth
operator|.
name|updateAllocation
argument_list|(
name|now
argument_list|,
name|nodeId
argument_list|,
name|allocatedContainerId
argument_list|,
name|allocatedQueue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|reservations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ContainerId
name|reservedContainerId
init|=
name|reservations
operator|.
name|get
argument_list|(
name|reservations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|containerId
decl_stmt|;
name|String
name|reservedQueue
init|=
name|reservations
operator|.
name|get
argument_list|(
name|reservations
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|queue
decl_stmt|;
name|schedulerHealth
operator|.
name|updateReservation
argument_list|(
name|now
argument_list|,
name|nodeId
argument_list|,
name|reservedContainerId
argument_list|,
name|reservedQueue
argument_list|)
expr_stmt|;
block|}
name|schedulerHealth
operator|.
name|updateSchedulerReservationCounts
argument_list|(
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getNumReservations
argument_list|()
argument_list|)
expr_stmt|;
name|schedulerHealth
operator|.
name|updateSchedulerAllocationCounts
argument_list|(
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getNumAllocations
argument_list|()
argument_list|)
expr_stmt|;
name|schedulerHealth
operator|.
name|updateSchedulerRunDetails
argument_list|(
name|now
argument_list|,
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getAllocated
argument_list|()
argument_list|,
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getReserved
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|canAllocateMore (CSAssignment assignment, int offswitchCount, int assignedContainers)
specifier|private
name|boolean
name|canAllocateMore
parameter_list|(
name|CSAssignment
name|assignment
parameter_list|,
name|int
name|offswitchCount
parameter_list|,
name|int
name|assignedContainers
parameter_list|)
block|{
comment|// Current assignment shouldn't be empty
if|if
condition|(
name|assignment
operator|==
literal|null
operator|||
name|Resources
operator|.
name|equals
argument_list|(
name|assignment
operator|.
name|getResource
argument_list|()
argument_list|,
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// offswitch assignment should be under threshold
if|if
condition|(
name|offswitchCount
operator|>=
name|offswitchPerHeartbeatLimit
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// And it should not be a reserved container
if|if
condition|(
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getNumReservations
argument_list|()
operator|>
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// assignMultipleEnabled should be ON,
comment|// and assignedContainers should be under threshold
return|return
name|assignMultipleEnabled
operator|&&
operator|(
name|maxAssignPerHeartbeat
operator|==
operator|-
literal|1
operator|||
name|assignedContainers
operator|<
name|maxAssignPerHeartbeat
operator|)
return|;
block|}
comment|/**    * We need to make sure when doing allocation, Node should be existed    * And we will construct a {@link CandidateNodeSet} before proceeding    */
DECL|method|allocateContainersToNode (NodeId nodeId, boolean withNodeHeartbeat)
specifier|private
name|void
name|allocateContainersToNode
parameter_list|(
name|NodeId
name|nodeId
parameter_list|,
name|boolean
name|withNodeHeartbeat
parameter_list|)
block|{
name|FiCaSchedulerNode
name|node
init|=
name|getNode
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|node
condition|)
block|{
name|int
name|offswitchCount
init|=
literal|0
decl_stmt|;
name|int
name|assignedContainers
init|=
literal|0
decl_stmt|;
name|CandidateNodeSet
argument_list|<
name|FiCaSchedulerNode
argument_list|>
name|candidates
init|=
operator|new
name|SimpleCandidateNodeSet
argument_list|<>
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|CSAssignment
name|assignment
init|=
name|allocateContainersToNode
argument_list|(
name|candidates
argument_list|,
name|withNodeHeartbeat
argument_list|)
decl_stmt|;
comment|// Only check if we can allocate more container on the same node when
comment|// scheduling is triggered by node heartbeat
if|if
condition|(
literal|null
operator|!=
name|assignment
operator|&&
name|withNodeHeartbeat
condition|)
block|{
if|if
condition|(
name|assignment
operator|.
name|getType
argument_list|()
operator|==
name|NodeType
operator|.
name|OFF_SWITCH
condition|)
block|{
name|offswitchCount
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|Resources
operator|.
name|greaterThan
argument_list|(
name|calculator
argument_list|,
name|getClusterResource
argument_list|()
argument_list|,
name|assignment
operator|.
name|getResource
argument_list|()
argument_list|,
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
condition|)
block|{
name|assignedContainers
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|canAllocateMore
argument_list|(
name|assignment
argument_list|,
name|offswitchCount
argument_list|,
name|assignedContainers
argument_list|)
condition|)
block|{
comment|// Try to see if it is possible to allocate multiple container for
comment|// the same node heartbeat
name|assignment
operator|=
name|allocateContainersToNode
argument_list|(
name|candidates
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|assignment
operator|&&
name|assignment
operator|.
name|getType
argument_list|()
operator|==
name|NodeType
operator|.
name|OFF_SWITCH
condition|)
block|{
name|offswitchCount
operator|++
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|!=
name|assignment
operator|&&
name|Resources
operator|.
name|greaterThan
argument_list|(
name|calculator
argument_list|,
name|getClusterResource
argument_list|()
argument_list|,
name|assignment
operator|.
name|getResource
argument_list|()
argument_list|,
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
condition|)
block|{
name|assignedContainers
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|offswitchCount
operator|>=
name|offswitchPerHeartbeatLimit
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Assigned maximum number of off-switch containers: "
operator|+
name|offswitchCount
operator|+
literal|", assignments so far: "
operator|+
name|assignment
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/*    * Logics of allocate container on a single node (Old behavior)    */
DECL|method|allocateContainerOnSingleNode ( CandidateNodeSet<FiCaSchedulerNode> candidates, FiCaSchedulerNode node, boolean withNodeHeartbeat)
specifier|private
name|CSAssignment
name|allocateContainerOnSingleNode
parameter_list|(
name|CandidateNodeSet
argument_list|<
name|FiCaSchedulerNode
argument_list|>
name|candidates
parameter_list|,
name|FiCaSchedulerNode
name|node
parameter_list|,
name|boolean
name|withNodeHeartbeat
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying to schedule on node: "
operator|+
name|node
operator|.
name|getNodeName
argument_list|()
operator|+
literal|", available: "
operator|+
name|node
operator|.
name|getUnallocatedResource
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Backward compatible way to make sure previous behavior which allocation
comment|// driven by node heartbeat works.
if|if
condition|(
name|getNode
argument_list|(
name|node
operator|.
name|getNodeID
argument_list|()
argument_list|)
operator|!=
name|node
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Trying to schedule on a removed node, please double check, "
operator|+
literal|"nodeId="
operator|+
name|node
operator|.
name|getNodeID
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|CSAssignment
name|assignment
decl_stmt|;
comment|// Assign new containers...
comment|// 1. Check for reserved applications
comment|// 2. Schedule if there are no reservations
name|RMContainer
name|reservedContainer
init|=
name|node
operator|.
name|getReservedContainer
argument_list|()
decl_stmt|;
if|if
condition|(
name|reservedContainer
operator|!=
literal|null
condition|)
block|{
name|FiCaSchedulerApp
name|reservedApplication
init|=
name|getCurrentAttemptForContainer
argument_list|(
name|reservedContainer
operator|.
name|getContainerId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|reservedApplication
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Trying to schedule for a finished app, please double check. nodeId="
operator|+
name|node
operator|.
name|getNodeID
argument_list|()
operator|+
literal|" container="
operator|+
name|reservedContainer
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Try to fulfill the reservation
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying to fulfill reservation for application "
operator|+
name|reservedApplication
operator|.
name|getApplicationId
argument_list|()
operator|+
literal|" on node: "
operator|+
name|node
operator|.
name|getNodeID
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LeafQueue
name|queue
init|=
operator|(
operator|(
name|LeafQueue
operator|)
name|reservedApplication
operator|.
name|getQueue
argument_list|()
operator|)
decl_stmt|;
name|assignment
operator|=
name|queue
operator|.
name|assignContainers
argument_list|(
name|getClusterResource
argument_list|()
argument_list|,
name|candidates
argument_list|,
comment|// TODO, now we only consider limits for parent for non-labeled
comment|// resources, should consider labeled resources as well.
operator|new
name|ResourceLimits
argument_list|(
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|,
name|getClusterResource
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|SchedulingMode
operator|.
name|RESPECT_PARTITION_EXCLUSIVITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|assignment
operator|.
name|isFulfilledReservation
argument_list|()
condition|)
block|{
if|if
condition|(
name|withNodeHeartbeat
condition|)
block|{
comment|// Only update SchedulerHealth in sync scheduling, existing
comment|// Data structure of SchedulerHealth need to be updated for
comment|// Async mode
name|updateSchedulerHealth
argument_list|(
name|lastNodeUpdateTime
argument_list|,
name|node
operator|.
name|getNodeID
argument_list|()
argument_list|,
name|assignment
argument_list|)
expr_stmt|;
block|}
name|schedulerHealth
operator|.
name|updateSchedulerFulfilledReservationCounts
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ActivitiesLogger
operator|.
name|QUEUE
operator|.
name|recordQueueActivity
argument_list|(
name|activitiesManager
argument_list|,
name|node
argument_list|,
name|queue
operator|.
name|getParent
argument_list|()
operator|.
name|getQueueName
argument_list|()
argument_list|,
name|queue
operator|.
name|getQueueName
argument_list|()
argument_list|,
name|ActivityState
operator|.
name|ACCEPTED
argument_list|,
name|ActivityDiagnosticConstant
operator|.
name|EMPTY
argument_list|)
expr_stmt|;
name|ActivitiesLogger
operator|.
name|NODE
operator|.
name|finishAllocatedNodeAllocation
argument_list|(
name|activitiesManager
argument_list|,
name|node
argument_list|,
name|reservedContainer
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|AllocationState
operator|.
name|ALLOCATED_FROM_RESERVED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ActivitiesLogger
operator|.
name|QUEUE
operator|.
name|recordQueueActivity
argument_list|(
name|activitiesManager
argument_list|,
name|node
argument_list|,
name|queue
operator|.
name|getParent
argument_list|()
operator|.
name|getQueueName
argument_list|()
argument_list|,
name|queue
operator|.
name|getQueueName
argument_list|()
argument_list|,
name|ActivityState
operator|.
name|ACCEPTED
argument_list|,
name|ActivityDiagnosticConstant
operator|.
name|EMPTY
argument_list|)
expr_stmt|;
name|ActivitiesLogger
operator|.
name|NODE
operator|.
name|finishAllocatedNodeAllocation
argument_list|(
name|activitiesManager
argument_list|,
name|node
argument_list|,
name|reservedContainer
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|AllocationState
operator|.
name|SKIPPED
argument_list|)
expr_stmt|;
block|}
name|assignment
operator|.
name|setSchedulingMode
argument_list|(
name|SchedulingMode
operator|.
name|RESPECT_PARTITION_EXCLUSIVITY
argument_list|)
expr_stmt|;
name|submitResourceCommitRequest
argument_list|(
name|getClusterResource
argument_list|()
argument_list|,
name|assignment
argument_list|)
expr_stmt|;
block|}
comment|// Do not schedule if there are any reservations to fulfill on the node
if|if
condition|(
name|node
operator|.
name|getReservedContainer
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skipping scheduling since node "
operator|+
name|node
operator|.
name|getNodeID
argument_list|()
operator|+
literal|" is reserved by application "
operator|+
name|node
operator|.
name|getReservedContainer
argument_list|()
operator|.
name|getContainerId
argument_list|()
operator|.
name|getApplicationAttemptId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|// First check if we can schedule
comment|// When this time look at one node only, try schedule if the node
comment|// has any available or killable resource
if|if
condition|(
name|calculator
operator|.
name|computeAvailableContainers
argument_list|(
name|Resources
operator|.
name|add
argument_list|(
name|node
operator|.
name|getUnallocatedResource
argument_list|()
argument_list|,
name|node
operator|.
name|getTotalKillableResources
argument_list|()
argument_list|)
argument_list|,
name|minimumAllocation
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"This node or this node partition doesn't have available or"
operator|+
literal|"killable resource"
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
return|return
name|allocateOrReserveNewContainers
argument_list|(
name|candidates
argument_list|,
name|withNodeHeartbeat
argument_list|)
return|;
block|}
DECL|method|allocateOrReserveNewContainers ( CandidateNodeSet<FiCaSchedulerNode> candidates, boolean withNodeHeartbeat)
specifier|private
name|CSAssignment
name|allocateOrReserveNewContainers
parameter_list|(
name|CandidateNodeSet
argument_list|<
name|FiCaSchedulerNode
argument_list|>
name|candidates
parameter_list|,
name|boolean
name|withNodeHeartbeat
parameter_list|)
block|{
name|CSAssignment
name|assignment
init|=
name|getRootQueue
argument_list|()
operator|.
name|assignContainers
argument_list|(
name|getClusterResource
argument_list|()
argument_list|,
name|candidates
argument_list|,
operator|new
name|ResourceLimits
argument_list|(
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|candidates
operator|.
name|getPartition
argument_list|()
argument_list|,
name|getClusterResource
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|SchedulingMode
operator|.
name|RESPECT_PARTITION_EXCLUSIVITY
argument_list|)
decl_stmt|;
name|assignment
operator|.
name|setSchedulingMode
argument_list|(
name|SchedulingMode
operator|.
name|RESPECT_PARTITION_EXCLUSIVITY
argument_list|)
expr_stmt|;
name|submitResourceCommitRequest
argument_list|(
name|getClusterResource
argument_list|()
argument_list|,
name|assignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|Resources
operator|.
name|greaterThan
argument_list|(
name|calculator
argument_list|,
name|getClusterResource
argument_list|()
argument_list|,
name|assignment
operator|.
name|getResource
argument_list|()
argument_list|,
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|withNodeHeartbeat
condition|)
block|{
name|updateSchedulerHealth
argument_list|(
name|lastNodeUpdateTime
argument_list|,
name|CandidateNodeSetUtils
operator|.
name|getSingleNode
argument_list|(
name|candidates
argument_list|)
operator|.
name|getNodeID
argument_list|()
argument_list|,
name|assignment
argument_list|)
expr_stmt|;
block|}
return|return
name|assignment
return|;
block|}
comment|// Only do non-exclusive allocation when node has node-labels.
if|if
condition|(
name|StringUtils
operator|.
name|equals
argument_list|(
name|candidates
operator|.
name|getPartition
argument_list|()
argument_list|,
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Only do non-exclusive allocation when the node-label supports that
try|try
block|{
if|if
condition|(
name|rmContext
operator|.
name|getNodeLabelManager
argument_list|()
operator|.
name|isExclusiveNodeLabel
argument_list|(
name|candidates
operator|.
name|getPartition
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception when trying to get exclusivity of node label="
operator|+
name|candidates
operator|.
name|getPartition
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Try to use NON_EXCLUSIVE
name|assignment
operator|=
name|getRootQueue
argument_list|()
operator|.
name|assignContainers
argument_list|(
name|getClusterResource
argument_list|()
argument_list|,
name|candidates
argument_list|,
comment|// TODO, now we only consider limits for parent for non-labeled
comment|// resources, should consider labeled resources as well.
operator|new
name|ResourceLimits
argument_list|(
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|,
name|getClusterResource
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|SchedulingMode
operator|.
name|IGNORE_PARTITION_EXCLUSIVITY
argument_list|)
expr_stmt|;
name|assignment
operator|.
name|setSchedulingMode
argument_list|(
name|SchedulingMode
operator|.
name|IGNORE_PARTITION_EXCLUSIVITY
argument_list|)
expr_stmt|;
name|submitResourceCommitRequest
argument_list|(
name|getClusterResource
argument_list|()
argument_list|,
name|assignment
argument_list|)
expr_stmt|;
return|return
name|assignment
return|;
block|}
comment|/*    * New behavior, allocate containers considering multiple nodes    */
DECL|method|allocateContainersOnMultiNodes ( CandidateNodeSet<FiCaSchedulerNode> candidates)
specifier|private
name|CSAssignment
name|allocateContainersOnMultiNodes
parameter_list|(
name|CandidateNodeSet
argument_list|<
name|FiCaSchedulerNode
argument_list|>
name|candidates
parameter_list|)
block|{
comment|// When this time look at multiple nodes, try schedule if the
comment|// partition has any available resource or killable resource
if|if
condition|(
name|getRootQueue
argument_list|()
operator|.
name|getQueueCapacities
argument_list|()
operator|.
name|getUsedCapacity
argument_list|(
name|candidates
operator|.
name|getPartition
argument_list|()
argument_list|)
operator|>=
literal|1.0f
operator|&&
name|preemptionManager
operator|.
name|getKillableResource
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|ROOT
argument_list|,
name|candidates
operator|.
name|getPartition
argument_list|()
argument_list|)
operator|==
name|Resources
operator|.
name|none
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"This node or this node partition doesn't have available or"
operator|+
literal|"killable resource"
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
return|return
name|allocateOrReserveNewContainers
argument_list|(
name|candidates
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|allocateContainersToNode ( CandidateNodeSet<FiCaSchedulerNode> candidates, boolean withNodeHeartbeat)
name|CSAssignment
name|allocateContainersToNode
parameter_list|(
name|CandidateNodeSet
argument_list|<
name|FiCaSchedulerNode
argument_list|>
name|candidates
parameter_list|,
name|boolean
name|withNodeHeartbeat
parameter_list|)
block|{
if|if
condition|(
name|rmContext
operator|.
name|isWorkPreservingRecoveryEnabled
argument_list|()
operator|&&
operator|!
name|rmContext
operator|.
name|isSchedulerReadyForAllocatingContainers
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
comment|// Backward compatible way to make sure previous behavior which allocation
comment|// driven by node heartbeat works.
name|FiCaSchedulerNode
name|node
init|=
name|CandidateNodeSetUtils
operator|.
name|getSingleNode
argument_list|(
name|candidates
argument_list|)
decl_stmt|;
comment|// We have two different logics to handle allocation on single node / multi
comment|// nodes.
name|CSAssignment
name|assignment
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|node
condition|)
block|{
name|assignment
operator|=
name|allocateContainerOnSingleNode
argument_list|(
name|candidates
argument_list|,
name|node
argument_list|,
name|withNodeHeartbeat
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assignment
operator|=
name|allocateContainersOnMultiNodes
argument_list|(
name|candidates
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|assignment
operator|!=
literal|null
operator|&&
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|!=
literal|null
operator|&&
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getNumAllocations
argument_list|()
operator|>
literal|0
condition|)
block|{
name|long
name|allocateTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTime
decl_stmt|;
name|CapacitySchedulerMetrics
operator|.
name|getMetrics
argument_list|()
operator|.
name|addAllocate
argument_list|(
name|allocateTime
argument_list|)
expr_stmt|;
block|}
return|return
name|assignment
return|;
block|}
annotation|@
name|Override
DECL|method|handle (SchedulerEvent event)
specifier|public
name|void
name|handle
parameter_list|(
name|SchedulerEvent
name|event
parameter_list|)
block|{
switch|switch
condition|(
name|event
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|NODE_ADDED
case|:
block|{
name|NodeAddedSchedulerEvent
name|nodeAddedEvent
init|=
operator|(
name|NodeAddedSchedulerEvent
operator|)
name|event
decl_stmt|;
name|addNode
argument_list|(
name|nodeAddedEvent
operator|.
name|getAddedRMNode
argument_list|()
argument_list|)
expr_stmt|;
name|recoverContainersOnNode
argument_list|(
name|nodeAddedEvent
operator|.
name|getContainerReports
argument_list|()
argument_list|,
name|nodeAddedEvent
operator|.
name|getAddedRMNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NODE_REMOVED
case|:
block|{
name|NodeRemovedSchedulerEvent
name|nodeRemovedEvent
init|=
operator|(
name|NodeRemovedSchedulerEvent
operator|)
name|event
decl_stmt|;
name|removeNode
argument_list|(
name|nodeRemovedEvent
operator|.
name|getRemovedRMNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NODE_RESOURCE_UPDATE
case|:
block|{
name|NodeResourceUpdateSchedulerEvent
name|nodeResourceUpdatedEvent
init|=
operator|(
name|NodeResourceUpdateSchedulerEvent
operator|)
name|event
decl_stmt|;
name|updateNodeAndQueueResource
argument_list|(
name|nodeResourceUpdatedEvent
operator|.
name|getRMNode
argument_list|()
argument_list|,
name|nodeResourceUpdatedEvent
operator|.
name|getResourceOption
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NODE_LABELS_UPDATE
case|:
block|{
name|NodeLabelsUpdateSchedulerEvent
name|labelUpdateEvent
init|=
operator|(
name|NodeLabelsUpdateSchedulerEvent
operator|)
name|event
decl_stmt|;
name|updateNodeLabelsAndQueueResource
argument_list|(
name|labelUpdateEvent
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NODE_UPDATE
case|:
block|{
name|NodeUpdateSchedulerEvent
name|nodeUpdatedEvent
init|=
operator|(
name|NodeUpdateSchedulerEvent
operator|)
name|event
decl_stmt|;
name|nodeUpdate
argument_list|(
name|nodeUpdatedEvent
operator|.
name|getRMNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|APP_ADDED
case|:
block|{
name|AppAddedSchedulerEvent
name|appAddedEvent
init|=
operator|(
name|AppAddedSchedulerEvent
operator|)
name|event
decl_stmt|;
name|String
name|queueName
init|=
name|resolveReservationQueueName
argument_list|(
name|appAddedEvent
operator|.
name|getQueue
argument_list|()
argument_list|,
name|appAddedEvent
operator|.
name|getApplicationId
argument_list|()
argument_list|,
name|appAddedEvent
operator|.
name|getReservationID
argument_list|()
argument_list|,
name|appAddedEvent
operator|.
name|getIsAppRecovering
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|queueName
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|appAddedEvent
operator|.
name|getIsAppRecovering
argument_list|()
condition|)
block|{
name|addApplication
argument_list|(
name|appAddedEvent
operator|.
name|getApplicationId
argument_list|()
argument_list|,
name|queueName
argument_list|,
name|appAddedEvent
operator|.
name|getUser
argument_list|()
argument_list|,
name|appAddedEvent
operator|.
name|getApplicatonPriority
argument_list|()
argument_list|,
name|appAddedEvent
operator|.
name|getPlacementContext
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addApplicationOnRecovery
argument_list|(
name|appAddedEvent
operator|.
name|getApplicationId
argument_list|()
argument_list|,
name|queueName
argument_list|,
name|appAddedEvent
operator|.
name|getUser
argument_list|()
argument_list|,
name|appAddedEvent
operator|.
name|getApplicatonPriority
argument_list|()
argument_list|,
name|appAddedEvent
operator|.
name|getPlacementContext
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|APP_REMOVED
case|:
block|{
name|AppRemovedSchedulerEvent
name|appRemovedEvent
init|=
operator|(
name|AppRemovedSchedulerEvent
operator|)
name|event
decl_stmt|;
name|doneApplication
argument_list|(
name|appRemovedEvent
operator|.
name|getApplicationID
argument_list|()
argument_list|,
name|appRemovedEvent
operator|.
name|getFinalState
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|APP_ATTEMPT_ADDED
case|:
block|{
name|AppAttemptAddedSchedulerEvent
name|appAttemptAddedEvent
init|=
operator|(
name|AppAttemptAddedSchedulerEvent
operator|)
name|event
decl_stmt|;
name|addApplicationAttempt
argument_list|(
name|appAttemptAddedEvent
operator|.
name|getApplicationAttemptId
argument_list|()
argument_list|,
name|appAttemptAddedEvent
operator|.
name|getTransferStateFromPreviousAttempt
argument_list|()
argument_list|,
name|appAttemptAddedEvent
operator|.
name|getIsAttemptRecovering
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|APP_ATTEMPT_REMOVED
case|:
block|{
name|AppAttemptRemovedSchedulerEvent
name|appAttemptRemovedEvent
init|=
operator|(
name|AppAttemptRemovedSchedulerEvent
operator|)
name|event
decl_stmt|;
name|doneApplicationAttempt
argument_list|(
name|appAttemptRemovedEvent
operator|.
name|getApplicationAttemptID
argument_list|()
argument_list|,
name|appAttemptRemovedEvent
operator|.
name|getFinalAttemptState
argument_list|()
argument_list|,
name|appAttemptRemovedEvent
operator|.
name|getKeepContainersAcrossAppAttempts
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONTAINER_EXPIRED
case|:
block|{
name|ContainerExpiredSchedulerEvent
name|containerExpiredEvent
init|=
operator|(
name|ContainerExpiredSchedulerEvent
operator|)
name|event
decl_stmt|;
name|ContainerId
name|containerId
init|=
name|containerExpiredEvent
operator|.
name|getContainerId
argument_list|()
decl_stmt|;
if|if
condition|(
name|containerExpiredEvent
operator|.
name|isIncrease
argument_list|()
condition|)
block|{
name|rollbackContainerUpdate
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|completedContainer
argument_list|(
name|getRMContainer
argument_list|(
name|containerId
argument_list|)
argument_list|,
name|SchedulerUtils
operator|.
name|createAbnormalContainerStatus
argument_list|(
name|containerId
argument_list|,
name|SchedulerUtils
operator|.
name|EXPIRED_CONTAINER
argument_list|)
argument_list|,
name|RMContainerEventType
operator|.
name|EXPIRE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|RELEASE_CONTAINER
case|:
block|{
name|RMContainer
name|container
init|=
operator|(
operator|(
name|ReleaseContainerEvent
operator|)
name|event
operator|)
operator|.
name|getContainer
argument_list|()
decl_stmt|;
name|completedContainer
argument_list|(
name|container
argument_list|,
name|SchedulerUtils
operator|.
name|createAbnormalContainerStatus
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|SchedulerUtils
operator|.
name|RELEASED_CONTAINER
argument_list|)
argument_list|,
name|RMContainerEventType
operator|.
name|RELEASED
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|KILL_RESERVED_CONTAINER
case|:
block|{
name|ContainerPreemptEvent
name|killReservedContainerEvent
init|=
operator|(
name|ContainerPreemptEvent
operator|)
name|event
decl_stmt|;
name|RMContainer
name|container
init|=
name|killReservedContainerEvent
operator|.
name|getContainer
argument_list|()
decl_stmt|;
name|killReservedContainer
argument_list|(
name|container
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MARK_CONTAINER_FOR_PREEMPTION
case|:
block|{
name|ContainerPreemptEvent
name|preemptContainerEvent
init|=
operator|(
name|ContainerPreemptEvent
operator|)
name|event
decl_stmt|;
name|ApplicationAttemptId
name|aid
init|=
name|preemptContainerEvent
operator|.
name|getAppId
argument_list|()
decl_stmt|;
name|RMContainer
name|containerToBePreempted
init|=
name|preemptContainerEvent
operator|.
name|getContainer
argument_list|()
decl_stmt|;
name|markContainerForPreemption
argument_list|(
name|aid
argument_list|,
name|containerToBePreempted
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MARK_CONTAINER_FOR_KILLABLE
case|:
block|{
name|ContainerPreemptEvent
name|containerKillableEvent
init|=
operator|(
name|ContainerPreemptEvent
operator|)
name|event
decl_stmt|;
name|RMContainer
name|killableContainer
init|=
name|containerKillableEvent
operator|.
name|getContainer
argument_list|()
decl_stmt|;
name|markContainerForKillable
argument_list|(
name|killableContainer
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MARK_CONTAINER_FOR_NONKILLABLE
case|:
block|{
if|if
condition|(
name|isLazyPreemptionEnabled
condition|)
block|{
name|ContainerPreemptEvent
name|cancelKillContainerEvent
init|=
operator|(
name|ContainerPreemptEvent
operator|)
name|event
decl_stmt|;
name|markContainerForNonKillable
argument_list|(
name|cancelKillContainerEvent
operator|.
name|getContainer
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|MANAGE_QUEUE
case|:
block|{
name|QueueManagementChangeEvent
name|queueManagementChangeEvent
init|=
operator|(
name|QueueManagementChangeEvent
operator|)
name|event
decl_stmt|;
name|ParentQueue
name|parentQueue
init|=
name|queueManagementChangeEvent
operator|.
name|getParentQueue
argument_list|()
decl_stmt|;
try|try
block|{
specifier|final
name|List
argument_list|<
name|QueueManagementChange
argument_list|>
name|queueManagementChanges
init|=
name|queueManagementChangeEvent
operator|.
name|getQueueManagementChanges
argument_list|()
decl_stmt|;
operator|(
operator|(
name|ManagedParentQueue
operator|)
name|parentQueue
operator|)
operator|.
name|validateAndApplyQueueManagementChanges
argument_list|(
name|queueManagementChanges
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SchedulerDynamicEditException
name|sde
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Queue Management Change event cannot be applied for "
operator|+
literal|"parent queue : "
operator|+
name|parentQueue
operator|.
name|getQueueName
argument_list|()
argument_list|,
name|sde
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Queue Management Change event cannot be applied for "
operator|+
literal|"parent queue : "
operator|+
name|parentQueue
operator|.
name|getQueueName
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|LOG
operator|.
name|error
argument_list|(
literal|"Invalid eventtype "
operator|+
name|event
operator|.
name|getType
argument_list|()
operator|+
literal|". Ignoring!"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Process node labels update.    */
DECL|method|updateNodeLabelsAndQueueResource ( NodeLabelsUpdateSchedulerEvent labelUpdateEvent)
specifier|private
name|void
name|updateNodeLabelsAndQueueResource
parameter_list|(
name|NodeLabelsUpdateSchedulerEvent
name|labelUpdateEvent
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|NodeId
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|labelUpdateEvent
operator|.
name|getUpdatedNodeToLabels
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|NodeId
name|id
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|labels
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|updateLabelsOnNode
argument_list|(
name|id
argument_list|,
name|labels
argument_list|)
expr_stmt|;
block|}
name|Resource
name|clusterResource
init|=
name|getClusterResource
argument_list|()
decl_stmt|;
name|getRootQueue
argument_list|()
operator|.
name|updateClusterResource
argument_list|(
name|clusterResource
argument_list|,
operator|new
name|ResourceLimits
argument_list|(
name|clusterResource
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|addNode (RMNode nodeManager)
specifier|private
name|void
name|addNode
parameter_list|(
name|RMNode
name|nodeManager
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|FiCaSchedulerNode
name|schedulerNode
init|=
operator|new
name|FiCaSchedulerNode
argument_list|(
name|nodeManager
argument_list|,
name|usePortForNodeName
argument_list|,
name|nodeManager
operator|.
name|getNodeLabels
argument_list|()
argument_list|)
decl_stmt|;
name|nodeTracker
operator|.
name|addNode
argument_list|(
name|schedulerNode
argument_list|)
expr_stmt|;
comment|// update this node to node label manager
if|if
condition|(
name|labelManager
operator|!=
literal|null
condition|)
block|{
name|labelManager
operator|.
name|activateNode
argument_list|(
name|nodeManager
operator|.
name|getNodeID
argument_list|()
argument_list|,
name|schedulerNode
operator|.
name|getTotalResource
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Resource
name|clusterResource
init|=
name|getClusterResource
argument_list|()
decl_stmt|;
name|getRootQueue
argument_list|()
operator|.
name|updateClusterResource
argument_list|(
name|clusterResource
argument_list|,
operator|new
name|ResourceLimits
argument_list|(
name|clusterResource
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Added node "
operator|+
name|nodeManager
operator|.
name|getNodeAddress
argument_list|()
operator|+
literal|" clusterResource: "
operator|+
name|clusterResource
argument_list|)
expr_stmt|;
if|if
condition|(
name|scheduleAsynchronously
operator|&&
name|getNumClusterNodes
argument_list|()
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|AsyncScheduleThread
name|t
range|:
name|asyncSchedulerThreads
control|)
block|{
name|t
operator|.
name|beginSchedule
argument_list|()
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|removeNode (RMNode nodeInfo)
specifier|private
name|void
name|removeNode
parameter_list|(
name|RMNode
name|nodeInfo
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// update this node to node label manager
if|if
condition|(
name|labelManager
operator|!=
literal|null
condition|)
block|{
name|labelManager
operator|.
name|deactivateNode
argument_list|(
name|nodeInfo
operator|.
name|getNodeID
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|NodeId
name|nodeId
init|=
name|nodeInfo
operator|.
name|getNodeID
argument_list|()
decl_stmt|;
name|FiCaSchedulerNode
name|node
init|=
name|nodeTracker
operator|.
name|getNode
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Attempting to remove non-existent node "
operator|+
name|nodeId
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Remove running containers
name|List
argument_list|<
name|RMContainer
argument_list|>
name|runningContainers
init|=
name|node
operator|.
name|getCopiedListOfRunningContainers
argument_list|()
decl_stmt|;
for|for
control|(
name|RMContainer
name|container
range|:
name|runningContainers
control|)
block|{
name|super
operator|.
name|completedContainer
argument_list|(
name|container
argument_list|,
name|SchedulerUtils
operator|.
name|createAbnormalContainerStatus
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|SchedulerUtils
operator|.
name|LOST_CONTAINER
argument_list|)
argument_list|,
name|RMContainerEventType
operator|.
name|KILL
argument_list|)
expr_stmt|;
block|}
comment|// Remove reservations, if any
name|RMContainer
name|reservedContainer
init|=
name|node
operator|.
name|getReservedContainer
argument_list|()
decl_stmt|;
if|if
condition|(
name|reservedContainer
operator|!=
literal|null
condition|)
block|{
name|super
operator|.
name|completedContainer
argument_list|(
name|reservedContainer
argument_list|,
name|SchedulerUtils
operator|.
name|createAbnormalContainerStatus
argument_list|(
name|reservedContainer
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|SchedulerUtils
operator|.
name|LOST_CONTAINER
argument_list|)
argument_list|,
name|RMContainerEventType
operator|.
name|KILL
argument_list|)
expr_stmt|;
block|}
name|nodeTracker
operator|.
name|removeNode
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
name|Resource
name|clusterResource
init|=
name|getClusterResource
argument_list|()
decl_stmt|;
name|getRootQueue
argument_list|()
operator|.
name|updateClusterResource
argument_list|(
name|clusterResource
argument_list|,
operator|new
name|ResourceLimits
argument_list|(
name|clusterResource
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|numNodes
init|=
name|nodeTracker
operator|.
name|nodeCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|scheduleAsynchronously
operator|&&
name|numNodes
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|AsyncScheduleThread
name|t
range|:
name|asyncSchedulerThreads
control|)
block|{
name|t
operator|.
name|suspendSchedule
argument_list|()
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Removed node "
operator|+
name|nodeInfo
operator|.
name|getNodeAddress
argument_list|()
operator|+
literal|" clusterResource: "
operator|+
name|getClusterResource
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|completedContainerInternal ( RMContainer rmContainer, ContainerStatus containerStatus, RMContainerEventType event)
specifier|protected
name|void
name|completedContainerInternal
parameter_list|(
name|RMContainer
name|rmContainer
parameter_list|,
name|ContainerStatus
name|containerStatus
parameter_list|,
name|RMContainerEventType
name|event
parameter_list|)
block|{
name|Container
name|container
init|=
name|rmContainer
operator|.
name|getContainer
argument_list|()
decl_stmt|;
name|ContainerId
name|containerId
init|=
name|container
operator|.
name|getId
argument_list|()
decl_stmt|;
comment|// Get the application for the finished container
name|FiCaSchedulerApp
name|application
init|=
name|getCurrentAttemptForContainer
argument_list|(
name|container
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|ApplicationId
name|appId
init|=
name|containerId
operator|.
name|getApplicationAttemptId
argument_list|()
operator|.
name|getApplicationId
argument_list|()
decl_stmt|;
if|if
condition|(
name|application
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Container "
operator|+
name|container
operator|+
literal|" of"
operator|+
literal|" finished application "
operator|+
name|appId
operator|+
literal|" completed with event "
operator|+
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Get the node on which the container was allocated
name|FiCaSchedulerNode
name|node
init|=
name|getNode
argument_list|(
name|container
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|node
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Container "
operator|+
name|container
operator|+
literal|" of"
operator|+
literal|" removed node "
operator|+
name|container
operator|.
name|getNodeId
argument_list|()
operator|+
literal|" completed with event "
operator|+
name|event
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Inform the queue
name|LeafQueue
name|queue
init|=
operator|(
name|LeafQueue
operator|)
name|application
operator|.
name|getQueue
argument_list|()
decl_stmt|;
name|queue
operator|.
name|completedContainer
argument_list|(
name|getClusterResource
argument_list|()
argument_list|,
name|application
argument_list|,
name|node
argument_list|,
name|rmContainer
argument_list|,
name|containerStatus
argument_list|,
name|event
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|ContainerExitStatus
operator|.
name|PREEMPTED
operator|==
name|containerStatus
operator|.
name|getExitStatus
argument_list|()
condition|)
block|{
name|updateQueuePreemptionMetrics
argument_list|(
name|queue
argument_list|,
name|rmContainer
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|updateQueuePreemptionMetrics ( CSQueue queue, RMContainer rmc)
specifier|private
name|void
name|updateQueuePreemptionMetrics
parameter_list|(
name|CSQueue
name|queue
parameter_list|,
name|RMContainer
name|rmc
parameter_list|)
block|{
name|QueueMetrics
name|qMetrics
init|=
name|queue
operator|.
name|getMetrics
argument_list|()
decl_stmt|;
name|long
name|usedMillis
init|=
name|rmc
operator|.
name|getFinishTime
argument_list|()
operator|-
name|rmc
operator|.
name|getCreationTime
argument_list|()
decl_stmt|;
name|Resource
name|containerResource
init|=
name|rmc
operator|.
name|getAllocatedResource
argument_list|()
decl_stmt|;
name|qMetrics
operator|.
name|preemptContainer
argument_list|()
expr_stmt|;
name|long
name|mbSeconds
init|=
operator|(
name|containerResource
operator|.
name|getMemorySize
argument_list|()
operator|*
name|usedMillis
operator|)
operator|/
name|DateUtils
operator|.
name|MILLIS_PER_SECOND
decl_stmt|;
name|long
name|vcSeconds
init|=
operator|(
name|containerResource
operator|.
name|getVirtualCores
argument_list|()
operator|*
name|usedMillis
operator|)
operator|/
name|DateUtils
operator|.
name|MILLIS_PER_SECOND
decl_stmt|;
name|qMetrics
operator|.
name|updatePreemptedMemoryMBSeconds
argument_list|(
name|mbSeconds
argument_list|)
expr_stmt|;
name|qMetrics
operator|.
name|updatePreemptedVcoreSeconds
argument_list|(
name|vcSeconds
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Lock
argument_list|(
name|Lock
operator|.
name|NoLock
operator|.
name|class
argument_list|)
annotation|@
name|VisibleForTesting
annotation|@
name|Override
DECL|method|getApplicationAttempt ( ApplicationAttemptId applicationAttemptId)
specifier|public
name|FiCaSchedulerApp
name|getApplicationAttempt
parameter_list|(
name|ApplicationAttemptId
name|applicationAttemptId
parameter_list|)
block|{
return|return
name|super
operator|.
name|getApplicationAttempt
argument_list|(
name|applicationAttemptId
argument_list|)
return|;
block|}
annotation|@
name|Lock
argument_list|(
name|Lock
operator|.
name|NoLock
operator|.
name|class
argument_list|)
DECL|method|getNode (NodeId nodeId)
specifier|public
name|FiCaSchedulerNode
name|getNode
parameter_list|(
name|NodeId
name|nodeId
parameter_list|)
block|{
return|return
name|nodeTracker
operator|.
name|getNode
argument_list|(
name|nodeId
argument_list|)
return|;
block|}
annotation|@
name|Lock
argument_list|(
name|Lock
operator|.
name|NoLock
operator|.
name|class
argument_list|)
DECL|method|getAllNodes ()
specifier|public
name|List
argument_list|<
name|FiCaSchedulerNode
argument_list|>
name|getAllNodes
parameter_list|()
block|{
return|return
name|nodeTracker
operator|.
name|getAllNodes
argument_list|()
return|;
block|}
annotation|@
name|Override
annotation|@
name|Lock
argument_list|(
name|Lock
operator|.
name|NoLock
operator|.
name|class
argument_list|)
DECL|method|recover (RMState state)
specifier|public
name|void
name|recover
parameter_list|(
name|RMState
name|state
parameter_list|)
throws|throws
name|Exception
block|{
comment|// NOT IMPLEMENTED
block|}
annotation|@
name|Override
DECL|method|killReservedContainer (RMContainer container)
specifier|public
name|void
name|killReservedContainer
parameter_list|(
name|RMContainer
name|container
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|SchedulerEventType
operator|.
name|KILL_RESERVED_CONTAINER
operator|+
literal|":"
operator|+
name|container
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// To think: What happens if this is no longer a reserved container, for
comment|// e.g if the reservation became an allocation.
name|super
operator|.
name|completedContainer
argument_list|(
name|container
argument_list|,
name|SchedulerUtils
operator|.
name|createAbnormalContainerStatus
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|SchedulerUtils
operator|.
name|UNRESERVED_CONTAINER
argument_list|)
argument_list|,
name|RMContainerEventType
operator|.
name|KILL
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|markContainerForPreemption (ApplicationAttemptId aid, RMContainer cont)
specifier|public
name|void
name|markContainerForPreemption
parameter_list|(
name|ApplicationAttemptId
name|aid
parameter_list|,
name|RMContainer
name|cont
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|SchedulerEventType
operator|.
name|MARK_CONTAINER_FOR_PREEMPTION
operator|+
literal|": appAttempt:"
operator|+
name|aid
operator|.
name|toString
argument_list|()
operator|+
literal|" container: "
operator|+
name|cont
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|FiCaSchedulerApp
name|app
init|=
name|getApplicationAttempt
argument_list|(
name|aid
argument_list|)
decl_stmt|;
if|if
condition|(
name|app
operator|!=
literal|null
condition|)
block|{
name|app
operator|.
name|markContainerForPreemption
argument_list|(
name|cont
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
annotation|@
name|Override
DECL|method|killContainer (RMContainer container)
specifier|public
name|void
name|killContainer
parameter_list|(
name|RMContainer
name|container
parameter_list|)
block|{
name|markContainerForKillable
argument_list|(
name|container
argument_list|)
expr_stmt|;
block|}
DECL|method|markContainerForKillable ( RMContainer killableContainer)
specifier|public
name|void
name|markContainerForKillable
parameter_list|(
name|RMContainer
name|killableContainer
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|SchedulerEventType
operator|.
name|MARK_CONTAINER_FOR_KILLABLE
operator|+
literal|": container"
operator|+
name|killableContainer
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isLazyPreemptionEnabled
condition|)
block|{
name|super
operator|.
name|completedContainer
argument_list|(
name|killableContainer
argument_list|,
name|SchedulerUtils
operator|.
name|createPreemptedContainerStatus
argument_list|(
name|killableContainer
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|SchedulerUtils
operator|.
name|PREEMPTED_CONTAINER
argument_list|)
argument_list|,
name|RMContainerEventType
operator|.
name|KILL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FiCaSchedulerNode
name|node
init|=
operator|(
name|FiCaSchedulerNode
operator|)
name|getSchedulerNode
argument_list|(
name|killableContainer
operator|.
name|getAllocatedNode
argument_list|()
argument_list|)
decl_stmt|;
name|FiCaSchedulerApp
name|application
init|=
name|getCurrentAttemptForContainer
argument_list|(
name|killableContainer
operator|.
name|getContainerId
argument_list|()
argument_list|)
decl_stmt|;
name|node
operator|.
name|markContainerToKillable
argument_list|(
name|killableContainer
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
comment|// notify PreemptionManager
comment|// Get the application for the finished container
if|if
condition|(
literal|null
operator|!=
name|application
condition|)
block|{
name|String
name|leafQueueName
init|=
name|application
operator|.
name|getCSLeafQueue
argument_list|()
operator|.
name|getQueueName
argument_list|()
decl_stmt|;
name|getPreemptionManager
argument_list|()
operator|.
name|addKillableContainer
argument_list|(
operator|new
name|KillableContainer
argument_list|(
name|killableContainer
argument_list|,
name|node
operator|.
name|getPartition
argument_list|()
argument_list|,
name|leafQueueName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|markContainerForNonKillable ( RMContainer nonKillableContainer)
specifier|private
name|void
name|markContainerForNonKillable
parameter_list|(
name|RMContainer
name|nonKillableContainer
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|SchedulerEventType
operator|.
name|MARK_CONTAINER_FOR_NONKILLABLE
operator|+
literal|": container"
operator|+
name|nonKillableContainer
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|FiCaSchedulerNode
name|node
init|=
operator|(
name|FiCaSchedulerNode
operator|)
name|getSchedulerNode
argument_list|(
name|nonKillableContainer
operator|.
name|getAllocatedNode
argument_list|()
argument_list|)
decl_stmt|;
name|FiCaSchedulerApp
name|application
init|=
name|getCurrentAttemptForContainer
argument_list|(
name|nonKillableContainer
operator|.
name|getContainerId
argument_list|()
argument_list|)
decl_stmt|;
name|node
operator|.
name|markContainerToNonKillable
argument_list|(
name|nonKillableContainer
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
comment|// notify PreemptionManager
comment|// Get the application for the finished container
if|if
condition|(
literal|null
operator|!=
name|application
condition|)
block|{
name|String
name|leafQueueName
init|=
name|application
operator|.
name|getCSLeafQueue
argument_list|()
operator|.
name|getQueueName
argument_list|()
decl_stmt|;
name|getPreemptionManager
argument_list|()
operator|.
name|removeKillableContainer
argument_list|(
operator|new
name|KillableContainer
argument_list|(
name|nonKillableContainer
argument_list|,
name|node
operator|.
name|getPartition
argument_list|()
argument_list|,
name|leafQueueName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|checkAccess (UserGroupInformation callerUGI, QueueACL acl, String queueName)
specifier|public
name|boolean
name|checkAccess
parameter_list|(
name|UserGroupInformation
name|callerUGI
parameter_list|,
name|QueueACL
name|acl
parameter_list|,
name|String
name|queueName
parameter_list|)
block|{
name|CSQueue
name|queue
init|=
name|getQueue
argument_list|(
name|queueName
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ACL not found for queue access-type "
operator|+
name|acl
operator|+
literal|" for queue "
operator|+
name|queueName
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
return|return
name|queue
operator|.
name|hasAccess
argument_list|(
name|acl
argument_list|,
name|callerUGI
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getAppsInQueue (String queueName)
specifier|public
name|List
argument_list|<
name|ApplicationAttemptId
argument_list|>
name|getAppsInQueue
parameter_list|(
name|String
name|queueName
parameter_list|)
block|{
name|CSQueue
name|queue
init|=
name|getQueue
argument_list|(
name|queueName
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|ApplicationAttemptId
argument_list|>
name|apps
init|=
operator|new
name|ArrayList
argument_list|<
name|ApplicationAttemptId
argument_list|>
argument_list|()
decl_stmt|;
name|queue
operator|.
name|collectSchedulerApplications
argument_list|(
name|apps
argument_list|)
expr_stmt|;
return|return
name|apps
return|;
block|}
DECL|method|isSystemAppsLimitReached ()
specifier|public
name|boolean
name|isSystemAppsLimitReached
parameter_list|()
block|{
if|if
condition|(
name|getRootQueue
argument_list|()
operator|.
name|getNumApplications
argument_list|()
operator|<
name|conf
operator|.
name|getMaximumSystemApplications
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|getDefaultReservationQueueName (String planQueueName)
specifier|private
name|String
name|getDefaultReservationQueueName
parameter_list|(
name|String
name|planQueueName
parameter_list|)
block|{
return|return
name|planQueueName
operator|+
name|ReservationConstants
operator|.
name|DEFAULT_QUEUE_SUFFIX
return|;
block|}
DECL|method|resolveReservationQueueName (String queueName, ApplicationId applicationId, ReservationId reservationID, boolean isRecovering)
specifier|private
name|String
name|resolveReservationQueueName
parameter_list|(
name|String
name|queueName
parameter_list|,
name|ApplicationId
name|applicationId
parameter_list|,
name|ReservationId
name|reservationID
parameter_list|,
name|boolean
name|isRecovering
parameter_list|)
block|{
try|try
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|CSQueue
name|queue
init|=
name|getQueue
argument_list|(
name|queueName
argument_list|)
decl_stmt|;
comment|// Check if the queue is a plan queue
if|if
condition|(
operator|(
name|queue
operator|==
literal|null
operator|)
operator|||
operator|!
operator|(
name|queue
operator|instanceof
name|PlanQueue
operator|)
condition|)
block|{
return|return
name|queueName
return|;
block|}
if|if
condition|(
name|reservationID
operator|!=
literal|null
condition|)
block|{
name|String
name|resQName
init|=
name|reservationID
operator|.
name|toString
argument_list|()
decl_stmt|;
name|queue
operator|=
name|getQueue
argument_list|(
name|resQName
argument_list|)
expr_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
block|{
comment|// reservation has terminated during failover
if|if
condition|(
name|isRecovering
operator|&&
name|conf
operator|.
name|getMoveOnExpiry
argument_list|(
name|getQueue
argument_list|(
name|queueName
argument_list|)
operator|.
name|getQueuePath
argument_list|()
argument_list|)
condition|)
block|{
comment|// move to the default child queue of the plan
return|return
name|getDefaultReservationQueueName
argument_list|(
name|queueName
argument_list|)
return|;
block|}
name|String
name|message
init|=
literal|"Application "
operator|+
name|applicationId
operator|+
literal|" submitted to a reservation which is not currently active: "
operator|+
name|resQName
decl_stmt|;
name|this
operator|.
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMAppEvent
argument_list|(
name|applicationId
argument_list|,
name|RMAppEventType
operator|.
name|APP_REJECTED
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|!
name|queue
operator|.
name|getParent
argument_list|()
operator|.
name|getQueueName
argument_list|()
operator|.
name|equals
argument_list|(
name|queueName
argument_list|)
condition|)
block|{
name|String
name|message
init|=
literal|"Application: "
operator|+
name|applicationId
operator|+
literal|" submitted to a reservation "
operator|+
name|resQName
operator|+
literal|" which does not belong to the specified queue: "
operator|+
name|queueName
decl_stmt|;
name|this
operator|.
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|RMAppEvent
argument_list|(
name|applicationId
argument_list|,
name|RMAppEventType
operator|.
name|APP_REJECTED
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// use the reservation queue to run the app
name|queueName
operator|=
name|resQName
expr_stmt|;
block|}
else|else
block|{
comment|// use the default child queue of the plan for unreserved apps
name|queueName
operator|=
name|getDefaultReservationQueueName
argument_list|(
name|queueName
argument_list|)
expr_stmt|;
block|}
return|return
name|queueName
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|removeQueue (String queueName)
specifier|public
name|void
name|removeQueue
parameter_list|(
name|String
name|queueName
parameter_list|)
throws|throws
name|SchedulerDynamicEditException
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing queue: "
operator|+
name|queueName
argument_list|)
expr_stmt|;
name|CSQueue
name|q
init|=
name|this
operator|.
name|getQueue
argument_list|(
name|queueName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|AbstractAutoCreatedLeafQueue
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|q
operator|.
name|getClass
argument_list|()
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|SchedulerDynamicEditException
argument_list|(
literal|"The queue that we are asked "
operator|+
literal|"to remove ("
operator|+
name|queueName
operator|+
literal|") is not a AutoCreatedLeafQueue or ReservationQueue"
argument_list|)
throw|;
block|}
name|AbstractAutoCreatedLeafQueue
name|disposableLeafQueue
init|=
operator|(
name|AbstractAutoCreatedLeafQueue
operator|)
name|q
decl_stmt|;
comment|// at this point we should have no more apps
if|if
condition|(
name|disposableLeafQueue
operator|.
name|getNumApplications
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|SchedulerDynamicEditException
argument_list|(
literal|"The queue "
operator|+
name|queueName
operator|+
literal|" is not empty "
operator|+
name|disposableLeafQueue
operator|.
name|getApplications
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|" active apps "
operator|+
name|disposableLeafQueue
operator|.
name|getPendingApplications
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|" pending apps"
argument_list|)
throw|;
block|}
operator|(
operator|(
name|AbstractManagedParentQueue
operator|)
name|disposableLeafQueue
operator|.
name|getParent
argument_list|()
operator|)
operator|.
name|removeChildQueue
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|this
operator|.
name|queueManager
operator|.
name|removeQueue
argument_list|(
name|queueName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Removal of AutoCreatedLeafQueue "
operator|+
name|queueName
operator|+
literal|" has succeeded"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|addQueue (Queue queue)
specifier|public
name|void
name|addQueue
parameter_list|(
name|Queue
name|queue
parameter_list|)
throws|throws
name|SchedulerDynamicEditException
throws|,
name|IOException
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SchedulerDynamicEditException
argument_list|(
literal|"Queue specified is null. Should be an implementation of "
operator|+
literal|"AbstractAutoCreatedLeafQueue"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|AbstractAutoCreatedLeafQueue
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|queue
operator|.
name|getClass
argument_list|()
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|SchedulerDynamicEditException
argument_list|(
literal|"Queue is not an implementation of "
operator|+
literal|"AbstractAutoCreatedLeafQueue : "
operator|+
name|queue
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
name|AbstractAutoCreatedLeafQueue
name|newQueue
init|=
operator|(
name|AbstractAutoCreatedLeafQueue
operator|)
name|queue
decl_stmt|;
if|if
condition|(
name|newQueue
operator|.
name|getParent
argument_list|()
operator|==
literal|null
operator|||
operator|!
operator|(
name|AbstractManagedParentQueue
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|newQueue
operator|.
name|getParent
argument_list|()
operator|.
name|getClass
argument_list|()
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|SchedulerDynamicEditException
argument_list|(
literal|"ParentQueue for "
operator|+
name|newQueue
operator|+
literal|" is not properly set"
operator|+
literal|" (should be set and be a PlanQueue or ManagedParentQueue)"
argument_list|)
throw|;
block|}
name|AbstractManagedParentQueue
name|parent
init|=
operator|(
name|AbstractManagedParentQueue
operator|)
name|newQueue
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|String
name|queuename
init|=
name|newQueue
operator|.
name|getQueueName
argument_list|()
decl_stmt|;
name|parent
operator|.
name|addChildQueue
argument_list|(
name|newQueue
argument_list|)
expr_stmt|;
name|this
operator|.
name|queueManager
operator|.
name|addQueue
argument_list|(
name|queuename
argument_list|,
name|newQueue
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Creation of AutoCreatedLeafQueue "
operator|+
name|newQueue
operator|+
literal|" succeeded"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|setEntitlement (String inQueue, QueueEntitlement entitlement)
specifier|public
name|void
name|setEntitlement
parameter_list|(
name|String
name|inQueue
parameter_list|,
name|QueueEntitlement
name|entitlement
parameter_list|)
throws|throws
name|YarnException
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|LeafQueue
name|queue
init|=
name|this
operator|.
name|queueManager
operator|.
name|getAndCheckLeafQueue
argument_list|(
name|inQueue
argument_list|)
decl_stmt|;
name|AbstractManagedParentQueue
name|parent
init|=
operator|(
name|AbstractManagedParentQueue
operator|)
name|queue
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|AbstractAutoCreatedLeafQueue
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|queue
operator|.
name|getClass
argument_list|()
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|SchedulerDynamicEditException
argument_list|(
literal|"Entitlement can not be"
operator|+
literal|" modified dynamically since queue "
operator|+
name|inQueue
operator|+
literal|" is not a AutoCreatedLeafQueue"
argument_list|)
throw|;
block|}
if|if
condition|(
name|parent
operator|==
literal|null
operator|||
operator|!
operator|(
name|AbstractManagedParentQueue
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|parent
operator|.
name|getClass
argument_list|()
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|SchedulerDynamicEditException
argument_list|(
literal|"The parent of AutoCreatedLeafQueue "
operator|+
name|inQueue
operator|+
literal|" must be a PlanQueue/ManagedParentQueue"
argument_list|)
throw|;
block|}
name|AbstractAutoCreatedLeafQueue
name|newQueue
init|=
operator|(
name|AbstractAutoCreatedLeafQueue
operator|)
name|queue
decl_stmt|;
name|parent
operator|.
name|validateQueueEntitlementChange
argument_list|(
name|newQueue
argument_list|,
name|entitlement
argument_list|)
expr_stmt|;
name|newQueue
operator|.
name|setEntitlement
argument_list|(
name|entitlement
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Set entitlement for AutoCreatedLeafQueue "
operator|+
name|inQueue
operator|+
literal|"  to "
operator|+
name|queue
operator|.
name|getCapacity
argument_list|()
operator|+
literal|" request was ("
operator|+
name|entitlement
operator|.
name|getCapacity
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|moveApplication (ApplicationId appId, String targetQueueName)
specifier|public
name|String
name|moveApplication
parameter_list|(
name|ApplicationId
name|appId
parameter_list|,
name|String
name|targetQueueName
parameter_list|)
throws|throws
name|YarnException
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|SchedulerApplication
argument_list|<
name|FiCaSchedulerApp
argument_list|>
name|application
init|=
name|applications
operator|.
name|get
argument_list|(
name|appId
argument_list|)
decl_stmt|;
if|if
condition|(
name|application
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|YarnException
argument_list|(
literal|"App to be moved "
operator|+
name|appId
operator|+
literal|" not found."
argument_list|)
throw|;
block|}
name|String
name|sourceQueueName
init|=
name|application
operator|.
name|getQueue
argument_list|()
operator|.
name|getQueueName
argument_list|()
decl_stmt|;
name|LeafQueue
name|source
init|=
name|this
operator|.
name|queueManager
operator|.
name|getAndCheckLeafQueue
argument_list|(
name|sourceQueueName
argument_list|)
decl_stmt|;
name|String
name|destQueueName
init|=
name|handleMoveToPlanQueue
argument_list|(
name|targetQueueName
argument_list|)
decl_stmt|;
name|LeafQueue
name|dest
init|=
name|this
operator|.
name|queueManager
operator|.
name|getAndCheckLeafQueue
argument_list|(
name|destQueueName
argument_list|)
decl_stmt|;
name|String
name|user
init|=
name|application
operator|.
name|getUser
argument_list|()
decl_stmt|;
try|try
block|{
name|dest
operator|.
name|submitApplication
argument_list|(
name|appId
argument_list|,
name|user
argument_list|,
name|destQueueName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YarnException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|FiCaSchedulerApp
name|app
init|=
name|application
operator|.
name|getCurrentAppAttempt
argument_list|()
decl_stmt|;
if|if
condition|(
name|app
operator|!=
literal|null
condition|)
block|{
comment|// Move all live containers even when stopped.
comment|// For transferStateFromPreviousAttempt required
for|for
control|(
name|RMContainer
name|rmContainer
range|:
name|app
operator|.
name|getLiveContainers
argument_list|()
control|)
block|{
name|source
operator|.
name|detachContainer
argument_list|(
name|getClusterResource
argument_list|()
argument_list|,
name|app
argument_list|,
name|rmContainer
argument_list|)
expr_stmt|;
comment|// attach the Container to another queue
name|dest
operator|.
name|attachContainer
argument_list|(
name|getClusterResource
argument_list|()
argument_list|,
name|app
argument_list|,
name|rmContainer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|app
operator|.
name|isStopped
argument_list|()
condition|)
block|{
name|source
operator|.
name|finishApplicationAttempt
argument_list|(
name|app
argument_list|,
name|sourceQueueName
argument_list|)
expr_stmt|;
comment|// Submit to a new queue
name|dest
operator|.
name|submitApplicationAttempt
argument_list|(
name|app
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
comment|// Finish app& update metrics
name|app
operator|.
name|move
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
name|source
operator|.
name|appFinished
argument_list|()
expr_stmt|;
comment|// Detach the application..
name|source
operator|.
name|getParent
argument_list|()
operator|.
name|finishApplication
argument_list|(
name|appId
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|application
operator|.
name|setQueue
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"App: "
operator|+
name|appId
operator|+
literal|" successfully moved from "
operator|+
name|sourceQueueName
operator|+
literal|" to: "
operator|+
name|destQueueName
argument_list|)
expr_stmt|;
return|return
name|targetQueueName
return|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|preValidateMoveApplication (ApplicationId appId, String newQueue)
specifier|public
name|void
name|preValidateMoveApplication
parameter_list|(
name|ApplicationId
name|appId
parameter_list|,
name|String
name|newQueue
parameter_list|)
throws|throws
name|YarnException
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|SchedulerApplication
argument_list|<
name|FiCaSchedulerApp
argument_list|>
name|application
init|=
name|applications
operator|.
name|get
argument_list|(
name|appId
argument_list|)
decl_stmt|;
if|if
condition|(
name|application
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|YarnException
argument_list|(
literal|"App to be moved "
operator|+
name|appId
operator|+
literal|" not found."
argument_list|)
throw|;
block|}
name|String
name|sourceQueueName
init|=
name|application
operator|.
name|getQueue
argument_list|()
operator|.
name|getQueueName
argument_list|()
decl_stmt|;
name|this
operator|.
name|queueManager
operator|.
name|getAndCheckLeafQueue
argument_list|(
name|sourceQueueName
argument_list|)
expr_stmt|;
name|String
name|destQueueName
init|=
name|handleMoveToPlanQueue
argument_list|(
name|newQueue
argument_list|)
decl_stmt|;
name|LeafQueue
name|dest
init|=
name|this
operator|.
name|queueManager
operator|.
name|getAndCheckLeafQueue
argument_list|(
name|destQueueName
argument_list|)
decl_stmt|;
comment|// Validation check - ACLs, submission limits for user& queue
name|String
name|user
init|=
name|application
operator|.
name|getUser
argument_list|()
decl_stmt|;
comment|// Check active partition only when attempt is available
name|FiCaSchedulerApp
name|appAttempt
init|=
name|getApplicationAttempt
argument_list|(
name|ApplicationAttemptId
operator|.
name|newInstance
argument_list|(
name|appId
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|appAttempt
condition|)
block|{
name|checkQueuePartition
argument_list|(
name|appAttempt
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|dest
operator|.
name|validateSubmitApplication
argument_list|(
name|appId
argument_list|,
name|user
argument_list|,
name|destQueueName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YarnException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Check application can be moved to queue with labels enabled. All labels in    * application life time will be checked    *    * @param app    * @param dest    * @throws YarnException    */
DECL|method|checkQueuePartition (FiCaSchedulerApp app, LeafQueue dest)
specifier|private
name|void
name|checkQueuePartition
parameter_list|(
name|FiCaSchedulerApp
name|app
parameter_list|,
name|LeafQueue
name|dest
parameter_list|)
throws|throws
name|YarnException
block|{
if|if
condition|(
operator|!
name|YarnConfiguration
operator|.
name|areNodeLabelsEnabled
argument_list|(
name|conf
argument_list|)
condition|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|targetqueuelabels
init|=
name|dest
operator|.
name|getAccessibleNodeLabels
argument_list|()
decl_stmt|;
name|AppSchedulingInfo
name|schedulingInfo
init|=
name|app
operator|.
name|getAppSchedulingInfo
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|appLabelexpressions
init|=
name|schedulingInfo
operator|.
name|getRequestedPartitions
argument_list|()
decl_stmt|;
comment|// default partition access always available remove empty label
name|appLabelexpressions
operator|.
name|remove
argument_list|(
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|nonAccessiblelabels
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|label
range|:
name|appLabelexpressions
control|)
block|{
if|if
condition|(
operator|!
name|SchedulerUtils
operator|.
name|checkQueueLabelExpression
argument_list|(
name|targetqueuelabels
argument_list|,
name|label
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|nonAccessiblelabels
operator|.
name|add
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nonAccessiblelabels
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|YarnException
argument_list|(
literal|"Specified queue="
operator|+
name|dest
operator|.
name|getQueueName
argument_list|()
operator|+
literal|" can't satisfy following "
operator|+
literal|"apps label expressions ="
operator|+
name|nonAccessiblelabels
operator|+
literal|" accessible node labels ="
operator|+
name|targetqueuelabels
argument_list|)
throw|;
block|}
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
DECL|method|getSchedulingResourceTypes ()
specifier|public
name|EnumSet
argument_list|<
name|SchedulerResourceTypes
argument_list|>
name|getSchedulingResourceTypes
parameter_list|()
block|{
if|if
condition|(
name|calculator
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|DefaultResourceCalculator
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|EnumSet
operator|.
name|of
argument_list|(
name|SchedulerResourceTypes
operator|.
name|MEMORY
argument_list|)
return|;
block|}
return|return
name|EnumSet
operator|.
name|of
argument_list|(
name|SchedulerResourceTypes
operator|.
name|MEMORY
argument_list|,
name|SchedulerResourceTypes
operator|.
name|CPU
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getMaximumResourceCapability (String queueName)
specifier|public
name|Resource
name|getMaximumResourceCapability
parameter_list|(
name|String
name|queueName
parameter_list|)
block|{
name|CSQueue
name|queue
init|=
name|getQueue
argument_list|(
name|queueName
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unknown queue: "
operator|+
name|queueName
argument_list|)
expr_stmt|;
return|return
name|getMaximumResourceCapability
argument_list|()
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|queue
operator|instanceof
name|LeafQueue
operator|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"queue "
operator|+
name|queueName
operator|+
literal|" is not an leaf queue"
argument_list|)
expr_stmt|;
return|return
name|getMaximumResourceCapability
argument_list|()
return|;
block|}
return|return
operator|(
operator|(
name|LeafQueue
operator|)
name|queue
operator|)
operator|.
name|getMaximumAllocation
argument_list|()
return|;
block|}
DECL|method|handleMoveToPlanQueue (String targetQueueName)
specifier|private
name|String
name|handleMoveToPlanQueue
parameter_list|(
name|String
name|targetQueueName
parameter_list|)
block|{
name|CSQueue
name|dest
init|=
name|getQueue
argument_list|(
name|targetQueueName
argument_list|)
decl_stmt|;
if|if
condition|(
name|dest
operator|!=
literal|null
operator|&&
name|dest
operator|instanceof
name|PlanQueue
condition|)
block|{
comment|// use the default child reservation queue of the plan
name|targetQueueName
operator|=
name|targetQueueName
operator|+
name|ReservationConstants
operator|.
name|DEFAULT_QUEUE_SUFFIX
expr_stmt|;
block|}
return|return
name|targetQueueName
return|;
block|}
annotation|@
name|Override
DECL|method|getPlanQueues ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getPlanQueues
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|ret
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|l
range|:
name|queueManager
operator|.
name|getQueues
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|l
operator|.
name|getValue
argument_list|()
operator|instanceof
name|PlanQueue
condition|)
block|{
name|ret
operator|.
name|add
argument_list|(
name|l
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
annotation|@
name|Override
DECL|method|checkAndGetApplicationPriority ( Priority priorityRequestedByApp, UserGroupInformation user, String queueName, ApplicationId applicationId)
specifier|public
name|Priority
name|checkAndGetApplicationPriority
parameter_list|(
name|Priority
name|priorityRequestedByApp
parameter_list|,
name|UserGroupInformation
name|user
parameter_list|,
name|String
name|queueName
parameter_list|,
name|ApplicationId
name|applicationId
parameter_list|)
throws|throws
name|YarnException
block|{
try|try
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|Priority
name|appPriority
init|=
name|priorityRequestedByApp
decl_stmt|;
comment|// Verify the scenario where priority is null from submissionContext.
if|if
condition|(
literal|null
operator|==
name|appPriority
condition|)
block|{
comment|// Verify whether submitted user has any default priority set. If so,
comment|// user's default priority will get precedence over queue default.
comment|// for updateApplicationPriority call flow, this check is done in
comment|// CientRMService itself.
name|appPriority
operator|=
name|this
operator|.
name|appPriorityACLManager
operator|.
name|getDefaultPriority
argument_list|(
name|queueName
argument_list|,
name|user
argument_list|)
expr_stmt|;
comment|// Get the default priority for the Queue. If Queue is non-existent,
comment|// then
comment|// use default priority. Do it only if user doesn't have any default.
if|if
condition|(
literal|null
operator|==
name|appPriority
condition|)
block|{
name|appPriority
operator|=
name|this
operator|.
name|queueManager
operator|.
name|getDefaultPriorityForQueue
argument_list|(
name|queueName
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Application '"
operator|+
name|applicationId
operator|+
literal|"' is submitted without priority "
operator|+
literal|"hence considering default queue/cluster priority: "
operator|+
name|appPriority
operator|.
name|getPriority
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Verify whether submitted priority is lesser than max priority
comment|// in the cluster. If it is out of found, defining a max cap.
if|if
condition|(
name|appPriority
operator|.
name|getPriority
argument_list|()
operator|>
name|getMaxClusterLevelAppPriority
argument_list|()
operator|.
name|getPriority
argument_list|()
condition|)
block|{
name|appPriority
operator|=
name|Priority
operator|.
name|newInstance
argument_list|(
name|getMaxClusterLevelAppPriority
argument_list|()
operator|.
name|getPriority
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Lets check for ACLs here.
if|if
condition|(
operator|!
name|appPriorityACLManager
operator|.
name|checkAccess
argument_list|(
name|user
argument_list|,
name|queueName
argument_list|,
name|appPriority
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|YarnException
argument_list|(
operator|new
name|AccessControlException
argument_list|(
literal|"User "
operator|+
name|user
operator|+
literal|" does not have permission to submit/update "
operator|+
name|applicationId
operator|+
literal|" for "
operator|+
name|appPriority
argument_list|)
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Priority '"
operator|+
name|appPriority
operator|.
name|getPriority
argument_list|()
operator|+
literal|"' is acceptable in queue : "
operator|+
name|queueName
operator|+
literal|" for application: "
operator|+
name|applicationId
argument_list|)
expr_stmt|;
return|return
name|appPriority
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|updateApplicationPriority (Priority newPriority, ApplicationId applicationId, SettableFuture<Object> future, UserGroupInformation user)
specifier|public
name|Priority
name|updateApplicationPriority
parameter_list|(
name|Priority
name|newPriority
parameter_list|,
name|ApplicationId
name|applicationId
parameter_list|,
name|SettableFuture
argument_list|<
name|Object
argument_list|>
name|future
parameter_list|,
name|UserGroupInformation
name|user
parameter_list|)
throws|throws
name|YarnException
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|Priority
name|appPriority
init|=
literal|null
decl_stmt|;
name|SchedulerApplication
argument_list|<
name|FiCaSchedulerApp
argument_list|>
name|application
init|=
name|applications
operator|.
name|get
argument_list|(
name|applicationId
argument_list|)
decl_stmt|;
if|if
condition|(
name|application
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|YarnException
argument_list|(
literal|"Application '"
operator|+
name|applicationId
operator|+
literal|"' is not present, hence could not change priority."
argument_list|)
throw|;
block|}
name|RMApp
name|rmApp
init|=
name|rmContext
operator|.
name|getRMApps
argument_list|()
operator|.
name|get
argument_list|(
name|applicationId
argument_list|)
decl_stmt|;
name|appPriority
operator|=
name|checkAndGetApplicationPriority
argument_list|(
name|newPriority
argument_list|,
name|user
argument_list|,
name|rmApp
operator|.
name|getQueue
argument_list|()
argument_list|,
name|applicationId
argument_list|)
expr_stmt|;
if|if
condition|(
name|application
operator|.
name|getPriority
argument_list|()
operator|.
name|equals
argument_list|(
name|appPriority
argument_list|)
condition|)
block|{
name|future
operator|.
name|set
argument_list|(
literal|null
argument_list|)
expr_stmt|;
return|return
name|appPriority
return|;
block|}
comment|// Update new priority in Submission Context to update to StateStore.
name|rmApp
operator|.
name|getApplicationSubmissionContext
argument_list|()
operator|.
name|setPriority
argument_list|(
name|appPriority
argument_list|)
expr_stmt|;
comment|// Update to state store
name|ApplicationStateData
name|appState
init|=
name|ApplicationStateData
operator|.
name|newInstance
argument_list|(
name|rmApp
operator|.
name|getSubmitTime
argument_list|()
argument_list|,
name|rmApp
operator|.
name|getStartTime
argument_list|()
argument_list|,
name|rmApp
operator|.
name|getApplicationSubmissionContext
argument_list|()
argument_list|,
name|rmApp
operator|.
name|getUser
argument_list|()
argument_list|,
name|rmApp
operator|.
name|getCallerContext
argument_list|()
argument_list|)
decl_stmt|;
name|appState
operator|.
name|setApplicationTimeouts
argument_list|(
name|rmApp
operator|.
name|getApplicationTimeouts
argument_list|()
argument_list|)
expr_stmt|;
name|rmContext
operator|.
name|getStateStore
argument_list|()
operator|.
name|updateApplicationStateSynchronously
argument_list|(
name|appState
argument_list|,
literal|false
argument_list|,
name|future
argument_list|)
expr_stmt|;
comment|// As we use iterator over a TreeSet for OrderingPolicy, once we change
comment|// priority then reinsert back to make order correct.
name|LeafQueue
name|queue
init|=
operator|(
name|LeafQueue
operator|)
name|getQueue
argument_list|(
name|rmApp
operator|.
name|getQueue
argument_list|()
argument_list|)
decl_stmt|;
name|queue
operator|.
name|updateApplicationPriority
argument_list|(
name|application
argument_list|,
name|appPriority
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Priority '"
operator|+
name|appPriority
operator|+
literal|"' is updated in queue :"
operator|+
name|rmApp
operator|.
name|getQueue
argument_list|()
operator|+
literal|" for application: "
operator|+
name|applicationId
operator|+
literal|" for the user: "
operator|+
name|rmApp
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|appPriority
return|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getPreemptionManager ()
specifier|public
name|PreemptionManager
name|getPreemptionManager
parameter_list|()
block|{
return|return
name|preemptionManager
return|;
block|}
annotation|@
name|Override
DECL|method|getClusterResourceUsage ()
specifier|public
name|ResourceUsage
name|getClusterResourceUsage
parameter_list|()
block|{
return|return
name|getRootQueue
argument_list|()
operator|.
name|getQueueResourceUsage
argument_list|()
return|;
block|}
DECL|method|getSchedulerContainer ( RMContainer rmContainer, boolean allocated)
specifier|private
name|SchedulerContainer
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
name|getSchedulerContainer
parameter_list|(
name|RMContainer
name|rmContainer
parameter_list|,
name|boolean
name|allocated
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|==
name|rmContainer
condition|)
block|{
return|return
literal|null
return|;
block|}
name|FiCaSchedulerApp
name|app
init|=
name|getApplicationAttempt
argument_list|(
name|rmContainer
operator|.
name|getApplicationAttemptId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|app
condition|)
block|{
return|return
literal|null
return|;
block|}
name|NodeId
name|nodeId
decl_stmt|;
comment|// Get nodeId
if|if
condition|(
name|rmContainer
operator|.
name|getState
argument_list|()
operator|==
name|RMContainerState
operator|.
name|RESERVED
condition|)
block|{
name|nodeId
operator|=
name|rmContainer
operator|.
name|getReservedNode
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|nodeId
operator|=
name|rmContainer
operator|.
name|getNodeId
argument_list|()
expr_stmt|;
block|}
name|FiCaSchedulerNode
name|node
init|=
name|getNode
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|node
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|SchedulerContainer
argument_list|<>
argument_list|(
name|app
argument_list|,
name|node
argument_list|,
name|rmContainer
argument_list|,
comment|// TODO, node partition should come from CSAssignment to avoid partition
comment|// get updated before submitting the commit
name|node
operator|.
name|getPartition
argument_list|()
argument_list|,
name|allocated
argument_list|)
return|;
block|}
specifier|private
name|List
argument_list|<
name|SchedulerContainer
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
argument_list|>
DECL|method|getSchedulerContainersToRelease ( CSAssignment csAssignment)
name|getSchedulerContainersToRelease
parameter_list|(
name|CSAssignment
name|csAssignment
parameter_list|)
block|{
name|List
argument_list|<
name|SchedulerContainer
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
argument_list|>
name|list
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|csAssignment
operator|.
name|getContainersToKill
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|csAssignment
operator|.
name|getContainersToKill
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|list
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|RMContainer
name|rmContainer
range|:
name|csAssignment
operator|.
name|getContainersToKill
argument_list|()
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|getSchedulerContainer
argument_list|(
name|rmContainer
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|csAssignment
operator|.
name|getExcessReservation
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
literal|null
operator|==
name|list
condition|)
block|{
name|list
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|getSchedulerContainer
argument_list|(
name|csAssignment
operator|.
name|getExcessReservation
argument_list|()
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|submitResourceCommitRequest (Resource cluster, CSAssignment csAssignment)
specifier|public
name|void
name|submitResourceCommitRequest
parameter_list|(
name|Resource
name|cluster
parameter_list|,
name|CSAssignment
name|csAssignment
parameter_list|)
block|{
name|ResourceCommitRequest
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
name|request
init|=
name|createResourceCommitRequest
argument_list|(
name|csAssignment
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|request
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|scheduleAsynchronously
condition|)
block|{
comment|// Submit to a commit thread and commit it async-ly
name|resourceCommitterService
operator|.
name|addNewCommitRequest
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Otherwise do it sync-ly.
name|tryCommit
argument_list|(
name|cluster
argument_list|,
name|request
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|attemptAllocationOnNode (SchedulerApplicationAttempt appAttempt, SchedulingRequest schedulingRequest, SchedulerNode schedulerNode)
specifier|public
name|boolean
name|attemptAllocationOnNode
parameter_list|(
name|SchedulerApplicationAttempt
name|appAttempt
parameter_list|,
name|SchedulingRequest
name|schedulingRequest
parameter_list|,
name|SchedulerNode
name|schedulerNode
parameter_list|)
block|{
if|if
condition|(
name|schedulingRequest
operator|.
name|getResourceSizing
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|schedulingRequest
operator|.
name|getResourceSizing
argument_list|()
operator|.
name|getNumAllocations
argument_list|()
operator|>
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The SchedulingRequest has requested more than 1 allocation,"
operator|+
literal|" but only 1 will be attempted !!"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|appAttempt
operator|.
name|isStopped
argument_list|()
condition|)
block|{
name|ResourceCommitRequest
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
name|resourceCommitRequest
init|=
name|createResourceCommitRequest
argument_list|(
name|appAttempt
argument_list|,
name|schedulingRequest
argument_list|,
name|schedulerNode
argument_list|)
decl_stmt|;
comment|// Validate placement constraint is satisfied before
comment|// committing the request.
try|try
block|{
if|if
condition|(
operator|!
name|PlacementConstraintsUtil
operator|.
name|canSatisfyConstraints
argument_list|(
name|appAttempt
operator|.
name|getApplicationId
argument_list|()
argument_list|,
name|schedulingRequest
argument_list|,
name|schedulerNode
argument_list|,
name|rmContext
operator|.
name|getPlacementConstraintManager
argument_list|()
argument_list|,
name|rmContext
operator|.
name|getAllocationTagsManager
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to allocate container for application "
operator|+
name|appAttempt
operator|.
name|getApplicationId
argument_list|()
operator|+
literal|" on node "
operator|+
name|schedulerNode
operator|.
name|getNodeName
argument_list|()
operator|+
literal|" because this allocation violates the"
operator|+
literal|" placement constraint."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|InvalidAllocationTagsQueryException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to allocate container"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|tryCommit
argument_list|(
name|getClusterResource
argument_list|()
argument_list|,
name|resourceCommitRequest
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|// This assumes numContainers = 1 for the request.
specifier|private
name|ResourceCommitRequest
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
DECL|method|createResourceCommitRequest (SchedulerApplicationAttempt appAttempt, SchedulingRequest schedulingRequest, SchedulerNode schedulerNode)
name|createResourceCommitRequest
parameter_list|(
name|SchedulerApplicationAttempt
name|appAttempt
parameter_list|,
name|SchedulingRequest
name|schedulingRequest
parameter_list|,
name|SchedulerNode
name|schedulerNode
parameter_list|)
block|{
name|ContainerAllocationProposal
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
name|allocated
init|=
literal|null
decl_stmt|;
name|Resource
name|resource
init|=
name|schedulingRequest
operator|.
name|getResourceSizing
argument_list|()
operator|.
name|getResources
argument_list|()
decl_stmt|;
if|if
condition|(
name|Resources
operator|.
name|greaterThan
argument_list|(
name|calculator
argument_list|,
name|getClusterResource
argument_list|()
argument_list|,
name|resource
argument_list|,
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
condition|)
block|{
name|ContainerId
name|cId
init|=
name|ContainerId
operator|.
name|newContainerId
argument_list|(
name|appAttempt
operator|.
name|getApplicationAttemptId
argument_list|()
argument_list|,
name|appAttempt
operator|.
name|getAppSchedulingInfo
argument_list|()
operator|.
name|getNewContainerId
argument_list|()
argument_list|)
decl_stmt|;
name|Container
name|container
init|=
name|BuilderUtils
operator|.
name|newContainer
argument_list|(
name|cId
argument_list|,
name|schedulerNode
operator|.
name|getNodeID
argument_list|()
argument_list|,
name|schedulerNode
operator|.
name|getHttpAddress
argument_list|()
argument_list|,
name|resource
argument_list|,
name|schedulingRequest
operator|.
name|getPriority
argument_list|()
argument_list|,
literal|null
argument_list|,
name|ExecutionType
operator|.
name|GUARANTEED
argument_list|,
name|schedulingRequest
operator|.
name|getAllocationRequestId
argument_list|()
argument_list|)
decl_stmt|;
name|RMContainer
name|rmContainer
init|=
operator|new
name|RMContainerImpl
argument_list|(
name|container
argument_list|,
name|SchedulerRequestKey
operator|.
name|extractFrom
argument_list|(
name|container
argument_list|)
argument_list|,
name|appAttempt
operator|.
name|getApplicationAttemptId
argument_list|()
argument_list|,
name|container
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|appAttempt
operator|.
name|getUser
argument_list|()
argument_list|,
name|rmContext
argument_list|,
literal|false
argument_list|)
decl_stmt|;
operator|(
operator|(
name|RMContainerImpl
operator|)
name|rmContainer
operator|)
operator|.
name|setAllocationTags
argument_list|(
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|schedulingRequest
operator|.
name|getAllocationTags
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|allocated
operator|=
operator|new
name|ContainerAllocationProposal
argument_list|<>
argument_list|(
name|getSchedulerContainer
argument_list|(
name|rmContainer
argument_list|,
literal|true
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|NodeType
operator|.
name|NODE_LOCAL
argument_list|,
name|NodeType
operator|.
name|NODE_LOCAL
argument_list|,
name|SchedulingMode
operator|.
name|RESPECT_PARTITION_EXCLUSIVITY
argument_list|,
name|resource
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|!=
name|allocated
condition|)
block|{
name|List
argument_list|<
name|ContainerAllocationProposal
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
argument_list|>
name|allocationsList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|allocationsList
operator|.
name|add
argument_list|(
name|allocated
argument_list|)
expr_stmt|;
return|return
operator|new
name|ResourceCommitRequest
argument_list|<>
argument_list|(
name|allocationsList
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|VisibleForTesting
specifier|public
name|ResourceCommitRequest
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
DECL|method|createResourceCommitRequest (CSAssignment csAssignment)
name|createResourceCommitRequest
parameter_list|(
name|CSAssignment
name|csAssignment
parameter_list|)
block|{
name|ContainerAllocationProposal
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
name|allocated
init|=
literal|null
decl_stmt|;
name|ContainerAllocationProposal
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
name|reserved
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|SchedulerContainer
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
argument_list|>
name|released
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|Resources
operator|.
name|greaterThan
argument_list|(
name|calculator
argument_list|,
name|getClusterResource
argument_list|()
argument_list|,
name|csAssignment
operator|.
name|getResource
argument_list|()
argument_list|,
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
condition|)
block|{
comment|// Allocated something
name|List
argument_list|<
name|AssignmentInformation
operator|.
name|AssignmentDetails
argument_list|>
name|allocations
init|=
name|csAssignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getAllocationDetails
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|allocations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|RMContainer
name|rmContainer
init|=
name|allocations
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|rmContainer
decl_stmt|;
name|allocated
operator|=
operator|new
name|ContainerAllocationProposal
argument_list|<>
argument_list|(
name|getSchedulerContainer
argument_list|(
name|rmContainer
argument_list|,
literal|true
argument_list|)
argument_list|,
name|getSchedulerContainersToRelease
argument_list|(
name|csAssignment
argument_list|)
argument_list|,
name|getSchedulerContainer
argument_list|(
name|csAssignment
operator|.
name|getFulfilledReservedContainer
argument_list|()
argument_list|,
literal|false
argument_list|)
argument_list|,
name|csAssignment
operator|.
name|getType
argument_list|()
argument_list|,
name|csAssignment
operator|.
name|getRequestLocalityType
argument_list|()
argument_list|,
name|csAssignment
operator|.
name|getSchedulingMode
argument_list|()
operator|!=
literal|null
condition|?
name|csAssignment
operator|.
name|getSchedulingMode
argument_list|()
else|:
name|SchedulingMode
operator|.
name|RESPECT_PARTITION_EXCLUSIVITY
argument_list|,
name|csAssignment
operator|.
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Reserved something
name|List
argument_list|<
name|AssignmentInformation
operator|.
name|AssignmentDetails
argument_list|>
name|reservation
init|=
name|csAssignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getReservationDetails
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|reservation
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|RMContainer
name|rmContainer
init|=
name|reservation
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|rmContainer
decl_stmt|;
name|reserved
operator|=
operator|new
name|ContainerAllocationProposal
argument_list|<>
argument_list|(
name|getSchedulerContainer
argument_list|(
name|rmContainer
argument_list|,
literal|false
argument_list|)
argument_list|,
name|getSchedulerContainersToRelease
argument_list|(
name|csAssignment
argument_list|)
argument_list|,
name|getSchedulerContainer
argument_list|(
name|csAssignment
operator|.
name|getFulfilledReservedContainer
argument_list|()
argument_list|,
literal|false
argument_list|)
argument_list|,
name|csAssignment
operator|.
name|getType
argument_list|()
argument_list|,
name|csAssignment
operator|.
name|getRequestLocalityType
argument_list|()
argument_list|,
name|csAssignment
operator|.
name|getSchedulingMode
argument_list|()
operator|!=
literal|null
condition|?
name|csAssignment
operator|.
name|getSchedulingMode
argument_list|()
else|:
name|SchedulingMode
operator|.
name|RESPECT_PARTITION_EXCLUSIVITY
argument_list|,
name|csAssignment
operator|.
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// When we don't need to allocate/reserve anything, we can feel free to
comment|// kill all to-release containers in the request.
if|if
condition|(
literal|null
operator|==
name|allocated
operator|&&
literal|null
operator|==
name|reserved
condition|)
block|{
name|released
operator|=
name|getSchedulerContainersToRelease
argument_list|(
name|csAssignment
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|!=
name|allocated
operator|||
literal|null
operator|!=
name|reserved
operator|||
operator|(
literal|null
operator|!=
name|released
operator|&&
operator|!
name|released
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
name|List
argument_list|<
name|ContainerAllocationProposal
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
argument_list|>
name|allocationsList
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|allocated
operator|!=
literal|null
condition|)
block|{
name|allocationsList
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|allocationsList
operator|.
name|add
argument_list|(
name|allocated
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|ContainerAllocationProposal
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
argument_list|>
name|reservationsList
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|reserved
operator|!=
literal|null
condition|)
block|{
name|reservationsList
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|reservationsList
operator|.
name|add
argument_list|(
name|reserved
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|ResourceCommitRequest
argument_list|<>
argument_list|(
name|allocationsList
argument_list|,
name|reservationsList
argument_list|,
name|released
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|tryCommit (Resource cluster, ResourceCommitRequest r, boolean updatePending)
specifier|public
name|boolean
name|tryCommit
parameter_list|(
name|Resource
name|cluster
parameter_list|,
name|ResourceCommitRequest
name|r
parameter_list|,
name|boolean
name|updatePending
parameter_list|)
block|{
name|long
name|commitStart
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|ResourceCommitRequest
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
name|request
init|=
operator|(
name|ResourceCommitRequest
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
operator|)
name|r
decl_stmt|;
name|ApplicationAttemptId
name|attemptId
init|=
literal|null
decl_stmt|;
comment|// We need to update unconfirmed allocated resource of application when
comment|// any container allocated.
name|boolean
name|updateUnconfirmedAllocatedResource
init|=
name|request
operator|.
name|getContainersToAllocate
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|request
operator|.
name|getContainersToAllocate
argument_list|()
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
comment|// find the application to accept and apply the ResourceCommitRequest
if|if
condition|(
name|request
operator|.
name|anythingAllocatedOrReserved
argument_list|()
condition|)
block|{
name|ContainerAllocationProposal
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
name|c
init|=
name|request
operator|.
name|getFirstAllocatedOrReservedContainer
argument_list|()
decl_stmt|;
name|attemptId
operator|=
name|c
operator|.
name|getAllocatedOrReservedContainer
argument_list|()
operator|.
name|getSchedulerApplicationAttempt
argument_list|()
operator|.
name|getApplicationAttemptId
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|request
operator|.
name|getContainersToRelease
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|attemptId
operator|=
name|request
operator|.
name|getContainersToRelease
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getSchedulerApplicationAttempt
argument_list|()
operator|.
name|getApplicationAttemptId
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Try to commit allocation proposal="
operator|+
name|request
argument_list|)
expr_stmt|;
block|}
name|boolean
name|isSuccess
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|attemptId
operator|!=
literal|null
condition|)
block|{
name|FiCaSchedulerApp
name|app
init|=
name|getApplicationAttempt
argument_list|(
name|attemptId
argument_list|)
decl_stmt|;
comment|// Required sanity check for attemptId - when async-scheduling enabled,
comment|// proposal might be outdated if AM failover just finished
comment|// and proposal queue was not be consumed in time
if|if
condition|(
name|app
operator|!=
literal|null
operator|&&
name|attemptId
operator|.
name|equals
argument_list|(
name|app
operator|.
name|getApplicationAttemptId
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|app
operator|.
name|accept
argument_list|(
name|cluster
argument_list|,
name|request
argument_list|,
name|updatePending
argument_list|)
operator|&&
name|app
operator|.
name|apply
argument_list|(
name|cluster
argument_list|,
name|request
argument_list|,
name|updatePending
argument_list|)
condition|)
block|{
name|long
name|commitSuccess
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|commitStart
decl_stmt|;
name|CapacitySchedulerMetrics
operator|.
name|getMetrics
argument_list|()
operator|.
name|addCommitSuccess
argument_list|(
name|commitSuccess
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Allocation proposal accepted"
argument_list|)
expr_stmt|;
name|isSuccess
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|long
name|commitFailed
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|commitStart
decl_stmt|;
name|CapacitySchedulerMetrics
operator|.
name|getMetrics
argument_list|()
operator|.
name|addCommitFailure
argument_list|(
name|commitFailed
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to accept allocation proposal"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Allocation proposal accepted="
operator|+
name|isSuccess
operator|+
literal|", proposal="
operator|+
name|request
argument_list|)
expr_stmt|;
block|}
comment|// Update unconfirmed allocated resource.
if|if
condition|(
name|updateUnconfirmedAllocatedResource
condition|)
block|{
name|app
operator|.
name|decUnconfirmedRes
argument_list|(
name|request
operator|.
name|getTotalAllocatedResource
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|isSuccess
return|;
block|}
DECL|method|getAsyncSchedulingPendingBacklogs ()
specifier|public
name|int
name|getAsyncSchedulingPendingBacklogs
parameter_list|()
block|{
if|if
condition|(
name|scheduleAsynchronously
condition|)
block|{
return|return
name|resourceCommitterService
operator|.
name|getPendingBacklogs
argument_list|()
return|;
block|}
return|return
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|getCapacitySchedulerQueueManager ()
specifier|public
name|CapacitySchedulerQueueManager
name|getCapacitySchedulerQueueManager
parameter_list|()
block|{
return|return
name|this
operator|.
name|queueManager
return|;
block|}
comment|/**    * Try to move a reserved container to a targetNode.    * If the targetNode is reserved by another application (other than this one).    * The previous reservation will be cancelled.    *    * @param toBeMovedContainer reserved container will be moved    * @param targetNode targetNode    * @return true if move succeeded. Return false if the targetNode is reserved by    *         a different container or move failed because of any other reasons.    */
DECL|method|moveReservedContainer (RMContainer toBeMovedContainer, FiCaSchedulerNode targetNode)
specifier|public
name|boolean
name|moveReservedContainer
parameter_list|(
name|RMContainer
name|toBeMovedContainer
parameter_list|,
name|FiCaSchedulerNode
name|targetNode
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying to move container="
operator|+
name|toBeMovedContainer
operator|+
literal|" to node="
operator|+
name|targetNode
operator|.
name|getNodeID
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|FiCaSchedulerNode
name|sourceNode
init|=
name|getNode
argument_list|(
name|toBeMovedContainer
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|sourceNode
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to move reservation, cannot find source node="
operator|+
name|toBeMovedContainer
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|// Target node updated?
if|if
condition|(
name|getNode
argument_list|(
name|targetNode
operator|.
name|getNodeID
argument_list|()
argument_list|)
operator|!=
name|targetNode
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to move reservation, node updated or removed, moving "
operator|+
literal|"cancelled."
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|// Target node's reservation status changed?
if|if
condition|(
name|targetNode
operator|.
name|getReservedContainer
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Target node's reservation status changed, moving cancelled."
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
name|FiCaSchedulerApp
name|app
init|=
name|getApplicationAttempt
argument_list|(
name|toBeMovedContainer
operator|.
name|getApplicationAttemptId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|app
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Cannot find to-be-moved container's application="
operator|+
name|toBeMovedContainer
operator|.
name|getApplicationAttemptId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|// finally, move the reserved container
return|return
name|app
operator|.
name|moveReservation
argument_list|(
name|toBeMovedContainer
argument_list|,
name|sourceNode
argument_list|,
name|targetNode
argument_list|)
return|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|checkAndGetApplicationLifetime (String queueName, long lifetimeRequestedByApp)
specifier|public
name|long
name|checkAndGetApplicationLifetime
parameter_list|(
name|String
name|queueName
parameter_list|,
name|long
name|lifetimeRequestedByApp
parameter_list|)
block|{
try|try
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|CSQueue
name|queue
init|=
name|getQueue
argument_list|(
name|queueName
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
operator|||
operator|!
operator|(
name|queue
operator|instanceof
name|LeafQueue
operator|)
condition|)
block|{
return|return
name|lifetimeRequestedByApp
return|;
block|}
name|long
name|defaultApplicationLifetime
init|=
operator|(
operator|(
name|LeafQueue
operator|)
name|queue
operator|)
operator|.
name|getDefaultApplicationLifetime
argument_list|()
decl_stmt|;
name|long
name|maximumApplicationLifetime
init|=
operator|(
operator|(
name|LeafQueue
operator|)
name|queue
operator|)
operator|.
name|getMaximumApplicationLifetime
argument_list|()
decl_stmt|;
comment|// check only for maximum, that's enough because default can't
comment|// exceed maximum
if|if
condition|(
name|maximumApplicationLifetime
operator|<=
literal|0
condition|)
block|{
return|return
name|lifetimeRequestedByApp
return|;
block|}
if|if
condition|(
name|lifetimeRequestedByApp
operator|<=
literal|0
condition|)
block|{
return|return
name|defaultApplicationLifetime
return|;
block|}
elseif|else
if|if
condition|(
name|lifetimeRequestedByApp
operator|>
name|maximumApplicationLifetime
condition|)
block|{
return|return
name|maximumApplicationLifetime
return|;
block|}
return|return
name|lifetimeRequestedByApp
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getMaximumApplicationLifetime (String queueName)
specifier|public
name|long
name|getMaximumApplicationLifetime
parameter_list|(
name|String
name|queueName
parameter_list|)
block|{
name|CSQueue
name|queue
init|=
name|getQueue
argument_list|(
name|queueName
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
operator|||
operator|!
operator|(
name|queue
operator|instanceof
name|LeafQueue
operator|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unknown queue: "
operator|+
name|queueName
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|// In seconds
return|return
operator|(
operator|(
name|LeafQueue
operator|)
name|queue
operator|)
operator|.
name|getMaximumApplicationLifetime
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isConfigurationMutable ()
specifier|public
name|boolean
name|isConfigurationMutable
parameter_list|()
block|{
return|return
name|csConfProvider
operator|instanceof
name|MutableConfigurationProvider
return|;
block|}
annotation|@
name|Override
DECL|method|getMutableConfProvider ()
specifier|public
name|MutableConfigurationProvider
name|getMutableConfProvider
parameter_list|()
block|{
if|if
condition|(
name|isConfigurationMutable
argument_list|()
condition|)
block|{
return|return
operator|(
name|MutableConfigurationProvider
operator|)
name|csConfProvider
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|autoCreateLeafQueue ( ApplicationPlacementContext placementContext)
specifier|private
name|LeafQueue
name|autoCreateLeafQueue
parameter_list|(
name|ApplicationPlacementContext
name|placementContext
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
name|AutoCreatedLeafQueue
name|autoCreatedLeafQueue
init|=
literal|null
decl_stmt|;
name|String
name|leafQueueName
init|=
name|placementContext
operator|.
name|getQueue
argument_list|()
decl_stmt|;
name|String
name|parentQueueName
init|=
name|placementContext
operator|.
name|getParentQueue
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|parentQueueName
argument_list|)
condition|)
block|{
name|CSQueue
name|parentQueue
init|=
name|getQueue
argument_list|(
name|parentQueueName
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentQueue
operator|!=
literal|null
operator|&&
name|conf
operator|.
name|isAutoCreateChildQueueEnabled
argument_list|(
name|parentQueue
operator|.
name|getQueuePath
argument_list|()
argument_list|)
condition|)
block|{
name|ManagedParentQueue
name|autoCreateEnabledParentQueue
init|=
operator|(
name|ManagedParentQueue
operator|)
name|parentQueue
decl_stmt|;
name|autoCreatedLeafQueue
operator|=
operator|new
name|AutoCreatedLeafQueue
argument_list|(
name|this
argument_list|,
name|leafQueueName
argument_list|,
name|autoCreateEnabledParentQueue
argument_list|)
expr_stmt|;
name|addQueue
argument_list|(
name|autoCreatedLeafQueue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SchedulerDynamicEditException
argument_list|(
literal|"Could not auto-create leaf queue for "
operator|+
name|leafQueueName
operator|+
literal|". Queue mapping specifies an invalid parent queue "
operator|+
literal|"which does not exist "
operator|+
name|parentQueueName
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|SchedulerDynamicEditException
argument_list|(
literal|"Could not auto-create leaf queue for "
operator|+
name|leafQueueName
operator|+
literal|". Queue mapping does not specify"
operator|+
literal|" which parent queue it needs to be created under."
argument_list|)
throw|;
block|}
return|return
name|autoCreatedLeafQueue
return|;
block|}
annotation|@
name|Override
DECL|method|resetSchedulerMetrics ()
specifier|public
name|void
name|resetSchedulerMetrics
parameter_list|()
block|{
name|CapacitySchedulerMetrics
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

