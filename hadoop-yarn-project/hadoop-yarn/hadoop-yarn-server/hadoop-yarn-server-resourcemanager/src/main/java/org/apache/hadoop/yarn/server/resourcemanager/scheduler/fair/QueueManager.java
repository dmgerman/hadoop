begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|fair
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|xml
operator|.
name|parsers
operator|.
name|ParserConfigurationException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableList
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|Private
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
operator|.
name|Unstable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|fair
operator|.
name|policies
operator|.
name|FifoPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xml
operator|.
name|sax
operator|.
name|SAXException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * Maintains a list of queues as well as scheduling parameters for each queue,  * such as guaranteed share allocations, from the fair scheduler config file.  */
end_comment

begin_class
annotation|@
name|Private
annotation|@
name|Unstable
DECL|class|QueueManager
specifier|public
class|class
name|QueueManager
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|QueueManager
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|class|IncompatibleQueueRemovalTask
specifier|private
specifier|final
class|class
name|IncompatibleQueueRemovalTask
block|{
DECL|field|queueToCreate
specifier|private
specifier|final
name|String
name|queueToCreate
decl_stmt|;
DECL|field|queueType
specifier|private
specifier|final
name|FSQueueType
name|queueType
decl_stmt|;
DECL|method|IncompatibleQueueRemovalTask (String queueToCreate, FSQueueType queueType)
specifier|private
name|IncompatibleQueueRemovalTask
parameter_list|(
name|String
name|queueToCreate
parameter_list|,
name|FSQueueType
name|queueType
parameter_list|)
block|{
name|this
operator|.
name|queueToCreate
operator|=
name|queueToCreate
expr_stmt|;
name|this
operator|.
name|queueType
operator|=
name|queueType
expr_stmt|;
block|}
DECL|method|execute ()
specifier|private
name|void
name|execute
parameter_list|()
block|{
name|Boolean
name|removed
init|=
name|removeEmptyIncompatibleQueues
argument_list|(
name|queueToCreate
argument_list|,
name|queueType
argument_list|)
operator|.
name|orElse
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|Boolean
operator|.
name|TRUE
operator|.
name|equals
argument_list|(
name|removed
argument_list|)
condition|)
block|{
name|FSQueue
name|queue
init|=
name|getQueue
argument_list|(
name|queueToCreate
argument_list|,
literal|true
argument_list|,
name|queueType
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|!=
literal|null
operator|&&
comment|// if queueToCreate is present in the allocation config, set it
comment|// to static
name|scheduler
operator|.
name|allocConf
operator|.
name|configuredQueues
operator|.
name|values
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|anyMatch
argument_list|(
name|s
lambda|->
name|s
operator|.
name|contains
argument_list|(
name|queueToCreate
argument_list|)
argument_list|)
condition|)
block|{
name|queue
operator|.
name|setDynamic
argument_list|(
literal|false
argument_list|)
block|;         }
block|}
if|if
condition|(
operator|!
name|Boolean
operator|.
name|FALSE
operator|.
name|equals
argument_list|(
name|removed
argument_list|)
condition|)
block|{
name|incompatibleQueuesPendingRemoval
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|field|ROOT_QUEUE
specifier|public
specifier|static
specifier|final
name|String
name|ROOT_QUEUE
init|=
literal|"root"
decl_stmt|;
DECL|field|scheduler
specifier|private
specifier|final
name|FairScheduler
name|scheduler
decl_stmt|;
DECL|field|leafQueues
specifier|private
specifier|final
name|Collection
argument_list|<
name|FSLeafQueue
argument_list|>
name|leafQueues
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|queues
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|FSQueue
argument_list|>
name|queues
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|incompatibleQueuesPendingRemoval
specifier|private
name|Set
argument_list|<
name|IncompatibleQueueRemovalTask
argument_list|>
name|incompatibleQueuesPendingRemoval
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|rootQueue
specifier|private
name|FSParentQueue
name|rootQueue
decl_stmt|;
DECL|method|QueueManager (FairScheduler scheduler)
specifier|public
name|QueueManager
parameter_list|(
name|FairScheduler
name|scheduler
parameter_list|)
block|{
name|this
operator|.
name|scheduler
operator|=
name|scheduler
expr_stmt|;
block|}
DECL|method|getRootQueue ()
specifier|public
name|FSParentQueue
name|getRootQueue
parameter_list|()
block|{
return|return
name|rootQueue
return|;
block|}
DECL|method|initialize (Configuration conf)
specifier|public
name|void
name|initialize
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|SAXException
throws|,
name|AllocationConfigurationException
throws|,
name|ParserConfigurationException
block|{
comment|// Policies of root and default queue are set to
comment|// SchedulingPolicy.DEFAULT_POLICY since the allocation file hasn't been
comment|// loaded yet.
name|rootQueue
operator|=
operator|new
name|FSParentQueue
argument_list|(
literal|"root"
argument_list|,
name|scheduler
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|rootQueue
operator|.
name|setDynamic
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|queues
operator|.
name|put
argument_list|(
name|rootQueue
operator|.
name|getName
argument_list|()
argument_list|,
name|rootQueue
argument_list|)
expr_stmt|;
comment|// Create the default queue
name|FSLeafQueue
name|defaultQueue
init|=
name|getLeafQueue
argument_list|(
name|YarnConfiguration
operator|.
name|DEFAULT_QUEUE_NAME
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|defaultQueue
operator|.
name|setDynamic
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Recursively reinitialize to propagate queue properties
name|rootQueue
operator|.
name|reinit
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get a leaf queue by name, creating it if the create param is    *<code>true</code> and the queue does not exist.    * If the queue is not or can not be a leaf queue, i.e. it already exists as    * a parent queue, or one of the parents in its name is already a leaf queue,    *<code>null</code> is returned.    *     * The root part of the name is optional, so a queue underneath the root     * named "queue1" could be referred to  as just "queue1", and a queue named    * "queue2" underneath a parent named "parent1" that is underneath the root     * could be referred to as just "parent1.queue2".    * @param name name of the queue    * @param create<code>true</code> if the queue must be created if it does    *               not exist,<code>false</code> otherwise    * @return the leaf queue or<code>null</code> if the queue cannot be found    */
DECL|method|getLeafQueue (String name, boolean create)
specifier|public
name|FSLeafQueue
name|getLeafQueue
parameter_list|(
name|String
name|name
parameter_list|,
name|boolean
name|create
parameter_list|)
block|{
return|return
name|getLeafQueue
argument_list|(
name|name
argument_list|,
name|create
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Get a leaf queue by name, creating it if the create param is    *<code>true</code> and the queue does not exist.    * If the queue is not or can not be a leaf queue, i.e. it already exists as    * a parent queue, or one of the parents in its name is already a leaf queue,    *<code>null</code> is returned.    *    * If the application will be assigned to the queue if the applicationId is    * not<code>null</code>    * @param name name of the queue    * @param create<code>true</code> if the queue must be created if it does    *               not exist,<code>false</code> otherwise    * @param applicationId the application ID to assign to the queue    * @return the leaf queue or<code>null</code> if teh queue cannot be found    */
DECL|method|getLeafQueue (String name, boolean create, ApplicationId applicationId)
specifier|public
name|FSLeafQueue
name|getLeafQueue
parameter_list|(
name|String
name|name
parameter_list|,
name|boolean
name|create
parameter_list|,
name|ApplicationId
name|applicationId
parameter_list|)
block|{
return|return
name|getLeafQueue
argument_list|(
name|name
argument_list|,
name|create
argument_list|,
name|applicationId
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|getLeafQueue (String name, boolean create, ApplicationId applicationId, boolean recomputeSteadyShares)
specifier|private
name|FSLeafQueue
name|getLeafQueue
parameter_list|(
name|String
name|name
parameter_list|,
name|boolean
name|create
parameter_list|,
name|ApplicationId
name|applicationId
parameter_list|,
name|boolean
name|recomputeSteadyShares
parameter_list|)
block|{
name|FSQueue
name|queue
init|=
name|getQueue
argument_list|(
name|name
argument_list|,
name|create
argument_list|,
name|FSQueueType
operator|.
name|LEAF
argument_list|,
name|recomputeSteadyShares
argument_list|,
name|applicationId
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|instanceof
name|FSParentQueue
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|(
name|FSLeafQueue
operator|)
name|queue
return|;
block|}
comment|/**    * Remove a leaf queue if empty.    * @param name name of the queue    * @return true if queue was removed or false otherwise    */
DECL|method|removeLeafQueue (String name)
specifier|public
name|boolean
name|removeLeafQueue
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|name
operator|=
name|ensureRootPrefix
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|!
name|Boolean
operator|.
name|FALSE
operator|.
name|equals
argument_list|(
name|removeEmptyIncompatibleQueues
argument_list|(
name|name
argument_list|,
name|FSQueueType
operator|.
name|PARENT
argument_list|)
operator|.
name|orElse
argument_list|(
literal|null
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get a parent queue by name, creating it if the create param is    *<code>true</code> and the queue does not exist.    * If the queue is not or can not be a parent queue, i.e. it already exists    * as a leaf queue, or one of the parents in its name is already a leaf    * queue,<code>null</code> is returned.    *     * The root part of the name is optional, so a queue underneath the root     * named "queue1" could be referred to  as just "queue1", and a queue named    * "queue2" underneath a parent named "parent1" that is underneath the root     * could be referred to as just "parent1.queue2".    * @param name name of the queue    * @param create<code>true</code> if the queue must be created if it does    *               not exist,<code>false</code> otherwise    * @return the parent queue or<code>null</code> if the queue cannot be found    */
DECL|method|getParentQueue (String name, boolean create)
specifier|public
name|FSParentQueue
name|getParentQueue
parameter_list|(
name|String
name|name
parameter_list|,
name|boolean
name|create
parameter_list|)
block|{
return|return
name|getParentQueue
argument_list|(
name|name
argument_list|,
name|create
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Get a parent queue by name, creating it if the create param is    *<code>true</code> and the queue does not exist.    * If the queue is not or can not be a parent queue, i.e. it already exists    * as a leaf queue, or one of the parents in its name is already a leaf    * queue,<code>null</code> is returned.    *    * The root part of the name is optional, so a queue underneath the root    * named "queue1" could be referred to  as just "queue1", and a queue named    * "queue2" underneath a parent named "parent1" that is underneath the root    * could be referred to as just "parent1.queue2".    * @param name name of the queue    * @param create<code>true</code> if the queue must be created if it does    *               not exist,<code>false</code> otherwise    * @param recomputeSteadyShares<code>true</code> if the steady fair share    *                              should be recalculated when a queue is added,    *<code>false</code> otherwise    * @return the parent queue or<code>null</code> if the queue cannot be found    */
DECL|method|getParentQueue (String name, boolean create, boolean recomputeSteadyShares)
specifier|public
name|FSParentQueue
name|getParentQueue
parameter_list|(
name|String
name|name
parameter_list|,
name|boolean
name|create
parameter_list|,
name|boolean
name|recomputeSteadyShares
parameter_list|)
block|{
name|FSQueue
name|queue
init|=
name|getQueue
argument_list|(
name|name
argument_list|,
name|create
argument_list|,
name|FSQueueType
operator|.
name|PARENT
argument_list|,
name|recomputeSteadyShares
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|instanceof
name|FSLeafQueue
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|(
name|FSParentQueue
operator|)
name|queue
return|;
block|}
DECL|method|getQueue (String name, boolean create, FSQueueType queueType, boolean recomputeSteadyShares, ApplicationId applicationId)
specifier|private
name|FSQueue
name|getQueue
parameter_list|(
name|String
name|name
parameter_list|,
name|boolean
name|create
parameter_list|,
name|FSQueueType
name|queueType
parameter_list|,
name|boolean
name|recomputeSteadyShares
parameter_list|,
name|ApplicationId
name|applicationId
parameter_list|)
block|{
name|boolean
name|recompute
init|=
name|recomputeSteadyShares
decl_stmt|;
name|name
operator|=
name|ensureRootPrefix
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|FSQueue
name|queue
decl_stmt|;
synchronized|synchronized
init|(
name|queues
init|)
block|{
name|queue
operator|=
name|queues
operator|.
name|get
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
operator|&&
name|create
condition|)
block|{
comment|// if the queue doesn't exist,create it and return
name|queue
operator|=
name|createQueue
argument_list|(
name|name
argument_list|,
name|queueType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|recompute
operator|=
literal|false
expr_stmt|;
block|}
comment|// At this point the queue exists and we need to assign the app if to the
comment|// but only to a leaf queue
if|if
condition|(
name|applicationId
operator|!=
literal|null
operator|&&
name|queue
operator|instanceof
name|FSLeafQueue
condition|)
block|{
operator|(
operator|(
name|FSLeafQueue
operator|)
name|queue
operator|)
operator|.
name|addAssignedApp
argument_list|(
name|applicationId
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Don't recompute if it is an existing queue or no change was made
if|if
condition|(
name|recompute
operator|&&
name|queue
operator|!=
literal|null
condition|)
block|{
name|rootQueue
operator|.
name|recomputeSteadyShares
argument_list|()
expr_stmt|;
block|}
return|return
name|queue
return|;
block|}
comment|/**    * Create a leaf or parent queue based on what is specified in    * {@code queueType} and place it in the tree. Create any parents that don't    * already exist.    *     * @return the created queue, if successful or null if not allowed (one of the    * parent queues in the queue name is already a leaf queue)    */
annotation|@
name|VisibleForTesting
DECL|method|createQueue (String name, FSQueueType queueType)
name|FSQueue
name|createQueue
parameter_list|(
name|String
name|name
parameter_list|,
name|FSQueueType
name|queueType
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|newQueueNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|FSParentQueue
name|parent
init|=
name|buildNewQueueList
argument_list|(
name|name
argument_list|,
name|newQueueNames
argument_list|)
decl_stmt|;
name|FSQueue
name|queue
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
comment|// Now that we know everything worked out, make all the queues
comment|// and add them to the map.
name|queue
operator|=
name|createNewQueues
argument_list|(
name|queueType
argument_list|,
name|parent
argument_list|,
name|newQueueNames
argument_list|)
expr_stmt|;
block|}
return|return
name|queue
return|;
block|}
comment|/**    * Compile a list of all parent queues of the given queue name that do not    * already exist. The queue names will be added to the {@code newQueueNames}    * list. The list will be in order of increasing queue depth. The first    * element of the list will be the parent closest to the root. The last    * element added will be the queue to be created. This method returns the    * deepest parent that does exist.    *    * @param name the fully qualified name of the queue to create    * @param newQueueNames the list to which to add non-existent queues    * @return the deepest existing parent queue    */
DECL|method|buildNewQueueList (String name, List<String> newQueueNames)
specifier|private
name|FSParentQueue
name|buildNewQueueList
parameter_list|(
name|String
name|name
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|newQueueNames
parameter_list|)
block|{
name|newQueueNames
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|int
name|sepIndex
init|=
name|name
operator|.
name|length
argument_list|()
decl_stmt|;
name|FSParentQueue
name|parent
init|=
literal|null
decl_stmt|;
comment|// Move up the queue tree until we reach one that exists.
while|while
condition|(
name|sepIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|prevSepIndex
init|=
name|sepIndex
decl_stmt|;
name|sepIndex
operator|=
name|name
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|,
name|sepIndex
operator|-
literal|1
argument_list|)
expr_stmt|;
name|String
name|node
init|=
name|name
operator|.
name|substring
argument_list|(
name|sepIndex
operator|+
literal|1
argument_list|,
name|prevSepIndex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isQueueNameValid
argument_list|(
name|node
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InvalidQueueNameException
argument_list|(
literal|"Illegal node name at offset "
operator|+
operator|(
name|sepIndex
operator|+
literal|1
operator|)
operator|+
literal|" for queue name "
operator|+
name|name
argument_list|)
throw|;
block|}
name|String
name|curName
init|=
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|sepIndex
argument_list|)
decl_stmt|;
name|FSQueue
name|queue
init|=
name|queues
operator|.
name|get
argument_list|(
name|curName
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|==
literal|null
condition|)
block|{
name|newQueueNames
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|curName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|queue
operator|instanceof
name|FSParentQueue
condition|)
block|{
name|parent
operator|=
operator|(
name|FSParentQueue
operator|)
name|queue
expr_stmt|;
block|}
comment|// If the queue isn't a parent queue, parent will still be null when
comment|// we break
break|break;
block|}
block|}
return|return
name|parent
return|;
block|}
comment|/**    * Create all queues in the {@code newQueueNames} list. The list must be in    * order of increasing depth. All but the last element in the list will be    * created as parent queues. The last element will be created as the type    * specified by the {@code queueType} parameter. The first queue will be    * created as a child of the {@code topParent} queue. All subsequent queues    * will be created as a child of the previously created queue.    *    * @param queueType the type of the last queue to create    * @param topParent the parent of the first queue to create    * @param newQueueNames the list of queues to create    * @return the last queue created    */
DECL|method|createNewQueues (FSQueueType queueType, FSParentQueue topParent, List<String> newQueueNames)
specifier|private
name|FSQueue
name|createNewQueues
parameter_list|(
name|FSQueueType
name|queueType
parameter_list|,
name|FSParentQueue
name|topParent
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|newQueueNames
parameter_list|)
block|{
name|AllocationConfiguration
name|queueConf
init|=
name|scheduler
operator|.
name|getAllocationConfiguration
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|String
argument_list|>
name|i
init|=
name|newQueueNames
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|FSParentQueue
name|parent
init|=
name|topParent
decl_stmt|;
name|FSQueue
name|queue
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|i
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|FSParentQueue
name|newParent
init|=
literal|null
decl_stmt|;
name|String
name|queueName
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// Check if child policy is allowed
name|SchedulingPolicy
name|childPolicy
init|=
name|scheduler
operator|.
name|getAllocationConfiguration
argument_list|()
operator|.
name|getSchedulingPolicy
argument_list|(
name|queueName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|parent
operator|.
name|getPolicy
argument_list|()
operator|.
name|isChildPolicyAllowed
argument_list|(
name|childPolicy
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Can't create queue '"
operator|+
name|queueName
operator|+
literal|"',"
operator|+
literal|"the child scheduling policy is not allowed by parent queue!"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Only create a leaf queue at the very end
if|if
condition|(
operator|!
name|i
operator|.
name|hasNext
argument_list|()
operator|&&
operator|(
name|queueType
operator|!=
name|FSQueueType
operator|.
name|PARENT
operator|)
condition|)
block|{
name|FSLeafQueue
name|leafQueue
init|=
operator|new
name|FSLeafQueue
argument_list|(
name|queueName
argument_list|,
name|scheduler
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|leafQueues
operator|.
name|add
argument_list|(
name|leafQueue
argument_list|)
expr_stmt|;
name|queue
operator|=
name|leafQueue
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|childPolicy
operator|instanceof
name|FifoPolicy
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Can't create queue '"
operator|+
name|queueName
operator|+
literal|"', since "
operator|+
name|FifoPolicy
operator|.
name|NAME
operator|+
literal|" is only for leaf queues."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|newParent
operator|=
operator|new
name|FSParentQueue
argument_list|(
name|queueName
argument_list|,
name|scheduler
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|queue
operator|=
name|newParent
expr_stmt|;
block|}
name|parent
operator|.
name|addChildQueue
argument_list|(
name|queue
argument_list|)
expr_stmt|;
name|setChildResourceLimits
argument_list|(
name|parent
argument_list|,
name|queue
argument_list|,
name|queueConf
argument_list|)
expr_stmt|;
name|queues
operator|.
name|put
argument_list|(
name|queue
operator|.
name|getName
argument_list|()
argument_list|,
name|queue
argument_list|)
expr_stmt|;
comment|// If we just created a leaf node, the newParent is null, but that's OK
comment|// because we only create a leaf node in the very last iteration.
name|parent
operator|=
name|newParent
expr_stmt|;
block|}
return|return
name|queue
return|;
block|}
comment|/**    * For the given child queue, set the max resources based on the    * parent queue's default child resource settings. This method assumes that    * the child queue is ad hoc and hence does not do any safety checks around    * overwriting existing max resource settings.    *    * @param parent the parent queue    * @param child the child queue    * @param queueConf the {@link AllocationConfiguration}    */
DECL|method|setChildResourceLimits (FSParentQueue parent, FSQueue child, AllocationConfiguration queueConf)
specifier|private
name|void
name|setChildResourceLimits
parameter_list|(
name|FSParentQueue
name|parent
parameter_list|,
name|FSQueue
name|child
parameter_list|,
name|AllocationConfiguration
name|queueConf
parameter_list|)
block|{
name|Map
argument_list|<
name|FSQueueType
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|configuredQueues
init|=
name|queueConf
operator|.
name|getConfiguredQueues
argument_list|()
decl_stmt|;
comment|// Ad hoc queues do not exist in the configured queues map
if|if
condition|(
operator|!
name|configuredQueues
operator|.
name|get
argument_list|(
name|FSQueueType
operator|.
name|LEAF
argument_list|)
operator|.
name|contains
argument_list|(
name|child
operator|.
name|getName
argument_list|()
argument_list|)
operator|&&
operator|!
name|configuredQueues
operator|.
name|get
argument_list|(
name|FSQueueType
operator|.
name|PARENT
argument_list|)
operator|.
name|contains
argument_list|(
name|child
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
comment|// For ad hoc queues, set their max reource allocations based on
comment|// their parents' default child settings.
name|ConfigurableResource
name|maxChild
init|=
name|parent
operator|.
name|getMaxChildQueueResource
argument_list|()
decl_stmt|;
if|if
condition|(
name|maxChild
operator|!=
literal|null
condition|)
block|{
name|child
operator|.
name|setMaxShare
argument_list|(
name|maxChild
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Make way for the given queue if possible, by removing incompatible    * queues with no apps in them. Incompatibility could be due to    * (1) queueToCreate being currently a parent but needs to change to leaf    * (2) queueToCreate being currently a leaf but needs to change to parent    * (3) an existing leaf queue in the ancestry of queueToCreate.    *     * We will never remove the root queue or the default queue in this way.    *    * @return Optional.of(Boolean.TRUE)  if there was an incompatible queue that    *                                    has been removed,    *         Optional.of(Boolean.FALSE) if there was an incompatible queue that    *                                    have not be removed,    *         Optional.empty()           if there is no incompatible queue.    */
DECL|method|removeEmptyIncompatibleQueues (String queueToCreate, FSQueueType queueType)
specifier|private
name|Optional
argument_list|<
name|Boolean
argument_list|>
name|removeEmptyIncompatibleQueues
parameter_list|(
name|String
name|queueToCreate
parameter_list|,
name|FSQueueType
name|queueType
parameter_list|)
block|{
name|queueToCreate
operator|=
name|ensureRootPrefix
argument_list|(
name|queueToCreate
argument_list|)
expr_stmt|;
comment|// Ensure queueToCreate is not root and doesn't
comment|// have the default queue in its ancestry.
if|if
condition|(
name|queueToCreate
operator|.
name|equals
argument_list|(
name|ROOT_QUEUE
argument_list|)
operator|||
name|queueToCreate
operator|.
name|startsWith
argument_list|(
name|ROOT_QUEUE
operator|+
literal|"."
operator|+
name|YarnConfiguration
operator|.
name|DEFAULT_QUEUE_NAME
operator|+
literal|"."
argument_list|)
condition|)
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
name|FSQueue
name|queue
init|=
name|queues
operator|.
name|get
argument_list|(
name|queueToCreate
argument_list|)
decl_stmt|;
comment|// Queue exists already.
if|if
condition|(
name|queue
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|queue
operator|instanceof
name|FSLeafQueue
condition|)
block|{
if|if
condition|(
name|queueType
operator|==
name|FSQueueType
operator|.
name|LEAF
condition|)
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
comment|// remove incompatibility since queue is a leaf currently
comment|// needs to change to a parent.
return|return
name|Optional
operator|.
name|of
argument_list|(
name|removeQueueIfEmpty
argument_list|(
name|queue
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|queueType
operator|==
name|FSQueueType
operator|.
name|PARENT
condition|)
block|{
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
comment|// If it's an existing parent queue and needs to change to leaf,
comment|// remove it if it's empty.
return|return
name|Optional
operator|.
name|of
argument_list|(
name|removeQueueIfEmpty
argument_list|(
name|queue
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|// Queue doesn't exist already. Check if the new queue would be created
comment|// under an existing leaf queue. If so, try removing that leaf queue.
name|int
name|sepIndex
init|=
name|queueToCreate
operator|.
name|length
argument_list|()
decl_stmt|;
name|sepIndex
operator|=
name|queueToCreate
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|,
name|sepIndex
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|sepIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|String
name|prefixString
init|=
name|queueToCreate
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|sepIndex
argument_list|)
decl_stmt|;
name|FSQueue
name|prefixQueue
init|=
name|queues
operator|.
name|get
argument_list|(
name|prefixString
argument_list|)
decl_stmt|;
if|if
condition|(
name|prefixQueue
operator|!=
literal|null
operator|&&
name|prefixQueue
operator|instanceof
name|FSLeafQueue
condition|)
block|{
return|return
name|Optional
operator|.
name|of
argument_list|(
name|removeQueueIfEmpty
argument_list|(
name|prefixQueue
argument_list|)
argument_list|)
return|;
block|}
name|sepIndex
operator|=
name|queueToCreate
operator|.
name|lastIndexOf
argument_list|(
literal|'.'
argument_list|,
name|sepIndex
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|Optional
operator|.
name|empty
argument_list|()
return|;
block|}
comment|/**    * Removes all empty dynamic queues (including empty dynamic parent queues).    */
DECL|method|removeEmptyDynamicQueues ()
specifier|public
name|void
name|removeEmptyDynamicQueues
parameter_list|()
block|{
synchronized|synchronized
init|(
name|queues
init|)
block|{
name|Set
argument_list|<
name|FSParentQueue
argument_list|>
name|parentQueuesToCheck
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|FSQueue
name|queue
range|:
name|getQueues
argument_list|()
control|)
block|{
if|if
condition|(
name|queue
operator|.
name|isDynamic
argument_list|()
operator|&&
name|queue
operator|.
name|getChildQueues
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|boolean
name|removed
init|=
name|removeQueueIfEmpty
argument_list|(
name|queue
argument_list|)
decl_stmt|;
if|if
condition|(
name|removed
operator|&&
name|queue
operator|.
name|getParent
argument_list|()
operator|.
name|isDynamic
argument_list|()
condition|)
block|{
name|parentQueuesToCheck
operator|.
name|add
argument_list|(
name|queue
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
operator|!
name|parentQueuesToCheck
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|FSParentQueue
name|queue
init|=
name|parentQueuesToCheck
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|queue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|removeQueue
argument_list|(
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|queue
operator|.
name|getParent
argument_list|()
operator|.
name|isDynamic
argument_list|()
condition|)
block|{
name|parentQueuesToCheck
operator|.
name|add
argument_list|(
name|queue
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|parentQueuesToCheck
operator|.
name|remove
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Re-checking incompatible queues that could not be removed earlier due to    * not being empty, and removing those that became empty.    */
DECL|method|removePendingIncompatibleQueues ()
specifier|public
name|void
name|removePendingIncompatibleQueues
parameter_list|()
block|{
synchronized|synchronized
init|(
name|queues
init|)
block|{
for|for
control|(
name|IncompatibleQueueRemovalTask
name|removalTask
range|:
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|incompatibleQueuesPendingRemoval
argument_list|)
control|)
block|{
name|removalTask
operator|.
name|execute
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Remove the queue if it and its descendents are all empty.    * @param queue    * @return true if removed, false otherwise    */
DECL|method|removeQueueIfEmpty (FSQueue queue)
specifier|private
name|boolean
name|removeQueueIfEmpty
parameter_list|(
name|FSQueue
name|queue
parameter_list|)
block|{
if|if
condition|(
name|queue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|removeQueue
argument_list|(
name|queue
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Remove a queue and all its descendents.    */
DECL|method|removeQueue (FSQueue queue)
specifier|private
name|void
name|removeQueue
parameter_list|(
name|FSQueue
name|queue
parameter_list|)
block|{
synchronized|synchronized
init|(
name|queues
init|)
block|{
if|if
condition|(
name|queue
operator|instanceof
name|FSLeafQueue
condition|)
block|{
name|leafQueues
operator|.
name|remove
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|FSQueue
name|childQueue
range|:
name|queue
operator|.
name|getChildQueues
argument_list|()
control|)
block|{
name|removeQueue
argument_list|(
name|childQueue
argument_list|)
expr_stmt|;
block|}
block|}
name|queues
operator|.
name|remove
argument_list|(
name|queue
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|FSParentQueue
name|parent
init|=
name|queue
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|parent
operator|.
name|removeChildQueue
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Gets a queue by name.    */
DECL|method|getQueue (String name)
specifier|public
name|FSQueue
name|getQueue
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|name
operator|=
name|ensureRootPrefix
argument_list|(
name|name
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|queues
init|)
block|{
return|return
name|queues
operator|.
name|get
argument_list|(
name|name
argument_list|)
return|;
block|}
block|}
comment|/**    * Return whether a queue exists already.    */
DECL|method|exists (String name)
specifier|public
name|boolean
name|exists
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|name
operator|=
name|ensureRootPrefix
argument_list|(
name|name
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|queues
init|)
block|{
return|return
name|queues
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
return|;
block|}
block|}
comment|/**    * Get a collection of all leaf queues.    */
DECL|method|getLeafQueues ()
specifier|public
name|Collection
argument_list|<
name|FSLeafQueue
argument_list|>
name|getLeafQueues
parameter_list|()
block|{
synchronized|synchronized
init|(
name|queues
init|)
block|{
return|return
name|leafQueues
return|;
block|}
block|}
comment|/**    * Get a collection of all queues.    */
DECL|method|getQueues ()
specifier|public
name|Collection
argument_list|<
name|FSQueue
argument_list|>
name|getQueues
parameter_list|()
block|{
synchronized|synchronized
init|(
name|queues
init|)
block|{
return|return
name|ImmutableList
operator|.
name|copyOf
argument_list|(
name|queues
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
block|}
DECL|method|ensureRootPrefix (String name)
specifier|private
specifier|static
name|String
name|ensureRootPrefix
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|name
operator|.
name|startsWith
argument_list|(
name|ROOT_QUEUE
operator|+
literal|"."
argument_list|)
operator|&&
operator|!
name|name
operator|.
name|equals
argument_list|(
name|ROOT_QUEUE
argument_list|)
condition|)
block|{
name|name
operator|=
name|ROOT_QUEUE
operator|+
literal|"."
operator|+
name|name
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
DECL|method|updateAllocationConfiguration (AllocationConfiguration queueConf)
specifier|public
name|void
name|updateAllocationConfiguration
parameter_list|(
name|AllocationConfiguration
name|queueConf
parameter_list|)
block|{
comment|// Create leaf queues and the parent queues in a leaf's
comment|// ancestry if they do not exist
synchronized|synchronized
init|(
name|queues
init|)
block|{
comment|// Verify and set scheduling policies for existing queues before creating
comment|// any queue, since we need parent policies to determine if we can create
comment|// its children.
if|if
condition|(
operator|!
name|rootQueue
operator|.
name|verifyAndSetPolicyFromConf
argument_list|(
name|queueConf
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Setting scheduling policies for existing queues failed!"
argument_list|)
expr_stmt|;
block|}
name|ensureQueueExistsAndIsCompatibleAndIsStatic
argument_list|(
name|queueConf
argument_list|,
name|FSQueueType
operator|.
name|LEAF
argument_list|)
expr_stmt|;
comment|// At this point all leaves and 'parents with
comment|// at least one child' would have been created.
comment|// Now create parents with no configured leaf.
name|ensureQueueExistsAndIsCompatibleAndIsStatic
argument_list|(
name|queueConf
argument_list|,
name|FSQueueType
operator|.
name|PARENT
argument_list|)
expr_stmt|;
block|}
comment|// Initialize all queues recursively
name|rootQueue
operator|.
name|reinit
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Update steady fair shares for all queues
name|rootQueue
operator|.
name|recomputeSteadyShares
argument_list|()
expr_stmt|;
block|}
DECL|method|ensureQueueExistsAndIsCompatibleAndIsStatic ( AllocationConfiguration queueConf, FSQueueType queueType)
specifier|private
name|void
name|ensureQueueExistsAndIsCompatibleAndIsStatic
parameter_list|(
name|AllocationConfiguration
name|queueConf
parameter_list|,
name|FSQueueType
name|queueType
parameter_list|)
block|{
for|for
control|(
name|String
name|name
range|:
name|queueConf
operator|.
name|getConfiguredQueues
argument_list|()
operator|.
name|get
argument_list|(
name|queueType
argument_list|)
control|)
block|{
name|Boolean
name|removed
init|=
name|removeEmptyIncompatibleQueues
argument_list|(
name|name
argument_list|,
name|queueType
argument_list|)
operator|.
name|orElse
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|Boolean
operator|.
name|FALSE
operator|.
name|equals
argument_list|(
name|removed
argument_list|)
condition|)
block|{
name|incompatibleQueuesPendingRemoval
operator|.
name|add
argument_list|(
operator|new
name|IncompatibleQueueRemovalTask
argument_list|(
name|name
argument_list|,
name|queueType
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FSQueue
name|queue
init|=
name|getQueue
argument_list|(
name|name
argument_list|,
literal|true
argument_list|,
name|queueType
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|queue
operator|!=
literal|null
condition|)
block|{
name|queue
operator|.
name|setDynamic
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Setting a set of queues to dynamic.    * @param queueNames The names of the queues to be set to dynamic    */
DECL|method|setQueuesToDynamic (Set<String> queueNames)
specifier|protected
name|void
name|setQueuesToDynamic
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|queueNames
parameter_list|)
block|{
synchronized|synchronized
init|(
name|queues
init|)
block|{
for|for
control|(
name|String
name|queueName
range|:
name|queueNames
control|)
block|{
name|queues
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
operator|.
name|setDynamic
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Check whether queue name is valid,    * return true if it is valid, otherwise return false.    */
annotation|@
name|VisibleForTesting
DECL|method|isQueueNameValid (String node)
name|boolean
name|isQueueNameValid
parameter_list|(
name|String
name|node
parameter_list|)
block|{
comment|// use the same white space trim as in QueueMetrics() otherwise things fail
comment|// This needs to trim additional Unicode whitespace characters beyond what
comment|// the built-in JDK methods consider whitespace. See YARN-5272.
return|return
operator|!
name|node
operator|.
name|isEmpty
argument_list|()
operator|&&
name|node
operator|.
name|equals
argument_list|(
name|FairSchedulerUtilities
operator|.
name|trimQueueName
argument_list|(
name|node
argument_list|)
argument_list|)
return|;
block|}
block|}
end_class

end_unit

