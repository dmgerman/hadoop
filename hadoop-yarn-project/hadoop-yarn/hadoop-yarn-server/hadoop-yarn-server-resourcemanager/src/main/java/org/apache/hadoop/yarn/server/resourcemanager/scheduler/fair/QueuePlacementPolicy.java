begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|fair
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|Private
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
operator|.
name|Unstable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|placement
operator|.
name|DefaultPlacementRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|placement
operator|.
name|FSPlacementRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|placement
operator|.
name|PlacementRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|placement
operator|.
name|PrimaryGroupPlacementRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|placement
operator|.
name|RejectPlacementRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|placement
operator|.
name|SecondaryGroupExistingPlacementRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|placement
operator|.
name|SpecifiedPlacementRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|placement
operator|.
name|UserPlacementRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Element
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|w3c
operator|.
name|dom
operator|.
name|NodeList
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|placement
operator|.
name|PlacementFactory
operator|.
name|getPlacementRule
import|;
end_import

begin_comment
comment|/**  * The FairScheduler rules based policy for placing an application in a queue.  * It parses the configuration and updates the {@link  * org.apache.hadoop.yarn.server.resourcemanager.placement.PlacementManager}  * with a list of {@link PlacementRule}s to execute in order.  */
end_comment

begin_class
annotation|@
name|Private
annotation|@
name|Unstable
DECL|class|QueuePlacementPolicy
specifier|final
class|class
name|QueuePlacementPolicy
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|QueuePlacementPolicy
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Simple private class to make the rule mapping simpler.
DECL|class|RuleMap
specifier|private
specifier|static
specifier|final
class|class
name|RuleMap
block|{
DECL|field|ruleClass
specifier|private
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|PlacementRule
argument_list|>
name|ruleClass
decl_stmt|;
DECL|field|terminal
specifier|private
specifier|final
name|String
name|terminal
decl_stmt|;
DECL|method|RuleMap (Class<? extends PlacementRule> clazz, String terminate)
specifier|private
name|RuleMap
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|PlacementRule
argument_list|>
name|clazz
parameter_list|,
name|String
name|terminate
parameter_list|)
block|{
name|this
operator|.
name|ruleClass
operator|=
name|clazz
expr_stmt|;
name|this
operator|.
name|terminal
operator|=
name|terminate
expr_stmt|;
block|}
block|}
comment|// The list of known rules:
comment|// key to the map is the name in the configuration.
comment|// for each name the mapping contains the class name of the implementation
comment|// and a flag (true, false or create) which describes the terminal state
comment|// see the method getTerminal() for more comments.
DECL|field|RULES
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RuleMap
argument_list|>
name|RULES
decl_stmt|;
static|static
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|RuleMap
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"user"
argument_list|,
operator|new
name|RuleMap
argument_list|(
name|UserPlacementRule
operator|.
name|class
argument_list|,
literal|"create"
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"primaryGroup"
argument_list|,
operator|new
name|RuleMap
argument_list|(
name|PrimaryGroupPlacementRule
operator|.
name|class
argument_list|,
literal|"create"
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"secondaryGroupExistingQueue"
argument_list|,
operator|new
name|RuleMap
argument_list|(
name|SecondaryGroupExistingPlacementRule
operator|.
name|class
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"specified"
argument_list|,
operator|new
name|RuleMap
argument_list|(
name|SpecifiedPlacementRule
operator|.
name|class
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"nestedUserQueue"
argument_list|,
operator|new
name|RuleMap
argument_list|(
name|UserPlacementRule
operator|.
name|class
argument_list|,
literal|"create"
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"default"
argument_list|,
operator|new
name|RuleMap
argument_list|(
name|DefaultPlacementRule
operator|.
name|class
argument_list|,
literal|"create"
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"reject"
argument_list|,
operator|new
name|RuleMap
argument_list|(
name|RejectPlacementRule
operator|.
name|class
argument_list|,
literal|"true"
argument_list|)
argument_list|)
expr_stmt|;
name|RULES
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|QueuePlacementPolicy ()
specifier|private
name|QueuePlacementPolicy
parameter_list|()
block|{   }
comment|/**    * Update the rules in the manager based on this placement policy.    * @param newRules The new list of rules to set in the manager.    * @param newTerminalState The list of terminal states for this set of rules.    * @param fs the reference to the scheduler needed in the rule on init.    * @throws AllocationConfigurationException for any errors    */
DECL|method|updateRuleSet (List<PlacementRule> newRules, List<Boolean> newTerminalState, FairScheduler fs)
specifier|private
specifier|static
name|void
name|updateRuleSet
parameter_list|(
name|List
argument_list|<
name|PlacementRule
argument_list|>
name|newRules
parameter_list|,
name|List
argument_list|<
name|Boolean
argument_list|>
name|newTerminalState
parameter_list|,
name|FairScheduler
name|fs
parameter_list|)
throws|throws
name|AllocationConfigurationException
block|{
if|if
condition|(
name|newRules
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Empty rule set defined, ignoring update"
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Placement rule order check"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|newTerminalState
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|newTerminalState
operator|.
name|get
argument_list|(
name|i
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AllocationConfigurationException
argument_list|(
literal|"Rules after rule "
operator|+
operator|(
name|i
operator|+
literal|1
operator|)
operator|+
literal|" in queue placement policy can never be reached"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|newTerminalState
operator|.
name|get
argument_list|(
name|newTerminalState
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AllocationConfigurationException
argument_list|(
literal|"Could get past last queue placement rule without assigning"
argument_list|)
throw|;
block|}
comment|// Set the scheduler in the rule to get queues etc
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initialising new rule set"
argument_list|)
expr_stmt|;
try|try
block|{
for|for
control|(
name|PlacementRule
name|rule
range|:
name|newRules
control|)
block|{
name|rule
operator|.
name|initialize
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// We should never throw as we pass in a FS object, however we still
comment|// should consider any exception here a config error.
throw|throw
operator|new
name|AllocationConfigurationException
argument_list|(
literal|"Rule initialisation failed with exception"
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
comment|// Update the placement manager with the new rule list.
comment|// We only get here when all rules are OK.
name|fs
operator|.
name|getRMContext
argument_list|()
operator|.
name|getQueuePlacementManager
argument_list|()
operator|.
name|updateRules
argument_list|(
name|newRules
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"PlacementManager active with new rule set"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Builds a QueuePlacementPolicy from a xml element.    * @param confElement the placement policy xml snippet from the    *                    {@link FairSchedulerConfiguration}    * @param fs the reference to the scheduler needed in the rule on init.    * @throws AllocationConfigurationException for any errors    */
DECL|method|fromXml (Element confElement, FairScheduler fs)
specifier|static
name|void
name|fromXml
parameter_list|(
name|Element
name|confElement
parameter_list|,
name|FairScheduler
name|fs
parameter_list|)
throws|throws
name|AllocationConfigurationException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reloading placement policy from allocation config"
argument_list|)
expr_stmt|;
if|if
condition|(
name|confElement
operator|==
literal|null
operator|||
operator|!
name|confElement
operator|.
name|hasChildNodes
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|AllocationConfigurationException
argument_list|(
literal|"Empty configuration for QueuePlacementPolicy is not allowed"
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|PlacementRule
argument_list|>
name|newRules
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Boolean
argument_list|>
name|newTerminalState
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|NodeList
name|elements
init|=
name|confElement
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|elements
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Node
name|node
init|=
name|elements
operator|.
name|item
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|instanceof
name|Element
operator|&&
name|node
operator|.
name|getNodeName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"rule"
argument_list|)
condition|)
block|{
name|String
name|name
init|=
operator|(
operator|(
name|Element
operator|)
name|node
operator|)
operator|.
name|getAttribute
argument_list|(
literal|"name"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating new rule: {}"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|PlacementRule
name|rule
init|=
name|createRule
argument_list|(
operator|(
name|Element
operator|)
name|node
argument_list|)
decl_stmt|;
comment|// The only child node that we currently know is a parent rule
name|PlacementRule
name|parentRule
init|=
literal|null
decl_stmt|;
name|String
name|parentName
init|=
literal|null
decl_stmt|;
name|Element
name|child
init|=
name|getParentRuleElement
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|!=
literal|null
condition|)
block|{
name|parentName
operator|=
name|child
operator|.
name|getAttribute
argument_list|(
literal|"name"
argument_list|)
expr_stmt|;
name|parentRule
operator|=
name|getParentRule
argument_list|(
name|child
argument_list|,
name|fs
argument_list|)
expr_stmt|;
block|}
comment|// Need to make sure that the nestedUserQueue has a parent for
comment|// backwards compatibility
if|if
condition|(
name|name
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"nestedUserQueue"
argument_list|)
operator|&&
name|parentRule
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AllocationConfigurationException
argument_list|(
literal|"Rule '"
operator|+
name|name
operator|+
literal|"' must have a parent rule set"
argument_list|)
throw|;
block|}
name|newRules
operator|.
name|add
argument_list|(
name|rule
argument_list|)
expr_stmt|;
if|if
condition|(
name|parentRule
operator|==
literal|null
condition|)
block|{
name|newTerminalState
operator|.
name|add
argument_list|(
name|getTerminal
argument_list|(
name|RULES
operator|.
name|get
argument_list|(
name|name
argument_list|)
operator|.
name|terminal
argument_list|,
name|rule
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|(
name|FSPlacementRule
operator|)
name|rule
operator|)
operator|.
name|setParentRule
argument_list|(
name|parentRule
argument_list|)
expr_stmt|;
name|newTerminalState
operator|.
name|add
argument_list|(
name|getTerminal
argument_list|(
name|RULES
operator|.
name|get
argument_list|(
name|name
argument_list|)
operator|.
name|terminal
argument_list|,
name|rule
argument_list|)
operator|&&
name|getTerminal
argument_list|(
name|RULES
operator|.
name|get
argument_list|(
name|parentName
argument_list|)
operator|.
name|terminal
argument_list|,
name|parentRule
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|updateRuleSet
argument_list|(
name|newRules
argument_list|,
name|newTerminalState
argument_list|,
name|fs
argument_list|)
expr_stmt|;
block|}
comment|/**    * Find the element that defines the parent rule.    * @param node the xml node to check for a parent rule    * @return {@link Element} that describes the parent rule or    *<code>null</code> if none is found    */
DECL|method|getParentRuleElement (Node node)
specifier|private
specifier|static
name|Element
name|getParentRuleElement
parameter_list|(
name|Node
name|node
parameter_list|)
throws|throws
name|AllocationConfigurationException
block|{
name|Element
name|parent
init|=
literal|null
decl_stmt|;
comment|// walk over the node list
if|if
condition|(
name|node
operator|.
name|hasChildNodes
argument_list|()
condition|)
block|{
name|NodeList
name|childList
init|=
name|node
operator|.
name|getChildNodes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|childList
operator|.
name|getLength
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|Node
name|child
init|=
name|childList
operator|.
name|item
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|instanceof
name|Element
operator|&&
name|child
operator|.
name|getNodeName
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"rule"
argument_list|)
condition|)
block|{
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Rule '{}' has multiple parent rules defined, only the "
operator|+
literal|"last parent rule will be used"
argument_list|,
operator|(
operator|(
name|Element
operator|)
name|node
operator|)
operator|.
name|getAttribute
argument_list|(
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|parent
operator|=
operator|(
operator|(
name|Element
operator|)
name|child
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|// sanity check the rule that is configured
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|String
name|parentName
init|=
name|parent
operator|.
name|getAttribute
argument_list|(
literal|"name"
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentName
operator|.
name|equals
argument_list|(
literal|"reject"
argument_list|)
operator|||
name|parentName
operator|.
name|equals
argument_list|(
literal|"nestedUserQueue"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AllocationConfigurationException
argument_list|(
literal|"Rule '"
operator|+
name|parentName
operator|+
literal|"' is not allowed as a parent rule for any rule"
argument_list|)
throw|;
block|}
block|}
return|return
name|parent
return|;
block|}
comment|/**    * Retrieve the configured parent rule from the xml config.    * @param parent the xml element that contains the name of the rule to add.    * @param fs the reference to the scheduler needed in the rule on init.    * @return {@link PlacementRule} to set as a parent    * @throws AllocationConfigurationException for any error    */
DECL|method|getParentRule (Element parent, FairScheduler fs)
specifier|private
specifier|static
name|PlacementRule
name|getParentRule
parameter_list|(
name|Element
name|parent
parameter_list|,
name|FairScheduler
name|fs
parameter_list|)
throws|throws
name|AllocationConfigurationException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating new parent rule: {}"
argument_list|,
name|parent
operator|.
name|getAttribute
argument_list|(
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
name|PlacementRule
name|parentRule
init|=
name|createRule
argument_list|(
name|parent
argument_list|)
decl_stmt|;
comment|// Init the rule, we do not want to add it to the list of the
comment|// placement manager
try|try
block|{
name|parentRule
operator|.
name|initialize
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// We should never throw as we pass in a FS object, however we
comment|// still should consider any exception here a config error.
throw|throw
operator|new
name|AllocationConfigurationException
argument_list|(
literal|"Parent Rule initialisation failed with exception"
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
return|return
name|parentRule
return|;
block|}
comment|/**    * Returns the terminal status of the rule based on the definition and the    * create flag set in the rule.    * @param terminal The definition of the terminal flag    * @param rule The rule to check    * @return<code>true</code> if the rule is terminal<code>false</code> in    * all other cases.    */
DECL|method|getTerminal (String terminal, PlacementRule rule)
specifier|private
specifier|static
name|Boolean
name|getTerminal
parameter_list|(
name|String
name|terminal
parameter_list|,
name|PlacementRule
name|rule
parameter_list|)
block|{
switch|switch
condition|(
name|terminal
condition|)
block|{
case|case
literal|"true"
case|:
comment|// rule is always terminal
return|return
literal|true
return|;
case|case
literal|"false"
case|:
comment|// rule is never terminal
return|return
literal|false
return|;
default|default:
comment|// rule is terminal based on the create flag
return|return
operator|(
operator|(
name|FSPlacementRule
operator|)
name|rule
operator|)
operator|.
name|getCreateFlag
argument_list|()
return|;
block|}
block|}
comment|/**    * Create a rule from a given a xml node.    * @param element the xml element to create the rule from    * @return PlacementRule    * @throws AllocationConfigurationException for any error    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|createRule (Element element)
specifier|private
specifier|static
name|PlacementRule
name|createRule
parameter_list|(
name|Element
name|element
parameter_list|)
throws|throws
name|AllocationConfigurationException
block|{
name|String
name|ruleName
init|=
name|element
operator|.
name|getAttribute
argument_list|(
literal|"name"
argument_list|)
decl_stmt|;
if|if
condition|(
literal|""
operator|.
name|equals
argument_list|(
name|ruleName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AllocationConfigurationException
argument_list|(
literal|"No name provided for a "
operator|+
literal|"rule element"
argument_list|)
throw|;
block|}
name|Class
argument_list|<
name|?
extends|extends
name|PlacementRule
argument_list|>
name|ruleClass
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|RULES
operator|.
name|containsKey
argument_list|(
name|ruleName
argument_list|)
condition|)
block|{
name|ruleClass
operator|=
name|RULES
operator|.
name|get
argument_list|(
name|ruleName
argument_list|)
operator|.
name|ruleClass
expr_stmt|;
block|}
if|if
condition|(
name|ruleClass
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|AllocationConfigurationException
argument_list|(
literal|"No rule class found for "
operator|+
name|ruleName
argument_list|)
throw|;
block|}
return|return
name|getPlacementRule
argument_list|(
name|ruleClass
argument_list|,
name|element
argument_list|)
return|;
block|}
comment|/**    * Build a simple queue placement policy from the configuration options    * {@link FairSchedulerConfiguration#ALLOW_UNDECLARED_POOLS} and    * {@link FairSchedulerConfiguration#USER_AS_DEFAULT_QUEUE}.    * @param fs the reference to the scheduler needed in the rule on init.    */
DECL|method|fromConfiguration (FairScheduler fs)
specifier|static
name|void
name|fromConfiguration
parameter_list|(
name|FairScheduler
name|fs
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating base placement policy from config"
argument_list|)
expr_stmt|;
name|Configuration
name|conf
init|=
name|fs
operator|.
name|getConfig
argument_list|()
decl_stmt|;
name|boolean
name|create
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|FairSchedulerConfiguration
operator|.
name|ALLOW_UNDECLARED_POOLS
argument_list|,
name|FairSchedulerConfiguration
operator|.
name|DEFAULT_ALLOW_UNDECLARED_POOLS
argument_list|)
decl_stmt|;
name|boolean
name|userAsDefaultQueue
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|FairSchedulerConfiguration
operator|.
name|USER_AS_DEFAULT_QUEUE
argument_list|,
name|FairSchedulerConfiguration
operator|.
name|DEFAULT_USER_AS_DEFAULT_QUEUE
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|PlacementRule
argument_list|>
name|newRules
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Boolean
argument_list|>
name|newTerminalState
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|PlacementRule
argument_list|>
name|clazz
init|=
name|RULES
operator|.
name|get
argument_list|(
literal|"specified"
argument_list|)
operator|.
name|ruleClass
decl_stmt|;
name|newRules
operator|.
name|add
argument_list|(
name|getPlacementRule
argument_list|(
name|clazz
argument_list|,
name|create
argument_list|)
argument_list|)
expr_stmt|;
name|newTerminalState
operator|.
name|add
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|userAsDefaultQueue
condition|)
block|{
name|clazz
operator|=
name|RULES
operator|.
name|get
argument_list|(
literal|"user"
argument_list|)
operator|.
name|ruleClass
expr_stmt|;
name|newRules
operator|.
name|add
argument_list|(
name|getPlacementRule
argument_list|(
name|clazz
argument_list|,
name|create
argument_list|)
argument_list|)
expr_stmt|;
name|newTerminalState
operator|.
name|add
argument_list|(
name|create
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|userAsDefaultQueue
operator|||
operator|!
name|create
condition|)
block|{
name|clazz
operator|=
name|RULES
operator|.
name|get
argument_list|(
literal|"default"
argument_list|)
operator|.
name|ruleClass
expr_stmt|;
name|newRules
operator|.
name|add
argument_list|(
name|getPlacementRule
argument_list|(
name|clazz
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|newTerminalState
operator|.
name|add
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|updateRuleSet
argument_list|(
name|newRules
argument_list|,
name|newTerminalState
argument_list|,
name|fs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AllocationConfigurationException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Should never hit exception when loading"
operator|+
literal|"placement policy from conf"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

