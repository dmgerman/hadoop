begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/** * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|Private
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|AccessControlList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Priority
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ReservationACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnRuntimeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|nodelabels
operator|.
name|CommonNodeLabelsManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|security
operator|.
name|AccessType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|nodelabels
operator|.
name|RMNodeLabelsManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|placement
operator|.
name|UserGroupMappingPlacementRule
operator|.
name|QueueMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|reservation
operator|.
name|ReservationSchedulerConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|SchedulerUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|AppPriorityACLConfigurationParser
operator|.
name|AppPriorityACLKeyType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|policy
operator|.
name|PriorityUtilizationQueueOrderingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|policy
operator|.
name|QueueOrderingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|policy
operator|.
name|FairOrderingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|policy
operator|.
name|FifoOrderingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|policy
operator|.
name|OrderingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|policy
operator|.
name|SchedulableEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|UnitsConversionUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|DefaultResourceCalculator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|ResourceCalculator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|Resources
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_class
DECL|class|CapacitySchedulerConfiguration
specifier|public
class|class
name|CapacitySchedulerConfiguration
extends|extends
name|ReservationSchedulerConfiguration
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|CS_CONFIGURATION_FILE
specifier|private
specifier|static
specifier|final
name|String
name|CS_CONFIGURATION_FILE
init|=
literal|"capacity-scheduler.xml"
decl_stmt|;
annotation|@
name|Private
DECL|field|PREFIX
specifier|public
specifier|static
specifier|final
name|String
name|PREFIX
init|=
literal|"yarn.scheduler.capacity."
decl_stmt|;
annotation|@
name|Private
DECL|field|DOT
specifier|public
specifier|static
specifier|final
name|String
name|DOT
init|=
literal|"."
decl_stmt|;
annotation|@
name|Private
DECL|field|MAXIMUM_APPLICATIONS_SUFFIX
specifier|public
specifier|static
specifier|final
name|String
name|MAXIMUM_APPLICATIONS_SUFFIX
init|=
literal|"maximum-applications"
decl_stmt|;
annotation|@
name|Private
DECL|field|MAXIMUM_SYSTEM_APPLICATIONS
specifier|public
specifier|static
specifier|final
name|String
name|MAXIMUM_SYSTEM_APPLICATIONS
init|=
name|PREFIX
operator|+
name|MAXIMUM_APPLICATIONS_SUFFIX
decl_stmt|;
annotation|@
name|Private
DECL|field|MAXIMUM_AM_RESOURCE_SUFFIX
specifier|public
specifier|static
specifier|final
name|String
name|MAXIMUM_AM_RESOURCE_SUFFIX
init|=
literal|"maximum-am-resource-percent"
decl_stmt|;
annotation|@
name|Private
DECL|field|MAXIMUM_APPLICATION_MASTERS_RESOURCE_PERCENT
specifier|public
specifier|static
specifier|final
name|String
name|MAXIMUM_APPLICATION_MASTERS_RESOURCE_PERCENT
init|=
name|PREFIX
operator|+
name|MAXIMUM_AM_RESOURCE_SUFFIX
decl_stmt|;
annotation|@
name|Private
DECL|field|QUEUES
specifier|public
specifier|static
specifier|final
name|String
name|QUEUES
init|=
literal|"queues"
decl_stmt|;
annotation|@
name|Private
DECL|field|CAPACITY
specifier|public
specifier|static
specifier|final
name|String
name|CAPACITY
init|=
literal|"capacity"
decl_stmt|;
annotation|@
name|Private
DECL|field|MAXIMUM_CAPACITY
specifier|public
specifier|static
specifier|final
name|String
name|MAXIMUM_CAPACITY
init|=
literal|"maximum-capacity"
decl_stmt|;
annotation|@
name|Private
DECL|field|USER_LIMIT
specifier|public
specifier|static
specifier|final
name|String
name|USER_LIMIT
init|=
literal|"minimum-user-limit-percent"
decl_stmt|;
annotation|@
name|Private
DECL|field|USER_LIMIT_FACTOR
specifier|public
specifier|static
specifier|final
name|String
name|USER_LIMIT_FACTOR
init|=
literal|"user-limit-factor"
decl_stmt|;
annotation|@
name|Private
DECL|field|USER_WEIGHT
specifier|public
specifier|static
specifier|final
name|String
name|USER_WEIGHT
init|=
literal|"weight"
decl_stmt|;
annotation|@
name|Private
DECL|field|USER_SETTINGS
specifier|public
specifier|static
specifier|final
name|String
name|USER_SETTINGS
init|=
literal|"user-settings"
decl_stmt|;
annotation|@
name|Private
DECL|field|DEFAULT_USER_WEIGHT
specifier|public
specifier|static
specifier|final
name|float
name|DEFAULT_USER_WEIGHT
init|=
literal|1.0f
decl_stmt|;
annotation|@
name|Private
DECL|field|STATE
specifier|public
specifier|static
specifier|final
name|String
name|STATE
init|=
literal|"state"
decl_stmt|;
annotation|@
name|Private
DECL|field|ACCESSIBLE_NODE_LABELS
specifier|public
specifier|static
specifier|final
name|String
name|ACCESSIBLE_NODE_LABELS
init|=
literal|"accessible-node-labels"
decl_stmt|;
annotation|@
name|Private
DECL|field|DEFAULT_NODE_LABEL_EXPRESSION
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_NODE_LABEL_EXPRESSION
init|=
literal|"default-node-label-expression"
decl_stmt|;
DECL|field|RESERVE_CONT_LOOK_ALL_NODES
specifier|public
specifier|static
specifier|final
name|String
name|RESERVE_CONT_LOOK_ALL_NODES
init|=
name|PREFIX
operator|+
literal|"reservations-continue-look-all-nodes"
decl_stmt|;
annotation|@
name|Private
DECL|field|DEFAULT_RESERVE_CONT_LOOK_ALL_NODES
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_RESERVE_CONT_LOOK_ALL_NODES
init|=
literal|true
decl_stmt|;
annotation|@
name|Private
DECL|field|MAXIMUM_ALLOCATION_MB
specifier|public
specifier|static
specifier|final
name|String
name|MAXIMUM_ALLOCATION_MB
init|=
literal|"maximum-allocation-mb"
decl_stmt|;
annotation|@
name|Private
DECL|field|MAXIMUM_ALLOCATION_VCORES
specifier|public
specifier|static
specifier|final
name|String
name|MAXIMUM_ALLOCATION_VCORES
init|=
literal|"maximum-allocation-vcores"
decl_stmt|;
comment|/**    * Ordering policy of queues    */
DECL|field|ORDERING_POLICY
specifier|public
specifier|static
specifier|final
name|String
name|ORDERING_POLICY
init|=
literal|"ordering-policy"
decl_stmt|;
comment|/*    * Ordering policy inside a leaf queue to sort apps    */
DECL|field|FIFO_APP_ORDERING_POLICY
specifier|public
specifier|static
specifier|final
name|String
name|FIFO_APP_ORDERING_POLICY
init|=
literal|"fifo"
decl_stmt|;
DECL|field|FAIR_APP_ORDERING_POLICY
specifier|public
specifier|static
specifier|final
name|String
name|FAIR_APP_ORDERING_POLICY
init|=
literal|"fair"
decl_stmt|;
DECL|field|DEFAULT_APP_ORDERING_POLICY
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_APP_ORDERING_POLICY
init|=
name|FIFO_APP_ORDERING_POLICY
decl_stmt|;
annotation|@
name|Private
DECL|field|DEFAULT_MAXIMUM_SYSTEM_APPLICATIIONS
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MAXIMUM_SYSTEM_APPLICATIIONS
init|=
literal|10000
decl_stmt|;
annotation|@
name|Private
specifier|public
specifier|static
specifier|final
name|float
DECL|field|DEFAULT_MAXIMUM_APPLICATIONMASTERS_RESOURCE_PERCENT
name|DEFAULT_MAXIMUM_APPLICATIONMASTERS_RESOURCE_PERCENT
init|=
literal|0.1f
decl_stmt|;
annotation|@
name|Private
DECL|field|UNDEFINED
specifier|public
specifier|static
specifier|final
name|float
name|UNDEFINED
init|=
operator|-
literal|1
decl_stmt|;
annotation|@
name|Private
DECL|field|MINIMUM_CAPACITY_VALUE
specifier|public
specifier|static
specifier|final
name|float
name|MINIMUM_CAPACITY_VALUE
init|=
literal|0
decl_stmt|;
annotation|@
name|Private
DECL|field|MAXIMUM_CAPACITY_VALUE
specifier|public
specifier|static
specifier|final
name|float
name|MAXIMUM_CAPACITY_VALUE
init|=
literal|100
decl_stmt|;
annotation|@
name|Private
DECL|field|DEFAULT_MAXIMUM_CAPACITY_VALUE
specifier|public
specifier|static
specifier|final
name|float
name|DEFAULT_MAXIMUM_CAPACITY_VALUE
init|=
operator|-
literal|1.0f
decl_stmt|;
annotation|@
name|Private
DECL|field|DEFAULT_USER_LIMIT
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_USER_LIMIT
init|=
literal|100
decl_stmt|;
annotation|@
name|Private
DECL|field|DEFAULT_USER_LIMIT_FACTOR
specifier|public
specifier|static
specifier|final
name|float
name|DEFAULT_USER_LIMIT_FACTOR
init|=
literal|1.0f
decl_stmt|;
annotation|@
name|Private
DECL|field|ALL_ACL
specifier|public
specifier|static
specifier|final
name|String
name|ALL_ACL
init|=
literal|"*"
decl_stmt|;
annotation|@
name|Private
DECL|field|NONE_ACL
specifier|public
specifier|static
specifier|final
name|String
name|NONE_ACL
init|=
literal|" "
decl_stmt|;
DECL|field|ENABLE_USER_METRICS
annotation|@
name|Private
specifier|public
specifier|static
specifier|final
name|String
name|ENABLE_USER_METRICS
init|=
name|PREFIX
operator|+
literal|"user-metrics.enable"
decl_stmt|;
DECL|field|DEFAULT_ENABLE_USER_METRICS
annotation|@
name|Private
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_ENABLE_USER_METRICS
init|=
literal|false
decl_stmt|;
comment|/** ResourceComparator for scheduling. */
DECL|field|RESOURCE_CALCULATOR_CLASS
annotation|@
name|Private
specifier|public
specifier|static
specifier|final
name|String
name|RESOURCE_CALCULATOR_CLASS
init|=
name|PREFIX
operator|+
literal|"resource-calculator"
decl_stmt|;
annotation|@
name|Private
specifier|public
specifier|static
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|ResourceCalculator
argument_list|>
DECL|field|DEFAULT_RESOURCE_CALCULATOR_CLASS
name|DEFAULT_RESOURCE_CALCULATOR_CLASS
init|=
name|DefaultResourceCalculator
operator|.
name|class
decl_stmt|;
annotation|@
name|Private
DECL|field|ROOT
specifier|public
specifier|static
specifier|final
name|String
name|ROOT
init|=
literal|"root"
decl_stmt|;
annotation|@
name|Private
DECL|field|NODE_LOCALITY_DELAY
specifier|public
specifier|static
specifier|final
name|String
name|NODE_LOCALITY_DELAY
init|=
name|PREFIX
operator|+
literal|"node-locality-delay"
decl_stmt|;
annotation|@
name|Private
DECL|field|DEFAULT_NODE_LOCALITY_DELAY
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_NODE_LOCALITY_DELAY
init|=
literal|40
decl_stmt|;
annotation|@
name|Private
DECL|field|RACK_LOCALITY_ADDITIONAL_DELAY
specifier|public
specifier|static
specifier|final
name|String
name|RACK_LOCALITY_ADDITIONAL_DELAY
init|=
name|PREFIX
operator|+
literal|"rack-locality-additional-delay"
decl_stmt|;
annotation|@
name|Private
DECL|field|DEFAULT_RACK_LOCALITY_ADDITIONAL_DELAY
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_RACK_LOCALITY_ADDITIONAL_DELAY
init|=
operator|-
literal|1
decl_stmt|;
annotation|@
name|Private
DECL|field|RACK_LOCALITY_FULL_RESET
specifier|public
specifier|static
specifier|final
name|String
name|RACK_LOCALITY_FULL_RESET
init|=
name|PREFIX
operator|+
literal|"rack-locality-full-reset"
decl_stmt|;
annotation|@
name|Private
DECL|field|DEFAULT_OFFSWITCH_PER_HEARTBEAT_LIMIT
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_OFFSWITCH_PER_HEARTBEAT_LIMIT
init|=
literal|1
decl_stmt|;
annotation|@
name|Private
DECL|field|OFFSWITCH_PER_HEARTBEAT_LIMIT
specifier|public
specifier|static
specifier|final
name|String
name|OFFSWITCH_PER_HEARTBEAT_LIMIT
init|=
name|PREFIX
operator|+
literal|"per-node-heartbeat.maximum-offswitch-assignments"
decl_stmt|;
annotation|@
name|Private
DECL|field|DEFAULT_RACK_LOCALITY_FULL_RESET
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_RACK_LOCALITY_FULL_RESET
init|=
literal|true
decl_stmt|;
annotation|@
name|Private
DECL|field|SCHEDULE_ASYNCHRONOUSLY_PREFIX
specifier|public
specifier|static
specifier|final
name|String
name|SCHEDULE_ASYNCHRONOUSLY_PREFIX
init|=
name|PREFIX
operator|+
literal|"schedule-asynchronously"
decl_stmt|;
annotation|@
name|Private
DECL|field|SCHEDULE_ASYNCHRONOUSLY_ENABLE
specifier|public
specifier|static
specifier|final
name|String
name|SCHEDULE_ASYNCHRONOUSLY_ENABLE
init|=
name|SCHEDULE_ASYNCHRONOUSLY_PREFIX
operator|+
literal|".enable"
decl_stmt|;
annotation|@
name|Private
DECL|field|SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD
specifier|public
specifier|static
specifier|final
name|String
name|SCHEDULE_ASYNCHRONOUSLY_MAXIMUM_THREAD
init|=
name|SCHEDULE_ASYNCHRONOUSLY_PREFIX
operator|+
literal|".maximum-threads"
decl_stmt|;
annotation|@
name|Private
DECL|field|DEFAULT_SCHEDULE_ASYNCHRONOUSLY_ENABLE
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_SCHEDULE_ASYNCHRONOUSLY_ENABLE
init|=
literal|false
decl_stmt|;
annotation|@
name|Private
DECL|field|QUEUE_MAPPING
specifier|public
specifier|static
specifier|final
name|String
name|QUEUE_MAPPING
init|=
name|PREFIX
operator|+
literal|"queue-mappings"
decl_stmt|;
annotation|@
name|Private
DECL|field|ENABLE_QUEUE_MAPPING_OVERRIDE
specifier|public
specifier|static
specifier|final
name|String
name|ENABLE_QUEUE_MAPPING_OVERRIDE
init|=
name|QUEUE_MAPPING
operator|+
literal|"-override.enable"
decl_stmt|;
annotation|@
name|Private
DECL|field|DEFAULT_ENABLE_QUEUE_MAPPING_OVERRIDE
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_ENABLE_QUEUE_MAPPING_OVERRIDE
init|=
literal|false
decl_stmt|;
annotation|@
name|Private
DECL|field|QUEUE_PREEMPTION_DISABLED
specifier|public
specifier|static
specifier|final
name|String
name|QUEUE_PREEMPTION_DISABLED
init|=
literal|"disable_preemption"
decl_stmt|;
annotation|@
name|Private
DECL|field|DEFAULT_APPLICATION_PRIORITY
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_APPLICATION_PRIORITY
init|=
literal|"default-application-priority"
decl_stmt|;
annotation|@
name|Private
DECL|field|DEFAULT_CONFIGURATION_APPLICATION_PRIORITY
specifier|public
specifier|static
specifier|final
name|Integer
name|DEFAULT_CONFIGURATION_APPLICATION_PRIORITY
init|=
literal|0
decl_stmt|;
annotation|@
name|Private
DECL|field|AVERAGE_CAPACITY
specifier|public
specifier|static
specifier|final
name|String
name|AVERAGE_CAPACITY
init|=
literal|"average-capacity"
decl_stmt|;
annotation|@
name|Private
DECL|field|IS_RESERVABLE
specifier|public
specifier|static
specifier|final
name|String
name|IS_RESERVABLE
init|=
literal|"reservable"
decl_stmt|;
annotation|@
name|Private
DECL|field|RESERVATION_WINDOW
specifier|public
specifier|static
specifier|final
name|String
name|RESERVATION_WINDOW
init|=
literal|"reservation-window"
decl_stmt|;
annotation|@
name|Private
DECL|field|INSTANTANEOUS_MAX_CAPACITY
specifier|public
specifier|static
specifier|final
name|String
name|INSTANTANEOUS_MAX_CAPACITY
init|=
literal|"instantaneous-max-capacity"
decl_stmt|;
annotation|@
name|Private
DECL|field|RESERVATION_ADMISSION_POLICY
specifier|public
specifier|static
specifier|final
name|String
name|RESERVATION_ADMISSION_POLICY
init|=
literal|"reservation-policy"
decl_stmt|;
annotation|@
name|Private
DECL|field|RESERVATION_AGENT_NAME
specifier|public
specifier|static
specifier|final
name|String
name|RESERVATION_AGENT_NAME
init|=
literal|"reservation-agent"
decl_stmt|;
annotation|@
name|Private
DECL|field|RESERVATION_SHOW_RESERVATION_AS_QUEUE
specifier|public
specifier|static
specifier|final
name|String
name|RESERVATION_SHOW_RESERVATION_AS_QUEUE
init|=
literal|"show-reservations-as-queues"
decl_stmt|;
annotation|@
name|Private
DECL|field|RESERVATION_PLANNER_NAME
specifier|public
specifier|static
specifier|final
name|String
name|RESERVATION_PLANNER_NAME
init|=
literal|"reservation-planner"
decl_stmt|;
annotation|@
name|Private
DECL|field|RESERVATION_MOVE_ON_EXPIRY
specifier|public
specifier|static
specifier|final
name|String
name|RESERVATION_MOVE_ON_EXPIRY
init|=
literal|"reservation-move-on-expiry"
decl_stmt|;
annotation|@
name|Private
DECL|field|RESERVATION_ENFORCEMENT_WINDOW
specifier|public
specifier|static
specifier|final
name|String
name|RESERVATION_ENFORCEMENT_WINDOW
init|=
literal|"reservation-enforcement-window"
decl_stmt|;
annotation|@
name|Private
DECL|field|LAZY_PREEMPTION_ENABLED
specifier|public
specifier|static
specifier|final
name|String
name|LAZY_PREEMPTION_ENABLED
init|=
name|PREFIX
operator|+
literal|"lazy-preemption-enabled"
decl_stmt|;
annotation|@
name|Private
DECL|field|DEFAULT_LAZY_PREEMPTION_ENABLED
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_LAZY_PREEMPTION_ENABLED
init|=
literal|false
decl_stmt|;
annotation|@
name|Private
DECL|field|ASSIGN_MULTIPLE_ENABLED
specifier|public
specifier|static
specifier|final
name|String
name|ASSIGN_MULTIPLE_ENABLED
init|=
name|PREFIX
operator|+
literal|"per-node-heartbeat.multiple-assignments-enabled"
decl_stmt|;
annotation|@
name|Private
DECL|field|DEFAULT_ASSIGN_MULTIPLE_ENABLED
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_ASSIGN_MULTIPLE_ENABLED
init|=
literal|true
decl_stmt|;
comment|/** Maximum number of containers to assign on each check-in. */
annotation|@
name|Private
DECL|field|MAX_ASSIGN_PER_HEARTBEAT
specifier|public
specifier|static
specifier|final
name|String
name|MAX_ASSIGN_PER_HEARTBEAT
init|=
name|PREFIX
operator|+
literal|"per-node-heartbeat.maximum-container-assignments"
decl_stmt|;
annotation|@
name|Private
DECL|field|DEFAULT_MAX_ASSIGN_PER_HEARTBEAT
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_MAX_ASSIGN_PER_HEARTBEAT
init|=
operator|-
literal|1
decl_stmt|;
comment|/** Configuring absolute min/max resources in a queue **/
annotation|@
name|Private
DECL|field|MINIMUM_RESOURCE
specifier|public
specifier|static
specifier|final
name|String
name|MINIMUM_RESOURCE
init|=
literal|"min-resource"
decl_stmt|;
annotation|@
name|Private
DECL|field|MAXIMUM_RESOURCE
specifier|public
specifier|static
specifier|final
name|String
name|MAXIMUM_RESOURCE
init|=
literal|"max-resource"
decl_stmt|;
DECL|field|DEFAULT_RESOURCE_TYPES
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_RESOURCE_TYPES
init|=
literal|"memory,vcores"
decl_stmt|;
DECL|field|PATTERN_FOR_ABSOLUTE_RESOURCE
specifier|public
specifier|static
specifier|final
name|String
name|PATTERN_FOR_ABSOLUTE_RESOURCE
init|=
literal|"^\\[[\\w\\.,\\-_=\\ /]+\\]$"
decl_stmt|;
DECL|field|RESOURCE_PATTERN
specifier|private
specifier|static
specifier|final
name|Pattern
name|RESOURCE_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|PATTERN_FOR_ABSOLUTE_RESOURCE
argument_list|)
decl_stmt|;
DECL|enum|AbsoluteResourceType
specifier|public
enum|enum
name|AbsoluteResourceType
block|{
DECL|enumConstant|MEMORY
DECL|enumConstant|VCORES
name|MEMORY
block|,
name|VCORES
block|;   }
DECL|field|priorityACLConfig
name|AppPriorityACLConfigurationParser
name|priorityACLConfig
init|=
operator|new
name|AppPriorityACLConfigurationParser
argument_list|()
decl_stmt|;
DECL|method|CapacitySchedulerConfiguration ()
specifier|public
name|CapacitySchedulerConfiguration
parameter_list|()
block|{
name|this
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|CapacitySchedulerConfiguration (Configuration configuration)
specifier|public
name|CapacitySchedulerConfiguration
parameter_list|(
name|Configuration
name|configuration
parameter_list|)
block|{
name|this
argument_list|(
name|configuration
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|CapacitySchedulerConfiguration (Configuration configuration, boolean useLocalConfigurationProvider)
specifier|public
name|CapacitySchedulerConfiguration
parameter_list|(
name|Configuration
name|configuration
parameter_list|,
name|boolean
name|useLocalConfigurationProvider
parameter_list|)
block|{
name|super
argument_list|(
name|configuration
argument_list|)
expr_stmt|;
if|if
condition|(
name|useLocalConfigurationProvider
condition|)
block|{
name|addResource
argument_list|(
name|CS_CONFIGURATION_FILE
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getQueuePrefix (String queue)
specifier|static
name|String
name|getQueuePrefix
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|String
name|queueName
init|=
name|PREFIX
operator|+
name|queue
operator|+
name|DOT
decl_stmt|;
return|return
name|queueName
return|;
block|}
DECL|method|getQueueOrderingPolicyPrefix (String queue)
specifier|static
name|String
name|getQueueOrderingPolicyPrefix
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|String
name|queueName
init|=
name|PREFIX
operator|+
name|queue
operator|+
name|DOT
operator|+
name|ORDERING_POLICY
operator|+
name|DOT
decl_stmt|;
return|return
name|queueName
return|;
block|}
DECL|method|getNodeLabelPrefix (String queue, String label)
specifier|private
name|String
name|getNodeLabelPrefix
parameter_list|(
name|String
name|queue
parameter_list|,
name|String
name|label
parameter_list|)
block|{
if|if
condition|(
name|label
operator|.
name|equals
argument_list|(
name|CommonNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|)
condition|)
block|{
return|return
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
return|;
block|}
return|return
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|ACCESSIBLE_NODE_LABELS
operator|+
name|DOT
operator|+
name|label
operator|+
name|DOT
return|;
block|}
DECL|method|getMaximumSystemApplications ()
specifier|public
name|int
name|getMaximumSystemApplications
parameter_list|()
block|{
name|int
name|maxApplications
init|=
name|getInt
argument_list|(
name|MAXIMUM_SYSTEM_APPLICATIONS
argument_list|,
name|DEFAULT_MAXIMUM_SYSTEM_APPLICATIIONS
argument_list|)
decl_stmt|;
return|return
name|maxApplications
return|;
block|}
DECL|method|getMaximumApplicationMasterResourcePercent ()
specifier|public
name|float
name|getMaximumApplicationMasterResourcePercent
parameter_list|()
block|{
return|return
name|getFloat
argument_list|(
name|MAXIMUM_APPLICATION_MASTERS_RESOURCE_PERCENT
argument_list|,
name|DEFAULT_MAXIMUM_APPLICATIONMASTERS_RESOURCE_PERCENT
argument_list|)
return|;
block|}
comment|/**    * Get the maximum applications per queue setting.    * @param queue name of the queue    * @return setting specified or -1 if not set    */
DECL|method|getMaximumApplicationsPerQueue (String queue)
specifier|public
name|int
name|getMaximumApplicationsPerQueue
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|int
name|maxApplicationsPerQueue
init|=
name|getInt
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|MAXIMUM_APPLICATIONS_SUFFIX
argument_list|,
operator|(
name|int
operator|)
name|UNDEFINED
argument_list|)
decl_stmt|;
return|return
name|maxApplicationsPerQueue
return|;
block|}
comment|/**    * Get the maximum am resource percent per queue setting.    * @param queue name of the queue    * @return per queue setting or defaults to the global am-resource-percent     *         setting if per queue setting not present    */
DECL|method|getMaximumApplicationMasterResourcePerQueuePercent (String queue)
specifier|public
name|float
name|getMaximumApplicationMasterResourcePerQueuePercent
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
return|return
name|getFloat
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|MAXIMUM_AM_RESOURCE_SUFFIX
argument_list|,
name|getMaximumApplicationMasterResourcePercent
argument_list|()
argument_list|)
return|;
block|}
DECL|method|setMaximumApplicationMasterResourcePerQueuePercent (String queue, float percent)
specifier|public
name|void
name|setMaximumApplicationMasterResourcePerQueuePercent
parameter_list|(
name|String
name|queue
parameter_list|,
name|float
name|percent
parameter_list|)
block|{
name|setFloat
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|MAXIMUM_AM_RESOURCE_SUFFIX
argument_list|,
name|percent
argument_list|)
expr_stmt|;
block|}
DECL|method|getNonLabeledQueueCapacity (String queue)
specifier|public
name|float
name|getNonLabeledQueueCapacity
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|String
name|configuredCapacity
init|=
name|get
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|CAPACITY
argument_list|)
decl_stmt|;
name|boolean
name|matcher
init|=
operator|(
name|configuredCapacity
operator|!=
literal|null
operator|)
operator|&&
name|RESOURCE_PATTERN
operator|.
name|matcher
argument_list|(
name|configuredCapacity
argument_list|)
operator|.
name|find
argument_list|()
decl_stmt|;
if|if
condition|(
name|matcher
condition|)
block|{
comment|// Return capacity in percentage as 0 for non-root queues and 100 for
comment|// root.From AbstractCSQueue, absolute resource will be parsed and
comment|// updated. Once nodes are added/removed in cluster, capacity in
comment|// percentage will also be re-calculated.
return|return
name|queue
operator|.
name|equals
argument_list|(
literal|"root"
argument_list|)
condition|?
literal|100.0f
else|:
literal|0f
return|;
block|}
name|float
name|capacity
init|=
name|queue
operator|.
name|equals
argument_list|(
literal|"root"
argument_list|)
condition|?
literal|100.0f
else|:
operator|(
name|configuredCapacity
operator|==
literal|null
operator|)
condition|?
literal|0f
else|:
name|Float
operator|.
name|parseFloat
argument_list|(
name|configuredCapacity
argument_list|)
decl_stmt|;
if|if
condition|(
name|capacity
argument_list|<
name|MINIMUM_CAPACITY_VALUE
operator|||
name|capacity
argument_list|>
name|MAXIMUM_CAPACITY_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal "
operator|+
literal|"capacity of "
operator|+
name|capacity
operator|+
literal|" for queue "
operator|+
name|queue
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"CSConf - getCapacity: queuePrefix="
operator|+
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
literal|", capacity="
operator|+
name|capacity
argument_list|)
expr_stmt|;
return|return
name|capacity
return|;
block|}
DECL|method|setCapacity (String queue, float capacity)
specifier|public
name|void
name|setCapacity
parameter_list|(
name|String
name|queue
parameter_list|,
name|float
name|capacity
parameter_list|)
block|{
if|if
condition|(
name|queue
operator|.
name|equals
argument_list|(
literal|"root"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot set capacity, root queue has a fixed capacity of 100.0f"
argument_list|)
throw|;
block|}
name|setFloat
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|CAPACITY
argument_list|,
name|capacity
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"CSConf - setCapacity: queuePrefix="
operator|+
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
literal|", capacity="
operator|+
name|capacity
argument_list|)
expr_stmt|;
block|}
DECL|method|getNonLabeledQueueMaximumCapacity (String queue)
specifier|public
name|float
name|getNonLabeledQueueMaximumCapacity
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|String
name|configuredCapacity
init|=
name|get
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|MAXIMUM_CAPACITY
argument_list|)
decl_stmt|;
name|boolean
name|matcher
init|=
operator|(
name|configuredCapacity
operator|!=
literal|null
operator|)
operator|&&
name|RESOURCE_PATTERN
operator|.
name|matcher
argument_list|(
name|configuredCapacity
argument_list|)
operator|.
name|find
argument_list|()
decl_stmt|;
if|if
condition|(
name|matcher
condition|)
block|{
comment|// Return capacity in percentage as 0 for non-root queues and 100 for
comment|// root.From AbstractCSQueue, absolute resource will be parsed and
comment|// updated. Once nodes are added/removed in cluster, capacity in
comment|// percentage will also be re-calculated.
return|return
literal|100.0f
return|;
block|}
name|float
name|maxCapacity
init|=
operator|(
name|configuredCapacity
operator|==
literal|null
operator|)
condition|?
name|MAXIMUM_CAPACITY_VALUE
else|:
name|Float
operator|.
name|parseFloat
argument_list|(
name|configuredCapacity
argument_list|)
decl_stmt|;
name|maxCapacity
operator|=
operator|(
name|maxCapacity
operator|==
name|DEFAULT_MAXIMUM_CAPACITY_VALUE
operator|)
condition|?
name|MAXIMUM_CAPACITY_VALUE
else|:
name|maxCapacity
expr_stmt|;
return|return
name|maxCapacity
return|;
block|}
DECL|method|setMaximumCapacity (String queue, float maxCapacity)
specifier|public
name|void
name|setMaximumCapacity
parameter_list|(
name|String
name|queue
parameter_list|,
name|float
name|maxCapacity
parameter_list|)
block|{
if|if
condition|(
name|maxCapacity
operator|>
name|MAXIMUM_CAPACITY_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal "
operator|+
literal|"maximum-capacity of "
operator|+
name|maxCapacity
operator|+
literal|" for queue "
operator|+
name|queue
argument_list|)
throw|;
block|}
name|setFloat
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|MAXIMUM_CAPACITY
argument_list|,
name|maxCapacity
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"CSConf - setMaxCapacity: queuePrefix="
operator|+
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
literal|", maxCapacity="
operator|+
name|maxCapacity
argument_list|)
expr_stmt|;
block|}
DECL|method|setCapacityByLabel (String queue, String label, float capacity)
specifier|public
name|void
name|setCapacityByLabel
parameter_list|(
name|String
name|queue
parameter_list|,
name|String
name|label
parameter_list|,
name|float
name|capacity
parameter_list|)
block|{
name|setFloat
argument_list|(
name|getNodeLabelPrefix
argument_list|(
name|queue
argument_list|,
name|label
argument_list|)
operator|+
name|CAPACITY
argument_list|,
name|capacity
argument_list|)
expr_stmt|;
block|}
DECL|method|setMaximumCapacityByLabel (String queue, String label, float capacity)
specifier|public
name|void
name|setMaximumCapacityByLabel
parameter_list|(
name|String
name|queue
parameter_list|,
name|String
name|label
parameter_list|,
name|float
name|capacity
parameter_list|)
block|{
name|setFloat
argument_list|(
name|getNodeLabelPrefix
argument_list|(
name|queue
argument_list|,
name|label
argument_list|)
operator|+
name|MAXIMUM_CAPACITY
argument_list|,
name|capacity
argument_list|)
expr_stmt|;
block|}
DECL|method|getUserLimit (String queue)
specifier|public
name|int
name|getUserLimit
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|int
name|userLimit
init|=
name|getInt
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|USER_LIMIT
argument_list|,
name|DEFAULT_USER_LIMIT
argument_list|)
decl_stmt|;
return|return
name|userLimit
return|;
block|}
comment|// TODO (wangda): We need to better distinguish app ordering policy and queue
comment|// ordering policy's classname / configuration options, etc. And dedup code
comment|// if possible.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getAppOrderingPolicy ( String queue)
specifier|public
parameter_list|<
name|S
extends|extends
name|SchedulableEntity
parameter_list|>
name|OrderingPolicy
argument_list|<
name|S
argument_list|>
name|getAppOrderingPolicy
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|String
name|policyType
init|=
name|get
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|ORDERING_POLICY
argument_list|,
name|DEFAULT_APP_ORDERING_POLICY
argument_list|)
decl_stmt|;
name|OrderingPolicy
argument_list|<
name|S
argument_list|>
name|orderingPolicy
decl_stmt|;
if|if
condition|(
name|policyType
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
name|FIFO_APP_ORDERING_POLICY
argument_list|)
condition|)
block|{
name|policyType
operator|=
name|FifoOrderingPolicy
operator|.
name|class
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|policyType
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
name|FAIR_APP_ORDERING_POLICY
argument_list|)
condition|)
block|{
name|policyType
operator|=
name|FairOrderingPolicy
operator|.
name|class
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|orderingPolicy
operator|=
operator|(
name|OrderingPolicy
argument_list|<
name|S
argument_list|>
operator|)
name|Class
operator|.
name|forName
argument_list|(
name|policyType
argument_list|)
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|String
name|message
init|=
literal|"Unable to construct ordering policy for: "
operator|+
name|policyType
operator|+
literal|", "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|message
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|config
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|confPrefix
init|=
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|ORDERING_POLICY
operator|+
literal|"."
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|kv
range|:
name|this
control|)
block|{
if|if
condition|(
name|kv
operator|.
name|getKey
argument_list|()
operator|.
name|startsWith
argument_list|(
name|confPrefix
argument_list|)
condition|)
block|{
name|config
operator|.
name|put
argument_list|(
name|kv
operator|.
name|getKey
argument_list|()
operator|.
name|substring
argument_list|(
name|confPrefix
operator|.
name|length
argument_list|()
argument_list|)
argument_list|,
name|kv
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|orderingPolicy
operator|.
name|configure
argument_list|(
name|config
argument_list|)
expr_stmt|;
return|return
name|orderingPolicy
return|;
block|}
DECL|method|setUserLimit (String queue, int userLimit)
specifier|public
name|void
name|setUserLimit
parameter_list|(
name|String
name|queue
parameter_list|,
name|int
name|userLimit
parameter_list|)
block|{
name|setInt
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|USER_LIMIT
argument_list|,
name|userLimit
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"here setUserLimit: queuePrefix="
operator|+
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
literal|", userLimit="
operator|+
name|getUserLimit
argument_list|(
name|queue
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|getUserLimitFactor (String queue)
specifier|public
name|float
name|getUserLimitFactor
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|float
name|userLimitFactor
init|=
name|getFloat
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|USER_LIMIT_FACTOR
argument_list|,
name|DEFAULT_USER_LIMIT_FACTOR
argument_list|)
decl_stmt|;
return|return
name|userLimitFactor
return|;
block|}
DECL|method|setUserLimitFactor (String queue, float userLimitFactor)
specifier|public
name|void
name|setUserLimitFactor
parameter_list|(
name|String
name|queue
parameter_list|,
name|float
name|userLimitFactor
parameter_list|)
block|{
name|setFloat
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|USER_LIMIT_FACTOR
argument_list|,
name|userLimitFactor
argument_list|)
expr_stmt|;
block|}
DECL|method|getConfiguredState (String queue)
specifier|public
name|QueueState
name|getConfiguredState
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|String
name|state
init|=
name|get
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|STATE
argument_list|)
decl_stmt|;
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|QueueState
operator|.
name|valueOf
argument_list|(
name|StringUtils
operator|.
name|toUpperCase
argument_list|(
name|state
argument_list|)
argument_list|)
return|;
block|}
block|}
DECL|method|getState (String queue)
specifier|public
name|QueueState
name|getState
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|QueueState
name|state
init|=
name|getConfiguredState
argument_list|(
name|queue
argument_list|)
decl_stmt|;
return|return
operator|(
name|state
operator|==
literal|null
operator|)
condition|?
name|QueueState
operator|.
name|RUNNING
else|:
name|state
return|;
block|}
annotation|@
name|Private
annotation|@
name|VisibleForTesting
DECL|method|setState (String queue, QueueState state)
specifier|public
name|void
name|setState
parameter_list|(
name|String
name|queue
parameter_list|,
name|QueueState
name|state
parameter_list|)
block|{
name|set
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|STATE
argument_list|,
name|state
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|setAccessibleNodeLabels (String queue, Set<String> labels)
specifier|public
name|void
name|setAccessibleNodeLabels
parameter_list|(
name|String
name|queue
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|labels
parameter_list|)
block|{
if|if
condition|(
name|labels
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|String
name|str
init|=
name|StringUtils
operator|.
name|join
argument_list|(
literal|","
argument_list|,
name|labels
argument_list|)
decl_stmt|;
name|set
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|ACCESSIBLE_NODE_LABELS
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
DECL|method|getAccessibleNodeLabels (String queue)
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getAccessibleNodeLabels
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|String
name|accessibleLabelStr
init|=
name|get
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|ACCESSIBLE_NODE_LABELS
argument_list|)
decl_stmt|;
comment|// When accessible-label is null,
if|if
condition|(
name|accessibleLabelStr
operator|==
literal|null
condition|)
block|{
comment|// Only return null when queue is not ROOT
if|if
condition|(
operator|!
name|queue
operator|.
name|equals
argument_list|(
name|ROOT
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
comment|// print a warning when accessibleNodeLabel specified in config and queue
comment|// is ROOT
if|if
condition|(
name|queue
operator|.
name|equals
argument_list|(
name|ROOT
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Accessible node labels for root queue will be ignored,"
operator|+
literal|" it will be automatically set to \"*\"."
argument_list|)
expr_stmt|;
block|}
block|}
comment|// always return ANY for queue root
if|if
condition|(
name|queue
operator|.
name|equals
argument_list|(
name|ROOT
argument_list|)
condition|)
block|{
return|return
name|ImmutableSet
operator|.
name|of
argument_list|(
name|RMNodeLabelsManager
operator|.
name|ANY
argument_list|)
return|;
block|}
comment|// In other cases, split the accessibleLabelStr by ","
name|Set
argument_list|<
name|String
argument_list|>
name|set
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|str
range|:
name|accessibleLabelStr
operator|.
name|split
argument_list|(
literal|","
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|str
operator|.
name|trim
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|set
operator|.
name|add
argument_list|(
name|str
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if labels contains "*", only keep ANY behind
if|if
condition|(
name|set
operator|.
name|contains
argument_list|(
name|RMNodeLabelsManager
operator|.
name|ANY
argument_list|)
condition|)
block|{
name|set
operator|.
name|clear
argument_list|()
expr_stmt|;
name|set
operator|.
name|add
argument_list|(
name|RMNodeLabelsManager
operator|.
name|ANY
argument_list|)
expr_stmt|;
block|}
return|return
name|Collections
operator|.
name|unmodifiableSet
argument_list|(
name|set
argument_list|)
return|;
block|}
DECL|method|internalGetLabeledQueueCapacity (String queue, String label, String suffix, float defaultValue)
specifier|private
name|float
name|internalGetLabeledQueueCapacity
parameter_list|(
name|String
name|queue
parameter_list|,
name|String
name|label
parameter_list|,
name|String
name|suffix
parameter_list|,
name|float
name|defaultValue
parameter_list|)
block|{
name|String
name|capacityPropertyName
init|=
name|getNodeLabelPrefix
argument_list|(
name|queue
argument_list|,
name|label
argument_list|)
operator|+
name|suffix
decl_stmt|;
name|boolean
name|matcher
init|=
operator|(
name|capacityPropertyName
operator|!=
literal|null
operator|)
operator|&&
name|RESOURCE_PATTERN
operator|.
name|matcher
argument_list|(
name|capacityPropertyName
argument_list|)
operator|.
name|find
argument_list|()
decl_stmt|;
if|if
condition|(
name|matcher
condition|)
block|{
comment|// Return capacity in percentage as 0 for non-root queues and 100 for
comment|// root.From AbstractCSQueue, absolute resource will be parsed and
comment|// updated. Once nodes are added/removed in cluster, capacity in
comment|// percentage will also be re-calculated.
return|return
name|defaultValue
return|;
block|}
name|float
name|capacity
init|=
name|getFloat
argument_list|(
name|capacityPropertyName
argument_list|,
name|defaultValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|capacity
argument_list|<
name|MINIMUM_CAPACITY_VALUE
operator|||
name|capacity
argument_list|>
name|MAXIMUM_CAPACITY_VALUE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal capacity of "
operator|+
name|capacity
operator|+
literal|" for node-label="
operator|+
name|label
operator|+
literal|" in queue="
operator|+
name|queue
operator|+
literal|", valid capacity should in range of [0, 100]."
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"CSConf - getCapacityOfLabel: prefix="
operator|+
name|getNodeLabelPrefix
argument_list|(
name|queue
argument_list|,
name|label
argument_list|)
operator|+
literal|", capacity="
operator|+
name|capacity
argument_list|)
expr_stmt|;
block|}
return|return
name|capacity
return|;
block|}
DECL|method|getLabeledQueueCapacity (String queue, String label)
specifier|public
name|float
name|getLabeledQueueCapacity
parameter_list|(
name|String
name|queue
parameter_list|,
name|String
name|label
parameter_list|)
block|{
return|return
name|internalGetLabeledQueueCapacity
argument_list|(
name|queue
argument_list|,
name|label
argument_list|,
name|CAPACITY
argument_list|,
literal|0f
argument_list|)
return|;
block|}
DECL|method|getLabeledQueueMaximumCapacity (String queue, String label)
specifier|public
name|float
name|getLabeledQueueMaximumCapacity
parameter_list|(
name|String
name|queue
parameter_list|,
name|String
name|label
parameter_list|)
block|{
return|return
name|internalGetLabeledQueueCapacity
argument_list|(
name|queue
argument_list|,
name|label
argument_list|,
name|MAXIMUM_CAPACITY
argument_list|,
literal|100f
argument_list|)
return|;
block|}
DECL|method|getDefaultNodeLabelExpression (String queue)
specifier|public
name|String
name|getDefaultNodeLabelExpression
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|String
name|defaultLabelExpression
init|=
name|get
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|DEFAULT_NODE_LABEL_EXPRESSION
argument_list|)
decl_stmt|;
if|if
condition|(
name|defaultLabelExpression
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|defaultLabelExpression
operator|.
name|trim
argument_list|()
return|;
block|}
DECL|method|setDefaultNodeLabelExpression (String queue, String exp)
specifier|public
name|void
name|setDefaultNodeLabelExpression
parameter_list|(
name|String
name|queue
parameter_list|,
name|String
name|exp
parameter_list|)
block|{
name|set
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|DEFAULT_NODE_LABEL_EXPRESSION
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
DECL|method|getMaximumAMResourcePercentPerPartition (String queue, String label)
specifier|public
name|float
name|getMaximumAMResourcePercentPerPartition
parameter_list|(
name|String
name|queue
parameter_list|,
name|String
name|label
parameter_list|)
block|{
comment|// If per-partition max-am-resource-percent is not configured,
comment|// use default value as max-am-resource-percent for this queue.
return|return
name|getFloat
argument_list|(
name|getNodeLabelPrefix
argument_list|(
name|queue
argument_list|,
name|label
argument_list|)
operator|+
name|MAXIMUM_AM_RESOURCE_SUFFIX
argument_list|,
name|getMaximumApplicationMasterResourcePerQueuePercent
argument_list|(
name|queue
argument_list|)
argument_list|)
return|;
block|}
DECL|method|setMaximumAMResourcePercentPerPartition (String queue, String label, float percent)
specifier|public
name|void
name|setMaximumAMResourcePercentPerPartition
parameter_list|(
name|String
name|queue
parameter_list|,
name|String
name|label
parameter_list|,
name|float
name|percent
parameter_list|)
block|{
name|setFloat
argument_list|(
name|getNodeLabelPrefix
argument_list|(
name|queue
argument_list|,
name|label
argument_list|)
operator|+
name|MAXIMUM_AM_RESOURCE_SUFFIX
argument_list|,
name|percent
argument_list|)
expr_stmt|;
block|}
comment|/*    * Returns whether we should continue to look at all heart beating nodes even    * after the reservation limit was hit. The node heart beating in could    * satisfy the request thus could be a better pick then waiting for the    * reservation to be fullfilled.  This config is refreshable.    */
DECL|method|getReservationContinueLook ()
specifier|public
name|boolean
name|getReservationContinueLook
parameter_list|()
block|{
return|return
name|getBoolean
argument_list|(
name|RESERVE_CONT_LOOK_ALL_NODES
argument_list|,
name|DEFAULT_RESERVE_CONT_LOOK_ALL_NODES
argument_list|)
return|;
block|}
DECL|method|getAclKey (QueueACL acl)
specifier|private
specifier|static
name|String
name|getAclKey
parameter_list|(
name|QueueACL
name|acl
parameter_list|)
block|{
return|return
literal|"acl_"
operator|+
name|StringUtils
operator|.
name|toLowerCase
argument_list|(
name|acl
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getAcl (String queue, QueueACL acl)
specifier|public
name|AccessControlList
name|getAcl
parameter_list|(
name|String
name|queue
parameter_list|,
name|QueueACL
name|acl
parameter_list|)
block|{
name|String
name|queuePrefix
init|=
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
decl_stmt|;
comment|// The root queue defaults to all access if not defined
comment|// Sub queues inherit access if not defined
name|String
name|defaultAcl
init|=
name|queue
operator|.
name|equals
argument_list|(
name|ROOT
argument_list|)
condition|?
name|ALL_ACL
else|:
name|NONE_ACL
decl_stmt|;
name|String
name|aclString
init|=
name|get
argument_list|(
name|queuePrefix
operator|+
name|getAclKey
argument_list|(
name|acl
argument_list|)
argument_list|,
name|defaultAcl
argument_list|)
decl_stmt|;
return|return
operator|new
name|AccessControlList
argument_list|(
name|aclString
argument_list|)
return|;
block|}
DECL|method|setAcl (String queue, QueueACL acl, String aclString)
specifier|public
name|void
name|setAcl
parameter_list|(
name|String
name|queue
parameter_list|,
name|QueueACL
name|acl
parameter_list|,
name|String
name|aclString
parameter_list|)
block|{
name|String
name|queuePrefix
init|=
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
decl_stmt|;
name|set
argument_list|(
name|queuePrefix
operator|+
name|getAclKey
argument_list|(
name|acl
argument_list|)
argument_list|,
name|aclString
argument_list|)
expr_stmt|;
block|}
DECL|method|getAclKey (ReservationACL acl)
specifier|private
specifier|static
name|String
name|getAclKey
parameter_list|(
name|ReservationACL
name|acl
parameter_list|)
block|{
return|return
literal|"acl_"
operator|+
name|StringUtils
operator|.
name|toLowerCase
argument_list|(
name|acl
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getAclKey (AccessType acl)
specifier|private
specifier|static
name|String
name|getAclKey
parameter_list|(
name|AccessType
name|acl
parameter_list|)
block|{
return|return
literal|"acl_"
operator|+
name|StringUtils
operator|.
name|toLowerCase
argument_list|(
name|acl
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getReservationAcls (String queue)
specifier|public
name|Map
argument_list|<
name|ReservationACL
argument_list|,
name|AccessControlList
argument_list|>
name|getReservationAcls
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|Map
argument_list|<
name|ReservationACL
argument_list|,
name|AccessControlList
argument_list|>
name|resAcls
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ReservationACL
name|acl
range|:
name|ReservationACL
operator|.
name|values
argument_list|()
control|)
block|{
name|resAcls
operator|.
name|put
argument_list|(
name|acl
argument_list|,
name|getReservationAcl
argument_list|(
name|queue
argument_list|,
name|acl
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|resAcls
return|;
block|}
DECL|method|getReservationAcl (String queue, ReservationACL acl)
specifier|private
name|AccessControlList
name|getReservationAcl
parameter_list|(
name|String
name|queue
parameter_list|,
name|ReservationACL
name|acl
parameter_list|)
block|{
name|String
name|queuePrefix
init|=
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
decl_stmt|;
comment|// The root queue defaults to all access if not defined
comment|// Sub queues inherit access if not defined
name|String
name|defaultAcl
init|=
name|ALL_ACL
decl_stmt|;
name|String
name|aclString
init|=
name|get
argument_list|(
name|queuePrefix
operator|+
name|getAclKey
argument_list|(
name|acl
argument_list|)
argument_list|,
name|defaultAcl
argument_list|)
decl_stmt|;
return|return
operator|new
name|AccessControlList
argument_list|(
name|aclString
argument_list|)
return|;
block|}
DECL|method|setAcl (String queue, ReservationACL acl, String aclString)
specifier|private
name|void
name|setAcl
parameter_list|(
name|String
name|queue
parameter_list|,
name|ReservationACL
name|acl
parameter_list|,
name|String
name|aclString
parameter_list|)
block|{
name|String
name|queuePrefix
init|=
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
decl_stmt|;
name|set
argument_list|(
name|queuePrefix
operator|+
name|getAclKey
argument_list|(
name|acl
argument_list|)
argument_list|,
name|aclString
argument_list|)
expr_stmt|;
block|}
DECL|method|setAcl (String queue, AccessType acl, String aclString)
specifier|private
name|void
name|setAcl
parameter_list|(
name|String
name|queue
parameter_list|,
name|AccessType
name|acl
parameter_list|,
name|String
name|aclString
parameter_list|)
block|{
name|String
name|queuePrefix
init|=
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
decl_stmt|;
name|set
argument_list|(
name|queuePrefix
operator|+
name|getAclKey
argument_list|(
name|acl
argument_list|)
argument_list|,
name|aclString
argument_list|)
expr_stmt|;
block|}
DECL|method|getAcls (String queue)
specifier|public
name|Map
argument_list|<
name|AccessType
argument_list|,
name|AccessControlList
argument_list|>
name|getAcls
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|Map
argument_list|<
name|AccessType
argument_list|,
name|AccessControlList
argument_list|>
name|acls
init|=
operator|new
name|HashMap
argument_list|<
name|AccessType
argument_list|,
name|AccessControlList
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|QueueACL
name|acl
range|:
name|QueueACL
operator|.
name|values
argument_list|()
control|)
block|{
name|acls
operator|.
name|put
argument_list|(
name|SchedulerUtils
operator|.
name|toAccessType
argument_list|(
name|acl
argument_list|)
argument_list|,
name|getAcl
argument_list|(
name|queue
argument_list|,
name|acl
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|acls
return|;
block|}
DECL|method|setAcls (String queue, Map<QueueACL, AccessControlList> acls)
specifier|public
name|void
name|setAcls
parameter_list|(
name|String
name|queue
parameter_list|,
name|Map
argument_list|<
name|QueueACL
argument_list|,
name|AccessControlList
argument_list|>
name|acls
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|QueueACL
argument_list|,
name|AccessControlList
argument_list|>
name|e
range|:
name|acls
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|setAcl
argument_list|(
name|queue
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getAclString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|setReservationAcls (String queue, Map<ReservationACL, AccessControlList> acls)
specifier|public
name|void
name|setReservationAcls
parameter_list|(
name|String
name|queue
parameter_list|,
name|Map
argument_list|<
name|ReservationACL
argument_list|,
name|AccessControlList
argument_list|>
name|acls
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ReservationACL
argument_list|,
name|AccessControlList
argument_list|>
name|e
range|:
name|acls
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|setAcl
argument_list|(
name|queue
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getAclString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|setPriorityAcls (String queue, Priority priority, Priority defaultPriority, String[] acls)
specifier|public
name|void
name|setPriorityAcls
parameter_list|(
name|String
name|queue
parameter_list|,
name|Priority
name|priority
parameter_list|,
name|Priority
name|defaultPriority
parameter_list|,
name|String
index|[]
name|acls
parameter_list|)
block|{
name|StringBuilder
name|aclString
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|StringBuilder
name|userAndGroup
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|acls
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|userAndGroup
operator|.
name|append
argument_list|(
name|AppPriorityACLKeyType
operator|.
name|values
argument_list|()
index|[
name|i
index|]
operator|+
literal|"="
operator|+
name|acls
index|[
name|i
index|]
operator|.
name|trim
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|aclString
operator|.
name|append
argument_list|(
literal|"["
operator|+
name|userAndGroup
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
operator|+
literal|" "
operator|+
literal|"max_priority="
operator|+
name|priority
operator|.
name|getPriority
argument_list|()
operator|+
literal|" "
operator|+
literal|"default_priority="
operator|+
name|defaultPriority
operator|.
name|getPriority
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
name|setAcl
argument_list|(
name|queue
argument_list|,
name|AccessType
operator|.
name|APPLICATION_MAX_PRIORITY
argument_list|,
name|aclString
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|getPriorityAcls (String queue, Priority clusterMaxPriority)
specifier|public
name|List
argument_list|<
name|AppPriorityACLGroup
argument_list|>
name|getPriorityAcls
parameter_list|(
name|String
name|queue
parameter_list|,
name|Priority
name|clusterMaxPriority
parameter_list|)
block|{
name|String
name|queuePrefix
init|=
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
decl_stmt|;
name|String
name|defaultAcl
init|=
name|ALL_ACL
decl_stmt|;
name|String
name|aclString
init|=
name|get
argument_list|(
name|queuePrefix
operator|+
name|getAclKey
argument_list|(
name|AccessType
operator|.
name|APPLICATION_MAX_PRIORITY
argument_list|)
argument_list|,
name|defaultAcl
argument_list|)
decl_stmt|;
return|return
name|priorityACLConfig
operator|.
name|getPriorityAcl
argument_list|(
name|clusterMaxPriority
argument_list|,
name|aclString
argument_list|)
return|;
block|}
DECL|method|getQueues (String queue)
specifier|public
name|String
index|[]
name|getQueues
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"CSConf - getQueues called for: queuePrefix="
operator|+
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
argument_list|)
expr_stmt|;
name|String
index|[]
name|queues
init|=
name|getStrings
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|QUEUES
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|trimmedQueueNames
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|queues
condition|)
block|{
for|for
control|(
name|String
name|s
range|:
name|queues
control|)
block|{
name|trimmedQueueNames
operator|.
name|add
argument_list|(
name|s
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|queues
operator|=
name|trimmedQueueNames
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"CSConf - getQueues: queuePrefix="
operator|+
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
literal|", queues="
operator|+
operator|(
operator|(
name|queues
operator|==
literal|null
operator|)
condition|?
literal|""
else|:
name|StringUtils
operator|.
name|arrayToString
argument_list|(
name|queues
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|queues
return|;
block|}
DECL|method|setQueues (String queue, String[] subQueues)
specifier|public
name|void
name|setQueues
parameter_list|(
name|String
name|queue
parameter_list|,
name|String
index|[]
name|subQueues
parameter_list|)
block|{
name|set
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|QUEUES
argument_list|,
name|StringUtils
operator|.
name|arrayToString
argument_list|(
name|subQueues
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"CSConf - setQueues: qPrefix="
operator|+
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
literal|", queues="
operator|+
name|StringUtils
operator|.
name|arrayToString
argument_list|(
name|subQueues
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|getMinimumAllocation ()
specifier|public
name|Resource
name|getMinimumAllocation
parameter_list|()
block|{
name|int
name|minimumMemory
init|=
name|getInt
argument_list|(
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_MINIMUM_ALLOCATION_MB
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_RM_SCHEDULER_MINIMUM_ALLOCATION_MB
argument_list|)
decl_stmt|;
name|int
name|minimumCores
init|=
name|getInt
argument_list|(
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_MINIMUM_ALLOCATION_VCORES
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_RM_SCHEDULER_MINIMUM_ALLOCATION_VCORES
argument_list|)
decl_stmt|;
return|return
name|Resources
operator|.
name|createResource
argument_list|(
name|minimumMemory
argument_list|,
name|minimumCores
argument_list|)
return|;
block|}
DECL|method|getMaximumAllocation ()
specifier|public
name|Resource
name|getMaximumAllocation
parameter_list|()
block|{
name|int
name|maximumMemory
init|=
name|getInt
argument_list|(
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_MAXIMUM_ALLOCATION_MB
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_RM_SCHEDULER_MAXIMUM_ALLOCATION_MB
argument_list|)
decl_stmt|;
name|int
name|maximumCores
init|=
name|getInt
argument_list|(
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_MAXIMUM_ALLOCATION_VCORES
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_RM_SCHEDULER_MAXIMUM_ALLOCATION_VCORES
argument_list|)
decl_stmt|;
return|return
name|Resources
operator|.
name|createResource
argument_list|(
name|maximumMemory
argument_list|,
name|maximumCores
argument_list|)
return|;
block|}
annotation|@
name|Private
DECL|method|getQueuePriority (String queue)
specifier|public
name|Priority
name|getQueuePriority
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|String
name|queuePolicyPrefix
init|=
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
decl_stmt|;
name|Priority
name|pri
init|=
name|Priority
operator|.
name|newInstance
argument_list|(
name|getInt
argument_list|(
name|queuePolicyPrefix
operator|+
literal|"priority"
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|pri
return|;
block|}
annotation|@
name|Private
DECL|method|setQueuePriority (String queue, int priority)
specifier|public
name|void
name|setQueuePriority
parameter_list|(
name|String
name|queue
parameter_list|,
name|int
name|priority
parameter_list|)
block|{
name|String
name|queuePolicyPrefix
init|=
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
decl_stmt|;
name|setInt
argument_list|(
name|queuePolicyPrefix
operator|+
literal|"priority"
argument_list|,
name|priority
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the per queue setting for the maximum limit to allocate to    * each container request.    *    * @param queue    *          name of the queue    * @return setting specified per queue else falls back to the cluster setting    */
DECL|method|getMaximumAllocationPerQueue (String queue)
specifier|public
name|Resource
name|getMaximumAllocationPerQueue
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|String
name|queuePrefix
init|=
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
decl_stmt|;
name|long
name|maxAllocationMbPerQueue
init|=
name|getInt
argument_list|(
name|queuePrefix
operator|+
name|MAXIMUM_ALLOCATION_MB
argument_list|,
operator|(
name|int
operator|)
name|UNDEFINED
argument_list|)
decl_stmt|;
name|int
name|maxAllocationVcoresPerQueue
init|=
name|getInt
argument_list|(
name|queuePrefix
operator|+
name|MAXIMUM_ALLOCATION_VCORES
argument_list|,
operator|(
name|int
operator|)
name|UNDEFINED
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"max alloc mb per queue for "
operator|+
name|queue
operator|+
literal|" is "
operator|+
name|maxAllocationMbPerQueue
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"max alloc vcores per queue for "
operator|+
name|queue
operator|+
literal|" is "
operator|+
name|maxAllocationVcoresPerQueue
argument_list|)
expr_stmt|;
block|}
name|Resource
name|clusterMax
init|=
name|getMaximumAllocation
argument_list|()
decl_stmt|;
if|if
condition|(
name|maxAllocationMbPerQueue
operator|==
operator|(
name|int
operator|)
name|UNDEFINED
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"max alloc mb per queue for "
operator|+
name|queue
operator|+
literal|" is undefined"
argument_list|)
expr_stmt|;
name|maxAllocationMbPerQueue
operator|=
name|clusterMax
operator|.
name|getMemorySize
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|maxAllocationVcoresPerQueue
operator|==
operator|(
name|int
operator|)
name|UNDEFINED
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"max alloc vcore per queue for "
operator|+
name|queue
operator|+
literal|" is undefined"
argument_list|)
expr_stmt|;
name|maxAllocationVcoresPerQueue
operator|=
name|clusterMax
operator|.
name|getVirtualCores
argument_list|()
expr_stmt|;
block|}
name|Resource
name|result
init|=
name|Resources
operator|.
name|createResource
argument_list|(
name|maxAllocationMbPerQueue
argument_list|,
name|maxAllocationVcoresPerQueue
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxAllocationMbPerQueue
operator|>
name|clusterMax
operator|.
name|getMemorySize
argument_list|()
operator|||
name|maxAllocationVcoresPerQueue
operator|>
name|clusterMax
operator|.
name|getVirtualCores
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Queue maximum allocation cannot be larger than the cluster setting"
operator|+
literal|" for queue "
operator|+
name|queue
operator|+
literal|" max allocation per queue: "
operator|+
name|result
operator|+
literal|" cluster setting: "
operator|+
name|clusterMax
argument_list|)
throw|;
block|}
return|return
name|result
return|;
block|}
DECL|method|getEnableUserMetrics ()
specifier|public
name|boolean
name|getEnableUserMetrics
parameter_list|()
block|{
return|return
name|getBoolean
argument_list|(
name|ENABLE_USER_METRICS
argument_list|,
name|DEFAULT_ENABLE_USER_METRICS
argument_list|)
return|;
block|}
DECL|method|getOffSwitchPerHeartbeatLimit ()
specifier|public
name|int
name|getOffSwitchPerHeartbeatLimit
parameter_list|()
block|{
name|int
name|limit
init|=
name|getInt
argument_list|(
name|OFFSWITCH_PER_HEARTBEAT_LIMIT
argument_list|,
name|DEFAULT_OFFSWITCH_PER_HEARTBEAT_LIMIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|limit
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|OFFSWITCH_PER_HEARTBEAT_LIMIT
operator|+
literal|"("
operator|+
name|limit
operator|+
literal|")< 1. Using 1."
argument_list|)
expr_stmt|;
name|limit
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|limit
return|;
block|}
DECL|method|setOffSwitchPerHeartbeatLimit (int limit)
specifier|public
name|void
name|setOffSwitchPerHeartbeatLimit
parameter_list|(
name|int
name|limit
parameter_list|)
block|{
name|setInt
argument_list|(
name|OFFSWITCH_PER_HEARTBEAT_LIMIT
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
DECL|method|getNodeLocalityDelay ()
specifier|public
name|int
name|getNodeLocalityDelay
parameter_list|()
block|{
return|return
name|getInt
argument_list|(
name|NODE_LOCALITY_DELAY
argument_list|,
name|DEFAULT_NODE_LOCALITY_DELAY
argument_list|)
return|;
block|}
DECL|method|getRackLocalityAdditionalDelay ()
specifier|public
name|int
name|getRackLocalityAdditionalDelay
parameter_list|()
block|{
return|return
name|getInt
argument_list|(
name|RACK_LOCALITY_ADDITIONAL_DELAY
argument_list|,
name|DEFAULT_RACK_LOCALITY_ADDITIONAL_DELAY
argument_list|)
return|;
block|}
DECL|method|getRackLocalityFullReset ()
specifier|public
name|boolean
name|getRackLocalityFullReset
parameter_list|()
block|{
return|return
name|getBoolean
argument_list|(
name|RACK_LOCALITY_FULL_RESET
argument_list|,
name|DEFAULT_RACK_LOCALITY_FULL_RESET
argument_list|)
return|;
block|}
DECL|method|getResourceCalculator ()
specifier|public
name|ResourceCalculator
name|getResourceCalculator
parameter_list|()
block|{
return|return
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|getClass
argument_list|(
name|RESOURCE_CALCULATOR_CLASS
argument_list|,
name|DEFAULT_RESOURCE_CALCULATOR_CLASS
argument_list|,
name|ResourceCalculator
operator|.
name|class
argument_list|)
argument_list|,
name|this
argument_list|)
return|;
block|}
DECL|method|getUsePortForNodeName ()
specifier|public
name|boolean
name|getUsePortForNodeName
parameter_list|()
block|{
return|return
name|getBoolean
argument_list|(
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_INCLUDE_PORT_IN_NODE_NAME
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_RM_SCHEDULER_USE_PORT_FOR_NODE_NAME
argument_list|)
return|;
block|}
DECL|method|setResourceComparator ( Class<? extends ResourceCalculator> resourceCalculatorClass)
specifier|public
name|void
name|setResourceComparator
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|ResourceCalculator
argument_list|>
name|resourceCalculatorClass
parameter_list|)
block|{
name|setClass
argument_list|(
name|RESOURCE_CALCULATOR_CLASS
argument_list|,
name|resourceCalculatorClass
argument_list|,
name|ResourceCalculator
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
DECL|method|getScheduleAynschronously ()
specifier|public
name|boolean
name|getScheduleAynschronously
parameter_list|()
block|{
return|return
name|getBoolean
argument_list|(
name|SCHEDULE_ASYNCHRONOUSLY_ENABLE
argument_list|,
name|DEFAULT_SCHEDULE_ASYNCHRONOUSLY_ENABLE
argument_list|)
return|;
block|}
DECL|method|setScheduleAynschronously (boolean async)
specifier|public
name|void
name|setScheduleAynschronously
parameter_list|(
name|boolean
name|async
parameter_list|)
block|{
name|setBoolean
argument_list|(
name|SCHEDULE_ASYNCHRONOUSLY_ENABLE
argument_list|,
name|async
argument_list|)
expr_stmt|;
block|}
DECL|method|getOverrideWithQueueMappings ()
specifier|public
name|boolean
name|getOverrideWithQueueMappings
parameter_list|()
block|{
return|return
name|getBoolean
argument_list|(
name|ENABLE_QUEUE_MAPPING_OVERRIDE
argument_list|,
name|DEFAULT_ENABLE_QUEUE_MAPPING_OVERRIDE
argument_list|)
return|;
block|}
annotation|@
name|Private
annotation|@
name|VisibleForTesting
DECL|method|setOverrideWithQueueMappings (boolean overrideWithQueueMappings)
specifier|public
name|void
name|setOverrideWithQueueMappings
parameter_list|(
name|boolean
name|overrideWithQueueMappings
parameter_list|)
block|{
name|setBoolean
argument_list|(
name|ENABLE_QUEUE_MAPPING_OVERRIDE
argument_list|,
name|overrideWithQueueMappings
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns a collection of strings, trimming leading and trailing whitespeace    * on each value    *    * @param str    *          String to parse    * @param delim    *          delimiter to separate the values    * @return Collection of parsed elements.    */
DECL|method|getTrimmedStringCollection (String str, String delim)
specifier|private
specifier|static
name|Collection
argument_list|<
name|String
argument_list|>
name|getTrimmedStringCollection
parameter_list|(
name|String
name|str
parameter_list|,
name|String
name|delim
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|values
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|str
operator|==
literal|null
condition|)
return|return
name|values
return|;
name|StringTokenizer
name|tokenizer
init|=
operator|new
name|StringTokenizer
argument_list|(
name|str
argument_list|,
name|delim
argument_list|)
decl_stmt|;
while|while
condition|(
name|tokenizer
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|next
init|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|next
operator|==
literal|null
operator|||
name|next
operator|.
name|trim
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|values
operator|.
name|add
argument_list|(
name|next
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|values
return|;
block|}
comment|/**    * Get user/group mappings to queues.    *    * @return user/groups mappings or null on illegal configs    */
DECL|method|getQueueMappings ()
specifier|public
name|List
argument_list|<
name|QueueMapping
argument_list|>
name|getQueueMappings
parameter_list|()
block|{
name|List
argument_list|<
name|QueueMapping
argument_list|>
name|mappings
init|=
operator|new
name|ArrayList
argument_list|<
name|QueueMapping
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|mappingsString
init|=
name|getTrimmedStringCollection
argument_list|(
name|QUEUE_MAPPING
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|mappingValue
range|:
name|mappingsString
control|)
block|{
name|String
index|[]
name|mapping
init|=
name|getTrimmedStringCollection
argument_list|(
name|mappingValue
argument_list|,
literal|":"
argument_list|)
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[]
block|{}
argument_list|)
decl_stmt|;
if|if
condition|(
name|mapping
operator|.
name|length
operator|!=
literal|3
operator|||
name|mapping
index|[
literal|1
index|]
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|||
name|mapping
index|[
literal|2
index|]
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal queue mapping "
operator|+
name|mappingValue
argument_list|)
throw|;
block|}
name|QueueMapping
name|m
decl_stmt|;
try|try
block|{
name|QueueMapping
operator|.
name|MappingType
name|mappingType
decl_stmt|;
if|if
condition|(
name|mapping
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"u"
argument_list|)
condition|)
block|{
name|mappingType
operator|=
name|QueueMapping
operator|.
name|MappingType
operator|.
name|USER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mapping
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"g"
argument_list|)
condition|)
block|{
name|mappingType
operator|=
name|QueueMapping
operator|.
name|MappingType
operator|.
name|GROUP
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"unknown mapping prefix "
operator|+
name|mapping
index|[
literal|0
index|]
argument_list|)
throw|;
block|}
name|m
operator|=
operator|new
name|QueueMapping
argument_list|(
name|mappingType
argument_list|,
name|mapping
index|[
literal|1
index|]
argument_list|,
name|mapping
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal queue mapping "
operator|+
name|mappingValue
argument_list|)
throw|;
block|}
if|if
condition|(
name|m
operator|!=
literal|null
condition|)
block|{
name|mappings
operator|.
name|add
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|mappings
return|;
block|}
annotation|@
name|Private
annotation|@
name|VisibleForTesting
DECL|method|setQueuePlacementRules (Collection<String> queuePlacementRules)
specifier|public
name|void
name|setQueuePlacementRules
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|queuePlacementRules
parameter_list|)
block|{
if|if
condition|(
name|queuePlacementRules
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|String
name|str
init|=
name|StringUtils
operator|.
name|join
argument_list|(
literal|","
argument_list|,
name|queuePlacementRules
argument_list|)
decl_stmt|;
name|setStrings
argument_list|(
name|YarnConfiguration
operator|.
name|QUEUE_PLACEMENT_RULES
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Private
annotation|@
name|VisibleForTesting
DECL|method|setQueueMappings (List<QueueMapping> queueMappings)
specifier|public
name|void
name|setQueueMappings
parameter_list|(
name|List
argument_list|<
name|QueueMapping
argument_list|>
name|queueMappings
parameter_list|)
block|{
if|if
condition|(
name|queueMappings
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|queueMappingStrs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|QueueMapping
name|mapping
range|:
name|queueMappings
control|)
block|{
name|queueMappingStrs
operator|.
name|add
argument_list|(
name|mapping
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|setStrings
argument_list|(
name|QUEUE_MAPPING
argument_list|,
name|StringUtils
operator|.
name|join
argument_list|(
literal|","
argument_list|,
name|queueMappingStrs
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|isReservable (String queue)
specifier|public
name|boolean
name|isReservable
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|boolean
name|isReservable
init|=
name|getBoolean
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|IS_RESERVABLE
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|isReservable
return|;
block|}
DECL|method|setReservable (String queue, boolean isReservable)
specifier|public
name|void
name|setReservable
parameter_list|(
name|String
name|queue
parameter_list|,
name|boolean
name|isReservable
parameter_list|)
block|{
name|setBoolean
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|IS_RESERVABLE
argument_list|,
name|isReservable
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"here setReservableQueue: queuePrefix="
operator|+
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
literal|", isReservableQueue="
operator|+
name|isReservable
argument_list|(
name|queue
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getReservationWindow (String queue)
specifier|public
name|long
name|getReservationWindow
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|long
name|reservationWindow
init|=
name|getLong
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|RESERVATION_WINDOW
argument_list|,
name|DEFAULT_RESERVATION_WINDOW
argument_list|)
decl_stmt|;
return|return
name|reservationWindow
return|;
block|}
annotation|@
name|Override
DECL|method|getAverageCapacity (String queue)
specifier|public
name|float
name|getAverageCapacity
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|float
name|avgCapacity
init|=
name|getFloat
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|AVERAGE_CAPACITY
argument_list|,
name|MAXIMUM_CAPACITY_VALUE
argument_list|)
decl_stmt|;
return|return
name|avgCapacity
return|;
block|}
annotation|@
name|Override
DECL|method|getInstantaneousMaxCapacity (String queue)
specifier|public
name|float
name|getInstantaneousMaxCapacity
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|float
name|instMaxCapacity
init|=
name|getFloat
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|INSTANTANEOUS_MAX_CAPACITY
argument_list|,
name|MAXIMUM_CAPACITY_VALUE
argument_list|)
decl_stmt|;
return|return
name|instMaxCapacity
return|;
block|}
DECL|method|setInstantaneousMaxCapacity (String queue, float instMaxCapacity)
specifier|public
name|void
name|setInstantaneousMaxCapacity
parameter_list|(
name|String
name|queue
parameter_list|,
name|float
name|instMaxCapacity
parameter_list|)
block|{
name|setFloat
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|INSTANTANEOUS_MAX_CAPACITY
argument_list|,
name|instMaxCapacity
argument_list|)
expr_stmt|;
block|}
DECL|method|setReservationWindow (String queue, long reservationWindow)
specifier|public
name|void
name|setReservationWindow
parameter_list|(
name|String
name|queue
parameter_list|,
name|long
name|reservationWindow
parameter_list|)
block|{
name|setLong
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|RESERVATION_WINDOW
argument_list|,
name|reservationWindow
argument_list|)
expr_stmt|;
block|}
DECL|method|setAverageCapacity (String queue, float avgCapacity)
specifier|public
name|void
name|setAverageCapacity
parameter_list|(
name|String
name|queue
parameter_list|,
name|float
name|avgCapacity
parameter_list|)
block|{
name|setFloat
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|AVERAGE_CAPACITY
argument_list|,
name|avgCapacity
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getReservationAdmissionPolicy (String queue)
specifier|public
name|String
name|getReservationAdmissionPolicy
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|String
name|reservationPolicy
init|=
name|get
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|RESERVATION_ADMISSION_POLICY
argument_list|,
name|DEFAULT_RESERVATION_ADMISSION_POLICY
argument_list|)
decl_stmt|;
return|return
name|reservationPolicy
return|;
block|}
DECL|method|setReservationAdmissionPolicy (String queue, String reservationPolicy)
specifier|public
name|void
name|setReservationAdmissionPolicy
parameter_list|(
name|String
name|queue
parameter_list|,
name|String
name|reservationPolicy
parameter_list|)
block|{
name|set
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|RESERVATION_ADMISSION_POLICY
argument_list|,
name|reservationPolicy
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getReservationAgent (String queue)
specifier|public
name|String
name|getReservationAgent
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|String
name|reservationAgent
init|=
name|get
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|RESERVATION_AGENT_NAME
argument_list|,
name|DEFAULT_RESERVATION_AGENT_NAME
argument_list|)
decl_stmt|;
return|return
name|reservationAgent
return|;
block|}
DECL|method|setReservationAgent (String queue, String reservationPolicy)
specifier|public
name|void
name|setReservationAgent
parameter_list|(
name|String
name|queue
parameter_list|,
name|String
name|reservationPolicy
parameter_list|)
block|{
name|set
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|RESERVATION_AGENT_NAME
argument_list|,
name|reservationPolicy
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getShowReservationAsQueues (String queuePath)
specifier|public
name|boolean
name|getShowReservationAsQueues
parameter_list|(
name|String
name|queuePath
parameter_list|)
block|{
name|boolean
name|showReservationAsQueues
init|=
name|getBoolean
argument_list|(
name|getQueuePrefix
argument_list|(
name|queuePath
argument_list|)
operator|+
name|RESERVATION_SHOW_RESERVATION_AS_QUEUE
argument_list|,
name|DEFAULT_SHOW_RESERVATIONS_AS_QUEUES
argument_list|)
decl_stmt|;
return|return
name|showReservationAsQueues
return|;
block|}
annotation|@
name|Override
DECL|method|getReplanner (String queue)
specifier|public
name|String
name|getReplanner
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|String
name|replanner
init|=
name|get
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|RESERVATION_PLANNER_NAME
argument_list|,
name|DEFAULT_RESERVATION_PLANNER_NAME
argument_list|)
decl_stmt|;
return|return
name|replanner
return|;
block|}
annotation|@
name|Override
DECL|method|getMoveOnExpiry (String queue)
specifier|public
name|boolean
name|getMoveOnExpiry
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|boolean
name|killOnExpiry
init|=
name|getBoolean
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|RESERVATION_MOVE_ON_EXPIRY
argument_list|,
name|DEFAULT_RESERVATION_MOVE_ON_EXPIRY
argument_list|)
decl_stmt|;
return|return
name|killOnExpiry
return|;
block|}
annotation|@
name|Override
DECL|method|getEnforcementWindow (String queue)
specifier|public
name|long
name|getEnforcementWindow
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|long
name|enforcementWindow
init|=
name|getLong
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|RESERVATION_ENFORCEMENT_WINDOW
argument_list|,
name|DEFAULT_RESERVATION_ENFORCEMENT_WINDOW
argument_list|)
decl_stmt|;
return|return
name|enforcementWindow
return|;
block|}
comment|/**    * Sets the<em>disable_preemption</em> property in order to indicate    * whether or not container preemption will be disabled for the specified    * queue.    *     * @param queue queue path    * @param preemptionDisabled true if preemption is disabled on queue    */
DECL|method|setPreemptionDisabled (String queue, boolean preemptionDisabled)
specifier|public
name|void
name|setPreemptionDisabled
parameter_list|(
name|String
name|queue
parameter_list|,
name|boolean
name|preemptionDisabled
parameter_list|)
block|{
name|setBoolean
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|QUEUE_PREEMPTION_DISABLED
argument_list|,
name|preemptionDisabled
argument_list|)
expr_stmt|;
block|}
comment|/**    * Indicates whether preemption is disabled on the specified queue.    *     * @param queue queue path to query    * @param defaultVal used as default if the<em>disable_preemption</em>    * is not set in the configuration    * @return true if preemption is disabled on<em>queue</em>, false otherwise    */
DECL|method|getPreemptionDisabled (String queue, boolean defaultVal)
specifier|public
name|boolean
name|getPreemptionDisabled
parameter_list|(
name|String
name|queue
parameter_list|,
name|boolean
name|defaultVal
parameter_list|)
block|{
name|boolean
name|preemptionDisabled
init|=
name|getBoolean
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|QUEUE_PREEMPTION_DISABLED
argument_list|,
name|defaultVal
argument_list|)
decl_stmt|;
return|return
name|preemptionDisabled
return|;
block|}
comment|/**    * Get configured node labels in a given queuePath    */
DECL|method|getConfiguredNodeLabels (String queuePath)
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getConfiguredNodeLabels
parameter_list|(
name|String
name|queuePath
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|configuredNodeLabels
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|e
init|=
literal|null
decl_stmt|;
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|iter
init|=
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|e
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|String
name|key
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|.
name|startsWith
argument_list|(
name|getQueuePrefix
argument_list|(
name|queuePath
argument_list|)
operator|+
name|ACCESSIBLE_NODE_LABELS
operator|+
name|DOT
argument_list|)
condition|)
block|{
comment|// Find<label-name> in
comment|//<queue-path>.accessible-node-labels.<label-name>.property
name|int
name|labelStartIdx
init|=
name|key
operator|.
name|indexOf
argument_list|(
name|ACCESSIBLE_NODE_LABELS
argument_list|)
operator|+
name|ACCESSIBLE_NODE_LABELS
operator|.
name|length
argument_list|()
operator|+
literal|1
decl_stmt|;
name|int
name|labelEndIndx
init|=
name|key
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|,
name|labelStartIdx
argument_list|)
decl_stmt|;
name|String
name|labelName
init|=
name|key
operator|.
name|substring
argument_list|(
name|labelStartIdx
argument_list|,
name|labelEndIndx
argument_list|)
decl_stmt|;
name|configuredNodeLabels
operator|.
name|add
argument_list|(
name|labelName
argument_list|)
expr_stmt|;
block|}
block|}
comment|// always add NO_LABEL
name|configuredNodeLabels
operator|.
name|add
argument_list|(
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|)
expr_stmt|;
return|return
name|configuredNodeLabels
return|;
block|}
DECL|method|getDefaultApplicationPriorityConfPerQueue (String queue)
specifier|public
name|Integer
name|getDefaultApplicationPriorityConfPerQueue
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|Integer
name|defaultPriority
init|=
name|getInt
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|DEFAULT_APPLICATION_PRIORITY
argument_list|,
name|DEFAULT_CONFIGURATION_APPLICATION_PRIORITY
argument_list|)
decl_stmt|;
return|return
name|defaultPriority
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setOrderingPolicy (String queue, String policy)
specifier|public
name|void
name|setOrderingPolicy
parameter_list|(
name|String
name|queue
parameter_list|,
name|String
name|policy
parameter_list|)
block|{
name|set
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|ORDERING_POLICY
argument_list|,
name|policy
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setOrderingPolicyParameter (String queue, String parameterKey, String parameterValue)
specifier|public
name|void
name|setOrderingPolicyParameter
parameter_list|(
name|String
name|queue
parameter_list|,
name|String
name|parameterKey
parameter_list|,
name|String
name|parameterValue
parameter_list|)
block|{
name|set
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|ORDERING_POLICY
operator|+
literal|"."
operator|+
name|parameterKey
argument_list|,
name|parameterValue
argument_list|)
expr_stmt|;
block|}
DECL|method|getLazyPreemptionEnabled ()
specifier|public
name|boolean
name|getLazyPreemptionEnabled
parameter_list|()
block|{
return|return
name|getBoolean
argument_list|(
name|LAZY_PREEMPTION_ENABLED
argument_list|,
name|DEFAULT_LAZY_PREEMPTION_ENABLED
argument_list|)
return|;
block|}
DECL|field|PREEMPTION_CONFIG_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|PREEMPTION_CONFIG_PREFIX
init|=
literal|"yarn.resourcemanager.monitor.capacity.preemption."
decl_stmt|;
DECL|field|INTRA_QUEUE_PREEMPTION_CONFIG_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|INTRA_QUEUE_PREEMPTION_CONFIG_PREFIX
init|=
literal|"intra-queue-preemption."
decl_stmt|;
comment|/** If true, run the policy but do not affect the cluster with preemption and    * kill events. */
DECL|field|PREEMPTION_OBSERVE_ONLY
specifier|public
specifier|static
specifier|final
name|String
name|PREEMPTION_OBSERVE_ONLY
init|=
name|PREEMPTION_CONFIG_PREFIX
operator|+
literal|"observe_only"
decl_stmt|;
DECL|field|DEFAULT_PREEMPTION_OBSERVE_ONLY
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_PREEMPTION_OBSERVE_ONLY
init|=
literal|false
decl_stmt|;
comment|/** Time in milliseconds between invocations of this policy */
DECL|field|PREEMPTION_MONITORING_INTERVAL
specifier|public
specifier|static
specifier|final
name|String
name|PREEMPTION_MONITORING_INTERVAL
init|=
name|PREEMPTION_CONFIG_PREFIX
operator|+
literal|"monitoring_interval"
decl_stmt|;
DECL|field|DEFAULT_PREEMPTION_MONITORING_INTERVAL
specifier|public
specifier|static
specifier|final
name|long
name|DEFAULT_PREEMPTION_MONITORING_INTERVAL
init|=
literal|3000L
decl_stmt|;
comment|/** Time in milliseconds between requesting a preemption from an application    * and killing the container. */
DECL|field|PREEMPTION_WAIT_TIME_BEFORE_KILL
specifier|public
specifier|static
specifier|final
name|String
name|PREEMPTION_WAIT_TIME_BEFORE_KILL
init|=
name|PREEMPTION_CONFIG_PREFIX
operator|+
literal|"max_wait_before_kill"
decl_stmt|;
DECL|field|DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL
specifier|public
specifier|static
specifier|final
name|long
name|DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL
init|=
literal|15000L
decl_stmt|;
comment|/** Maximum percentage of resources preemptionCandidates in a single round. By    * controlling this value one can throttle the pace at which containers are    * reclaimed from the cluster. After computing the total desired preemption,    * the policy scales it back within this limit. */
DECL|field|TOTAL_PREEMPTION_PER_ROUND
specifier|public
specifier|static
specifier|final
name|String
name|TOTAL_PREEMPTION_PER_ROUND
init|=
name|PREEMPTION_CONFIG_PREFIX
operator|+
literal|"total_preemption_per_round"
decl_stmt|;
DECL|field|DEFAULT_TOTAL_PREEMPTION_PER_ROUND
specifier|public
specifier|static
specifier|final
name|float
name|DEFAULT_TOTAL_PREEMPTION_PER_ROUND
init|=
literal|0.1f
decl_stmt|;
comment|/** Maximum amount of resources above the target capacity ignored for    * preemption. This defines a deadzone around the target capacity that helps    * prevent thrashing and oscillations around the computed target balance.    * High values would slow the time to capacity and (absent natural    * completions) it might prevent convergence to guaranteed capacity. */
DECL|field|PREEMPTION_MAX_IGNORED_OVER_CAPACITY
specifier|public
specifier|static
specifier|final
name|String
name|PREEMPTION_MAX_IGNORED_OVER_CAPACITY
init|=
name|PREEMPTION_CONFIG_PREFIX
operator|+
literal|"max_ignored_over_capacity"
decl_stmt|;
DECL|field|DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY
specifier|public
specifier|static
specifier|final
name|double
name|DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY
init|=
literal|0.1
decl_stmt|;
comment|/**    * Given a computed preemption target, account for containers naturally    * expiring and preempt only this percentage of the delta. This determines    * the rate of geometric convergence into the deadzone ({@link    * #PREEMPTION_MAX_IGNORED_OVER_CAPACITY}). For example, a termination factor of 0.5    * will reclaim almost 95% of resources within 5 * {@link    * #PREEMPTION_WAIT_TIME_BEFORE_KILL}, even absent natural termination. */
DECL|field|PREEMPTION_NATURAL_TERMINATION_FACTOR
specifier|public
specifier|static
specifier|final
name|String
name|PREEMPTION_NATURAL_TERMINATION_FACTOR
init|=
name|PREEMPTION_CONFIG_PREFIX
operator|+
literal|"natural_termination_factor"
decl_stmt|;
DECL|field|DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR
specifier|public
specifier|static
specifier|final
name|double
name|DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR
init|=
literal|0.2
decl_stmt|;
comment|/**    * By default, reserved resource will be excluded while balancing capacities    * of queues.    *    * Why doing this? In YARN-4390, we added preemption-based-on-reserved-container    * Support. To reduce unnecessary preemption for large containers. We will    * not include reserved resources while calculating ideal-allocation in    * FifoCandidatesSelector.    *    * Changes in YARN-4390 will significantly reduce number of containers preempted    * When cluster has heterogeneous container requests. (Please check test    * report: https://issues.apache.org/jira/secure/attachment/12796197/YARN-4390-test-results.pdf    *    * However, on the other hand, in some corner cases, especially for    * fragmented cluster. It could lead to preemption cannot kick in in some    * cases. Please see YARN-5731.    *    * So to solve the problem, make this change to be configurable, and please    * note that it is an experimental option.    */
specifier|public
specifier|static
specifier|final
name|String
DECL|field|ADDITIONAL_RESOURCE_BALANCE_BASED_ON_RESERVED_CONTAINERS
name|ADDITIONAL_RESOURCE_BALANCE_BASED_ON_RESERVED_CONTAINERS
init|=
name|PREEMPTION_CONFIG_PREFIX
operator|+
literal|"additional_res_balance_based_on_reserved_containers"
decl_stmt|;
specifier|public
specifier|static
specifier|final
name|boolean
DECL|field|DEFAULT_ADDITIONAL_RESOURCE_BALANCE_BASED_ON_RESERVED_CONTAINERS
name|DEFAULT_ADDITIONAL_RESOURCE_BALANCE_BASED_ON_RESERVED_CONTAINERS
init|=
literal|false
decl_stmt|;
comment|/**    * When calculating which containers to be preempted, we will try to preempt    * containers for reserved containers first. By default is false.    */
DECL|field|PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS
specifier|public
specifier|static
specifier|final
name|String
name|PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS
init|=
name|PREEMPTION_CONFIG_PREFIX
operator|+
literal|"select_based_on_reserved_containers"
decl_stmt|;
DECL|field|DEFAULT_PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS
init|=
literal|false
decl_stmt|;
comment|/**    * For intra-queue preemption, priority/user-limit/fairness based selectors    * can help to preempt containers.    */
DECL|field|INTRAQUEUE_PREEMPTION_ENABLED
specifier|public
specifier|static
specifier|final
name|String
name|INTRAQUEUE_PREEMPTION_ENABLED
init|=
name|PREEMPTION_CONFIG_PREFIX
operator|+
name|INTRA_QUEUE_PREEMPTION_CONFIG_PREFIX
operator|+
literal|"enabled"
decl_stmt|;
DECL|field|DEFAULT_INTRAQUEUE_PREEMPTION_ENABLED
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_INTRAQUEUE_PREEMPTION_ENABLED
init|=
literal|false
decl_stmt|;
comment|/**    * For intra-queue preemption, consider those queues which are above used cap    * limit.    */
DECL|field|INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD
specifier|public
specifier|static
specifier|final
name|String
name|INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD
init|=
name|PREEMPTION_CONFIG_PREFIX
operator|+
name|INTRA_QUEUE_PREEMPTION_CONFIG_PREFIX
operator|+
literal|"minimum-threshold"
decl_stmt|;
DECL|field|DEFAULT_INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD
specifier|public
specifier|static
specifier|final
name|float
name|DEFAULT_INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD
init|=
literal|0.5f
decl_stmt|;
comment|/**    * For intra-queue preemption, allowable maximum-preemptable limit per queue.    */
DECL|field|INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT
specifier|public
specifier|static
specifier|final
name|String
name|INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT
init|=
name|PREEMPTION_CONFIG_PREFIX
operator|+
name|INTRA_QUEUE_PREEMPTION_CONFIG_PREFIX
operator|+
literal|"max-allowable-limit"
decl_stmt|;
DECL|field|DEFAULT_INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT
specifier|public
specifier|static
specifier|final
name|float
name|DEFAULT_INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT
init|=
literal|0.2f
decl_stmt|;
comment|/**    * For intra-queue preemption, enforce a preemption order such as    * "userlimit_first" or "priority_first".    */
DECL|field|INTRAQUEUE_PREEMPTION_ORDER_POLICY
specifier|public
specifier|static
specifier|final
name|String
name|INTRAQUEUE_PREEMPTION_ORDER_POLICY
init|=
name|PREEMPTION_CONFIG_PREFIX
operator|+
name|INTRA_QUEUE_PREEMPTION_CONFIG_PREFIX
operator|+
literal|"preemption-order-policy"
decl_stmt|;
DECL|field|DEFAULT_INTRAQUEUE_PREEMPTION_ORDER_POLICY
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_INTRAQUEUE_PREEMPTION_ORDER_POLICY
init|=
literal|"userlimit_first"
decl_stmt|;
comment|/**    * Maximum application for a queue to be used when application per queue is    * not defined.To be consistent with previous version the default value is set    * as UNDEFINED.    */
annotation|@
name|Private
DECL|field|QUEUE_GLOBAL_MAX_APPLICATION
specifier|public
specifier|static
specifier|final
name|String
name|QUEUE_GLOBAL_MAX_APPLICATION
init|=
name|PREFIX
operator|+
literal|"global-queue-max-application"
decl_stmt|;
DECL|method|getGlobalMaximumApplicationsPerQueue ()
specifier|public
name|int
name|getGlobalMaximumApplicationsPerQueue
parameter_list|()
block|{
name|int
name|maxApplicationsPerQueue
init|=
name|getInt
argument_list|(
name|QUEUE_GLOBAL_MAX_APPLICATION
argument_list|,
operator|(
name|int
operator|)
name|UNDEFINED
argument_list|)
decl_stmt|;
return|return
name|maxApplicationsPerQueue
return|;
block|}
comment|/**    * Ordering policy inside a parent queue to sort queues    */
comment|/**    * Less relative usage queue can get next resource, this is default    */
DECL|field|QUEUE_UTILIZATION_ORDERING_POLICY
specifier|public
specifier|static
specifier|final
name|String
name|QUEUE_UTILIZATION_ORDERING_POLICY
init|=
literal|"utilization"
decl_stmt|;
comment|/**    * Combination of relative usage and priority    */
DECL|field|QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY
specifier|public
specifier|static
specifier|final
name|String
name|QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY
init|=
literal|"priority-utilization"
decl_stmt|;
DECL|field|DEFAULT_QUEUE_ORDERING_POLICY
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_QUEUE_ORDERING_POLICY
init|=
name|QUEUE_UTILIZATION_ORDERING_POLICY
decl_stmt|;
annotation|@
name|Private
DECL|method|setQueueOrderingPolicy (String queue, String policy)
specifier|public
name|void
name|setQueueOrderingPolicy
parameter_list|(
name|String
name|queue
parameter_list|,
name|String
name|policy
parameter_list|)
block|{
name|set
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|ORDERING_POLICY
argument_list|,
name|policy
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Private
DECL|method|getQueueOrderingPolicy (String queue, String parentPolicy)
specifier|public
name|QueueOrderingPolicy
name|getQueueOrderingPolicy
parameter_list|(
name|String
name|queue
parameter_list|,
name|String
name|parentPolicy
parameter_list|)
block|{
name|String
name|defaultPolicy
init|=
name|parentPolicy
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|defaultPolicy
condition|)
block|{
name|defaultPolicy
operator|=
name|DEFAULT_QUEUE_ORDERING_POLICY
expr_stmt|;
block|}
name|String
name|policyType
init|=
name|get
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|ORDERING_POLICY
argument_list|,
name|defaultPolicy
argument_list|)
decl_stmt|;
name|QueueOrderingPolicy
name|qop
decl_stmt|;
if|if
condition|(
name|policyType
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
name|QUEUE_UTILIZATION_ORDERING_POLICY
argument_list|)
condition|)
block|{
comment|// Doesn't respect priority
name|qop
operator|=
operator|new
name|PriorityUtilizationQueueOrderingPolicy
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|policyType
operator|.
name|trim
argument_list|()
operator|.
name|equals
argument_list|(
name|QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY
argument_list|)
condition|)
block|{
name|qop
operator|=
operator|new
name|PriorityUtilizationQueueOrderingPolicy
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|message
init|=
literal|"Unable to construct queue ordering policy="
operator|+
name|policyType
operator|+
literal|" queue="
operator|+
name|queue
decl_stmt|;
throw|throw
operator|new
name|YarnRuntimeException
argument_list|(
name|message
argument_list|)
throw|;
block|}
return|return
name|qop
return|;
block|}
comment|/*    * Get global configuration for ordering policies    */
DECL|method|getOrderingPolicyGlobalConfigKey (String orderPolicyName, String configKey)
specifier|private
name|String
name|getOrderingPolicyGlobalConfigKey
parameter_list|(
name|String
name|orderPolicyName
parameter_list|,
name|String
name|configKey
parameter_list|)
block|{
return|return
name|PREFIX
operator|+
name|ORDERING_POLICY
operator|+
name|DOT
operator|+
name|orderPolicyName
operator|+
name|DOT
operator|+
name|configKey
return|;
block|}
comment|/**    * Global configurations of queue-priority-utilization ordering policy    */
DECL|field|UNDER_UTILIZED_PREEMPTION_ENABLED
specifier|private
specifier|static
specifier|final
name|String
name|UNDER_UTILIZED_PREEMPTION_ENABLED
init|=
literal|"underutilized-preemption.enabled"
decl_stmt|;
comment|/**    * Do we allow under-utilized queue with higher priority to preempt queue    * with lower priority *even if queue with lower priority is not satisfied*.    *    * For example, two queues, a and b    * a.priority = 1, (a.used-capacity - a.reserved-capacity) = 40%    * b.priority = 0, b.used-capacity = 30%    *    * Set this configuration to true to allow queue-a to preempt container from    * queue-b.    *    * (The reason why deduct reserved-capacity from used-capacity for queue with    * higher priority is: the reserved-capacity is just scheduler's internal    * implementation to allocate large containers, it is not possible for    * application to use such reserved-capacity. It is possible that a queue with    * large container requests have a large number of containers but cannot    * allocate from any of them. But scheduler will make sure a satisfied queue    * will not preempt resource from any other queues. A queue is considered to    * be satisfied when queue's used-capacity - reserved-capacity     * guaranteed-capacity.)    *    * @return allowed or not    */
DECL|method|getPUOrderingPolicyUnderUtilizedPreemptionEnabled ()
specifier|public
name|boolean
name|getPUOrderingPolicyUnderUtilizedPreemptionEnabled
parameter_list|()
block|{
return|return
name|getBoolean
argument_list|(
name|getOrderingPolicyGlobalConfigKey
argument_list|(
name|QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY
argument_list|,
name|UNDER_UTILIZED_PREEMPTION_ENABLED
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setPUOrderingPolicyUnderUtilizedPreemptionEnabled ( boolean enabled)
specifier|public
name|void
name|setPUOrderingPolicyUnderUtilizedPreemptionEnabled
parameter_list|(
name|boolean
name|enabled
parameter_list|)
block|{
name|setBoolean
argument_list|(
name|getOrderingPolicyGlobalConfigKey
argument_list|(
name|QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY
argument_list|,
name|UNDER_UTILIZED_PREEMPTION_ENABLED
argument_list|)
argument_list|,
name|enabled
argument_list|)
expr_stmt|;
block|}
DECL|field|UNDER_UTILIZED_PREEMPTION_DELAY
specifier|private
specifier|static
specifier|final
name|String
name|UNDER_UTILIZED_PREEMPTION_DELAY
init|=
literal|"underutilized-preemption.reserved-container-delay-ms"
decl_stmt|;
comment|/**    * When a reserved container of an underutilized queue is created. Preemption    * will kick in after specified delay (in ms).    *    * The total time to preempt resources for a reserved container from higher    * priority queue will be: reserved-container-delay-ms +    * {@link CapacitySchedulerConfiguration#PREEMPTION_WAIT_TIME_BEFORE_KILL}.    *    * This parameter is added to make preemption from lower priority queue which    * is underutilized to be more careful. This parameter takes effect when    * underutilized-preemption.enabled set to true.    *    * @return delay    */
DECL|method|getPUOrderingPolicyUnderUtilizedPreemptionDelay ()
specifier|public
name|long
name|getPUOrderingPolicyUnderUtilizedPreemptionDelay
parameter_list|()
block|{
return|return
name|getLong
argument_list|(
name|getOrderingPolicyGlobalConfigKey
argument_list|(
name|QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY
argument_list|,
name|UNDER_UTILIZED_PREEMPTION_DELAY
argument_list|)
argument_list|,
literal|60000L
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setPUOrderingPolicyUnderUtilizedPreemptionDelay ( long timeout)
specifier|public
name|void
name|setPUOrderingPolicyUnderUtilizedPreemptionDelay
parameter_list|(
name|long
name|timeout
parameter_list|)
block|{
name|setLong
argument_list|(
name|getOrderingPolicyGlobalConfigKey
argument_list|(
name|QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY
argument_list|,
name|UNDER_UTILIZED_PREEMPTION_DELAY
argument_list|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
DECL|field|UNDER_UTILIZED_PREEMPTION_MOVE_RESERVATION
specifier|private
specifier|static
specifier|final
name|String
name|UNDER_UTILIZED_PREEMPTION_MOVE_RESERVATION
init|=
literal|"underutilized-preemption.allow-move-reservation"
decl_stmt|;
comment|/**    * When doing preemption from under-satisfied queues for priority queue.    * Do we allow move reserved container from one host to another?    *    * @return allow or not    */
DECL|method|getPUOrderingPolicyUnderUtilizedPreemptionMoveReservation ()
specifier|public
name|boolean
name|getPUOrderingPolicyUnderUtilizedPreemptionMoveReservation
parameter_list|()
block|{
return|return
name|getBoolean
argument_list|(
name|getOrderingPolicyGlobalConfigKey
argument_list|(
name|QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY
argument_list|,
name|UNDER_UTILIZED_PREEMPTION_MOVE_RESERVATION
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setPUOrderingPolicyUnderUtilizedPreemptionMoveReservation ( boolean allowMoveReservation)
specifier|public
name|void
name|setPUOrderingPolicyUnderUtilizedPreemptionMoveReservation
parameter_list|(
name|boolean
name|allowMoveReservation
parameter_list|)
block|{
name|setBoolean
argument_list|(
name|getOrderingPolicyGlobalConfigKey
argument_list|(
name|QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY
argument_list|,
name|UNDER_UTILIZED_PREEMPTION_MOVE_RESERVATION
argument_list|)
argument_list|,
name|allowMoveReservation
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the weights of all users at this queue level from the configuration.    * Used in computing user-specific user limit, relative to other users.    * @param queuePath full queue path    * @return map of user weights, if they exists. Otherwise, return empty map.    */
DECL|method|getAllUserWeightsForQueue (String queuePath)
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|getAllUserWeightsForQueue
parameter_list|(
name|String
name|queuePath
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|userWeights
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|qPathPlusPrefix
init|=
name|getQueuePrefix
argument_list|(
name|queuePath
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\\."
argument_list|,
literal|"\\\\."
argument_list|)
operator|+
name|USER_SETTINGS
operator|+
literal|"\\."
decl_stmt|;
name|String
name|weightKeyRegex
init|=
name|qPathPlusPrefix
operator|+
literal|"\\w+\\."
operator|+
name|USER_WEIGHT
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|props
init|=
name|getValByRegex
argument_list|(
name|weightKeyRegex
argument_list|)
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|e
range|:
name|props
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|userName
init|=
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|replaceFirst
argument_list|(
name|qPathPlusPrefix
argument_list|,
literal|""
argument_list|)
operator|.
name|replaceFirst
argument_list|(
literal|"\\."
operator|+
name|USER_WEIGHT
argument_list|,
literal|""
argument_list|)
decl_stmt|;
if|if
condition|(
name|userName
operator|!=
literal|null
operator|&&
operator|!
name|userName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|userWeights
operator|.
name|put
argument_list|(
name|userName
argument_list|,
operator|new
name|Float
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|userWeights
return|;
block|}
DECL|method|getAssignMultipleEnabled ()
specifier|public
name|boolean
name|getAssignMultipleEnabled
parameter_list|()
block|{
return|return
name|getBoolean
argument_list|(
name|ASSIGN_MULTIPLE_ENABLED
argument_list|,
name|DEFAULT_ASSIGN_MULTIPLE_ENABLED
argument_list|)
return|;
block|}
DECL|method|getMaxAssignPerHeartbeat ()
specifier|public
name|int
name|getMaxAssignPerHeartbeat
parameter_list|()
block|{
return|return
name|getInt
argument_list|(
name|MAX_ASSIGN_PER_HEARTBEAT
argument_list|,
name|DEFAULT_MAX_ASSIGN_PER_HEARTBEAT
argument_list|)
return|;
block|}
DECL|field|MAXIMUM_LIFETIME_SUFFIX
specifier|public
specifier|static
specifier|final
name|String
name|MAXIMUM_LIFETIME_SUFFIX
init|=
literal|"maximum-application-lifetime"
decl_stmt|;
DECL|field|DEFAULT_LIFETIME_SUFFIX
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_LIFETIME_SUFFIX
init|=
literal|"default-application-lifetime"
decl_stmt|;
DECL|method|getMaximumLifetimePerQueue (String queue)
specifier|public
name|long
name|getMaximumLifetimePerQueue
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|long
name|maximumLifetimePerQueue
init|=
name|getLong
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|MAXIMUM_LIFETIME_SUFFIX
argument_list|,
operator|(
name|long
operator|)
name|UNDEFINED
argument_list|)
decl_stmt|;
return|return
name|maximumLifetimePerQueue
return|;
block|}
DECL|method|setMaximumLifetimePerQueue (String queue, long maximumLifetime)
specifier|public
name|void
name|setMaximumLifetimePerQueue
parameter_list|(
name|String
name|queue
parameter_list|,
name|long
name|maximumLifetime
parameter_list|)
block|{
name|setLong
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|MAXIMUM_LIFETIME_SUFFIX
argument_list|,
name|maximumLifetime
argument_list|)
expr_stmt|;
block|}
DECL|method|getDefaultLifetimePerQueue (String queue)
specifier|public
name|long
name|getDefaultLifetimePerQueue
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
name|long
name|maximumLifetimePerQueue
init|=
name|getLong
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|DEFAULT_LIFETIME_SUFFIX
argument_list|,
operator|(
name|long
operator|)
name|UNDEFINED
argument_list|)
decl_stmt|;
return|return
name|maximumLifetimePerQueue
return|;
block|}
DECL|method|setDefaultLifetimePerQueue (String queue, long defaultLifetime)
specifier|public
name|void
name|setDefaultLifetimePerQueue
parameter_list|(
name|String
name|queue
parameter_list|,
name|long
name|defaultLifetime
parameter_list|)
block|{
name|setLong
argument_list|(
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|DEFAULT_LIFETIME_SUFFIX
argument_list|,
name|defaultLifetime
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Private
DECL|field|DEFAULT_AUTO_CREATE_CHILD_QUEUE_ENABLED
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_AUTO_CREATE_CHILD_QUEUE_ENABLED
init|=
literal|false
decl_stmt|;
annotation|@
name|Private
DECL|field|AUTO_CREATE_CHILD_QUEUE_ENABLED
specifier|public
specifier|static
specifier|final
name|String
name|AUTO_CREATE_CHILD_QUEUE_ENABLED
init|=
literal|"auto-create-child-queue.enabled"
decl_stmt|;
annotation|@
name|Private
DECL|field|AUTO_CREATED_LEAF_QUEUE_TEMPLATE_PREFIX
specifier|public
specifier|static
specifier|final
name|String
name|AUTO_CREATED_LEAF_QUEUE_TEMPLATE_PREFIX
init|=
literal|"leaf-queue-template"
decl_stmt|;
annotation|@
name|Private
DECL|field|AUTO_CREATE_QUEUE_MAX_QUEUES
specifier|public
specifier|static
specifier|final
name|String
name|AUTO_CREATE_QUEUE_MAX_QUEUES
init|=
literal|"auto-create-child-queue.max-queues"
decl_stmt|;
annotation|@
name|Private
DECL|field|DEFAULT_AUTO_CREATE_QUEUE_MAX_QUEUES
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_AUTO_CREATE_QUEUE_MAX_QUEUES
init|=
literal|1000
decl_stmt|;
comment|/**    * If true, this queue will be created as a Parent Queue which Auto Created    * leaf child queues    *    * @param queuePath The queues path    * @return true if auto create is enabled for child queues else false. Default    * is false    */
annotation|@
name|Private
DECL|method|isAutoCreateChildQueueEnabled (String queuePath)
specifier|public
name|boolean
name|isAutoCreateChildQueueEnabled
parameter_list|(
name|String
name|queuePath
parameter_list|)
block|{
name|boolean
name|isAutoCreateEnabled
init|=
name|getBoolean
argument_list|(
name|getQueuePrefix
argument_list|(
name|queuePath
argument_list|)
operator|+
name|AUTO_CREATE_CHILD_QUEUE_ENABLED
argument_list|,
name|DEFAULT_AUTO_CREATE_CHILD_QUEUE_ENABLED
argument_list|)
decl_stmt|;
return|return
name|isAutoCreateEnabled
return|;
block|}
annotation|@
name|Private
annotation|@
name|VisibleForTesting
DECL|method|setAutoCreateChildQueueEnabled (String queuePath, boolean autoCreationEnabled)
specifier|public
name|void
name|setAutoCreateChildQueueEnabled
parameter_list|(
name|String
name|queuePath
parameter_list|,
name|boolean
name|autoCreationEnabled
parameter_list|)
block|{
name|setBoolean
argument_list|(
name|getQueuePrefix
argument_list|(
name|queuePath
argument_list|)
operator|+
name|AUTO_CREATE_CHILD_QUEUE_ENABLED
argument_list|,
name|autoCreationEnabled
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the auto created leaf queue's template configuration prefix    * Leaf queue's template capacities are configured at the parent queue    *    * @param queuePath parent queue's path    * @return Config prefix for leaf queue template configurations    */
annotation|@
name|Private
DECL|method|getAutoCreatedQueueTemplateConfPrefix (String queuePath)
specifier|public
name|String
name|getAutoCreatedQueueTemplateConfPrefix
parameter_list|(
name|String
name|queuePath
parameter_list|)
block|{
return|return
name|queuePath
operator|+
name|DOT
operator|+
name|AUTO_CREATED_LEAF_QUEUE_TEMPLATE_PREFIX
return|;
block|}
annotation|@
name|Private
DECL|field|FAIL_AUTO_CREATION_ON_EXCEEDING_CAPACITY
specifier|public
specifier|static
specifier|final
name|String
name|FAIL_AUTO_CREATION_ON_EXCEEDING_CAPACITY
init|=
literal|"auto-create-child-queue.fail-on-exceeding-parent-capacity"
decl_stmt|;
annotation|@
name|Private
DECL|field|DEFAULT_FAIL_AUTO_CREATION_ON_EXCEEDING_CAPACITY
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_FAIL_AUTO_CREATION_ON_EXCEEDING_CAPACITY
init|=
literal|false
decl_stmt|;
comment|/**    * Fail further auto leaf queue creation when parent's guaranteed capacity is    * exceeded.    *    * @param queuePath the parent queue's path    * @return true if configured to fail else false    */
annotation|@
name|Private
DECL|method|getShouldFailAutoQueueCreationWhenGuaranteedCapacityExceeded ( String queuePath)
specifier|public
name|boolean
name|getShouldFailAutoQueueCreationWhenGuaranteedCapacityExceeded
parameter_list|(
name|String
name|queuePath
parameter_list|)
block|{
name|boolean
name|shouldFailAutoQueueCreationOnExceedingGuaranteedCapacity
init|=
name|getBoolean
argument_list|(
name|getQueuePrefix
argument_list|(
name|queuePath
argument_list|)
operator|+
name|FAIL_AUTO_CREATION_ON_EXCEEDING_CAPACITY
argument_list|,
name|DEFAULT_FAIL_AUTO_CREATION_ON_EXCEEDING_CAPACITY
argument_list|)
decl_stmt|;
return|return
name|shouldFailAutoQueueCreationOnExceedingGuaranteedCapacity
return|;
block|}
annotation|@
name|VisibleForTesting
annotation|@
name|Private
DECL|method|setShouldFailAutoQueueCreationWhenGuaranteedCapacityExceeded ( String queuePath, boolean autoCreationEnabled)
specifier|public
name|void
name|setShouldFailAutoQueueCreationWhenGuaranteedCapacityExceeded
parameter_list|(
name|String
name|queuePath
parameter_list|,
name|boolean
name|autoCreationEnabled
parameter_list|)
block|{
name|setBoolean
argument_list|(
name|getQueuePrefix
argument_list|(
name|queuePath
argument_list|)
operator|+
name|FAIL_AUTO_CREATION_ON_EXCEEDING_CAPACITY
argument_list|,
name|autoCreationEnabled
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the max number of leaf queues that are allowed to be created under    * a parent queue    *    * @param queuePath the paret queue's path    * @return the max number of leaf queues allowed to be auto created    */
annotation|@
name|Private
DECL|method|getAutoCreatedQueuesMaxChildQueuesLimit (String queuePath)
specifier|public
name|int
name|getAutoCreatedQueuesMaxChildQueuesLimit
parameter_list|(
name|String
name|queuePath
parameter_list|)
block|{
return|return
name|getInt
argument_list|(
name|getQueuePrefix
argument_list|(
name|queuePath
argument_list|)
operator|+
name|AUTO_CREATE_QUEUE_MAX_QUEUES
argument_list|,
name|DEFAULT_AUTO_CREATE_QUEUE_MAX_QUEUES
argument_list|)
return|;
block|}
annotation|@
name|Private
annotation|@
name|VisibleForTesting
DECL|method|setAutoCreatedLeafQueueTemplateCapacity (String queuePath, float val)
specifier|public
name|void
name|setAutoCreatedLeafQueueTemplateCapacity
parameter_list|(
name|String
name|queuePath
parameter_list|,
name|float
name|val
parameter_list|)
block|{
name|String
name|leafQueueConfPrefix
init|=
name|getAutoCreatedQueueTemplateConfPrefix
argument_list|(
name|queuePath
argument_list|)
decl_stmt|;
name|setCapacity
argument_list|(
name|leafQueueConfPrefix
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Private
annotation|@
name|VisibleForTesting
DECL|method|setAutoCreatedLeafQueueTemplateMaxCapacity (String queuePath, float val)
specifier|public
name|void
name|setAutoCreatedLeafQueueTemplateMaxCapacity
parameter_list|(
name|String
name|queuePath
parameter_list|,
name|float
name|val
parameter_list|)
block|{
name|String
name|leafQueueConfPrefix
init|=
name|getAutoCreatedQueueTemplateConfPrefix
argument_list|(
name|queuePath
argument_list|)
decl_stmt|;
name|setMaximumCapacity
argument_list|(
name|leafQueueConfPrefix
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
DECL|method|getUnits (String resourceValue)
specifier|public
specifier|static
name|String
name|getUnits
parameter_list|(
name|String
name|resourceValue
parameter_list|)
block|{
name|String
name|units
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|resourceValue
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Character
operator|.
name|isAlphabetic
argument_list|(
name|resourceValue
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
name|units
operator|=
name|resourceValue
operator|.
name|substring
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|isAlpha
argument_list|(
name|units
argument_list|)
condition|)
block|{
return|return
name|units
return|;
block|}
block|}
block|}
return|return
literal|""
return|;
block|}
comment|/**    * Get absolute minimum resource requirement for a queue.    *    * @param label    *          NodeLabel    * @param queue    *          queue path    * @param resourceTypes    *          Resource types    * @return ResourceInformation    */
DECL|method|getMinimumResourceRequirement (String label, String queue, Set<String> resourceTypes)
specifier|public
name|Resource
name|getMinimumResourceRequirement
parameter_list|(
name|String
name|label
parameter_list|,
name|String
name|queue
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|resourceTypes
parameter_list|)
block|{
return|return
name|internalGetLabeledResourceRequirementForQueue
argument_list|(
name|queue
argument_list|,
name|label
argument_list|,
name|resourceTypes
argument_list|,
name|CAPACITY
argument_list|)
return|;
block|}
comment|/**    * Get absolute maximum resource requirement for a queue.    *    * @param label    *          NodeLabel    * @param queue    *          queue path    * @param resourceTypes    *          Resource types    * @return Resource    */
DECL|method|getMaximumResourceRequirement (String label, String queue, Set<String> resourceTypes)
specifier|public
name|Resource
name|getMaximumResourceRequirement
parameter_list|(
name|String
name|label
parameter_list|,
name|String
name|queue
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|resourceTypes
parameter_list|)
block|{
return|return
name|internalGetLabeledResourceRequirementForQueue
argument_list|(
name|queue
argument_list|,
name|label
argument_list|,
name|resourceTypes
argument_list|,
name|MAXIMUM_CAPACITY
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setMinimumResourceRequirement (String label, String queue, Resource resource)
specifier|public
name|void
name|setMinimumResourceRequirement
parameter_list|(
name|String
name|label
parameter_list|,
name|String
name|queue
parameter_list|,
name|Resource
name|resource
parameter_list|)
block|{
name|updateMinMaxResourceToConf
argument_list|(
name|label
argument_list|,
name|queue
argument_list|,
name|resource
argument_list|,
name|CAPACITY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setMaximumResourceRequirement (String label, String queue, Resource resource)
specifier|public
name|void
name|setMaximumResourceRequirement
parameter_list|(
name|String
name|label
parameter_list|,
name|String
name|queue
parameter_list|,
name|Resource
name|resource
parameter_list|)
block|{
name|updateMinMaxResourceToConf
argument_list|(
name|label
argument_list|,
name|queue
argument_list|,
name|resource
argument_list|,
name|MAXIMUM_CAPACITY
argument_list|)
expr_stmt|;
block|}
DECL|method|updateMinMaxResourceToConf (String label, String queue, Resource resource, String type)
specifier|private
name|void
name|updateMinMaxResourceToConf
parameter_list|(
name|String
name|label
parameter_list|,
name|String
name|queue
parameter_list|,
name|Resource
name|resource
parameter_list|,
name|String
name|type
parameter_list|)
block|{
if|if
condition|(
name|queue
operator|.
name|equals
argument_list|(
literal|"root"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot set resource, root queue will take 100% of cluster capacity"
argument_list|)
throw|;
block|}
name|StringBuilder
name|resourceString
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|resourceString
operator|.
name|append
argument_list|(
literal|"["
operator|+
name|AbsoluteResourceType
operator|.
name|MEMORY
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|+
literal|"="
operator|+
name|resource
operator|.
name|getMemorySize
argument_list|()
operator|+
literal|","
operator|+
name|AbsoluteResourceType
operator|.
name|VCORES
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
operator|+
literal|"="
operator|+
name|resource
operator|.
name|getVirtualCores
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
name|String
name|prefix
init|=
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|label
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|prefix
operator|=
name|getQueuePrefix
argument_list|(
name|queue
argument_list|)
operator|+
name|ACCESSIBLE_NODE_LABELS
operator|+
name|DOT
operator|+
name|label
operator|+
name|DOT
operator|+
name|type
expr_stmt|;
block|}
name|set
argument_list|(
name|prefix
argument_list|,
name|resourceString
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|internalGetLabeledResourceRequirementForQueue (String queue, String label, Set<String> resourceTypes, String suffix)
specifier|private
name|Resource
name|internalGetLabeledResourceRequirementForQueue
parameter_list|(
name|String
name|queue
parameter_list|,
name|String
name|label
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|resourceTypes
parameter_list|,
name|String
name|suffix
parameter_list|)
block|{
name|String
name|propertyName
init|=
name|getNodeLabelPrefix
argument_list|(
name|queue
argument_list|,
name|label
argument_list|)
operator|+
name|suffix
decl_stmt|;
name|String
name|resourceString
init|=
name|get
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
if|if
condition|(
name|resourceString
operator|==
literal|null
operator|||
name|resourceString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Resources
operator|.
name|none
argument_list|()
return|;
block|}
comment|// Define resource here.
name|Resource
name|resource
init|=
name|Resource
operator|.
name|newInstance
argument_list|(
literal|0l
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|Matcher
name|matcher
init|=
name|RESOURCE_PATTERN
operator|.
name|matcher
argument_list|(
name|resourceString
argument_list|)
decl_stmt|;
comment|/*      * Absolute resource configuration for a queue will be grouped by "[]".      * Syntax of absolute resource config could be like below      * "memory=4Gi vcores=2". Ideally this means "4GB of memory and 2 vcores".      */
if|if
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
comment|// Get the sub-group.
name|String
name|subGroup
init|=
name|matcher
operator|.
name|group
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|subGroup
operator|.
name|trim
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Resources
operator|.
name|none
argument_list|()
return|;
block|}
name|subGroup
operator|=
name|subGroup
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|subGroup
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|kvPair
range|:
name|subGroup
operator|.
name|trim
argument_list|()
operator|.
name|split
argument_list|(
literal|","
argument_list|)
control|)
block|{
name|String
index|[]
name|splits
init|=
name|kvPair
operator|.
name|split
argument_list|(
literal|"="
argument_list|)
decl_stmt|;
comment|// Ensure that each sub string is key value pair separated by '='.
if|if
condition|(
name|splits
operator|!=
literal|null
operator|&&
name|splits
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|updateResourceValuesFromConfig
argument_list|(
name|resourceTypes
argument_list|,
name|resource
argument_list|,
name|splits
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Memory has to be configured always.
if|if
condition|(
name|resource
operator|.
name|getMemorySize
argument_list|()
operator|==
literal|0l
condition|)
block|{
return|return
name|Resources
operator|.
name|none
argument_list|()
return|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"CSConf - getAbsolueResourcePerQueue: prefix="
operator|+
name|getNodeLabelPrefix
argument_list|(
name|queue
argument_list|,
name|label
argument_list|)
operator|+
literal|", capacity="
operator|+
name|resource
argument_list|)
expr_stmt|;
block|}
return|return
name|resource
return|;
block|}
DECL|method|updateResourceValuesFromConfig (Set<String> resourceTypes, Resource resource, String[] splits)
specifier|private
name|void
name|updateResourceValuesFromConfig
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|resourceTypes
parameter_list|,
name|Resource
name|resource
parameter_list|,
name|String
index|[]
name|splits
parameter_list|)
block|{
comment|// If key is not a valid type, skip it.
if|if
condition|(
operator|!
name|resourceTypes
operator|.
name|contains
argument_list|(
name|splits
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
return|return;
block|}
name|String
name|units
init|=
name|getUnits
argument_list|(
name|splits
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|Long
name|resourceValue
init|=
name|Long
operator|.
name|valueOf
argument_list|(
name|splits
index|[
literal|1
index|]
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|splits
index|[
literal|1
index|]
operator|.
name|length
argument_list|()
operator|-
name|units
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// Convert all incoming units to MB if units is configured.
if|if
condition|(
operator|!
name|units
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|resourceValue
operator|=
name|UnitsConversionUtil
operator|.
name|convert
argument_list|(
name|units
argument_list|,
literal|"Mi"
argument_list|,
name|resourceValue
argument_list|)
expr_stmt|;
block|}
comment|// map it based on key.
name|AbsoluteResourceType
name|resType
init|=
name|AbsoluteResourceType
operator|.
name|valueOf
argument_list|(
name|StringUtils
operator|.
name|toUpperCase
argument_list|(
name|splits
index|[
literal|0
index|]
operator|.
name|trim
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|resType
condition|)
block|{
case|case
name|MEMORY
case|:
name|resource
operator|.
name|setMemorySize
argument_list|(
name|resourceValue
argument_list|)
expr_stmt|;
break|break;
case|case
name|VCORES
case|:
name|resource
operator|.
name|setVirtualCores
argument_list|(
name|resourceValue
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default :
break|break;
block|}
block|}
block|}
end_class

end_unit

