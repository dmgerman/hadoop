begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|Private
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|AccessControlList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|factories
operator|.
name|RecordFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|factory
operator|.
name|providers
operator|.
name|RecordFactoryProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|security
operator|.
name|AccessType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|security
operator|.
name|PrivilegedEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|security
operator|.
name|PrivilegedEntity
operator|.
name|EntityType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|security
operator|.
name|YarnAuthorizationProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|nodelabels
operator|.
name|RMNodeLabelsManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|NodeType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|QueueMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|ResourceLimits
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|ResourceUsage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|SchedulerUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|ResourceCalculator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|Resources
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_class
DECL|class|AbstractCSQueue
specifier|public
specifier|abstract
class|class
name|AbstractCSQueue
implements|implements
name|CSQueue
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|AbstractCSQueue
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|NULL_ASSIGNMENT
specifier|static
specifier|final
name|CSAssignment
name|NULL_ASSIGNMENT
init|=
operator|new
name|CSAssignment
argument_list|(
name|Resources
operator|.
name|createResource
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NodeType
operator|.
name|NODE_LOCAL
argument_list|)
decl_stmt|;
DECL|field|SKIP_ASSIGNMENT
specifier|static
specifier|final
name|CSAssignment
name|SKIP_ASSIGNMENT
init|=
operator|new
name|CSAssignment
argument_list|(
literal|true
argument_list|)
decl_stmt|;
DECL|field|parent
name|CSQueue
name|parent
decl_stmt|;
DECL|field|queueName
specifier|final
name|String
name|queueName
decl_stmt|;
DECL|field|numContainers
specifier|volatile
name|int
name|numContainers
decl_stmt|;
DECL|field|minimumAllocation
specifier|final
name|Resource
name|minimumAllocation
decl_stmt|;
DECL|field|maximumAllocation
name|Resource
name|maximumAllocation
decl_stmt|;
DECL|field|state
name|QueueState
name|state
decl_stmt|;
DECL|field|metrics
specifier|final
name|QueueMetrics
name|metrics
decl_stmt|;
DECL|field|queueEntity
specifier|protected
specifier|final
name|PrivilegedEntity
name|queueEntity
decl_stmt|;
DECL|field|resourceCalculator
specifier|final
name|ResourceCalculator
name|resourceCalculator
decl_stmt|;
DECL|field|accessibleLabels
name|Set
argument_list|<
name|String
argument_list|>
name|accessibleLabels
decl_stmt|;
DECL|field|labelManager
name|RMNodeLabelsManager
name|labelManager
decl_stmt|;
DECL|field|defaultLabelExpression
name|String
name|defaultLabelExpression
decl_stmt|;
DECL|field|acls
name|Map
argument_list|<
name|AccessType
argument_list|,
name|AccessControlList
argument_list|>
name|acls
init|=
operator|new
name|HashMap
argument_list|<
name|AccessType
argument_list|,
name|AccessControlList
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|reservationsContinueLooking
name|boolean
name|reservationsContinueLooking
decl_stmt|;
DECL|field|preemptionDisabled
specifier|private
name|boolean
name|preemptionDisabled
decl_stmt|;
comment|// Track resource usage-by-label like used-resource/pending-resource, etc.
DECL|field|queueUsage
name|ResourceUsage
name|queueUsage
decl_stmt|;
comment|// Track capacities like used-capcity/abs-used-capacity/capacity/abs-capacity,
comment|// etc.
DECL|field|queueCapacities
name|QueueCapacities
name|queueCapacities
decl_stmt|;
DECL|field|recordFactory
specifier|private
specifier|final
name|RecordFactory
name|recordFactory
init|=
name|RecordFactoryProvider
operator|.
name|getRecordFactory
argument_list|(
literal|null
argument_list|)
decl_stmt|;
DECL|field|csContext
specifier|protected
name|CapacitySchedulerContext
name|csContext
decl_stmt|;
DECL|field|authorizer
specifier|protected
name|YarnAuthorizationProvider
name|authorizer
init|=
literal|null
decl_stmt|;
DECL|method|AbstractCSQueue (CapacitySchedulerContext cs, String queueName, CSQueue parent, CSQueue old)
specifier|public
name|AbstractCSQueue
parameter_list|(
name|CapacitySchedulerContext
name|cs
parameter_list|,
name|String
name|queueName
parameter_list|,
name|CSQueue
name|parent
parameter_list|,
name|CSQueue
name|old
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|labelManager
operator|=
name|cs
operator|.
name|getRMContext
argument_list|()
operator|.
name|getNodeLabelManager
argument_list|()
expr_stmt|;
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
name|this
operator|.
name|queueName
operator|=
name|queueName
expr_stmt|;
name|this
operator|.
name|resourceCalculator
operator|=
name|cs
operator|.
name|getResourceCalculator
argument_list|()
expr_stmt|;
comment|// must be called after parent and queueName is set
name|this
operator|.
name|metrics
operator|=
name|old
operator|!=
literal|null
condition|?
name|old
operator|.
name|getMetrics
argument_list|()
else|:
name|QueueMetrics
operator|.
name|forQueue
argument_list|(
name|getQueuePath
argument_list|()
argument_list|,
name|parent
argument_list|,
name|cs
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getEnableUserMetrics
argument_list|()
argument_list|,
name|cs
operator|.
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|csContext
operator|=
name|cs
expr_stmt|;
name|this
operator|.
name|minimumAllocation
operator|=
name|csContext
operator|.
name|getMinimumResourceCapability
argument_list|()
expr_stmt|;
comment|// initialize ResourceUsage
name|queueUsage
operator|=
operator|new
name|ResourceUsage
argument_list|()
expr_stmt|;
name|queueEntity
operator|=
operator|new
name|PrivilegedEntity
argument_list|(
name|EntityType
operator|.
name|QUEUE
argument_list|,
name|getQueuePath
argument_list|()
argument_list|)
expr_stmt|;
comment|// initialize QueueCapacities
name|queueCapacities
operator|=
operator|new
name|QueueCapacities
argument_list|(
name|parent
operator|==
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|setupConfigurableCapacities ()
specifier|protected
name|void
name|setupConfigurableCapacities
parameter_list|()
block|{
name|CSQueueUtils
operator|.
name|loadUpdateAndCheckCapacities
argument_list|(
name|getQueuePath
argument_list|()
argument_list|,
name|accessibleLabels
argument_list|,
name|csContext
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|queueCapacities
argument_list|,
name|parent
operator|==
literal|null
condition|?
literal|null
else|:
name|parent
operator|.
name|getQueueCapacities
argument_list|()
argument_list|,
name|csContext
operator|.
name|getRMContext
argument_list|()
operator|.
name|getNodeLabelManager
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getCapacity ()
specifier|public
specifier|synchronized
name|float
name|getCapacity
parameter_list|()
block|{
return|return
name|queueCapacities
operator|.
name|getCapacity
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getAbsoluteCapacity ()
specifier|public
specifier|synchronized
name|float
name|getAbsoluteCapacity
parameter_list|()
block|{
return|return
name|queueCapacities
operator|.
name|getAbsoluteCapacity
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getAbsoluteMaximumCapacity ()
specifier|public
name|float
name|getAbsoluteMaximumCapacity
parameter_list|()
block|{
return|return
name|queueCapacities
operator|.
name|getAbsoluteMaximumCapacity
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getAbsoluteUsedCapacity ()
specifier|public
specifier|synchronized
name|float
name|getAbsoluteUsedCapacity
parameter_list|()
block|{
return|return
name|queueCapacities
operator|.
name|getAbsoluteUsedCapacity
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getMaximumCapacity ()
specifier|public
name|float
name|getMaximumCapacity
parameter_list|()
block|{
return|return
name|queueCapacities
operator|.
name|getMaximumCapacity
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getUsedCapacity ()
specifier|public
specifier|synchronized
name|float
name|getUsedCapacity
parameter_list|()
block|{
return|return
name|queueCapacities
operator|.
name|getUsedCapacity
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getUsedResources ()
specifier|public
name|Resource
name|getUsedResources
parameter_list|()
block|{
return|return
name|queueUsage
operator|.
name|getUsed
argument_list|()
return|;
block|}
DECL|method|getNumContainers ()
specifier|public
specifier|synchronized
name|int
name|getNumContainers
parameter_list|()
block|{
return|return
name|numContainers
return|;
block|}
annotation|@
name|Override
DECL|method|getState ()
specifier|public
specifier|synchronized
name|QueueState
name|getState
parameter_list|()
block|{
return|return
name|state
return|;
block|}
annotation|@
name|Override
DECL|method|getMetrics ()
specifier|public
name|QueueMetrics
name|getMetrics
parameter_list|()
block|{
return|return
name|metrics
return|;
block|}
annotation|@
name|Override
DECL|method|getQueueName ()
specifier|public
name|String
name|getQueueName
parameter_list|()
block|{
return|return
name|queueName
return|;
block|}
DECL|method|getPrivilegedEntity ()
specifier|public
name|PrivilegedEntity
name|getPrivilegedEntity
parameter_list|()
block|{
return|return
name|queueEntity
return|;
block|}
annotation|@
name|Override
DECL|method|getParent ()
specifier|public
specifier|synchronized
name|CSQueue
name|getParent
parameter_list|()
block|{
return|return
name|parent
return|;
block|}
annotation|@
name|Override
DECL|method|setParent (CSQueue newParentQueue)
specifier|public
specifier|synchronized
name|void
name|setParent
parameter_list|(
name|CSQueue
name|newParentQueue
parameter_list|)
block|{
name|this
operator|.
name|parent
operator|=
operator|(
name|ParentQueue
operator|)
name|newParentQueue
expr_stmt|;
block|}
DECL|method|getAccessibleNodeLabels ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getAccessibleNodeLabels
parameter_list|()
block|{
return|return
name|accessibleLabels
return|;
block|}
annotation|@
name|Override
DECL|method|hasAccess (QueueACL acl, UserGroupInformation user)
specifier|public
name|boolean
name|hasAccess
parameter_list|(
name|QueueACL
name|acl
parameter_list|,
name|UserGroupInformation
name|user
parameter_list|)
block|{
return|return
name|authorizer
operator|.
name|checkPermission
argument_list|(
name|SchedulerUtils
operator|.
name|toAccessType
argument_list|(
name|acl
argument_list|)
argument_list|,
name|queueEntity
argument_list|,
name|user
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setUsedCapacity (float usedCapacity)
specifier|public
specifier|synchronized
name|void
name|setUsedCapacity
parameter_list|(
name|float
name|usedCapacity
parameter_list|)
block|{
name|queueCapacities
operator|.
name|setUsedCapacity
argument_list|(
name|usedCapacity
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setAbsoluteUsedCapacity (float absUsedCapacity)
specifier|public
specifier|synchronized
name|void
name|setAbsoluteUsedCapacity
parameter_list|(
name|float
name|absUsedCapacity
parameter_list|)
block|{
name|queueCapacities
operator|.
name|setAbsoluteUsedCapacity
argument_list|(
name|absUsedCapacity
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set maximum capacity - used only for testing.    * @param maximumCapacity new max capacity    */
DECL|method|setMaxCapacity (float maximumCapacity)
specifier|synchronized
name|void
name|setMaxCapacity
parameter_list|(
name|float
name|maximumCapacity
parameter_list|)
block|{
comment|// Sanity check
name|CSQueueUtils
operator|.
name|checkMaxCapacity
argument_list|(
name|getQueueName
argument_list|()
argument_list|,
name|queueCapacities
operator|.
name|getCapacity
argument_list|()
argument_list|,
name|maximumCapacity
argument_list|)
expr_stmt|;
name|float
name|absMaxCapacity
init|=
name|CSQueueUtils
operator|.
name|computeAbsoluteMaximumCapacity
argument_list|(
name|maximumCapacity
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|CSQueueUtils
operator|.
name|checkAbsoluteCapacity
argument_list|(
name|getQueueName
argument_list|()
argument_list|,
name|queueCapacities
operator|.
name|getAbsoluteCapacity
argument_list|()
argument_list|,
name|absMaxCapacity
argument_list|)
expr_stmt|;
name|queueCapacities
operator|.
name|setMaximumCapacity
argument_list|(
name|maximumCapacity
argument_list|)
expr_stmt|;
name|queueCapacities
operator|.
name|setAbsoluteMaximumCapacity
argument_list|(
name|absMaxCapacity
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getDefaultNodeLabelExpression ()
specifier|public
name|String
name|getDefaultNodeLabelExpression
parameter_list|()
block|{
return|return
name|defaultLabelExpression
return|;
block|}
DECL|method|setupQueueConfigs (Resource clusterResource)
specifier|synchronized
name|void
name|setupQueueConfigs
parameter_list|(
name|Resource
name|clusterResource
parameter_list|)
throws|throws
name|IOException
block|{
comment|// get labels
name|this
operator|.
name|accessibleLabels
operator|=
name|csContext
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getAccessibleNodeLabels
argument_list|(
name|getQueuePath
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|defaultLabelExpression
operator|=
name|csContext
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getDefaultNodeLabelExpression
argument_list|(
name|getQueuePath
argument_list|()
argument_list|)
expr_stmt|;
comment|// inherit from parent if labels not set
if|if
condition|(
name|this
operator|.
name|accessibleLabels
operator|==
literal|null
operator|&&
name|parent
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|accessibleLabels
operator|=
name|parent
operator|.
name|getAccessibleNodeLabels
argument_list|()
expr_stmt|;
block|}
name|SchedulerUtils
operator|.
name|checkIfLabelInClusterNodeLabels
argument_list|(
name|labelManager
argument_list|,
name|this
operator|.
name|accessibleLabels
argument_list|)
expr_stmt|;
comment|// inherit from parent if labels not set
if|if
condition|(
name|this
operator|.
name|defaultLabelExpression
operator|==
literal|null
operator|&&
name|parent
operator|!=
literal|null
operator|&&
name|this
operator|.
name|accessibleLabels
operator|.
name|containsAll
argument_list|(
name|parent
operator|.
name|getAccessibleNodeLabels
argument_list|()
argument_list|)
condition|)
block|{
name|this
operator|.
name|defaultLabelExpression
operator|=
name|parent
operator|.
name|getDefaultNodeLabelExpression
argument_list|()
expr_stmt|;
block|}
comment|// After we setup labels, we can setup capacities
name|setupConfigurableCapacities
argument_list|()
expr_stmt|;
name|this
operator|.
name|maximumAllocation
operator|=
name|csContext
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getMaximumAllocationPerQueue
argument_list|(
name|getQueuePath
argument_list|()
argument_list|)
expr_stmt|;
name|authorizer
operator|=
name|YarnAuthorizationProvider
operator|.
name|getInstance
argument_list|(
name|csContext
operator|.
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|csContext
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getState
argument_list|(
name|getQueuePath
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|acls
operator|=
name|csContext
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getAcls
argument_list|(
name|getQueuePath
argument_list|()
argument_list|)
expr_stmt|;
comment|// Update metrics
name|CSQueueUtils
operator|.
name|updateQueueStatistics
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|minimumAllocation
argument_list|,
name|this
argument_list|,
name|labelManager
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// Check if labels of this queue is a subset of parent queue, only do this
comment|// when we not root
if|if
condition|(
name|parent
operator|!=
literal|null
operator|&&
name|parent
operator|.
name|getParent
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|parent
operator|.
name|getAccessibleNodeLabels
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|parent
operator|.
name|getAccessibleNodeLabels
argument_list|()
operator|.
name|contains
argument_list|(
name|RMNodeLabelsManager
operator|.
name|ANY
argument_list|)
condition|)
block|{
comment|// if parent isn't "*", child shouldn't be "*" too
if|if
condition|(
name|this
operator|.
name|getAccessibleNodeLabels
argument_list|()
operator|.
name|contains
argument_list|(
name|RMNodeLabelsManager
operator|.
name|ANY
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Parent's accessible queue is not ANY(*), "
operator|+
literal|"but child's accessible queue is *"
argument_list|)
throw|;
block|}
else|else
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|diff
init|=
name|Sets
operator|.
name|difference
argument_list|(
name|this
operator|.
name|getAccessibleNodeLabels
argument_list|()
argument_list|,
name|parent
operator|.
name|getAccessibleNodeLabels
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|diff
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Some labels of child queue is not a subset "
operator|+
literal|"of parent queue, these labels=["
operator|+
name|StringUtils
operator|.
name|join
argument_list|(
name|diff
argument_list|,
literal|","
argument_list|)
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
name|this
operator|.
name|reservationsContinueLooking
operator|=
name|csContext
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getReservationContinueLook
argument_list|()
expr_stmt|;
name|this
operator|.
name|preemptionDisabled
operator|=
name|isQueueHierarchyPreemptionDisabled
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|getQueueInfo ()
specifier|protected
name|QueueInfo
name|getQueueInfo
parameter_list|()
block|{
name|QueueInfo
name|queueInfo
init|=
name|recordFactory
operator|.
name|newRecordInstance
argument_list|(
name|QueueInfo
operator|.
name|class
argument_list|)
decl_stmt|;
name|queueInfo
operator|.
name|setQueueName
argument_list|(
name|queueName
argument_list|)
expr_stmt|;
name|queueInfo
operator|.
name|setAccessibleNodeLabels
argument_list|(
name|accessibleLabels
argument_list|)
expr_stmt|;
name|queueInfo
operator|.
name|setCapacity
argument_list|(
name|queueCapacities
operator|.
name|getCapacity
argument_list|()
argument_list|)
expr_stmt|;
name|queueInfo
operator|.
name|setMaximumCapacity
argument_list|(
name|queueCapacities
operator|.
name|getMaximumCapacity
argument_list|()
argument_list|)
expr_stmt|;
name|queueInfo
operator|.
name|setQueueState
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|queueInfo
operator|.
name|setDefaultNodeLabelExpression
argument_list|(
name|defaultLabelExpression
argument_list|)
expr_stmt|;
name|queueInfo
operator|.
name|setCurrentCapacity
argument_list|(
name|getUsedCapacity
argument_list|()
argument_list|)
expr_stmt|;
name|queueInfo
operator|.
name|setQueueStatistics
argument_list|(
name|getQueueStatistics
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|queueInfo
return|;
block|}
DECL|method|getQueueStatistics ()
specifier|public
name|QueueStatistics
name|getQueueStatistics
parameter_list|()
block|{
name|QueueStatistics
name|stats
init|=
name|recordFactory
operator|.
name|newRecordInstance
argument_list|(
name|QueueStatistics
operator|.
name|class
argument_list|)
decl_stmt|;
name|stats
operator|.
name|setNumAppsSubmitted
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getAppsSubmitted
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setNumAppsRunning
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getAppsRunning
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setNumAppsPending
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getAppsPending
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setNumAppsCompleted
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getAppsCompleted
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setNumAppsKilled
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getAppsKilled
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setNumAppsFailed
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getAppsFailed
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setNumActiveUsers
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getActiveUsers
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setAvailableMemoryMB
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getAvailableMB
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setAllocatedMemoryMB
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getAllocatedMB
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setPendingMemoryMB
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getPendingMB
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setReservedMemoryMB
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getReservedMB
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setAvailableVCores
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getAvailableVirtualCores
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setAllocatedVCores
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getAllocatedVirtualCores
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setPendingVCores
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getPendingVirtualCores
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setReservedVCores
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getReservedVirtualCores
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|stats
return|;
block|}
annotation|@
name|Private
DECL|method|getMaximumAllocation ()
specifier|public
specifier|synchronized
name|Resource
name|getMaximumAllocation
parameter_list|()
block|{
return|return
name|maximumAllocation
return|;
block|}
annotation|@
name|Private
DECL|method|getMinimumAllocation ()
specifier|public
name|Resource
name|getMinimumAllocation
parameter_list|()
block|{
return|return
name|minimumAllocation
return|;
block|}
DECL|method|allocateResource (Resource clusterResource, Resource resource, String nodePartition)
specifier|synchronized
name|void
name|allocateResource
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|Resource
name|resource
parameter_list|,
name|String
name|nodePartition
parameter_list|)
block|{
name|queueUsage
operator|.
name|incUsed
argument_list|(
name|nodePartition
argument_list|,
name|resource
argument_list|)
expr_stmt|;
operator|++
name|numContainers
expr_stmt|;
name|CSQueueUtils
operator|.
name|updateQueueStatistics
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|minimumAllocation
argument_list|,
name|this
argument_list|,
name|labelManager
argument_list|,
name|nodePartition
argument_list|)
expr_stmt|;
block|}
DECL|method|releaseResource (Resource clusterResource, Resource resource, String nodePartition)
specifier|protected
specifier|synchronized
name|void
name|releaseResource
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|Resource
name|resource
parameter_list|,
name|String
name|nodePartition
parameter_list|)
block|{
name|queueUsage
operator|.
name|decUsed
argument_list|(
name|nodePartition
argument_list|,
name|resource
argument_list|)
expr_stmt|;
name|CSQueueUtils
operator|.
name|updateQueueStatistics
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|minimumAllocation
argument_list|,
name|this
argument_list|,
name|labelManager
argument_list|,
name|nodePartition
argument_list|)
expr_stmt|;
operator|--
name|numContainers
expr_stmt|;
block|}
annotation|@
name|Private
DECL|method|getReservationContinueLooking ()
specifier|public
name|boolean
name|getReservationContinueLooking
parameter_list|()
block|{
return|return
name|reservationsContinueLooking
return|;
block|}
annotation|@
name|Private
DECL|method|getACLs ()
specifier|public
name|Map
argument_list|<
name|AccessType
argument_list|,
name|AccessControlList
argument_list|>
name|getACLs
parameter_list|()
block|{
return|return
name|acls
return|;
block|}
annotation|@
name|Private
DECL|method|getPreemptionDisabled ()
specifier|public
name|boolean
name|getPreemptionDisabled
parameter_list|()
block|{
return|return
name|preemptionDisabled
return|;
block|}
annotation|@
name|Private
DECL|method|getQueueCapacities ()
specifier|public
name|QueueCapacities
name|getQueueCapacities
parameter_list|()
block|{
return|return
name|queueCapacities
return|;
block|}
annotation|@
name|Private
DECL|method|getQueueResourceUsage ()
specifier|public
name|ResourceUsage
name|getQueueResourceUsage
parameter_list|()
block|{
return|return
name|queueUsage
return|;
block|}
comment|/**    * The specified queue is preemptable if system-wide preemption is turned on    * unless any queue in the<em>qPath</em> hierarchy has explicitly turned    * preemption off.    * NOTE: Preemptability is inherited from a queue's parent.    *     * @return true if queue has preemption disabled, false otherwise    */
DECL|method|isQueueHierarchyPreemptionDisabled (CSQueue q)
specifier|private
name|boolean
name|isQueueHierarchyPreemptionDisabled
parameter_list|(
name|CSQueue
name|q
parameter_list|)
block|{
name|CapacitySchedulerConfiguration
name|csConf
init|=
name|csContext
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|boolean
name|systemWidePreemption
init|=
name|csConf
operator|.
name|getBoolean
argument_list|(
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_ENABLE_MONITORS
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_RM_SCHEDULER_ENABLE_MONITORS
argument_list|)
decl_stmt|;
name|CSQueue
name|parentQ
init|=
name|q
operator|.
name|getParent
argument_list|()
decl_stmt|;
comment|// If the system-wide preemption switch is turned off, all of the queues in
comment|// the qPath hierarchy have preemption disabled, so return true.
if|if
condition|(
operator|!
name|systemWidePreemption
condition|)
return|return
literal|true
return|;
comment|// If q is the root queue and the system-wide preemption switch is turned
comment|// on, then q does not have preemption disabled (default=false, below)
comment|// unless the preemption_disabled property is explicitly set.
if|if
condition|(
name|parentQ
operator|==
literal|null
condition|)
block|{
return|return
name|csConf
operator|.
name|getPreemptionDisabled
argument_list|(
name|q
operator|.
name|getQueuePath
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// If this is not the root queue, inherit the default value for the
comment|// preemption_disabled property from the parent. Preemptability will be
comment|// inherited from the parent's hierarchy unless explicitly overridden at
comment|// this level.
return|return
name|csConf
operator|.
name|getPreemptionDisabled
argument_list|(
name|q
operator|.
name|getQueuePath
argument_list|()
argument_list|,
name|parentQ
operator|.
name|getPreemptionDisabled
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getCurrentLimitResource (String nodePartition, Resource clusterResource, ResourceLimits currentResourceLimits, SchedulingMode schedulingMode)
specifier|private
name|Resource
name|getCurrentLimitResource
parameter_list|(
name|String
name|nodePartition
parameter_list|,
name|Resource
name|clusterResource
parameter_list|,
name|ResourceLimits
name|currentResourceLimits
parameter_list|,
name|SchedulingMode
name|schedulingMode
parameter_list|)
block|{
if|if
condition|(
name|schedulingMode
operator|==
name|SchedulingMode
operator|.
name|RESPECT_PARTITION_EXCLUSIVITY
condition|)
block|{
comment|/*        * Current limit resource: For labeled resource: limit = queue-max-resource        * (TODO, this part need update when we support labeled-limit) For        * non-labeled resource: limit = min(queue-max-resource,        * limit-set-by-parent)        */
name|Resource
name|queueMaxResource
init|=
name|Resources
operator|.
name|multiplyAndNormalizeDown
argument_list|(
name|resourceCalculator
argument_list|,
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|nodePartition
argument_list|,
name|clusterResource
argument_list|)
argument_list|,
name|queueCapacities
operator|.
name|getAbsoluteMaximumCapacity
argument_list|(
name|nodePartition
argument_list|)
argument_list|,
name|minimumAllocation
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodePartition
operator|.
name|equals
argument_list|(
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|)
condition|)
block|{
return|return
name|Resources
operator|.
name|min
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|queueMaxResource
argument_list|,
name|currentResourceLimits
operator|.
name|getLimit
argument_list|()
argument_list|)
return|;
block|}
return|return
name|queueMaxResource
return|;
block|}
elseif|else
if|if
condition|(
name|schedulingMode
operator|==
name|SchedulingMode
operator|.
name|IGNORE_PARTITION_EXCLUSIVITY
condition|)
block|{
comment|// When we doing non-exclusive resource allocation, maximum capacity of
comment|// all queues on this label equals to total resource with the label.
return|return
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|nodePartition
argument_list|,
name|clusterResource
argument_list|)
return|;
block|}
return|return
name|Resources
operator|.
name|none
argument_list|()
return|;
block|}
DECL|method|canAssignToThisQueue (Resource clusterResource, String nodePartition, ResourceLimits currentResourceLimits, Resource nowRequired, Resource resourceCouldBeUnreserved, SchedulingMode schedulingMode)
specifier|synchronized
name|boolean
name|canAssignToThisQueue
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|String
name|nodePartition
parameter_list|,
name|ResourceLimits
name|currentResourceLimits
parameter_list|,
name|Resource
name|nowRequired
parameter_list|,
name|Resource
name|resourceCouldBeUnreserved
parameter_list|,
name|SchedulingMode
name|schedulingMode
parameter_list|)
block|{
comment|// New total resource = used + required
name|Resource
name|newTotalResource
init|=
name|Resources
operator|.
name|add
argument_list|(
name|queueUsage
operator|.
name|getUsed
argument_list|(
name|nodePartition
argument_list|)
argument_list|,
name|nowRequired
argument_list|)
decl_stmt|;
comment|// Get current limited resource:
comment|// - When doing RESPECT_PARTITION_EXCLUSIVITY allocation, we will respect
comment|// queues' max capacity.
comment|// - When doing IGNORE_PARTITION_EXCLUSIVITY allocation, we will not respect
comment|// queue's max capacity, queue's max capacity on the partition will be
comment|// considered to be 100%. Which is a queue can use all resource in the
comment|// partition.
comment|// Doing this because: for non-exclusive allocation, we make sure there's
comment|// idle resource on the partition, to avoid wastage, such resource will be
comment|// leveraged as much as we can, and preemption policy will reclaim it back
comment|// when partitoned-resource-request comes back.
name|Resource
name|currentLimitResource
init|=
name|getCurrentLimitResource
argument_list|(
name|nodePartition
argument_list|,
name|clusterResource
argument_list|,
name|currentResourceLimits
argument_list|,
name|schedulingMode
argument_list|)
decl_stmt|;
comment|// if reservation continous looking enabled, check to see if could we
comment|// potentially use this node instead of a reserved node if the application
comment|// has reserved containers.
comment|// TODO, now only consider reservation cases when the node has no label
if|if
condition|(
name|this
operator|.
name|reservationsContinueLooking
operator|&&
name|nodePartition
operator|.
name|equals
argument_list|(
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|)
operator|&&
name|Resources
operator|.
name|greaterThan
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|resourceCouldBeUnreserved
argument_list|,
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
condition|)
block|{
comment|// resource-without-reserved = used - reserved
name|Resource
name|newTotalWithoutReservedResource
init|=
name|Resources
operator|.
name|subtract
argument_list|(
name|newTotalResource
argument_list|,
name|resourceCouldBeUnreserved
argument_list|)
decl_stmt|;
comment|// when total-used-without-reserved-resource< currentLimit, we still
comment|// have chance to allocate on this node by unreserving some containers
if|if
condition|(
name|Resources
operator|.
name|lessThan
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|newTotalWithoutReservedResource
argument_list|,
name|currentLimitResource
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"try to use reserved: "
operator|+
name|getQueueName
argument_list|()
operator|+
literal|" usedResources: "
operator|+
name|queueUsage
operator|.
name|getUsed
argument_list|()
operator|+
literal|", clusterResources: "
operator|+
name|clusterResource
operator|+
literal|", reservedResources: "
operator|+
name|resourceCouldBeUnreserved
operator|+
literal|", capacity-without-reserved: "
operator|+
name|newTotalWithoutReservedResource
operator|+
literal|", maxLimitCapacity: "
operator|+
name|currentLimitResource
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
comment|// Check if we over current-resource-limit computed.
if|if
condition|(
name|Resources
operator|.
name|greaterThan
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|newTotalResource
argument_list|,
name|currentLimitResource
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getQueueName
argument_list|()
operator|+
literal|"Check assign to queue, nodePartition="
operator|+
name|nodePartition
operator|+
literal|" usedResources: "
operator|+
name|queueUsage
operator|.
name|getUsed
argument_list|(
name|nodePartition
argument_list|)
operator|+
literal|" clusterResources: "
operator|+
name|clusterResource
operator|+
literal|" currentUsedCapacity "
operator|+
name|Resources
operator|.
name|divide
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|queueUsage
operator|.
name|getUsed
argument_list|(
name|nodePartition
argument_list|)
argument_list|,
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|nodePartition
argument_list|,
name|clusterResource
argument_list|)
argument_list|)
operator|+
literal|" max-capacity: "
operator|+
name|queueCapacities
operator|.
name|getAbsoluteMaximumCapacity
argument_list|(
name|nodePartition
argument_list|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|incPendingResource (String nodeLabel, Resource resourceToInc)
specifier|public
name|void
name|incPendingResource
parameter_list|(
name|String
name|nodeLabel
parameter_list|,
name|Resource
name|resourceToInc
parameter_list|)
block|{
if|if
condition|(
name|nodeLabel
operator|==
literal|null
condition|)
block|{
name|nodeLabel
operator|=
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
expr_stmt|;
block|}
comment|// ResourceUsage has its own lock, no addition lock needs here.
name|queueUsage
operator|.
name|incPending
argument_list|(
name|nodeLabel
argument_list|,
name|resourceToInc
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|parent
condition|)
block|{
name|parent
operator|.
name|incPendingResource
argument_list|(
name|nodeLabel
argument_list|,
name|resourceToInc
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|decPendingResource (String nodeLabel, Resource resourceToDec)
specifier|public
name|void
name|decPendingResource
parameter_list|(
name|String
name|nodeLabel
parameter_list|,
name|Resource
name|resourceToDec
parameter_list|)
block|{
if|if
condition|(
name|nodeLabel
operator|==
literal|null
condition|)
block|{
name|nodeLabel
operator|=
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
expr_stmt|;
block|}
comment|// ResourceUsage has its own lock, no addition lock needs here.
name|queueUsage
operator|.
name|decPending
argument_list|(
name|nodeLabel
argument_list|,
name|resourceToDec
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|parent
condition|)
block|{
name|parent
operator|.
name|decPendingResource
argument_list|(
name|nodeLabel
argument_list|,
name|resourceToDec
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Return if the queue has pending resource on given nodePartition and    * schedulingMode.     */
DECL|method|hasPendingResourceRequest (String nodePartition, Resource cluster, SchedulingMode schedulingMode)
name|boolean
name|hasPendingResourceRequest
parameter_list|(
name|String
name|nodePartition
parameter_list|,
name|Resource
name|cluster
parameter_list|,
name|SchedulingMode
name|schedulingMode
parameter_list|)
block|{
return|return
name|SchedulerUtils
operator|.
name|hasPendingResourceRequest
argument_list|(
name|resourceCalculator
argument_list|,
name|queueUsage
argument_list|,
name|nodePartition
argument_list|,
name|cluster
argument_list|,
name|schedulingMode
argument_list|)
return|;
block|}
DECL|method|accessibleToPartition (String nodePartition)
name|boolean
name|accessibleToPartition
parameter_list|(
name|String
name|nodePartition
parameter_list|)
block|{
comment|// if queue's label is *, it can access any node
if|if
condition|(
name|accessibleLabels
operator|!=
literal|null
operator|&&
name|accessibleLabels
operator|.
name|contains
argument_list|(
name|RMNodeLabelsManager
operator|.
name|ANY
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// any queue can access to a node without label
if|if
condition|(
name|nodePartition
operator|==
literal|null
operator|||
name|nodePartition
operator|.
name|equals
argument_list|(
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// a queue can access to a node only if it contains any label of the node
if|if
condition|(
name|accessibleLabels
operator|!=
literal|null
operator|&&
name|accessibleLabels
operator|.
name|contains
argument_list|(
name|nodePartition
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// sorry, you cannot access
return|return
literal|false
return|;
block|}
block|}
end_class

end_unit

