begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|Private
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|AccessControlList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Priority
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|factories
operator|.
name|RecordFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|factory
operator|.
name|providers
operator|.
name|RecordFactoryProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|security
operator|.
name|AccessRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|security
operator|.
name|AccessType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|security
operator|.
name|PrivilegedEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|security
operator|.
name|PrivilegedEntity
operator|.
name|EntityType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|security
operator|.
name|YarnAuthorizationProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|nodelabels
operator|.
name|RMNodeLabelsManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|activities
operator|.
name|ActivitiesManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|ResourceLimits
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|ResourceUsage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|SchedulerApplicationAttempt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|SchedulerUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|ContainerAllocationProposal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|ResourceCommitRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|SchedulerContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|fica
operator|.
name|FiCaSchedulerApp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|fica
operator|.
name|FiCaSchedulerNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|placement
operator|.
name|SimplePlacementSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|ResourceCalculator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|Resources
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_class
DECL|class|AbstractCSQueue
specifier|public
specifier|abstract
class|class
name|AbstractCSQueue
implements|implements
name|CSQueue
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|AbstractCSQueue
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|parent
specifier|volatile
name|CSQueue
name|parent
decl_stmt|;
DECL|field|queueName
specifier|final
name|String
name|queueName
decl_stmt|;
DECL|field|numContainers
specifier|volatile
name|int
name|numContainers
decl_stmt|;
DECL|field|minimumAllocation
specifier|final
name|Resource
name|minimumAllocation
decl_stmt|;
DECL|field|maximumAllocation
specifier|volatile
name|Resource
name|maximumAllocation
decl_stmt|;
DECL|field|state
specifier|volatile
name|QueueState
name|state
decl_stmt|;
DECL|field|metrics
specifier|final
name|CSQueueMetrics
name|metrics
decl_stmt|;
DECL|field|queueEntity
specifier|protected
specifier|final
name|PrivilegedEntity
name|queueEntity
decl_stmt|;
DECL|field|resourceCalculator
specifier|final
name|ResourceCalculator
name|resourceCalculator
decl_stmt|;
DECL|field|accessibleLabels
name|Set
argument_list|<
name|String
argument_list|>
name|accessibleLabels
decl_stmt|;
DECL|field|labelManager
specifier|final
name|RMNodeLabelsManager
name|labelManager
decl_stmt|;
DECL|field|defaultLabelExpression
name|String
name|defaultLabelExpression
decl_stmt|;
DECL|field|acls
name|Map
argument_list|<
name|AccessType
argument_list|,
name|AccessControlList
argument_list|>
name|acls
init|=
operator|new
name|HashMap
argument_list|<
name|AccessType
argument_list|,
name|AccessControlList
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|reservationsContinueLooking
specifier|volatile
name|boolean
name|reservationsContinueLooking
decl_stmt|;
DECL|field|preemptionDisabled
specifier|private
specifier|volatile
name|boolean
name|preemptionDisabled
decl_stmt|;
comment|// Track resource usage-by-label like used-resource/pending-resource, etc.
DECL|field|queueUsage
specifier|volatile
name|ResourceUsage
name|queueUsage
decl_stmt|;
comment|// Track capacities like used-capcity/abs-used-capacity/capacity/abs-capacity,
comment|// etc.
DECL|field|queueCapacities
name|QueueCapacities
name|queueCapacities
decl_stmt|;
DECL|field|recordFactory
specifier|private
specifier|final
name|RecordFactory
name|recordFactory
init|=
name|RecordFactoryProvider
operator|.
name|getRecordFactory
argument_list|(
literal|null
argument_list|)
decl_stmt|;
DECL|field|csContext
specifier|protected
name|CapacitySchedulerContext
name|csContext
decl_stmt|;
DECL|field|authorizer
specifier|protected
name|YarnAuthorizationProvider
name|authorizer
init|=
literal|null
decl_stmt|;
DECL|field|activitiesManager
specifier|protected
name|ActivitiesManager
name|activitiesManager
decl_stmt|;
DECL|field|readLock
specifier|protected
name|ReentrantReadWriteLock
operator|.
name|ReadLock
name|readLock
decl_stmt|;
DECL|field|writeLock
specifier|protected
name|ReentrantReadWriteLock
operator|.
name|WriteLock
name|writeLock
decl_stmt|;
DECL|method|AbstractCSQueue (CapacitySchedulerContext cs, String queueName, CSQueue parent, CSQueue old)
specifier|public
name|AbstractCSQueue
parameter_list|(
name|CapacitySchedulerContext
name|cs
parameter_list|,
name|String
name|queueName
parameter_list|,
name|CSQueue
name|parent
parameter_list|,
name|CSQueue
name|old
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|labelManager
operator|=
name|cs
operator|.
name|getRMContext
argument_list|()
operator|.
name|getNodeLabelManager
argument_list|()
expr_stmt|;
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
name|this
operator|.
name|queueName
operator|=
name|queueName
expr_stmt|;
name|this
operator|.
name|resourceCalculator
operator|=
name|cs
operator|.
name|getResourceCalculator
argument_list|()
expr_stmt|;
name|this
operator|.
name|activitiesManager
operator|=
name|cs
operator|.
name|getActivitiesManager
argument_list|()
expr_stmt|;
comment|// must be called after parent and queueName is set
name|this
operator|.
name|metrics
operator|=
name|old
operator|!=
literal|null
condition|?
operator|(
name|CSQueueMetrics
operator|)
name|old
operator|.
name|getMetrics
argument_list|()
else|:
name|CSQueueMetrics
operator|.
name|forQueue
argument_list|(
name|getQueuePath
argument_list|()
argument_list|,
name|parent
argument_list|,
name|cs
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getEnableUserMetrics
argument_list|()
argument_list|,
name|cs
operator|.
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|csContext
operator|=
name|cs
expr_stmt|;
name|this
operator|.
name|minimumAllocation
operator|=
name|csContext
operator|.
name|getMinimumResourceCapability
argument_list|()
expr_stmt|;
comment|// initialize ResourceUsage
name|queueUsage
operator|=
operator|new
name|ResourceUsage
argument_list|()
expr_stmt|;
name|queueEntity
operator|=
operator|new
name|PrivilegedEntity
argument_list|(
name|EntityType
operator|.
name|QUEUE
argument_list|,
name|getQueuePath
argument_list|()
argument_list|)
expr_stmt|;
comment|// initialize QueueCapacities
name|queueCapacities
operator|=
operator|new
name|QueueCapacities
argument_list|(
name|parent
operator|==
literal|null
argument_list|)
expr_stmt|;
name|ReentrantReadWriteLock
name|lock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
name|readLock
operator|=
name|lock
operator|.
name|readLock
argument_list|()
expr_stmt|;
name|writeLock
operator|=
name|lock
operator|.
name|writeLock
argument_list|()
expr_stmt|;
block|}
DECL|method|setupConfigurableCapacities ()
specifier|protected
name|void
name|setupConfigurableCapacities
parameter_list|()
block|{
name|CSQueueUtils
operator|.
name|loadUpdateAndCheckCapacities
argument_list|(
name|getQueuePath
argument_list|()
argument_list|,
name|csContext
operator|.
name|getConfiguration
argument_list|()
argument_list|,
name|queueCapacities
argument_list|,
name|parent
operator|==
literal|null
condition|?
literal|null
else|:
name|parent
operator|.
name|getQueueCapacities
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getCapacity ()
specifier|public
name|float
name|getCapacity
parameter_list|()
block|{
return|return
name|queueCapacities
operator|.
name|getCapacity
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getAbsoluteCapacity ()
specifier|public
name|float
name|getAbsoluteCapacity
parameter_list|()
block|{
return|return
name|queueCapacities
operator|.
name|getAbsoluteCapacity
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getAbsoluteMaximumCapacity ()
specifier|public
name|float
name|getAbsoluteMaximumCapacity
parameter_list|()
block|{
return|return
name|queueCapacities
operator|.
name|getAbsoluteMaximumCapacity
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getAbsoluteUsedCapacity ()
specifier|public
name|float
name|getAbsoluteUsedCapacity
parameter_list|()
block|{
return|return
name|queueCapacities
operator|.
name|getAbsoluteUsedCapacity
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getMaximumCapacity ()
specifier|public
name|float
name|getMaximumCapacity
parameter_list|()
block|{
return|return
name|queueCapacities
operator|.
name|getMaximumCapacity
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getUsedCapacity ()
specifier|public
name|float
name|getUsedCapacity
parameter_list|()
block|{
return|return
name|queueCapacities
operator|.
name|getUsedCapacity
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getUsedResources ()
specifier|public
name|Resource
name|getUsedResources
parameter_list|()
block|{
return|return
name|queueUsage
operator|.
name|getUsed
argument_list|()
return|;
block|}
DECL|method|getNumContainers ()
specifier|public
name|int
name|getNumContainers
parameter_list|()
block|{
return|return
name|numContainers
return|;
block|}
annotation|@
name|Override
DECL|method|getState ()
specifier|public
name|QueueState
name|getState
parameter_list|()
block|{
return|return
name|state
return|;
block|}
annotation|@
name|Override
DECL|method|getMetrics ()
specifier|public
name|CSQueueMetrics
name|getMetrics
parameter_list|()
block|{
return|return
name|metrics
return|;
block|}
annotation|@
name|Override
DECL|method|getQueueName ()
specifier|public
name|String
name|getQueueName
parameter_list|()
block|{
return|return
name|queueName
return|;
block|}
annotation|@
name|Override
DECL|method|getPrivilegedEntity ()
specifier|public
name|PrivilegedEntity
name|getPrivilegedEntity
parameter_list|()
block|{
return|return
name|queueEntity
return|;
block|}
annotation|@
name|Override
DECL|method|getParent ()
specifier|public
name|CSQueue
name|getParent
parameter_list|()
block|{
return|return
name|parent
return|;
block|}
annotation|@
name|Override
DECL|method|setParent (CSQueue newParentQueue)
specifier|public
name|void
name|setParent
parameter_list|(
name|CSQueue
name|newParentQueue
parameter_list|)
block|{
name|this
operator|.
name|parent
operator|=
name|newParentQueue
expr_stmt|;
block|}
DECL|method|getAccessibleNodeLabels ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getAccessibleNodeLabels
parameter_list|()
block|{
return|return
name|accessibleLabels
return|;
block|}
annotation|@
name|Override
DECL|method|hasAccess (QueueACL acl, UserGroupInformation user)
specifier|public
name|boolean
name|hasAccess
parameter_list|(
name|QueueACL
name|acl
parameter_list|,
name|UserGroupInformation
name|user
parameter_list|)
block|{
return|return
name|authorizer
operator|.
name|checkPermission
argument_list|(
operator|new
name|AccessRequest
argument_list|(
name|queueEntity
argument_list|,
name|user
argument_list|,
name|SchedulerUtils
operator|.
name|toAccessType
argument_list|(
name|acl
argument_list|)
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|Server
operator|.
name|getRemoteAddress
argument_list|()
argument_list|,
literal|null
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setUsedCapacity (float usedCapacity)
specifier|public
name|void
name|setUsedCapacity
parameter_list|(
name|float
name|usedCapacity
parameter_list|)
block|{
name|queueCapacities
operator|.
name|setUsedCapacity
argument_list|(
name|usedCapacity
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setAbsoluteUsedCapacity (float absUsedCapacity)
specifier|public
name|void
name|setAbsoluteUsedCapacity
parameter_list|(
name|float
name|absUsedCapacity
parameter_list|)
block|{
name|queueCapacities
operator|.
name|setAbsoluteUsedCapacity
argument_list|(
name|absUsedCapacity
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set maximum capacity - used only for testing.    * @param maximumCapacity new max capacity    */
DECL|method|setMaxCapacity (float maximumCapacity)
name|void
name|setMaxCapacity
parameter_list|(
name|float
name|maximumCapacity
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// Sanity check
name|CSQueueUtils
operator|.
name|checkMaxCapacity
argument_list|(
name|getQueueName
argument_list|()
argument_list|,
name|queueCapacities
operator|.
name|getCapacity
argument_list|()
argument_list|,
name|maximumCapacity
argument_list|)
expr_stmt|;
name|float
name|absMaxCapacity
init|=
name|CSQueueUtils
operator|.
name|computeAbsoluteMaximumCapacity
argument_list|(
name|maximumCapacity
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|CSQueueUtils
operator|.
name|checkAbsoluteCapacity
argument_list|(
name|getQueueName
argument_list|()
argument_list|,
name|queueCapacities
operator|.
name|getAbsoluteCapacity
argument_list|()
argument_list|,
name|absMaxCapacity
argument_list|)
expr_stmt|;
name|queueCapacities
operator|.
name|setMaximumCapacity
argument_list|(
name|maximumCapacity
argument_list|)
expr_stmt|;
name|queueCapacities
operator|.
name|setAbsoluteMaximumCapacity
argument_list|(
name|absMaxCapacity
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getDefaultNodeLabelExpression ()
specifier|public
name|String
name|getDefaultNodeLabelExpression
parameter_list|()
block|{
return|return
name|defaultLabelExpression
return|;
block|}
DECL|method|setupQueueConfigs (Resource clusterResource)
name|void
name|setupQueueConfigs
parameter_list|(
name|Resource
name|clusterResource
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// get labels
name|this
operator|.
name|accessibleLabels
operator|=
name|csContext
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getAccessibleNodeLabels
argument_list|(
name|getQueuePath
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|defaultLabelExpression
operator|=
name|csContext
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getDefaultNodeLabelExpression
argument_list|(
name|getQueuePath
argument_list|()
argument_list|)
expr_stmt|;
comment|// inherit from parent if labels not set
if|if
condition|(
name|this
operator|.
name|accessibleLabels
operator|==
literal|null
operator|&&
name|parent
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|accessibleLabels
operator|=
name|parent
operator|.
name|getAccessibleNodeLabels
argument_list|()
expr_stmt|;
block|}
comment|// inherit from parent if labels not set
if|if
condition|(
name|this
operator|.
name|defaultLabelExpression
operator|==
literal|null
operator|&&
name|parent
operator|!=
literal|null
operator|&&
name|this
operator|.
name|accessibleLabels
operator|.
name|containsAll
argument_list|(
name|parent
operator|.
name|getAccessibleNodeLabels
argument_list|()
argument_list|)
condition|)
block|{
name|this
operator|.
name|defaultLabelExpression
operator|=
name|parent
operator|.
name|getDefaultNodeLabelExpression
argument_list|()
expr_stmt|;
block|}
comment|// After we setup labels, we can setup capacities
name|setupConfigurableCapacities
argument_list|()
expr_stmt|;
name|this
operator|.
name|maximumAllocation
operator|=
name|csContext
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getMaximumAllocationPerQueue
argument_list|(
name|getQueuePath
argument_list|()
argument_list|)
expr_stmt|;
name|authorizer
operator|=
name|YarnAuthorizationProvider
operator|.
name|getInstance
argument_list|(
name|csContext
operator|.
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
name|initializeQueueState
argument_list|()
expr_stmt|;
name|this
operator|.
name|acls
operator|=
name|csContext
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getAcls
argument_list|(
name|getQueuePath
argument_list|()
argument_list|)
expr_stmt|;
comment|// Update metrics
name|CSQueueUtils
operator|.
name|updateQueueStatistics
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|minimumAllocation
argument_list|,
name|this
argument_list|,
name|labelManager
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// Check if labels of this queue is a subset of parent queue, only do this
comment|// when we not root
if|if
condition|(
name|parent
operator|!=
literal|null
operator|&&
name|parent
operator|.
name|getParent
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|parent
operator|.
name|getAccessibleNodeLabels
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|parent
operator|.
name|getAccessibleNodeLabels
argument_list|()
operator|.
name|contains
argument_list|(
name|RMNodeLabelsManager
operator|.
name|ANY
argument_list|)
condition|)
block|{
comment|// if parent isn't "*", child shouldn't be "*" too
if|if
condition|(
name|this
operator|.
name|getAccessibleNodeLabels
argument_list|()
operator|.
name|contains
argument_list|(
name|RMNodeLabelsManager
operator|.
name|ANY
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Parent's accessible queue is not ANY(*), "
operator|+
literal|"but child's accessible queue is *"
argument_list|)
throw|;
block|}
else|else
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|diff
init|=
name|Sets
operator|.
name|difference
argument_list|(
name|this
operator|.
name|getAccessibleNodeLabels
argument_list|()
argument_list|,
name|parent
operator|.
name|getAccessibleNodeLabels
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|diff
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Some labels of child queue is not a subset "
operator|+
literal|"of parent queue, these labels=["
operator|+
name|StringUtils
operator|.
name|join
argument_list|(
name|diff
argument_list|,
literal|","
argument_list|)
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
name|this
operator|.
name|reservationsContinueLooking
operator|=
name|csContext
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getReservationContinueLook
argument_list|()
expr_stmt|;
name|this
operator|.
name|preemptionDisabled
operator|=
name|isQueueHierarchyPreemptionDisabled
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|initializeQueueState ()
specifier|private
name|void
name|initializeQueueState
parameter_list|()
block|{
comment|// inherit from parent if state not set, only do this when we are not root
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|QueueState
name|configuredState
init|=
name|csContext
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getConfiguredState
argument_list|(
name|getQueuePath
argument_list|()
argument_list|)
decl_stmt|;
name|QueueState
name|parentState
init|=
name|parent
operator|.
name|getState
argument_list|()
decl_stmt|;
if|if
condition|(
name|configuredState
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|state
operator|=
name|parentState
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|configuredState
operator|==
name|QueueState
operator|.
name|RUNNING
operator|&&
name|parentState
operator|==
name|QueueState
operator|.
name|STOPPED
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The parent queue:"
operator|+
name|parent
operator|.
name|getQueueName
argument_list|()
operator|+
literal|" state is STOPPED, "
operator|+
literal|"child queue:"
operator|+
name|queueName
operator|+
literal|" state cannot be RUNNING."
argument_list|)
throw|;
block|}
else|else
block|{
name|this
operator|.
name|state
operator|=
name|configuredState
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// if this is the root queue, get the state from the configuration.
comment|// if the state is not set, use RUNNING as default state.
name|this
operator|.
name|state
operator|=
name|csContext
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getState
argument_list|(
name|getQueuePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getQueueInfo ()
specifier|protected
name|QueueInfo
name|getQueueInfo
parameter_list|()
block|{
comment|// Deliberately doesn't use lock here, because this method will be invoked
comment|// from schedulerApplicationAttempt, to avoid deadlock, sacrifice
comment|// consistency here.
comment|// TODO, improve this
name|QueueInfo
name|queueInfo
init|=
name|recordFactory
operator|.
name|newRecordInstance
argument_list|(
name|QueueInfo
operator|.
name|class
argument_list|)
decl_stmt|;
name|queueInfo
operator|.
name|setQueueName
argument_list|(
name|queueName
argument_list|)
expr_stmt|;
name|queueInfo
operator|.
name|setAccessibleNodeLabels
argument_list|(
name|accessibleLabels
argument_list|)
expr_stmt|;
name|queueInfo
operator|.
name|setCapacity
argument_list|(
name|queueCapacities
operator|.
name|getCapacity
argument_list|()
argument_list|)
expr_stmt|;
name|queueInfo
operator|.
name|setMaximumCapacity
argument_list|(
name|queueCapacities
operator|.
name|getMaximumCapacity
argument_list|()
argument_list|)
expr_stmt|;
name|queueInfo
operator|.
name|setQueueState
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|queueInfo
operator|.
name|setDefaultNodeLabelExpression
argument_list|(
name|defaultLabelExpression
argument_list|)
expr_stmt|;
name|queueInfo
operator|.
name|setCurrentCapacity
argument_list|(
name|getUsedCapacity
argument_list|()
argument_list|)
expr_stmt|;
name|queueInfo
operator|.
name|setQueueStatistics
argument_list|(
name|getQueueStatistics
argument_list|()
argument_list|)
expr_stmt|;
name|queueInfo
operator|.
name|setPreemptionDisabled
argument_list|(
name|preemptionDisabled
argument_list|)
expr_stmt|;
return|return
name|queueInfo
return|;
block|}
DECL|method|getQueueStatistics ()
specifier|public
name|QueueStatistics
name|getQueueStatistics
parameter_list|()
block|{
comment|// Deliberately doesn't use lock here, because this method will be invoked
comment|// from schedulerApplicationAttempt, to avoid deadlock, sacrifice
comment|// consistency here.
comment|// TODO, improve this
name|QueueStatistics
name|stats
init|=
name|recordFactory
operator|.
name|newRecordInstance
argument_list|(
name|QueueStatistics
operator|.
name|class
argument_list|)
decl_stmt|;
name|stats
operator|.
name|setNumAppsSubmitted
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getAppsSubmitted
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setNumAppsRunning
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getAppsRunning
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setNumAppsPending
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getAppsPending
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setNumAppsCompleted
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getAppsCompleted
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setNumAppsKilled
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getAppsKilled
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setNumAppsFailed
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getAppsFailed
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setNumActiveUsers
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getActiveUsers
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setAvailableMemoryMB
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getAvailableMB
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setAllocatedMemoryMB
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getAllocatedMB
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setPendingMemoryMB
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getPendingMB
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setReservedMemoryMB
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getReservedMB
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setAvailableVCores
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getAvailableVirtualCores
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setAllocatedVCores
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getAllocatedVirtualCores
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setPendingVCores
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getPendingVirtualCores
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setReservedVCores
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getReservedVirtualCores
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setPendingContainers
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getPendingContainers
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setAllocatedContainers
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getAllocatedContainers
argument_list|()
argument_list|)
expr_stmt|;
name|stats
operator|.
name|setReservedContainers
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getReservedContainers
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|stats
return|;
block|}
annotation|@
name|Private
DECL|method|getMaximumAllocation ()
specifier|public
name|Resource
name|getMaximumAllocation
parameter_list|()
block|{
return|return
name|maximumAllocation
return|;
block|}
annotation|@
name|Private
DECL|method|getMinimumAllocation ()
specifier|public
name|Resource
name|getMinimumAllocation
parameter_list|()
block|{
return|return
name|minimumAllocation
return|;
block|}
DECL|method|allocateResource (Resource clusterResource, Resource resource, String nodePartition, boolean changeContainerResource)
name|void
name|allocateResource
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|Resource
name|resource
parameter_list|,
name|String
name|nodePartition
parameter_list|,
name|boolean
name|changeContainerResource
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|queueUsage
operator|.
name|incUsed
argument_list|(
name|nodePartition
argument_list|,
name|resource
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|changeContainerResource
condition|)
block|{
operator|++
name|numContainers
expr_stmt|;
block|}
name|CSQueueUtils
operator|.
name|updateQueueStatistics
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|minimumAllocation
argument_list|,
name|this
argument_list|,
name|labelManager
argument_list|,
name|nodePartition
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|releaseResource (Resource clusterResource, Resource resource, String nodePartition, boolean changeContainerResource)
specifier|protected
name|void
name|releaseResource
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|Resource
name|resource
parameter_list|,
name|String
name|nodePartition
parameter_list|,
name|boolean
name|changeContainerResource
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|queueUsage
operator|.
name|decUsed
argument_list|(
name|nodePartition
argument_list|,
name|resource
argument_list|)
expr_stmt|;
name|CSQueueUtils
operator|.
name|updateQueueStatistics
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|minimumAllocation
argument_list|,
name|this
argument_list|,
name|labelManager
argument_list|,
name|nodePartition
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|changeContainerResource
condition|)
block|{
operator|--
name|numContainers
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Private
DECL|method|getReservationContinueLooking ()
specifier|public
name|boolean
name|getReservationContinueLooking
parameter_list|()
block|{
return|return
name|reservationsContinueLooking
return|;
block|}
annotation|@
name|Private
DECL|method|getACLs ()
specifier|public
name|Map
argument_list|<
name|AccessType
argument_list|,
name|AccessControlList
argument_list|>
name|getACLs
parameter_list|()
block|{
try|try
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
return|return
name|acls
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Private
DECL|method|getPreemptionDisabled ()
specifier|public
name|boolean
name|getPreemptionDisabled
parameter_list|()
block|{
return|return
name|preemptionDisabled
return|;
block|}
annotation|@
name|Private
DECL|method|getQueueCapacities ()
specifier|public
name|QueueCapacities
name|getQueueCapacities
parameter_list|()
block|{
return|return
name|queueCapacities
return|;
block|}
annotation|@
name|Private
DECL|method|getQueueResourceUsage ()
specifier|public
name|ResourceUsage
name|getQueueResourceUsage
parameter_list|()
block|{
return|return
name|queueUsage
return|;
block|}
annotation|@
name|Override
DECL|method|getReadLock ()
specifier|public
name|ReentrantReadWriteLock
operator|.
name|ReadLock
name|getReadLock
parameter_list|()
block|{
return|return
name|readLock
return|;
block|}
comment|/**    * The specified queue is preemptable if system-wide preemption is turned on    * unless any queue in the<em>qPath</em> hierarchy has explicitly turned    * preemption off.    * NOTE: Preemptability is inherited from a queue's parent.    *     * @return true if queue has preemption disabled, false otherwise    */
DECL|method|isQueueHierarchyPreemptionDisabled (CSQueue q)
specifier|private
name|boolean
name|isQueueHierarchyPreemptionDisabled
parameter_list|(
name|CSQueue
name|q
parameter_list|)
block|{
name|CapacitySchedulerConfiguration
name|csConf
init|=
name|csContext
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|boolean
name|systemWidePreemption
init|=
name|csConf
operator|.
name|getBoolean
argument_list|(
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_ENABLE_MONITORS
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_RM_SCHEDULER_ENABLE_MONITORS
argument_list|)
decl_stmt|;
name|CSQueue
name|parentQ
init|=
name|q
operator|.
name|getParent
argument_list|()
decl_stmt|;
comment|// If the system-wide preemption switch is turned off, all of the queues in
comment|// the qPath hierarchy have preemption disabled, so return true.
if|if
condition|(
operator|!
name|systemWidePreemption
condition|)
return|return
literal|true
return|;
comment|// If q is the root queue and the system-wide preemption switch is turned
comment|// on, then q does not have preemption disabled (default=false, below)
comment|// unless the preemption_disabled property is explicitly set.
if|if
condition|(
name|parentQ
operator|==
literal|null
condition|)
block|{
return|return
name|csConf
operator|.
name|getPreemptionDisabled
argument_list|(
name|q
operator|.
name|getQueuePath
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|// If this is not the root queue, inherit the default value for the
comment|// preemption_disabled property from the parent. Preemptability will be
comment|// inherited from the parent's hierarchy unless explicitly overridden at
comment|// this level.
return|return
name|csConf
operator|.
name|getPreemptionDisabled
argument_list|(
name|q
operator|.
name|getQueuePath
argument_list|()
argument_list|,
name|parentQ
operator|.
name|getPreemptionDisabled
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getCurrentLimitResource (String nodePartition, Resource clusterResource, ResourceLimits currentResourceLimits, SchedulingMode schedulingMode)
specifier|private
name|Resource
name|getCurrentLimitResource
parameter_list|(
name|String
name|nodePartition
parameter_list|,
name|Resource
name|clusterResource
parameter_list|,
name|ResourceLimits
name|currentResourceLimits
parameter_list|,
name|SchedulingMode
name|schedulingMode
parameter_list|)
block|{
if|if
condition|(
name|schedulingMode
operator|==
name|SchedulingMode
operator|.
name|RESPECT_PARTITION_EXCLUSIVITY
condition|)
block|{
comment|/*        * Current limit resource: For labeled resource: limit = queue-max-resource        * (TODO, this part need update when we support labeled-limit) For        * non-labeled resource: limit = min(queue-max-resource,        * limit-set-by-parent)        */
name|Resource
name|queueMaxResource
init|=
name|getQueueMaxResource
argument_list|(
name|nodePartition
argument_list|,
name|clusterResource
argument_list|)
decl_stmt|;
return|return
name|Resources
operator|.
name|min
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|queueMaxResource
argument_list|,
name|currentResourceLimits
operator|.
name|getLimit
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|schedulingMode
operator|==
name|SchedulingMode
operator|.
name|IGNORE_PARTITION_EXCLUSIVITY
condition|)
block|{
comment|// When we doing non-exclusive resource allocation, maximum capacity of
comment|// all queues on this label equals to total resource with the label.
return|return
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|nodePartition
argument_list|,
name|clusterResource
argument_list|)
return|;
block|}
return|return
name|Resources
operator|.
name|none
argument_list|()
return|;
block|}
DECL|method|getQueueMaxResource (String nodePartition, Resource clusterResource)
name|Resource
name|getQueueMaxResource
parameter_list|(
name|String
name|nodePartition
parameter_list|,
name|Resource
name|clusterResource
parameter_list|)
block|{
return|return
name|Resources
operator|.
name|multiplyAndNormalizeDown
argument_list|(
name|resourceCalculator
argument_list|,
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|nodePartition
argument_list|,
name|clusterResource
argument_list|)
argument_list|,
name|queueCapacities
operator|.
name|getAbsoluteMaximumCapacity
argument_list|(
name|nodePartition
argument_list|)
argument_list|,
name|minimumAllocation
argument_list|)
return|;
block|}
DECL|method|canAssignToThisQueue (Resource clusterResource, String nodePartition, ResourceLimits currentResourceLimits, Resource resourceCouldBeUnreserved, SchedulingMode schedulingMode)
name|boolean
name|canAssignToThisQueue
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|String
name|nodePartition
parameter_list|,
name|ResourceLimits
name|currentResourceLimits
parameter_list|,
name|Resource
name|resourceCouldBeUnreserved
parameter_list|,
name|SchedulingMode
name|schedulingMode
parameter_list|)
block|{
try|try
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// Get current limited resource:
comment|// - When doing RESPECT_PARTITION_EXCLUSIVITY allocation, we will respect
comment|// queues' max capacity.
comment|// - When doing IGNORE_PARTITION_EXCLUSIVITY allocation, we will not respect
comment|// queue's max capacity, queue's max capacity on the partition will be
comment|// considered to be 100%. Which is a queue can use all resource in the
comment|// partition.
comment|// Doing this because: for non-exclusive allocation, we make sure there's
comment|// idle resource on the partition, to avoid wastage, such resource will be
comment|// leveraged as much as we can, and preemption policy will reclaim it back
comment|// when partitoned-resource-request comes back.
name|Resource
name|currentLimitResource
init|=
name|getCurrentLimitResource
argument_list|(
name|nodePartition
argument_list|,
name|clusterResource
argument_list|,
name|currentResourceLimits
argument_list|,
name|schedulingMode
argument_list|)
decl_stmt|;
name|Resource
name|nowTotalUsed
init|=
name|queueUsage
operator|.
name|getUsed
argument_list|(
name|nodePartition
argument_list|)
decl_stmt|;
comment|// Set headroom for currentResourceLimits:
comment|// When queue is a parent queue: Headroom = limit - used + killable
comment|// When queue is a leaf queue: Headroom = limit - used (leaf queue cannot preempt itself)
name|Resource
name|usedExceptKillable
init|=
name|nowTotalUsed
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|getChildQueues
argument_list|()
operator|&&
operator|!
name|getChildQueues
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|usedExceptKillable
operator|=
name|Resources
operator|.
name|subtract
argument_list|(
name|nowTotalUsed
argument_list|,
name|getTotalKillableResource
argument_list|(
name|nodePartition
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|currentResourceLimits
operator|.
name|setHeadroom
argument_list|(
name|Resources
operator|.
name|subtract
argument_list|(
name|currentLimitResource
argument_list|,
name|usedExceptKillable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Resources
operator|.
name|greaterThanOrEqual
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|usedExceptKillable
argument_list|,
name|currentLimitResource
argument_list|)
condition|)
block|{
comment|// if reservation continous looking enabled, check to see if could we
comment|// potentially use this node instead of a reserved node if the application
comment|// has reserved containers.
comment|// TODO, now only consider reservation cases when the node has no label
if|if
condition|(
name|this
operator|.
name|reservationsContinueLooking
operator|&&
name|nodePartition
operator|.
name|equals
argument_list|(
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|)
operator|&&
name|Resources
operator|.
name|greaterThan
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|resourceCouldBeUnreserved
argument_list|,
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
condition|)
block|{
comment|// resource-without-reserved = used - reserved
name|Resource
name|newTotalWithoutReservedResource
init|=
name|Resources
operator|.
name|subtract
argument_list|(
name|usedExceptKillable
argument_list|,
name|resourceCouldBeUnreserved
argument_list|)
decl_stmt|;
comment|// when total-used-without-reserved-resource< currentLimit, we still
comment|// have chance to allocate on this node by unreserving some containers
if|if
condition|(
name|Resources
operator|.
name|lessThan
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|newTotalWithoutReservedResource
argument_list|,
name|currentLimitResource
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"try to use reserved: "
operator|+
name|getQueueName
argument_list|()
operator|+
literal|" usedResources: "
operator|+
name|queueUsage
operator|.
name|getUsed
argument_list|()
operator|+
literal|", clusterResources: "
operator|+
name|clusterResource
operator|+
literal|", reservedResources: "
operator|+
name|resourceCouldBeUnreserved
operator|+
literal|", capacity-without-reserved: "
operator|+
name|newTotalWithoutReservedResource
operator|+
literal|", maxLimitCapacity: "
operator|+
name|currentLimitResource
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getQueueName
argument_list|()
operator|+
literal|"Check assign to queue, nodePartition="
operator|+
name|nodePartition
operator|+
literal|" usedResources: "
operator|+
name|queueUsage
operator|.
name|getUsed
argument_list|(
name|nodePartition
argument_list|)
operator|+
literal|" clusterResources: "
operator|+
name|clusterResource
operator|+
literal|" currentUsedCapacity "
operator|+
name|Resources
operator|.
name|divide
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|queueUsage
operator|.
name|getUsed
argument_list|(
name|nodePartition
argument_list|)
argument_list|,
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|nodePartition
argument_list|,
name|clusterResource
argument_list|)
argument_list|)
operator|+
literal|" max-capacity: "
operator|+
name|queueCapacities
operator|.
name|getAbsoluteMaximumCapacity
argument_list|(
name|nodePartition
argument_list|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|incReservedResource (String partition, Resource reservedRes)
specifier|public
name|void
name|incReservedResource
parameter_list|(
name|String
name|partition
parameter_list|,
name|Resource
name|reservedRes
parameter_list|)
block|{
if|if
condition|(
name|partition
operator|==
literal|null
condition|)
block|{
name|partition
operator|=
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
expr_stmt|;
block|}
name|queueUsage
operator|.
name|incReserved
argument_list|(
name|partition
argument_list|,
name|reservedRes
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|parent
condition|)
block|{
name|parent
operator|.
name|incReservedResource
argument_list|(
name|partition
argument_list|,
name|reservedRes
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|decReservedResource (String partition, Resource reservedRes)
specifier|public
name|void
name|decReservedResource
parameter_list|(
name|String
name|partition
parameter_list|,
name|Resource
name|reservedRes
parameter_list|)
block|{
if|if
condition|(
name|partition
operator|==
literal|null
condition|)
block|{
name|partition
operator|=
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
expr_stmt|;
block|}
name|queueUsage
operator|.
name|decReserved
argument_list|(
name|partition
argument_list|,
name|reservedRes
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|parent
condition|)
block|{
name|parent
operator|.
name|decReservedResource
argument_list|(
name|partition
argument_list|,
name|reservedRes
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|incPendingResource (String nodeLabel, Resource resourceToInc)
specifier|public
name|void
name|incPendingResource
parameter_list|(
name|String
name|nodeLabel
parameter_list|,
name|Resource
name|resourceToInc
parameter_list|)
block|{
if|if
condition|(
name|nodeLabel
operator|==
literal|null
condition|)
block|{
name|nodeLabel
operator|=
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
expr_stmt|;
block|}
comment|// ResourceUsage has its own lock, no addition lock needs here.
name|queueUsage
operator|.
name|incPending
argument_list|(
name|nodeLabel
argument_list|,
name|resourceToInc
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|parent
condition|)
block|{
name|parent
operator|.
name|incPendingResource
argument_list|(
name|nodeLabel
argument_list|,
name|resourceToInc
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|decPendingResource (String nodeLabel, Resource resourceToDec)
specifier|public
name|void
name|decPendingResource
parameter_list|(
name|String
name|nodeLabel
parameter_list|,
name|Resource
name|resourceToDec
parameter_list|)
block|{
if|if
condition|(
name|nodeLabel
operator|==
literal|null
condition|)
block|{
name|nodeLabel
operator|=
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
expr_stmt|;
block|}
comment|// ResourceUsage has its own lock, no addition lock needs here.
name|queueUsage
operator|.
name|decPending
argument_list|(
name|nodeLabel
argument_list|,
name|resourceToDec
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|parent
condition|)
block|{
name|parent
operator|.
name|decPendingResource
argument_list|(
name|nodeLabel
argument_list|,
name|resourceToDec
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|incUsedResource (String nodeLabel, Resource resourceToInc, SchedulerApplicationAttempt application)
specifier|public
name|void
name|incUsedResource
parameter_list|(
name|String
name|nodeLabel
parameter_list|,
name|Resource
name|resourceToInc
parameter_list|,
name|SchedulerApplicationAttempt
name|application
parameter_list|)
block|{
if|if
condition|(
name|nodeLabel
operator|==
literal|null
condition|)
block|{
name|nodeLabel
operator|=
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
expr_stmt|;
block|}
comment|// ResourceUsage has its own lock, no addition lock needs here.
name|queueUsage
operator|.
name|incUsed
argument_list|(
name|nodeLabel
argument_list|,
name|resourceToInc
argument_list|)
expr_stmt|;
name|CSQueueUtils
operator|.
name|updateUsedCapacity
argument_list|(
name|resourceCalculator
argument_list|,
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|nodeLabel
argument_list|,
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
argument_list|,
name|minimumAllocation
argument_list|,
name|queueUsage
argument_list|,
name|queueCapacities
argument_list|,
name|nodeLabel
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|parent
condition|)
block|{
name|parent
operator|.
name|incUsedResource
argument_list|(
name|nodeLabel
argument_list|,
name|resourceToInc
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|decUsedResource (String nodeLabel, Resource resourceToDec, SchedulerApplicationAttempt application)
specifier|public
name|void
name|decUsedResource
parameter_list|(
name|String
name|nodeLabel
parameter_list|,
name|Resource
name|resourceToDec
parameter_list|,
name|SchedulerApplicationAttempt
name|application
parameter_list|)
block|{
if|if
condition|(
name|nodeLabel
operator|==
literal|null
condition|)
block|{
name|nodeLabel
operator|=
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
expr_stmt|;
block|}
comment|// ResourceUsage has its own lock, no addition lock needs here.
name|queueUsage
operator|.
name|decUsed
argument_list|(
name|nodeLabel
argument_list|,
name|resourceToDec
argument_list|)
expr_stmt|;
name|CSQueueUtils
operator|.
name|updateUsedCapacity
argument_list|(
name|resourceCalculator
argument_list|,
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|nodeLabel
argument_list|,
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
argument_list|,
name|minimumAllocation
argument_list|,
name|queueUsage
argument_list|,
name|queueCapacities
argument_list|,
name|nodeLabel
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|parent
condition|)
block|{
name|parent
operator|.
name|decUsedResource
argument_list|(
name|nodeLabel
argument_list|,
name|resourceToDec
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Return if the queue has pending resource on given nodePartition and    * schedulingMode.     */
DECL|method|hasPendingResourceRequest (String nodePartition, Resource cluster, SchedulingMode schedulingMode)
name|boolean
name|hasPendingResourceRequest
parameter_list|(
name|String
name|nodePartition
parameter_list|,
name|Resource
name|cluster
parameter_list|,
name|SchedulingMode
name|schedulingMode
parameter_list|)
block|{
return|return
name|SchedulerUtils
operator|.
name|hasPendingResourceRequest
argument_list|(
name|resourceCalculator
argument_list|,
name|queueUsage
argument_list|,
name|nodePartition
argument_list|,
name|cluster
argument_list|,
name|schedulingMode
argument_list|)
return|;
block|}
DECL|method|accessibleToPartition (String nodePartition)
specifier|public
name|boolean
name|accessibleToPartition
parameter_list|(
name|String
name|nodePartition
parameter_list|)
block|{
comment|// if queue's label is *, it can access any node
if|if
condition|(
name|accessibleLabels
operator|!=
literal|null
operator|&&
name|accessibleLabels
operator|.
name|contains
argument_list|(
name|RMNodeLabelsManager
operator|.
name|ANY
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// any queue can access to a node without label
if|if
condition|(
name|nodePartition
operator|==
literal|null
operator|||
name|nodePartition
operator|.
name|equals
argument_list|(
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// a queue can access to a node only if it contains any label of the node
if|if
condition|(
name|accessibleLabels
operator|!=
literal|null
operator|&&
name|accessibleLabels
operator|.
name|contains
argument_list|(
name|nodePartition
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// sorry, you cannot access
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|getDefaultApplicationPriority ()
specifier|public
name|Priority
name|getDefaultApplicationPriority
parameter_list|()
block|{
comment|// TODO add dummy implementation
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|getNodeLabelsForQueue ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getNodeLabelsForQueue
parameter_list|()
block|{
comment|// if queue's label is *, queue can access any labels. Instead of
comment|// considering all labels in cluster, only those labels which are
comment|// use some resource of this queue can be considered.
name|Set
argument_list|<
name|String
argument_list|>
name|nodeLabels
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|getAccessibleNodeLabels
argument_list|()
operator|!=
literal|null
operator|&&
name|this
operator|.
name|getAccessibleNodeLabels
argument_list|()
operator|.
name|contains
argument_list|(
name|RMNodeLabelsManager
operator|.
name|ANY
argument_list|)
condition|)
block|{
name|nodeLabels
operator|.
name|addAll
argument_list|(
name|Sets
operator|.
name|union
argument_list|(
name|this
operator|.
name|getQueueCapacities
argument_list|()
operator|.
name|getNodePartitionsSet
argument_list|()
argument_list|,
name|this
operator|.
name|getQueueResourceUsage
argument_list|()
operator|.
name|getNodePartitionsSet
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodeLabels
operator|.
name|addAll
argument_list|(
name|this
operator|.
name|getAccessibleNodeLabels
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Add NO_LABEL also to this list as NO_LABEL also can be granted with
comment|// resource in many general cases.
if|if
condition|(
operator|!
name|nodeLabels
operator|.
name|contains
argument_list|(
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|)
condition|)
block|{
name|nodeLabels
operator|.
name|add
argument_list|(
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|)
expr_stmt|;
block|}
return|return
name|nodeLabels
return|;
block|}
DECL|method|getTotalKillableResource (String partition)
specifier|public
name|Resource
name|getTotalKillableResource
parameter_list|(
name|String
name|partition
parameter_list|)
block|{
return|return
name|csContext
operator|.
name|getPreemptionManager
argument_list|()
operator|.
name|getKillableResource
argument_list|(
name|queueName
argument_list|,
name|partition
argument_list|)
return|;
block|}
DECL|method|getKillableContainers (String partition)
specifier|public
name|Iterator
argument_list|<
name|RMContainer
argument_list|>
name|getKillableContainers
parameter_list|(
name|String
name|partition
parameter_list|)
block|{
return|return
name|csContext
operator|.
name|getPreemptionManager
argument_list|()
operator|.
name|getKillableContainers
argument_list|(
name|queueName
argument_list|,
name|partition
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
annotation|@
name|Override
DECL|method|assignContainers (Resource clusterResource, FiCaSchedulerNode node, ResourceLimits resourceLimits, SchedulingMode schedulingMode)
specifier|public
name|CSAssignment
name|assignContainers
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|FiCaSchedulerNode
name|node
parameter_list|,
name|ResourceLimits
name|resourceLimits
parameter_list|,
name|SchedulingMode
name|schedulingMode
parameter_list|)
block|{
return|return
name|assignContainers
argument_list|(
name|clusterResource
argument_list|,
operator|new
name|SimplePlacementSet
argument_list|<>
argument_list|(
name|node
argument_list|)
argument_list|,
name|resourceLimits
argument_list|,
name|schedulingMode
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|accept (Resource cluster, ResourceCommitRequest<FiCaSchedulerApp, FiCaSchedulerNode> request)
specifier|public
name|boolean
name|accept
parameter_list|(
name|Resource
name|cluster
parameter_list|,
name|ResourceCommitRequest
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
name|request
parameter_list|)
block|{
comment|// Do we need to check parent queue before making this decision?
name|boolean
name|checkParentQueue
init|=
literal|false
decl_stmt|;
name|ContainerAllocationProposal
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
name|allocation
init|=
name|request
operator|.
name|getFirstAllocatedOrReservedContainer
argument_list|()
decl_stmt|;
name|SchedulerContainer
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
name|schedulerContainer
init|=
name|allocation
operator|.
name|getAllocatedOrReservedContainer
argument_list|()
decl_stmt|;
comment|// Do not check when allocating new container from a reserved container
if|if
condition|(
name|allocation
operator|.
name|getAllocateFromReservedContainer
argument_list|()
operator|==
literal|null
condition|)
block|{
name|Resource
name|required
init|=
name|allocation
operator|.
name|getAllocatedOrReservedResource
argument_list|()
decl_stmt|;
name|Resource
name|netAllocated
init|=
name|Resources
operator|.
name|subtract
argument_list|(
name|required
argument_list|,
name|request
operator|.
name|getTotalReleasedResource
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|String
name|partition
init|=
name|schedulerContainer
operator|.
name|getNodePartition
argument_list|()
decl_stmt|;
name|Resource
name|maxResourceLimit
decl_stmt|;
if|if
condition|(
name|allocation
operator|.
name|getSchedulingMode
argument_list|()
operator|==
name|SchedulingMode
operator|.
name|RESPECT_PARTITION_EXCLUSIVITY
condition|)
block|{
name|maxResourceLimit
operator|=
name|getQueueMaxResource
argument_list|(
name|partition
argument_list|,
name|cluster
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|maxResourceLimit
operator|=
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|schedulerContainer
operator|.
name|getNodePartition
argument_list|()
argument_list|,
name|cluster
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Resources
operator|.
name|fitsIn
argument_list|(
name|resourceCalculator
argument_list|,
name|cluster
argument_list|,
name|Resources
operator|.
name|add
argument_list|(
name|queueUsage
operator|.
name|getUsed
argument_list|(
name|partition
argument_list|)
argument_list|,
name|netAllocated
argument_list|)
argument_list|,
name|maxResourceLimit
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Used resource="
operator|+
name|queueUsage
operator|.
name|getUsed
argument_list|(
name|partition
argument_list|)
operator|+
literal|" exceeded maxResourceLimit of the queue ="
operator|+
name|maxResourceLimit
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// Only check parent queue when something new allocated or reserved.
name|checkParentQueue
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|parent
operator|!=
literal|null
operator|&&
name|checkParentQueue
condition|)
block|{
return|return
name|parent
operator|.
name|accept
argument_list|(
name|cluster
argument_list|,
name|request
argument_list|)
return|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|validateSubmitApplication (ApplicationId applicationId, String userName, String queue)
specifier|public
name|void
name|validateSubmitApplication
parameter_list|(
name|ApplicationId
name|applicationId
parameter_list|,
name|String
name|userName
parameter_list|,
name|String
name|queue
parameter_list|)
throws|throws
name|AccessControlException
block|{
comment|// Dummy implementation
block|}
block|}
end_class

end_unit

