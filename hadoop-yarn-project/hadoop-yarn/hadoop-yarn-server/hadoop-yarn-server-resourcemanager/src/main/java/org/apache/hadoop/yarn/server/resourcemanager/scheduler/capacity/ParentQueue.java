begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/** * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|Private
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
operator|.
name|Evolving
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|AccessControlList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationAttemptId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ExecutionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueUserACLInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ResourceInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|factories
operator|.
name|RecordFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|factory
operator|.
name|providers
operator|.
name|RecordFactoryProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|security
operator|.
name|AccessType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|nodelabels
operator|.
name|RMNodeLabelsManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainerEventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainerState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|ActiveUsersManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|NodeType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|ResourceLimits
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|SchedulerApplicationAttempt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|SchedulerUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|activities
operator|.
name|ActivitiesLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|activities
operator|.
name|ActivityDiagnosticConstant
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|activities
operator|.
name|ActivityState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|activities
operator|.
name|AllocationState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|policy
operator|.
name|QueueOrderingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|ContainerAllocationProposal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|ResourceCommitRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|SchedulerContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|fica
operator|.
name|FiCaSchedulerApp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|fica
operator|.
name|FiCaSchedulerNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|placement
operator|.
name|CandidateNodeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|placement
operator|.
name|CandidateNodeSetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|UnitsConversionUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|ResourceCalculator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|ResourceUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|Resources
import|;
end_import

begin_class
annotation|@
name|Private
annotation|@
name|Evolving
DECL|class|ParentQueue
specifier|public
class|class
name|ParentQueue
extends|extends
name|AbstractCSQueue
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ParentQueue
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|childQueues
specifier|protected
specifier|final
name|List
argument_list|<
name|CSQueue
argument_list|>
name|childQueues
decl_stmt|;
DECL|field|rootQueue
specifier|private
specifier|final
name|boolean
name|rootQueue
decl_stmt|;
DECL|field|numApplications
specifier|private
specifier|volatile
name|int
name|numApplications
decl_stmt|;
DECL|field|scheduler
specifier|private
specifier|final
name|CapacitySchedulerContext
name|scheduler
decl_stmt|;
DECL|field|recordFactory
specifier|private
specifier|final
name|RecordFactory
name|recordFactory
init|=
name|RecordFactoryProvider
operator|.
name|getRecordFactory
argument_list|(
literal|null
argument_list|)
decl_stmt|;
DECL|field|queueOrderingPolicy
specifier|private
name|QueueOrderingPolicy
name|queueOrderingPolicy
decl_stmt|;
DECL|method|ParentQueue (CapacitySchedulerContext cs, String queueName, CSQueue parent, CSQueue old)
specifier|public
name|ParentQueue
parameter_list|(
name|CapacitySchedulerContext
name|cs
parameter_list|,
name|String
name|queueName
parameter_list|,
name|CSQueue
name|parent
parameter_list|,
name|CSQueue
name|old
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|cs
argument_list|,
name|queueName
argument_list|,
name|parent
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|this
operator|.
name|scheduler
operator|=
name|cs
expr_stmt|;
name|this
operator|.
name|rootQueue
operator|=
operator|(
name|parent
operator|==
literal|null
operator|)
expr_stmt|;
name|float
name|rawCapacity
init|=
name|cs
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getNonLabeledQueueCapacity
argument_list|(
name|getQueuePath
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rootQueue
operator|&&
operator|(
name|rawCapacity
operator|!=
name|CapacitySchedulerConfiguration
operator|.
name|MAXIMUM_CAPACITY_VALUE
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal "
operator|+
literal|"capacity of "
operator|+
name|rawCapacity
operator|+
literal|" for queue "
operator|+
name|queueName
operator|+
literal|". Must be "
operator|+
name|CapacitySchedulerConfiguration
operator|.
name|MAXIMUM_CAPACITY_VALUE
argument_list|)
throw|;
block|}
name|this
operator|.
name|childQueues
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|setupQueueConfigs
argument_list|(
name|cs
operator|.
name|getClusterResource
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Initialized parent-queue "
operator|+
name|queueName
operator|+
literal|" name="
operator|+
name|queueName
operator|+
literal|", fullname="
operator|+
name|getQueuePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// returns what is configured queue ordering policy
DECL|method|getQueueOrderingPolicyConfigName ()
specifier|private
name|String
name|getQueueOrderingPolicyConfigName
parameter_list|()
block|{
return|return
name|queueOrderingPolicy
operator|==
literal|null
condition|?
literal|null
else|:
name|queueOrderingPolicy
operator|.
name|getConfigName
argument_list|()
return|;
block|}
DECL|method|setupQueueConfigs (Resource clusterResource)
specifier|protected
name|void
name|setupQueueConfigs
parameter_list|(
name|Resource
name|clusterResource
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|super
operator|.
name|setupQueueConfigs
argument_list|(
name|clusterResource
argument_list|)
expr_stmt|;
name|StringBuilder
name|aclsString
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|AccessType
argument_list|,
name|AccessControlList
argument_list|>
name|e
range|:
name|acls
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|aclsString
operator|.
name|append
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
operator|+
literal|":"
operator|+
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getAclString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|StringBuilder
name|labelStrBuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|accessibleLabels
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|s
range|:
name|accessibleLabels
control|)
block|{
name|labelStrBuilder
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|labelStrBuilder
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Initialize queue ordering policy
name|queueOrderingPolicy
operator|=
name|csContext
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getQueueOrderingPolicy
argument_list|(
name|getQueuePath
argument_list|()
argument_list|,
name|parent
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
operator|(
name|ParentQueue
operator|)
name|parent
operator|)
operator|.
name|getQueueOrderingPolicyConfigName
argument_list|()
argument_list|)
expr_stmt|;
name|queueOrderingPolicy
operator|.
name|setQueues
argument_list|(
name|childQueues
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|queueName
operator|+
literal|", capacity="
operator|+
name|this
operator|.
name|queueCapacities
operator|.
name|getCapacity
argument_list|()
operator|+
literal|", absoluteCapacity="
operator|+
name|this
operator|.
name|queueCapacities
operator|.
name|getAbsoluteCapacity
argument_list|()
operator|+
literal|", maxCapacity="
operator|+
name|this
operator|.
name|queueCapacities
operator|.
name|getMaximumCapacity
argument_list|()
operator|+
literal|", absoluteMaxCapacity="
operator|+
name|this
operator|.
name|queueCapacities
operator|.
name|getAbsoluteMaximumCapacity
argument_list|()
operator|+
literal|", state="
operator|+
name|getState
argument_list|()
operator|+
literal|", acls="
operator|+
name|aclsString
operator|+
literal|", labels="
operator|+
name|labelStrBuilder
operator|.
name|toString
argument_list|()
operator|+
literal|"\n"
operator|+
literal|", reservationsContinueLooking="
operator|+
name|reservationsContinueLooking
operator|+
literal|", orderingPolicy="
operator|+
name|getQueueOrderingPolicyConfigName
argument_list|()
operator|+
literal|", priority="
operator|+
name|priority
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|PRECISION
specifier|private
specifier|static
name|float
name|PRECISION
init|=
literal|0.0005f
decl_stmt|;
comment|// 0.05% precision
DECL|method|setChildQueues (Collection<CSQueue> childQueues)
name|void
name|setChildQueues
parameter_list|(
name|Collection
argument_list|<
name|CSQueue
argument_list|>
name|childQueues
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// Validate
name|float
name|childCapacities
init|=
literal|0
decl_stmt|;
name|Resource
name|minResDefaultLabel
init|=
name|Resources
operator|.
name|createResource
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|CSQueue
name|queue
range|:
name|childQueues
control|)
block|{
name|childCapacities
operator|+=
name|queue
operator|.
name|getCapacity
argument_list|()
expr_stmt|;
name|Resources
operator|.
name|addTo
argument_list|(
name|minResDefaultLabel
argument_list|,
name|queue
operator|.
name|getQueueResourceQuotas
argument_list|()
operator|.
name|getConfiguredMinResource
argument_list|()
argument_list|)
expr_stmt|;
comment|// If any child queue is using percentage based capacity model vs parent
comment|// queues' absolute configuration or vice versa, throw back an
comment|// exception.
if|if
condition|(
operator|!
name|queueName
operator|.
name|equals
argument_list|(
literal|"root"
argument_list|)
operator|&&
name|getCapacity
argument_list|()
operator|!=
literal|0f
operator|&&
operator|!
name|queue
operator|.
name|getQueueResourceQuotas
argument_list|()
operator|.
name|getConfiguredMinResource
argument_list|()
operator|.
name|equals
argument_list|(
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parent queue '"
operator|+
name|getQueueName
argument_list|()
operator|+
literal|"' and child queue '"
operator|+
name|queue
operator|.
name|getQueueName
argument_list|()
operator|+
literal|"' should use either percentage based capacity"
operator|+
literal|" configuration or absolute resource together."
argument_list|)
throw|;
block|}
block|}
name|float
name|delta
init|=
name|Math
operator|.
name|abs
argument_list|(
literal|1.0f
operator|-
name|childCapacities
argument_list|)
decl_stmt|;
comment|// crude way to check
comment|// allow capacities being set to 0, and enforce child 0 if parent is 0
if|if
condition|(
operator|(
name|minResDefaultLabel
operator|.
name|equals
argument_list|(
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
operator|&&
operator|(
name|queueCapacities
operator|.
name|getCapacity
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|(
name|delta
operator|>
name|PRECISION
operator|)
operator|)
operator|||
operator|(
operator|(
name|queueCapacities
operator|.
name|getCapacity
argument_list|()
operator|==
literal|0
operator|)
operator|&&
operator|(
name|childCapacities
operator|>
literal|0
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal"
operator|+
literal|" capacity of "
operator|+
name|childCapacities
operator|+
literal|" for children of queue "
operator|+
name|queueName
argument_list|)
throw|;
block|}
comment|// check label capacities
for|for
control|(
name|String
name|nodeLabel
range|:
name|queueCapacities
operator|.
name|getExistingNodeLabels
argument_list|()
control|)
block|{
name|float
name|capacityByLabel
init|=
name|queueCapacities
operator|.
name|getCapacity
argument_list|(
name|nodeLabel
argument_list|)
decl_stmt|;
comment|// check children's labels
name|float
name|sum
init|=
literal|0
decl_stmt|;
name|Resource
name|minRes
init|=
name|Resources
operator|.
name|createResource
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|Resource
name|resourceByLabel
init|=
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|nodeLabel
argument_list|,
name|scheduler
operator|.
name|getClusterResource
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|CSQueue
name|queue
range|:
name|childQueues
control|)
block|{
name|sum
operator|+=
name|queue
operator|.
name|getQueueCapacities
argument_list|()
operator|.
name|getCapacity
argument_list|(
name|nodeLabel
argument_list|)
expr_stmt|;
comment|// If any child queue of a label is using percentage based capacity
comment|// model vs parent queues' absolute configuration or vice versa, throw
comment|// back an exception
if|if
condition|(
operator|!
name|queueName
operator|.
name|equals
argument_list|(
literal|"root"
argument_list|)
operator|&&
operator|!
name|this
operator|.
name|capacityConfigType
operator|.
name|equals
argument_list|(
name|queue
operator|.
name|getCapacityConfigType
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parent queue '"
operator|+
name|getQueueName
argument_list|()
operator|+
literal|"' and child queue '"
operator|+
name|queue
operator|.
name|getQueueName
argument_list|()
operator|+
literal|"' should use either percentage based capacity"
operator|+
literal|"configuration or absolute resource together for label:"
operator|+
name|nodeLabel
argument_list|)
throw|;
block|}
comment|// Accumulate all min/max resource configured for all child queues.
name|Resources
operator|.
name|addTo
argument_list|(
name|minRes
argument_list|,
name|queue
operator|.
name|getQueueResourceQuotas
argument_list|()
operator|.
name|getConfiguredMinResource
argument_list|(
name|nodeLabel
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|minResDefaultLabel
operator|.
name|equals
argument_list|(
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
operator|&&
name|capacityByLabel
operator|>
literal|0
operator|&&
name|Math
operator|.
name|abs
argument_list|(
literal|1.0f
operator|-
name|sum
argument_list|)
operator|>
name|PRECISION
operator|)
operator|||
operator|(
name|capacityByLabel
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sum
operator|>
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal"
operator|+
literal|" capacity of "
operator|+
name|sum
operator|+
literal|" for children of queue "
operator|+
name|queueName
operator|+
literal|" for label="
operator|+
name|nodeLabel
argument_list|)
throw|;
block|}
comment|// Ensure that for each parent queue: parent.min-resource>=
comment|// Î£(child.min-resource).
name|Resource
name|parentMinResource
init|=
name|queueResourceQuotas
operator|.
name|getConfiguredMinResource
argument_list|(
name|nodeLabel
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|parentMinResource
operator|.
name|equals
argument_list|(
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
operator|&&
name|Resources
operator|.
name|lessThan
argument_list|(
name|resourceCalculator
argument_list|,
name|resourceByLabel
argument_list|,
name|parentMinResource
argument_list|,
name|minRes
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parent Queues"
operator|+
literal|" capacity: "
operator|+
name|parentMinResource
operator|+
literal|" is less than"
operator|+
literal|" to its children:"
operator|+
name|minRes
operator|+
literal|" for queue:"
operator|+
name|queueName
argument_list|)
throw|;
block|}
block|}
name|this
operator|.
name|childQueues
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|childQueues
operator|.
name|addAll
argument_list|(
name|childQueues
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"setChildQueues: "
operator|+
name|getChildQueuesToPrint
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getQueueInfo ( boolean includeChildQueues, boolean recursive)
specifier|public
name|QueueInfo
name|getQueueInfo
parameter_list|(
name|boolean
name|includeChildQueues
parameter_list|,
name|boolean
name|recursive
parameter_list|)
block|{
try|try
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|QueueInfo
name|queueInfo
init|=
name|getQueueInfo
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|QueueInfo
argument_list|>
name|childQueuesInfo
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|includeChildQueues
condition|)
block|{
for|for
control|(
name|CSQueue
name|child
range|:
name|childQueues
control|)
block|{
comment|// Get queue information recursively?
name|childQueuesInfo
operator|.
name|add
argument_list|(
name|child
operator|.
name|getQueueInfo
argument_list|(
name|recursive
argument_list|,
name|recursive
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|queueInfo
operator|.
name|setChildQueues
argument_list|(
name|childQueuesInfo
argument_list|)
expr_stmt|;
return|return
name|queueInfo
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getUserAclInfo ( UserGroupInformation user)
specifier|private
name|QueueUserACLInfo
name|getUserAclInfo
parameter_list|(
name|UserGroupInformation
name|user
parameter_list|)
block|{
try|try
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|QueueUserACLInfo
name|userAclInfo
init|=
name|recordFactory
operator|.
name|newRecordInstance
argument_list|(
name|QueueUserACLInfo
operator|.
name|class
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|QueueACL
argument_list|>
name|operations
init|=
operator|new
name|ArrayList
argument_list|<
name|QueueACL
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|QueueACL
name|operation
range|:
name|QueueACL
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|hasAccess
argument_list|(
name|operation
argument_list|,
name|user
argument_list|)
condition|)
block|{
name|operations
operator|.
name|add
argument_list|(
name|operation
argument_list|)
expr_stmt|;
block|}
block|}
name|userAclInfo
operator|.
name|setQueueName
argument_list|(
name|getQueueName
argument_list|()
argument_list|)
expr_stmt|;
name|userAclInfo
operator|.
name|setUserAcls
argument_list|(
name|operations
argument_list|)
expr_stmt|;
return|return
name|userAclInfo
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getQueueUserAclInfo ( UserGroupInformation user)
specifier|public
name|List
argument_list|<
name|QueueUserACLInfo
argument_list|>
name|getQueueUserAclInfo
parameter_list|(
name|UserGroupInformation
name|user
parameter_list|)
block|{
try|try
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|QueueUserACLInfo
argument_list|>
name|userAcls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Add parent queue acls
name|userAcls
operator|.
name|add
argument_list|(
name|getUserAclInfo
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
comment|// Add children queue acls
for|for
control|(
name|CSQueue
name|child
range|:
name|childQueues
control|)
block|{
name|userAcls
operator|.
name|addAll
argument_list|(
name|child
operator|.
name|getQueueUserAclInfo
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|userAcls
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|queueName
operator|+
literal|": "
operator|+
literal|"numChildQueue= "
operator|+
name|childQueues
operator|.
name|size
argument_list|()
operator|+
literal|", "
operator|+
literal|"capacity="
operator|+
name|queueCapacities
operator|.
name|getCapacity
argument_list|()
operator|+
literal|", "
operator|+
literal|"absoluteCapacity="
operator|+
name|queueCapacities
operator|.
name|getAbsoluteCapacity
argument_list|()
operator|+
literal|", "
operator|+
literal|"usedResources="
operator|+
name|queueUsage
operator|.
name|getUsed
argument_list|()
operator|+
literal|"usedCapacity="
operator|+
name|getUsedCapacity
argument_list|()
operator|+
literal|", "
operator|+
literal|"numApps="
operator|+
name|getNumApplications
argument_list|()
operator|+
literal|", "
operator|+
literal|"numContainers="
operator|+
name|getNumContainers
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|reinitialize (CSQueue newlyParsedQueue, Resource clusterResource)
specifier|public
name|void
name|reinitialize
parameter_list|(
name|CSQueue
name|newlyParsedQueue
parameter_list|,
name|Resource
name|clusterResource
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// Sanity check
if|if
condition|(
operator|!
operator|(
name|newlyParsedQueue
operator|instanceof
name|ParentQueue
operator|)
operator|||
operator|!
name|newlyParsedQueue
operator|.
name|getQueuePath
argument_list|()
operator|.
name|equals
argument_list|(
name|getQueuePath
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Trying to reinitialize "
operator|+
name|getQueuePath
argument_list|()
operator|+
literal|" from "
operator|+
name|newlyParsedQueue
operator|.
name|getQueuePath
argument_list|()
argument_list|)
throw|;
block|}
name|ParentQueue
name|newlyParsedParentQueue
init|=
operator|(
name|ParentQueue
operator|)
name|newlyParsedQueue
decl_stmt|;
comment|// Set new configs
name|setupQueueConfigs
argument_list|(
name|clusterResource
argument_list|)
expr_stmt|;
comment|// Re-configure existing child queues and add new ones
comment|// The CS has already checked to ensure all existing child queues are present!
name|Map
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|currentChildQueues
init|=
name|getQueuesMap
argument_list|(
name|childQueues
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|newChildQueues
init|=
name|getQueuesMap
argument_list|(
name|newlyParsedParentQueue
operator|.
name|childQueues
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|e
range|:
name|newChildQueues
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|newChildQueueName
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|CSQueue
name|newChildQueue
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|CSQueue
name|childQueue
init|=
name|currentChildQueues
operator|.
name|get
argument_list|(
name|newChildQueueName
argument_list|)
decl_stmt|;
comment|// Check if the child-queue already exists
if|if
condition|(
name|childQueue
operator|!=
literal|null
condition|)
block|{
comment|// Check if the child-queue has been converted into parent queue or
comment|// parent Queue has been converted to child queue. The CS has already
comment|// checked to ensure that this child-queue is in STOPPED state if
comment|// Child queue has been converted to ParentQueue.
if|if
condition|(
operator|(
name|childQueue
operator|instanceof
name|LeafQueue
operator|&&
name|newChildQueue
operator|instanceof
name|ParentQueue
operator|)
operator|||
operator|(
name|childQueue
operator|instanceof
name|ParentQueue
operator|&&
name|newChildQueue
operator|instanceof
name|LeafQueue
operator|)
condition|)
block|{
comment|// We would convert this LeafQueue to ParentQueue, or vice versa.
comment|// consider this as the combination of DELETE then ADD.
name|newChildQueue
operator|.
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|currentChildQueues
operator|.
name|put
argument_list|(
name|newChildQueueName
argument_list|,
name|newChildQueue
argument_list|)
expr_stmt|;
comment|// inform CapacitySchedulerQueueManager
name|CapacitySchedulerQueueManager
name|queueManager
init|=
name|this
operator|.
name|csContext
operator|.
name|getCapacitySchedulerQueueManager
argument_list|()
decl_stmt|;
name|queueManager
operator|.
name|addQueue
argument_list|(
name|newChildQueueName
argument_list|,
name|newChildQueue
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// Re-init existing queues
name|childQueue
operator|.
name|reinitialize
argument_list|(
name|newChildQueue
argument_list|,
name|clusterResource
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getQueueName
argument_list|()
operator|+
literal|": re-configured queue: "
operator|+
name|childQueue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// New child queue, do not re-init
comment|// Set parent to 'this'
name|newChildQueue
operator|.
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Save in list of current child queues
name|currentChildQueues
operator|.
name|put
argument_list|(
name|newChildQueueName
argument_list|,
name|newChildQueue
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getQueueName
argument_list|()
operator|+
literal|": added new child queue: "
operator|+
name|newChildQueue
argument_list|)
expr_stmt|;
block|}
block|}
comment|// remove the deleted queue in the refreshed xml.
for|for
control|(
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
argument_list|>
name|itr
init|=
name|currentChildQueues
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|itr
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|e
init|=
name|itr
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|queueName
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|newChildQueues
operator|.
name|containsKey
argument_list|(
name|queueName
argument_list|)
condition|)
block|{
name|itr
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Re-sort all queues
name|childQueues
operator|.
name|clear
argument_list|()
expr_stmt|;
name|childQueues
operator|.
name|addAll
argument_list|(
name|currentChildQueues
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
comment|// Make sure we notifies QueueOrderingPolicy
name|queueOrderingPolicy
operator|.
name|setQueues
argument_list|(
name|childQueues
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getQueuesMap (List<CSQueue> queues)
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|getQueuesMap
parameter_list|(
name|List
argument_list|<
name|CSQueue
argument_list|>
name|queues
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|queuesMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|CSQueue
name|queue
range|:
name|queues
control|)
block|{
name|queuesMap
operator|.
name|put
argument_list|(
name|queue
operator|.
name|getQueueName
argument_list|()
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
return|return
name|queuesMap
return|;
block|}
annotation|@
name|Override
DECL|method|submitApplication (ApplicationId applicationId, String user, String queue)
specifier|public
name|void
name|submitApplication
parameter_list|(
name|ApplicationId
name|applicationId
parameter_list|,
name|String
name|user
parameter_list|,
name|String
name|queue
parameter_list|)
throws|throws
name|AccessControlException
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// Sanity check
name|validateSubmitApplication
argument_list|(
name|applicationId
argument_list|,
name|user
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|addApplication
argument_list|(
name|applicationId
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// Inform the parent queue
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|parent
operator|.
name|submitApplication
argument_list|(
name|applicationId
argument_list|,
name|user
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|ace
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to submit application to parent-queue: "
operator|+
name|parent
operator|.
name|getQueuePath
argument_list|()
argument_list|,
name|ace
argument_list|)
expr_stmt|;
name|removeApplication
argument_list|(
name|applicationId
argument_list|,
name|user
argument_list|)
expr_stmt|;
throw|throw
name|ace
throw|;
block|}
block|}
block|}
DECL|method|validateSubmitApplication (ApplicationId applicationId, String userName, String queue)
specifier|public
name|void
name|validateSubmitApplication
parameter_list|(
name|ApplicationId
name|applicationId
parameter_list|,
name|String
name|userName
parameter_list|,
name|String
name|queue
parameter_list|)
throws|throws
name|AccessControlException
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|queue
operator|.
name|equals
argument_list|(
name|queueName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"Cannot submit application "
operator|+
literal|"to non-leaf queue: "
operator|+
name|queueName
argument_list|)
throw|;
block|}
if|if
condition|(
name|getState
argument_list|()
operator|!=
name|QueueState
operator|.
name|RUNNING
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"Queue "
operator|+
name|getQueuePath
argument_list|()
operator|+
literal|" is STOPPED. Cannot accept submission of application: "
operator|+
name|applicationId
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|submitApplicationAttempt (FiCaSchedulerApp application, String userName)
specifier|public
name|void
name|submitApplicationAttempt
parameter_list|(
name|FiCaSchedulerApp
name|application
parameter_list|,
name|String
name|userName
parameter_list|)
block|{
comment|// submit attempt logic.
block|}
annotation|@
name|Override
DECL|method|finishApplicationAttempt (FiCaSchedulerApp application, String queue)
specifier|public
name|void
name|finishApplicationAttempt
parameter_list|(
name|FiCaSchedulerApp
name|application
parameter_list|,
name|String
name|queue
parameter_list|)
block|{
comment|// finish attempt logic.
block|}
DECL|method|addApplication (ApplicationId applicationId, String user)
specifier|private
name|void
name|addApplication
parameter_list|(
name|ApplicationId
name|applicationId
parameter_list|,
name|String
name|user
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
operator|++
name|numApplications
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Application added -"
operator|+
literal|" appId: "
operator|+
name|applicationId
operator|+
literal|" user: "
operator|+
name|user
operator|+
literal|" leaf-queue of parent: "
operator|+
name|getQueueName
argument_list|()
operator|+
literal|" #applications: "
operator|+
name|getNumApplications
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|finishApplication (ApplicationId application, String user)
specifier|public
name|void
name|finishApplication
parameter_list|(
name|ApplicationId
name|application
parameter_list|,
name|String
name|user
parameter_list|)
block|{
name|removeApplication
argument_list|(
name|application
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|appFinished
argument_list|()
expr_stmt|;
comment|// Inform the parent queue
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|parent
operator|.
name|finishApplication
argument_list|(
name|application
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeApplication (ApplicationId applicationId, String user)
specifier|private
name|void
name|removeApplication
parameter_list|(
name|ApplicationId
name|applicationId
parameter_list|,
name|String
name|user
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
operator|--
name|numApplications
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Application removed -"
operator|+
literal|" appId: "
operator|+
name|applicationId
operator|+
literal|" user: "
operator|+
name|user
operator|+
literal|" leaf-queue of parent: "
operator|+
name|getQueueName
argument_list|()
operator|+
literal|" #applications: "
operator|+
name|getNumApplications
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getParentName ()
specifier|private
name|String
name|getParentName
parameter_list|()
block|{
return|return
name|getParent
argument_list|()
operator|!=
literal|null
condition|?
name|getParent
argument_list|()
operator|.
name|getQueueName
argument_list|()
else|:
literal|""
return|;
block|}
annotation|@
name|Override
DECL|method|assignContainers (Resource clusterResource, CandidateNodeSet<FiCaSchedulerNode> candidates, ResourceLimits resourceLimits, SchedulingMode schedulingMode)
specifier|public
name|CSAssignment
name|assignContainers
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|CandidateNodeSet
argument_list|<
name|FiCaSchedulerNode
argument_list|>
name|candidates
parameter_list|,
name|ResourceLimits
name|resourceLimits
parameter_list|,
name|SchedulingMode
name|schedulingMode
parameter_list|)
block|{
name|FiCaSchedulerNode
name|node
init|=
name|CandidateNodeSetUtils
operator|.
name|getSingleNode
argument_list|(
name|candidates
argument_list|)
decl_stmt|;
comment|// if our queue cannot access this node, just return
if|if
condition|(
name|schedulingMode
operator|==
name|SchedulingMode
operator|.
name|RESPECT_PARTITION_EXCLUSIVITY
operator|&&
operator|!
name|accessibleToPartition
argument_list|(
name|candidates
operator|.
name|getPartition
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skip this queue="
operator|+
name|getQueuePath
argument_list|()
operator|+
literal|", because it is not able to access partition="
operator|+
name|candidates
operator|.
name|getPartition
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ActivitiesLogger
operator|.
name|QUEUE
operator|.
name|recordQueueActivity
argument_list|(
name|activitiesManager
argument_list|,
name|node
argument_list|,
name|getParentName
argument_list|()
argument_list|,
name|getQueueName
argument_list|()
argument_list|,
name|ActivityState
operator|.
name|REJECTED
argument_list|,
name|ActivityDiagnosticConstant
operator|.
name|NOT_ABLE_TO_ACCESS_PARTITION
operator|+
name|node
operator|.
name|getPartition
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|rootQueue
condition|)
block|{
name|ActivitiesLogger
operator|.
name|NODE
operator|.
name|finishSkippedNodeAllocation
argument_list|(
name|activitiesManager
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|CSAssignment
operator|.
name|NULL_ASSIGNMENT
return|;
block|}
comment|// Check if this queue need more resource, simply skip allocation if this
comment|// queue doesn't need more resources.
if|if
condition|(
operator|!
name|super
operator|.
name|hasPendingResourceRequest
argument_list|(
name|candidates
operator|.
name|getPartition
argument_list|()
argument_list|,
name|clusterResource
argument_list|,
name|schedulingMode
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skip this queue="
operator|+
name|getQueuePath
argument_list|()
operator|+
literal|", because it doesn't need more resource, schedulingMode="
operator|+
name|schedulingMode
operator|.
name|name
argument_list|()
operator|+
literal|" node-partition="
operator|+
name|candidates
operator|.
name|getPartition
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ActivitiesLogger
operator|.
name|QUEUE
operator|.
name|recordQueueActivity
argument_list|(
name|activitiesManager
argument_list|,
name|node
argument_list|,
name|getParentName
argument_list|()
argument_list|,
name|getQueueName
argument_list|()
argument_list|,
name|ActivityState
operator|.
name|SKIPPED
argument_list|,
name|ActivityDiagnosticConstant
operator|.
name|QUEUE_DO_NOT_NEED_MORE_RESOURCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rootQueue
condition|)
block|{
name|ActivitiesLogger
operator|.
name|NODE
operator|.
name|finishSkippedNodeAllocation
argument_list|(
name|activitiesManager
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
return|return
name|CSAssignment
operator|.
name|NULL_ASSIGNMENT
return|;
block|}
name|CSAssignment
name|assignment
init|=
operator|new
name|CSAssignment
argument_list|(
name|Resources
operator|.
name|createResource
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NodeType
operator|.
name|NODE_LOCAL
argument_list|)
decl_stmt|;
while|while
condition|(
name|canAssign
argument_list|(
name|clusterResource
argument_list|,
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying to assign containers to child-queue of "
operator|+
name|getQueueName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Are we over maximum-capacity for this queue?
comment|// This will also consider parent's limits and also continuous reservation
comment|// looking
if|if
condition|(
operator|!
name|super
operator|.
name|canAssignToThisQueue
argument_list|(
name|clusterResource
argument_list|,
name|candidates
operator|.
name|getPartition
argument_list|()
argument_list|,
name|resourceLimits
argument_list|,
name|Resources
operator|.
name|createResource
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getReservedMB
argument_list|()
argument_list|,
name|getMetrics
argument_list|()
operator|.
name|getReservedVirtualCores
argument_list|()
argument_list|)
argument_list|,
name|schedulingMode
argument_list|)
condition|)
block|{
name|ActivitiesLogger
operator|.
name|QUEUE
operator|.
name|recordQueueActivity
argument_list|(
name|activitiesManager
argument_list|,
name|node
argument_list|,
name|getParentName
argument_list|()
argument_list|,
name|getQueueName
argument_list|()
argument_list|,
name|ActivityState
operator|.
name|SKIPPED
argument_list|,
name|ActivityDiagnosticConstant
operator|.
name|QUEUE_MAX_CAPACITY_LIMIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rootQueue
condition|)
block|{
name|ActivitiesLogger
operator|.
name|NODE
operator|.
name|finishSkippedNodeAllocation
argument_list|(
name|activitiesManager
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|// Schedule
name|CSAssignment
name|assignedToChild
init|=
name|assignContainersToChildQueues
argument_list|(
name|clusterResource
argument_list|,
name|candidates
argument_list|,
name|resourceLimits
argument_list|,
name|schedulingMode
argument_list|)
decl_stmt|;
name|assignment
operator|.
name|setType
argument_list|(
name|assignedToChild
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|assignment
operator|.
name|setRequestLocalityType
argument_list|(
name|assignedToChild
operator|.
name|getRequestLocalityType
argument_list|()
argument_list|)
expr_stmt|;
name|assignment
operator|.
name|setExcessReservation
argument_list|(
name|assignedToChild
operator|.
name|getExcessReservation
argument_list|()
argument_list|)
expr_stmt|;
name|assignment
operator|.
name|setContainersToKill
argument_list|(
name|assignedToChild
operator|.
name|getContainersToKill
argument_list|()
argument_list|)
expr_stmt|;
comment|// Done if no child-queue assigned anything
if|if
condition|(
name|Resources
operator|.
name|greaterThan
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|assignedToChild
operator|.
name|getResource
argument_list|()
argument_list|,
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
condition|)
block|{
name|ActivitiesLogger
operator|.
name|QUEUE
operator|.
name|recordQueueActivity
argument_list|(
name|activitiesManager
argument_list|,
name|node
argument_list|,
name|getParentName
argument_list|()
argument_list|,
name|getQueueName
argument_list|()
argument_list|,
name|ActivityState
operator|.
name|ACCEPTED
argument_list|,
name|ActivityDiagnosticConstant
operator|.
name|EMPTY
argument_list|)
expr_stmt|;
name|boolean
name|isReserved
init|=
name|assignedToChild
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getReservationDetails
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|assignedToChild
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getReservationDetails
argument_list|()
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
operator|&&
operator|!
name|isReserved
condition|)
block|{
if|if
condition|(
name|rootQueue
condition|)
block|{
name|ActivitiesLogger
operator|.
name|NODE
operator|.
name|finishAllocatedNodeAllocation
argument_list|(
name|activitiesManager
argument_list|,
name|node
argument_list|,
name|assignedToChild
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getFirstAllocatedOrReservedContainerId
argument_list|()
argument_list|,
name|AllocationState
operator|.
name|ALLOCATED
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|rootQueue
condition|)
block|{
name|ActivitiesLogger
operator|.
name|NODE
operator|.
name|finishAllocatedNodeAllocation
argument_list|(
name|activitiesManager
argument_list|,
name|node
argument_list|,
name|assignedToChild
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getFirstAllocatedOrReservedContainerId
argument_list|()
argument_list|,
name|AllocationState
operator|.
name|RESERVED
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Track resource utilization in this pass of the scheduler
name|Resources
operator|.
name|addTo
argument_list|(
name|assignment
operator|.
name|getResource
argument_list|()
argument_list|,
name|assignedToChild
operator|.
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
name|Resources
operator|.
name|addTo
argument_list|(
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getAllocated
argument_list|()
argument_list|,
name|assignedToChild
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getAllocated
argument_list|()
argument_list|)
expr_stmt|;
name|Resources
operator|.
name|addTo
argument_list|(
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getReserved
argument_list|()
argument_list|,
name|assignedToChild
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getReserved
argument_list|()
argument_list|)
expr_stmt|;
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|incrAllocations
argument_list|(
name|assignedToChild
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getNumAllocations
argument_list|()
argument_list|)
expr_stmt|;
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|incrReservations
argument_list|(
name|assignedToChild
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getNumReservations
argument_list|()
argument_list|)
expr_stmt|;
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getAllocationDetails
argument_list|()
operator|.
name|addAll
argument_list|(
name|assignedToChild
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getAllocationDetails
argument_list|()
argument_list|)
expr_stmt|;
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getReservationDetails
argument_list|()
operator|.
name|addAll
argument_list|(
name|assignedToChild
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getReservationDetails
argument_list|()
argument_list|)
expr_stmt|;
name|assignment
operator|.
name|setIncreasedAllocation
argument_list|(
name|assignedToChild
operator|.
name|isIncreasedAllocation
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"assignedContainer"
operator|+
literal|" queue="
operator|+
name|getQueueName
argument_list|()
operator|+
literal|" usedCapacity="
operator|+
name|getUsedCapacity
argument_list|()
operator|+
literal|" absoluteUsedCapacity="
operator|+
name|getAbsoluteUsedCapacity
argument_list|()
operator|+
literal|" used="
operator|+
name|queueUsage
operator|.
name|getUsed
argument_list|()
operator|+
literal|" cluster="
operator|+
name|clusterResource
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ParentQ="
operator|+
name|getQueueName
argument_list|()
operator|+
literal|" assignedSoFarInThisIteration="
operator|+
name|assignment
operator|.
name|getResource
argument_list|()
operator|+
literal|" usedCapacity="
operator|+
name|getUsedCapacity
argument_list|()
operator|+
literal|" absoluteUsedCapacity="
operator|+
name|getAbsoluteUsedCapacity
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|assignment
operator|.
name|setSkippedType
argument_list|(
name|assignedToChild
operator|.
name|getSkippedType
argument_list|()
argument_list|)
expr_stmt|;
name|ActivitiesLogger
operator|.
name|QUEUE
operator|.
name|recordQueueActivity
argument_list|(
name|activitiesManager
argument_list|,
name|node
argument_list|,
name|getParentName
argument_list|()
argument_list|,
name|getQueueName
argument_list|()
argument_list|,
name|ActivityState
operator|.
name|SKIPPED
argument_list|,
name|ActivityDiagnosticConstant
operator|.
name|EMPTY
argument_list|)
expr_stmt|;
if|if
condition|(
name|rootQueue
condition|)
block|{
name|ActivitiesLogger
operator|.
name|NODE
operator|.
name|finishSkippedNodeAllocation
argument_list|(
name|activitiesManager
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/*        * Previously here, we can allocate more than one container for each        * allocation under rootQ. Now this logic is not proper any more        * in global scheduling world.        *        * So here do not try to allocate more than one container for each        * allocation, let top scheduler make the decision.        */
break|break;
block|}
return|return
name|assignment
return|;
block|}
DECL|method|canAssign (Resource clusterResource, FiCaSchedulerNode node)
specifier|private
name|boolean
name|canAssign
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|FiCaSchedulerNode
name|node
parameter_list|)
block|{
comment|// When node == null means global scheduling is enabled, always return true
if|if
condition|(
literal|null
operator|==
name|node
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// Two conditions need to meet when trying to allocate:
comment|// 1) Node doesn't have reserved container
comment|// 2) Node's available-resource + killable-resource should> 0
return|return
name|node
operator|.
name|getReservedContainer
argument_list|()
operator|==
literal|null
operator|&&
name|Resources
operator|.
name|greaterThanOrEqual
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|Resources
operator|.
name|add
argument_list|(
name|node
operator|.
name|getUnallocatedResource
argument_list|()
argument_list|,
name|node
operator|.
name|getTotalKillableResources
argument_list|()
argument_list|)
argument_list|,
name|minimumAllocation
argument_list|)
return|;
block|}
DECL|method|getResourceLimitsOfChild (CSQueue child, Resource clusterResource, Resource parentLimits, String nodePartition)
specifier|private
name|ResourceLimits
name|getResourceLimitsOfChild
parameter_list|(
name|CSQueue
name|child
parameter_list|,
name|Resource
name|clusterResource
parameter_list|,
name|Resource
name|parentLimits
parameter_list|,
name|String
name|nodePartition
parameter_list|)
block|{
comment|// Set resource-limit of a given child, child.limit =
comment|// min(my.limit - my.used + child.used, child.max)
comment|// Parent available resource = parent-limit - parent-used-resource
name|Resource
name|parentMaxAvailableResource
init|=
name|Resources
operator|.
name|subtract
argument_list|(
name|parentLimits
argument_list|,
name|queueUsage
operator|.
name|getUsed
argument_list|(
name|nodePartition
argument_list|)
argument_list|)
decl_stmt|;
comment|// Deduct killable from used
name|Resources
operator|.
name|addTo
argument_list|(
name|parentMaxAvailableResource
argument_list|,
name|getTotalKillableResource
argument_list|(
name|nodePartition
argument_list|)
argument_list|)
expr_stmt|;
comment|// Child's limit = parent-available-resource + child-used
name|Resource
name|childLimit
init|=
name|Resources
operator|.
name|add
argument_list|(
name|parentMaxAvailableResource
argument_list|,
name|child
operator|.
name|getQueueResourceUsage
argument_list|()
operator|.
name|getUsed
argument_list|(
name|nodePartition
argument_list|)
argument_list|)
decl_stmt|;
comment|// Get child's max resource
name|Resource
name|childConfiguredMaxResource
init|=
name|child
operator|.
name|getEffectiveMaxCapacityDown
argument_list|(
name|nodePartition
argument_list|,
name|minimumAllocation
argument_list|)
decl_stmt|;
comment|// Child's limit should be capped by child configured max resource
name|childLimit
operator|=
name|Resources
operator|.
name|min
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|childLimit
argument_list|,
name|childConfiguredMaxResource
argument_list|)
expr_stmt|;
comment|// Normalize before return
name|childLimit
operator|=
name|Resources
operator|.
name|roundDown
argument_list|(
name|resourceCalculator
argument_list|,
name|childLimit
argument_list|,
name|minimumAllocation
argument_list|)
expr_stmt|;
return|return
operator|new
name|ResourceLimits
argument_list|(
name|childLimit
argument_list|)
return|;
block|}
DECL|method|sortAndGetChildrenAllocationIterator ( String partition)
specifier|private
name|Iterator
argument_list|<
name|CSQueue
argument_list|>
name|sortAndGetChildrenAllocationIterator
parameter_list|(
name|String
name|partition
parameter_list|)
block|{
return|return
name|queueOrderingPolicy
operator|.
name|getAssignmentIterator
argument_list|(
name|partition
argument_list|)
return|;
block|}
DECL|method|assignContainersToChildQueues (Resource cluster, CandidateNodeSet<FiCaSchedulerNode> candidates, ResourceLimits limits, SchedulingMode schedulingMode)
specifier|private
name|CSAssignment
name|assignContainersToChildQueues
parameter_list|(
name|Resource
name|cluster
parameter_list|,
name|CandidateNodeSet
argument_list|<
name|FiCaSchedulerNode
argument_list|>
name|candidates
parameter_list|,
name|ResourceLimits
name|limits
parameter_list|,
name|SchedulingMode
name|schedulingMode
parameter_list|)
block|{
name|CSAssignment
name|assignment
init|=
name|CSAssignment
operator|.
name|NULL_ASSIGNMENT
decl_stmt|;
name|Resource
name|parentLimits
init|=
name|limits
operator|.
name|getLimit
argument_list|()
decl_stmt|;
name|printChildQueues
argument_list|()
expr_stmt|;
comment|// Try to assign to most 'under-served' sub-queue
for|for
control|(
name|Iterator
argument_list|<
name|CSQueue
argument_list|>
name|iter
init|=
name|sortAndGetChildrenAllocationIterator
argument_list|(
name|candidates
operator|.
name|getPartition
argument_list|()
argument_list|)
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|CSQueue
name|childQueue
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying to assign to queue: "
operator|+
name|childQueue
operator|.
name|getQueuePath
argument_list|()
operator|+
literal|" stats: "
operator|+
name|childQueue
argument_list|)
expr_stmt|;
block|}
comment|// Get ResourceLimits of child queue before assign containers
name|ResourceLimits
name|childLimits
init|=
name|getResourceLimitsOfChild
argument_list|(
name|childQueue
argument_list|,
name|cluster
argument_list|,
name|parentLimits
argument_list|,
name|candidates
operator|.
name|getPartition
argument_list|()
argument_list|)
decl_stmt|;
name|CSAssignment
name|childAssignment
init|=
name|childQueue
operator|.
name|assignContainers
argument_list|(
name|cluster
argument_list|,
name|candidates
argument_list|,
name|childLimits
argument_list|,
name|schedulingMode
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Assigned to queue: "
operator|+
name|childQueue
operator|.
name|getQueuePath
argument_list|()
operator|+
literal|" stats: "
operator|+
name|childQueue
operator|+
literal|" --> "
operator|+
name|childAssignment
operator|.
name|getResource
argument_list|()
operator|+
literal|", "
operator|+
name|childAssignment
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Resources
operator|.
name|greaterThan
argument_list|(
name|resourceCalculator
argument_list|,
name|cluster
argument_list|,
name|childAssignment
operator|.
name|getResource
argument_list|()
argument_list|,
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
condition|)
block|{
name|assignment
operator|=
name|childAssignment
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|childAssignment
operator|.
name|getSkippedType
argument_list|()
operator|==
name|CSAssignment
operator|.
name|SkippedType
operator|.
name|QUEUE_LIMIT
condition|)
block|{
if|if
condition|(
name|assignment
operator|.
name|getSkippedType
argument_list|()
operator|!=
name|CSAssignment
operator|.
name|SkippedType
operator|.
name|QUEUE_LIMIT
condition|)
block|{
name|assignment
operator|=
name|childAssignment
expr_stmt|;
block|}
name|Resource
name|resourceToSubtract
init|=
name|Resources
operator|.
name|max
argument_list|(
name|resourceCalculator
argument_list|,
name|cluster
argument_list|,
name|childLimits
operator|.
name|getHeadroom
argument_list|()
argument_list|,
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Decrease parentLimits "
operator|+
name|parentLimits
operator|+
literal|" for "
operator|+
name|this
operator|.
name|getQueueName
argument_list|()
operator|+
literal|" by "
operator|+
name|resourceToSubtract
operator|+
literal|" as childQueue="
operator|+
name|childQueue
operator|.
name|getQueueName
argument_list|()
operator|+
literal|" is blocked"
argument_list|)
expr_stmt|;
block|}
name|parentLimits
operator|=
name|Resources
operator|.
name|subtract
argument_list|(
name|parentLimits
argument_list|,
name|resourceToSubtract
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|assignment
return|;
block|}
DECL|method|getChildQueuesToPrint ()
name|String
name|getChildQueuesToPrint
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|CSQueue
name|q
range|:
name|childQueues
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|q
operator|.
name|getQueuePath
argument_list|()
operator|+
literal|"usedCapacity=("
operator|+
name|q
operator|.
name|getUsedCapacity
argument_list|()
operator|+
literal|"), "
operator|+
literal|" label=("
operator|+
name|StringUtils
operator|.
name|join
argument_list|(
name|q
operator|.
name|getAccessibleNodeLabels
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
literal|","
argument_list|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|printChildQueues ()
specifier|private
name|void
name|printChildQueues
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"printChildQueues - queue: "
operator|+
name|getQueuePath
argument_list|()
operator|+
literal|" child-queues: "
operator|+
name|getChildQueuesToPrint
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|internalReleaseResource (Resource clusterResource, FiCaSchedulerNode node, Resource releasedResource)
specifier|private
name|void
name|internalReleaseResource
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|FiCaSchedulerNode
name|node
parameter_list|,
name|Resource
name|releasedResource
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|super
operator|.
name|releaseResource
argument_list|(
name|clusterResource
argument_list|,
name|releasedResource
argument_list|,
name|node
operator|.
name|getPartition
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"completedContainer "
operator|+
name|this
operator|+
literal|", cluster="
operator|+
name|clusterResource
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|completedContainer (Resource clusterResource, FiCaSchedulerApp application, FiCaSchedulerNode node, RMContainer rmContainer, ContainerStatus containerStatus, RMContainerEventType event, CSQueue completedChildQueue, boolean sortQueues)
specifier|public
name|void
name|completedContainer
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|FiCaSchedulerApp
name|application
parameter_list|,
name|FiCaSchedulerNode
name|node
parameter_list|,
name|RMContainer
name|rmContainer
parameter_list|,
name|ContainerStatus
name|containerStatus
parameter_list|,
name|RMContainerEventType
name|event
parameter_list|,
name|CSQueue
name|completedChildQueue
parameter_list|,
name|boolean
name|sortQueues
parameter_list|)
block|{
if|if
condition|(
name|application
operator|!=
literal|null
condition|)
block|{
name|internalReleaseResource
argument_list|(
name|clusterResource
argument_list|,
name|node
argument_list|,
name|rmContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
comment|// Inform the parent
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
comment|// complete my parent
name|parent
operator|.
name|completedContainer
argument_list|(
name|clusterResource
argument_list|,
name|application
argument_list|,
name|node
argument_list|,
name|rmContainer
argument_list|,
literal|null
argument_list|,
name|event
argument_list|,
name|this
argument_list|,
name|sortQueues
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|updateClusterResource (Resource clusterResource, ResourceLimits resourceLimits)
specifier|public
name|void
name|updateClusterResource
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|ResourceLimits
name|resourceLimits
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// Update effective capacity in all parent queue.
name|Set
argument_list|<
name|String
argument_list|>
name|configuredNodelabels
init|=
name|csContext
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getConfiguredNodeLabels
argument_list|(
name|getQueuePath
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|label
range|:
name|configuredNodelabels
control|)
block|{
name|calculateEffectiveResourcesAndCapacity
argument_list|(
name|label
argument_list|,
name|clusterResource
argument_list|)
expr_stmt|;
block|}
comment|// Update all children
for|for
control|(
name|CSQueue
name|childQueue
range|:
name|childQueues
control|)
block|{
comment|// Get ResourceLimits of child queue before assign containers
name|ResourceLimits
name|childLimits
init|=
name|getResourceLimitsOfChild
argument_list|(
name|childQueue
argument_list|,
name|clusterResource
argument_list|,
name|resourceLimits
operator|.
name|getLimit
argument_list|()
argument_list|,
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|)
decl_stmt|;
name|childQueue
operator|.
name|updateClusterResource
argument_list|(
name|clusterResource
argument_list|,
name|childLimits
argument_list|)
expr_stmt|;
block|}
name|CSQueueUtils
operator|.
name|updateQueueStatistics
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|this
argument_list|,
name|labelManager
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|hasChildQueues ()
specifier|public
name|boolean
name|hasChildQueues
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
DECL|method|calculateEffectiveResourcesAndCapacity (String label, Resource clusterResource)
specifier|private
name|void
name|calculateEffectiveResourcesAndCapacity
parameter_list|(
name|String
name|label
parameter_list|,
name|Resource
name|clusterResource
parameter_list|)
block|{
comment|// For root queue, ensure that max/min resource is updated to latest
comment|// cluster resource.
name|Resource
name|resourceByLabel
init|=
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|label
argument_list|,
name|clusterResource
argument_list|)
decl_stmt|;
if|if
condition|(
name|getQueueName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"root"
argument_list|)
condition|)
block|{
name|queueResourceQuotas
operator|.
name|setConfiguredMinResource
argument_list|(
name|label
argument_list|,
name|resourceByLabel
argument_list|)
expr_stmt|;
name|queueResourceQuotas
operator|.
name|setConfiguredMaxResource
argument_list|(
name|label
argument_list|,
name|resourceByLabel
argument_list|)
expr_stmt|;
name|queueResourceQuotas
operator|.
name|setEffectiveMinResource
argument_list|(
name|label
argument_list|,
name|resourceByLabel
argument_list|)
expr_stmt|;
name|queueResourceQuotas
operator|.
name|setEffectiveMaxResource
argument_list|(
name|label
argument_list|,
name|resourceByLabel
argument_list|)
expr_stmt|;
name|queueCapacities
operator|.
name|setAbsoluteCapacity
argument_list|(
name|label
argument_list|,
literal|1.0f
argument_list|)
expr_stmt|;
block|}
comment|// Total configured min resources of direct children of this given parent
comment|// queue.
name|Resource
name|configuredMinResources
init|=
name|Resource
operator|.
name|newInstance
argument_list|(
literal|0L
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|CSQueue
name|childQueue
range|:
name|getChildQueues
argument_list|()
control|)
block|{
name|Resources
operator|.
name|addTo
argument_list|(
name|configuredMinResources
argument_list|,
name|childQueue
operator|.
name|getQueueResourceQuotas
argument_list|()
operator|.
name|getConfiguredMinResource
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Factor to scale down effective resource: When cluster has sufficient
comment|// resources, effective_min_resources will be same as configured
comment|// min_resources.
name|Resource
name|numeratorForMinRatio
init|=
literal|null
decl_stmt|;
name|ResourceCalculator
name|rc
init|=
name|this
operator|.
name|csContext
operator|.
name|getResourceCalculator
argument_list|()
decl_stmt|;
if|if
condition|(
name|getQueueName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"root"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|resourceByLabel
operator|.
name|equals
argument_list|(
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
operator|&&
name|Resources
operator|.
name|lessThan
argument_list|(
name|rc
argument_list|,
name|clusterResource
argument_list|,
name|resourceByLabel
argument_list|,
name|configuredMinResources
argument_list|)
condition|)
block|{
name|numeratorForMinRatio
operator|=
name|resourceByLabel
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|Resources
operator|.
name|lessThan
argument_list|(
name|rc
argument_list|,
name|clusterResource
argument_list|,
name|queueResourceQuotas
operator|.
name|getEffectiveMinResource
argument_list|(
name|label
argument_list|)
argument_list|,
name|configuredMinResources
argument_list|)
condition|)
block|{
name|numeratorForMinRatio
operator|=
name|queueResourceQuotas
operator|.
name|getEffectiveMinResource
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|effectiveMinRatioPerResource
init|=
name|getEffectiveMinRatioPerResource
argument_list|(
name|configuredMinResources
argument_list|,
name|numeratorForMinRatio
argument_list|)
decl_stmt|;
comment|// loop and do this for all child queues
for|for
control|(
name|CSQueue
name|childQueue
range|:
name|getChildQueues
argument_list|()
control|)
block|{
name|Resource
name|minResource
init|=
name|childQueue
operator|.
name|getQueueResourceQuotas
argument_list|()
operator|.
name|getConfiguredMinResource
argument_list|(
name|label
argument_list|)
decl_stmt|;
comment|// Update effective resource (min/max) to each child queue.
if|if
condition|(
name|childQueue
operator|.
name|getCapacityConfigType
argument_list|()
operator|.
name|equals
argument_list|(
name|CapacityConfigType
operator|.
name|ABSOLUTE_RESOURCE
argument_list|)
condition|)
block|{
name|childQueue
operator|.
name|getQueueResourceQuotas
argument_list|()
operator|.
name|setEffectiveMinResource
argument_list|(
name|label
argument_list|,
name|getMinResourceNormalized
argument_list|(
name|childQueue
operator|.
name|getQueueName
argument_list|()
argument_list|,
name|effectiveMinRatioPerResource
argument_list|,
name|minResource
argument_list|)
argument_list|)
expr_stmt|;
comment|// Max resource of a queue should be a minimum of {configuredMaxRes,
comment|// parentMaxRes}. parentMaxRes could be configured value. But if not
comment|// present could also be taken from effective max resource of parent.
name|Resource
name|parentMaxRes
init|=
name|queueResourceQuotas
operator|.
name|getConfiguredMaxResource
argument_list|(
name|label
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
operator|&&
name|parentMaxRes
operator|.
name|equals
argument_list|(
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
condition|)
block|{
name|parentMaxRes
operator|=
name|parent
operator|.
name|getQueueResourceQuotas
argument_list|()
operator|.
name|getEffectiveMaxResource
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
comment|// Minimum of {childMaxResource, parentMaxRes}. However if
comment|// childMaxResource is empty, consider parent's max resource alone.
name|Resource
name|childMaxResource
init|=
name|childQueue
operator|.
name|getQueueResourceQuotas
argument_list|()
operator|.
name|getConfiguredMaxResource
argument_list|(
name|label
argument_list|)
decl_stmt|;
name|Resource
name|effMaxResource
init|=
name|Resources
operator|.
name|min
argument_list|(
name|resourceCalculator
argument_list|,
name|resourceByLabel
argument_list|,
name|childMaxResource
operator|.
name|equals
argument_list|(
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
condition|?
name|parentMaxRes
else|:
name|childMaxResource
argument_list|,
name|parentMaxRes
argument_list|)
decl_stmt|;
name|childQueue
operator|.
name|getQueueResourceQuotas
argument_list|()
operator|.
name|setEffectiveMaxResource
argument_list|(
name|label
argument_list|,
name|Resources
operator|.
name|clone
argument_list|(
name|effMaxResource
argument_list|)
argument_list|)
expr_stmt|;
comment|// In cases where we still need to update some units based on
comment|// percentage, we have to calculate percentage and update.
name|deriveCapacityFromAbsoluteConfigurations
argument_list|(
name|label
argument_list|,
name|clusterResource
argument_list|,
name|rc
argument_list|,
name|childQueue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|childQueue
operator|.
name|getQueueResourceQuotas
argument_list|()
operator|.
name|setEffectiveMinResource
argument_list|(
name|label
argument_list|,
name|Resources
operator|.
name|multiply
argument_list|(
name|resourceByLabel
argument_list|,
name|childQueue
operator|.
name|getQueueCapacities
argument_list|()
operator|.
name|getAbsoluteCapacity
argument_list|(
name|label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|childQueue
operator|.
name|getQueueResourceQuotas
argument_list|()
operator|.
name|setEffectiveMaxResource
argument_list|(
name|label
argument_list|,
name|Resources
operator|.
name|multiply
argument_list|(
name|resourceByLabel
argument_list|,
name|childQueue
operator|.
name|getQueueCapacities
argument_list|()
operator|.
name|getAbsoluteMaximumCapacity
argument_list|(
name|label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Updating effective min resource for queue:"
operator|+
name|childQueue
operator|.
name|getQueueName
argument_list|()
operator|+
literal|" as effMinResource="
operator|+
name|childQueue
operator|.
name|getQueueResourceQuotas
argument_list|()
operator|.
name|getEffectiveMinResource
argument_list|(
name|label
argument_list|)
operator|+
literal|"and Updating effective max resource as effMaxResource="
operator|+
name|childQueue
operator|.
name|getQueueResourceQuotas
argument_list|()
operator|.
name|getEffectiveMaxResource
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getMinResourceNormalized (String name, Map<String, Float> effectiveMinRatio, Resource minResource)
specifier|private
name|Resource
name|getMinResourceNormalized
parameter_list|(
name|String
name|name
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|effectiveMinRatio
parameter_list|,
name|Resource
name|minResource
parameter_list|)
block|{
name|Resource
name|ret
init|=
name|Resource
operator|.
name|newInstance
argument_list|(
name|minResource
argument_list|)
decl_stmt|;
name|int
name|maxLength
init|=
name|ResourceUtils
operator|.
name|getNumberOfKnownResourceTypes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxLength
condition|;
name|i
operator|++
control|)
block|{
name|ResourceInformation
name|nResourceInformation
init|=
name|minResource
operator|.
name|getResourceInformation
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Float
name|ratio
init|=
name|effectiveMinRatio
operator|.
name|get
argument_list|(
name|nResourceInformation
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ratio
operator|!=
literal|null
condition|)
block|{
name|ret
operator|.
name|setResourceValue
argument_list|(
name|i
argument_list|,
call|(
name|long
call|)
argument_list|(
name|nResourceInformation
operator|.
name|getValue
argument_list|()
operator|*
name|ratio
operator|.
name|floatValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Updating min resource for Queue: "
operator|+
name|name
operator|+
literal|" as "
operator|+
name|ret
operator|.
name|getResourceInformation
argument_list|(
name|i
argument_list|)
operator|+
literal|", Actual resource: "
operator|+
name|nResourceInformation
operator|.
name|getValue
argument_list|()
operator|+
literal|", ratio: "
operator|+
name|ratio
operator|.
name|floatValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
DECL|method|getEffectiveMinRatioPerResource ( Resource configuredMinResources, Resource numeratorForMinRatio)
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|getEffectiveMinRatioPerResource
parameter_list|(
name|Resource
name|configuredMinResources
parameter_list|,
name|Resource
name|numeratorForMinRatio
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|effectiveMinRatioPerResource
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|numeratorForMinRatio
operator|!=
literal|null
condition|)
block|{
name|int
name|maxLength
init|=
name|ResourceUtils
operator|.
name|getNumberOfKnownResourceTypes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxLength
condition|;
name|i
operator|++
control|)
block|{
name|ResourceInformation
name|nResourceInformation
init|=
name|numeratorForMinRatio
operator|.
name|getResourceInformation
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|ResourceInformation
name|dResourceInformation
init|=
name|configuredMinResources
operator|.
name|getResourceInformation
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|nValue
init|=
name|nResourceInformation
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|long
name|dValue
init|=
name|UnitsConversionUtil
operator|.
name|convert
argument_list|(
name|dResourceInformation
operator|.
name|getUnits
argument_list|()
argument_list|,
name|nResourceInformation
operator|.
name|getUnits
argument_list|()
argument_list|,
name|dResourceInformation
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|dValue
operator|!=
literal|0
condition|)
block|{
name|effectiveMinRatioPerResource
operator|.
name|put
argument_list|(
name|nResourceInformation
operator|.
name|getName
argument_list|()
argument_list|,
operator|(
name|float
operator|)
name|nValue
operator|/
name|dValue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|effectiveMinRatioPerResource
return|;
block|}
DECL|method|deriveCapacityFromAbsoluteConfigurations (String label, Resource clusterResource, ResourceCalculator rc, CSQueue childQueue)
specifier|private
name|void
name|deriveCapacityFromAbsoluteConfigurations
parameter_list|(
name|String
name|label
parameter_list|,
name|Resource
name|clusterResource
parameter_list|,
name|ResourceCalculator
name|rc
parameter_list|,
name|CSQueue
name|childQueue
parameter_list|)
block|{
comment|/*      * In case when queues are configured with absolute resources, it is better      * to update capacity/max-capacity etc w.r.t absolute resource as well. In      * case of computation, these values wont be used any more. However for      * metrics and UI, its better these values are pre-computed here itself.      */
comment|// 1. Update capacity as a float based on parent's minResource
name|childQueue
operator|.
name|getQueueCapacities
argument_list|()
operator|.
name|setCapacity
argument_list|(
name|label
argument_list|,
name|rc
operator|.
name|divide
argument_list|(
name|clusterResource
argument_list|,
name|childQueue
operator|.
name|getQueueResourceQuotas
argument_list|()
operator|.
name|getEffectiveMinResource
argument_list|(
name|label
argument_list|)
argument_list|,
name|getQueueResourceQuotas
argument_list|()
operator|.
name|getEffectiveMinResource
argument_list|(
name|label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 2. Update max-capacity as a float based on parent's maxResource
name|childQueue
operator|.
name|getQueueCapacities
argument_list|()
operator|.
name|setMaximumCapacity
argument_list|(
name|label
argument_list|,
name|rc
operator|.
name|divide
argument_list|(
name|clusterResource
argument_list|,
name|childQueue
operator|.
name|getQueueResourceQuotas
argument_list|()
operator|.
name|getEffectiveMaxResource
argument_list|(
name|label
argument_list|)
argument_list|,
name|getQueueResourceQuotas
argument_list|()
operator|.
name|getEffectiveMaxResource
argument_list|(
name|label
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// 3. Update absolute capacity as a float based on parent's minResource and
comment|// cluster resource.
name|childQueue
operator|.
name|getQueueCapacities
argument_list|()
operator|.
name|setAbsoluteCapacity
argument_list|(
name|label
argument_list|,
operator|(
name|float
operator|)
name|childQueue
operator|.
name|getQueueCapacities
argument_list|()
operator|.
name|getCapacity
argument_list|()
operator|/
name|getQueueCapacities
argument_list|()
operator|.
name|getAbsoluteCapacity
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
comment|// 4. Update absolute max-capacity as a float based on parent's maxResource
comment|// and cluster resource.
name|childQueue
operator|.
name|getQueueCapacities
argument_list|()
operator|.
name|setAbsoluteMaximumCapacity
argument_list|(
name|label
argument_list|,
operator|(
name|float
operator|)
name|childQueue
operator|.
name|getQueueCapacities
argument_list|()
operator|.
name|getMaximumCapacity
argument_list|(
name|label
argument_list|)
operator|/
name|getQueueCapacities
argument_list|()
operator|.
name|getAbsoluteMaximumCapacity
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
comment|// Re-visit max applications for a queue based on absolute capacity if
comment|// needed.
if|if
condition|(
name|childQueue
operator|instanceof
name|LeafQueue
condition|)
block|{
name|LeafQueue
name|leafQueue
init|=
operator|(
name|LeafQueue
operator|)
name|childQueue
decl_stmt|;
name|CapacitySchedulerConfiguration
name|conf
init|=
name|csContext
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|int
name|maxApplications
init|=
call|(
name|int
call|)
argument_list|(
name|conf
operator|.
name|getMaximumSystemApplications
argument_list|()
operator|*
name|childQueue
operator|.
name|getQueueCapacities
argument_list|()
operator|.
name|getAbsoluteCapacity
argument_list|(
name|label
argument_list|)
argument_list|)
decl_stmt|;
name|leafQueue
operator|.
name|setMaxApplications
argument_list|(
name|maxApplications
argument_list|)
expr_stmt|;
name|int
name|maxApplicationsPerUser
init|=
name|Math
operator|.
name|min
argument_list|(
name|maxApplications
argument_list|,
call|(
name|int
call|)
argument_list|(
name|maxApplications
operator|*
operator|(
name|leafQueue
operator|.
name|getUsersManager
argument_list|()
operator|.
name|getUserLimit
argument_list|()
operator|/
literal|100.0f
operator|)
operator|*
name|leafQueue
operator|.
name|getUsersManager
argument_list|()
operator|.
name|getUserLimitFactor
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|leafQueue
operator|.
name|setMaxApplicationsPerUser
argument_list|(
name|maxApplicationsPerUser
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"LeafQueue:"
operator|+
name|leafQueue
operator|.
name|getQueueName
argument_list|()
operator|+
literal|", maxApplications="
operator|+
name|maxApplications
operator|+
literal|", maxApplicationsPerUser="
operator|+
name|maxApplicationsPerUser
operator|+
literal|", Abs Cap:"
operator|+
name|childQueue
operator|.
name|getQueueCapacities
argument_list|()
operator|.
name|getAbsoluteCapacity
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getChildQueues ()
specifier|public
name|List
argument_list|<
name|CSQueue
argument_list|>
name|getChildQueues
parameter_list|()
block|{
try|try
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
return|return
operator|new
name|ArrayList
argument_list|<
name|CSQueue
argument_list|>
argument_list|(
name|childQueues
argument_list|)
return|;
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|recoverContainer (Resource clusterResource, SchedulerApplicationAttempt attempt, RMContainer rmContainer)
specifier|public
name|void
name|recoverContainer
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|SchedulerApplicationAttempt
name|attempt
parameter_list|,
name|RMContainer
name|rmContainer
parameter_list|)
block|{
if|if
condition|(
name|rmContainer
operator|.
name|getState
argument_list|()
operator|.
name|equals
argument_list|(
name|RMContainerState
operator|.
name|COMPLETED
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|rmContainer
operator|.
name|getExecutionType
argument_list|()
operator|!=
name|ExecutionType
operator|.
name|GUARANTEED
condition|)
block|{
return|return;
block|}
comment|// Careful! Locking order is important!
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|FiCaSchedulerNode
name|node
init|=
name|scheduler
operator|.
name|getNode
argument_list|(
name|rmContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
name|allocateResource
argument_list|(
name|clusterResource
argument_list|,
name|rmContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getResource
argument_list|()
argument_list|,
name|node
operator|.
name|getPartition
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|parent
operator|.
name|recoverContainer
argument_list|(
name|clusterResource
argument_list|,
name|attempt
argument_list|,
name|rmContainer
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getAbstractUsersManager ()
specifier|public
name|ActiveUsersManager
name|getAbstractUsersManager
parameter_list|()
block|{
comment|// Should never be called since all applications are submitted to LeafQueues
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|collectSchedulerApplications ( Collection<ApplicationAttemptId> apps)
specifier|public
name|void
name|collectSchedulerApplications
parameter_list|(
name|Collection
argument_list|<
name|ApplicationAttemptId
argument_list|>
name|apps
parameter_list|)
block|{
try|try
block|{
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
for|for
control|(
name|CSQueue
name|queue
range|:
name|childQueues
control|)
block|{
name|queue
operator|.
name|collectSchedulerApplications
argument_list|(
name|apps
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|attachContainer (Resource clusterResource, FiCaSchedulerApp application, RMContainer rmContainer)
specifier|public
name|void
name|attachContainer
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|FiCaSchedulerApp
name|application
parameter_list|,
name|RMContainer
name|rmContainer
parameter_list|)
block|{
if|if
condition|(
name|application
operator|!=
literal|null
condition|)
block|{
name|FiCaSchedulerNode
name|node
init|=
name|scheduler
operator|.
name|getNode
argument_list|(
name|rmContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
name|allocateResource
argument_list|(
name|clusterResource
argument_list|,
name|rmContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getResource
argument_list|()
argument_list|,
name|node
operator|.
name|getPartition
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"movedContainer"
operator|+
literal|" queueMoveIn="
operator|+
name|getQueueName
argument_list|()
operator|+
literal|" usedCapacity="
operator|+
name|getUsedCapacity
argument_list|()
operator|+
literal|" absoluteUsedCapacity="
operator|+
name|getAbsoluteUsedCapacity
argument_list|()
operator|+
literal|" used="
operator|+
name|queueUsage
operator|.
name|getUsed
argument_list|()
operator|+
literal|" cluster="
operator|+
name|clusterResource
argument_list|)
expr_stmt|;
comment|// Inform the parent
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|parent
operator|.
name|attachContainer
argument_list|(
name|clusterResource
argument_list|,
name|application
argument_list|,
name|rmContainer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|detachContainer (Resource clusterResource, FiCaSchedulerApp application, RMContainer rmContainer)
specifier|public
name|void
name|detachContainer
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|FiCaSchedulerApp
name|application
parameter_list|,
name|RMContainer
name|rmContainer
parameter_list|)
block|{
if|if
condition|(
name|application
operator|!=
literal|null
condition|)
block|{
name|FiCaSchedulerNode
name|node
init|=
name|scheduler
operator|.
name|getNode
argument_list|(
name|rmContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
name|super
operator|.
name|releaseResource
argument_list|(
name|clusterResource
argument_list|,
name|rmContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getResource
argument_list|()
argument_list|,
name|node
operator|.
name|getPartition
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"movedContainer"
operator|+
literal|" queueMoveOut="
operator|+
name|getQueueName
argument_list|()
operator|+
literal|" usedCapacity="
operator|+
name|getUsedCapacity
argument_list|()
operator|+
literal|" absoluteUsedCapacity="
operator|+
name|getAbsoluteUsedCapacity
argument_list|()
operator|+
literal|" used="
operator|+
name|queueUsage
operator|.
name|getUsed
argument_list|()
operator|+
literal|" cluster="
operator|+
name|clusterResource
argument_list|)
expr_stmt|;
comment|// Inform the parent
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|parent
operator|.
name|detachContainer
argument_list|(
name|clusterResource
argument_list|,
name|application
argument_list|,
name|rmContainer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getNumApplications ()
specifier|public
name|int
name|getNumApplications
parameter_list|()
block|{
return|return
name|numApplications
return|;
block|}
DECL|method|allocateResource (Resource clusterResource, Resource resource, String nodePartition)
name|void
name|allocateResource
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|Resource
name|resource
parameter_list|,
name|String
name|nodePartition
parameter_list|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|super
operator|.
name|allocateResource
argument_list|(
name|clusterResource
argument_list|,
name|resource
argument_list|,
name|nodePartition
argument_list|)
expr_stmt|;
comment|/**        * check if we need to kill (killable) containers if maximum resource violated.        * Doing this because we will deduct killable resource when going from root.        * For example:        *<pre>        *      Root        *      /   \        *     a     b        *   /  \        *  a1  a2        *</pre>        *        * a: max=10G, used=10G, killable=2G        * a1: used=8G, killable=2G        * a2: used=2G, pending=2G, killable=0G        *        * When we get queue-a to allocate resource, even if queue-a        * reaches its max resource, we deduct its used by killable, so we can allocate        * at most 2G resources. ResourceLimits passed down to a2 has headroom set to 2G.        *        * If scheduler finds a 2G available resource in existing cluster, and assigns it        * to a2, now a2's used= 2G + 2G = 4G, and a's used = 8G + 4G = 12G> 10G        *        * When this happens, we have to preempt killable container (on same or different        * nodes) of parent queue to avoid violating parent's max resource.        */
if|if
condition|(
operator|!
name|queueResourceQuotas
operator|.
name|getEffectiveMaxResource
argument_list|(
name|nodePartition
argument_list|)
operator|.
name|equals
argument_list|(
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|Resources
operator|.
name|lessThan
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|queueResourceQuotas
operator|.
name|getEffectiveMaxResource
argument_list|(
name|nodePartition
argument_list|)
argument_list|,
name|queueUsage
operator|.
name|getUsed
argument_list|(
name|nodePartition
argument_list|)
argument_list|)
condition|)
block|{
name|killContainersToEnforceMaxQueueCapacity
argument_list|(
name|nodePartition
argument_list|,
name|clusterResource
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|getQueueCapacities
argument_list|()
operator|.
name|getAbsoluteMaximumCapacity
argument_list|(
name|nodePartition
argument_list|)
operator|<
name|getQueueCapacities
argument_list|()
operator|.
name|getAbsoluteUsedCapacity
argument_list|(
name|nodePartition
argument_list|)
condition|)
block|{
name|killContainersToEnforceMaxQueueCapacity
argument_list|(
name|nodePartition
argument_list|,
name|clusterResource
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|killContainersToEnforceMaxQueueCapacity (String partition, Resource clusterResource)
specifier|private
name|void
name|killContainersToEnforceMaxQueueCapacity
parameter_list|(
name|String
name|partition
parameter_list|,
name|Resource
name|clusterResource
parameter_list|)
block|{
name|Iterator
argument_list|<
name|RMContainer
argument_list|>
name|killableContainerIter
init|=
name|getKillableContainers
argument_list|(
name|partition
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|killableContainerIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return;
block|}
name|Resource
name|partitionResource
init|=
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|partition
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Resource
name|maxResource
init|=
name|getEffectiveMaxCapacity
argument_list|(
name|partition
argument_list|)
decl_stmt|;
while|while
condition|(
name|Resources
operator|.
name|greaterThan
argument_list|(
name|resourceCalculator
argument_list|,
name|partitionResource
argument_list|,
name|queueUsage
operator|.
name|getUsed
argument_list|(
name|partition
argument_list|)
argument_list|,
name|maxResource
argument_list|)
condition|)
block|{
name|RMContainer
name|toKillContainer
init|=
name|killableContainerIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|FiCaSchedulerApp
name|attempt
init|=
name|csContext
operator|.
name|getApplicationAttempt
argument_list|(
name|toKillContainer
operator|.
name|getContainerId
argument_list|()
operator|.
name|getApplicationAttemptId
argument_list|()
argument_list|)
decl_stmt|;
name|FiCaSchedulerNode
name|node
init|=
name|csContext
operator|.
name|getNode
argument_list|(
name|toKillContainer
operator|.
name|getAllocatedNode
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|attempt
operator|&&
literal|null
operator|!=
name|node
condition|)
block|{
name|LeafQueue
name|lq
init|=
name|attempt
operator|.
name|getCSLeafQueue
argument_list|()
decl_stmt|;
name|lq
operator|.
name|completedContainer
argument_list|(
name|clusterResource
argument_list|,
name|attempt
argument_list|,
name|node
argument_list|,
name|toKillContainer
argument_list|,
name|SchedulerUtils
operator|.
name|createPreemptedContainerStatus
argument_list|(
name|toKillContainer
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|SchedulerUtils
operator|.
name|PREEMPTED_CONTAINER
argument_list|)
argument_list|,
name|RMContainerEventType
operator|.
name|KILL
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Killed container="
operator|+
name|toKillContainer
operator|.
name|getContainerId
argument_list|()
operator|+
literal|" from queue="
operator|+
name|lq
operator|.
name|getQueueName
argument_list|()
operator|+
literal|" to make queue="
operator|+
name|this
operator|.
name|getQueueName
argument_list|()
operator|+
literal|"'s max-capacity enforced"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|killableContainerIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
block|}
DECL|method|apply (Resource cluster, ResourceCommitRequest<FiCaSchedulerApp, FiCaSchedulerNode> request)
specifier|public
name|void
name|apply
parameter_list|(
name|Resource
name|cluster
parameter_list|,
name|ResourceCommitRequest
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
name|request
parameter_list|)
block|{
if|if
condition|(
name|request
operator|.
name|anythingAllocatedOrReserved
argument_list|()
condition|)
block|{
name|ContainerAllocationProposal
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
name|allocation
init|=
name|request
operator|.
name|getFirstAllocatedOrReservedContainer
argument_list|()
decl_stmt|;
name|SchedulerContainer
argument_list|<
name|FiCaSchedulerApp
argument_list|,
name|FiCaSchedulerNode
argument_list|>
name|schedulerContainer
init|=
name|allocation
operator|.
name|getAllocatedOrReservedContainer
argument_list|()
decl_stmt|;
comment|// Do not modify queue when allocation from reserved container
if|if
condition|(
name|allocation
operator|.
name|getAllocateFromReservedContainer
argument_list|()
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// Book-keeping
comment|// Note: Update headroom to account for current allocation too...
name|allocateResource
argument_list|(
name|cluster
argument_list|,
name|allocation
operator|.
name|getAllocatedOrReservedResource
argument_list|()
argument_list|,
name|schedulerContainer
operator|.
name|getNodePartition
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"assignedContainer"
operator|+
literal|" queue="
operator|+
name|getQueueName
argument_list|()
operator|+
literal|" usedCapacity="
operator|+
name|getUsedCapacity
argument_list|()
operator|+
literal|" absoluteUsedCapacity="
operator|+
name|getAbsoluteUsedCapacity
argument_list|()
operator|+
literal|" used="
operator|+
name|queueUsage
operator|.
name|getUsed
argument_list|()
operator|+
literal|" cluster="
operator|+
name|cluster
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|parent
operator|.
name|apply
argument_list|(
name|cluster
argument_list|,
name|request
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|stopQueue ()
specifier|public
name|void
name|stopQueue
parameter_list|()
block|{
try|try
block|{
name|this
operator|.
name|writeLock
operator|.
name|lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|getNumApplications
argument_list|()
operator|>
literal|0
condition|)
block|{
name|updateQueueState
argument_list|(
name|QueueState
operator|.
name|DRAINING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|updateQueueState
argument_list|(
name|QueueState
operator|.
name|STOPPED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getChildQueues
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|CSQueue
name|child
range|:
name|getChildQueues
argument_list|()
control|)
block|{
name|child
operator|.
name|stopQueue
argument_list|()
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|writeLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getQueueOrderingPolicy ()
specifier|public
name|QueueOrderingPolicy
name|getQueueOrderingPolicy
parameter_list|()
block|{
return|return
name|queueOrderingPolicy
return|;
block|}
block|}
end_class

end_unit

