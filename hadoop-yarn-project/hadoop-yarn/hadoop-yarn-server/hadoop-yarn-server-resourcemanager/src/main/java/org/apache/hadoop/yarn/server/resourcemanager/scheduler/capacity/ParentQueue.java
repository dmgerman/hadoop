begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/** * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|Private
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
operator|.
name|Evolving
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|AccessControlList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationAttemptId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueUserACLInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|factories
operator|.
name|RecordFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|factory
operator|.
name|providers
operator|.
name|RecordFactoryProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|nodelabels
operator|.
name|CommonNodeLabelsManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|security
operator|.
name|AccessType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|nodelabels
operator|.
name|RMNodeLabelsManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainerEventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainerState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|ActiveUsersManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|NodeType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|ResourceLimits
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|SchedulerApplicationAttempt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|SchedulerUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|fica
operator|.
name|FiCaSchedulerApp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|fica
operator|.
name|FiCaSchedulerNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|Resources
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_class
annotation|@
name|Private
annotation|@
name|Evolving
DECL|class|ParentQueue
specifier|public
class|class
name|ParentQueue
extends|extends
name|AbstractCSQueue
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ParentQueue
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|childQueues
specifier|protected
specifier|final
name|Set
argument_list|<
name|CSQueue
argument_list|>
name|childQueues
decl_stmt|;
DECL|field|rootQueue
specifier|private
specifier|final
name|boolean
name|rootQueue
decl_stmt|;
DECL|field|queueComparator
specifier|final
name|Comparator
argument_list|<
name|CSQueue
argument_list|>
name|queueComparator
decl_stmt|;
DECL|field|numApplications
specifier|volatile
name|int
name|numApplications
decl_stmt|;
DECL|field|scheduler
specifier|private
specifier|final
name|CapacitySchedulerContext
name|scheduler
decl_stmt|;
DECL|field|recordFactory
specifier|private
specifier|final
name|RecordFactory
name|recordFactory
init|=
name|RecordFactoryProvider
operator|.
name|getRecordFactory
argument_list|(
literal|null
argument_list|)
decl_stmt|;
DECL|method|ParentQueue (CapacitySchedulerContext cs, String queueName, CSQueue parent, CSQueue old)
specifier|public
name|ParentQueue
parameter_list|(
name|CapacitySchedulerContext
name|cs
parameter_list|,
name|String
name|queueName
parameter_list|,
name|CSQueue
name|parent
parameter_list|,
name|CSQueue
name|old
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|cs
argument_list|,
name|queueName
argument_list|,
name|parent
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|this
operator|.
name|scheduler
operator|=
name|cs
expr_stmt|;
name|this
operator|.
name|queueComparator
operator|=
name|cs
operator|.
name|getQueueComparator
argument_list|()
expr_stmt|;
name|this
operator|.
name|rootQueue
operator|=
operator|(
name|parent
operator|==
literal|null
operator|)
expr_stmt|;
name|float
name|rawCapacity
init|=
name|cs
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getNonLabeledQueueCapacity
argument_list|(
name|getQueuePath
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rootQueue
operator|&&
operator|(
name|rawCapacity
operator|!=
name|CapacitySchedulerConfiguration
operator|.
name|MAXIMUM_CAPACITY_VALUE
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal "
operator|+
literal|"capacity of "
operator|+
name|rawCapacity
operator|+
literal|" for queue "
operator|+
name|queueName
operator|+
literal|". Must be "
operator|+
name|CapacitySchedulerConfiguration
operator|.
name|MAXIMUM_CAPACITY_VALUE
argument_list|)
throw|;
block|}
name|this
operator|.
name|childQueues
operator|=
operator|new
name|TreeSet
argument_list|<
name|CSQueue
argument_list|>
argument_list|(
name|queueComparator
argument_list|)
expr_stmt|;
name|setupQueueConfigs
argument_list|(
name|cs
operator|.
name|getClusterResource
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Initialized parent-queue "
operator|+
name|queueName
operator|+
literal|" name="
operator|+
name|queueName
operator|+
literal|", fullname="
operator|+
name|getQueuePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|setupQueueConfigs (Resource clusterResource)
specifier|synchronized
name|void
name|setupQueueConfigs
parameter_list|(
name|Resource
name|clusterResource
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|setupQueueConfigs
argument_list|(
name|clusterResource
argument_list|)
expr_stmt|;
name|StringBuilder
name|aclsString
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|AccessType
argument_list|,
name|AccessControlList
argument_list|>
name|e
range|:
name|acls
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|aclsString
operator|.
name|append
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
operator|+
literal|":"
operator|+
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getAclString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|StringBuilder
name|labelStrBuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|accessibleLabels
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|s
range|:
name|accessibleLabels
control|)
block|{
name|labelStrBuilder
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|labelStrBuilder
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|queueName
operator|+
literal|", capacity="
operator|+
name|this
operator|.
name|queueCapacities
operator|.
name|getCapacity
argument_list|()
operator|+
literal|", asboluteCapacity="
operator|+
name|this
operator|.
name|queueCapacities
operator|.
name|getAbsoluteCapacity
argument_list|()
operator|+
literal|", maxCapacity="
operator|+
name|this
operator|.
name|queueCapacities
operator|.
name|getMaximumCapacity
argument_list|()
operator|+
literal|", asboluteMaxCapacity="
operator|+
name|this
operator|.
name|queueCapacities
operator|.
name|getAbsoluteMaximumCapacity
argument_list|()
operator|+
literal|", state="
operator|+
name|state
operator|+
literal|", acls="
operator|+
name|aclsString
operator|+
literal|", labels="
operator|+
name|labelStrBuilder
operator|.
name|toString
argument_list|()
operator|+
literal|"\n"
operator|+
literal|", reservationsContinueLooking="
operator|+
name|reservationsContinueLooking
argument_list|)
expr_stmt|;
block|}
DECL|field|PRECISION
specifier|private
specifier|static
name|float
name|PRECISION
init|=
literal|0.0005f
decl_stmt|;
comment|// 0.05% precision
DECL|method|setChildQueues (Collection<CSQueue> childQueues)
specifier|synchronized
name|void
name|setChildQueues
parameter_list|(
name|Collection
argument_list|<
name|CSQueue
argument_list|>
name|childQueues
parameter_list|)
block|{
comment|// Validate
name|float
name|childCapacities
init|=
literal|0
decl_stmt|;
for|for
control|(
name|CSQueue
name|queue
range|:
name|childQueues
control|)
block|{
name|childCapacities
operator|+=
name|queue
operator|.
name|getCapacity
argument_list|()
expr_stmt|;
block|}
name|float
name|delta
init|=
name|Math
operator|.
name|abs
argument_list|(
literal|1.0f
operator|-
name|childCapacities
argument_list|)
decl_stmt|;
comment|// crude way to check
comment|// allow capacities being set to 0, and enforce child 0 if parent is 0
if|if
condition|(
operator|(
operator|(
name|queueCapacities
operator|.
name|getCapacity
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|(
name|delta
operator|>
name|PRECISION
operator|)
operator|)
operator|||
operator|(
operator|(
name|queueCapacities
operator|.
name|getCapacity
argument_list|()
operator|==
literal|0
operator|)
operator|&&
operator|(
name|childCapacities
operator|>
literal|0
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal"
operator|+
literal|" capacity of "
operator|+
name|childCapacities
operator|+
literal|" for children of queue "
operator|+
name|queueName
argument_list|)
throw|;
block|}
comment|// check label capacities
for|for
control|(
name|String
name|nodeLabel
range|:
name|labelManager
operator|.
name|getClusterNodeLabels
argument_list|()
control|)
block|{
name|float
name|capacityByLabel
init|=
name|queueCapacities
operator|.
name|getCapacity
argument_list|(
name|nodeLabel
argument_list|)
decl_stmt|;
comment|// check children's labels
name|float
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|CSQueue
name|queue
range|:
name|childQueues
control|)
block|{
name|sum
operator|+=
name|queue
operator|.
name|getQueueCapacities
argument_list|()
operator|.
name|getCapacity
argument_list|(
name|nodeLabel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|capacityByLabel
operator|>
literal|0
operator|&&
name|Math
operator|.
name|abs
argument_list|(
literal|1.0f
operator|-
name|sum
argument_list|)
operator|>
name|PRECISION
operator|)
operator|||
operator|(
name|capacityByLabel
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sum
operator|>
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal"
operator|+
literal|" capacity of "
operator|+
name|sum
operator|+
literal|" for children of queue "
operator|+
name|queueName
operator|+
literal|" for label="
operator|+
name|nodeLabel
argument_list|)
throw|;
block|}
block|}
name|this
operator|.
name|childQueues
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|childQueues
operator|.
name|addAll
argument_list|(
name|childQueues
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"setChildQueues: "
operator|+
name|getChildQueuesToPrint
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getQueuePath ()
specifier|public
name|String
name|getQueuePath
parameter_list|()
block|{
name|String
name|parentPath
init|=
operator|(
operator|(
name|parent
operator|==
literal|null
operator|)
condition|?
literal|""
else|:
operator|(
name|parent
operator|.
name|getQueuePath
argument_list|()
operator|+
literal|"."
operator|)
operator|)
decl_stmt|;
return|return
name|parentPath
operator|+
name|getQueueName
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getQueueInfo ( boolean includeChildQueues, boolean recursive)
specifier|public
specifier|synchronized
name|QueueInfo
name|getQueueInfo
parameter_list|(
name|boolean
name|includeChildQueues
parameter_list|,
name|boolean
name|recursive
parameter_list|)
block|{
name|QueueInfo
name|queueInfo
init|=
name|getQueueInfo
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|QueueInfo
argument_list|>
name|childQueuesInfo
init|=
operator|new
name|ArrayList
argument_list|<
name|QueueInfo
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|includeChildQueues
condition|)
block|{
for|for
control|(
name|CSQueue
name|child
range|:
name|childQueues
control|)
block|{
comment|// Get queue information recursively?
name|childQueuesInfo
operator|.
name|add
argument_list|(
name|child
operator|.
name|getQueueInfo
argument_list|(
name|recursive
argument_list|,
name|recursive
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|queueInfo
operator|.
name|setChildQueues
argument_list|(
name|childQueuesInfo
argument_list|)
expr_stmt|;
return|return
name|queueInfo
return|;
block|}
DECL|method|getUserAclInfo ( UserGroupInformation user)
specifier|private
specifier|synchronized
name|QueueUserACLInfo
name|getUserAclInfo
parameter_list|(
name|UserGroupInformation
name|user
parameter_list|)
block|{
name|QueueUserACLInfo
name|userAclInfo
init|=
name|recordFactory
operator|.
name|newRecordInstance
argument_list|(
name|QueueUserACLInfo
operator|.
name|class
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|QueueACL
argument_list|>
name|operations
init|=
operator|new
name|ArrayList
argument_list|<
name|QueueACL
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|QueueACL
name|operation
range|:
name|QueueACL
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|hasAccess
argument_list|(
name|operation
argument_list|,
name|user
argument_list|)
condition|)
block|{
name|operations
operator|.
name|add
argument_list|(
name|operation
argument_list|)
expr_stmt|;
block|}
block|}
name|userAclInfo
operator|.
name|setQueueName
argument_list|(
name|getQueueName
argument_list|()
argument_list|)
expr_stmt|;
name|userAclInfo
operator|.
name|setUserAcls
argument_list|(
name|operations
argument_list|)
expr_stmt|;
return|return
name|userAclInfo
return|;
block|}
annotation|@
name|Override
DECL|method|getQueueUserAclInfo ( UserGroupInformation user)
specifier|public
specifier|synchronized
name|List
argument_list|<
name|QueueUserACLInfo
argument_list|>
name|getQueueUserAclInfo
parameter_list|(
name|UserGroupInformation
name|user
parameter_list|)
block|{
name|List
argument_list|<
name|QueueUserACLInfo
argument_list|>
name|userAcls
init|=
operator|new
name|ArrayList
argument_list|<
name|QueueUserACLInfo
argument_list|>
argument_list|()
decl_stmt|;
comment|// Add parent queue acls
name|userAcls
operator|.
name|add
argument_list|(
name|getUserAclInfo
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
comment|// Add children queue acls
for|for
control|(
name|CSQueue
name|child
range|:
name|childQueues
control|)
block|{
name|userAcls
operator|.
name|addAll
argument_list|(
name|child
operator|.
name|getQueueUserAclInfo
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|userAcls
return|;
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|queueName
operator|+
literal|": "
operator|+
literal|"numChildQueue= "
operator|+
name|childQueues
operator|.
name|size
argument_list|()
operator|+
literal|", "
operator|+
literal|"capacity="
operator|+
name|queueCapacities
operator|.
name|getCapacity
argument_list|()
operator|+
literal|", "
operator|+
literal|"absoluteCapacity="
operator|+
name|queueCapacities
operator|.
name|getAbsoluteCapacity
argument_list|()
operator|+
literal|", "
operator|+
literal|"usedResources="
operator|+
name|queueUsage
operator|.
name|getUsed
argument_list|()
operator|+
literal|"usedCapacity="
operator|+
name|getUsedCapacity
argument_list|()
operator|+
literal|", "
operator|+
literal|"numApps="
operator|+
name|getNumApplications
argument_list|()
operator|+
literal|", "
operator|+
literal|"numContainers="
operator|+
name|getNumContainers
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|reinitialize (CSQueue newlyParsedQueue, Resource clusterResource)
specifier|public
specifier|synchronized
name|void
name|reinitialize
parameter_list|(
name|CSQueue
name|newlyParsedQueue
parameter_list|,
name|Resource
name|clusterResource
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Sanity check
if|if
condition|(
operator|!
operator|(
name|newlyParsedQueue
operator|instanceof
name|ParentQueue
operator|)
operator|||
operator|!
name|newlyParsedQueue
operator|.
name|getQueuePath
argument_list|()
operator|.
name|equals
argument_list|(
name|getQueuePath
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Trying to reinitialize "
operator|+
name|getQueuePath
argument_list|()
operator|+
literal|" from "
operator|+
name|newlyParsedQueue
operator|.
name|getQueuePath
argument_list|()
argument_list|)
throw|;
block|}
name|ParentQueue
name|newlyParsedParentQueue
init|=
operator|(
name|ParentQueue
operator|)
name|newlyParsedQueue
decl_stmt|;
comment|// Set new configs
name|setupQueueConfigs
argument_list|(
name|clusterResource
argument_list|)
expr_stmt|;
comment|// Re-configure existing child queues and add new ones
comment|// The CS has already checked to ensure all existing child queues are present!
name|Map
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|currentChildQueues
init|=
name|getQueues
argument_list|(
name|childQueues
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|newChildQueues
init|=
name|getQueues
argument_list|(
name|newlyParsedParentQueue
operator|.
name|childQueues
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|e
range|:
name|newChildQueues
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|newChildQueueName
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|CSQueue
name|newChildQueue
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|CSQueue
name|childQueue
init|=
name|currentChildQueues
operator|.
name|get
argument_list|(
name|newChildQueueName
argument_list|)
decl_stmt|;
comment|// Check if the child-queue already exists
if|if
condition|(
name|childQueue
operator|!=
literal|null
condition|)
block|{
comment|// Re-init existing child queues
name|childQueue
operator|.
name|reinitialize
argument_list|(
name|newChildQueue
argument_list|,
name|clusterResource
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getQueueName
argument_list|()
operator|+
literal|": re-configured queue: "
operator|+
name|childQueue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// New child queue, do not re-init
comment|// Set parent to 'this'
name|newChildQueue
operator|.
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Save in list of current child queues
name|currentChildQueues
operator|.
name|put
argument_list|(
name|newChildQueueName
argument_list|,
name|newChildQueue
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getQueueName
argument_list|()
operator|+
literal|": added new child queue: "
operator|+
name|newChildQueue
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Re-sort all queues
name|childQueues
operator|.
name|clear
argument_list|()
expr_stmt|;
name|childQueues
operator|.
name|addAll
argument_list|(
name|currentChildQueues
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|getQueues (Set<CSQueue> queues)
name|Map
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|getQueues
parameter_list|(
name|Set
argument_list|<
name|CSQueue
argument_list|>
name|queues
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|queuesMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|CSQueue
name|queue
range|:
name|queues
control|)
block|{
name|queuesMap
operator|.
name|put
argument_list|(
name|queue
operator|.
name|getQueueName
argument_list|()
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
return|return
name|queuesMap
return|;
block|}
annotation|@
name|Override
DECL|method|submitApplication (ApplicationId applicationId, String user, String queue)
specifier|public
name|void
name|submitApplication
parameter_list|(
name|ApplicationId
name|applicationId
parameter_list|,
name|String
name|user
parameter_list|,
name|String
name|queue
parameter_list|)
throws|throws
name|AccessControlException
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// Sanity check
if|if
condition|(
name|queue
operator|.
name|equals
argument_list|(
name|queueName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"Cannot submit application "
operator|+
literal|"to non-leaf queue: "
operator|+
name|queueName
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|!=
name|QueueState
operator|.
name|RUNNING
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"Queue "
operator|+
name|getQueuePath
argument_list|()
operator|+
literal|" is STOPPED. Cannot accept submission of application: "
operator|+
name|applicationId
argument_list|)
throw|;
block|}
name|addApplication
argument_list|(
name|applicationId
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
comment|// Inform the parent queue
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|parent
operator|.
name|submitApplication
argument_list|(
name|applicationId
argument_list|,
name|user
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|ace
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to submit application to parent-queue: "
operator|+
name|parent
operator|.
name|getQueuePath
argument_list|()
argument_list|,
name|ace
argument_list|)
expr_stmt|;
name|removeApplication
argument_list|(
name|applicationId
argument_list|,
name|user
argument_list|)
expr_stmt|;
throw|throw
name|ace
throw|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|submitApplicationAttempt (FiCaSchedulerApp application, String userName)
specifier|public
name|void
name|submitApplicationAttempt
parameter_list|(
name|FiCaSchedulerApp
name|application
parameter_list|,
name|String
name|userName
parameter_list|)
block|{
comment|// submit attempt logic.
block|}
annotation|@
name|Override
DECL|method|finishApplicationAttempt (FiCaSchedulerApp application, String queue)
specifier|public
name|void
name|finishApplicationAttempt
parameter_list|(
name|FiCaSchedulerApp
name|application
parameter_list|,
name|String
name|queue
parameter_list|)
block|{
comment|// finish attempt logic.
block|}
DECL|method|addApplication (ApplicationId applicationId, String user)
specifier|private
specifier|synchronized
name|void
name|addApplication
parameter_list|(
name|ApplicationId
name|applicationId
parameter_list|,
name|String
name|user
parameter_list|)
block|{
operator|++
name|numApplications
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Application added -"
operator|+
literal|" appId: "
operator|+
name|applicationId
operator|+
literal|" user: "
operator|+
name|user
operator|+
literal|" leaf-queue of parent: "
operator|+
name|getQueueName
argument_list|()
operator|+
literal|" #applications: "
operator|+
name|getNumApplications
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|finishApplication (ApplicationId application, String user)
specifier|public
name|void
name|finishApplication
parameter_list|(
name|ApplicationId
name|application
parameter_list|,
name|String
name|user
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|removeApplication
argument_list|(
name|application
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
comment|// Inform the parent queue
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|parent
operator|.
name|finishApplication
argument_list|(
name|application
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeApplication (ApplicationId applicationId, String user)
specifier|private
specifier|synchronized
name|void
name|removeApplication
parameter_list|(
name|ApplicationId
name|applicationId
parameter_list|,
name|String
name|user
parameter_list|)
block|{
operator|--
name|numApplications
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Application removed -"
operator|+
literal|" appId: "
operator|+
name|applicationId
operator|+
literal|" user: "
operator|+
name|user
operator|+
literal|" leaf-queue of parent: "
operator|+
name|getQueueName
argument_list|()
operator|+
literal|" #applications: "
operator|+
name|getNumApplications
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|assignContainers (Resource clusterResource, FiCaSchedulerNode node, boolean needToUnreserve, ResourceLimits resourceLimits)
specifier|public
specifier|synchronized
name|CSAssignment
name|assignContainers
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|FiCaSchedulerNode
name|node
parameter_list|,
name|boolean
name|needToUnreserve
parameter_list|,
name|ResourceLimits
name|resourceLimits
parameter_list|)
block|{
name|CSAssignment
name|assignment
init|=
operator|new
name|CSAssignment
argument_list|(
name|Resources
operator|.
name|createResource
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NodeType
operator|.
name|NODE_LOCAL
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|nodeLabels
init|=
name|node
operator|.
name|getLabels
argument_list|()
decl_stmt|;
comment|// if our queue cannot access this node, just return
if|if
condition|(
operator|!
name|SchedulerUtils
operator|.
name|checkQueueAccessToNode
argument_list|(
name|accessibleLabels
argument_list|,
name|nodeLabels
argument_list|)
condition|)
block|{
return|return
name|assignment
return|;
block|}
while|while
condition|(
name|canAssign
argument_list|(
name|clusterResource
argument_list|,
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying to assign containers to child-queue of "
operator|+
name|getQueueName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|boolean
name|localNeedToUnreserve
init|=
literal|false
decl_stmt|;
comment|// Are we over maximum-capacity for this queue?
if|if
condition|(
operator|!
name|canAssignToThisQueue
argument_list|(
name|clusterResource
argument_list|,
name|nodeLabels
argument_list|)
condition|)
block|{
comment|// check to see if we could if we unreserve first
name|localNeedToUnreserve
operator|=
name|assignToQueueIfUnreserve
argument_list|(
name|clusterResource
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|localNeedToUnreserve
condition|)
block|{
break|break;
block|}
block|}
comment|// Schedule
name|CSAssignment
name|assignedToChild
init|=
name|assignContainersToChildQueues
argument_list|(
name|clusterResource
argument_list|,
name|node
argument_list|,
name|localNeedToUnreserve
operator||
name|needToUnreserve
argument_list|,
name|resourceLimits
argument_list|)
decl_stmt|;
name|assignment
operator|.
name|setType
argument_list|(
name|assignedToChild
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
comment|// Done if no child-queue assigned anything
if|if
condition|(
name|Resources
operator|.
name|greaterThan
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|assignedToChild
operator|.
name|getResource
argument_list|()
argument_list|,
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
condition|)
block|{
comment|// Track resource utilization for the parent-queue
name|super
operator|.
name|allocateResource
argument_list|(
name|clusterResource
argument_list|,
name|assignedToChild
operator|.
name|getResource
argument_list|()
argument_list|,
name|nodeLabels
argument_list|)
expr_stmt|;
comment|// Track resource utilization in this pass of the scheduler
name|Resources
operator|.
name|addTo
argument_list|(
name|assignment
operator|.
name|getResource
argument_list|()
argument_list|,
name|assignedToChild
operator|.
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"assignedContainer"
operator|+
literal|" queue="
operator|+
name|getQueueName
argument_list|()
operator|+
literal|" usedCapacity="
operator|+
name|getUsedCapacity
argument_list|()
operator|+
literal|" absoluteUsedCapacity="
operator|+
name|getAbsoluteUsedCapacity
argument_list|()
operator|+
literal|" used="
operator|+
name|queueUsage
operator|.
name|getUsed
argument_list|()
operator|+
literal|" cluster="
operator|+
name|clusterResource
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ParentQ="
operator|+
name|getQueueName
argument_list|()
operator|+
literal|" assignedSoFarInThisIteration="
operator|+
name|assignment
operator|.
name|getResource
argument_list|()
operator|+
literal|" usedCapacity="
operator|+
name|getUsedCapacity
argument_list|()
operator|+
literal|" absoluteUsedCapacity="
operator|+
name|getAbsoluteUsedCapacity
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Do not assign more than one container if this isn't the root queue
comment|// or if we've already assigned an off-switch container
if|if
condition|(
operator|!
name|rootQueue
operator|||
name|assignment
operator|.
name|getType
argument_list|()
operator|==
name|NodeType
operator|.
name|OFF_SWITCH
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|rootQueue
operator|&&
name|assignment
operator|.
name|getType
argument_list|()
operator|==
name|NodeType
operator|.
name|OFF_SWITCH
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not assigning more than one off-switch container,"
operator|+
literal|" assignments so far: "
operator|+
name|assignment
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
return|return
name|assignment
return|;
block|}
DECL|method|canAssignToThisQueue (Resource clusterResource, Set<String> nodeLabels)
specifier|private
specifier|synchronized
name|boolean
name|canAssignToThisQueue
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|nodeLabels
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|labelCanAccess
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|accessibleLabels
operator|.
name|contains
argument_list|(
name|CommonNodeLabelsManager
operator|.
name|ANY
argument_list|)
condition|?
name|nodeLabels
else|:
name|Sets
operator|.
name|intersection
argument_list|(
name|accessibleLabels
argument_list|,
name|nodeLabels
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeLabels
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Any queue can always access any node without label
name|labelCanAccess
operator|.
name|add
argument_list|(
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|)
expr_stmt|;
block|}
name|boolean
name|canAssign
init|=
literal|true
decl_stmt|;
for|for
control|(
name|String
name|label
range|:
name|labelCanAccess
control|)
block|{
name|float
name|currentAbsoluteLabelUsedCapacity
init|=
name|Resources
operator|.
name|divide
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|queueUsage
operator|.
name|getUsed
argument_list|(
name|label
argument_list|)
argument_list|,
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|label
argument_list|,
name|clusterResource
argument_list|)
argument_list|)
decl_stmt|;
comment|// if any of the label doesn't beyond limit, we can allocate on this node
if|if
condition|(
name|currentAbsoluteLabelUsedCapacity
operator|>=
name|queueCapacities
operator|.
name|getAbsoluteMaximumCapacity
argument_list|(
name|label
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getQueueName
argument_list|()
operator|+
literal|" used="
operator|+
name|queueUsage
operator|.
name|getUsed
argument_list|()
operator|+
literal|" current-capacity ("
operator|+
name|queueUsage
operator|.
name|getUsed
argument_list|(
name|label
argument_list|)
operator|+
literal|") "
operator|+
literal|">= max-capacity ("
operator|+
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|label
argument_list|,
name|clusterResource
argument_list|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
name|canAssign
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
return|return
name|canAssign
return|;
block|}
DECL|method|assignToQueueIfUnreserve (Resource clusterResource)
specifier|private
specifier|synchronized
name|boolean
name|assignToQueueIfUnreserve
parameter_list|(
name|Resource
name|clusterResource
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|reservationsContinueLooking
condition|)
block|{
comment|// check to see if we could potentially use this node instead of a reserved
comment|// node
name|Resource
name|reservedResources
init|=
name|Resources
operator|.
name|createResource
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getReservedMB
argument_list|()
argument_list|,
name|getMetrics
argument_list|()
operator|.
name|getReservedVirtualCores
argument_list|()
argument_list|)
decl_stmt|;
name|float
name|capacityWithoutReservedCapacity
init|=
name|Resources
operator|.
name|divide
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|Resources
operator|.
name|subtract
argument_list|(
name|queueUsage
operator|.
name|getUsed
argument_list|()
argument_list|,
name|reservedResources
argument_list|)
argument_list|,
name|clusterResource
argument_list|)
decl_stmt|;
if|if
condition|(
name|capacityWithoutReservedCapacity
operator|<=
name|queueCapacities
operator|.
name|getAbsoluteMaximumCapacity
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"parent: try to use reserved: "
operator|+
name|getQueueName
argument_list|()
operator|+
literal|" usedResources: "
operator|+
name|queueUsage
operator|.
name|getUsed
argument_list|()
operator|.
name|getMemory
argument_list|()
operator|+
literal|" clusterResources: "
operator|+
name|clusterResource
operator|.
name|getMemory
argument_list|()
operator|+
literal|" reservedResources: "
operator|+
name|reservedResources
operator|.
name|getMemory
argument_list|()
operator|+
literal|" currentCapacity "
operator|+
operator|(
operator|(
name|float
operator|)
name|queueUsage
operator|.
name|getUsed
argument_list|()
operator|.
name|getMemory
argument_list|()
operator|)
operator|/
name|clusterResource
operator|.
name|getMemory
argument_list|()
operator|+
literal|" potentialNewWithoutReservedCapacity: "
operator|+
name|capacityWithoutReservedCapacity
operator|+
literal|" ( "
operator|+
literal|" max-capacity: "
operator|+
name|queueCapacities
operator|.
name|getAbsoluteMaximumCapacity
argument_list|()
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
comment|// we could potentially use this node instead of reserved node
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|canAssign (Resource clusterResource, FiCaSchedulerNode node)
specifier|private
name|boolean
name|canAssign
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|FiCaSchedulerNode
name|node
parameter_list|)
block|{
return|return
operator|(
name|node
operator|.
name|getReservedContainer
argument_list|()
operator|==
literal|null
operator|)
operator|&&
name|Resources
operator|.
name|greaterThanOrEqual
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|node
operator|.
name|getAvailableResource
argument_list|()
argument_list|,
name|minimumAllocation
argument_list|)
return|;
block|}
DECL|method|getResourceLimitsOfChild (CSQueue child, Resource clusterResource, ResourceLimits myLimits)
specifier|private
name|ResourceLimits
name|getResourceLimitsOfChild
parameter_list|(
name|CSQueue
name|child
parameter_list|,
name|Resource
name|clusterResource
parameter_list|,
name|ResourceLimits
name|myLimits
parameter_list|)
block|{
comment|/*      * Set head-room of a given child, limit =      * min(minimum-of-limit-of-this-queue-and-ancestors, this.max) - this.used      * + child.used. To avoid any of this queue's and its ancestors' limit      * being violated      */
name|Resource
name|myCurrentLimit
init|=
name|getCurrentResourceLimit
argument_list|(
name|clusterResource
argument_list|,
name|myLimits
argument_list|)
decl_stmt|;
comment|// My available resource = my-current-limit - my-used-resource
name|Resource
name|myMaxAvailableResource
init|=
name|Resources
operator|.
name|subtract
argument_list|(
name|myCurrentLimit
argument_list|,
name|getUsedResources
argument_list|()
argument_list|)
decl_stmt|;
comment|// Child's limit = my-available-resource + resource-already-used-by-child
name|Resource
name|childLimit
init|=
name|Resources
operator|.
name|add
argument_list|(
name|myMaxAvailableResource
argument_list|,
name|child
operator|.
name|getUsedResources
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|ResourceLimits
argument_list|(
name|childLimit
argument_list|)
return|;
block|}
DECL|method|assignContainersToChildQueues ( Resource cluster, FiCaSchedulerNode node, boolean needToUnreserve, ResourceLimits limits)
specifier|private
specifier|synchronized
name|CSAssignment
name|assignContainersToChildQueues
parameter_list|(
name|Resource
name|cluster
parameter_list|,
name|FiCaSchedulerNode
name|node
parameter_list|,
name|boolean
name|needToUnreserve
parameter_list|,
name|ResourceLimits
name|limits
parameter_list|)
block|{
name|CSAssignment
name|assignment
init|=
operator|new
name|CSAssignment
argument_list|(
name|Resources
operator|.
name|createResource
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NodeType
operator|.
name|NODE_LOCAL
argument_list|)
decl_stmt|;
name|printChildQueues
argument_list|()
expr_stmt|;
comment|// Try to assign to most 'under-served' sub-queue
for|for
control|(
name|Iterator
argument_list|<
name|CSQueue
argument_list|>
name|iter
init|=
name|childQueues
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|CSQueue
name|childQueue
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying to assign to queue: "
operator|+
name|childQueue
operator|.
name|getQueuePath
argument_list|()
operator|+
literal|" stats: "
operator|+
name|childQueue
argument_list|)
expr_stmt|;
block|}
comment|// Get ResourceLimits of child queue before assign containers
name|ResourceLimits
name|childLimits
init|=
name|getResourceLimitsOfChild
argument_list|(
name|childQueue
argument_list|,
name|cluster
argument_list|,
name|limits
argument_list|)
decl_stmt|;
name|assignment
operator|=
name|childQueue
operator|.
name|assignContainers
argument_list|(
name|cluster
argument_list|,
name|node
argument_list|,
name|needToUnreserve
argument_list|,
name|childLimits
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Assigned to queue: "
operator|+
name|childQueue
operator|.
name|getQueuePath
argument_list|()
operator|+
literal|" stats: "
operator|+
name|childQueue
operator|+
literal|" --> "
operator|+
name|assignment
operator|.
name|getResource
argument_list|()
operator|+
literal|", "
operator|+
name|assignment
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// If we do assign, remove the queue and re-insert in-order to re-sort
if|if
condition|(
name|Resources
operator|.
name|greaterThan
argument_list|(
name|resourceCalculator
argument_list|,
name|cluster
argument_list|,
name|assignment
operator|.
name|getResource
argument_list|()
argument_list|,
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
condition|)
block|{
comment|// Remove and re-insert to sort
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Re-sorting assigned queue: "
operator|+
name|childQueue
operator|.
name|getQueuePath
argument_list|()
operator|+
literal|" stats: "
operator|+
name|childQueue
argument_list|)
expr_stmt|;
name|childQueues
operator|.
name|add
argument_list|(
name|childQueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|printChildQueues
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|assignment
return|;
block|}
DECL|method|getChildQueuesToPrint ()
name|String
name|getChildQueuesToPrint
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|CSQueue
name|q
range|:
name|childQueues
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|q
operator|.
name|getQueuePath
argument_list|()
operator|+
literal|"usedCapacity=("
operator|+
name|q
operator|.
name|getUsedCapacity
argument_list|()
operator|+
literal|"), "
operator|+
literal|" label=("
operator|+
name|StringUtils
operator|.
name|join
argument_list|(
name|q
operator|.
name|getAccessibleNodeLabels
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
literal|","
argument_list|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|printChildQueues ()
specifier|private
name|void
name|printChildQueues
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"printChildQueues - queue: "
operator|+
name|getQueuePath
argument_list|()
operator|+
literal|" child-queues: "
operator|+
name|getChildQueuesToPrint
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|completedContainer (Resource clusterResource, FiCaSchedulerApp application, FiCaSchedulerNode node, RMContainer rmContainer, ContainerStatus containerStatus, RMContainerEventType event, CSQueue completedChildQueue, boolean sortQueues)
specifier|public
name|void
name|completedContainer
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|FiCaSchedulerApp
name|application
parameter_list|,
name|FiCaSchedulerNode
name|node
parameter_list|,
name|RMContainer
name|rmContainer
parameter_list|,
name|ContainerStatus
name|containerStatus
parameter_list|,
name|RMContainerEventType
name|event
parameter_list|,
name|CSQueue
name|completedChildQueue
parameter_list|,
name|boolean
name|sortQueues
parameter_list|)
block|{
if|if
condition|(
name|application
operator|!=
literal|null
condition|)
block|{
comment|// Careful! Locking order is important!
comment|// Book keeping
synchronized|synchronized
init|(
name|this
init|)
block|{
name|super
operator|.
name|releaseResource
argument_list|(
name|clusterResource
argument_list|,
name|rmContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getResource
argument_list|()
argument_list|,
name|node
operator|.
name|getLabels
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"completedContainer"
operator|+
literal|" queue="
operator|+
name|getQueueName
argument_list|()
operator|+
literal|" usedCapacity="
operator|+
name|getUsedCapacity
argument_list|()
operator|+
literal|" absoluteUsedCapacity="
operator|+
name|getAbsoluteUsedCapacity
argument_list|()
operator|+
literal|" used="
operator|+
name|queueUsage
operator|.
name|getUsed
argument_list|()
operator|+
literal|" cluster="
operator|+
name|clusterResource
argument_list|)
expr_stmt|;
comment|// Note that this is using an iterator on the childQueues so this can't
comment|// be called if already within an iterator for the childQueues. Like
comment|// from assignContainersToChildQueues.
if|if
condition|(
name|sortQueues
condition|)
block|{
comment|// reinsert the updated queue
for|for
control|(
name|Iterator
argument_list|<
name|CSQueue
argument_list|>
name|iter
init|=
name|childQueues
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|CSQueue
name|csqueue
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|csqueue
operator|.
name|equals
argument_list|(
name|completedChildQueue
argument_list|)
condition|)
block|{
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Re-sorting completed queue: "
operator|+
name|csqueue
operator|.
name|getQueuePath
argument_list|()
operator|+
literal|" stats: "
operator|+
name|csqueue
argument_list|)
expr_stmt|;
name|childQueues
operator|.
name|add
argument_list|(
name|csqueue
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|// Inform the parent
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
comment|// complete my parent
name|parent
operator|.
name|completedContainer
argument_list|(
name|clusterResource
argument_list|,
name|application
argument_list|,
name|node
argument_list|,
name|rmContainer
argument_list|,
literal|null
argument_list|,
name|event
argument_list|,
name|this
argument_list|,
name|sortQueues
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|updateClusterResource (Resource clusterResource, ResourceLimits resourceLimits)
specifier|public
specifier|synchronized
name|void
name|updateClusterResource
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|ResourceLimits
name|resourceLimits
parameter_list|)
block|{
comment|// Update all children
for|for
control|(
name|CSQueue
name|childQueue
range|:
name|childQueues
control|)
block|{
comment|// Get ResourceLimits of child queue before assign containers
name|ResourceLimits
name|childLimits
init|=
name|getResourceLimitsOfChild
argument_list|(
name|childQueue
argument_list|,
name|clusterResource
argument_list|,
name|resourceLimits
argument_list|)
decl_stmt|;
name|childQueue
operator|.
name|updateClusterResource
argument_list|(
name|clusterResource
argument_list|,
name|childLimits
argument_list|)
expr_stmt|;
block|}
comment|// Update metrics
name|CSQueueUtils
operator|.
name|updateQueueStatistics
argument_list|(
name|resourceCalculator
argument_list|,
name|this
argument_list|,
name|parent
argument_list|,
name|clusterResource
argument_list|,
name|minimumAllocation
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getChildQueues ()
specifier|public
specifier|synchronized
name|List
argument_list|<
name|CSQueue
argument_list|>
name|getChildQueues
parameter_list|()
block|{
return|return
operator|new
name|ArrayList
argument_list|<
name|CSQueue
argument_list|>
argument_list|(
name|childQueues
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|recoverContainer (Resource clusterResource, SchedulerApplicationAttempt attempt, RMContainer rmContainer)
specifier|public
name|void
name|recoverContainer
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|SchedulerApplicationAttempt
name|attempt
parameter_list|,
name|RMContainer
name|rmContainer
parameter_list|)
block|{
if|if
condition|(
name|rmContainer
operator|.
name|getState
argument_list|()
operator|.
name|equals
argument_list|(
name|RMContainerState
operator|.
name|COMPLETED
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Careful! Locking order is important!
synchronized|synchronized
init|(
name|this
init|)
block|{
name|FiCaSchedulerNode
name|node
init|=
name|scheduler
operator|.
name|getNode
argument_list|(
name|rmContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
name|super
operator|.
name|allocateResource
argument_list|(
name|clusterResource
argument_list|,
name|rmContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getResource
argument_list|()
argument_list|,
name|node
operator|.
name|getLabels
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|parent
operator|.
name|recoverContainer
argument_list|(
name|clusterResource
argument_list|,
name|attempt
argument_list|,
name|rmContainer
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getActiveUsersManager ()
specifier|public
name|ActiveUsersManager
name|getActiveUsersManager
parameter_list|()
block|{
comment|// Should never be called since all applications are submitted to LeafQueues
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|collectSchedulerApplications ( Collection<ApplicationAttemptId> apps)
specifier|public
specifier|synchronized
name|void
name|collectSchedulerApplications
parameter_list|(
name|Collection
argument_list|<
name|ApplicationAttemptId
argument_list|>
name|apps
parameter_list|)
block|{
for|for
control|(
name|CSQueue
name|queue
range|:
name|childQueues
control|)
block|{
name|queue
operator|.
name|collectSchedulerApplications
argument_list|(
name|apps
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|attachContainer (Resource clusterResource, FiCaSchedulerApp application, RMContainer rmContainer)
specifier|public
name|void
name|attachContainer
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|FiCaSchedulerApp
name|application
parameter_list|,
name|RMContainer
name|rmContainer
parameter_list|)
block|{
if|if
condition|(
name|application
operator|!=
literal|null
condition|)
block|{
name|FiCaSchedulerNode
name|node
init|=
name|scheduler
operator|.
name|getNode
argument_list|(
name|rmContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
name|super
operator|.
name|allocateResource
argument_list|(
name|clusterResource
argument_list|,
name|rmContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getResource
argument_list|()
argument_list|,
name|node
operator|.
name|getLabels
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"movedContainer"
operator|+
literal|" queueMoveIn="
operator|+
name|getQueueName
argument_list|()
operator|+
literal|" usedCapacity="
operator|+
name|getUsedCapacity
argument_list|()
operator|+
literal|" absoluteUsedCapacity="
operator|+
name|getAbsoluteUsedCapacity
argument_list|()
operator|+
literal|" used="
operator|+
name|queueUsage
operator|.
name|getUsed
argument_list|()
operator|+
literal|" cluster="
operator|+
name|clusterResource
argument_list|)
expr_stmt|;
comment|// Inform the parent
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|parent
operator|.
name|attachContainer
argument_list|(
name|clusterResource
argument_list|,
name|application
argument_list|,
name|rmContainer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|detachContainer (Resource clusterResource, FiCaSchedulerApp application, RMContainer rmContainer)
specifier|public
name|void
name|detachContainer
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|FiCaSchedulerApp
name|application
parameter_list|,
name|RMContainer
name|rmContainer
parameter_list|)
block|{
if|if
condition|(
name|application
operator|!=
literal|null
condition|)
block|{
name|FiCaSchedulerNode
name|node
init|=
name|scheduler
operator|.
name|getNode
argument_list|(
name|rmContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
name|super
operator|.
name|releaseResource
argument_list|(
name|clusterResource
argument_list|,
name|rmContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getResource
argument_list|()
argument_list|,
name|node
operator|.
name|getLabels
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"movedContainer"
operator|+
literal|" queueMoveOut="
operator|+
name|getQueueName
argument_list|()
operator|+
literal|" usedCapacity="
operator|+
name|getUsedCapacity
argument_list|()
operator|+
literal|" absoluteUsedCapacity="
operator|+
name|getAbsoluteUsedCapacity
argument_list|()
operator|+
literal|" used="
operator|+
name|queueUsage
operator|.
name|getUsed
argument_list|()
operator|+
literal|" cluster="
operator|+
name|clusterResource
argument_list|)
expr_stmt|;
comment|// Inform the parent
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|parent
operator|.
name|detachContainer
argument_list|(
name|clusterResource
argument_list|,
name|application
argument_list|,
name|rmContainer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getNumApplications ()
specifier|public
specifier|synchronized
name|int
name|getNumApplications
parameter_list|()
block|{
return|return
name|numApplications
return|;
block|}
block|}
end_class

end_unit

