begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/** * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|Private
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
operator|.
name|Evolving
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|AccessControlList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationAttemptId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueUserACLInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|InvalidResourceRequestException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|factories
operator|.
name|RecordFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|factory
operator|.
name|providers
operator|.
name|RecordFactoryProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|security
operator|.
name|AccessType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|nodelabels
operator|.
name|RMNodeLabelsManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainerEventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainerState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|ActiveUsersManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|NodeType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|ResourceLimits
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|SchedContainerChangeRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|SchedulerApplicationAttempt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|SchedulerUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|fica
operator|.
name|FiCaSchedulerApp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|fica
operator|.
name|FiCaSchedulerNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|Resources
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_class
annotation|@
name|Private
annotation|@
name|Evolving
DECL|class|ParentQueue
specifier|public
class|class
name|ParentQueue
extends|extends
name|AbstractCSQueue
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ParentQueue
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|childQueues
specifier|protected
specifier|final
name|Set
argument_list|<
name|CSQueue
argument_list|>
name|childQueues
decl_stmt|;
DECL|field|rootQueue
specifier|private
specifier|final
name|boolean
name|rootQueue
decl_stmt|;
DECL|field|nonPartitionedQueueComparator
specifier|final
name|Comparator
argument_list|<
name|CSQueue
argument_list|>
name|nonPartitionedQueueComparator
decl_stmt|;
DECL|field|partitionQueueComparator
specifier|final
name|PartitionedQueueComparator
name|partitionQueueComparator
decl_stmt|;
DECL|field|numApplications
specifier|volatile
name|int
name|numApplications
decl_stmt|;
DECL|field|scheduler
specifier|private
specifier|final
name|CapacitySchedulerContext
name|scheduler
decl_stmt|;
DECL|field|needToResortQueuesAtNextAllocation
specifier|private
name|boolean
name|needToResortQueuesAtNextAllocation
init|=
literal|false
decl_stmt|;
DECL|field|recordFactory
specifier|private
specifier|final
name|RecordFactory
name|recordFactory
init|=
name|RecordFactoryProvider
operator|.
name|getRecordFactory
argument_list|(
literal|null
argument_list|)
decl_stmt|;
DECL|method|ParentQueue (CapacitySchedulerContext cs, String queueName, CSQueue parent, CSQueue old)
specifier|public
name|ParentQueue
parameter_list|(
name|CapacitySchedulerContext
name|cs
parameter_list|,
name|String
name|queueName
parameter_list|,
name|CSQueue
name|parent
parameter_list|,
name|CSQueue
name|old
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|cs
argument_list|,
name|queueName
argument_list|,
name|parent
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|this
operator|.
name|scheduler
operator|=
name|cs
expr_stmt|;
name|this
operator|.
name|nonPartitionedQueueComparator
operator|=
name|cs
operator|.
name|getNonPartitionedQueueComparator
argument_list|()
expr_stmt|;
name|this
operator|.
name|partitionQueueComparator
operator|=
name|cs
operator|.
name|getPartitionedQueueComparator
argument_list|()
expr_stmt|;
name|this
operator|.
name|rootQueue
operator|=
operator|(
name|parent
operator|==
literal|null
operator|)
expr_stmt|;
name|float
name|rawCapacity
init|=
name|cs
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getNonLabeledQueueCapacity
argument_list|(
name|getQueuePath
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|rootQueue
operator|&&
operator|(
name|rawCapacity
operator|!=
name|CapacitySchedulerConfiguration
operator|.
name|MAXIMUM_CAPACITY_VALUE
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal "
operator|+
literal|"capacity of "
operator|+
name|rawCapacity
operator|+
literal|" for queue "
operator|+
name|queueName
operator|+
literal|". Must be "
operator|+
name|CapacitySchedulerConfiguration
operator|.
name|MAXIMUM_CAPACITY_VALUE
argument_list|)
throw|;
block|}
name|this
operator|.
name|childQueues
operator|=
operator|new
name|TreeSet
argument_list|<
name|CSQueue
argument_list|>
argument_list|(
name|nonPartitionedQueueComparator
argument_list|)
expr_stmt|;
name|setupQueueConfigs
argument_list|(
name|cs
operator|.
name|getClusterResource
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Initialized parent-queue "
operator|+
name|queueName
operator|+
literal|" name="
operator|+
name|queueName
operator|+
literal|", fullname="
operator|+
name|getQueuePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|setupQueueConfigs (Resource clusterResource)
specifier|synchronized
name|void
name|setupQueueConfigs
parameter_list|(
name|Resource
name|clusterResource
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|setupQueueConfigs
argument_list|(
name|clusterResource
argument_list|)
expr_stmt|;
name|StringBuilder
name|aclsString
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|AccessType
argument_list|,
name|AccessControlList
argument_list|>
name|e
range|:
name|acls
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|aclsString
operator|.
name|append
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
operator|+
literal|":"
operator|+
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|getAclString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|StringBuilder
name|labelStrBuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|accessibleLabels
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|s
range|:
name|accessibleLabels
control|)
block|{
name|labelStrBuilder
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|labelStrBuilder
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|queueName
operator|+
literal|", capacity="
operator|+
name|this
operator|.
name|queueCapacities
operator|.
name|getCapacity
argument_list|()
operator|+
literal|", asboluteCapacity="
operator|+
name|this
operator|.
name|queueCapacities
operator|.
name|getAbsoluteCapacity
argument_list|()
operator|+
literal|", maxCapacity="
operator|+
name|this
operator|.
name|queueCapacities
operator|.
name|getMaximumCapacity
argument_list|()
operator|+
literal|", asboluteMaxCapacity="
operator|+
name|this
operator|.
name|queueCapacities
operator|.
name|getAbsoluteMaximumCapacity
argument_list|()
operator|+
literal|", state="
operator|+
name|state
operator|+
literal|", acls="
operator|+
name|aclsString
operator|+
literal|", labels="
operator|+
name|labelStrBuilder
operator|.
name|toString
argument_list|()
operator|+
literal|"\n"
operator|+
literal|", reservationsContinueLooking="
operator|+
name|reservationsContinueLooking
argument_list|)
expr_stmt|;
block|}
DECL|field|PRECISION
specifier|private
specifier|static
name|float
name|PRECISION
init|=
literal|0.0005f
decl_stmt|;
comment|// 0.05% precision
DECL|method|setChildQueues (Collection<CSQueue> childQueues)
specifier|synchronized
name|void
name|setChildQueues
parameter_list|(
name|Collection
argument_list|<
name|CSQueue
argument_list|>
name|childQueues
parameter_list|)
block|{
comment|// Validate
name|float
name|childCapacities
init|=
literal|0
decl_stmt|;
for|for
control|(
name|CSQueue
name|queue
range|:
name|childQueues
control|)
block|{
name|childCapacities
operator|+=
name|queue
operator|.
name|getCapacity
argument_list|()
expr_stmt|;
block|}
name|float
name|delta
init|=
name|Math
operator|.
name|abs
argument_list|(
literal|1.0f
operator|-
name|childCapacities
argument_list|)
decl_stmt|;
comment|// crude way to check
comment|// allow capacities being set to 0, and enforce child 0 if parent is 0
if|if
condition|(
operator|(
operator|(
name|queueCapacities
operator|.
name|getCapacity
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|(
name|delta
operator|>
name|PRECISION
operator|)
operator|)
operator|||
operator|(
operator|(
name|queueCapacities
operator|.
name|getCapacity
argument_list|()
operator|==
literal|0
operator|)
operator|&&
operator|(
name|childCapacities
operator|>
literal|0
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal"
operator|+
literal|" capacity of "
operator|+
name|childCapacities
operator|+
literal|" for children of queue "
operator|+
name|queueName
argument_list|)
throw|;
block|}
comment|// check label capacities
for|for
control|(
name|String
name|nodeLabel
range|:
name|queueCapacities
operator|.
name|getExistingNodeLabels
argument_list|()
control|)
block|{
name|float
name|capacityByLabel
init|=
name|queueCapacities
operator|.
name|getCapacity
argument_list|(
name|nodeLabel
argument_list|)
decl_stmt|;
comment|// check children's labels
name|float
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|CSQueue
name|queue
range|:
name|childQueues
control|)
block|{
name|sum
operator|+=
name|queue
operator|.
name|getQueueCapacities
argument_list|()
operator|.
name|getCapacity
argument_list|(
name|nodeLabel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|capacityByLabel
operator|>
literal|0
operator|&&
name|Math
operator|.
name|abs
argument_list|(
literal|1.0f
operator|-
name|sum
argument_list|)
operator|>
name|PRECISION
operator|)
operator|||
operator|(
name|capacityByLabel
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sum
operator|>
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal"
operator|+
literal|" capacity of "
operator|+
name|sum
operator|+
literal|" for children of queue "
operator|+
name|queueName
operator|+
literal|" for label="
operator|+
name|nodeLabel
argument_list|)
throw|;
block|}
block|}
name|this
operator|.
name|childQueues
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|childQueues
operator|.
name|addAll
argument_list|(
name|childQueues
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"setChildQueues: "
operator|+
name|getChildQueuesToPrint
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getQueuePath ()
specifier|public
name|String
name|getQueuePath
parameter_list|()
block|{
name|String
name|parentPath
init|=
operator|(
operator|(
name|parent
operator|==
literal|null
operator|)
condition|?
literal|""
else|:
operator|(
name|parent
operator|.
name|getQueuePath
argument_list|()
operator|+
literal|"."
operator|)
operator|)
decl_stmt|;
return|return
name|parentPath
operator|+
name|getQueueName
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getQueueInfo ( boolean includeChildQueues, boolean recursive)
specifier|public
specifier|synchronized
name|QueueInfo
name|getQueueInfo
parameter_list|(
name|boolean
name|includeChildQueues
parameter_list|,
name|boolean
name|recursive
parameter_list|)
block|{
name|QueueInfo
name|queueInfo
init|=
name|getQueueInfo
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|QueueInfo
argument_list|>
name|childQueuesInfo
init|=
operator|new
name|ArrayList
argument_list|<
name|QueueInfo
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|includeChildQueues
condition|)
block|{
for|for
control|(
name|CSQueue
name|child
range|:
name|childQueues
control|)
block|{
comment|// Get queue information recursively?
name|childQueuesInfo
operator|.
name|add
argument_list|(
name|child
operator|.
name|getQueueInfo
argument_list|(
name|recursive
argument_list|,
name|recursive
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|queueInfo
operator|.
name|setChildQueues
argument_list|(
name|childQueuesInfo
argument_list|)
expr_stmt|;
return|return
name|queueInfo
return|;
block|}
DECL|method|getUserAclInfo ( UserGroupInformation user)
specifier|private
specifier|synchronized
name|QueueUserACLInfo
name|getUserAclInfo
parameter_list|(
name|UserGroupInformation
name|user
parameter_list|)
block|{
name|QueueUserACLInfo
name|userAclInfo
init|=
name|recordFactory
operator|.
name|newRecordInstance
argument_list|(
name|QueueUserACLInfo
operator|.
name|class
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|QueueACL
argument_list|>
name|operations
init|=
operator|new
name|ArrayList
argument_list|<
name|QueueACL
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|QueueACL
name|operation
range|:
name|QueueACL
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|hasAccess
argument_list|(
name|operation
argument_list|,
name|user
argument_list|)
condition|)
block|{
name|operations
operator|.
name|add
argument_list|(
name|operation
argument_list|)
expr_stmt|;
block|}
block|}
name|userAclInfo
operator|.
name|setQueueName
argument_list|(
name|getQueueName
argument_list|()
argument_list|)
expr_stmt|;
name|userAclInfo
operator|.
name|setUserAcls
argument_list|(
name|operations
argument_list|)
expr_stmt|;
return|return
name|userAclInfo
return|;
block|}
annotation|@
name|Override
DECL|method|getQueueUserAclInfo ( UserGroupInformation user)
specifier|public
specifier|synchronized
name|List
argument_list|<
name|QueueUserACLInfo
argument_list|>
name|getQueueUserAclInfo
parameter_list|(
name|UserGroupInformation
name|user
parameter_list|)
block|{
name|List
argument_list|<
name|QueueUserACLInfo
argument_list|>
name|userAcls
init|=
operator|new
name|ArrayList
argument_list|<
name|QueueUserACLInfo
argument_list|>
argument_list|()
decl_stmt|;
comment|// Add parent queue acls
name|userAcls
operator|.
name|add
argument_list|(
name|getUserAclInfo
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
comment|// Add children queue acls
for|for
control|(
name|CSQueue
name|child
range|:
name|childQueues
control|)
block|{
name|userAcls
operator|.
name|addAll
argument_list|(
name|child
operator|.
name|getQueueUserAclInfo
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|userAcls
return|;
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|queueName
operator|+
literal|": "
operator|+
literal|"numChildQueue= "
operator|+
name|childQueues
operator|.
name|size
argument_list|()
operator|+
literal|", "
operator|+
literal|"capacity="
operator|+
name|queueCapacities
operator|.
name|getCapacity
argument_list|()
operator|+
literal|", "
operator|+
literal|"absoluteCapacity="
operator|+
name|queueCapacities
operator|.
name|getAbsoluteCapacity
argument_list|()
operator|+
literal|", "
operator|+
literal|"usedResources="
operator|+
name|queueUsage
operator|.
name|getUsed
argument_list|()
operator|+
literal|"usedCapacity="
operator|+
name|getUsedCapacity
argument_list|()
operator|+
literal|", "
operator|+
literal|"numApps="
operator|+
name|getNumApplications
argument_list|()
operator|+
literal|", "
operator|+
literal|"numContainers="
operator|+
name|getNumContainers
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|reinitialize (CSQueue newlyParsedQueue, Resource clusterResource)
specifier|public
specifier|synchronized
name|void
name|reinitialize
parameter_list|(
name|CSQueue
name|newlyParsedQueue
parameter_list|,
name|Resource
name|clusterResource
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Sanity check
if|if
condition|(
operator|!
operator|(
name|newlyParsedQueue
operator|instanceof
name|ParentQueue
operator|)
operator|||
operator|!
name|newlyParsedQueue
operator|.
name|getQueuePath
argument_list|()
operator|.
name|equals
argument_list|(
name|getQueuePath
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Trying to reinitialize "
operator|+
name|getQueuePath
argument_list|()
operator|+
literal|" from "
operator|+
name|newlyParsedQueue
operator|.
name|getQueuePath
argument_list|()
argument_list|)
throw|;
block|}
name|ParentQueue
name|newlyParsedParentQueue
init|=
operator|(
name|ParentQueue
operator|)
name|newlyParsedQueue
decl_stmt|;
comment|// Set new configs
name|setupQueueConfigs
argument_list|(
name|clusterResource
argument_list|)
expr_stmt|;
comment|// Re-configure existing child queues and add new ones
comment|// The CS has already checked to ensure all existing child queues are present!
name|Map
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|currentChildQueues
init|=
name|getQueues
argument_list|(
name|childQueues
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|newChildQueues
init|=
name|getQueues
argument_list|(
name|newlyParsedParentQueue
operator|.
name|childQueues
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|e
range|:
name|newChildQueues
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|newChildQueueName
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|CSQueue
name|newChildQueue
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|CSQueue
name|childQueue
init|=
name|currentChildQueues
operator|.
name|get
argument_list|(
name|newChildQueueName
argument_list|)
decl_stmt|;
comment|// Check if the child-queue already exists
if|if
condition|(
name|childQueue
operator|!=
literal|null
condition|)
block|{
comment|// Re-init existing child queues
name|childQueue
operator|.
name|reinitialize
argument_list|(
name|newChildQueue
argument_list|,
name|clusterResource
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getQueueName
argument_list|()
operator|+
literal|": re-configured queue: "
operator|+
name|childQueue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// New child queue, do not re-init
comment|// Set parent to 'this'
name|newChildQueue
operator|.
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Save in list of current child queues
name|currentChildQueues
operator|.
name|put
argument_list|(
name|newChildQueueName
argument_list|,
name|newChildQueue
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|getQueueName
argument_list|()
operator|+
literal|": added new child queue: "
operator|+
name|newChildQueue
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Re-sort all queues
name|childQueues
operator|.
name|clear
argument_list|()
expr_stmt|;
name|childQueues
operator|.
name|addAll
argument_list|(
name|currentChildQueues
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|getQueues (Set<CSQueue> queues)
name|Map
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|getQueues
parameter_list|(
name|Set
argument_list|<
name|CSQueue
argument_list|>
name|queues
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|queuesMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|CSQueue
name|queue
range|:
name|queues
control|)
block|{
name|queuesMap
operator|.
name|put
argument_list|(
name|queue
operator|.
name|getQueueName
argument_list|()
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
return|return
name|queuesMap
return|;
block|}
annotation|@
name|Override
DECL|method|submitApplication (ApplicationId applicationId, String user, String queue)
specifier|public
name|void
name|submitApplication
parameter_list|(
name|ApplicationId
name|applicationId
parameter_list|,
name|String
name|user
parameter_list|,
name|String
name|queue
parameter_list|)
throws|throws
name|AccessControlException
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// Sanity check
if|if
condition|(
name|queue
operator|.
name|equals
argument_list|(
name|queueName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"Cannot submit application "
operator|+
literal|"to non-leaf queue: "
operator|+
name|queueName
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|!=
name|QueueState
operator|.
name|RUNNING
condition|)
block|{
throw|throw
operator|new
name|AccessControlException
argument_list|(
literal|"Queue "
operator|+
name|getQueuePath
argument_list|()
operator|+
literal|" is STOPPED. Cannot accept submission of application: "
operator|+
name|applicationId
argument_list|)
throw|;
block|}
name|addApplication
argument_list|(
name|applicationId
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
comment|// Inform the parent queue
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|parent
operator|.
name|submitApplication
argument_list|(
name|applicationId
argument_list|,
name|user
argument_list|,
name|queue
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AccessControlException
name|ace
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to submit application to parent-queue: "
operator|+
name|parent
operator|.
name|getQueuePath
argument_list|()
argument_list|,
name|ace
argument_list|)
expr_stmt|;
name|removeApplication
argument_list|(
name|applicationId
argument_list|,
name|user
argument_list|)
expr_stmt|;
throw|throw
name|ace
throw|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|submitApplicationAttempt (FiCaSchedulerApp application, String userName)
specifier|public
name|void
name|submitApplicationAttempt
parameter_list|(
name|FiCaSchedulerApp
name|application
parameter_list|,
name|String
name|userName
parameter_list|)
block|{
comment|// submit attempt logic.
block|}
annotation|@
name|Override
DECL|method|finishApplicationAttempt (FiCaSchedulerApp application, String queue)
specifier|public
name|void
name|finishApplicationAttempt
parameter_list|(
name|FiCaSchedulerApp
name|application
parameter_list|,
name|String
name|queue
parameter_list|)
block|{
comment|// finish attempt logic.
block|}
DECL|method|addApplication (ApplicationId applicationId, String user)
specifier|private
specifier|synchronized
name|void
name|addApplication
parameter_list|(
name|ApplicationId
name|applicationId
parameter_list|,
name|String
name|user
parameter_list|)
block|{
operator|++
name|numApplications
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Application added -"
operator|+
literal|" appId: "
operator|+
name|applicationId
operator|+
literal|" user: "
operator|+
name|user
operator|+
literal|" leaf-queue of parent: "
operator|+
name|getQueueName
argument_list|()
operator|+
literal|" #applications: "
operator|+
name|getNumApplications
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|finishApplication (ApplicationId application, String user)
specifier|public
name|void
name|finishApplication
parameter_list|(
name|ApplicationId
name|application
parameter_list|,
name|String
name|user
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|removeApplication
argument_list|(
name|application
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
comment|// Inform the parent queue
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|parent
operator|.
name|finishApplication
argument_list|(
name|application
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeApplication (ApplicationId applicationId, String user)
specifier|private
specifier|synchronized
name|void
name|removeApplication
parameter_list|(
name|ApplicationId
name|applicationId
parameter_list|,
name|String
name|user
parameter_list|)
block|{
operator|--
name|numApplications
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Application removed -"
operator|+
literal|" appId: "
operator|+
name|applicationId
operator|+
literal|" user: "
operator|+
name|user
operator|+
literal|" leaf-queue of parent: "
operator|+
name|getQueueName
argument_list|()
operator|+
literal|" #applications: "
operator|+
name|getNumApplications
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|assignContainers (Resource clusterResource, FiCaSchedulerNode node, ResourceLimits resourceLimits, SchedulingMode schedulingMode)
specifier|public
specifier|synchronized
name|CSAssignment
name|assignContainers
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|FiCaSchedulerNode
name|node
parameter_list|,
name|ResourceLimits
name|resourceLimits
parameter_list|,
name|SchedulingMode
name|schedulingMode
parameter_list|)
block|{
comment|// if our queue cannot access this node, just return
if|if
condition|(
name|schedulingMode
operator|==
name|SchedulingMode
operator|.
name|RESPECT_PARTITION_EXCLUSIVITY
operator|&&
operator|!
name|accessibleToPartition
argument_list|(
name|node
operator|.
name|getPartition
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skip this queue="
operator|+
name|getQueuePath
argument_list|()
operator|+
literal|", because it is not able to access partition="
operator|+
name|node
operator|.
name|getPartition
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|CSAssignment
operator|.
name|NULL_ASSIGNMENT
return|;
block|}
comment|// Check if this queue need more resource, simply skip allocation if this
comment|// queue doesn't need more resources.
if|if
condition|(
operator|!
name|super
operator|.
name|hasPendingResourceRequest
argument_list|(
name|node
operator|.
name|getPartition
argument_list|()
argument_list|,
name|clusterResource
argument_list|,
name|schedulingMode
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Skip this queue="
operator|+
name|getQueuePath
argument_list|()
operator|+
literal|", because it doesn't need more resource, schedulingMode="
operator|+
name|schedulingMode
operator|.
name|name
argument_list|()
operator|+
literal|" node-partition="
operator|+
name|node
operator|.
name|getPartition
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|CSAssignment
operator|.
name|NULL_ASSIGNMENT
return|;
block|}
name|CSAssignment
name|assignment
init|=
operator|new
name|CSAssignment
argument_list|(
name|Resources
operator|.
name|createResource
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NodeType
operator|.
name|NODE_LOCAL
argument_list|)
decl_stmt|;
while|while
condition|(
name|canAssign
argument_list|(
name|clusterResource
argument_list|,
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying to assign containers to child-queue of "
operator|+
name|getQueueName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Are we over maximum-capacity for this queue?
comment|// This will also consider parent's limits and also continuous reservation
comment|// looking
if|if
condition|(
operator|!
name|super
operator|.
name|canAssignToThisQueue
argument_list|(
name|clusterResource
argument_list|,
name|node
operator|.
name|getPartition
argument_list|()
argument_list|,
name|resourceLimits
argument_list|,
name|Resources
operator|.
name|createResource
argument_list|(
name|getMetrics
argument_list|()
operator|.
name|getReservedMB
argument_list|()
argument_list|,
name|getMetrics
argument_list|()
operator|.
name|getReservedVirtualCores
argument_list|()
argument_list|)
argument_list|,
name|schedulingMode
argument_list|)
condition|)
block|{
break|break;
block|}
comment|// Schedule
name|CSAssignment
name|assignedToChild
init|=
name|assignContainersToChildQueues
argument_list|(
name|clusterResource
argument_list|,
name|node
argument_list|,
name|resourceLimits
argument_list|,
name|schedulingMode
argument_list|)
decl_stmt|;
name|assignment
operator|.
name|setType
argument_list|(
name|assignedToChild
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
comment|// Done if no child-queue assigned anything
if|if
condition|(
name|Resources
operator|.
name|greaterThan
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|assignedToChild
operator|.
name|getResource
argument_list|()
argument_list|,
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
condition|)
block|{
comment|// Track resource utilization for the parent-queue
name|allocateResource
argument_list|(
name|clusterResource
argument_list|,
name|assignedToChild
operator|.
name|getResource
argument_list|()
argument_list|,
name|node
operator|.
name|getPartition
argument_list|()
argument_list|,
name|assignedToChild
operator|.
name|isIncreasedAllocation
argument_list|()
argument_list|)
expr_stmt|;
comment|// Track resource utilization in this pass of the scheduler
name|Resources
operator|.
name|addTo
argument_list|(
name|assignment
operator|.
name|getResource
argument_list|()
argument_list|,
name|assignedToChild
operator|.
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
name|Resources
operator|.
name|addTo
argument_list|(
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getAllocated
argument_list|()
argument_list|,
name|assignedToChild
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getAllocated
argument_list|()
argument_list|)
expr_stmt|;
name|Resources
operator|.
name|addTo
argument_list|(
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getReserved
argument_list|()
argument_list|,
name|assignedToChild
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getReserved
argument_list|()
argument_list|)
expr_stmt|;
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|incrAllocations
argument_list|(
name|assignedToChild
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getNumAllocations
argument_list|()
argument_list|)
expr_stmt|;
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|incrReservations
argument_list|(
name|assignedToChild
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getNumReservations
argument_list|()
argument_list|)
expr_stmt|;
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getAllocationDetails
argument_list|()
operator|.
name|addAll
argument_list|(
name|assignedToChild
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getAllocationDetails
argument_list|()
argument_list|)
expr_stmt|;
name|assignment
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getReservationDetails
argument_list|()
operator|.
name|addAll
argument_list|(
name|assignedToChild
operator|.
name|getAssignmentInformation
argument_list|()
operator|.
name|getReservationDetails
argument_list|()
argument_list|)
expr_stmt|;
name|assignment
operator|.
name|setIncreasedAllocation
argument_list|(
name|assignedToChild
operator|.
name|isIncreasedAllocation
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"assignedContainer"
operator|+
literal|" queue="
operator|+
name|getQueueName
argument_list|()
operator|+
literal|" usedCapacity="
operator|+
name|getUsedCapacity
argument_list|()
operator|+
literal|" absoluteUsedCapacity="
operator|+
name|getAbsoluteUsedCapacity
argument_list|()
operator|+
literal|" used="
operator|+
name|queueUsage
operator|.
name|getUsed
argument_list|()
operator|+
literal|" cluster="
operator|+
name|clusterResource
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assignment
operator|.
name|setSkippedType
argument_list|(
name|assignedToChild
operator|.
name|getSkippedType
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ParentQ="
operator|+
name|getQueueName
argument_list|()
operator|+
literal|" assignedSoFarInThisIteration="
operator|+
name|assignment
operator|.
name|getResource
argument_list|()
operator|+
literal|" usedCapacity="
operator|+
name|getUsedCapacity
argument_list|()
operator|+
literal|" absoluteUsedCapacity="
operator|+
name|getAbsoluteUsedCapacity
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Do not assign more than one container if this isn't the root queue
comment|// or if we've already assigned an off-switch container
if|if
condition|(
operator|!
name|rootQueue
operator|||
name|assignment
operator|.
name|getType
argument_list|()
operator|==
name|NodeType
operator|.
name|OFF_SWITCH
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|rootQueue
operator|&&
name|assignment
operator|.
name|getType
argument_list|()
operator|==
name|NodeType
operator|.
name|OFF_SWITCH
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Not assigning more than one off-switch container,"
operator|+
literal|" assignments so far: "
operator|+
name|assignment
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
return|return
name|assignment
return|;
block|}
DECL|method|canAssign (Resource clusterResource, FiCaSchedulerNode node)
specifier|private
name|boolean
name|canAssign
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|FiCaSchedulerNode
name|node
parameter_list|)
block|{
comment|// Two conditions need to meet when trying to allocate:
comment|// 1) Node doesn't have reserved container
comment|// 2) Node's available-resource + killable-resource should> 0
return|return
name|node
operator|.
name|getReservedContainer
argument_list|()
operator|==
literal|null
operator|&&
name|Resources
operator|.
name|greaterThanOrEqual
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|Resources
operator|.
name|add
argument_list|(
name|node
operator|.
name|getUnallocatedResource
argument_list|()
argument_list|,
name|node
operator|.
name|getTotalKillableResources
argument_list|()
argument_list|)
argument_list|,
name|minimumAllocation
argument_list|)
return|;
block|}
DECL|method|getResourceLimitsOfChild (CSQueue child, Resource clusterResource, Resource parentLimits, String nodePartition)
specifier|private
name|ResourceLimits
name|getResourceLimitsOfChild
parameter_list|(
name|CSQueue
name|child
parameter_list|,
name|Resource
name|clusterResource
parameter_list|,
name|Resource
name|parentLimits
parameter_list|,
name|String
name|nodePartition
parameter_list|)
block|{
comment|// Set resource-limit of a given child, child.limit =
comment|// min(my.limit - my.used + child.used, child.max)
comment|// Parent available resource = parent-limit - parent-used-resource
name|Resource
name|parentMaxAvailableResource
init|=
name|Resources
operator|.
name|subtract
argument_list|(
name|parentLimits
argument_list|,
name|queueUsage
operator|.
name|getUsed
argument_list|(
name|nodePartition
argument_list|)
argument_list|)
decl_stmt|;
comment|// Deduct killable from used
name|Resources
operator|.
name|addTo
argument_list|(
name|parentMaxAvailableResource
argument_list|,
name|getTotalKillableResource
argument_list|(
name|nodePartition
argument_list|)
argument_list|)
expr_stmt|;
comment|// Child's limit = parent-available-resource + child-used
name|Resource
name|childLimit
init|=
name|Resources
operator|.
name|add
argument_list|(
name|parentMaxAvailableResource
argument_list|,
name|child
operator|.
name|getQueueResourceUsage
argument_list|()
operator|.
name|getUsed
argument_list|(
name|nodePartition
argument_list|)
argument_list|)
decl_stmt|;
comment|// Get child's max resource
name|Resource
name|childConfiguredMaxResource
init|=
name|Resources
operator|.
name|multiplyAndNormalizeDown
argument_list|(
name|resourceCalculator
argument_list|,
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|nodePartition
argument_list|,
name|clusterResource
argument_list|)
argument_list|,
name|child
operator|.
name|getQueueCapacities
argument_list|()
operator|.
name|getAbsoluteMaximumCapacity
argument_list|(
name|nodePartition
argument_list|)
argument_list|,
name|minimumAllocation
argument_list|)
decl_stmt|;
comment|// Child's limit should be capped by child configured max resource
name|childLimit
operator|=
name|Resources
operator|.
name|min
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|childLimit
argument_list|,
name|childConfiguredMaxResource
argument_list|)
expr_stmt|;
comment|// Normalize before return
name|childLimit
operator|=
name|Resources
operator|.
name|roundDown
argument_list|(
name|resourceCalculator
argument_list|,
name|childLimit
argument_list|,
name|minimumAllocation
argument_list|)
expr_stmt|;
return|return
operator|new
name|ResourceLimits
argument_list|(
name|childLimit
argument_list|)
return|;
block|}
DECL|method|sortAndGetChildrenAllocationIterator (FiCaSchedulerNode node)
specifier|private
name|Iterator
argument_list|<
name|CSQueue
argument_list|>
name|sortAndGetChildrenAllocationIterator
parameter_list|(
name|FiCaSchedulerNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|getPartition
argument_list|()
operator|.
name|equals
argument_list|(
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|)
condition|)
block|{
if|if
condition|(
name|needToResortQueuesAtNextAllocation
condition|)
block|{
comment|// If we skipped resort queues last time, we need to re-sort queue
comment|// before allocation
name|List
argument_list|<
name|CSQueue
argument_list|>
name|childrenList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|childQueues
argument_list|)
decl_stmt|;
name|childQueues
operator|.
name|clear
argument_list|()
expr_stmt|;
name|childQueues
operator|.
name|addAll
argument_list|(
name|childrenList
argument_list|)
expr_stmt|;
name|needToResortQueuesAtNextAllocation
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|childQueues
operator|.
name|iterator
argument_list|()
return|;
block|}
name|partitionQueueComparator
operator|.
name|setPartitionToLookAt
argument_list|(
name|node
operator|.
name|getPartition
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|CSQueue
argument_list|>
name|childrenList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|childQueues
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|childrenList
argument_list|,
name|partitionQueueComparator
argument_list|)
expr_stmt|;
return|return
name|childrenList
operator|.
name|iterator
argument_list|()
return|;
block|}
DECL|method|assignContainersToChildQueues ( Resource cluster, FiCaSchedulerNode node, ResourceLimits limits, SchedulingMode schedulingMode)
specifier|private
specifier|synchronized
name|CSAssignment
name|assignContainersToChildQueues
parameter_list|(
name|Resource
name|cluster
parameter_list|,
name|FiCaSchedulerNode
name|node
parameter_list|,
name|ResourceLimits
name|limits
parameter_list|,
name|SchedulingMode
name|schedulingMode
parameter_list|)
block|{
name|CSAssignment
name|assignment
init|=
name|CSAssignment
operator|.
name|NULL_ASSIGNMENT
decl_stmt|;
name|Resource
name|parentLimits
init|=
name|limits
operator|.
name|getLimit
argument_list|()
decl_stmt|;
name|printChildQueues
argument_list|()
expr_stmt|;
comment|// Try to assign to most 'under-served' sub-queue
for|for
control|(
name|Iterator
argument_list|<
name|CSQueue
argument_list|>
name|iter
init|=
name|sortAndGetChildrenAllocationIterator
argument_list|(
name|node
argument_list|)
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|CSQueue
name|childQueue
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying to assign to queue: "
operator|+
name|childQueue
operator|.
name|getQueuePath
argument_list|()
operator|+
literal|" stats: "
operator|+
name|childQueue
argument_list|)
expr_stmt|;
block|}
comment|// Get ResourceLimits of child queue before assign containers
name|ResourceLimits
name|childLimits
init|=
name|getResourceLimitsOfChild
argument_list|(
name|childQueue
argument_list|,
name|cluster
argument_list|,
name|parentLimits
argument_list|,
name|node
operator|.
name|getPartition
argument_list|()
argument_list|)
decl_stmt|;
name|CSAssignment
name|childAssignment
init|=
name|childQueue
operator|.
name|assignContainers
argument_list|(
name|cluster
argument_list|,
name|node
argument_list|,
name|childLimits
argument_list|,
name|schedulingMode
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Assigned to queue: "
operator|+
name|childQueue
operator|.
name|getQueuePath
argument_list|()
operator|+
literal|" stats: "
operator|+
name|childQueue
operator|+
literal|" --> "
operator|+
name|childAssignment
operator|.
name|getResource
argument_list|()
operator|+
literal|", "
operator|+
name|childAssignment
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// If we do assign, remove the queue and re-insert in-order to re-sort
if|if
condition|(
name|Resources
operator|.
name|greaterThan
argument_list|(
name|resourceCalculator
argument_list|,
name|cluster
argument_list|,
name|childAssignment
operator|.
name|getResource
argument_list|()
argument_list|,
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
condition|)
block|{
comment|// Only update childQueues when we doing non-partitioned node
comment|// allocation.
if|if
condition|(
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
operator|.
name|equals
argument_list|(
name|node
operator|.
name|getPartition
argument_list|()
argument_list|)
condition|)
block|{
comment|// Remove and re-insert to sort
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Re-sorting assigned queue: "
operator|+
name|childQueue
operator|.
name|getQueuePath
argument_list|()
operator|+
literal|" stats: "
operator|+
name|childQueue
argument_list|)
expr_stmt|;
name|childQueues
operator|.
name|add
argument_list|(
name|childQueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|printChildQueues
argument_list|()
expr_stmt|;
block|}
block|}
name|assignment
operator|=
name|childAssignment
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|childAssignment
operator|.
name|getSkippedType
argument_list|()
operator|==
name|CSAssignment
operator|.
name|SkippedType
operator|.
name|QUEUE_LIMIT
condition|)
block|{
if|if
condition|(
name|assignment
operator|.
name|getSkippedType
argument_list|()
operator|!=
name|CSAssignment
operator|.
name|SkippedType
operator|.
name|QUEUE_LIMIT
condition|)
block|{
name|assignment
operator|=
name|childAssignment
expr_stmt|;
block|}
name|Resource
name|resourceToSubtract
init|=
name|Resources
operator|.
name|max
argument_list|(
name|resourceCalculator
argument_list|,
name|cluster
argument_list|,
name|childLimits
operator|.
name|getHeadroom
argument_list|()
argument_list|,
name|Resources
operator|.
name|none
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Decrease parentLimits "
operator|+
name|parentLimits
operator|+
literal|" for "
operator|+
name|this
operator|.
name|getQueueName
argument_list|()
operator|+
literal|" by "
operator|+
name|resourceToSubtract
operator|+
literal|" as childQueue="
operator|+
name|childQueue
operator|.
name|getQueueName
argument_list|()
operator|+
literal|" is blocked"
argument_list|)
expr_stmt|;
block|}
name|parentLimits
operator|=
name|Resources
operator|.
name|subtract
argument_list|(
name|parentLimits
argument_list|,
name|resourceToSubtract
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|assignment
return|;
block|}
DECL|method|getChildQueuesToPrint ()
name|String
name|getChildQueuesToPrint
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|CSQueue
name|q
range|:
name|childQueues
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|q
operator|.
name|getQueuePath
argument_list|()
operator|+
literal|"usedCapacity=("
operator|+
name|q
operator|.
name|getUsedCapacity
argument_list|()
operator|+
literal|"), "
operator|+
literal|" label=("
operator|+
name|StringUtils
operator|.
name|join
argument_list|(
name|q
operator|.
name|getAccessibleNodeLabels
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|,
literal|","
argument_list|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|printChildQueues ()
specifier|private
name|void
name|printChildQueues
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"printChildQueues - queue: "
operator|+
name|getQueuePath
argument_list|()
operator|+
literal|" child-queues: "
operator|+
name|getChildQueuesToPrint
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|internalReleaseResource (Resource clusterResource, FiCaSchedulerNode node, Resource releasedResource, boolean changeResource, CSQueue completedChildQueue, boolean sortQueues)
specifier|private
specifier|synchronized
name|void
name|internalReleaseResource
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|FiCaSchedulerNode
name|node
parameter_list|,
name|Resource
name|releasedResource
parameter_list|,
name|boolean
name|changeResource
parameter_list|,
name|CSQueue
name|completedChildQueue
parameter_list|,
name|boolean
name|sortQueues
parameter_list|)
block|{
name|super
operator|.
name|releaseResource
argument_list|(
name|clusterResource
argument_list|,
name|releasedResource
argument_list|,
name|node
operator|.
name|getPartition
argument_list|()
argument_list|,
name|changeResource
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"completedContainer "
operator|+
name|this
operator|+
literal|", cluster="
operator|+
name|clusterResource
argument_list|)
expr_stmt|;
block|}
comment|// Note that this is using an iterator on the childQueues so this can't
comment|// be called if already within an iterator for the childQueues. Like
comment|// from assignContainersToChildQueues.
if|if
condition|(
name|sortQueues
condition|)
block|{
comment|// reinsert the updated queue
for|for
control|(
name|Iterator
argument_list|<
name|CSQueue
argument_list|>
name|iter
init|=
name|childQueues
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|CSQueue
name|csqueue
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|csqueue
operator|.
name|equals
argument_list|(
name|completedChildQueue
argument_list|)
condition|)
block|{
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Re-sorting completed queue: "
operator|+
name|csqueue
argument_list|)
expr_stmt|;
block|}
name|childQueues
operator|.
name|add
argument_list|(
name|csqueue
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|// If we skipped sort queue this time, we need to resort queues to make
comment|// sure we allocate from least usage (or order defined by queue policy)
comment|// queues.
name|needToResortQueuesAtNextAllocation
operator|=
operator|!
name|sortQueues
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|decreaseContainer (Resource clusterResource, SchedContainerChangeRequest decreaseRequest, FiCaSchedulerApp app)
specifier|public
name|void
name|decreaseContainer
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|SchedContainerChangeRequest
name|decreaseRequest
parameter_list|,
name|FiCaSchedulerApp
name|app
parameter_list|)
throws|throws
name|InvalidResourceRequestException
block|{
comment|// delta capacity is negative when it's a decrease request
name|Resource
name|absDeltaCapacity
init|=
name|Resources
operator|.
name|negate
argument_list|(
name|decreaseRequest
operator|.
name|getDeltaCapacity
argument_list|()
argument_list|)
decl_stmt|;
name|internalReleaseResource
argument_list|(
name|clusterResource
argument_list|,
name|csContext
operator|.
name|getNode
argument_list|(
name|decreaseRequest
operator|.
name|getNodeId
argument_list|()
argument_list|)
argument_list|,
name|absDeltaCapacity
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Inform the parent
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|parent
operator|.
name|decreaseContainer
argument_list|(
name|clusterResource
argument_list|,
name|decreaseRequest
argument_list|,
name|app
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|unreserveIncreasedContainer (Resource clusterResource, FiCaSchedulerApp app, FiCaSchedulerNode node, RMContainer rmContainer)
specifier|public
name|void
name|unreserveIncreasedContainer
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|FiCaSchedulerApp
name|app
parameter_list|,
name|FiCaSchedulerNode
name|node
parameter_list|,
name|RMContainer
name|rmContainer
parameter_list|)
block|{
if|if
condition|(
name|app
operator|!=
literal|null
condition|)
block|{
name|internalReleaseResource
argument_list|(
name|clusterResource
argument_list|,
name|node
argument_list|,
name|rmContainer
operator|.
name|getReservedResource
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Inform the parent
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|parent
operator|.
name|unreserveIncreasedContainer
argument_list|(
name|clusterResource
argument_list|,
name|app
argument_list|,
name|node
argument_list|,
name|rmContainer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|completedContainer (Resource clusterResource, FiCaSchedulerApp application, FiCaSchedulerNode node, RMContainer rmContainer, ContainerStatus containerStatus, RMContainerEventType event, CSQueue completedChildQueue, boolean sortQueues)
specifier|public
name|void
name|completedContainer
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|FiCaSchedulerApp
name|application
parameter_list|,
name|FiCaSchedulerNode
name|node
parameter_list|,
name|RMContainer
name|rmContainer
parameter_list|,
name|ContainerStatus
name|containerStatus
parameter_list|,
name|RMContainerEventType
name|event
parameter_list|,
name|CSQueue
name|completedChildQueue
parameter_list|,
name|boolean
name|sortQueues
parameter_list|)
block|{
if|if
condition|(
name|application
operator|!=
literal|null
condition|)
block|{
name|internalReleaseResource
argument_list|(
name|clusterResource
argument_list|,
name|node
argument_list|,
name|rmContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getResource
argument_list|()
argument_list|,
literal|false
argument_list|,
name|completedChildQueue
argument_list|,
name|sortQueues
argument_list|)
expr_stmt|;
comment|// Inform the parent
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
comment|// complete my parent
name|parent
operator|.
name|completedContainer
argument_list|(
name|clusterResource
argument_list|,
name|application
argument_list|,
name|node
argument_list|,
name|rmContainer
argument_list|,
literal|null
argument_list|,
name|event
argument_list|,
name|this
argument_list|,
name|sortQueues
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|updateClusterResource (Resource clusterResource, ResourceLimits resourceLimits)
specifier|public
specifier|synchronized
name|void
name|updateClusterResource
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|ResourceLimits
name|resourceLimits
parameter_list|)
block|{
comment|// Update all children
for|for
control|(
name|CSQueue
name|childQueue
range|:
name|childQueues
control|)
block|{
comment|// Get ResourceLimits of child queue before assign containers
name|ResourceLimits
name|childLimits
init|=
name|getResourceLimitsOfChild
argument_list|(
name|childQueue
argument_list|,
name|clusterResource
argument_list|,
name|resourceLimits
operator|.
name|getLimit
argument_list|()
argument_list|,
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|)
decl_stmt|;
name|childQueue
operator|.
name|updateClusterResource
argument_list|(
name|clusterResource
argument_list|,
name|childLimits
argument_list|)
expr_stmt|;
block|}
name|CSQueueUtils
operator|.
name|updateQueueStatistics
argument_list|(
name|resourceCalculator
argument_list|,
name|clusterResource
argument_list|,
name|minimumAllocation
argument_list|,
name|this
argument_list|,
name|labelManager
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getChildQueues ()
specifier|public
specifier|synchronized
name|List
argument_list|<
name|CSQueue
argument_list|>
name|getChildQueues
parameter_list|()
block|{
return|return
operator|new
name|ArrayList
argument_list|<
name|CSQueue
argument_list|>
argument_list|(
name|childQueues
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|recoverContainer (Resource clusterResource, SchedulerApplicationAttempt attempt, RMContainer rmContainer)
specifier|public
name|void
name|recoverContainer
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|SchedulerApplicationAttempt
name|attempt
parameter_list|,
name|RMContainer
name|rmContainer
parameter_list|)
block|{
if|if
condition|(
name|rmContainer
operator|.
name|getState
argument_list|()
operator|.
name|equals
argument_list|(
name|RMContainerState
operator|.
name|COMPLETED
argument_list|)
condition|)
block|{
return|return;
block|}
comment|// Careful! Locking order is important!
synchronized|synchronized
init|(
name|this
init|)
block|{
name|FiCaSchedulerNode
name|node
init|=
name|scheduler
operator|.
name|getNode
argument_list|(
name|rmContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
name|allocateResource
argument_list|(
name|clusterResource
argument_list|,
name|rmContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getResource
argument_list|()
argument_list|,
name|node
operator|.
name|getPartition
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|parent
operator|.
name|recoverContainer
argument_list|(
name|clusterResource
argument_list|,
name|attempt
argument_list|,
name|rmContainer
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getActiveUsersManager ()
specifier|public
name|ActiveUsersManager
name|getActiveUsersManager
parameter_list|()
block|{
comment|// Should never be called since all applications are submitted to LeafQueues
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|collectSchedulerApplications ( Collection<ApplicationAttemptId> apps)
specifier|public
specifier|synchronized
name|void
name|collectSchedulerApplications
parameter_list|(
name|Collection
argument_list|<
name|ApplicationAttemptId
argument_list|>
name|apps
parameter_list|)
block|{
for|for
control|(
name|CSQueue
name|queue
range|:
name|childQueues
control|)
block|{
name|queue
operator|.
name|collectSchedulerApplications
argument_list|(
name|apps
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|attachContainer (Resource clusterResource, FiCaSchedulerApp application, RMContainer rmContainer)
specifier|public
name|void
name|attachContainer
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|FiCaSchedulerApp
name|application
parameter_list|,
name|RMContainer
name|rmContainer
parameter_list|)
block|{
if|if
condition|(
name|application
operator|!=
literal|null
condition|)
block|{
name|FiCaSchedulerNode
name|node
init|=
name|scheduler
operator|.
name|getNode
argument_list|(
name|rmContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
name|allocateResource
argument_list|(
name|clusterResource
argument_list|,
name|rmContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getResource
argument_list|()
argument_list|,
name|node
operator|.
name|getPartition
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"movedContainer"
operator|+
literal|" queueMoveIn="
operator|+
name|getQueueName
argument_list|()
operator|+
literal|" usedCapacity="
operator|+
name|getUsedCapacity
argument_list|()
operator|+
literal|" absoluteUsedCapacity="
operator|+
name|getAbsoluteUsedCapacity
argument_list|()
operator|+
literal|" used="
operator|+
name|queueUsage
operator|.
name|getUsed
argument_list|()
operator|+
literal|" cluster="
operator|+
name|clusterResource
argument_list|)
expr_stmt|;
comment|// Inform the parent
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|parent
operator|.
name|attachContainer
argument_list|(
name|clusterResource
argument_list|,
name|application
argument_list|,
name|rmContainer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|detachContainer (Resource clusterResource, FiCaSchedulerApp application, RMContainer rmContainer)
specifier|public
name|void
name|detachContainer
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|FiCaSchedulerApp
name|application
parameter_list|,
name|RMContainer
name|rmContainer
parameter_list|)
block|{
if|if
condition|(
name|application
operator|!=
literal|null
condition|)
block|{
name|FiCaSchedulerNode
name|node
init|=
name|scheduler
operator|.
name|getNode
argument_list|(
name|rmContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
name|super
operator|.
name|releaseResource
argument_list|(
name|clusterResource
argument_list|,
name|rmContainer
operator|.
name|getContainer
argument_list|()
operator|.
name|getResource
argument_list|()
argument_list|,
name|node
operator|.
name|getPartition
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"movedContainer"
operator|+
literal|" queueMoveOut="
operator|+
name|getQueueName
argument_list|()
operator|+
literal|" usedCapacity="
operator|+
name|getUsedCapacity
argument_list|()
operator|+
literal|" absoluteUsedCapacity="
operator|+
name|getAbsoluteUsedCapacity
argument_list|()
operator|+
literal|" used="
operator|+
name|queueUsage
operator|.
name|getUsed
argument_list|()
operator|+
literal|" cluster="
operator|+
name|clusterResource
argument_list|)
expr_stmt|;
comment|// Inform the parent
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|parent
operator|.
name|detachContainer
argument_list|(
name|clusterResource
argument_list|,
name|application
argument_list|,
name|rmContainer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getNumApplications ()
specifier|public
specifier|synchronized
name|int
name|getNumApplications
parameter_list|()
block|{
return|return
name|numApplications
return|;
block|}
DECL|method|allocateResource (Resource clusterResource, Resource resource, String nodePartition, boolean changeContainerResource)
specifier|synchronized
name|void
name|allocateResource
parameter_list|(
name|Resource
name|clusterResource
parameter_list|,
name|Resource
name|resource
parameter_list|,
name|String
name|nodePartition
parameter_list|,
name|boolean
name|changeContainerResource
parameter_list|)
block|{
name|super
operator|.
name|allocateResource
argument_list|(
name|clusterResource
argument_list|,
name|resource
argument_list|,
name|nodePartition
argument_list|,
name|changeContainerResource
argument_list|)
expr_stmt|;
comment|/**      * check if we need to kill (killable) containers if maximum resource violated.      * Doing this because we will deduct killable resource when going from root.      * For example:      *<pre>      *      Root      *      /   \      *     a     b      *   /  \      *  a1  a2      *</pre>      *      * a: max=10G, used=10G, killable=2G      * a1: used=8G, killable=2G      * a2: used=2G, pending=2G, killable=0G      *      * When we get queue-a to allocate resource, even if queue-a      * reaches its max resource, we deduct its used by killable, so we can allocate      * at most 2G resources. ResourceLimits passed down to a2 has headroom set to 2G.      *      * If scheduler finds a 2G available resource in existing cluster, and assigns it      * to a2, now a2's used= 2G + 2G = 4G, and a's used = 8G + 4G = 12G> 10G      *      * When this happens, we have to preempt killable container (on same or different      * nodes) of parent queue to avoid violating parent's max resource.      */
if|if
condition|(
name|getQueueCapacities
argument_list|()
operator|.
name|getAbsoluteMaximumCapacity
argument_list|(
name|nodePartition
argument_list|)
operator|<
name|getQueueCapacities
argument_list|()
operator|.
name|getAbsoluteUsedCapacity
argument_list|(
name|nodePartition
argument_list|)
condition|)
block|{
name|killContainersToEnforceMaxQueueCapacity
argument_list|(
name|nodePartition
argument_list|,
name|clusterResource
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|killContainersToEnforceMaxQueueCapacity (String partition, Resource clusterResource)
specifier|private
name|void
name|killContainersToEnforceMaxQueueCapacity
parameter_list|(
name|String
name|partition
parameter_list|,
name|Resource
name|clusterResource
parameter_list|)
block|{
name|Iterator
argument_list|<
name|RMContainer
argument_list|>
name|killableContainerIter
init|=
name|getKillableContainers
argument_list|(
name|partition
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|killableContainerIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return;
block|}
name|Resource
name|partitionResource
init|=
name|labelManager
operator|.
name|getResourceByLabel
argument_list|(
name|partition
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Resource
name|maxResource
init|=
name|Resources
operator|.
name|multiply
argument_list|(
name|partitionResource
argument_list|,
name|getQueueCapacities
argument_list|()
operator|.
name|getAbsoluteMaximumCapacity
argument_list|(
name|partition
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|Resources
operator|.
name|greaterThan
argument_list|(
name|resourceCalculator
argument_list|,
name|partitionResource
argument_list|,
name|queueUsage
operator|.
name|getUsed
argument_list|(
name|partition
argument_list|)
argument_list|,
name|maxResource
argument_list|)
condition|)
block|{
name|RMContainer
name|toKillContainer
init|=
name|killableContainerIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|FiCaSchedulerApp
name|attempt
init|=
name|csContext
operator|.
name|getApplicationAttempt
argument_list|(
name|toKillContainer
operator|.
name|getContainerId
argument_list|()
operator|.
name|getApplicationAttemptId
argument_list|()
argument_list|)
decl_stmt|;
name|FiCaSchedulerNode
name|node
init|=
name|csContext
operator|.
name|getNode
argument_list|(
name|toKillContainer
operator|.
name|getAllocatedNode
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|attempt
operator|&&
literal|null
operator|!=
name|node
condition|)
block|{
name|LeafQueue
name|lq
init|=
name|attempt
operator|.
name|getCSLeafQueue
argument_list|()
decl_stmt|;
name|lq
operator|.
name|completedContainer
argument_list|(
name|clusterResource
argument_list|,
name|attempt
argument_list|,
name|node
argument_list|,
name|toKillContainer
argument_list|,
name|SchedulerUtils
operator|.
name|createPreemptedContainerStatus
argument_list|(
name|toKillContainer
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|SchedulerUtils
operator|.
name|PREEMPTED_CONTAINER
argument_list|)
argument_list|,
name|RMContainerEventType
operator|.
name|KILL
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Killed container="
operator|+
name|toKillContainer
operator|.
name|getContainerId
argument_list|()
operator|+
literal|" from queue="
operator|+
name|lq
operator|.
name|getQueueName
argument_list|()
operator|+
literal|" to make queue="
operator|+
name|this
operator|.
name|getQueueName
argument_list|()
operator|+
literal|"'s max-capacity enforced"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|killableContainerIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
block|}
block|}
end_class

end_unit

