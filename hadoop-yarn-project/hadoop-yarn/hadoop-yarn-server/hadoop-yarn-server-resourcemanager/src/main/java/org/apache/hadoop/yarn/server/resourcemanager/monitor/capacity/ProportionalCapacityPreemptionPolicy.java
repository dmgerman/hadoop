begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.resourcemanager.monitor.capacity
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|monitor
operator|.
name|capacity
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationAttemptId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnRuntimeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|RMContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|monitor
operator|.
name|SchedulingEditPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|nodelabels
operator|.
name|RMNodeLabelsManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|PreemptableResourceScheduler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|CSQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|CapacityScheduler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|CapacitySchedulerConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|ParentQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|QueueCapacities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|preemption
operator|.
name|PreemptableQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|ContainerPreemptEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|SchedulerEventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|Clock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|SystemClock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|ResourceCalculator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|Resources
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|MessageFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
operator|.
name|ReadLock
import|;
end_import

begin_comment
comment|/**  * This class implement a {@link SchedulingEditPolicy} that is designed to be  * paired with the {@code CapacityScheduler}. At every invocation of {@code  * editSchedule()} it computes the ideal amount of resources assigned to each  * queue (for each queue in the hierarchy), and determines whether preemption  * is needed. Overcapacity is distributed among queues in a weighted fair manner,  * where the weight is the amount of guaranteed capacity for the queue.  * Based on this ideal assignment it determines whether preemption is required  * and select a set of containers from each application that would be killed if  * the corresponding amount of resources is not freed up by the application.  *  * If not in {@code observeOnly} mode, it triggers preemption requests via a  * {@link ContainerPreemptEvent} that the {@code ResourceManager} will ensure  * to deliver to the application (or to execute).  *  * If the deficit of resources is persistent over a long enough period of time  * this policy will trigger forced termination of containers (again by generating  * {@link ContainerPreemptEvent}).  */
end_comment

begin_class
DECL|class|ProportionalCapacityPreemptionPolicy
specifier|public
class|class
name|ProportionalCapacityPreemptionPolicy
implements|implements
name|SchedulingEditPolicy
implements|,
name|CapacitySchedulerPreemptionContext
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ProportionalCapacityPreemptionPolicy
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|clock
specifier|private
specifier|final
name|Clock
name|clock
decl_stmt|;
comment|// Configurable fields
DECL|field|maxIgnoredOverCapacity
specifier|private
name|double
name|maxIgnoredOverCapacity
decl_stmt|;
DECL|field|maxWaitTime
specifier|private
name|long
name|maxWaitTime
decl_stmt|;
DECL|field|monitoringInterval
specifier|private
name|long
name|monitoringInterval
decl_stmt|;
DECL|field|percentageClusterPreemptionAllowed
specifier|private
name|float
name|percentageClusterPreemptionAllowed
decl_stmt|;
DECL|field|naturalTerminationFactor
specifier|private
name|double
name|naturalTerminationFactor
decl_stmt|;
DECL|field|observeOnly
specifier|private
name|boolean
name|observeOnly
decl_stmt|;
DECL|field|lazyPreempionEnabled
specifier|private
name|boolean
name|lazyPreempionEnabled
decl_stmt|;
DECL|field|maxAllowableLimitForIntraQueuePreemption
specifier|private
name|float
name|maxAllowableLimitForIntraQueuePreemption
decl_stmt|;
DECL|field|minimumThresholdForIntraQueuePreemption
specifier|private
name|float
name|minimumThresholdForIntraQueuePreemption
decl_stmt|;
comment|// Pointer to other RM components
DECL|field|rmContext
specifier|private
name|RMContext
name|rmContext
decl_stmt|;
DECL|field|rc
specifier|private
name|ResourceCalculator
name|rc
decl_stmt|;
DECL|field|scheduler
specifier|private
name|CapacityScheduler
name|scheduler
decl_stmt|;
DECL|field|nlm
specifier|private
name|RMNodeLabelsManager
name|nlm
decl_stmt|;
comment|// Internal properties to make decisions of what to preempt
DECL|field|preemptionCandidates
specifier|private
specifier|final
name|Map
argument_list|<
name|RMContainer
argument_list|,
name|Long
argument_list|>
name|preemptionCandidates
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|queueToPartitions
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|TempQueuePerPartition
argument_list|>
argument_list|>
name|queueToPartitions
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|partitionToUnderServedQueues
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|LinkedHashSet
argument_list|<
name|String
argument_list|>
argument_list|>
name|partitionToUnderServedQueues
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|LinkedHashSet
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|List
argument_list|<
name|PreemptionCandidatesSelector
argument_list|>
DECL|field|candidatesSelectionPolicies
name|candidatesSelectionPolicies
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|allPartitions
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|allPartitions
decl_stmt|;
DECL|field|leafQueueNames
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|leafQueueNames
decl_stmt|;
comment|// Preemptable Entities, synced from scheduler at every run
DECL|field|preemptableQueues
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|PreemptableQueue
argument_list|>
name|preemptableQueues
decl_stmt|;
DECL|field|killableContainers
specifier|private
name|Set
argument_list|<
name|ContainerId
argument_list|>
name|killableContainers
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|ProportionalCapacityPreemptionPolicy ()
specifier|public
name|ProportionalCapacityPreemptionPolicy
parameter_list|()
block|{
name|clock
operator|=
name|SystemClock
operator|.
name|getInstance
argument_list|()
expr_stmt|;
name|allPartitions
operator|=
name|Collections
operator|.
name|EMPTY_SET
expr_stmt|;
name|leafQueueNames
operator|=
name|Collections
operator|.
name|EMPTY_SET
expr_stmt|;
name|preemptableQueues
operator|=
name|Collections
operator|.
name|EMPTY_MAP
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|VisibleForTesting
DECL|method|ProportionalCapacityPreemptionPolicy (RMContext context, CapacityScheduler scheduler, Clock clock)
specifier|public
name|ProportionalCapacityPreemptionPolicy
parameter_list|(
name|RMContext
name|context
parameter_list|,
name|CapacityScheduler
name|scheduler
parameter_list|,
name|Clock
name|clock
parameter_list|)
block|{
name|init
argument_list|(
name|context
operator|.
name|getYarnConfiguration
argument_list|()
argument_list|,
name|context
argument_list|,
name|scheduler
argument_list|)
expr_stmt|;
name|this
operator|.
name|clock
operator|=
name|clock
expr_stmt|;
name|allPartitions
operator|=
name|Collections
operator|.
name|EMPTY_SET
expr_stmt|;
name|leafQueueNames
operator|=
name|Collections
operator|.
name|EMPTY_SET
expr_stmt|;
name|preemptableQueues
operator|=
name|Collections
operator|.
name|EMPTY_MAP
expr_stmt|;
block|}
DECL|method|init (Configuration config, RMContext context, PreemptableResourceScheduler sched)
specifier|public
name|void
name|init
parameter_list|(
name|Configuration
name|config
parameter_list|,
name|RMContext
name|context
parameter_list|,
name|PreemptableResourceScheduler
name|sched
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Preemption monitor:"
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
argument_list|)
expr_stmt|;
assert|assert
literal|null
operator|==
name|scheduler
operator|:
literal|"Unexpected duplicate call to init"
assert|;
if|if
condition|(
operator|!
operator|(
name|sched
operator|instanceof
name|CapacityScheduler
operator|)
condition|)
block|{
throw|throw
operator|new
name|YarnRuntimeException
argument_list|(
literal|"Class "
operator|+
name|sched
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|" not instance of "
operator|+
name|CapacityScheduler
operator|.
name|class
operator|.
name|getCanonicalName
argument_list|()
argument_list|)
throw|;
block|}
name|rmContext
operator|=
name|context
expr_stmt|;
name|scheduler
operator|=
operator|(
name|CapacityScheduler
operator|)
name|sched
expr_stmt|;
name|CapacitySchedulerConfiguration
name|csConfig
init|=
name|scheduler
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|maxIgnoredOverCapacity
operator|=
name|csConfig
operator|.
name|getDouble
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|PREEMPTION_MAX_IGNORED_OVER_CAPACITY
argument_list|,
name|CapacitySchedulerConfiguration
operator|.
name|DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY
argument_list|)
expr_stmt|;
name|naturalTerminationFactor
operator|=
name|csConfig
operator|.
name|getDouble
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|PREEMPTION_NATURAL_TERMINATION_FACTOR
argument_list|,
name|CapacitySchedulerConfiguration
operator|.
name|DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR
argument_list|)
expr_stmt|;
name|maxWaitTime
operator|=
name|csConfig
operator|.
name|getLong
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|PREEMPTION_WAIT_TIME_BEFORE_KILL
argument_list|,
name|CapacitySchedulerConfiguration
operator|.
name|DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL
argument_list|)
expr_stmt|;
name|monitoringInterval
operator|=
name|csConfig
operator|.
name|getLong
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|PREEMPTION_MONITORING_INTERVAL
argument_list|,
name|CapacitySchedulerConfiguration
operator|.
name|DEFAULT_PREEMPTION_MONITORING_INTERVAL
argument_list|)
expr_stmt|;
name|percentageClusterPreemptionAllowed
operator|=
name|csConfig
operator|.
name|getFloat
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|TOTAL_PREEMPTION_PER_ROUND
argument_list|,
name|CapacitySchedulerConfiguration
operator|.
name|DEFAULT_TOTAL_PREEMPTION_PER_ROUND
argument_list|)
expr_stmt|;
name|observeOnly
operator|=
name|csConfig
operator|.
name|getBoolean
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|PREEMPTION_OBSERVE_ONLY
argument_list|,
name|CapacitySchedulerConfiguration
operator|.
name|DEFAULT_PREEMPTION_OBSERVE_ONLY
argument_list|)
expr_stmt|;
name|lazyPreempionEnabled
operator|=
name|csConfig
operator|.
name|getBoolean
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|LAZY_PREEMPTION_ENALBED
argument_list|,
name|CapacitySchedulerConfiguration
operator|.
name|DEFAULT_LAZY_PREEMPTION_ENABLED
argument_list|)
expr_stmt|;
name|maxAllowableLimitForIntraQueuePreemption
operator|=
name|csConfig
operator|.
name|getFloat
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT
argument_list|,
name|CapacitySchedulerConfiguration
operator|.
name|DEFAULT_INTRAQUEUE_PREEMPTION_MAX_ALLOWABLE_LIMIT
argument_list|)
expr_stmt|;
name|minimumThresholdForIntraQueuePreemption
operator|=
name|csConfig
operator|.
name|getFloat
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD
argument_list|,
name|CapacitySchedulerConfiguration
operator|.
name|DEFAULT_INTRAQUEUE_PREEMPTION_MINIMUM_THRESHOLD
argument_list|)
expr_stmt|;
name|rc
operator|=
name|scheduler
operator|.
name|getResourceCalculator
argument_list|()
expr_stmt|;
name|nlm
operator|=
name|scheduler
operator|.
name|getRMContext
argument_list|()
operator|.
name|getNodeLabelManager
argument_list|()
expr_stmt|;
comment|// Do we need white queue-priority preemption policy?
name|boolean
name|isQueuePriorityPreemptionEnabled
init|=
name|csConfig
operator|.
name|getPUOrderingPolicyUnderUtilizedPreemptionEnabled
argument_list|()
decl_stmt|;
if|if
condition|(
name|isQueuePriorityPreemptionEnabled
condition|)
block|{
name|candidatesSelectionPolicies
operator|.
name|add
argument_list|(
operator|new
name|QueuePriorityContainerCandidateSelector
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Do we need to specially consider reserved containers?
name|boolean
name|selectCandidatesForResevedContainers
init|=
name|csConfig
operator|.
name|getBoolean
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS
argument_list|,
name|CapacitySchedulerConfiguration
operator|.
name|DEFAULT_PREEMPTION_SELECT_CANDIDATES_FOR_RESERVED_CONTAINERS
argument_list|)
decl_stmt|;
if|if
condition|(
name|selectCandidatesForResevedContainers
condition|)
block|{
name|candidatesSelectionPolicies
operator|.
name|add
argument_list|(
operator|new
name|ReservedContainerCandidatesSelector
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// initialize candidates preemption selection policies
name|candidatesSelectionPolicies
operator|.
name|add
argument_list|(
operator|new
name|FifoCandidatesSelector
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
comment|// Do we need to specially consider intra queue
name|boolean
name|isIntraQueuePreemptionEnabled
init|=
name|csConfig
operator|.
name|getBoolean
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|INTRAQUEUE_PREEMPTION_ENABLED
argument_list|,
name|CapacitySchedulerConfiguration
operator|.
name|DEFAULT_INTRAQUEUE_PREEMPTION_ENABLED
argument_list|)
decl_stmt|;
if|if
condition|(
name|isIntraQueuePreemptionEnabled
condition|)
block|{
name|candidatesSelectionPolicies
operator|.
name|add
argument_list|(
operator|new
name|IntraQueueCandidatesSelector
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getResourceCalculator ()
specifier|public
name|ResourceCalculator
name|getResourceCalculator
parameter_list|()
block|{
return|return
name|rc
return|;
block|}
annotation|@
name|Override
DECL|method|editSchedule ()
specifier|public
specifier|synchronized
name|void
name|editSchedule
parameter_list|()
block|{
name|long
name|startTs
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|CSQueue
name|root
init|=
name|scheduler
operator|.
name|getRootQueue
argument_list|()
decl_stmt|;
name|Resource
name|clusterResources
init|=
name|Resources
operator|.
name|clone
argument_list|(
name|scheduler
operator|.
name|getClusterResource
argument_list|()
argument_list|)
decl_stmt|;
name|containerBasedPreemptOrKill
argument_list|(
name|root
argument_list|,
name|clusterResources
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Total time used="
operator|+
operator|(
name|clock
operator|.
name|getTime
argument_list|()
operator|-
name|startTs
operator|)
operator|+
literal|" ms."
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|preemptOrkillSelectedContainerAfterWait ( Map<ApplicationAttemptId, Set<RMContainer>> selectedCandidates, long currentTime)
specifier|private
name|void
name|preemptOrkillSelectedContainerAfterWait
parameter_list|(
name|Map
argument_list|<
name|ApplicationAttemptId
argument_list|,
name|Set
argument_list|<
name|RMContainer
argument_list|>
argument_list|>
name|selectedCandidates
parameter_list|,
name|long
name|currentTime
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Starting to preempt containers for selectedCandidates and size:"
operator|+
name|selectedCandidates
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// preempt (or kill) the selected containers
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ApplicationAttemptId
argument_list|,
name|Set
argument_list|<
name|RMContainer
argument_list|>
argument_list|>
name|e
range|:
name|selectedCandidates
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ApplicationAttemptId
name|appAttemptId
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Send to scheduler: in app="
operator|+
name|appAttemptId
operator|+
literal|" #containers-to-be-preemptionCandidates="
operator|+
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|RMContainer
name|container
range|:
name|e
operator|.
name|getValue
argument_list|()
control|)
block|{
comment|// if we tried to preempt this for more than maxWaitTime
if|if
condition|(
name|preemptionCandidates
operator|.
name|get
argument_list|(
name|container
argument_list|)
operator|!=
literal|null
operator|&&
name|preemptionCandidates
operator|.
name|get
argument_list|(
name|container
argument_list|)
operator|+
name|maxWaitTime
operator|<=
name|currentTime
condition|)
block|{
comment|// kill it
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|ContainerPreemptEvent
argument_list|(
name|appAttemptId
argument_list|,
name|container
argument_list|,
name|SchedulerEventType
operator|.
name|MARK_CONTAINER_FOR_KILLABLE
argument_list|)
argument_list|)
expr_stmt|;
name|preemptionCandidates
operator|.
name|remove
argument_list|(
name|container
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|preemptionCandidates
operator|.
name|get
argument_list|(
name|container
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|// We already updated the information to scheduler earlier, we need
comment|// not have to raise another event.
continue|continue;
block|}
comment|//otherwise just send preemption events
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|ContainerPreemptEvent
argument_list|(
name|appAttemptId
argument_list|,
name|container
argument_list|,
name|SchedulerEventType
operator|.
name|MARK_CONTAINER_FOR_PREEMPTION
argument_list|)
argument_list|)
expr_stmt|;
name|preemptionCandidates
operator|.
name|put
argument_list|(
name|container
argument_list|,
name|currentTime
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|syncKillableContainersFromScheduler ()
specifier|private
name|void
name|syncKillableContainersFromScheduler
parameter_list|()
block|{
comment|// sync preemptable entities from scheduler
name|preemptableQueues
operator|=
name|scheduler
operator|.
name|getPreemptionManager
argument_list|()
operator|.
name|getShallowCopyOfPreemptableQueues
argument_list|()
expr_stmt|;
name|killableContainers
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|PreemptableQueue
argument_list|>
name|entry
range|:
name|preemptableQueues
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|PreemptableQueue
name|entity
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
argument_list|<
name|ContainerId
argument_list|,
name|RMContainer
argument_list|>
name|map
range|:
name|entity
operator|.
name|getKillableContainers
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|killableContainers
operator|.
name|addAll
argument_list|(
name|map
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|cleanupStaledPreemptionCandidates (long currentTime)
specifier|private
name|void
name|cleanupStaledPreemptionCandidates
parameter_list|(
name|long
name|currentTime
parameter_list|)
block|{
comment|// Keep the preemptionCandidates list clean
comment|// garbage collect containers that are irrelevant for preemption
comment|// And avoid preempt selected containers for *this execution*
comment|// or within 1 ms
name|preemptionCandidates
operator|.
name|entrySet
argument_list|()
operator|.
name|removeIf
argument_list|(
name|candidate
lambda|->
name|candidate
operator|.
name|getValue
argument_list|()
operator|+
literal|2
operator|*
name|maxWaitTime
operator|<
name|currentTime
argument_list|)
expr_stmt|;
block|}
DECL|method|getLeafQueueNames (TempQueuePerPartition q)
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|getLeafQueueNames
parameter_list|(
name|TempQueuePerPartition
name|q
parameter_list|)
block|{
if|if
condition|(
name|q
operator|.
name|children
operator|==
literal|null
operator|||
name|q
operator|.
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|ImmutableSet
operator|.
name|of
argument_list|(
name|q
operator|.
name|queueName
argument_list|)
return|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|leafQueueNames
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|TempQueuePerPartition
name|child
range|:
name|q
operator|.
name|children
control|)
block|{
name|leafQueueNames
operator|.
name|addAll
argument_list|(
name|getLeafQueueNames
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|leafQueueNames
return|;
block|}
comment|/**    * This method selects and tracks containers to be preemptionCandidates. If a container    * is in the target list for more than maxWaitTime it is killed.    *    * @param root the root of the CapacityScheduler queue hierarchy    * @param clusterResources the total amount of resources in the cluster    */
DECL|method|containerBasedPreemptOrKill (CSQueue root, Resource clusterResources)
specifier|private
name|void
name|containerBasedPreemptOrKill
parameter_list|(
name|CSQueue
name|root
parameter_list|,
name|Resource
name|clusterResources
parameter_list|)
block|{
comment|// Sync killable containers from scheduler when lazy preemption enabled
if|if
condition|(
name|lazyPreempionEnabled
condition|)
block|{
name|syncKillableContainersFromScheduler
argument_list|()
expr_stmt|;
block|}
comment|// All partitions to look at
name|Set
argument_list|<
name|String
argument_list|>
name|partitions
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|partitions
operator|.
name|addAll
argument_list|(
name|scheduler
operator|.
name|getRMContext
argument_list|()
operator|.
name|getNodeLabelManager
argument_list|()
operator|.
name|getClusterNodeLabelNames
argument_list|()
argument_list|)
expr_stmt|;
name|partitions
operator|.
name|add
argument_list|(
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|)
expr_stmt|;
name|this
operator|.
name|allPartitions
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|partitions
argument_list|)
expr_stmt|;
comment|// extract a summary of the queues from scheduler
synchronized|synchronized
init|(
name|scheduler
init|)
block|{
name|queueToPartitions
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|partitionToLookAt
range|:
name|allPartitions
control|)
block|{
name|cloneQueues
argument_list|(
name|root
argument_list|,
name|Resources
operator|.
name|clone
argument_list|(
name|nlm
operator|.
name|getResourceByLabel
argument_list|(
name|partitionToLookAt
argument_list|,
name|clusterResources
argument_list|)
argument_list|)
argument_list|,
name|partitionToLookAt
argument_list|)
expr_stmt|;
block|}
comment|// Update effective priority of queues
block|}
name|this
operator|.
name|leafQueueNames
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|getLeafQueueNames
argument_list|(
name|getQueueByPartition
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|ROOT
argument_list|,
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// compute total preemption allowed
name|Resource
name|totalPreemptionAllowed
init|=
name|Resources
operator|.
name|multiply
argument_list|(
name|clusterResources
argument_list|,
name|percentageClusterPreemptionAllowed
argument_list|)
decl_stmt|;
comment|// based on ideal allocation select containers to be preemptionCandidates from each
comment|// queue and each application
name|Map
argument_list|<
name|ApplicationAttemptId
argument_list|,
name|Set
argument_list|<
name|RMContainer
argument_list|>
argument_list|>
name|toPreempt
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|PreemptionCandidatesSelector
name|selector
range|:
name|candidatesSelectionPolicies
control|)
block|{
name|long
name|startTime
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|MessageFormat
operator|.
name|format
argument_list|(
literal|"Trying to use {0} to select preemption candidates"
argument_list|,
name|selector
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|startTime
operator|=
name|clock
operator|.
name|getTime
argument_list|()
expr_stmt|;
block|}
name|toPreempt
operator|=
name|selector
operator|.
name|selectCandidates
argument_list|(
name|toPreempt
argument_list|,
name|clusterResources
argument_list|,
name|totalPreemptionAllowed
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|MessageFormat
operator|.
name|format
argument_list|(
literal|"{0} uses {1} millisecond to run"
argument_list|,
name|selector
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|clock
operator|.
name|getTime
argument_list|()
operator|-
name|startTime
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|totalSelected
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Set
argument_list|<
name|RMContainer
argument_list|>
name|set
range|:
name|toPreempt
operator|.
name|values
argument_list|()
control|)
block|{
name|totalSelected
operator|+=
name|set
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
name|MessageFormat
operator|.
name|format
argument_list|(
literal|"So far, total {0} containers selected to be preempted"
argument_list|,
name|totalSelected
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logToCSV
argument_list|(
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|leafQueueNames
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// if we are in observeOnly mode return before any action is taken
if|if
condition|(
name|observeOnly
condition|)
block|{
return|return;
block|}
comment|// TODO: need consider revert killable containers when no more demandings.
comment|// Since we could have several selectors to make decisions concurrently.
comment|// So computed ideal-allocation varies between different selectors.
comment|//
comment|// We may need to "score" killable containers and revert the most preferred
comment|// containers. The bottom line is, we shouldn't preempt a queue which is already
comment|// below its guaranteed resource.
name|long
name|currentTime
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
comment|// preempt (or kill) the selected containers
name|preemptOrkillSelectedContainerAfterWait
argument_list|(
name|toPreempt
argument_list|,
name|currentTime
argument_list|)
expr_stmt|;
comment|// cleanup staled preemption candidates
name|cleanupStaledPreemptionCandidates
argument_list|(
name|currentTime
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getMonitoringInterval ()
specifier|public
name|long
name|getMonitoringInterval
parameter_list|()
block|{
return|return
name|monitoringInterval
return|;
block|}
annotation|@
name|Override
DECL|method|getPolicyName ()
specifier|public
name|String
name|getPolicyName
parameter_list|()
block|{
return|return
literal|"ProportionalCapacityPreemptionPolicy"
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getToPreemptContainers ()
specifier|public
name|Map
argument_list|<
name|RMContainer
argument_list|,
name|Long
argument_list|>
name|getToPreemptContainers
parameter_list|()
block|{
return|return
name|preemptionCandidates
return|;
block|}
comment|/**    * This method walks a tree of CSQueue and clones the portion of the state    * relevant for preemption in TempQueue(s). It also maintains a pointer to    * the leaves. Finally it aggregates pending resources in each queue and rolls    * it up to higher levels.    *    * @param curQueue current queue which I'm looking at now    * @param partitionResource the total amount of resources in the cluster    * @return the root of the cloned queue hierarchy    */
DECL|method|cloneQueues (CSQueue curQueue, Resource partitionResource, String partitionToLookAt)
specifier|private
name|TempQueuePerPartition
name|cloneQueues
parameter_list|(
name|CSQueue
name|curQueue
parameter_list|,
name|Resource
name|partitionResource
parameter_list|,
name|String
name|partitionToLookAt
parameter_list|)
block|{
name|TempQueuePerPartition
name|ret
decl_stmt|;
name|ReadLock
name|readLock
init|=
name|curQueue
operator|.
name|getReadLock
argument_list|()
decl_stmt|;
try|try
block|{
comment|// Acquire a read lock from Parent/LeafQueue.
name|readLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|String
name|queueName
init|=
name|curQueue
operator|.
name|getQueueName
argument_list|()
decl_stmt|;
name|QueueCapacities
name|qc
init|=
name|curQueue
operator|.
name|getQueueCapacities
argument_list|()
decl_stmt|;
name|float
name|absCap
init|=
name|qc
operator|.
name|getAbsoluteCapacity
argument_list|(
name|partitionToLookAt
argument_list|)
decl_stmt|;
name|float
name|absMaxCap
init|=
name|qc
operator|.
name|getAbsoluteMaximumCapacity
argument_list|(
name|partitionToLookAt
argument_list|)
decl_stmt|;
name|boolean
name|preemptionDisabled
init|=
name|curQueue
operator|.
name|getPreemptionDisabled
argument_list|()
decl_stmt|;
name|Resource
name|current
init|=
name|Resources
operator|.
name|clone
argument_list|(
name|curQueue
operator|.
name|getQueueResourceUsage
argument_list|()
operator|.
name|getUsed
argument_list|(
name|partitionToLookAt
argument_list|)
argument_list|)
decl_stmt|;
name|Resource
name|killable
init|=
name|Resources
operator|.
name|none
argument_list|()
decl_stmt|;
name|Resource
name|reserved
init|=
name|Resources
operator|.
name|clone
argument_list|(
name|curQueue
operator|.
name|getQueueResourceUsage
argument_list|()
operator|.
name|getReserved
argument_list|(
name|partitionToLookAt
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|preemptableQueues
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
condition|)
block|{
name|killable
operator|=
name|Resources
operator|.
name|clone
argument_list|(
name|preemptableQueues
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
operator|.
name|getKillableResource
argument_list|(
name|partitionToLookAt
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// when partition is a non-exclusive partition, the actual maxCapacity
comment|// could more than specified maxCapacity
try|try
block|{
if|if
condition|(
operator|!
name|scheduler
operator|.
name|getRMContext
argument_list|()
operator|.
name|getNodeLabelManager
argument_list|()
operator|.
name|isExclusiveNodeLabel
argument_list|(
name|partitionToLookAt
argument_list|)
condition|)
block|{
name|absMaxCap
operator|=
literal|1.0f
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// This may cause by partition removed when running capacity monitor,
comment|// just ignore the error, this will be corrected when doing next check.
block|}
name|ret
operator|=
operator|new
name|TempQueuePerPartition
argument_list|(
name|queueName
argument_list|,
name|current
argument_list|,
name|preemptionDisabled
argument_list|,
name|partitionToLookAt
argument_list|,
name|killable
argument_list|,
name|absCap
argument_list|,
name|absMaxCap
argument_list|,
name|partitionResource
argument_list|,
name|reserved
argument_list|,
name|curQueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|curQueue
operator|instanceof
name|ParentQueue
condition|)
block|{
name|String
name|configuredOrderingPolicy
init|=
operator|(
operator|(
name|ParentQueue
operator|)
name|curQueue
operator|)
operator|.
name|getQueueOrderingPolicy
argument_list|()
operator|.
name|getConfigName
argument_list|()
decl_stmt|;
comment|// Recursively add children
for|for
control|(
name|CSQueue
name|c
range|:
name|curQueue
operator|.
name|getChildQueues
argument_list|()
control|)
block|{
name|TempQueuePerPartition
name|subq
init|=
name|cloneQueues
argument_list|(
name|c
argument_list|,
name|partitionResource
argument_list|,
name|partitionToLookAt
argument_list|)
decl_stmt|;
comment|// If we respect priority
if|if
condition|(
name|StringUtils
operator|.
name|equals
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|QUEUE_PRIORITY_UTILIZATION_ORDERING_POLICY
argument_list|,
name|configuredOrderingPolicy
argument_list|)
condition|)
block|{
name|subq
operator|.
name|relativePriority
operator|=
name|c
operator|.
name|getPriority
argument_list|()
operator|.
name|getPriority
argument_list|()
expr_stmt|;
block|}
name|ret
operator|.
name|addChild
argument_list|(
name|subq
argument_list|)
expr_stmt|;
name|subq
operator|.
name|parent
operator|=
name|ret
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|readLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|addTempQueuePartition
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|// simple printout function that reports internal queue state (useful for
comment|// plotting)
DECL|method|logToCSV (List<String> leafQueueNames)
specifier|private
name|void
name|logToCSV
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|leafQueueNames
parameter_list|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|leafQueueNames
argument_list|)
expr_stmt|;
name|String
name|queueState
init|=
literal|" QUEUESTATE: "
operator|+
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|queueState
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|queueName
range|:
name|leafQueueNames
control|)
block|{
name|TempQueuePerPartition
name|tq
init|=
name|getQueueByPartition
argument_list|(
name|queueName
argument_list|,
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|tq
operator|.
name|appendLogString
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|addTempQueuePartition (TempQueuePerPartition queuePartition)
specifier|private
name|void
name|addTempQueuePartition
parameter_list|(
name|TempQueuePerPartition
name|queuePartition
parameter_list|)
block|{
name|String
name|queueName
init|=
name|queuePartition
operator|.
name|queueName
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|TempQueuePerPartition
argument_list|>
name|queuePartitions
decl_stmt|;
if|if
condition|(
literal|null
operator|==
operator|(
name|queuePartitions
operator|=
name|queueToPartitions
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
operator|)
condition|)
block|{
name|queuePartitions
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|queueToPartitions
operator|.
name|put
argument_list|(
name|queueName
argument_list|,
name|queuePartitions
argument_list|)
expr_stmt|;
block|}
name|queuePartitions
operator|.
name|put
argument_list|(
name|queuePartition
operator|.
name|partition
argument_list|,
name|queuePartition
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get queue partition by given queueName and partitionName    */
annotation|@
name|Override
DECL|method|getQueueByPartition (String queueName, String partition)
specifier|public
name|TempQueuePerPartition
name|getQueueByPartition
parameter_list|(
name|String
name|queueName
parameter_list|,
name|String
name|partition
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|TempQueuePerPartition
argument_list|>
name|partitionToQueues
decl_stmt|;
if|if
condition|(
literal|null
operator|==
operator|(
name|partitionToQueues
operator|=
name|queueToPartitions
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|YarnRuntimeException
argument_list|(
literal|"This shouldn't happen, cannot find "
operator|+
literal|"TempQueuePerPartition for queueName="
operator|+
name|queueName
argument_list|)
throw|;
block|}
return|return
name|partitionToQueues
operator|.
name|get
argument_list|(
name|partition
argument_list|)
return|;
block|}
comment|/**    * Get all queue partitions by given queueName    */
annotation|@
name|Override
DECL|method|getQueuePartitions (String queueName)
specifier|public
name|Collection
argument_list|<
name|TempQueuePerPartition
argument_list|>
name|getQueuePartitions
parameter_list|(
name|String
name|queueName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|queueToPartitions
operator|.
name|containsKey
argument_list|(
name|queueName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|YarnRuntimeException
argument_list|(
literal|"This shouldn't happen, cannot find "
operator|+
literal|"TempQueuePerPartition collection for queueName="
operator|+
name|queueName
argument_list|)
throw|;
block|}
return|return
name|queueToPartitions
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
operator|.
name|values
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getScheduler ()
specifier|public
name|CapacityScheduler
name|getScheduler
parameter_list|()
block|{
return|return
name|scheduler
return|;
block|}
annotation|@
name|Override
DECL|method|getRMContext ()
specifier|public
name|RMContext
name|getRMContext
parameter_list|()
block|{
return|return
name|rmContext
return|;
block|}
annotation|@
name|Override
DECL|method|isObserveOnly ()
specifier|public
name|boolean
name|isObserveOnly
parameter_list|()
block|{
return|return
name|observeOnly
return|;
block|}
annotation|@
name|Override
DECL|method|getKillableContainers ()
specifier|public
name|Set
argument_list|<
name|ContainerId
argument_list|>
name|getKillableContainers
parameter_list|()
block|{
return|return
name|killableContainers
return|;
block|}
annotation|@
name|Override
DECL|method|getMaxIgnoreOverCapacity ()
specifier|public
name|double
name|getMaxIgnoreOverCapacity
parameter_list|()
block|{
return|return
name|maxIgnoredOverCapacity
return|;
block|}
annotation|@
name|Override
DECL|method|getNaturalTerminationFactor ()
specifier|public
name|double
name|getNaturalTerminationFactor
parameter_list|()
block|{
return|return
name|naturalTerminationFactor
return|;
block|}
annotation|@
name|Override
DECL|method|getLeafQueueNames ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getLeafQueueNames
parameter_list|()
block|{
return|return
name|leafQueueNames
return|;
block|}
annotation|@
name|Override
DECL|method|getAllPartitions ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getAllPartitions
parameter_list|()
block|{
return|return
name|allPartitions
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getQueuePartitions ()
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|TempQueuePerPartition
argument_list|>
argument_list|>
name|getQueuePartitions
parameter_list|()
block|{
return|return
name|queueToPartitions
return|;
block|}
annotation|@
name|Override
DECL|method|getClusterMaxApplicationPriority ()
specifier|public
name|int
name|getClusterMaxApplicationPriority
parameter_list|()
block|{
return|return
name|scheduler
operator|.
name|getMaxClusterLevelAppPriority
argument_list|()
operator|.
name|getPriority
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getMaxAllowableLimitForIntraQueuePreemption ()
specifier|public
name|float
name|getMaxAllowableLimitForIntraQueuePreemption
parameter_list|()
block|{
return|return
name|maxAllowableLimitForIntraQueuePreemption
return|;
block|}
annotation|@
name|Override
DECL|method|getMinimumThresholdForIntraQueuePreemption ()
specifier|public
name|float
name|getMinimumThresholdForIntraQueuePreemption
parameter_list|()
block|{
return|return
name|minimumThresholdForIntraQueuePreemption
return|;
block|}
annotation|@
name|Override
DECL|method|getPartitionResource (String partition)
specifier|public
name|Resource
name|getPartitionResource
parameter_list|(
name|String
name|partition
parameter_list|)
block|{
return|return
name|Resources
operator|.
name|clone
argument_list|(
name|nlm
operator|.
name|getResourceByLabel
argument_list|(
name|partition
argument_list|,
name|Resources
operator|.
name|clone
argument_list|(
name|scheduler
operator|.
name|getClusterResource
argument_list|()
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
DECL|method|getUnderServedQueuesPerPartition ( String partition)
specifier|public
name|LinkedHashSet
argument_list|<
name|String
argument_list|>
name|getUnderServedQueuesPerPartition
parameter_list|(
name|String
name|partition
parameter_list|)
block|{
return|return
name|partitionToUnderServedQueues
operator|.
name|get
argument_list|(
name|partition
argument_list|)
return|;
block|}
DECL|method|addPartitionToUnderServedQueues (String queueName, String partition)
specifier|public
name|void
name|addPartitionToUnderServedQueues
parameter_list|(
name|String
name|queueName
parameter_list|,
name|String
name|partition
parameter_list|)
block|{
name|LinkedHashSet
argument_list|<
name|String
argument_list|>
name|underServedQueues
init|=
name|partitionToUnderServedQueues
operator|.
name|get
argument_list|(
name|partition
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|underServedQueues
condition|)
block|{
name|underServedQueues
operator|=
operator|new
name|LinkedHashSet
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|partitionToUnderServedQueues
operator|.
name|put
argument_list|(
name|partition
argument_list|,
name|underServedQueues
argument_list|)
expr_stmt|;
block|}
name|underServedQueues
operator|.
name|add
argument_list|(
name|queueName
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

