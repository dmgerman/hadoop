begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.resourcemanager.monitor.capacity
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|monitor
operator|.
name|capacity
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationAttemptId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnRuntimeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|RMContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|monitor
operator|.
name|SchedulingEditPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|nodelabels
operator|.
name|RMNodeLabelsManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmcontainer
operator|.
name|RMContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|PreemptableResourceScheduler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|CSQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|CapacityScheduler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|CapacitySchedulerConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|LeafQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|QueueCapacities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
operator|.
name|preemption
operator|.
name|PreemptableQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|ContainerPreemptEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|event
operator|.
name|SchedulerEventType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|Clock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|SystemClock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|ResourceCalculator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|Resources
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * This class implement a {@link SchedulingEditPolicy} that is designed to be  * paired with the {@code CapacityScheduler}. At every invocation of {@code  * editSchedule()} it computes the ideal amount of resources assigned to each  * queue (for each queue in the hierarchy), and determines whether preemption  * is needed. Overcapacity is distributed among queues in a weighted fair manner,  * where the weight is the amount of guaranteed capacity for the queue.  * Based on this ideal assignment it determines whether preemption is required  * and select a set of containers from each application that would be killed if  * the corresponding amount of resources is not freed up by the application.  *  * If not in {@code observeOnly} mode, it triggers preemption requests via a  * {@link ContainerPreemptEvent} that the {@code ResourceManager} will ensure  * to deliver to the application (or to execute).  *  * If the deficit of resources is persistent over a long enough period of time  * this policy will trigger forced termination of containers (again by generating  * {@link ContainerPreemptEvent}).  */
end_comment

begin_class
DECL|class|ProportionalCapacityPreemptionPolicy
specifier|public
class|class
name|ProportionalCapacityPreemptionPolicy
implements|implements
name|SchedulingEditPolicy
implements|,
name|CapacitySchedulerPreemptionContext
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ProportionalCapacityPreemptionPolicy
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|clock
specifier|private
specifier|final
name|Clock
name|clock
decl_stmt|;
comment|// Configurable fields
DECL|field|maxIgnoredOverCapacity
specifier|private
name|double
name|maxIgnoredOverCapacity
decl_stmt|;
DECL|field|maxWaitTime
specifier|private
name|long
name|maxWaitTime
decl_stmt|;
DECL|field|monitoringInterval
specifier|private
name|long
name|monitoringInterval
decl_stmt|;
DECL|field|percentageClusterPreemptionAllowed
specifier|private
name|float
name|percentageClusterPreemptionAllowed
decl_stmt|;
DECL|field|naturalTerminationFactor
specifier|private
name|double
name|naturalTerminationFactor
decl_stmt|;
DECL|field|observeOnly
specifier|private
name|boolean
name|observeOnly
decl_stmt|;
DECL|field|lazyPreempionEnabled
specifier|private
name|boolean
name|lazyPreempionEnabled
decl_stmt|;
comment|// Pointer to other RM components
DECL|field|rmContext
specifier|private
name|RMContext
name|rmContext
decl_stmt|;
DECL|field|rc
specifier|private
name|ResourceCalculator
name|rc
decl_stmt|;
DECL|field|scheduler
specifier|private
name|CapacityScheduler
name|scheduler
decl_stmt|;
DECL|field|nlm
specifier|private
name|RMNodeLabelsManager
name|nlm
decl_stmt|;
comment|// Internal properties to make decisions of what to preempt
DECL|field|preemptionCandidates
specifier|private
specifier|final
name|Map
argument_list|<
name|RMContainer
argument_list|,
name|Long
argument_list|>
name|preemptionCandidates
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|queueToPartitions
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|TempQueuePerPartition
argument_list|>
argument_list|>
name|queueToPartitions
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|List
argument_list|<
name|PreemptionCandidatesSelector
argument_list|>
DECL|field|candidatesSelectionPolicies
name|candidatesSelectionPolicies
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|allPartitions
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|allPartitions
decl_stmt|;
DECL|field|leafQueueNames
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|leafQueueNames
decl_stmt|;
comment|// Preemptable Entities, synced from scheduler at every run
DECL|field|preemptableQueues
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|PreemptableQueue
argument_list|>
name|preemptableQueues
decl_stmt|;
DECL|field|killableContainers
specifier|private
name|Set
argument_list|<
name|ContainerId
argument_list|>
name|killableContainers
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|ProportionalCapacityPreemptionPolicy ()
specifier|public
name|ProportionalCapacityPreemptionPolicy
parameter_list|()
block|{
name|clock
operator|=
name|SystemClock
operator|.
name|getInstance
argument_list|()
expr_stmt|;
name|allPartitions
operator|=
name|Collections
operator|.
name|EMPTY_SET
expr_stmt|;
name|leafQueueNames
operator|=
name|Collections
operator|.
name|EMPTY_SET
expr_stmt|;
name|preemptableQueues
operator|=
name|Collections
operator|.
name|EMPTY_MAP
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|VisibleForTesting
DECL|method|ProportionalCapacityPreemptionPolicy (RMContext context, CapacityScheduler scheduler, Clock clock)
specifier|public
name|ProportionalCapacityPreemptionPolicy
parameter_list|(
name|RMContext
name|context
parameter_list|,
name|CapacityScheduler
name|scheduler
parameter_list|,
name|Clock
name|clock
parameter_list|)
block|{
name|init
argument_list|(
name|context
operator|.
name|getYarnConfiguration
argument_list|()
argument_list|,
name|context
argument_list|,
name|scheduler
argument_list|)
expr_stmt|;
name|this
operator|.
name|clock
operator|=
name|clock
expr_stmt|;
name|allPartitions
operator|=
name|Collections
operator|.
name|EMPTY_SET
expr_stmt|;
name|leafQueueNames
operator|=
name|Collections
operator|.
name|EMPTY_SET
expr_stmt|;
name|preemptableQueues
operator|=
name|Collections
operator|.
name|EMPTY_MAP
expr_stmt|;
block|}
DECL|method|init (Configuration config, RMContext context, PreemptableResourceScheduler sched)
specifier|public
name|void
name|init
parameter_list|(
name|Configuration
name|config
parameter_list|,
name|RMContext
name|context
parameter_list|,
name|PreemptableResourceScheduler
name|sched
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Preemption monitor:"
operator|+
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
argument_list|)
expr_stmt|;
assert|assert
literal|null
operator|==
name|scheduler
operator|:
literal|"Unexpected duplicate call to init"
assert|;
if|if
condition|(
operator|!
operator|(
name|sched
operator|instanceof
name|CapacityScheduler
operator|)
condition|)
block|{
throw|throw
operator|new
name|YarnRuntimeException
argument_list|(
literal|"Class "
operator|+
name|sched
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|" not instance of "
operator|+
name|CapacityScheduler
operator|.
name|class
operator|.
name|getCanonicalName
argument_list|()
argument_list|)
throw|;
block|}
name|rmContext
operator|=
name|context
expr_stmt|;
name|scheduler
operator|=
operator|(
name|CapacityScheduler
operator|)
name|sched
expr_stmt|;
name|CapacitySchedulerConfiguration
name|csConfig
init|=
name|scheduler
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|maxIgnoredOverCapacity
operator|=
name|csConfig
operator|.
name|getDouble
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|PREEMPTION_MAX_IGNORED_OVER_CAPACITY
argument_list|,
name|CapacitySchedulerConfiguration
operator|.
name|DEFAULT_PREEMPTION_MAX_IGNORED_OVER_CAPACITY
argument_list|)
expr_stmt|;
name|naturalTerminationFactor
operator|=
name|csConfig
operator|.
name|getDouble
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|PREEMPTION_NATURAL_TERMINATION_FACTOR
argument_list|,
name|CapacitySchedulerConfiguration
operator|.
name|DEFAULT_PREEMPTION_NATURAL_TERMINATION_FACTOR
argument_list|)
expr_stmt|;
name|maxWaitTime
operator|=
name|csConfig
operator|.
name|getLong
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|PREEMPTION_WAIT_TIME_BEFORE_KILL
argument_list|,
name|CapacitySchedulerConfiguration
operator|.
name|DEFAULT_PREEMPTION_WAIT_TIME_BEFORE_KILL
argument_list|)
expr_stmt|;
name|monitoringInterval
operator|=
name|csConfig
operator|.
name|getLong
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|PREEMPTION_MONITORING_INTERVAL
argument_list|,
name|CapacitySchedulerConfiguration
operator|.
name|DEFAULT_PREEMPTION_MONITORING_INTERVAL
argument_list|)
expr_stmt|;
name|percentageClusterPreemptionAllowed
operator|=
name|csConfig
operator|.
name|getFloat
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|TOTAL_PREEMPTION_PER_ROUND
argument_list|,
name|CapacitySchedulerConfiguration
operator|.
name|DEFAULT_TOTAL_PREEMPTION_PER_ROUND
argument_list|)
expr_stmt|;
name|observeOnly
operator|=
name|csConfig
operator|.
name|getBoolean
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|PREEMPTION_OBSERVE_ONLY
argument_list|,
name|CapacitySchedulerConfiguration
operator|.
name|DEFAULT_PREEMPTION_OBSERVE_ONLY
argument_list|)
expr_stmt|;
name|lazyPreempionEnabled
operator|=
name|csConfig
operator|.
name|getBoolean
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|LAZY_PREEMPTION_ENALBED
argument_list|,
name|CapacitySchedulerConfiguration
operator|.
name|DEFAULT_LAZY_PREEMPTION_ENABLED
argument_list|)
expr_stmt|;
name|rc
operator|=
name|scheduler
operator|.
name|getResourceCalculator
argument_list|()
expr_stmt|;
name|nlm
operator|=
name|scheduler
operator|.
name|getRMContext
argument_list|()
operator|.
name|getNodeLabelManager
argument_list|()
expr_stmt|;
comment|// initialize candidates preemption selection policies
name|candidatesSelectionPolicies
operator|.
name|add
argument_list|(
operator|new
name|FifoCandidatesSelector
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getResourceCalculator ()
specifier|public
name|ResourceCalculator
name|getResourceCalculator
parameter_list|()
block|{
return|return
name|rc
return|;
block|}
annotation|@
name|Override
DECL|method|editSchedule ()
specifier|public
name|void
name|editSchedule
parameter_list|()
block|{
name|CSQueue
name|root
init|=
name|scheduler
operator|.
name|getRootQueue
argument_list|()
decl_stmt|;
name|Resource
name|clusterResources
init|=
name|Resources
operator|.
name|clone
argument_list|(
name|scheduler
operator|.
name|getClusterResource
argument_list|()
argument_list|)
decl_stmt|;
name|containerBasedPreemptOrKill
argument_list|(
name|root
argument_list|,
name|clusterResources
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|preemptOrkillSelectedContainerAfterWait ( Map<ApplicationAttemptId, Set<RMContainer>> selectedCandidates)
specifier|private
name|void
name|preemptOrkillSelectedContainerAfterWait
parameter_list|(
name|Map
argument_list|<
name|ApplicationAttemptId
argument_list|,
name|Set
argument_list|<
name|RMContainer
argument_list|>
argument_list|>
name|selectedCandidates
parameter_list|)
block|{
comment|// preempt (or kill) the selected containers
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ApplicationAttemptId
argument_list|,
name|Set
argument_list|<
name|RMContainer
argument_list|>
argument_list|>
name|e
range|:
name|selectedCandidates
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ApplicationAttemptId
name|appAttemptId
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Send to scheduler: in app="
operator|+
name|appAttemptId
operator|+
literal|" #containers-to-be-preemptionCandidates="
operator|+
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|RMContainer
name|container
range|:
name|e
operator|.
name|getValue
argument_list|()
control|)
block|{
comment|// if we tried to preempt this for more than maxWaitTime
if|if
condition|(
name|preemptionCandidates
operator|.
name|get
argument_list|(
name|container
argument_list|)
operator|!=
literal|null
operator|&&
name|preemptionCandidates
operator|.
name|get
argument_list|(
name|container
argument_list|)
operator|+
name|maxWaitTime
operator|<
name|clock
operator|.
name|getTime
argument_list|()
condition|)
block|{
comment|// kill it
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|ContainerPreemptEvent
argument_list|(
name|appAttemptId
argument_list|,
name|container
argument_list|,
name|SchedulerEventType
operator|.
name|MARK_CONTAINER_FOR_KILLABLE
argument_list|)
argument_list|)
expr_stmt|;
name|preemptionCandidates
operator|.
name|remove
argument_list|(
name|container
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|preemptionCandidates
operator|.
name|get
argument_list|(
name|container
argument_list|)
operator|!=
literal|null
condition|)
block|{
comment|// We already updated the information to scheduler earlier, we need
comment|// not have to raise another event.
continue|continue;
block|}
comment|//otherwise just send preemption events
name|rmContext
operator|.
name|getDispatcher
argument_list|()
operator|.
name|getEventHandler
argument_list|()
operator|.
name|handle
argument_list|(
operator|new
name|ContainerPreemptEvent
argument_list|(
name|appAttemptId
argument_list|,
name|container
argument_list|,
name|SchedulerEventType
operator|.
name|MARK_CONTAINER_FOR_PREEMPTION
argument_list|)
argument_list|)
expr_stmt|;
name|preemptionCandidates
operator|.
name|put
argument_list|(
name|container
argument_list|,
name|clock
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|syncKillableContainersFromScheduler ()
specifier|private
name|void
name|syncKillableContainersFromScheduler
parameter_list|()
block|{
comment|// sync preemptable entities from scheduler
name|preemptableQueues
operator|=
name|scheduler
operator|.
name|getPreemptionManager
argument_list|()
operator|.
name|getShallowCopyOfPreemptableQueues
argument_list|()
expr_stmt|;
name|killableContainers
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|PreemptableQueue
argument_list|>
name|entry
range|:
name|preemptableQueues
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|PreemptableQueue
name|entity
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
argument_list|<
name|ContainerId
argument_list|,
name|RMContainer
argument_list|>
name|map
range|:
name|entity
operator|.
name|getKillableContainers
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|killableContainers
operator|.
name|addAll
argument_list|(
name|map
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|cleanupStaledPreemptionCandidates ()
specifier|private
name|void
name|cleanupStaledPreemptionCandidates
parameter_list|()
block|{
comment|// Keep the preemptionCandidates list clean
for|for
control|(
name|Iterator
argument_list|<
name|RMContainer
argument_list|>
name|i
init|=
name|preemptionCandidates
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|i
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|RMContainer
name|id
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// garbage collect containers that are irrelevant for preemption
if|if
condition|(
name|preemptionCandidates
operator|.
name|get
argument_list|(
name|id
argument_list|)
operator|+
literal|2
operator|*
name|maxWaitTime
operator|<
name|clock
operator|.
name|getTime
argument_list|()
condition|)
block|{
name|i
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|getLeafQueueNames (TempQueuePerPartition q)
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|getLeafQueueNames
parameter_list|(
name|TempQueuePerPartition
name|q
parameter_list|)
block|{
if|if
condition|(
name|q
operator|.
name|children
operator|==
literal|null
operator|||
name|q
operator|.
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|ImmutableSet
operator|.
name|of
argument_list|(
name|q
operator|.
name|queueName
argument_list|)
return|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|leafQueueNames
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|TempQueuePerPartition
name|child
range|:
name|q
operator|.
name|children
control|)
block|{
name|leafQueueNames
operator|.
name|addAll
argument_list|(
name|getLeafQueueNames
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|leafQueueNames
return|;
block|}
comment|/**    * This method selects and tracks containers to be preemptionCandidates. If a container    * is in the target list for more than maxWaitTime it is killed.    *    * @param root the root of the CapacityScheduler queue hierarchy    * @param clusterResources the total amount of resources in the cluster    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|containerBasedPreemptOrKill (CSQueue root, Resource clusterResources)
specifier|private
name|void
name|containerBasedPreemptOrKill
parameter_list|(
name|CSQueue
name|root
parameter_list|,
name|Resource
name|clusterResources
parameter_list|)
block|{
comment|// Sync killable containers from scheduler when lazy preemption enabled
if|if
condition|(
name|lazyPreempionEnabled
condition|)
block|{
name|syncKillableContainersFromScheduler
argument_list|()
expr_stmt|;
block|}
comment|// All partitions to look at
name|Set
argument_list|<
name|String
argument_list|>
name|partitions
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|partitions
operator|.
name|addAll
argument_list|(
name|scheduler
operator|.
name|getRMContext
argument_list|()
operator|.
name|getNodeLabelManager
argument_list|()
operator|.
name|getClusterNodeLabelNames
argument_list|()
argument_list|)
expr_stmt|;
name|partitions
operator|.
name|add
argument_list|(
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|)
expr_stmt|;
name|this
operator|.
name|allPartitions
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|partitions
argument_list|)
expr_stmt|;
comment|// extract a summary of the queues from scheduler
synchronized|synchronized
init|(
name|scheduler
init|)
block|{
name|queueToPartitions
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|partitionToLookAt
range|:
name|allPartitions
control|)
block|{
name|cloneQueues
argument_list|(
name|root
argument_list|,
name|nlm
operator|.
name|getResourceByLabel
argument_list|(
name|partitionToLookAt
argument_list|,
name|clusterResources
argument_list|)
argument_list|,
name|partitionToLookAt
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|leafQueueNames
operator|=
name|ImmutableSet
operator|.
name|copyOf
argument_list|(
name|getLeafQueueNames
argument_list|(
name|getQueueByPartition
argument_list|(
name|CapacitySchedulerConfiguration
operator|.
name|ROOT
argument_list|,
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// compute total preemption allowed
name|Resource
name|totalPreemptionAllowed
init|=
name|Resources
operator|.
name|multiply
argument_list|(
name|clusterResources
argument_list|,
name|percentageClusterPreemptionAllowed
argument_list|)
decl_stmt|;
comment|// based on ideal allocation select containers to be preemptionCandidates from each
comment|// queue and each application
name|Map
argument_list|<
name|ApplicationAttemptId
argument_list|,
name|Set
argument_list|<
name|RMContainer
argument_list|>
argument_list|>
name|toPreempt
init|=
literal|null
decl_stmt|;
for|for
control|(
name|PreemptionCandidatesSelector
name|selector
range|:
name|candidatesSelectionPolicies
control|)
block|{
name|toPreempt
operator|=
name|selector
operator|.
name|selectCandidates
argument_list|(
name|toPreempt
argument_list|,
name|clusterResources
argument_list|,
name|totalPreemptionAllowed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logToCSV
argument_list|(
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|leafQueueNames
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// if we are in observeOnly mode return before any action is taken
if|if
condition|(
name|observeOnly
condition|)
block|{
return|return;
block|}
comment|// TODO: need consider revert killable containers when no more demandings.
comment|// Since we could have several selectors to make decisions concurrently.
comment|// So computed ideal-allocation varies between different selectors.
comment|//
comment|// We may need to "score" killable containers and revert the most preferred
comment|// containers. The bottom line is, we shouldn't preempt a queue which is already
comment|// below its guaranteed resource.
comment|// preempt (or kill) the selected containers
name|preemptOrkillSelectedContainerAfterWait
argument_list|(
name|toPreempt
argument_list|)
expr_stmt|;
comment|// cleanup staled preemption candidates
name|cleanupStaledPreemptionCandidates
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getMonitoringInterval ()
specifier|public
name|long
name|getMonitoringInterval
parameter_list|()
block|{
return|return
name|monitoringInterval
return|;
block|}
annotation|@
name|Override
DECL|method|getPolicyName ()
specifier|public
name|String
name|getPolicyName
parameter_list|()
block|{
return|return
literal|"ProportionalCapacityPreemptionPolicy"
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getToPreemptContainers ()
specifier|public
name|Map
argument_list|<
name|RMContainer
argument_list|,
name|Long
argument_list|>
name|getToPreemptContainers
parameter_list|()
block|{
return|return
name|preemptionCandidates
return|;
block|}
comment|/**    * This method walks a tree of CSQueue and clones the portion of the state    * relevant for preemption in TempQueue(s). It also maintains a pointer to    * the leaves. Finally it aggregates pending resources in each queue and rolls    * it up to higher levels.    *    * @param curQueue current queue which I'm looking at now    * @param partitionResource the total amount of resources in the cluster    * @return the root of the cloned queue hierarchy    */
DECL|method|cloneQueues (CSQueue curQueue, Resource partitionResource, String partitionToLookAt)
specifier|private
name|TempQueuePerPartition
name|cloneQueues
parameter_list|(
name|CSQueue
name|curQueue
parameter_list|,
name|Resource
name|partitionResource
parameter_list|,
name|String
name|partitionToLookAt
parameter_list|)
block|{
name|TempQueuePerPartition
name|ret
decl_stmt|;
synchronized|synchronized
init|(
name|curQueue
init|)
block|{
name|String
name|queueName
init|=
name|curQueue
operator|.
name|getQueueName
argument_list|()
decl_stmt|;
name|QueueCapacities
name|qc
init|=
name|curQueue
operator|.
name|getQueueCapacities
argument_list|()
decl_stmt|;
name|float
name|absCap
init|=
name|qc
operator|.
name|getAbsoluteCapacity
argument_list|(
name|partitionToLookAt
argument_list|)
decl_stmt|;
name|float
name|absMaxCap
init|=
name|qc
operator|.
name|getAbsoluteMaximumCapacity
argument_list|(
name|partitionToLookAt
argument_list|)
decl_stmt|;
name|boolean
name|preemptionDisabled
init|=
name|curQueue
operator|.
name|getPreemptionDisabled
argument_list|()
decl_stmt|;
name|Resource
name|current
init|=
name|curQueue
operator|.
name|getQueueResourceUsage
argument_list|()
operator|.
name|getUsed
argument_list|(
name|partitionToLookAt
argument_list|)
decl_stmt|;
name|Resource
name|guaranteed
init|=
name|Resources
operator|.
name|multiply
argument_list|(
name|partitionResource
argument_list|,
name|absCap
argument_list|)
decl_stmt|;
name|Resource
name|maxCapacity
init|=
name|Resources
operator|.
name|multiply
argument_list|(
name|partitionResource
argument_list|,
name|absMaxCap
argument_list|)
decl_stmt|;
name|Resource
name|killable
init|=
name|Resources
operator|.
name|none
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|preemptableQueues
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
condition|)
block|{
name|killable
operator|=
name|preemptableQueues
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
operator|.
name|getKillableResource
argument_list|(
name|partitionToLookAt
argument_list|)
expr_stmt|;
block|}
comment|// when partition is a non-exclusive partition, the actual maxCapacity
comment|// could more than specified maxCapacity
try|try
block|{
if|if
condition|(
operator|!
name|scheduler
operator|.
name|getRMContext
argument_list|()
operator|.
name|getNodeLabelManager
argument_list|()
operator|.
name|isExclusiveNodeLabel
argument_list|(
name|partitionToLookAt
argument_list|)
condition|)
block|{
name|maxCapacity
operator|=
name|Resources
operator|.
name|max
argument_list|(
name|rc
argument_list|,
name|partitionResource
argument_list|,
name|maxCapacity
argument_list|,
name|current
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// This may cause by partition removed when running capacity monitor,
comment|// just ignore the error, this will be corrected when doing next check.
block|}
name|Resource
name|extra
init|=
name|Resource
operator|.
name|newInstance
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|Resources
operator|.
name|greaterThan
argument_list|(
name|rc
argument_list|,
name|partitionResource
argument_list|,
name|current
argument_list|,
name|guaranteed
argument_list|)
condition|)
block|{
name|extra
operator|=
name|Resources
operator|.
name|subtract
argument_list|(
name|current
argument_list|,
name|guaranteed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curQueue
operator|instanceof
name|LeafQueue
condition|)
block|{
name|LeafQueue
name|l
init|=
operator|(
name|LeafQueue
operator|)
name|curQueue
decl_stmt|;
name|Resource
name|pending
init|=
name|l
operator|.
name|getTotalPendingResourcesConsideringUserLimit
argument_list|(
name|partitionResource
argument_list|,
name|partitionToLookAt
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|new
name|TempQueuePerPartition
argument_list|(
name|queueName
argument_list|,
name|current
argument_list|,
name|pending
argument_list|,
name|guaranteed
argument_list|,
name|maxCapacity
argument_list|,
name|preemptionDisabled
argument_list|,
name|partitionToLookAt
argument_list|,
name|killable
argument_list|)
expr_stmt|;
if|if
condition|(
name|preemptionDisabled
condition|)
block|{
name|ret
operator|.
name|untouchableExtra
operator|=
name|extra
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|.
name|preemptableExtra
operator|=
name|extra
expr_stmt|;
block|}
name|ret
operator|.
name|setLeafQueue
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Resource
name|pending
init|=
name|Resource
operator|.
name|newInstance
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|new
name|TempQueuePerPartition
argument_list|(
name|curQueue
operator|.
name|getQueueName
argument_list|()
argument_list|,
name|current
argument_list|,
name|pending
argument_list|,
name|guaranteed
argument_list|,
name|maxCapacity
argument_list|,
literal|false
argument_list|,
name|partitionToLookAt
argument_list|,
name|killable
argument_list|)
expr_stmt|;
name|Resource
name|childrensPreemptable
init|=
name|Resource
operator|.
name|newInstance
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|CSQueue
name|c
range|:
name|curQueue
operator|.
name|getChildQueues
argument_list|()
control|)
block|{
name|TempQueuePerPartition
name|subq
init|=
name|cloneQueues
argument_list|(
name|c
argument_list|,
name|partitionResource
argument_list|,
name|partitionToLookAt
argument_list|)
decl_stmt|;
name|Resources
operator|.
name|addTo
argument_list|(
name|childrensPreemptable
argument_list|,
name|subq
operator|.
name|preemptableExtra
argument_list|)
expr_stmt|;
name|ret
operator|.
name|addChild
argument_list|(
name|subq
argument_list|)
expr_stmt|;
block|}
comment|// untouchableExtra = max(extra - childrenPreemptable, 0)
if|if
condition|(
name|Resources
operator|.
name|greaterThanOrEqual
argument_list|(
name|rc
argument_list|,
name|partitionResource
argument_list|,
name|childrensPreemptable
argument_list|,
name|extra
argument_list|)
condition|)
block|{
name|ret
operator|.
name|untouchableExtra
operator|=
name|Resource
operator|.
name|newInstance
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|.
name|untouchableExtra
operator|=
name|Resources
operator|.
name|subtract
argument_list|(
name|extra
argument_list|,
name|childrensPreemptable
argument_list|)
expr_stmt|;
block|}
name|ret
operator|.
name|preemptableExtra
operator|=
name|Resources
operator|.
name|min
argument_list|(
name|rc
argument_list|,
name|partitionResource
argument_list|,
name|childrensPreemptable
argument_list|,
name|extra
argument_list|)
expr_stmt|;
block|}
block|}
name|addTempQueuePartition
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|// simple printout function that reports internal queue state (useful for
comment|// plotting)
DECL|method|logToCSV (List<String> leafQueueNames)
specifier|private
name|void
name|logToCSV
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|leafQueueNames
parameter_list|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|leafQueueNames
argument_list|)
expr_stmt|;
name|String
name|queueState
init|=
literal|" QUEUESTATE: "
operator|+
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|queueState
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|queueName
range|:
name|leafQueueNames
control|)
block|{
name|TempQueuePerPartition
name|tq
init|=
name|getQueueByPartition
argument_list|(
name|queueName
argument_list|,
name|RMNodeLabelsManager
operator|.
name|NO_LABEL
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|tq
operator|.
name|appendLogString
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|addTempQueuePartition (TempQueuePerPartition queuePartition)
specifier|private
name|void
name|addTempQueuePartition
parameter_list|(
name|TempQueuePerPartition
name|queuePartition
parameter_list|)
block|{
name|String
name|queueName
init|=
name|queuePartition
operator|.
name|queueName
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|TempQueuePerPartition
argument_list|>
name|queuePartitions
decl_stmt|;
if|if
condition|(
literal|null
operator|==
operator|(
name|queuePartitions
operator|=
name|queueToPartitions
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
operator|)
condition|)
block|{
name|queuePartitions
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|queueToPartitions
operator|.
name|put
argument_list|(
name|queueName
argument_list|,
name|queuePartitions
argument_list|)
expr_stmt|;
block|}
name|queuePartitions
operator|.
name|put
argument_list|(
name|queuePartition
operator|.
name|partition
argument_list|,
name|queuePartition
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get queue partition by given queueName and partitionName    */
annotation|@
name|Override
DECL|method|getQueueByPartition (String queueName, String partition)
specifier|public
name|TempQueuePerPartition
name|getQueueByPartition
parameter_list|(
name|String
name|queueName
parameter_list|,
name|String
name|partition
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|TempQueuePerPartition
argument_list|>
name|partitionToQueues
decl_stmt|;
if|if
condition|(
literal|null
operator|==
operator|(
name|partitionToQueues
operator|=
name|queueToPartitions
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|partitionToQueues
operator|.
name|get
argument_list|(
name|partition
argument_list|)
return|;
block|}
comment|/**    * Get all queue partitions by given queueName    */
annotation|@
name|Override
DECL|method|getQueuePartitions (String queueName)
specifier|public
name|Collection
argument_list|<
name|TempQueuePerPartition
argument_list|>
name|getQueuePartitions
parameter_list|(
name|String
name|queueName
parameter_list|)
block|{
if|if
condition|(
operator|!
name|queueToPartitions
operator|.
name|containsKey
argument_list|(
name|queueName
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|queueToPartitions
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
operator|.
name|values
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getScheduler ()
specifier|public
name|CapacityScheduler
name|getScheduler
parameter_list|()
block|{
return|return
name|scheduler
return|;
block|}
annotation|@
name|Override
DECL|method|getRMContext ()
specifier|public
name|RMContext
name|getRMContext
parameter_list|()
block|{
return|return
name|rmContext
return|;
block|}
annotation|@
name|Override
DECL|method|isObserveOnly ()
specifier|public
name|boolean
name|isObserveOnly
parameter_list|()
block|{
return|return
name|observeOnly
return|;
block|}
annotation|@
name|Override
DECL|method|getKillableContainers ()
specifier|public
name|Set
argument_list|<
name|ContainerId
argument_list|>
name|getKillableContainers
parameter_list|()
block|{
return|return
name|killableContainers
return|;
block|}
annotation|@
name|Override
DECL|method|getMaxIgnoreOverCapacity ()
specifier|public
name|double
name|getMaxIgnoreOverCapacity
parameter_list|()
block|{
return|return
name|maxIgnoredOverCapacity
return|;
block|}
annotation|@
name|Override
DECL|method|getNaturalTerminationFactor ()
specifier|public
name|double
name|getNaturalTerminationFactor
parameter_list|()
block|{
return|return
name|naturalTerminationFactor
return|;
block|}
annotation|@
name|Override
DECL|method|getLeafQueueNames ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getLeafQueueNames
parameter_list|()
block|{
return|return
name|leafQueueNames
return|;
block|}
annotation|@
name|Override
DECL|method|getAllPartitions ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getAllPartitions
parameter_list|()
block|{
return|return
name|allPartitions
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getQueuePartitions ()
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|TempQueuePerPartition
argument_list|>
argument_list|>
name|getQueuePartitions
parameter_list|()
block|{
return|return
name|queueToPartitions
return|;
block|}
block|}
end_class

end_unit

