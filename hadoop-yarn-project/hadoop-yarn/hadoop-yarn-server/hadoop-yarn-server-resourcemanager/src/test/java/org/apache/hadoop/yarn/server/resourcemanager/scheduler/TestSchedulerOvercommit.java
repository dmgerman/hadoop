begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/** * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.resourcemanager.scheduler
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
package|;
end_package

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|emptyList
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|singletonList
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|singletonMap
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|GenericTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|AllocateResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Container
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerExitStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|NodeId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|PreemptionContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|PreemptionMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ResourceOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ResourceRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|nodelabels
operator|.
name|NodeAttributeStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|UpdateNodeResourceRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|AdminService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|MockAM
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|MockNM
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|MockRM
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|TestResourceTrackerService
operator|.
name|NullNodeAttributeStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|RMApp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|attempt
operator|.
name|RMAppAttempt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|attempt
operator|.
name|RMAppAttemptState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|utils
operator|.
name|BuilderUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Generic tests for overcommitting resources. This needs to be instantiated  * with a scheduler ({@link YarnConfiguration.RM_SCHEDULER}).  *  * If reducing the amount of resources leads to overcommitting (negative  * available resources), the scheduler will select containers to make room.  *<ul>  *<li>If there is no timeout (&lt;0), it doesn't kill or preempt surplus  * containers.</li>  *<li>If the timeout is 0, it kills the surplus containers immediately.</li>  *<li>If the timeout is larger than 0, it first asks the application to  * preempt those containers and after the timeout passes, it kills the surplus  * containers.</li>  *</ul>  */
end_comment

begin_class
DECL|class|TestSchedulerOvercommit
specifier|public
specifier|abstract
class|class
name|TestSchedulerOvercommit
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TestSchedulerOvercommit
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** 1 GB in MB. */
DECL|field|GB
specifier|protected
specifier|final
specifier|static
name|int
name|GB
init|=
literal|1024
decl_stmt|;
comment|/** We do scheduling and heart beat every 200ms. */
DECL|field|INTERVAL
specifier|protected
specifier|static
specifier|final
name|int
name|INTERVAL
init|=
literal|200
decl_stmt|;
comment|/** Mock Resource Manager. */
DECL|field|rm
specifier|private
name|MockRM
name|rm
decl_stmt|;
comment|/** Scheduler for the Mock Resource Manager.*/
DECL|field|scheduler
specifier|private
name|ResourceScheduler
name|scheduler
decl_stmt|;
comment|/** Node Manager running containers. */
DECL|field|nm
specifier|private
name|MockNM
name|nm
decl_stmt|;
DECL|field|nmId
specifier|private
name|NodeId
name|nmId
decl_stmt|;
comment|/** Application to allocate containers. */
DECL|field|attempt
specifier|private
name|RMAppAttempt
name|attempt
decl_stmt|;
DECL|field|am
specifier|private
name|MockAM
name|am
decl_stmt|;
comment|/**    * Setup the cluster with: an RM, a NM and an application for test.    * @throws Exception If it cannot set up the cluster.    */
annotation|@
name|Before
DECL|method|setup ()
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Setting up the test cluster..."
argument_list|)
expr_stmt|;
comment|// Start the Resource Manager
name|Configuration
name|conf
init|=
name|getConfiguration
argument_list|()
decl_stmt|;
name|rm
operator|=
operator|new
name|MockRM
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|rm
operator|.
name|start
argument_list|()
expr_stmt|;
name|scheduler
operator|=
name|rm
operator|.
name|getResourceScheduler
argument_list|()
expr_stmt|;
comment|// Add a Node Manager with 4GB
name|nm
operator|=
name|rm
operator|.
name|registerNode
argument_list|(
literal|"127.0.0.1:1234"
argument_list|,
literal|4
operator|*
name|GB
argument_list|)
expr_stmt|;
name|nmId
operator|=
name|nm
operator|.
name|getNodeId
argument_list|()
expr_stmt|;
comment|// Start an AM with 2GB
name|RMApp
name|app
init|=
name|rm
operator|.
name|submitApp
argument_list|(
literal|2
operator|*
name|GB
argument_list|)
decl_stmt|;
name|nm
operator|.
name|nodeHeartbeat
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|attempt
operator|=
name|app
operator|.
name|getCurrentAppAttempt
argument_list|()
expr_stmt|;
name|am
operator|=
name|rm
operator|.
name|sendAMLaunched
argument_list|(
name|attempt
operator|.
name|getAppAttemptId
argument_list|()
argument_list|)
expr_stmt|;
name|am
operator|.
name|registerAppAttempt
argument_list|()
expr_stmt|;
comment|// After allocation, used 2GB and remaining 2GB on the NM
name|assertMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|2
operator|*
name|GB
argument_list|,
literal|2
operator|*
name|GB
argument_list|)
expr_stmt|;
name|nm
operator|.
name|nodeHeartbeat
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the configuration for the scheduler. This is used when setting up the    * Resource Manager and should setup the scheduler (e.g., Capacity Scheduler    * or Fair Scheduler). It needs to set the configuration with    * {@link YarnConfiguration.RM_SCHEDULER}.    * @return Configuration for the scheduler.    */
DECL|method|getConfiguration ()
specifier|protected
name|Configuration
name|getConfiguration
parameter_list|()
block|{
name|Configuration
name|conf
init|=
operator|new
name|YarnConfiguration
argument_list|()
decl_stmt|;
comment|// Prevent loading node attributes
name|conf
operator|.
name|setClass
argument_list|(
name|YarnConfiguration
operator|.
name|FS_NODE_ATTRIBUTE_STORE_IMPL_CLASS
argument_list|,
name|NullNodeAttributeStore
operator|.
name|class
argument_list|,
name|NodeAttributeStore
operator|.
name|class
argument_list|)
expr_stmt|;
return|return
name|conf
return|;
block|}
comment|/**    * Stops the default application and the RM (with the scheduler).    * @throws Exception If it cannot stop the cluster.    */
annotation|@
name|After
DECL|method|cleanup ()
specifier|public
name|void
name|cleanup
parameter_list|()
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cleaning up the test cluster..."
argument_list|)
expr_stmt|;
if|if
condition|(
name|am
operator|!=
literal|null
condition|)
block|{
name|am
operator|.
name|unregisterAppAttempt
argument_list|()
expr_stmt|;
name|am
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|rm
operator|!=
literal|null
condition|)
block|{
name|rm
operator|.
name|drainEvents
argument_list|()
expr_stmt|;
name|rm
operator|.
name|stop
argument_list|()
expr_stmt|;
name|rm
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * Reducing the resources with no timeout should prevent new containers    * but wait for the current ones without killing.    */
annotation|@
name|Test
DECL|method|testReduceNoTimeout ()
specifier|public
name|void
name|testReduceNoTimeout
parameter_list|()
throws|throws
name|Exception
block|{
comment|// New 2GB container should give 4 GB used (2+2) and 0 GB available
name|Container
name|c1
init|=
name|createContainer
argument_list|(
name|am
argument_list|,
literal|2
operator|*
name|GB
argument_list|)
decl_stmt|;
name|assertMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|4
operator|*
name|GB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Update node resource to 2 GB, so resource is over-consumed
name|updateNodeResource
argument_list|(
name|rm
argument_list|,
name|nmId
argument_list|,
literal|2
operator|*
name|GB
argument_list|,
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// The used resource should still be 4 GB and negative available resource
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|4
operator|*
name|GB
argument_list|,
operator|-
literal|2
operator|*
name|GB
argument_list|,
name|INTERVAL
argument_list|,
literal|2
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|// Check that the NM got the updated resources
name|nm
operator|.
name|nodeHeartbeat
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
operator|*
name|GB
argument_list|,
name|nm
operator|.
name|getCapability
argument_list|()
operator|.
name|getMemorySize
argument_list|()
argument_list|)
expr_stmt|;
comment|// Check that we did not get a preemption request
name|assertNoPreemption
argument_list|(
name|am
operator|.
name|schedule
argument_list|()
operator|.
name|getPreemptionMessage
argument_list|()
argument_list|)
expr_stmt|;
comment|// Check container can complete successfully with resource over-commitment
name|ContainerStatus
name|containerStatus
init|=
name|BuilderUtils
operator|.
name|newContainerStatus
argument_list|(
name|c1
operator|.
name|getId
argument_list|()
argument_list|,
name|ContainerState
operator|.
name|COMPLETE
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
name|c1
operator|.
name|getResource
argument_list|()
argument_list|)
decl_stmt|;
name|nm
operator|.
name|containerStatus
argument_list|(
name|containerStatus
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting for container to be finished for app..."
argument_list|)
expr_stmt|;
name|GenericTestUtils
operator|.
name|waitFor
argument_list|(
parameter_list|()
lambda|->
name|attempt
operator|.
name|getJustFinishedContainers
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
argument_list|,
name|INTERVAL
argument_list|,
literal|2
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|am
operator|.
name|schedule
argument_list|()
operator|.
name|getCompletedContainersStatuses
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|2
operator|*
name|GB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Verify no NPE is trigger in schedule after resource is updated
name|am
operator|.
name|addRequests
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"127.0.0.1"
block|,
literal|"127.0.0.2"
block|}
argument_list|,
literal|3
operator|*
name|GB
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|AllocateResponse
name|allocResponse2
init|=
name|am
operator|.
name|schedule
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Shouldn't have enough resource to allocate containers"
argument_list|,
name|allocResponse2
operator|.
name|getAllocatedContainers
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
comment|// Try 10 times as scheduling is an async process
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|INTERVAL
argument_list|)
expr_stmt|;
name|allocResponse2
operator|=
name|am
operator|.
name|schedule
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Shouldn't have enough resource to allocate containers"
argument_list|,
name|allocResponse2
operator|.
name|getAllocatedContainers
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Changing resources multiples times without waiting for the    * timeout.    */
annotation|@
name|Test
DECL|method|testChangeResourcesNoTimeout ()
specifier|public
name|void
name|testChangeResourcesNoTimeout
parameter_list|()
throws|throws
name|Exception
block|{
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|2
operator|*
name|GB
argument_list|,
literal|2
operator|*
name|GB
argument_list|,
literal|100
argument_list|,
literal|2
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|updateNodeResource
argument_list|(
name|rm
argument_list|,
name|nmId
argument_list|,
literal|5
operator|*
name|GB
argument_list|,
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|2
operator|*
name|GB
argument_list|,
literal|3
operator|*
name|GB
argument_list|,
literal|100
argument_list|,
literal|2
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|updateNodeResource
argument_list|(
name|rm
argument_list|,
name|nmId
argument_list|,
literal|0
operator|*
name|GB
argument_list|,
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|2
operator|*
name|GB
argument_list|,
operator|-
literal|2
operator|*
name|GB
argument_list|,
literal|100
argument_list|,
literal|2
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|updateNodeResource
argument_list|(
name|rm
argument_list|,
name|nmId
argument_list|,
literal|4
operator|*
name|GB
argument_list|,
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|2
operator|*
name|GB
argument_list|,
literal|2
operator|*
name|GB
argument_list|,
literal|100
argument_list|,
literal|2
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|// The application should still be running without issues.
name|assertEquals
argument_list|(
name|RMAppAttemptState
operator|.
name|RUNNING
argument_list|,
name|attempt
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Reducing the resources with 0 time out kills the container right away.    */
annotation|@
name|Test
DECL|method|testReduceKill ()
specifier|public
name|void
name|testReduceKill
parameter_list|()
throws|throws
name|Exception
block|{
name|Container
name|container
init|=
name|createContainer
argument_list|(
name|am
argument_list|,
literal|2
operator|*
name|GB
argument_list|)
decl_stmt|;
name|assertMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|4
operator|*
name|GB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// Reducing to 2GB should kill the container
name|long
name|t0
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
name|updateNodeResource
argument_list|(
name|rm
argument_list|,
name|nmId
argument_list|,
literal|2
operator|*
name|GB
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nm
argument_list|,
literal|2
operator|*
name|GB
argument_list|,
literal|0
operator|*
name|GB
argument_list|,
name|INTERVAL
argument_list|,
literal|2
operator|*
name|INTERVAL
argument_list|)
expr_stmt|;
comment|// Check that the new container was killed
name|List
argument_list|<
name|ContainerStatus
argument_list|>
name|completedContainers
init|=
name|am
operator|.
name|schedule
argument_list|()
operator|.
name|getCompletedContainersStatuses
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|completedContainers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|ContainerStatus
name|containerStatus
init|=
name|completedContainers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertContainerKilled
argument_list|(
name|container
operator|.
name|getId
argument_list|()
argument_list|,
name|containerStatus
argument_list|)
expr_stmt|;
comment|// It should kill the containers right away
name|assertTime
argument_list|(
literal|0
argument_list|,
name|Time
operator|.
name|now
argument_list|()
operator|-
name|t0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Reducing the resources with a time out should first preempt and then kill.    */
annotation|@
name|Test
DECL|method|testReducePreemptAndKill ()
specifier|public
name|void
name|testReducePreemptAndKill
parameter_list|()
throws|throws
name|Exception
block|{
name|Container
name|container
init|=
name|createContainer
argument_list|(
name|am
argument_list|,
literal|2
operator|*
name|GB
argument_list|)
decl_stmt|;
name|assertMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|4
operator|*
name|GB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// We give an overcommit time out of 2 seconds
specifier|final
name|int
name|timeout
init|=
operator|(
name|int
operator|)
name|TimeUnit
operator|.
name|SECONDS
operator|.
name|toMillis
argument_list|(
literal|2
argument_list|)
decl_stmt|;
comment|// Reducing to 2GB should first preempt the container
name|long
name|t0
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
name|updateNodeResource
argument_list|(
name|rm
argument_list|,
name|nmId
argument_list|,
literal|2
operator|*
name|GB
argument_list|,
literal|2
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nm
argument_list|,
literal|4
operator|*
name|GB
argument_list|,
operator|-
literal|2
operator|*
name|GB
argument_list|,
name|INTERVAL
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
comment|// We should receive a notification to preempt the container
name|PreemptionMessage
name|preemptMsg
init|=
name|am
operator|.
name|schedule
argument_list|()
operator|.
name|getPreemptionMessage
argument_list|()
decl_stmt|;
name|assertPreemption
argument_list|(
name|container
operator|.
name|getId
argument_list|()
argument_list|,
name|preemptMsg
argument_list|)
expr_stmt|;
comment|// Wait until the container is killed
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nm
argument_list|,
literal|2
operator|*
name|GB
argument_list|,
literal|0
argument_list|,
name|INTERVAL
argument_list|,
name|timeout
operator|+
literal|2
operator|*
name|INTERVAL
argument_list|)
expr_stmt|;
comment|// Check that the container was killed
name|List
argument_list|<
name|ContainerStatus
argument_list|>
name|completedContainers
init|=
name|am
operator|.
name|schedule
argument_list|()
operator|.
name|getCompletedContainersStatuses
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|completedContainers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|ContainerStatus
name|containerStatus
init|=
name|completedContainers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertContainerKilled
argument_list|(
name|container
operator|.
name|getId
argument_list|()
argument_list|,
name|containerStatus
argument_list|)
expr_stmt|;
comment|// Check how long it took to kill the container
name|assertTime
argument_list|(
name|timeout
argument_list|,
name|Time
operator|.
name|now
argument_list|()
operator|-
name|t0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Reducing the resources (with a time out) triggers a preemption message to    * the AM right away. Then, increasing them again should prevent the killing    * when the time out would have happened.    */
annotation|@
name|Test
DECL|method|testReducePreemptAndCancel ()
specifier|public
name|void
name|testReducePreemptAndCancel
parameter_list|()
throws|throws
name|Exception
block|{
name|Container
name|container
init|=
name|createContainer
argument_list|(
name|am
argument_list|,
literal|2
operator|*
name|GB
argument_list|)
decl_stmt|;
name|assertMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|4
operator|*
name|GB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// We give an overcommit time out of 2 seconds
specifier|final
name|int
name|timeout
init|=
operator|(
name|int
operator|)
name|TimeUnit
operator|.
name|SECONDS
operator|.
name|toMillis
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// Reducing to 2GB should first preempt the container
name|updateNodeResource
argument_list|(
name|rm
argument_list|,
name|nmId
argument_list|,
literal|2
operator|*
name|GB
argument_list|,
literal|2
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nm
argument_list|,
literal|4
operator|*
name|GB
argument_list|,
operator|-
literal|2
operator|*
name|GB
argument_list|,
name|INTERVAL
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
comment|// We should receive a notification to preempt the container
name|PreemptionMessage
name|preemptMsg
init|=
name|am
operator|.
name|schedule
argument_list|()
operator|.
name|getPreemptionMessage
argument_list|()
decl_stmt|;
name|assertPreemption
argument_list|(
name|container
operator|.
name|getId
argument_list|()
argument_list|,
name|preemptMsg
argument_list|)
expr_stmt|;
comment|// Increase the resources again
name|updateNodeResource
argument_list|(
name|rm
argument_list|,
name|nmId
argument_list|,
literal|4
operator|*
name|GB
argument_list|,
literal|2
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nm
argument_list|,
literal|4
operator|*
name|GB
argument_list|,
literal|0
argument_list|,
name|INTERVAL
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|long
name|t0
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
while|while
condition|(
name|Time
operator|.
name|now
argument_list|()
operator|-
name|t0
operator|<
name|TimeUnit
operator|.
name|SECONDS
operator|.
name|toMillis
argument_list|(
literal|2
argument_list|)
condition|)
block|{
name|nm
operator|.
name|nodeHeartbeat
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|AllocateResponse
name|allocation
init|=
name|am
operator|.
name|schedule
argument_list|()
decl_stmt|;
name|assertNoPreemption
argument_list|(
name|allocation
operator|.
name|getPreemptionMessage
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|allocation
operator|.
name|getCompletedContainersStatuses
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|INTERVAL
argument_list|)
expr_stmt|;
block|}
comment|// Check that the containers are still running
name|assertMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|4
operator|*
name|GB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|scheduler
operator|.
name|getNodeReport
argument_list|(
name|nmId
argument_list|)
operator|.
name|getNumContainers
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test the order we kill multiple containers.    * It initially has: AM(2GB), C1(1GB), C2(1GB), AM2(2GB), and C3(2GB).    * It should kill in this order: C3, C2, C1, AM2, and AM1.    */
annotation|@
name|Test
DECL|method|testKillMultipleContainers ()
specifier|public
name|void
name|testKillMultipleContainers
parameter_list|()
throws|throws
name|Exception
block|{
name|updateNodeResource
argument_list|(
name|rm
argument_list|,
name|nmId
argument_list|,
literal|8
operator|*
name|GB
argument_list|,
literal|6
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|2
operator|*
name|GB
argument_list|,
literal|6
operator|*
name|GB
argument_list|,
literal|200
argument_list|,
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|// Start 2 containers with 1 GB each
name|Container
name|c1
init|=
name|createContainer
argument_list|(
name|am
argument_list|,
literal|1
operator|*
name|GB
argument_list|)
decl_stmt|;
name|Container
name|c2
init|=
name|createContainer
argument_list|(
name|am
argument_list|,
literal|1
operator|*
name|GB
argument_list|)
decl_stmt|;
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|4
operator|*
name|GB
argument_list|,
literal|4
operator|*
name|GB
argument_list|,
literal|200
argument_list|,
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|// Start an AM with 2GB
name|RMApp
name|app2
init|=
name|rm
operator|.
name|submitApp
argument_list|(
literal|2
operator|*
name|GB
argument_list|,
literal|"app2"
argument_list|,
literal|"user2"
argument_list|)
decl_stmt|;
name|nm
operator|.
name|nodeHeartbeat
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|RMAppAttempt
name|attempt2
init|=
name|app2
operator|.
name|getCurrentAppAttempt
argument_list|()
decl_stmt|;
name|MockAM
name|am2
init|=
name|rm
operator|.
name|sendAMLaunched
argument_list|(
name|attempt2
operator|.
name|getAppAttemptId
argument_list|()
argument_list|)
decl_stmt|;
name|am2
operator|.
name|registerAppAttempt
argument_list|()
expr_stmt|;
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nm
argument_list|,
literal|6
operator|*
name|GB
argument_list|,
literal|2
operator|*
name|GB
argument_list|,
literal|200
argument_list|,
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|RMAppAttemptState
operator|.
name|RUNNING
argument_list|,
name|attempt2
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|Container
name|c3
init|=
name|createContainer
argument_list|(
name|am2
argument_list|,
literal|2
operator|*
name|GB
argument_list|)
decl_stmt|;
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nm
argument_list|,
literal|8
operator|*
name|GB
argument_list|,
literal|0
operator|*
name|GB
argument_list|,
literal|200
argument_list|,
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|scheduler
operator|.
name|getNodeReport
argument_list|(
name|nmId
argument_list|)
operator|.
name|getNumContainers
argument_list|()
argument_list|)
expr_stmt|;
comment|// Reduce the resources to kill C3 and C2 (not AM2)
name|updateNodeResource
argument_list|(
name|rm
argument_list|,
name|nmId
argument_list|,
literal|5
operator|*
name|GB
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nm
argument_list|,
literal|5
operator|*
name|GB
argument_list|,
literal|0
operator|*
name|GB
argument_list|,
literal|200
argument_list|,
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|scheduler
operator|.
name|getNodeReport
argument_list|(
name|nmId
argument_list|)
operator|.
name|getNumContainers
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ContainerStatus
argument_list|>
name|completedContainers
init|=
name|am2
operator|.
name|schedule
argument_list|()
operator|.
name|getCompletedContainersStatuses
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|completedContainers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|ContainerStatus
name|container3Status
init|=
name|completedContainers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertContainerKilled
argument_list|(
name|c3
operator|.
name|getId
argument_list|()
argument_list|,
name|container3Status
argument_list|)
expr_stmt|;
name|completedContainers
operator|=
name|am
operator|.
name|schedule
argument_list|()
operator|.
name|getCompletedContainersStatuses
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|completedContainers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|ContainerStatus
name|container2Status
init|=
name|completedContainers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertContainerKilled
argument_list|(
name|c2
operator|.
name|getId
argument_list|()
argument_list|,
name|container2Status
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|RMAppAttemptState
operator|.
name|RUNNING
argument_list|,
name|attempt
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|RMAppAttemptState
operator|.
name|RUNNING
argument_list|,
name|attempt2
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
comment|// Reduce the resources to kill C1 (not AM2)
name|updateNodeResource
argument_list|(
name|rm
argument_list|,
name|nmId
argument_list|,
literal|4
operator|*
name|GB
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nm
argument_list|,
literal|4
operator|*
name|GB
argument_list|,
literal|0
operator|*
name|GB
argument_list|,
literal|200
argument_list|,
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|scheduler
operator|.
name|getNodeReport
argument_list|(
name|nmId
argument_list|)
operator|.
name|getNumContainers
argument_list|()
argument_list|)
expr_stmt|;
name|completedContainers
operator|=
name|am
operator|.
name|schedule
argument_list|()
operator|.
name|getCompletedContainersStatuses
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|completedContainers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|ContainerStatus
name|container1Status
init|=
name|completedContainers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertContainerKilled
argument_list|(
name|c1
operator|.
name|getId
argument_list|()
argument_list|,
name|container1Status
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|RMAppAttemptState
operator|.
name|RUNNING
argument_list|,
name|attempt
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|RMAppAttemptState
operator|.
name|RUNNING
argument_list|,
name|attempt2
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
comment|// Reduce the resources to kill AM2
name|updateNodeResource
argument_list|(
name|rm
argument_list|,
name|nmId
argument_list|,
literal|2
operator|*
name|GB
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nm
argument_list|,
literal|2
operator|*
name|GB
argument_list|,
literal|0
operator|*
name|GB
argument_list|,
literal|200
argument_list|,
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|scheduler
operator|.
name|getNodeReport
argument_list|(
name|nmId
argument_list|)
operator|.
name|getNumContainers
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|RMAppAttemptState
operator|.
name|FAILED
argument_list|,
name|attempt2
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
comment|// The first application should be fine and still running
name|assertEquals
argument_list|(
name|RMAppAttemptState
operator|.
name|RUNNING
argument_list|,
name|attempt
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testEndToEnd ()
specifier|public
name|void
name|testEndToEnd
parameter_list|()
throws|throws
name|Exception
block|{
name|Container
name|c1
init|=
name|createContainer
argument_list|(
name|am
argument_list|,
literal|2
operator|*
name|GB
argument_list|)
decl_stmt|;
name|assertMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|4
operator|*
name|GB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// check node report, 4 GB used and 0 GB available
name|assertMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|4
operator|*
name|GB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nm
operator|.
name|nodeHeartbeat
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|4
operator|*
name|GB
argument_list|,
name|nm
operator|.
name|getCapability
argument_list|()
operator|.
name|getMemorySize
argument_list|()
argument_list|)
expr_stmt|;
comment|// update node resource to 2 GB, so resource is over-consumed
name|updateNodeResource
argument_list|(
name|rm
argument_list|,
name|nmId
argument_list|,
literal|2
operator|*
name|GB
argument_list|,
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// the used resource should still 4 GB and negative available resource
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|4
operator|*
name|GB
argument_list|,
operator|-
literal|2
operator|*
name|GB
argument_list|,
literal|200
argument_list|,
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|// check that we did not get a preemption requests
name|assertNoPreemption
argument_list|(
name|am
operator|.
name|schedule
argument_list|()
operator|.
name|getPreemptionMessage
argument_list|()
argument_list|)
expr_stmt|;
comment|// check that the NM got the updated resources
name|nm
operator|.
name|nodeHeartbeat
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
operator|*
name|GB
argument_list|,
name|nm
operator|.
name|getCapability
argument_list|()
operator|.
name|getMemorySize
argument_list|()
argument_list|)
expr_stmt|;
comment|// check container can complete successfully with resource over-commitment
name|ContainerStatus
name|containerStatus
init|=
name|BuilderUtils
operator|.
name|newContainerStatus
argument_list|(
name|c1
operator|.
name|getId
argument_list|()
argument_list|,
name|ContainerState
operator|.
name|COMPLETE
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
name|c1
operator|.
name|getResource
argument_list|()
argument_list|)
decl_stmt|;
name|nm
operator|.
name|containerStatus
argument_list|(
name|containerStatus
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting for containers to be finished for app 1..."
argument_list|)
expr_stmt|;
name|GenericTestUtils
operator|.
name|waitFor
argument_list|(
parameter_list|()
lambda|->
name|attempt
operator|.
name|getJustFinishedContainers
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
argument_list|,
literal|100
argument_list|,
literal|2000
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|am
operator|.
name|schedule
argument_list|()
operator|.
name|getCompletedContainersStatuses
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|2
operator|*
name|GB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// verify no NPE is trigger in schedule after resource is updated
name|am
operator|.
name|addRequests
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"127.0.0.1"
block|,
literal|"127.0.0.2"
block|}
argument_list|,
literal|3
operator|*
name|GB
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|AllocateResponse
name|allocResponse2
init|=
name|am
operator|.
name|schedule
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Shouldn't have enough resource to allocate containers"
argument_list|,
name|allocResponse2
operator|.
name|getAllocatedContainers
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
comment|// try 10 times as scheduling is an async process
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|allocResponse2
operator|=
name|am
operator|.
name|schedule
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Shouldn't have enough resource to allocate containers"
argument_list|,
name|allocResponse2
operator|.
name|getAllocatedContainers
argument_list|()
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// increase the resources again to 5 GB to schedule the 3GB container
name|updateNodeResource
argument_list|(
name|rm
argument_list|,
name|nmId
argument_list|,
literal|5
operator|*
name|GB
argument_list|,
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|2
operator|*
name|GB
argument_list|,
literal|3
operator|*
name|GB
argument_list|,
literal|100
argument_list|,
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|// kick the scheduling and check it took effect
name|nm
operator|.
name|nodeHeartbeat
argument_list|(
literal|true
argument_list|)
expr_stmt|;
while|while
condition|(
name|allocResponse2
operator|.
name|getAllocatedContainers
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting for containers to be created for app 1..."
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|allocResponse2
operator|=
name|am
operator|.
name|schedule
argument_list|()
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|allocResponse2
operator|.
name|getAllocatedContainers
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Container
name|c2
init|=
name|allocResponse2
operator|.
name|getAllocatedContainers
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|3
operator|*
name|GB
argument_list|,
name|c2
operator|.
name|getResource
argument_list|()
operator|.
name|getMemorySize
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|nmId
argument_list|,
name|c2
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
name|assertMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|5
operator|*
name|GB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// reduce the resources and trigger a preempt request to the AM for c2
name|updateNodeResource
argument_list|(
name|rm
argument_list|,
name|nmId
argument_list|,
literal|3
operator|*
name|GB
argument_list|,
literal|2
argument_list|,
literal|2
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|5
operator|*
name|GB
argument_list|,
operator|-
literal|2
operator|*
name|GB
argument_list|,
literal|200
argument_list|,
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|PreemptionMessage
name|preemptMsg
init|=
name|am
operator|.
name|schedule
argument_list|()
operator|.
name|getPreemptionMessage
argument_list|()
decl_stmt|;
name|assertPreemption
argument_list|(
name|c2
operator|.
name|getId
argument_list|()
argument_list|,
name|preemptMsg
argument_list|)
expr_stmt|;
comment|// increasing the resources again, should stop killing the containers
name|updateNodeResource
argument_list|(
name|rm
argument_list|,
name|nmId
argument_list|,
literal|5
operator|*
name|GB
argument_list|,
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|5
operator|*
name|GB
argument_list|,
literal|0
argument_list|,
literal|200
argument_list|,
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|3
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|assertMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|5
operator|*
name|GB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// reduce the resources again to trigger a preempt request to the AM for c2
name|long
name|t0
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
name|updateNodeResource
argument_list|(
name|rm
argument_list|,
name|nmId
argument_list|,
literal|3
operator|*
name|GB
argument_list|,
literal|2
argument_list|,
literal|2
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|5
operator|*
name|GB
argument_list|,
operator|-
literal|2
operator|*
name|GB
argument_list|,
literal|200
argument_list|,
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|preemptMsg
operator|=
name|am
operator|.
name|schedule
argument_list|()
operator|.
name|getPreemptionMessage
argument_list|()
expr_stmt|;
name|assertPreemption
argument_list|(
name|c2
operator|.
name|getId
argument_list|()
argument_list|,
name|preemptMsg
argument_list|)
expr_stmt|;
comment|// wait until the scheduler kills the container
name|GenericTestUtils
operator|.
name|waitFor
argument_list|(
parameter_list|()
lambda|->
block|{
try|try
block|{
name|nm
operator|.
name|nodeHeartbeat
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// trigger preemption in the NM
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot heartbeat"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|SchedulerNodeReport
name|report
init|=
name|scheduler
operator|.
name|getNodeReport
argument_list|(
name|nmId
argument_list|)
decl_stmt|;
return|return
name|report
operator|.
name|getAvailableResource
argument_list|()
operator|.
name|getMemorySize
argument_list|()
operator|>
literal|0
return|;
block|}
argument_list|,
literal|200
argument_list|,
literal|5
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|assertMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|2
operator|*
name|GB
argument_list|,
literal|1
operator|*
name|GB
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ContainerStatus
argument_list|>
name|completedContainers
init|=
name|am
operator|.
name|schedule
argument_list|()
operator|.
name|getCompletedContainersStatuses
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|completedContainers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|ContainerStatus
name|c2status
init|=
name|completedContainers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertContainerKilled
argument_list|(
name|c2
operator|.
name|getId
argument_list|()
argument_list|,
name|c2status
argument_list|)
expr_stmt|;
name|assertTime
argument_list|(
literal|2000
argument_list|,
name|Time
operator|.
name|now
argument_list|()
operator|-
name|t0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a container with a particular size and make sure it succeeds.    * @param am Application Master to add the container to.    * @param memory Memory of the container.    * @return Newly created container.    * @throws Exception If there are issues creating the container.    */
DECL|method|createContainer ( final MockAM app, final int memory)
specifier|protected
name|Container
name|createContainer
parameter_list|(
specifier|final
name|MockAM
name|app
parameter_list|,
specifier|final
name|int
name|memory
parameter_list|)
throws|throws
name|Exception
block|{
name|ResourceRequest
name|req
init|=
name|ResourceRequest
operator|.
name|newBuilder
argument_list|()
operator|.
name|capability
argument_list|(
name|Resource
operator|.
name|newInstance
argument_list|(
name|memory
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|.
name|numContainers
argument_list|(
literal|1
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|AllocateResponse
name|response
init|=
name|app
operator|.
name|allocate
argument_list|(
name|singletonList
argument_list|(
name|req
argument_list|)
argument_list|,
name|emptyList
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Container
argument_list|>
name|allocated
init|=
name|response
operator|.
name|getAllocatedContainers
argument_list|()
decl_stmt|;
name|nm
operator|.
name|nodeHeartbeat
argument_list|(
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|allocated
operator|.
name|isEmpty
argument_list|()
operator|&&
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting for containers to be created for app..."
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|INTERVAL
argument_list|)
expr_stmt|;
name|response
operator|=
name|app
operator|.
name|schedule
argument_list|()
expr_stmt|;
name|allocated
operator|=
name|response
operator|.
name|getAllocatedContainers
argument_list|()
expr_stmt|;
name|nm
operator|.
name|nodeHeartbeat
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|assertFalse
argument_list|(
literal|"Cannot create the container"
argument_list|,
name|allocated
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|allocated
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Container
name|c
init|=
name|allocated
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|memory
argument_list|,
name|c
operator|.
name|getResource
argument_list|()
operator|.
name|getMemorySize
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|nmId
argument_list|,
name|c
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
comment|/**    * Update the resources on a Node Manager.    * @param rm Resource Manager to contact.    * @param nmId Identifier of the Node Manager.    * @param memory Memory in MB.    * @param vCores Number of virtual cores.    * @param overcommitTimeout Timeout for overcommit.    * @throws Exception If the update cannot be completed.    */
DECL|method|updateNodeResource (MockRM rm, NodeId nmId, int memory, int vCores, int overcommitTimeout)
specifier|public
specifier|static
name|void
name|updateNodeResource
parameter_list|(
name|MockRM
name|rm
parameter_list|,
name|NodeId
name|nmId
parameter_list|,
name|int
name|memory
parameter_list|,
name|int
name|vCores
parameter_list|,
name|int
name|overcommitTimeout
parameter_list|)
throws|throws
name|Exception
block|{
name|AdminService
name|admin
init|=
name|rm
operator|.
name|getAdminService
argument_list|()
decl_stmt|;
name|ResourceOption
name|resourceOption
init|=
name|ResourceOption
operator|.
name|newInstance
argument_list|(
name|Resource
operator|.
name|newInstance
argument_list|(
name|memory
argument_list|,
name|vCores
argument_list|)
argument_list|,
name|overcommitTimeout
argument_list|)
decl_stmt|;
name|UpdateNodeResourceRequest
name|req
init|=
name|UpdateNodeResourceRequest
operator|.
name|newInstance
argument_list|(
name|singletonMap
argument_list|(
name|nmId
argument_list|,
name|resourceOption
argument_list|)
argument_list|)
decl_stmt|;
name|admin
operator|.
name|updateNodeResource
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
comment|/**    * Make sure that the container was killed.    * @param containerId Expected container identifier.    * @param status Container status to check.    */
DECL|method|assertContainerKilled ( final ContainerId containerId, final ContainerStatus status)
specifier|public
specifier|static
name|void
name|assertContainerKilled
parameter_list|(
specifier|final
name|ContainerId
name|containerId
parameter_list|,
specifier|final
name|ContainerStatus
name|status
parameter_list|)
block|{
name|assertEquals
argument_list|(
name|containerId
argument_list|,
name|status
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ContainerState
operator|.
name|COMPLETE
argument_list|,
name|status
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|ContainerExitStatus
operator|.
name|PREEMPTED
argument_list|,
name|status
operator|.
name|getExitStatus
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|SchedulerUtils
operator|.
name|PREEMPTED_CONTAINER
argument_list|,
name|status
operator|.
name|getDiagnostics
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check that an elapsed time is at least the expected time and no more than    * two heart beats/scheduling rounds.    * @param expectedTime Time expected in milliseconds.    * @param time Actual time to check.    */
DECL|method|assertTime (final long expectedTime, final long time)
specifier|public
specifier|static
name|void
name|assertTime
parameter_list|(
specifier|final
name|long
name|expectedTime
parameter_list|,
specifier|final
name|long
name|time
parameter_list|)
block|{
name|assertTrue
argument_list|(
literal|"Too short: "
operator|+
name|time
operator|+
literal|"ms"
argument_list|,
name|time
operator|>
name|expectedTime
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Too long: "
operator|+
name|time
operator|+
literal|"ms"
argument_list|,
name|time
operator|<
operator|(
name|expectedTime
operator|+
literal|2
operator|*
name|INTERVAL
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check that the scheduler didn't ask to preempt anything.    * @param msg Preemption message from the scheduler.    */
DECL|method|assertNoPreemption (final PreemptionMessage msg)
specifier|public
specifier|static
name|void
name|assertNoPreemption
parameter_list|(
specifier|final
name|PreemptionMessage
name|msg
parameter_list|)
block|{
if|if
condition|(
name|msg
operator|!=
literal|null
operator|&&
name|msg
operator|.
name|getContract
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|msg
operator|.
name|getContract
argument_list|()
operator|.
name|getContainers
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|fail
argument_list|(
literal|"We shouldn't preempt containers: "
operator|+
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Check that the scheduler ask to preempt a particular container.    * @param containerId Expected container to preempt.    * @param msg Preemption message from the scheduler.    */
DECL|method|assertPreemption ( final ContainerId containerId, final PreemptionMessage msg)
specifier|public
specifier|static
name|void
name|assertPreemption
parameter_list|(
specifier|final
name|ContainerId
name|containerId
parameter_list|,
specifier|final
name|PreemptionMessage
name|msg
parameter_list|)
block|{
name|assertNotNull
argument_list|(
literal|"Expected a preemption message"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|ContainerId
argument_list|>
name|preemptContainers
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|msg
operator|.
name|getContract
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|PreemptionContainer
name|c
range|:
name|msg
operator|.
name|getContract
argument_list|()
operator|.
name|getContainers
argument_list|()
control|)
block|{
name|preemptContainers
operator|.
name|add
argument_list|(
name|c
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|msg
operator|.
name|getStrictContract
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|PreemptionContainer
name|c
range|:
name|msg
operator|.
name|getStrictContract
argument_list|()
operator|.
name|getContainers
argument_list|()
control|)
block|{
name|preemptContainers
operator|.
name|add
argument_list|(
name|c
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
name|containerId
argument_list|)
argument_list|,
name|preemptContainers
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check if a node report has the expected memory values.    * @param scheduler Scheduler with the data.    * @param nmId Identifier of the node to check.    * @param expectedUsed The expected used memory in MB.    * @param expectedAvailable The expected available memory in MB.    */
DECL|method|assertMemory (ResourceScheduler scheduler, NodeId nmId, long expectedUsed, long expectedAvailable)
specifier|public
specifier|static
name|void
name|assertMemory
parameter_list|(
name|ResourceScheduler
name|scheduler
parameter_list|,
name|NodeId
name|nmId
parameter_list|,
name|long
name|expectedUsed
parameter_list|,
name|long
name|expectedAvailable
parameter_list|)
block|{
name|SchedulerNodeReport
name|nmReport
init|=
name|scheduler
operator|.
name|getNodeReport
argument_list|(
name|nmId
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|nmReport
argument_list|)
expr_stmt|;
name|Resource
name|used
init|=
name|nmReport
operator|.
name|getUsedResource
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Used memory"
argument_list|,
name|expectedUsed
argument_list|,
name|used
operator|.
name|getMemorySize
argument_list|()
argument_list|)
expr_stmt|;
name|Resource
name|available
init|=
name|nmReport
operator|.
name|getAvailableResource
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Available memory"
argument_list|,
name|expectedAvailable
argument_list|,
name|available
operator|.
name|getMemorySize
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Wait until the memory of a NM is at a given point.    * It does not trigger NM heart beat.    * @param scheduler Scheduler with the data.    * @param nmId Identifier of the node to check.    * @param expectedUsed The expected used memory in MB.    * @param expectedAvailable The expected available memory in MB.    * @param checkEveryMillis How often to perform the test in ms.    * @param waitForMillis The maximum time to wait in ms.    * @throws Exception If we don't get to the expected memory.    */
DECL|method|waitMemory (ResourceScheduler scheduler, NodeId nmId, int expectedUsed, int expectedAvailable, int checkEveryMillis, int waitForMillis)
specifier|public
specifier|static
name|void
name|waitMemory
parameter_list|(
name|ResourceScheduler
name|scheduler
parameter_list|,
name|NodeId
name|nmId
parameter_list|,
name|int
name|expectedUsed
parameter_list|,
name|int
name|expectedAvailable
parameter_list|,
name|int
name|checkEveryMillis
parameter_list|,
name|int
name|waitForMillis
parameter_list|)
throws|throws
name|Exception
block|{
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
literal|null
argument_list|,
name|expectedUsed
argument_list|,
name|expectedAvailable
argument_list|,
name|checkEveryMillis
argument_list|,
name|waitForMillis
argument_list|)
expr_stmt|;
block|}
comment|/**    * Wait until the memory of a NM is at a given point.    * It triggers NM heart beat.    * @param scheduler Scheduler with the data.    * @param nm Node Manager to check.    * @param expectedUsed The expected used memory in MB.    * @param expectedAvailable The expected available memory in MB.    * @param checkEveryMillis How often to perform the test in ms.    * @param waitForMillis The maximum time to wait in ms.    * @throws Exception If we don't get to the expected memory.    */
DECL|method|waitMemory (ResourceScheduler scheduler, MockNM nm, int expectedUsed, int expectedAvailable, int checkEveryMillis, int waitForMillis)
specifier|public
specifier|static
name|void
name|waitMemory
parameter_list|(
name|ResourceScheduler
name|scheduler
parameter_list|,
name|MockNM
name|nm
parameter_list|,
name|int
name|expectedUsed
parameter_list|,
name|int
name|expectedAvailable
parameter_list|,
name|int
name|checkEveryMillis
parameter_list|,
name|int
name|waitForMillis
parameter_list|)
throws|throws
name|Exception
block|{
name|waitMemory
argument_list|(
name|scheduler
argument_list|,
name|nm
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|nm
argument_list|,
name|expectedUsed
argument_list|,
name|expectedAvailable
argument_list|,
name|checkEveryMillis
argument_list|,
name|waitForMillis
argument_list|)
expr_stmt|;
block|}
comment|/**    * Wait until the memory of a NM is at a given point.    * If the NM is specified, it does heart beat.    * @param scheduler Scheduler with the data.    * @param nmId Identifier of the node to check.    * @param nm Node Manager to check.    * @param expectedUsed The expected used memory in MB.    * @param expectedAvailable The expected available memory in MB.    * @param checkEveryMillis How often to perform the test in ms.    * @param waitForMillis The maximum time to wait in ms.    * @throws Exception If we don't get to the expected memory.    */
DECL|method|waitMemory (ResourceScheduler scheduler, NodeId nmId, MockNM nm, int expectedUsed, int expectedAvailable, int checkEveryMillis, int waitForMillis)
specifier|public
specifier|static
name|void
name|waitMemory
parameter_list|(
name|ResourceScheduler
name|scheduler
parameter_list|,
name|NodeId
name|nmId
parameter_list|,
name|MockNM
name|nm
parameter_list|,
name|int
name|expectedUsed
parameter_list|,
name|int
name|expectedAvailable
parameter_list|,
name|int
name|checkEveryMillis
parameter_list|,
name|int
name|waitForMillis
parameter_list|)
throws|throws
name|Exception
block|{
name|long
name|start
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
while|while
condition|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|start
operator|<
name|waitForMillis
condition|)
block|{
try|try
block|{
if|if
condition|(
name|nm
operator|!=
literal|null
condition|)
block|{
name|nm
operator|.
name|nodeHeartbeat
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|assertMemory
argument_list|(
name|scheduler
argument_list|,
name|nmId
argument_list|,
name|expectedUsed
argument_list|,
name|expectedAvailable
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|AssertionError
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|checkEveryMillis
argument_list|)
expr_stmt|;
block|}
block|}
comment|// No success, notify time out
name|SchedulerNodeReport
name|nmReport
init|=
name|scheduler
operator|.
name|getNodeReport
argument_list|(
name|nmId
argument_list|)
decl_stmt|;
name|Resource
name|used
init|=
name|nmReport
operator|.
name|getUsedResource
argument_list|()
decl_stmt|;
name|Resource
name|available
init|=
name|nmReport
operator|.
name|getAvailableResource
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|TimeoutException
argument_list|(
literal|"Took longer than "
operator|+
name|waitForMillis
operator|+
literal|"ms to get to "
operator|+
name|expectedUsed
operator|+
literal|","
operator|+
name|expectedAvailable
operator|+
literal|" actual="
operator|+
name|used
operator|+
literal|","
operator|+
name|available
argument_list|)
throw|;
block|}
block|}
end_class

end_unit

