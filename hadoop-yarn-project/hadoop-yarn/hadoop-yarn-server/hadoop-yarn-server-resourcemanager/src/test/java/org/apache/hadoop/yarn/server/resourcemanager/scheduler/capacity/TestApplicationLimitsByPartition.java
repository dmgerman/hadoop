begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.resourcemanager.scheduler.capacity
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|capacity
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|mock
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|spy
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|when
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationAttemptId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|NodeId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Priority
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ResourceRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|factories
operator|.
name|RecordFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|factory
operator|.
name|providers
operator|.
name|RecordFactoryProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|MockAM
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|MockNM
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|MockRM
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|RMContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|nodelabels
operator|.
name|NullRMNodeLabelsManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|nodelabels
operator|.
name|RMNodeLabelsManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|RMApp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|rmapp
operator|.
name|attempt
operator|.
name|RMAppAttempt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|ResourceLimits
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|ResourceScheduler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|ResourceUsage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|SchedulerApplicationAttempt
operator|.
name|AMState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|fica
operator|.
name|FiCaSchedulerApp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|resourcemanager
operator|.
name|scheduler
operator|.
name|common
operator|.
name|fica
operator|.
name|FiCaSchedulerNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|DefaultResourceCalculator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|ResourceCalculator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|Resources
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|Matchers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|Mockito
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_class
DECL|class|TestApplicationLimitsByPartition
specifier|public
class|class
name|TestApplicationLimitsByPartition
block|{
DECL|field|GB
specifier|final
specifier|static
name|int
name|GB
init|=
literal|1024
decl_stmt|;
DECL|field|queue
name|LeafQueue
name|queue
decl_stmt|;
DECL|field|mgr
name|RMNodeLabelsManager
name|mgr
decl_stmt|;
DECL|field|conf
specifier|private
name|YarnConfiguration
name|conf
decl_stmt|;
DECL|field|resourceCalculator
specifier|private
specifier|final
name|ResourceCalculator
name|resourceCalculator
init|=
operator|new
name|DefaultResourceCalculator
argument_list|()
decl_stmt|;
annotation|@
name|Before
DECL|method|setUp ()
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|IOException
block|{
name|conf
operator|=
operator|new
name|YarnConfiguration
argument_list|()
expr_stmt|;
name|conf
operator|.
name|setClass
argument_list|(
name|YarnConfiguration
operator|.
name|RM_SCHEDULER
argument_list|,
name|CapacityScheduler
operator|.
name|class
argument_list|,
name|ResourceScheduler
operator|.
name|class
argument_list|)
expr_stmt|;
name|mgr
operator|=
operator|new
name|NullRMNodeLabelsManager
argument_list|()
expr_stmt|;
name|mgr
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
DECL|method|simpleNodeLabelMappingToManager ()
specifier|private
name|void
name|simpleNodeLabelMappingToManager
parameter_list|()
throws|throws
name|IOException
block|{
comment|// set node -> label
name|mgr
operator|.
name|addToCluserNodeLabelsWithDefaultExclusivity
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|"x"
argument_list|,
literal|"y"
argument_list|)
argument_list|)
expr_stmt|;
name|mgr
operator|.
name|addLabelsToNode
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
name|NodeId
operator|.
name|newInstance
argument_list|(
literal|"h1"
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TestUtils
operator|.
name|toSet
argument_list|(
literal|"x"
argument_list|)
argument_list|,
name|NodeId
operator|.
name|newInstance
argument_list|(
literal|"h2"
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TestUtils
operator|.
name|toSet
argument_list|(
literal|"y"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|complexNodeLabelMappingToManager ()
specifier|private
name|void
name|complexNodeLabelMappingToManager
parameter_list|()
throws|throws
name|IOException
block|{
comment|// set node -> label
name|mgr
operator|.
name|addToCluserNodeLabelsWithDefaultExclusivity
argument_list|(
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|"x"
argument_list|,
literal|"y"
argument_list|,
literal|"z"
argument_list|)
argument_list|)
expr_stmt|;
name|mgr
operator|.
name|addLabelsToNode
argument_list|(
name|ImmutableMap
operator|.
name|of
argument_list|(
name|NodeId
operator|.
name|newInstance
argument_list|(
literal|"h1"
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TestUtils
operator|.
name|toSet
argument_list|(
literal|"x"
argument_list|)
argument_list|,
name|NodeId
operator|.
name|newInstance
argument_list|(
literal|"h2"
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TestUtils
operator|.
name|toSet
argument_list|(
literal|"y"
argument_list|)
argument_list|,
name|NodeId
operator|.
name|newInstance
argument_list|(
literal|"h3"
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TestUtils
operator|.
name|toSet
argument_list|(
literal|"y"
argument_list|)
argument_list|,
name|NodeId
operator|.
name|newInstance
argument_list|(
literal|"h4"
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TestUtils
operator|.
name|toSet
argument_list|(
literal|"z"
argument_list|)
argument_list|,
name|NodeId
operator|.
name|newInstance
argument_list|(
literal|"h5"
argument_list|,
literal|0
argument_list|)
argument_list|,
name|RMNodeLabelsManager
operator|.
name|EMPTY_STRING_SET
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|120000
argument_list|)
DECL|method|testAMResourceLimitWithLabels ()
specifier|public
name|void
name|testAMResourceLimitWithLabels
parameter_list|()
throws|throws
name|Exception
block|{
comment|/*      * Test Case:      * Verify AM resource limit per partition level and per queue level. So      * we use 2 queues to verify this case.      * Queue a1 supports labels (x,y). Configure am-resource-limit as 0.2 (x)      * Queue c1 supports default label. Configure am-resource-limit as 0.2      *      * Queue A1 for label X can only support 2Gb AM resource.      * Queue C1 (empty label) can support 2Gb AM resource.      *      * Verify atleast one AM is launched, and AM resources should not go more      * than 2GB in each queue.      */
name|simpleNodeLabelMappingToManager
argument_list|()
expr_stmt|;
name|CapacitySchedulerConfiguration
name|config
init|=
operator|(
name|CapacitySchedulerConfiguration
operator|)
name|TestUtils
operator|.
name|getConfigurationWithQueueLabels
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// After getting queue conf, configure AM resource percent for Queue A1
comment|// as 0.2 (Label X) and for Queue C1 as 0.2 (Empty Label)
specifier|final
name|String
name|A1
init|=
name|CapacitySchedulerConfiguration
operator|.
name|ROOT
operator|+
literal|".a"
operator|+
literal|".a1"
decl_stmt|;
specifier|final
name|String
name|C1
init|=
name|CapacitySchedulerConfiguration
operator|.
name|ROOT
operator|+
literal|".c"
operator|+
literal|".c1"
decl_stmt|;
name|config
operator|.
name|setMaximumAMResourcePercentPerPartition
argument_list|(
name|A1
argument_list|,
literal|"x"
argument_list|,
literal|0.2f
argument_list|)
expr_stmt|;
name|config
operator|.
name|setMaximumApplicationMasterResourcePerQueuePercent
argument_list|(
name|C1
argument_list|,
literal|0.2f
argument_list|)
expr_stmt|;
comment|// Now inject node label manager with this updated config
name|MockRM
name|rm1
init|=
operator|new
name|MockRM
argument_list|(
name|config
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|RMNodeLabelsManager
name|createNodeLabelManager
parameter_list|()
block|{
return|return
name|mgr
return|;
block|}
block|}
decl_stmt|;
name|rm1
operator|.
name|getRMContext
argument_list|()
operator|.
name|setNodeLabelManager
argument_list|(
name|mgr
argument_list|)
expr_stmt|;
name|rm1
operator|.
name|start
argument_list|()
expr_stmt|;
name|MockNM
name|nm1
init|=
name|rm1
operator|.
name|registerNode
argument_list|(
literal|"h1:1234"
argument_list|,
literal|10
operator|*
name|GB
argument_list|)
decl_stmt|;
comment|// label = x
name|rm1
operator|.
name|registerNode
argument_list|(
literal|"h2:1234"
argument_list|,
literal|10
operator|*
name|GB
argument_list|)
expr_stmt|;
comment|// label = y
name|MockNM
name|nm3
init|=
name|rm1
operator|.
name|registerNode
argument_list|(
literal|"h3:1234"
argument_list|,
literal|10
operator|*
name|GB
argument_list|)
decl_stmt|;
comment|// label =<empty>
comment|// Submit app1 with 1Gb AM resource to Queue A1 for label X
name|RMApp
name|app1
init|=
name|rm1
operator|.
name|submitApp
argument_list|(
name|GB
argument_list|,
literal|"app"
argument_list|,
literal|"user"
argument_list|,
literal|null
argument_list|,
literal|"a1"
argument_list|,
literal|"x"
argument_list|)
decl_stmt|;
comment|// Submit app2 with 1Gb AM resource to Queue A1 for label X
name|RMApp
name|app2
init|=
name|rm1
operator|.
name|submitApp
argument_list|(
name|GB
argument_list|,
literal|"app"
argument_list|,
literal|"user"
argument_list|,
literal|null
argument_list|,
literal|"a1"
argument_list|,
literal|"x"
argument_list|)
decl_stmt|;
comment|// Submit 3rd app to Queue A1 for label X, and this will be pending as
comment|// AM limit is already crossed for label X. (2GB)
name|RMApp
name|pendingApp
init|=
name|rm1
operator|.
name|submitApp
argument_list|(
name|GB
argument_list|,
literal|"app"
argument_list|,
literal|"user"
argument_list|,
literal|null
argument_list|,
literal|"a1"
argument_list|,
literal|"x"
argument_list|)
decl_stmt|;
name|CapacityScheduler
name|cs
init|=
operator|(
name|CapacityScheduler
operator|)
name|rm1
operator|.
name|getResourceScheduler
argument_list|()
decl_stmt|;
name|LeafQueue
name|leafQueue
init|=
operator|(
name|LeafQueue
operator|)
name|cs
operator|.
name|getQueue
argument_list|(
literal|"a1"
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertNotNull
argument_list|(
name|leafQueue
argument_list|)
expr_stmt|;
comment|// Only one AM will be activated here and second AM will be still
comment|// pending.
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|leafQueue
operator|.
name|getNumActiveApplications
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|leafQueue
operator|.
name|getNumPendingApplications
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"AM diagnostics not set properly"
argument_list|,
name|app1
operator|.
name|getDiagnostics
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
name|AMState
operator|.
name|ACTIVATED
operator|.
name|getDiagnosticMessage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"AM diagnostics not set properly"
argument_list|,
name|app2
operator|.
name|getDiagnostics
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
name|AMState
operator|.
name|ACTIVATED
operator|.
name|getDiagnosticMessage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"AM diagnostics not set properly"
argument_list|,
name|pendingApp
operator|.
name|getDiagnostics
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
name|AMState
operator|.
name|INACTIVATED
operator|.
name|getDiagnosticMessage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"AM diagnostics not set properly"
argument_list|,
name|pendingApp
operator|.
name|getDiagnostics
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
name|CSAMContainerLaunchDiagnosticsConstants
operator|.
name|QUEUE_AM_RESOURCE_LIMIT_EXCEED
argument_list|)
argument_list|)
expr_stmt|;
comment|// Now verify the same test case in Queue C1 where label is not configured.
comment|// Submit an app to Queue C1 with empty label
name|RMApp
name|app3
init|=
name|rm1
operator|.
name|submitApp
argument_list|(
name|GB
argument_list|,
literal|"app"
argument_list|,
literal|"user"
argument_list|,
literal|null
argument_list|,
literal|"c1"
argument_list|)
decl_stmt|;
name|MockRM
operator|.
name|launchAndRegisterAM
argument_list|(
name|app3
argument_list|,
name|rm1
argument_list|,
name|nm3
argument_list|)
expr_stmt|;
comment|// Submit next app to Queue C1 with empty label
name|RMApp
name|app4
init|=
name|rm1
operator|.
name|submitApp
argument_list|(
name|GB
argument_list|,
literal|"app"
argument_list|,
literal|"user"
argument_list|,
literal|null
argument_list|,
literal|"c1"
argument_list|)
decl_stmt|;
name|MockRM
operator|.
name|launchAndRegisterAM
argument_list|(
name|app4
argument_list|,
name|rm1
argument_list|,
name|nm3
argument_list|)
expr_stmt|;
comment|// Submit 3rd app to Queue C1. This will be pending as Queue's am-limit
comment|// is reached.
name|pendingApp
operator|=
name|rm1
operator|.
name|submitApp
argument_list|(
name|GB
argument_list|,
literal|"app"
argument_list|,
literal|"user"
argument_list|,
literal|null
argument_list|,
literal|"c1"
argument_list|)
expr_stmt|;
name|leafQueue
operator|=
operator|(
name|LeafQueue
operator|)
name|cs
operator|.
name|getQueue
argument_list|(
literal|"c1"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertNotNull
argument_list|(
name|leafQueue
argument_list|)
expr_stmt|;
comment|// 2 apps will be activated, third one will be pending as am-limit
comment|// is reached.
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|leafQueue
operator|.
name|getNumActiveApplications
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|leafQueue
operator|.
name|getNumPendingApplications
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"AM diagnostics not set properly"
argument_list|,
name|pendingApp
operator|.
name|getDiagnostics
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
name|AMState
operator|.
name|INACTIVATED
operator|.
name|getDiagnosticMessage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"AM diagnostics not set properly"
argument_list|,
name|pendingApp
operator|.
name|getDiagnostics
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
name|CSAMContainerLaunchDiagnosticsConstants
operator|.
name|QUEUE_AM_RESOURCE_LIMIT_EXCEED
argument_list|)
argument_list|)
expr_stmt|;
name|rm1
operator|.
name|killApp
argument_list|(
name|app3
operator|.
name|getApplicationId
argument_list|()
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|// After killing one running app, pending app will also get activated.
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|leafQueue
operator|.
name|getNumActiveApplications
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|leafQueue
operator|.
name|getNumPendingApplications
argument_list|()
argument_list|)
expr_stmt|;
name|rm1
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|120000
argument_list|)
DECL|method|testAtleastOneAMRunPerPartition ()
specifier|public
name|void
name|testAtleastOneAMRunPerPartition
parameter_list|()
throws|throws
name|Exception
block|{
comment|/*      * Test Case:      * Even though am-resource-limit per queue/partition may cross if we      * activate an app (high am resource demand), we have to activate it      * since no other apps are running in that Queue/Partition. Here also      * we run one test case for partition level and one in queue level to      * ensure no breakage in existing functionality.      *      * Queue a1 supports labels (x,y). Configure am-resource-limit as 0.15 (x)      * Queue c1 supports default label. Configure am-resource-limit as 0.15      *      * Queue A1 for label X can only support 1.5Gb AM resource.      * Queue C1 (empty label) can support 1.5Gb AM resource.      *      * Verify atleast one AM is launched in each Queue.      */
name|simpleNodeLabelMappingToManager
argument_list|()
expr_stmt|;
name|CapacitySchedulerConfiguration
name|config
init|=
operator|(
name|CapacitySchedulerConfiguration
operator|)
name|TestUtils
operator|.
name|getConfigurationWithQueueLabels
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// After getting queue conf, configure AM resource percent for Queue A1
comment|// as 0.15 (Label X) and for Queue C1 as 0.15 (Empty Label)
specifier|final
name|String
name|A1
init|=
name|CapacitySchedulerConfiguration
operator|.
name|ROOT
operator|+
literal|".a"
operator|+
literal|".a1"
decl_stmt|;
specifier|final
name|String
name|C1
init|=
name|CapacitySchedulerConfiguration
operator|.
name|ROOT
operator|+
literal|".c"
operator|+
literal|".c1"
decl_stmt|;
name|config
operator|.
name|setMaximumAMResourcePercentPerPartition
argument_list|(
name|A1
argument_list|,
literal|"x"
argument_list|,
literal|0.15f
argument_list|)
expr_stmt|;
name|config
operator|.
name|setMaximumApplicationMasterResourcePerQueuePercent
argument_list|(
name|C1
argument_list|,
literal|0.15f
argument_list|)
expr_stmt|;
comment|// inject node label manager
name|MockRM
name|rm1
init|=
operator|new
name|MockRM
argument_list|(
name|config
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|RMNodeLabelsManager
name|createNodeLabelManager
parameter_list|()
block|{
return|return
name|mgr
return|;
block|}
block|}
decl_stmt|;
name|rm1
operator|.
name|getRMContext
argument_list|()
operator|.
name|setNodeLabelManager
argument_list|(
name|mgr
argument_list|)
expr_stmt|;
name|rm1
operator|.
name|start
argument_list|()
expr_stmt|;
name|MockNM
name|nm1
init|=
name|rm1
operator|.
name|registerNode
argument_list|(
literal|"h1:1234"
argument_list|,
literal|10
operator|*
name|GB
argument_list|)
decl_stmt|;
comment|// label = x
name|rm1
operator|.
name|registerNode
argument_list|(
literal|"h2:1234"
argument_list|,
literal|10
operator|*
name|GB
argument_list|)
expr_stmt|;
comment|// label = y
name|MockNM
name|nm3
init|=
name|rm1
operator|.
name|registerNode
argument_list|(
literal|"h3:1234"
argument_list|,
literal|10
operator|*
name|GB
argument_list|)
decl_stmt|;
comment|// label =<empty>
comment|// Submit app1 (2 GB) to Queue A1 and label X
name|RMApp
name|app1
init|=
name|rm1
operator|.
name|submitApp
argument_list|(
literal|2
operator|*
name|GB
argument_list|,
literal|"app"
argument_list|,
literal|"user"
argument_list|,
literal|null
argument_list|,
literal|"a1"
argument_list|,
literal|"x"
argument_list|)
decl_stmt|;
comment|// This app must be activated eventhough the am-resource per-partition
comment|// limit is only for 1.5GB.
name|MockRM
operator|.
name|launchAndRegisterAM
argument_list|(
name|app1
argument_list|,
name|rm1
argument_list|,
name|nm1
argument_list|)
expr_stmt|;
comment|// Submit 2nd app to label "X" with one GB and it must be pending since
comment|// am-resource per-partition limit is crossed (1.5 GB was the limit).
name|rm1
operator|.
name|submitApp
argument_list|(
name|GB
argument_list|,
literal|"app"
argument_list|,
literal|"user"
argument_list|,
literal|null
argument_list|,
literal|"a1"
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
name|CapacityScheduler
name|cs
init|=
operator|(
name|CapacityScheduler
operator|)
name|rm1
operator|.
name|getResourceScheduler
argument_list|()
decl_stmt|;
name|LeafQueue
name|leafQueue
init|=
operator|(
name|LeafQueue
operator|)
name|cs
operator|.
name|getQueue
argument_list|(
literal|"a1"
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertNotNull
argument_list|(
name|leafQueue
argument_list|)
expr_stmt|;
comment|// Only 1 app will be activated as am-limit for partition "x" is 0.15
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|leafQueue
operator|.
name|getNumActiveApplications
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|leafQueue
operator|.
name|getNumPendingApplications
argument_list|()
argument_list|)
expr_stmt|;
comment|// Now verify the same test case in Queue C1 which takes default label
comment|// to see queue level am-resource-limit is still working as expected.
comment|// Submit an app to Queue C1 with empty label (2 GB)
name|RMApp
name|app3
init|=
name|rm1
operator|.
name|submitApp
argument_list|(
literal|2
operator|*
name|GB
argument_list|,
literal|"app"
argument_list|,
literal|"user"
argument_list|,
literal|null
argument_list|,
literal|"c1"
argument_list|)
decl_stmt|;
comment|// This app must be activated even though the am-resource per-queue
comment|// limit is only for 1.5GB
name|MockRM
operator|.
name|launchAndRegisterAM
argument_list|(
name|app3
argument_list|,
name|rm1
argument_list|,
name|nm3
argument_list|)
expr_stmt|;
comment|// Submit 2nd app to C1 (Default label, hence am-limit per-queue will be
comment|// considered).
name|rm1
operator|.
name|submitApp
argument_list|(
name|GB
argument_list|,
literal|"app"
argument_list|,
literal|"user"
argument_list|,
literal|null
argument_list|,
literal|"c1"
argument_list|)
expr_stmt|;
name|leafQueue
operator|=
operator|(
name|LeafQueue
operator|)
name|cs
operator|.
name|getQueue
argument_list|(
literal|"c1"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertNotNull
argument_list|(
name|leafQueue
argument_list|)
expr_stmt|;
comment|// 1 app will be activated (and it has AM resource more than queue limit)
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|leafQueue
operator|.
name|getNumActiveApplications
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|leafQueue
operator|.
name|getNumPendingApplications
argument_list|()
argument_list|)
expr_stmt|;
name|rm1
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|120000
argument_list|)
DECL|method|testDefaultAMLimitFromQueueForPartition ()
specifier|public
name|void
name|testDefaultAMLimitFromQueueForPartition
parameter_list|()
throws|throws
name|Exception
block|{
comment|/*      * Test Case:      * Configure AM resource limit per queue level. If partition level config      * is not found, we will be considering per-queue level am-limit. Ensure      * this is working as expected.      *      * Queue A1 am-resource limit to be configured as 0.2 (not for partition x)      *      * Eventhough per-partition level config is not done, CS should consider      * the configuration done for queue level.      */
name|simpleNodeLabelMappingToManager
argument_list|()
expr_stmt|;
name|CapacitySchedulerConfiguration
name|config
init|=
operator|(
name|CapacitySchedulerConfiguration
operator|)
name|TestUtils
operator|.
name|getConfigurationWithQueueLabels
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// After getting queue conf, configure AM resource percent for Queue A1
comment|// as 0.2 (not for partition, rather in queue level)
specifier|final
name|String
name|A1
init|=
name|CapacitySchedulerConfiguration
operator|.
name|ROOT
operator|+
literal|".a"
operator|+
literal|".a1"
decl_stmt|;
name|config
operator|.
name|setMaximumApplicationMasterResourcePerQueuePercent
argument_list|(
name|A1
argument_list|,
literal|0.2f
argument_list|)
expr_stmt|;
comment|// inject node label manager
name|MockRM
name|rm1
init|=
operator|new
name|MockRM
argument_list|(
name|config
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|RMNodeLabelsManager
name|createNodeLabelManager
parameter_list|()
block|{
return|return
name|mgr
return|;
block|}
block|}
decl_stmt|;
name|rm1
operator|.
name|getRMContext
argument_list|()
operator|.
name|setNodeLabelManager
argument_list|(
name|mgr
argument_list|)
expr_stmt|;
name|rm1
operator|.
name|start
argument_list|()
expr_stmt|;
name|MockNM
name|nm1
init|=
name|rm1
operator|.
name|registerNode
argument_list|(
literal|"h1:1234"
argument_list|,
literal|10
operator|*
name|GB
argument_list|)
decl_stmt|;
comment|// label = x
name|rm1
operator|.
name|registerNode
argument_list|(
literal|"h2:1234"
argument_list|,
literal|10
operator|*
name|GB
argument_list|)
expr_stmt|;
comment|// label = y
name|rm1
operator|.
name|registerNode
argument_list|(
literal|"h3:1234"
argument_list|,
literal|10
operator|*
name|GB
argument_list|)
expr_stmt|;
comment|// label =<empty>
comment|// Submit app1 (2 GB) to Queue A1 and label X
name|RMApp
name|app1
init|=
name|rm1
operator|.
name|submitApp
argument_list|(
literal|2
operator|*
name|GB
argument_list|,
literal|"app"
argument_list|,
literal|"user"
argument_list|,
literal|null
argument_list|,
literal|"a1"
argument_list|,
literal|"x"
argument_list|)
decl_stmt|;
comment|// Submit 2nd app to label "X" with one GB. Since queue am-limit is 2GB,
comment|// 2nd app will be pending and first one will get activated.
name|RMApp
name|pendingApp
init|=
name|rm1
operator|.
name|submitApp
argument_list|(
name|GB
argument_list|,
literal|"app"
argument_list|,
literal|"user"
argument_list|,
literal|null
argument_list|,
literal|"a1"
argument_list|,
literal|"x"
argument_list|)
decl_stmt|;
name|CapacityScheduler
name|cs
init|=
operator|(
name|CapacityScheduler
operator|)
name|rm1
operator|.
name|getResourceScheduler
argument_list|()
decl_stmt|;
name|LeafQueue
name|leafQueue
init|=
operator|(
name|LeafQueue
operator|)
name|cs
operator|.
name|getQueue
argument_list|(
literal|"a1"
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertNotNull
argument_list|(
name|leafQueue
argument_list|)
expr_stmt|;
comment|// Only 1 app will be activated as am-limit for queue is 0.2 and same is
comment|// used for partition "x" also.
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|leafQueue
operator|.
name|getNumActiveApplications
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|leafQueue
operator|.
name|getNumPendingApplications
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"AM diagnostics not set properly"
argument_list|,
name|app1
operator|.
name|getDiagnostics
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
name|AMState
operator|.
name|ACTIVATED
operator|.
name|getDiagnosticMessage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"AM diagnostics not set properly"
argument_list|,
name|pendingApp
operator|.
name|getDiagnostics
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
name|AMState
operator|.
name|INACTIVATED
operator|.
name|getDiagnosticMessage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"AM diagnostics not set properly"
argument_list|,
name|pendingApp
operator|.
name|getDiagnostics
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
name|CSAMContainerLaunchDiagnosticsConstants
operator|.
name|QUEUE_AM_RESOURCE_LIMIT_EXCEED
argument_list|)
argument_list|)
expr_stmt|;
name|rm1
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|120000
argument_list|)
DECL|method|testUserAMResourceLimitWithLabels ()
specifier|public
name|void
name|testUserAMResourceLimitWithLabels
parameter_list|()
throws|throws
name|Exception
block|{
comment|/*      * Test Case:      * Verify user level AM resource limit. This test case is ran with two      * users. And per-partition level am-resource-limit will be 0.4, which      * internally will be 4GB. Hence 2GB will be available for each      * user for its AM resource.      *      * Now this test case will create a scenario where AM resource limit per      * partition is not met, but user level am-resource limit is reached.      * Hence app will be pending.      */
specifier|final
name|String
name|user_0
init|=
literal|"user_0"
decl_stmt|;
specifier|final
name|String
name|user_1
init|=
literal|"user_1"
decl_stmt|;
name|simpleNodeLabelMappingToManager
argument_list|()
expr_stmt|;
name|CapacitySchedulerConfiguration
name|config
init|=
operator|(
name|CapacitySchedulerConfiguration
operator|)
name|TestUtils
operator|.
name|getConfigurationWithQueueLabels
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// After getting queue conf, configure AM resource percent for Queue A1
comment|// as 0.4 (Label X). Also set userlimit as 50% for this queue. So when we
comment|// have two users submitting applications, each user will get 50%  of AM
comment|// resource which is available in this partition.
specifier|final
name|String
name|A1
init|=
name|CapacitySchedulerConfiguration
operator|.
name|ROOT
operator|+
literal|".a"
operator|+
literal|".a1"
decl_stmt|;
name|config
operator|.
name|setMaximumAMResourcePercentPerPartition
argument_list|(
name|A1
argument_list|,
literal|"x"
argument_list|,
literal|0.4f
argument_list|)
expr_stmt|;
name|config
operator|.
name|setUserLimit
argument_list|(
name|A1
argument_list|,
literal|50
argument_list|)
expr_stmt|;
comment|// Now inject node label manager with this updated config
name|MockRM
name|rm1
init|=
operator|new
name|MockRM
argument_list|(
name|config
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|RMNodeLabelsManager
name|createNodeLabelManager
parameter_list|()
block|{
return|return
name|mgr
return|;
block|}
block|}
decl_stmt|;
name|rm1
operator|.
name|getRMContext
argument_list|()
operator|.
name|setNodeLabelManager
argument_list|(
name|mgr
argument_list|)
expr_stmt|;
name|rm1
operator|.
name|start
argument_list|()
expr_stmt|;
name|MockNM
name|nm1
init|=
name|rm1
operator|.
name|registerNode
argument_list|(
literal|"h1:1234"
argument_list|,
literal|10
operator|*
name|GB
argument_list|)
decl_stmt|;
comment|// label = x
name|rm1
operator|.
name|registerNode
argument_list|(
literal|"h2:1234"
argument_list|,
literal|10
operator|*
name|GB
argument_list|)
expr_stmt|;
comment|// label = y
name|rm1
operator|.
name|registerNode
argument_list|(
literal|"h3:1234"
argument_list|,
literal|10
operator|*
name|GB
argument_list|)
expr_stmt|;
comment|// label =<empty>
comment|// Submit app1 with 1Gb AM resource to Queue A1 for label X for user0
name|RMApp
name|app1
init|=
name|rm1
operator|.
name|submitApp
argument_list|(
name|GB
argument_list|,
literal|"app"
argument_list|,
name|user_0
argument_list|,
literal|null
argument_list|,
literal|"a1"
argument_list|,
literal|"x"
argument_list|)
decl_stmt|;
name|MockAM
name|am1
init|=
name|MockRM
operator|.
name|launchAndRegisterAM
argument_list|(
name|app1
argument_list|,
name|rm1
argument_list|,
name|nm1
argument_list|)
decl_stmt|;
comment|// Place few allocate requests to make it an active application
name|am1
operator|.
name|allocate
argument_list|(
literal|"*"
argument_list|,
literal|1
operator|*
name|GB
argument_list|,
literal|15
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|ContainerId
argument_list|>
argument_list|()
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|// Now submit 2nd app to Queue A1 for label X for user1
name|RMApp
name|app2
init|=
name|rm1
operator|.
name|submitApp
argument_list|(
name|GB
argument_list|,
literal|"app"
argument_list|,
name|user_1
argument_list|,
literal|null
argument_list|,
literal|"a1"
argument_list|,
literal|"x"
argument_list|)
decl_stmt|;
name|MockRM
operator|.
name|launchAndRegisterAM
argument_list|(
name|app2
argument_list|,
name|rm1
argument_list|,
name|nm1
argument_list|)
expr_stmt|;
name|CapacityScheduler
name|cs
init|=
operator|(
name|CapacityScheduler
operator|)
name|rm1
operator|.
name|getResourceScheduler
argument_list|()
decl_stmt|;
name|LeafQueue
name|leafQueue
init|=
operator|(
name|LeafQueue
operator|)
name|cs
operator|.
name|getQueue
argument_list|(
literal|"a1"
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertNotNull
argument_list|(
name|leafQueue
argument_list|)
expr_stmt|;
comment|// Verify active applications count in this queue.
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|leafQueue
operator|.
name|getNumActiveApplications
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|leafQueue
operator|.
name|getNumActiveApplications
argument_list|(
name|user_0
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|leafQueue
operator|.
name|getNumPendingApplications
argument_list|()
argument_list|)
expr_stmt|;
comment|// Submit 3rd app to Queue A1 for label X for user1. Now user1 will have
comment|// 2 applications (2 GB resource) and user0 will have one app (1GB).
name|RMApp
name|app3
init|=
name|rm1
operator|.
name|submitApp
argument_list|(
name|GB
argument_list|,
literal|"app"
argument_list|,
name|user_1
argument_list|,
literal|null
argument_list|,
literal|"a1"
argument_list|,
literal|"x"
argument_list|)
decl_stmt|;
name|MockAM
name|am2
init|=
name|MockRM
operator|.
name|launchAndRegisterAM
argument_list|(
name|app3
argument_list|,
name|rm1
argument_list|,
name|nm1
argument_list|)
decl_stmt|;
comment|// Place few allocate requests to make it an active application. This is
comment|// to ensure that user1 and user0 are active users.
name|am2
operator|.
name|allocate
argument_list|(
literal|"*"
argument_list|,
literal|1
operator|*
name|GB
argument_list|,
literal|10
argument_list|,
operator|new
name|ArrayList
argument_list|<
name|ContainerId
argument_list|>
argument_list|()
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|// Submit final app to Queue A1 for label X. Since we are trying to submit
comment|// for user1, we need 3Gb resource for AMs.
comment|// 4Gb -> 40% of label "X" in queue A1
comment|// Since we have 2 users, 50% of 4Gb will be max for each user. Here user1
comment|// has already crossed this 2GB limit, hence this app will be pending.
name|RMApp
name|pendingApp
init|=
name|rm1
operator|.
name|submitApp
argument_list|(
name|GB
argument_list|,
literal|"app"
argument_list|,
name|user_1
argument_list|,
literal|null
argument_list|,
literal|"a1"
argument_list|,
literal|"x"
argument_list|)
decl_stmt|;
comment|// Verify active applications count per user and also in queue level.
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|leafQueue
operator|.
name|getNumActiveApplications
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|leafQueue
operator|.
name|getNumActiveApplications
argument_list|(
name|user_0
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|leafQueue
operator|.
name|getNumActiveApplications
argument_list|(
name|user_1
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|leafQueue
operator|.
name|getNumPendingApplications
argument_list|(
name|user_1
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|leafQueue
operator|.
name|getNumPendingApplications
argument_list|()
argument_list|)
expr_stmt|;
comment|//verify Diagnostic messages
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"AM diagnostics not set properly"
argument_list|,
name|pendingApp
operator|.
name|getDiagnostics
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
name|AMState
operator|.
name|INACTIVATED
operator|.
name|getDiagnosticMessage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"AM diagnostics not set properly"
argument_list|,
name|pendingApp
operator|.
name|getDiagnostics
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
name|CSAMContainerLaunchDiagnosticsConstants
operator|.
name|USER_AM_RESOURCE_LIMIT_EXCEED
argument_list|)
argument_list|)
expr_stmt|;
name|rm1
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testAMResourceLimitForMultipleApplications ()
specifier|public
name|void
name|testAMResourceLimitForMultipleApplications
parameter_list|()
throws|throws
name|Exception
block|{
comment|/*      * Test Case:      * In a complex node label setup, verify am-resource-percentage calculation      * and check whether applications can get activated as per expectation.      */
name|complexNodeLabelMappingToManager
argument_list|()
expr_stmt|;
name|CapacitySchedulerConfiguration
name|config
init|=
operator|(
name|CapacitySchedulerConfiguration
operator|)
name|TestUtils
operator|.
name|getComplexConfigurationWithQueueLabels
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|/*      * Queue structure:      *                      root (*)      *                  ________________      *                 /                \      *               a x(100%), y(50%)   b y(50%), z(100%)      *               ________________    ______________      *              /                   /              \      *             a1 (x,y)         b1(no)              b2(y,z)      *               100%                          y = 100%, z = 100%      *      * Node structure:      * h1 : x      * h2 : y      * h3 : y      * h4 : z      * h5 : NO      *      * Total resource:      * x: 10G      * y: 20G      * z: 10G      * *: 10G      *      * AM resource percentage config:      * A1  : 0.25      * B2  : 0.15      */
specifier|final
name|String
name|A1
init|=
name|CapacitySchedulerConfiguration
operator|.
name|ROOT
operator|+
literal|".a"
operator|+
literal|".a1"
decl_stmt|;
specifier|final
name|String
name|B1
init|=
name|CapacitySchedulerConfiguration
operator|.
name|ROOT
operator|+
literal|".b"
operator|+
literal|".b1"
decl_stmt|;
name|config
operator|.
name|setMaximumAMResourcePercentPerPartition
argument_list|(
name|A1
argument_list|,
literal|"y"
argument_list|,
literal|0.25f
argument_list|)
expr_stmt|;
name|config
operator|.
name|setMaximumApplicationMasterResourcePerQueuePercent
argument_list|(
name|B1
argument_list|,
literal|0.15f
argument_list|)
expr_stmt|;
comment|// Now inject node label manager with this updated config
name|MockRM
name|rm1
init|=
operator|new
name|MockRM
argument_list|(
name|config
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|RMNodeLabelsManager
name|createNodeLabelManager
parameter_list|()
block|{
return|return
name|mgr
return|;
block|}
block|}
decl_stmt|;
name|rm1
operator|.
name|getRMContext
argument_list|()
operator|.
name|setNodeLabelManager
argument_list|(
name|mgr
argument_list|)
expr_stmt|;
name|rm1
operator|.
name|start
argument_list|()
expr_stmt|;
name|rm1
operator|.
name|registerNode
argument_list|(
literal|"h1:1234"
argument_list|,
literal|10
operator|*
name|GB
argument_list|)
expr_stmt|;
comment|// label = x
name|MockNM
name|nm2
init|=
name|rm1
operator|.
name|registerNode
argument_list|(
literal|"h2:1234"
argument_list|,
literal|10
operator|*
name|GB
argument_list|)
decl_stmt|;
comment|// label = y
name|MockNM
name|nm3
init|=
name|rm1
operator|.
name|registerNode
argument_list|(
literal|"h3:1234"
argument_list|,
literal|10
operator|*
name|GB
argument_list|)
decl_stmt|;
comment|// label = y
name|rm1
operator|.
name|registerNode
argument_list|(
literal|"h4:1234"
argument_list|,
literal|10
operator|*
name|GB
argument_list|)
expr_stmt|;
comment|// label = z
name|MockNM
name|nm5
init|=
name|rm1
operator|.
name|registerNode
argument_list|(
literal|"h5:1234"
argument_list|,
literal|10
operator|*
name|GB
argument_list|)
decl_stmt|;
comment|// label =<empty>
comment|// Submit app1 with 2Gb AM resource to Queue A1 for label Y
name|RMApp
name|app1
init|=
name|rm1
operator|.
name|submitApp
argument_list|(
literal|2
operator|*
name|GB
argument_list|,
literal|"app"
argument_list|,
literal|"user"
argument_list|,
literal|null
argument_list|,
literal|"a1"
argument_list|,
literal|"y"
argument_list|)
decl_stmt|;
name|MockRM
operator|.
name|launchAndRegisterAM
argument_list|(
name|app1
argument_list|,
name|rm1
argument_list|,
name|nm2
argument_list|)
expr_stmt|;
comment|// Submit app2 with 1Gb AM resource to Queue A1 for label Y
name|RMApp
name|app2
init|=
name|rm1
operator|.
name|submitApp
argument_list|(
name|GB
argument_list|,
literal|"app"
argument_list|,
literal|"user"
argument_list|,
literal|null
argument_list|,
literal|"a1"
argument_list|,
literal|"y"
argument_list|)
decl_stmt|;
name|MockRM
operator|.
name|launchAndRegisterAM
argument_list|(
name|app2
argument_list|,
name|rm1
argument_list|,
name|nm3
argument_list|)
expr_stmt|;
comment|// Submit another app with 1Gb AM resource to Queue A1 for label Y
name|rm1
operator|.
name|submitApp
argument_list|(
name|GB
argument_list|,
literal|"app"
argument_list|,
literal|"user"
argument_list|,
literal|null
argument_list|,
literal|"a1"
argument_list|,
literal|"y"
argument_list|)
expr_stmt|;
name|CapacityScheduler
name|cs
init|=
operator|(
name|CapacityScheduler
operator|)
name|rm1
operator|.
name|getResourceScheduler
argument_list|()
decl_stmt|;
name|LeafQueue
name|leafQueue
init|=
operator|(
name|LeafQueue
operator|)
name|cs
operator|.
name|getQueue
argument_list|(
literal|"a1"
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertNotNull
argument_list|(
name|leafQueue
argument_list|)
expr_stmt|;
comment|/*      *  capacity of queue A  -> 50% for label Y      *  capacity of queue A1 -> 100% for label Y      *      *  Total resources available for label Y -> 20GB (nm2 and nm3)      *  Hence in queue A1, max resource for label Y is 10GB.      *      *  AM resource percent config for queue A1 -> 0.25      *        ==> 2.5Gb (3 Gb) is max-am-resource-limit      */
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|leafQueue
operator|.
name|getNumActiveApplications
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|leafQueue
operator|.
name|getNumPendingApplications
argument_list|()
argument_list|)
expr_stmt|;
comment|// Submit app3 with 1Gb AM resource to Queue B1 (no_label)
name|RMApp
name|app3
init|=
name|rm1
operator|.
name|submitApp
argument_list|(
name|GB
argument_list|,
literal|"app"
argument_list|,
literal|"user"
argument_list|,
literal|null
argument_list|,
literal|"b1"
argument_list|)
decl_stmt|;
name|MockRM
operator|.
name|launchAndRegisterAM
argument_list|(
name|app3
argument_list|,
name|rm1
argument_list|,
name|nm5
argument_list|)
expr_stmt|;
comment|// Submit another app with 1Gb AM resource to Queue B1 (no_label)
name|rm1
operator|.
name|submitApp
argument_list|(
name|GB
argument_list|,
literal|"app"
argument_list|,
literal|"user"
argument_list|,
literal|null
argument_list|,
literal|"b1"
argument_list|)
expr_stmt|;
name|leafQueue
operator|=
operator|(
name|LeafQueue
operator|)
name|cs
operator|.
name|getQueue
argument_list|(
literal|"b1"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertNotNull
argument_list|(
name|leafQueue
argument_list|)
expr_stmt|;
comment|/*      *  capacity of queue B  -> 90% for queue      *                       -> and 100% for no-label      *  capacity of queue B1 -> 50% for no-label/queue      *      *  Total resources available for no-label -> 10GB (nm5)      *  Hence in queue B1, max resource for no-label is 5GB.      *      *  AM resource percent config for queue B1 -> 0.15      *        ==> 1Gb is max-am-resource-limit      *      *  Only one app will be activated and all othe will be pending.      */
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|leafQueue
operator|.
name|getNumActiveApplications
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|leafQueue
operator|.
name|getNumPendingApplications
argument_list|()
argument_list|)
expr_stmt|;
name|rm1
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testHeadroom ()
specifier|public
name|void
name|testHeadroom
parameter_list|()
throws|throws
name|Exception
block|{
comment|/*      * Test Case: Verify Headroom calculated is sum of headrooms for each      * partition requested. So submit a app with requests for default partition      * and 'x' partition, so the total headroom for the user should be sum of      * the head room for both labels.      */
name|simpleNodeLabelMappingToManager
argument_list|()
expr_stmt|;
name|CapacitySchedulerConfiguration
name|csConf
init|=
operator|(
name|CapacitySchedulerConfiguration
operator|)
name|TestUtils
operator|.
name|getComplexConfigurationWithQueueLabels
argument_list|(
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|String
name|A1
init|=
name|CapacitySchedulerConfiguration
operator|.
name|ROOT
operator|+
literal|".a"
operator|+
literal|".a1"
decl_stmt|;
specifier|final
name|String
name|B2
init|=
name|CapacitySchedulerConfiguration
operator|.
name|ROOT
operator|+
literal|".b"
operator|+
literal|".b2"
decl_stmt|;
name|csConf
operator|.
name|setUserLimit
argument_list|(
name|A1
argument_list|,
literal|25
argument_list|)
expr_stmt|;
name|csConf
operator|.
name|setUserLimit
argument_list|(
name|B2
argument_list|,
literal|25
argument_list|)
expr_stmt|;
name|YarnConfiguration
name|conf
init|=
operator|new
name|YarnConfiguration
argument_list|()
decl_stmt|;
name|CapacitySchedulerContext
name|csContext
init|=
name|mock
argument_list|(
name|CapacitySchedulerContext
operator|.
name|class
argument_list|)
decl_stmt|;
name|when
argument_list|(
name|csContext
operator|.
name|getConfiguration
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|csConf
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|csContext
operator|.
name|getConf
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|csContext
operator|.
name|getMinimumResourceCapability
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|Resources
operator|.
name|createResource
argument_list|(
name|GB
argument_list|)
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|csContext
operator|.
name|getMaximumResourceCapability
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|Resources
operator|.
name|createResource
argument_list|(
literal|16
operator|*
name|GB
argument_list|)
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|csContext
operator|.
name|getNonPartitionedQueueComparator
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|CapacitySchedulerQueueManager
operator|.
name|NON_PARTITIONED_QUEUE_COMPARATOR
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|csContext
operator|.
name|getResourceCalculator
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|resourceCalculator
argument_list|)
expr_stmt|;
name|RMContext
name|rmContext
init|=
name|TestUtils
operator|.
name|getMockRMContext
argument_list|()
decl_stmt|;
name|RMContext
name|spyRMContext
init|=
name|spy
argument_list|(
name|rmContext
argument_list|)
decl_stmt|;
name|when
argument_list|(
name|spyRMContext
operator|.
name|getNodeLabelManager
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|mgr
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|csContext
operator|.
name|getRMContext
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|spyRMContext
argument_list|)
expr_stmt|;
name|mgr
operator|.
name|activateNode
argument_list|(
name|NodeId
operator|.
name|newInstance
argument_list|(
literal|"h0"
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Resource
operator|.
name|newInstance
argument_list|(
literal|160
operator|*
name|GB
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
comment|// default Label
name|mgr
operator|.
name|activateNode
argument_list|(
name|NodeId
operator|.
name|newInstance
argument_list|(
literal|"h1"
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Resource
operator|.
name|newInstance
argument_list|(
literal|160
operator|*
name|GB
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
comment|// label x
name|mgr
operator|.
name|activateNode
argument_list|(
name|NodeId
operator|.
name|newInstance
argument_list|(
literal|"h2"
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Resource
operator|.
name|newInstance
argument_list|(
literal|160
operator|*
name|GB
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
comment|// label y
comment|// Say cluster has 100 nodes of 16G each
name|Resource
name|clusterResource
init|=
name|Resources
operator|.
name|createResource
argument_list|(
literal|160
operator|*
name|GB
argument_list|)
decl_stmt|;
name|when
argument_list|(
name|csContext
operator|.
name|getClusterResource
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|clusterResource
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
name|queues
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|CSQueue
argument_list|>
argument_list|()
decl_stmt|;
name|CSQueue
name|rootQueue
init|=
name|CapacitySchedulerQueueManager
operator|.
name|parseQueue
argument_list|(
name|csContext
argument_list|,
name|csConf
argument_list|,
literal|null
argument_list|,
literal|"root"
argument_list|,
name|queues
argument_list|,
name|queues
argument_list|,
name|TestUtils
operator|.
name|spyHook
argument_list|)
decl_stmt|;
name|ResourceUsage
name|queueResUsage
init|=
name|rootQueue
operator|.
name|getQueueResourceUsage
argument_list|()
decl_stmt|;
name|when
argument_list|(
name|csContext
operator|.
name|getClusterResourceUsage
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|queueResUsage
argument_list|)
expr_stmt|;
comment|// Manipulate queue 'a'
name|LeafQueue
name|queue
init|=
name|TestLeafQueue
operator|.
name|stubLeafQueue
argument_list|(
operator|(
name|LeafQueue
operator|)
name|queues
operator|.
name|get
argument_list|(
literal|"b2"
argument_list|)
argument_list|)
decl_stmt|;
name|queue
operator|.
name|updateClusterResource
argument_list|(
name|clusterResource
argument_list|,
operator|new
name|ResourceLimits
argument_list|(
name|clusterResource
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|rack_0
init|=
literal|"rack_0"
decl_stmt|;
name|FiCaSchedulerNode
name|node_0
init|=
name|TestUtils
operator|.
name|getMockNode
argument_list|(
literal|"h0"
argument_list|,
name|rack_0
argument_list|,
literal|0
argument_list|,
literal|160
operator|*
name|GB
argument_list|)
decl_stmt|;
name|FiCaSchedulerNode
name|node_1
init|=
name|TestUtils
operator|.
name|getMockNode
argument_list|(
literal|"h1"
argument_list|,
name|rack_0
argument_list|,
literal|0
argument_list|,
literal|160
operator|*
name|GB
argument_list|)
decl_stmt|;
specifier|final
name|String
name|user_0
init|=
literal|"user_0"
decl_stmt|;
specifier|final
name|String
name|user_1
init|=
literal|"user_1"
decl_stmt|;
name|RecordFactory
name|recordFactory
init|=
name|RecordFactoryProvider
operator|.
name|getRecordFactory
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|ConcurrentMap
argument_list|<
name|ApplicationId
argument_list|,
name|RMApp
argument_list|>
name|spyApps
init|=
name|spy
argument_list|(
operator|new
name|ConcurrentHashMap
argument_list|<
name|ApplicationId
argument_list|,
name|RMApp
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
name|RMApp
name|rmApp
init|=
name|mock
argument_list|(
name|RMApp
operator|.
name|class
argument_list|)
decl_stmt|;
name|ResourceRequest
name|amResourceRequest
init|=
name|mock
argument_list|(
name|ResourceRequest
operator|.
name|class
argument_list|)
decl_stmt|;
name|Resource
name|amResource
init|=
name|Resources
operator|.
name|createResource
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|when
argument_list|(
name|amResourceRequest
operator|.
name|getCapability
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|amResource
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|rmApp
operator|.
name|getAMResourceRequest
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|amResourceRequest
argument_list|)
expr_stmt|;
name|Mockito
operator|.
name|doReturn
argument_list|(
name|rmApp
argument_list|)
operator|.
name|when
argument_list|(
name|spyApps
argument_list|)
operator|.
name|get
argument_list|(
operator|(
name|ApplicationId
operator|)
name|Matchers
operator|.
name|any
argument_list|()
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|spyRMContext
operator|.
name|getRMApps
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|spyApps
argument_list|)
expr_stmt|;
name|RMAppAttempt
name|rmAppAttempt
init|=
name|mock
argument_list|(
name|RMAppAttempt
operator|.
name|class
argument_list|)
decl_stmt|;
name|when
argument_list|(
name|rmApp
operator|.
name|getRMAppAttempt
argument_list|(
operator|(
name|ApplicationAttemptId
operator|)
name|Matchers
operator|.
name|any
argument_list|()
argument_list|)
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|rmAppAttempt
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|rmApp
operator|.
name|getCurrentAppAttempt
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|rmAppAttempt
argument_list|)
expr_stmt|;
name|Mockito
operator|.
name|doReturn
argument_list|(
name|rmApp
argument_list|)
operator|.
name|when
argument_list|(
name|spyApps
argument_list|)
operator|.
name|get
argument_list|(
operator|(
name|ApplicationId
operator|)
name|Matchers
operator|.
name|any
argument_list|()
argument_list|)
expr_stmt|;
name|Mockito
operator|.
name|doReturn
argument_list|(
literal|true
argument_list|)
operator|.
name|when
argument_list|(
name|spyApps
argument_list|)
operator|.
name|containsKey
argument_list|(
operator|(
name|ApplicationId
operator|)
name|Matchers
operator|.
name|any
argument_list|()
argument_list|)
expr_stmt|;
name|Priority
name|priority_1
init|=
name|TestUtils
operator|.
name|createMockPriority
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// Submit first application with some resource-requests from user_0,
comment|// and check headroom
specifier|final
name|ApplicationAttemptId
name|appAttemptId_0_0
init|=
name|TestUtils
operator|.
name|getMockApplicationAttemptId
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|FiCaSchedulerApp
name|app_0_0
init|=
operator|new
name|FiCaSchedulerApp
argument_list|(
name|appAttemptId_0_0
argument_list|,
name|user_0
argument_list|,
name|queue
argument_list|,
name|queue
operator|.
name|getActiveUsersManager
argument_list|()
argument_list|,
name|spyRMContext
argument_list|)
decl_stmt|;
name|queue
operator|.
name|submitApplicationAttempt
argument_list|(
name|app_0_0
argument_list|,
name|user_0
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ResourceRequest
argument_list|>
name|app_0_0_requests
init|=
operator|new
name|ArrayList
argument_list|<
name|ResourceRequest
argument_list|>
argument_list|()
decl_stmt|;
name|app_0_0_requests
operator|.
name|add
argument_list|(
name|TestUtils
operator|.
name|createResourceRequest
argument_list|(
name|ResourceRequest
operator|.
name|ANY
argument_list|,
literal|1
operator|*
name|GB
argument_list|,
literal|2
argument_list|,
literal|true
argument_list|,
name|priority_1
argument_list|,
name|recordFactory
argument_list|)
argument_list|)
expr_stmt|;
name|app_0_0
operator|.
name|updateResourceRequests
argument_list|(
name|app_0_0_requests
argument_list|)
expr_stmt|;
comment|// Schedule to compute
name|queue
operator|.
name|assignContainers
argument_list|(
name|clusterResource
argument_list|,
name|node_0
argument_list|,
operator|new
name|ResourceLimits
argument_list|(
name|clusterResource
argument_list|)
argument_list|,
name|SchedulingMode
operator|.
name|RESPECT_PARTITION_EXCLUSIVITY
argument_list|)
expr_stmt|;
comment|//head room = queue capacity = 50 % 90% 160 GB
name|Resource
name|expectedHeadroom
init|=
name|Resources
operator|.
name|createResource
argument_list|(
call|(
name|int
call|)
argument_list|(
literal|0.5
operator|*
literal|0.9
operator|*
literal|160
argument_list|)
operator|*
name|GB
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|expectedHeadroom
argument_list|,
name|app_0_0
operator|.
name|getHeadroom
argument_list|()
argument_list|)
expr_stmt|;
comment|// Submit second application from user_0, check headroom
specifier|final
name|ApplicationAttemptId
name|appAttemptId_0_1
init|=
name|TestUtils
operator|.
name|getMockApplicationAttemptId
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|FiCaSchedulerApp
name|app_0_1
init|=
operator|new
name|FiCaSchedulerApp
argument_list|(
name|appAttemptId_0_1
argument_list|,
name|user_0
argument_list|,
name|queue
argument_list|,
name|queue
operator|.
name|getActiveUsersManager
argument_list|()
argument_list|,
name|spyRMContext
argument_list|)
decl_stmt|;
name|queue
operator|.
name|submitApplicationAttempt
argument_list|(
name|app_0_1
argument_list|,
name|user_0
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ResourceRequest
argument_list|>
name|app_0_1_requests
init|=
operator|new
name|ArrayList
argument_list|<
name|ResourceRequest
argument_list|>
argument_list|()
decl_stmt|;
name|app_0_1_requests
operator|.
name|add
argument_list|(
name|TestUtils
operator|.
name|createResourceRequest
argument_list|(
name|ResourceRequest
operator|.
name|ANY
argument_list|,
literal|1
operator|*
name|GB
argument_list|,
literal|2
argument_list|,
literal|true
argument_list|,
name|priority_1
argument_list|,
name|recordFactory
argument_list|)
argument_list|)
expr_stmt|;
name|app_0_1
operator|.
name|updateResourceRequests
argument_list|(
name|app_0_1_requests
argument_list|)
expr_stmt|;
name|app_0_1_requests
operator|.
name|clear
argument_list|()
expr_stmt|;
name|app_0_1_requests
operator|.
name|add
argument_list|(
name|TestUtils
operator|.
name|createResourceRequest
argument_list|(
name|ResourceRequest
operator|.
name|ANY
argument_list|,
literal|1
operator|*
name|GB
argument_list|,
literal|2
argument_list|,
literal|true
argument_list|,
name|priority_1
argument_list|,
name|recordFactory
argument_list|,
literal|"y"
argument_list|)
argument_list|)
expr_stmt|;
name|app_0_1
operator|.
name|updateResourceRequests
argument_list|(
name|app_0_1_requests
argument_list|)
expr_stmt|;
comment|// Schedule to compute
name|queue
operator|.
name|assignContainers
argument_list|(
name|clusterResource
argument_list|,
name|node_0
argument_list|,
operator|new
name|ResourceLimits
argument_list|(
name|clusterResource
argument_list|)
argument_list|,
name|SchedulingMode
operator|.
name|RESPECT_PARTITION_EXCLUSIVITY
argument_list|)
expr_stmt|;
comment|// Schedule to compute
name|queue
operator|.
name|assignContainers
argument_list|(
name|clusterResource
argument_list|,
name|node_1
argument_list|,
operator|new
name|ResourceLimits
argument_list|(
name|clusterResource
argument_list|)
argument_list|,
name|SchedulingMode
operator|.
name|RESPECT_PARTITION_EXCLUSIVITY
argument_list|)
expr_stmt|;
comment|// Schedule to compute
name|assertEquals
argument_list|(
name|expectedHeadroom
argument_list|,
name|app_0_0
operator|.
name|getHeadroom
argument_list|()
argument_list|)
expr_stmt|;
comment|// no change
comment|//head room for default label + head room for y partition
comment|//head room for y partition = 100% 50%(b queue capacity ) *  160 * GB
name|Resource
name|expectedHeadroomWithReqInY
init|=
name|Resources
operator|.
name|add
argument_list|(
name|Resources
operator|.
name|createResource
argument_list|(
call|(
name|int
call|)
argument_list|(
literal|0.5
operator|*
literal|160
argument_list|)
operator|*
name|GB
argument_list|,
literal|1
argument_list|)
argument_list|,
name|expectedHeadroom
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|expectedHeadroomWithReqInY
argument_list|,
name|app_0_1
operator|.
name|getHeadroom
argument_list|()
argument_list|)
expr_stmt|;
comment|// Submit first application from user_1, check for new headroom
specifier|final
name|ApplicationAttemptId
name|appAttemptId_1_0
init|=
name|TestUtils
operator|.
name|getMockApplicationAttemptId
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|FiCaSchedulerApp
name|app_1_0
init|=
operator|new
name|FiCaSchedulerApp
argument_list|(
name|appAttemptId_1_0
argument_list|,
name|user_1
argument_list|,
name|queue
argument_list|,
name|queue
operator|.
name|getActiveUsersManager
argument_list|()
argument_list|,
name|spyRMContext
argument_list|)
decl_stmt|;
name|queue
operator|.
name|submitApplicationAttempt
argument_list|(
name|app_1_0
argument_list|,
name|user_1
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ResourceRequest
argument_list|>
name|app_1_0_requests
init|=
operator|new
name|ArrayList
argument_list|<
name|ResourceRequest
argument_list|>
argument_list|()
decl_stmt|;
name|app_1_0_requests
operator|.
name|add
argument_list|(
name|TestUtils
operator|.
name|createResourceRequest
argument_list|(
name|ResourceRequest
operator|.
name|ANY
argument_list|,
literal|1
operator|*
name|GB
argument_list|,
literal|2
argument_list|,
literal|true
argument_list|,
name|priority_1
argument_list|,
name|recordFactory
argument_list|)
argument_list|)
expr_stmt|;
name|app_1_0
operator|.
name|updateResourceRequests
argument_list|(
name|app_1_0_requests
argument_list|)
expr_stmt|;
name|app_1_0_requests
operator|.
name|clear
argument_list|()
expr_stmt|;
name|app_1_0_requests
operator|.
name|add
argument_list|(
name|TestUtils
operator|.
name|createResourceRequest
argument_list|(
name|ResourceRequest
operator|.
name|ANY
argument_list|,
literal|1
operator|*
name|GB
argument_list|,
literal|2
argument_list|,
literal|true
argument_list|,
name|priority_1
argument_list|,
name|recordFactory
argument_list|,
literal|"y"
argument_list|)
argument_list|)
expr_stmt|;
name|app_1_0
operator|.
name|updateResourceRequests
argument_list|(
name|app_1_0_requests
argument_list|)
expr_stmt|;
comment|// Schedule to compute
name|queue
operator|.
name|assignContainers
argument_list|(
name|clusterResource
argument_list|,
name|node_0
argument_list|,
operator|new
name|ResourceLimits
argument_list|(
name|clusterResource
argument_list|)
argument_list|,
name|SchedulingMode
operator|.
name|RESPECT_PARTITION_EXCLUSIVITY
argument_list|)
expr_stmt|;
comment|// Schedule to compute
comment|//head room = queue capacity = (50 % 90% 160 GB)/2 (for 2 users)
name|expectedHeadroom
operator|=
name|Resources
operator|.
name|createResource
argument_list|(
call|(
name|int
call|)
argument_list|(
literal|0.5
operator|*
literal|0.9
operator|*
literal|160
operator|*
literal|0.5
argument_list|)
operator|*
name|GB
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|//head room for default label + head room for y partition
comment|//head room for y partition = 100% 50%(b queue capacity ) *  160 * GB
name|expectedHeadroomWithReqInY
operator|=
name|Resources
operator|.
name|add
argument_list|(
name|Resources
operator|.
name|createResource
argument_list|(
call|(
name|int
call|)
argument_list|(
literal|0.5
operator|*
literal|0.5
operator|*
literal|160
argument_list|)
operator|*
name|GB
argument_list|,
literal|1
argument_list|)
argument_list|,
name|expectedHeadroom
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expectedHeadroom
argument_list|,
name|app_0_0
operator|.
name|getHeadroom
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expectedHeadroomWithReqInY
argument_list|,
name|app_0_1
operator|.
name|getHeadroom
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expectedHeadroomWithReqInY
argument_list|,
name|app_1_0
operator|.
name|getHeadroom
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

