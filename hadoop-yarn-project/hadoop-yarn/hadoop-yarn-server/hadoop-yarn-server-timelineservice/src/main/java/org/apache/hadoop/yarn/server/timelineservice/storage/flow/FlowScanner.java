begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.timelineservice.storage.flow
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|timelineservice
operator|.
name|storage
operator|.
name|flow
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Tag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|coprocessor
operator|.
name|RegionCoprocessorEnvironment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|InternalScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
operator|.
name|ByteArrayComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|timelineservice
operator|.
name|storage
operator|.
name|common
operator|.
name|GenericConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|timelineservice
operator|.
name|storage
operator|.
name|common
operator|.
name|NumericValueConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|timelineservice
operator|.
name|storage
operator|.
name|common
operator|.
name|TimelineStorageUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|timelineservice
operator|.
name|storage
operator|.
name|common
operator|.
name|ValueConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|timelineservice
operator|.
name|storage
operator|.
name|common
operator|.
name|TimestampGenerator
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * Invoked via the coprocessor when a Get or a Scan is issued for flow run  * table. Looks through the list of cells per row, checks their tags and does  * operation on those cells as per the cell tags. Transforms reads of the stored  * metrics into calculated sums for each column Also, finds the min and max for  * start and end times in a flow run.  */
end_comment

begin_class
DECL|class|FlowScanner
class|class
name|FlowScanner
implements|implements
name|RegionScanner
implements|,
name|Closeable
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FlowScanner
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * use a special application id to represent the flow id this is needed since    * TimestampGenerator parses the app id to generate a cell timestamp.    */
DECL|field|FLOW_APP_ID
specifier|private
specifier|static
specifier|final
name|String
name|FLOW_APP_ID
init|=
literal|"application_00000000000_0000"
decl_stmt|;
DECL|field|region
specifier|private
specifier|final
name|HRegion
name|region
decl_stmt|;
DECL|field|flowRunScanner
specifier|private
specifier|final
name|InternalScanner
name|flowRunScanner
decl_stmt|;
DECL|field|limit
specifier|private
specifier|final
name|int
name|limit
decl_stmt|;
DECL|field|appFinalValueRetentionThreshold
specifier|private
specifier|final
name|long
name|appFinalValueRetentionThreshold
decl_stmt|;
DECL|field|regionScanner
specifier|private
name|RegionScanner
name|regionScanner
decl_stmt|;
DECL|field|hasMore
specifier|private
name|boolean
name|hasMore
decl_stmt|;
DECL|field|currentRow
specifier|private
name|byte
index|[]
name|currentRow
decl_stmt|;
DECL|field|availableCells
specifier|private
name|List
argument_list|<
name|Cell
argument_list|>
name|availableCells
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|currentIndex
specifier|private
name|int
name|currentIndex
decl_stmt|;
DECL|field|action
specifier|private
name|FlowScannerOperation
name|action
init|=
name|FlowScannerOperation
operator|.
name|READ
decl_stmt|;
DECL|method|FlowScanner (RegionCoprocessorEnvironment env, int limit, InternalScanner internalScanner, FlowScannerOperation action)
name|FlowScanner
parameter_list|(
name|RegionCoprocessorEnvironment
name|env
parameter_list|,
name|int
name|limit
parameter_list|,
name|InternalScanner
name|internalScanner
parameter_list|,
name|FlowScannerOperation
name|action
parameter_list|)
block|{
name|this
operator|.
name|limit
operator|=
name|limit
expr_stmt|;
name|this
operator|.
name|flowRunScanner
operator|=
name|internalScanner
expr_stmt|;
if|if
condition|(
name|internalScanner
operator|instanceof
name|RegionScanner
condition|)
block|{
name|this
operator|.
name|regionScanner
operator|=
operator|(
name|RegionScanner
operator|)
name|internalScanner
expr_stmt|;
block|}
name|this
operator|.
name|action
operator|=
name|action
expr_stmt|;
if|if
condition|(
name|env
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|appFinalValueRetentionThreshold
operator|=
name|YarnConfiguration
operator|.
name|DEFAULT_APP_FINAL_VALUE_RETENTION_THRESHOLD
expr_stmt|;
name|this
operator|.
name|region
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|region
operator|=
name|env
operator|.
name|getRegion
argument_list|()
expr_stmt|;
name|Configuration
name|hbaseConf
init|=
name|env
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|this
operator|.
name|appFinalValueRetentionThreshold
operator|=
name|hbaseConf
operator|.
name|getLong
argument_list|(
name|YarnConfiguration
operator|.
name|APP_FINAL_VALUE_RETENTION_THRESHOLD
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_APP_FINAL_VALUE_RETENTION_THRESHOLD
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * (non-Javadoc)    *    * @see org.apache.hadoop.hbase.regionserver.RegionScanner#getRegionInfo()    */
annotation|@
name|Override
DECL|method|getRegionInfo ()
specifier|public
name|HRegionInfo
name|getRegionInfo
parameter_list|()
block|{
return|return
name|region
operator|.
name|getRegionInfo
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|nextRaw (List<Cell> cells)
specifier|public
name|boolean
name|nextRaw
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|nextRaw
argument_list|(
name|cells
argument_list|,
name|limit
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|nextRaw (List<Cell> cells, int cellLimit)
specifier|public
name|boolean
name|nextRaw
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
parameter_list|,
name|int
name|cellLimit
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|nextInternal
argument_list|(
name|cells
argument_list|,
name|cellLimit
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|next (List<Cell> cells)
specifier|public
name|boolean
name|next
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|next
argument_list|(
name|cells
argument_list|,
name|limit
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|next (List<Cell> cells, int cellLimit)
specifier|public
name|boolean
name|next
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
parameter_list|,
name|int
name|cellLimit
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|nextInternal
argument_list|(
name|cells
argument_list|,
name|cellLimit
argument_list|)
return|;
block|}
comment|/**    * Get value converter associated with a column or a column prefix. If nothing    * matches, generic converter is returned.    * @param colQualifierBytes    * @return value converter implementation.    */
DECL|method|getValueConverter (byte[] colQualifierBytes)
specifier|private
specifier|static
name|ValueConverter
name|getValueConverter
parameter_list|(
name|byte
index|[]
name|colQualifierBytes
parameter_list|)
block|{
comment|// Iterate over all the column prefixes for flow run table and get the
comment|// appropriate converter for the column qualifier passed if prefix matches.
for|for
control|(
name|FlowRunColumnPrefix
name|colPrefix
range|:
name|FlowRunColumnPrefix
operator|.
name|values
argument_list|()
control|)
block|{
name|byte
index|[]
name|colPrefixBytes
init|=
name|colPrefix
operator|.
name|getColumnPrefixBytes
argument_list|(
literal|""
argument_list|)
decl_stmt|;
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|colPrefixBytes
argument_list|,
literal|0
argument_list|,
name|colPrefixBytes
operator|.
name|length
argument_list|,
name|colQualifierBytes
argument_list|,
literal|0
argument_list|,
name|colPrefixBytes
operator|.
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|colPrefix
operator|.
name|getValueConverter
argument_list|()
return|;
block|}
block|}
comment|// Iterate over all the columns for flow run table and get the
comment|// appropriate converter for the column qualifier passed if match occurs.
for|for
control|(
name|FlowRunColumn
name|column
range|:
name|FlowRunColumn
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|column
operator|.
name|getColumnQualifierBytes
argument_list|()
argument_list|,
name|colQualifierBytes
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|column
operator|.
name|getValueConverter
argument_list|()
return|;
block|}
block|}
comment|// Return generic converter if nothing matches.
return|return
name|GenericConverter
operator|.
name|getInstance
argument_list|()
return|;
block|}
comment|/**    * Checks if the converter is a numeric converter or not. For a converter to    * be numeric, it must implement {@link NumericValueConverter} interface.    * @param converter    * @return true, if converter is of type NumericValueConverter, false    * otherwise.    */
DECL|method|isNumericConverter (ValueConverter converter)
specifier|private
specifier|static
name|boolean
name|isNumericConverter
parameter_list|(
name|ValueConverter
name|converter
parameter_list|)
block|{
return|return
operator|(
name|converter
operator|instanceof
name|NumericValueConverter
operator|)
return|;
block|}
comment|/**    * This method loops through the cells in a given row of the    * {@link FlowRunTable}. It looks at the tags of each cell to figure out how    * to process the contents. It then calculates the sum or min or max for each    * column or returns the cell as is.    *    * @param cells    * @param cellLimit    * @return true if next row is available for the scanner, false otherwise    * @throws IOException    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
DECL|method|nextInternal (List<Cell> cells, int cellLimit)
specifier|private
name|boolean
name|nextInternal
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
parameter_list|,
name|int
name|cellLimit
parameter_list|)
throws|throws
name|IOException
block|{
name|Cell
name|cell
init|=
literal|null
decl_stmt|;
name|startNext
argument_list|()
expr_stmt|;
comment|// Loop through all the cells in this row
comment|// For min/max/metrics we do need to scan the entire set of cells to get the
comment|// right one
comment|// But with flush/compaction, the number of cells being scanned will go down
comment|// cells are grouped per column qualifier then sorted by cell timestamp
comment|// (latest to oldest) per column qualifier
comment|// So all cells in one qualifier come one after the other before we see the
comment|// next column qualifier
name|ByteArrayComparator
name|comp
init|=
operator|new
name|ByteArrayComparator
argument_list|()
decl_stmt|;
name|byte
index|[]
name|currentColumnQualifier
init|=
name|TimelineStorageUtils
operator|.
name|EMPTY_BYTES
decl_stmt|;
name|AggregationOperation
name|currentAggOp
init|=
literal|null
decl_stmt|;
name|SortedSet
argument_list|<
name|Cell
argument_list|>
name|currentColumnCells
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|KeyValue
operator|.
name|COMPARATOR
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|alreadySeenAggDim
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|addedCnt
init|=
literal|0
decl_stmt|;
name|long
name|currentTimestamp
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|ValueConverter
name|converter
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|cellLimit
operator|<=
literal|0
operator|||
name|addedCnt
operator|<
name|cellLimit
condition|)
block|{
name|cell
operator|=
name|peekAtNextCell
argument_list|(
name|cellLimit
argument_list|)
expr_stmt|;
if|if
condition|(
name|cell
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|byte
index|[]
name|newColumnQualifier
init|=
name|CellUtil
operator|.
name|cloneQualifier
argument_list|(
name|cell
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp
operator|.
name|compare
argument_list|(
name|currentColumnQualifier
argument_list|,
name|newColumnQualifier
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|converter
operator|!=
literal|null
operator|&&
name|isNumericConverter
argument_list|(
name|converter
argument_list|)
condition|)
block|{
name|addedCnt
operator|+=
name|emitCells
argument_list|(
name|cells
argument_list|,
name|currentColumnCells
argument_list|,
name|currentAggOp
argument_list|,
operator|(
name|NumericValueConverter
operator|)
name|converter
argument_list|,
name|currentTimestamp
argument_list|)
expr_stmt|;
block|}
name|resetState
argument_list|(
name|currentColumnCells
argument_list|,
name|alreadySeenAggDim
argument_list|)
expr_stmt|;
name|currentColumnQualifier
operator|=
name|newColumnQualifier
expr_stmt|;
name|currentAggOp
operator|=
name|getCurrentAggOp
argument_list|(
name|cell
argument_list|)
expr_stmt|;
name|converter
operator|=
name|getValueConverter
argument_list|(
name|newColumnQualifier
argument_list|)
expr_stmt|;
block|}
comment|// No operation needs to be performed on non numeric converters.
if|if
condition|(
operator|!
name|isNumericConverter
argument_list|(
name|converter
argument_list|)
condition|)
block|{
name|nextCell
argument_list|(
name|cellLimit
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|collectCells
argument_list|(
name|currentColumnCells
argument_list|,
name|currentAggOp
argument_list|,
name|cell
argument_list|,
name|alreadySeenAggDim
argument_list|,
operator|(
name|NumericValueConverter
operator|)
name|converter
argument_list|)
expr_stmt|;
name|nextCell
argument_list|(
name|cellLimit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|currentColumnCells
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|addedCnt
operator|+=
name|emitCells
argument_list|(
name|cells
argument_list|,
name|currentColumnCells
argument_list|,
name|currentAggOp
argument_list|,
operator|(
name|NumericValueConverter
operator|)
name|converter
argument_list|,
name|currentTimestamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|addedCnt
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"emitted cells. "
operator|+
name|addedCnt
operator|+
literal|" for "
operator|+
name|this
operator|.
name|action
operator|+
literal|" rowKey="
operator|+
name|FlowRunRowKey
operator|.
name|parseRowKey
argument_list|(
name|cells
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getRow
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"emitted no cells for "
operator|+
name|this
operator|.
name|action
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|hasMore
argument_list|()
return|;
block|}
DECL|method|getCurrentAggOp (Cell cell)
specifier|private
name|AggregationOperation
name|getCurrentAggOp
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
name|List
argument_list|<
name|Tag
argument_list|>
name|tags
init|=
name|Tag
operator|.
name|asList
argument_list|(
name|cell
operator|.
name|getTagsArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsLength
argument_list|()
argument_list|)
decl_stmt|;
comment|// We assume that all the operations for a particular column are the same
return|return
name|TimelineStorageUtils
operator|.
name|getAggregationOperationFromTagsList
argument_list|(
name|tags
argument_list|)
return|;
block|}
comment|/**    * resets the parameters to an intialized state for next loop iteration.    *    * @param cell    * @param currentAggOp    * @param currentColumnCells    * @param alreadySeenAggDim    * @param collectedButNotEmitted    */
DECL|method|resetState (SortedSet<Cell> currentColumnCells, Set<String> alreadySeenAggDim)
specifier|private
name|void
name|resetState
parameter_list|(
name|SortedSet
argument_list|<
name|Cell
argument_list|>
name|currentColumnCells
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|alreadySeenAggDim
parameter_list|)
block|{
name|currentColumnCells
operator|.
name|clear
argument_list|()
expr_stmt|;
name|alreadySeenAggDim
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|collectCells (SortedSet<Cell> currentColumnCells, AggregationOperation currentAggOp, Cell cell, Set<String> alreadySeenAggDim, NumericValueConverter converter)
specifier|private
name|void
name|collectCells
parameter_list|(
name|SortedSet
argument_list|<
name|Cell
argument_list|>
name|currentColumnCells
parameter_list|,
name|AggregationOperation
name|currentAggOp
parameter_list|,
name|Cell
name|cell
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|alreadySeenAggDim
parameter_list|,
name|NumericValueConverter
name|converter
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentAggOp
operator|==
literal|null
condition|)
block|{
comment|// not a min/max/metric cell, so just return it as is
name|currentColumnCells
operator|.
name|add
argument_list|(
name|cell
argument_list|)
expr_stmt|;
name|nextCell
argument_list|(
name|limit
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|currentAggOp
condition|)
block|{
case|case
name|GLOBAL_MIN
case|:
if|if
condition|(
name|currentColumnCells
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|currentColumnCells
operator|.
name|add
argument_list|(
name|cell
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Cell
name|currentMinCell
init|=
name|currentColumnCells
operator|.
name|first
argument_list|()
decl_stmt|;
name|Cell
name|newMinCell
init|=
name|compareCellValues
argument_list|(
name|currentMinCell
argument_list|,
name|cell
argument_list|,
name|currentAggOp
argument_list|,
name|converter
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|currentMinCell
operator|.
name|equals
argument_list|(
name|newMinCell
argument_list|)
condition|)
block|{
name|currentColumnCells
operator|.
name|remove
argument_list|(
name|currentMinCell
argument_list|)
expr_stmt|;
name|currentColumnCells
operator|.
name|add
argument_list|(
name|newMinCell
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|GLOBAL_MAX
case|:
if|if
condition|(
name|currentColumnCells
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|currentColumnCells
operator|.
name|add
argument_list|(
name|cell
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Cell
name|currentMaxCell
init|=
name|currentColumnCells
operator|.
name|first
argument_list|()
decl_stmt|;
name|Cell
name|newMaxCell
init|=
name|compareCellValues
argument_list|(
name|currentMaxCell
argument_list|,
name|cell
argument_list|,
name|currentAggOp
argument_list|,
name|converter
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|currentMaxCell
operator|.
name|equals
argument_list|(
name|newMaxCell
argument_list|)
condition|)
block|{
name|currentColumnCells
operator|.
name|remove
argument_list|(
name|currentMaxCell
argument_list|)
expr_stmt|;
name|currentColumnCells
operator|.
name|add
argument_list|(
name|newMaxCell
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SUM
case|:
case|case
name|SUM_FINAL
case|:
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"In collect cells "
operator|+
literal|" FlowSannerOperation="
operator|+
name|this
operator|.
name|action
operator|+
literal|" currentAggOp="
operator|+
name|currentAggOp
operator|+
literal|" cell qualifier="
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|CellUtil
operator|.
name|cloneQualifier
argument_list|(
name|cell
argument_list|)
argument_list|)
operator|+
literal|" cell value= "
operator|+
operator|(
name|Number
operator|)
name|converter
operator|.
name|decodeValue
argument_list|(
name|CellUtil
operator|.
name|cloneValue
argument_list|(
name|cell
argument_list|)
argument_list|)
operator|+
literal|" timestamp="
operator|+
name|cell
operator|.
name|getTimestamp
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// only if this app has not been seen yet, add to current column cells
name|List
argument_list|<
name|Tag
argument_list|>
name|tags
init|=
name|Tag
operator|.
name|asList
argument_list|(
name|cell
operator|.
name|getTagsArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsLength
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|aggDim
init|=
name|TimelineStorageUtils
operator|.
name|getAggregationCompactionDimension
argument_list|(
name|tags
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|alreadySeenAggDim
operator|.
name|contains
argument_list|(
name|aggDim
argument_list|)
condition|)
block|{
comment|// if this agg dimension has already been seen,
comment|// since they show up in sorted order
comment|// we drop the rest which are older
comment|// in other words, this cell is older than previously seen cells
comment|// for that agg dim
comment|// but when this agg dim is not seen,
comment|// consider this cell in our working set
name|currentColumnCells
operator|.
name|add
argument_list|(
name|cell
argument_list|)
expr_stmt|;
name|alreadySeenAggDim
operator|.
name|add
argument_list|(
name|aggDim
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
comment|// end of switch case
block|}
comment|/*    * Processes the cells in input param currentColumnCells and populates    * List<Cell> cells as the output based on the input AggregationOperation    * parameter.    */
DECL|method|emitCells (List<Cell> cells, SortedSet<Cell> currentColumnCells, AggregationOperation currentAggOp, NumericValueConverter converter, long currentTimestamp)
specifier|private
name|int
name|emitCells
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
parameter_list|,
name|SortedSet
argument_list|<
name|Cell
argument_list|>
name|currentColumnCells
parameter_list|,
name|AggregationOperation
name|currentAggOp
parameter_list|,
name|NumericValueConverter
name|converter
parameter_list|,
name|long
name|currentTimestamp
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|(
name|currentColumnCells
operator|==
literal|null
operator|)
operator|||
operator|(
name|currentColumnCells
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|currentAggOp
operator|==
literal|null
condition|)
block|{
name|cells
operator|.
name|addAll
argument_list|(
name|currentColumnCells
argument_list|)
expr_stmt|;
return|return
name|currentColumnCells
operator|.
name|size
argument_list|()
return|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"In emitCells "
operator|+
name|this
operator|.
name|action
operator|+
literal|" currentColumnCells size= "
operator|+
name|currentColumnCells
operator|.
name|size
argument_list|()
operator|+
literal|" currentAggOp"
operator|+
name|currentAggOp
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|currentAggOp
condition|)
block|{
case|case
name|GLOBAL_MIN
case|:
case|case
name|GLOBAL_MAX
case|:
name|cells
operator|.
name|addAll
argument_list|(
name|currentColumnCells
argument_list|)
expr_stmt|;
return|return
name|currentColumnCells
operator|.
name|size
argument_list|()
return|;
case|case
name|SUM
case|:
case|case
name|SUM_FINAL
case|:
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|FLUSH
case|:
case|case
name|MINOR_COMPACTION
case|:
name|cells
operator|.
name|addAll
argument_list|(
name|currentColumnCells
argument_list|)
expr_stmt|;
return|return
name|currentColumnCells
operator|.
name|size
argument_list|()
return|;
case|case
name|READ
case|:
name|Cell
name|sumCell
init|=
name|processSummation
argument_list|(
name|currentColumnCells
argument_list|,
name|converter
argument_list|)
decl_stmt|;
name|cells
operator|.
name|add
argument_list|(
name|sumCell
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|MAJOR_COMPACTION
case|:
name|List
argument_list|<
name|Cell
argument_list|>
name|finalCells
init|=
name|processSummationMajorCompaction
argument_list|(
name|currentColumnCells
argument_list|,
name|converter
argument_list|,
name|currentTimestamp
argument_list|)
decl_stmt|;
name|cells
operator|.
name|addAll
argument_list|(
name|finalCells
argument_list|)
expr_stmt|;
return|return
name|finalCells
operator|.
name|size
argument_list|()
return|;
default|default:
name|cells
operator|.
name|addAll
argument_list|(
name|currentColumnCells
argument_list|)
expr_stmt|;
return|return
name|currentColumnCells
operator|.
name|size
argument_list|()
return|;
block|}
default|default:
name|cells
operator|.
name|addAll
argument_list|(
name|currentColumnCells
argument_list|)
expr_stmt|;
return|return
name|currentColumnCells
operator|.
name|size
argument_list|()
return|;
block|}
block|}
comment|/*    * Returns a cell whose value is the sum of all cell values in the input set.    * The new cell created has the timestamp of the most recent metric cell. The    * sum of a metric for a flow run is the summation at the point of the last    * metric update in that flow till that time.    */
DECL|method|processSummation (SortedSet<Cell> currentColumnCells, NumericValueConverter converter)
specifier|private
name|Cell
name|processSummation
parameter_list|(
name|SortedSet
argument_list|<
name|Cell
argument_list|>
name|currentColumnCells
parameter_list|,
name|NumericValueConverter
name|converter
parameter_list|)
throws|throws
name|IOException
block|{
name|Number
name|sum
init|=
literal|0
decl_stmt|;
name|Number
name|currentValue
init|=
literal|0
decl_stmt|;
name|long
name|ts
init|=
literal|0L
decl_stmt|;
name|long
name|mostCurrentTimestamp
init|=
literal|0L
decl_stmt|;
name|Cell
name|mostRecentCell
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Cell
name|cell
range|:
name|currentColumnCells
control|)
block|{
name|currentValue
operator|=
operator|(
name|Number
operator|)
name|converter
operator|.
name|decodeValue
argument_list|(
name|CellUtil
operator|.
name|cloneValue
argument_list|(
name|cell
argument_list|)
argument_list|)
expr_stmt|;
name|ts
operator|=
name|cell
operator|.
name|getTimestamp
argument_list|()
expr_stmt|;
if|if
condition|(
name|mostCurrentTimestamp
operator|<
name|ts
condition|)
block|{
name|mostCurrentTimestamp
operator|=
name|ts
expr_stmt|;
name|mostRecentCell
operator|=
name|cell
expr_stmt|;
block|}
name|sum
operator|=
name|converter
operator|.
name|add
argument_list|(
name|sum
argument_list|,
name|currentValue
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|sumBytes
init|=
name|converter
operator|.
name|encodeValue
argument_list|(
name|sum
argument_list|)
decl_stmt|;
name|Cell
name|sumCell
init|=
name|TimelineStorageUtils
operator|.
name|createNewCell
argument_list|(
name|mostRecentCell
argument_list|,
name|sumBytes
argument_list|)
decl_stmt|;
return|return
name|sumCell
return|;
block|}
comment|/**    * Returns a list of cells that contains    *    * A) the latest cells for applications that haven't finished yet    * B) summation    * for the flow, based on applications that have completed and are older than    * a certain time    *    * The new cell created has the timestamp of the most recent metric cell. The    * sum of a metric for a flow run is the summation at the point of the last    * metric update in that flow till that time.    */
annotation|@
name|VisibleForTesting
DECL|method|processSummationMajorCompaction ( SortedSet<Cell> currentColumnCells, NumericValueConverter converter, long currentTimestamp)
name|List
argument_list|<
name|Cell
argument_list|>
name|processSummationMajorCompaction
parameter_list|(
name|SortedSet
argument_list|<
name|Cell
argument_list|>
name|currentColumnCells
parameter_list|,
name|NumericValueConverter
name|converter
parameter_list|,
name|long
name|currentTimestamp
parameter_list|)
throws|throws
name|IOException
block|{
name|Number
name|sum
init|=
literal|0
decl_stmt|;
name|Number
name|currentValue
init|=
literal|0
decl_stmt|;
name|long
name|ts
init|=
literal|0L
decl_stmt|;
name|boolean
name|summationDone
init|=
literal|false
decl_stmt|;
name|List
argument_list|<
name|Cell
argument_list|>
name|finalCells
init|=
operator|new
name|ArrayList
argument_list|<
name|Cell
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentColumnCells
operator|==
literal|null
condition|)
block|{
return|return
name|finalCells
return|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"In processSummationMajorCompaction,"
operator|+
literal|" will drop cells older than "
operator|+
name|currentTimestamp
operator|+
literal|" CurrentColumnCells size="
operator|+
name|currentColumnCells
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Cell
name|cell
range|:
name|currentColumnCells
control|)
block|{
name|AggregationOperation
name|cellAggOp
init|=
name|getCurrentAggOp
argument_list|(
name|cell
argument_list|)
decl_stmt|;
comment|// if this is the existing flow sum cell
name|List
argument_list|<
name|Tag
argument_list|>
name|tags
init|=
name|Tag
operator|.
name|asList
argument_list|(
name|cell
operator|.
name|getTagsArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsLength
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|appId
init|=
name|TimelineStorageUtils
operator|.
name|getAggregationCompactionDimension
argument_list|(
name|tags
argument_list|)
decl_stmt|;
if|if
condition|(
name|appId
operator|==
name|FLOW_APP_ID
condition|)
block|{
name|sum
operator|=
name|converter
operator|.
name|add
argument_list|(
name|sum
argument_list|,
name|currentValue
argument_list|)
expr_stmt|;
name|summationDone
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"reading flow app id sum="
operator|+
name|sum
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|currentValue
operator|=
operator|(
name|Number
operator|)
name|converter
operator|.
name|decodeValue
argument_list|(
name|CellUtil
operator|.
name|cloneValue
argument_list|(
name|cell
argument_list|)
argument_list|)
expr_stmt|;
comment|// read the timestamp truncated by the generator
name|ts
operator|=
name|TimestampGenerator
operator|.
name|getTruncatedTimestamp
argument_list|(
name|cell
operator|.
name|getTimestamp
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cellAggOp
operator|==
name|AggregationOperation
operator|.
name|SUM_FINAL
operator|)
operator|&&
operator|(
operator|(
name|ts
operator|+
name|this
operator|.
name|appFinalValueRetentionThreshold
operator|)
operator|<
name|currentTimestamp
operator|)
condition|)
block|{
name|sum
operator|=
name|converter
operator|.
name|add
argument_list|(
name|sum
argument_list|,
name|currentValue
argument_list|)
expr_stmt|;
name|summationDone
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"MAJOR COMPACTION loop sum= "
operator|+
name|sum
operator|+
literal|" discarding now: "
operator|+
literal|" qualifier="
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|CellUtil
operator|.
name|cloneQualifier
argument_list|(
name|cell
argument_list|)
argument_list|)
operator|+
literal|" value="
operator|+
operator|(
name|Number
operator|)
name|converter
operator|.
name|decodeValue
argument_list|(
name|CellUtil
operator|.
name|cloneValue
argument_list|(
name|cell
argument_list|)
argument_list|)
operator|+
literal|" timestamp="
operator|+
name|cell
operator|.
name|getTimestamp
argument_list|()
operator|+
literal|" "
operator|+
name|this
operator|.
name|action
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// not a final value but it's the latest cell for this app
comment|// so include this cell in the list of cells to write back
name|finalCells
operator|.
name|add
argument_list|(
name|cell
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|summationDone
condition|)
block|{
name|Cell
name|anyCell
init|=
name|currentColumnCells
operator|.
name|first
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Tag
argument_list|>
name|tags
init|=
operator|new
name|ArrayList
argument_list|<
name|Tag
argument_list|>
argument_list|()
decl_stmt|;
name|Tag
name|t
init|=
operator|new
name|Tag
argument_list|(
name|AggregationOperation
operator|.
name|SUM_FINAL
operator|.
name|getTagType
argument_list|()
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|FLOW_APP_ID
argument_list|)
argument_list|)
decl_stmt|;
name|tags
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
operator|new
name|Tag
argument_list|(
name|AggregationCompactionDimension
operator|.
name|APPLICATION_ID
operator|.
name|getTagType
argument_list|()
argument_list|,
name|Bytes
operator|.
name|toBytes
argument_list|(
name|FLOW_APP_ID
argument_list|)
argument_list|)
expr_stmt|;
name|tags
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|byte
index|[]
name|tagByteArray
init|=
name|Tag
operator|.
name|fromList
argument_list|(
name|tags
argument_list|)
decl_stmt|;
name|Cell
name|sumCell
init|=
name|TimelineStorageUtils
operator|.
name|createNewCell
argument_list|(
name|CellUtil
operator|.
name|cloneRow
argument_list|(
name|anyCell
argument_list|)
argument_list|,
name|CellUtil
operator|.
name|cloneFamily
argument_list|(
name|anyCell
argument_list|)
argument_list|,
name|CellUtil
operator|.
name|cloneQualifier
argument_list|(
name|anyCell
argument_list|)
argument_list|,
name|TimestampGenerator
operator|.
name|getSupplementedTimestamp
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
name|FLOW_APP_ID
argument_list|)
argument_list|,
name|converter
operator|.
name|encodeValue
argument_list|(
name|sum
argument_list|)
argument_list|,
name|tagByteArray
argument_list|)
decl_stmt|;
name|finalCells
operator|.
name|add
argument_list|(
name|sumCell
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"MAJOR COMPACTION final sum= "
operator|+
name|sum
operator|+
literal|" for "
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|CellUtil
operator|.
name|cloneQualifier
argument_list|(
name|sumCell
argument_list|)
argument_list|)
operator|+
literal|" "
operator|+
name|this
operator|.
name|action
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"After major compaction for qualifier="
operator|+
name|Bytes
operator|.
name|toString
argument_list|(
name|CellUtil
operator|.
name|cloneQualifier
argument_list|(
name|sumCell
argument_list|)
argument_list|)
operator|+
literal|" with currentColumnCells.size="
operator|+
name|currentColumnCells
operator|.
name|size
argument_list|()
operator|+
literal|" returning finalCells.size="
operator|+
name|finalCells
operator|.
name|size
argument_list|()
operator|+
literal|" with sum="
operator|+
name|sum
operator|.
name|longValue
argument_list|()
operator|+
literal|" with cell timestamp "
operator|+
name|sumCell
operator|.
name|getTimestamp
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|qualifier
init|=
literal|""
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"After major compaction for qualifier="
operator|+
name|qualifier
operator|+
literal|" with currentColumnCells.size="
operator|+
name|currentColumnCells
operator|.
name|size
argument_list|()
operator|+
literal|" returning finalCells.size="
operator|+
name|finalCells
operator|.
name|size
argument_list|()
operator|+
literal|" with zero sum="
operator|+
name|sum
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|finalCells
return|;
block|}
comment|/**    * Determines which cell is to be returned based on the values in each cell    * and the comparison operation MIN or MAX.    *    * @param previouslyChosenCell    * @param currentCell    * @param currentAggOp    * @return the cell which is the min (or max) cell    * @throws IOException    */
DECL|method|compareCellValues (Cell previouslyChosenCell, Cell currentCell, AggregationOperation currentAggOp, NumericValueConverter converter)
specifier|private
name|Cell
name|compareCellValues
parameter_list|(
name|Cell
name|previouslyChosenCell
parameter_list|,
name|Cell
name|currentCell
parameter_list|,
name|AggregationOperation
name|currentAggOp
parameter_list|,
name|NumericValueConverter
name|converter
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|previouslyChosenCell
operator|==
literal|null
condition|)
block|{
return|return
name|currentCell
return|;
block|}
try|try
block|{
name|Number
name|previouslyChosenCellValue
init|=
operator|(
name|Number
operator|)
name|converter
operator|.
name|decodeValue
argument_list|(
name|CellUtil
operator|.
name|cloneValue
argument_list|(
name|previouslyChosenCell
argument_list|)
argument_list|)
decl_stmt|;
name|Number
name|currentCellValue
init|=
operator|(
name|Number
operator|)
name|converter
operator|.
name|decodeValue
argument_list|(
name|CellUtil
operator|.
name|cloneValue
argument_list|(
name|currentCell
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|currentAggOp
condition|)
block|{
case|case
name|GLOBAL_MIN
case|:
if|if
condition|(
name|converter
operator|.
name|compare
argument_list|(
name|currentCellValue
argument_list|,
name|previouslyChosenCellValue
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// new value is minimum, hence return this cell
return|return
name|currentCell
return|;
block|}
else|else
block|{
comment|// previously chosen value is miniumum, hence return previous min cell
return|return
name|previouslyChosenCell
return|;
block|}
case|case
name|GLOBAL_MAX
case|:
if|if
condition|(
name|converter
operator|.
name|compare
argument_list|(
name|currentCellValue
argument_list|,
name|previouslyChosenCellValue
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|// new value is max, hence return this cell
return|return
name|currentCell
return|;
block|}
else|else
block|{
comment|// previously chosen value is max, hence return previous max cell
return|return
name|previouslyChosenCell
return|;
block|}
default|default:
return|return
name|currentCell
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"caught iae during conversion to long "
argument_list|,
name|iae
argument_list|)
expr_stmt|;
return|return
name|currentCell
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|flowRunScanner
operator|!=
literal|null
condition|)
block|{
name|flowRunScanner
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"scanner close called but scanner is null"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Called to signal the start of the next() call by the scanner.    */
DECL|method|startNext ()
specifier|public
name|void
name|startNext
parameter_list|()
block|{
name|currentRow
operator|=
literal|null
expr_stmt|;
block|}
comment|/**    * Returns whether or not the underlying scanner has more rows.    */
DECL|method|hasMore ()
specifier|public
name|boolean
name|hasMore
parameter_list|()
block|{
return|return
name|currentIndex
operator|<
name|availableCells
operator|.
name|size
argument_list|()
condition|?
literal|true
else|:
name|hasMore
return|;
block|}
comment|/**    * Returns the next available cell for the current row and advances the    * pointer to the next cell. This method can be called multiple times in a row    * to advance through all the available cells.    *    * @param cellLimit    *          the limit of number of cells to return if the next batch must be    *          fetched by the wrapped scanner    * @return the next available cell or null if no more cells are available for    *         the current row    * @throws IOException    */
DECL|method|nextCell (int cellLimit)
specifier|public
name|Cell
name|nextCell
parameter_list|(
name|int
name|cellLimit
parameter_list|)
throws|throws
name|IOException
block|{
name|Cell
name|cell
init|=
name|peekAtNextCell
argument_list|(
name|cellLimit
argument_list|)
decl_stmt|;
if|if
condition|(
name|cell
operator|!=
literal|null
condition|)
block|{
name|currentIndex
operator|++
expr_stmt|;
block|}
return|return
name|cell
return|;
block|}
comment|/**    * Returns the next available cell for the current row, without advancing the    * pointer. Calling this method multiple times in a row will continue to    * return the same cell.    *    * @param cellLimit    *          the limit of number of cells to return if the next batch must be    *          fetched by the wrapped scanner    * @return the next available cell or null if no more cells are available for    *         the current row    * @throws IOException if any problem is encountered while grabbing the next    *     cell.    */
DECL|method|peekAtNextCell (int cellLimit)
specifier|public
name|Cell
name|peekAtNextCell
parameter_list|(
name|int
name|cellLimit
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentIndex
operator|>=
name|availableCells
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// done with current batch
name|availableCells
operator|.
name|clear
argument_list|()
expr_stmt|;
name|currentIndex
operator|=
literal|0
expr_stmt|;
name|hasMore
operator|=
name|flowRunScanner
operator|.
name|next
argument_list|(
name|availableCells
argument_list|,
name|cellLimit
argument_list|)
expr_stmt|;
block|}
name|Cell
name|cell
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|currentIndex
operator|<
name|availableCells
operator|.
name|size
argument_list|()
condition|)
block|{
name|cell
operator|=
name|availableCells
operator|.
name|get
argument_list|(
name|currentIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentRow
operator|==
literal|null
condition|)
block|{
name|currentRow
operator|=
name|CellUtil
operator|.
name|cloneRow
argument_list|(
name|cell
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|CellUtil
operator|.
name|matchingRow
argument_list|(
name|cell
argument_list|,
name|currentRow
argument_list|)
condition|)
block|{
comment|// moved on to the next row
comment|// don't use the current cell
comment|// also signal no more cells for this row
return|return
literal|null
return|;
block|}
block|}
return|return
name|cell
return|;
block|}
comment|/*    * (non-Javadoc)    *    * @see org.apache.hadoop.hbase.regionserver.RegionScanner#getMaxResultSize()    */
annotation|@
name|Override
DECL|method|getMaxResultSize ()
specifier|public
name|long
name|getMaxResultSize
parameter_list|()
block|{
if|if
condition|(
name|regionScanner
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"RegionScanner.isFilterDone() called when the flow "
operator|+
literal|"scanner's scanner is not a RegionScanner"
argument_list|)
throw|;
block|}
return|return
name|regionScanner
operator|.
name|getMaxResultSize
argument_list|()
return|;
block|}
comment|/*    * (non-Javadoc)    *    * @see org.apache.hadoop.hbase.regionserver.RegionScanner#getMvccReadPoint()    */
annotation|@
name|Override
DECL|method|getMvccReadPoint ()
specifier|public
name|long
name|getMvccReadPoint
parameter_list|()
block|{
if|if
condition|(
name|regionScanner
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"RegionScanner.isFilterDone() called when the flow "
operator|+
literal|"scanner's internal scanner is not a RegionScanner"
argument_list|)
throw|;
block|}
return|return
name|regionScanner
operator|.
name|getMvccReadPoint
argument_list|()
return|;
block|}
comment|/*    * (non-Javadoc)    *    * @see org.apache.hadoop.hbase.regionserver.RegionScanner#isFilterDone()    */
annotation|@
name|Override
DECL|method|isFilterDone ()
specifier|public
name|boolean
name|isFilterDone
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|regionScanner
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"RegionScanner.isFilterDone() called when the flow "
operator|+
literal|"scanner's internal scanner is not a RegionScanner"
argument_list|)
throw|;
block|}
return|return
name|regionScanner
operator|.
name|isFilterDone
argument_list|()
return|;
block|}
comment|/*    * (non-Javadoc)    *    * @see org.apache.hadoop.hbase.regionserver.RegionScanner#reseek(byte[])    */
annotation|@
name|Override
DECL|method|reseek (byte[] bytes)
specifier|public
name|boolean
name|reseek
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|regionScanner
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"RegionScanner.reseek() called when the flow "
operator|+
literal|"scanner's internal scanner is not a RegionScanner"
argument_list|)
throw|;
block|}
return|return
name|regionScanner
operator|.
name|reseek
argument_list|(
name|bytes
argument_list|)
return|;
block|}
block|}
end_class

end_unit

