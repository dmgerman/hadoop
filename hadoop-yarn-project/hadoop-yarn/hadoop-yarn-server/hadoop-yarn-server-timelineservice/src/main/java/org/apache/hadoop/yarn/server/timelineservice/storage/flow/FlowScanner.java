begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.timelineservice.storage.flow
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|timelineservice
operator|.
name|storage
operator|.
name|flow
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Cell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|CellUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|HRegionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|KeyValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|Tag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|HRegion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|InternalScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|regionserver
operator|.
name|RegionScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hbase
operator|.
name|util
operator|.
name|Bytes
operator|.
name|ByteArrayComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|timelineservice
operator|.
name|storage
operator|.
name|common
operator|.
name|GenericConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|timelineservice
operator|.
name|storage
operator|.
name|common
operator|.
name|NumericValueConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|timelineservice
operator|.
name|storage
operator|.
name|common
operator|.
name|TimelineStorageUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|timelineservice
operator|.
name|storage
operator|.
name|common
operator|.
name|ValueConverter
import|;
end_import

begin_comment
comment|/**  * Invoked via the coprocessor when a Get or a Scan is issued for flow run  * table. Looks through the list of cells per row, checks their tags and does  * operation on those cells as per the cell tags. Transforms reads of the stored  * metrics into calculated sums for each column Also, finds the min and max for  * start and end times in a flow run.  */
end_comment

begin_class
DECL|class|FlowScanner
class|class
name|FlowScanner
implements|implements
name|RegionScanner
implements|,
name|Closeable
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FlowScanner
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|region
specifier|private
specifier|final
name|HRegion
name|region
decl_stmt|;
DECL|field|flowRunScanner
specifier|private
specifier|final
name|InternalScanner
name|flowRunScanner
decl_stmt|;
DECL|field|regionScanner
specifier|private
name|RegionScanner
name|regionScanner
decl_stmt|;
DECL|field|limit
specifier|private
specifier|final
name|int
name|limit
decl_stmt|;
DECL|field|hasMore
specifier|private
name|boolean
name|hasMore
decl_stmt|;
DECL|field|currentRow
specifier|private
name|byte
index|[]
name|currentRow
decl_stmt|;
DECL|field|availableCells
specifier|private
name|List
argument_list|<
name|Cell
argument_list|>
name|availableCells
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|currentIndex
specifier|private
name|int
name|currentIndex
decl_stmt|;
DECL|method|FlowScanner (HRegion region, int limit, InternalScanner internalScanner)
name|FlowScanner
parameter_list|(
name|HRegion
name|region
parameter_list|,
name|int
name|limit
parameter_list|,
name|InternalScanner
name|internalScanner
parameter_list|)
block|{
name|this
operator|.
name|region
operator|=
name|region
expr_stmt|;
name|this
operator|.
name|limit
operator|=
name|limit
expr_stmt|;
name|this
operator|.
name|flowRunScanner
operator|=
name|internalScanner
expr_stmt|;
if|if
condition|(
name|internalScanner
operator|instanceof
name|RegionScanner
condition|)
block|{
name|this
operator|.
name|regionScanner
operator|=
operator|(
name|RegionScanner
operator|)
name|internalScanner
expr_stmt|;
block|}
comment|// TODO: note if it's compaction/flush
block|}
comment|/*    * (non-Javadoc)    *    * @see org.apache.hadoop.hbase.regionserver.RegionScanner#getRegionInfo()    */
annotation|@
name|Override
DECL|method|getRegionInfo ()
specifier|public
name|HRegionInfo
name|getRegionInfo
parameter_list|()
block|{
return|return
name|region
operator|.
name|getRegionInfo
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|nextRaw (List<Cell> cells)
specifier|public
name|boolean
name|nextRaw
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|nextRaw
argument_list|(
name|cells
argument_list|,
name|limit
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|nextRaw (List<Cell> cells, int cellLimit)
specifier|public
name|boolean
name|nextRaw
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
parameter_list|,
name|int
name|cellLimit
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|nextInternal
argument_list|(
name|cells
argument_list|,
name|cellLimit
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|next (List<Cell> cells)
specifier|public
name|boolean
name|next
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|next
argument_list|(
name|cells
argument_list|,
name|limit
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|next (List<Cell> cells, int cellLimit)
specifier|public
name|boolean
name|next
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
parameter_list|,
name|int
name|cellLimit
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|nextInternal
argument_list|(
name|cells
argument_list|,
name|cellLimit
argument_list|)
return|;
block|}
DECL|method|getAggregationCompactionDimension (List<Tag> tags)
specifier|private
name|String
name|getAggregationCompactionDimension
parameter_list|(
name|List
argument_list|<
name|Tag
argument_list|>
name|tags
parameter_list|)
block|{
name|String
name|appId
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Tag
name|t
range|:
name|tags
control|)
block|{
if|if
condition|(
name|AggregationCompactionDimension
operator|.
name|APPLICATION_ID
operator|.
name|getTagType
argument_list|()
operator|==
name|t
operator|.
name|getType
argument_list|()
condition|)
block|{
name|appId
operator|=
name|Bytes
operator|.
name|toString
argument_list|(
name|t
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|appId
return|;
block|}
comment|/**    * Get value converter associated with a column or a column prefix. If nothing    * matches, generic converter is returned.    * @param colQualifierBytes    * @return value converter implementation.    */
DECL|method|getValueConverter (byte[] colQualifierBytes)
specifier|private
specifier|static
name|ValueConverter
name|getValueConverter
parameter_list|(
name|byte
index|[]
name|colQualifierBytes
parameter_list|)
block|{
comment|// Iterate over all the column prefixes for flow run table and get the
comment|// appropriate converter for the column qualifier passed if prefix matches.
for|for
control|(
name|FlowRunColumnPrefix
name|colPrefix
range|:
name|FlowRunColumnPrefix
operator|.
name|values
argument_list|()
control|)
block|{
name|byte
index|[]
name|colPrefixBytes
init|=
name|colPrefix
operator|.
name|getColumnPrefixBytes
argument_list|(
literal|""
argument_list|)
decl_stmt|;
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|colPrefixBytes
argument_list|,
literal|0
argument_list|,
name|colPrefixBytes
operator|.
name|length
argument_list|,
name|colQualifierBytes
argument_list|,
literal|0
argument_list|,
name|colPrefixBytes
operator|.
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|colPrefix
operator|.
name|getValueConverter
argument_list|()
return|;
block|}
block|}
comment|// Iterate over all the columns for flow run table and get the
comment|// appropriate converter for the column qualifier passed if match occurs.
for|for
control|(
name|FlowRunColumn
name|column
range|:
name|FlowRunColumn
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|Bytes
operator|.
name|compareTo
argument_list|(
name|column
operator|.
name|getColumnQualifierBytes
argument_list|()
argument_list|,
name|colQualifierBytes
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|column
operator|.
name|getValueConverter
argument_list|()
return|;
block|}
block|}
comment|// Return generic converter if nothing matches.
return|return
name|GenericConverter
operator|.
name|getInstance
argument_list|()
return|;
block|}
comment|/**    * Checks if the converter is a numeric converter or not. For a converter to    * be numeric, it must implement {@link NumericValueConverter} interface.    * @param converter    * @return true, if converter is of type NumericValueConverter, false    * otherwise.    */
DECL|method|isNumericConverter (ValueConverter converter)
specifier|private
specifier|static
name|boolean
name|isNumericConverter
parameter_list|(
name|ValueConverter
name|converter
parameter_list|)
block|{
return|return
operator|(
name|converter
operator|instanceof
name|NumericValueConverter
operator|)
return|;
block|}
comment|/**    * This method loops through the cells in a given row of the    * {@link FlowRunTable}. It looks at the tags of each cell to figure out how    * to process the contents. It then calculates the sum or min or max for each    * column or returns the cell as is.    *    * @param cells    * @param cellLimit    * @return true if next row is available for the scanner, false otherwise    * @throws IOException    */
DECL|method|nextInternal (List<Cell> cells, int cellLimit)
specifier|private
name|boolean
name|nextInternal
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
parameter_list|,
name|int
name|cellLimit
parameter_list|)
throws|throws
name|IOException
block|{
name|Cell
name|cell
init|=
literal|null
decl_stmt|;
name|startNext
argument_list|()
expr_stmt|;
comment|// Loop through all the cells in this row
comment|// For min/max/metrics we do need to scan the entire set of cells to get the
comment|// right one
comment|// But with flush/compaction, the number of cells being scanned will go down
comment|// cells are grouped per column qualifier then sorted by cell timestamp
comment|// (latest to oldest) per column qualifier
comment|// So all cells in one qualifier come one after the other before we see the
comment|// next column qualifier
name|ByteArrayComparator
name|comp
init|=
operator|new
name|ByteArrayComparator
argument_list|()
decl_stmt|;
name|byte
index|[]
name|currentColumnQualifier
init|=
name|TimelineStorageUtils
operator|.
name|EMPTY_BYTES
decl_stmt|;
name|AggregationOperation
name|currentAggOp
init|=
literal|null
decl_stmt|;
name|SortedSet
argument_list|<
name|Cell
argument_list|>
name|currentColumnCells
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|KeyValue
operator|.
name|COMPARATOR
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|alreadySeenAggDim
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|addedCnt
init|=
literal|0
decl_stmt|;
name|ValueConverter
name|converter
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|cell
operator|=
name|peekAtNextCell
argument_list|(
name|cellLimit
argument_list|)
operator|)
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|cellLimit
operator|<=
literal|0
operator|||
name|addedCnt
operator|<
name|cellLimit
operator|)
condition|)
block|{
name|byte
index|[]
name|newColumnQualifier
init|=
name|CellUtil
operator|.
name|cloneQualifier
argument_list|(
name|cell
argument_list|)
decl_stmt|;
if|if
condition|(
name|comp
operator|.
name|compare
argument_list|(
name|currentColumnQualifier
argument_list|,
name|newColumnQualifier
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|converter
operator|!=
literal|null
operator|&&
name|isNumericConverter
argument_list|(
name|converter
argument_list|)
condition|)
block|{
name|addedCnt
operator|+=
name|emitCells
argument_list|(
name|cells
argument_list|,
name|currentColumnCells
argument_list|,
name|currentAggOp
argument_list|,
operator|(
name|NumericValueConverter
operator|)
name|converter
argument_list|)
expr_stmt|;
block|}
name|resetState
argument_list|(
name|currentColumnCells
argument_list|,
name|alreadySeenAggDim
argument_list|)
expr_stmt|;
name|currentColumnQualifier
operator|=
name|newColumnQualifier
expr_stmt|;
name|currentAggOp
operator|=
name|getCurrentAggOp
argument_list|(
name|cell
argument_list|)
expr_stmt|;
name|converter
operator|=
name|getValueConverter
argument_list|(
name|newColumnQualifier
argument_list|)
expr_stmt|;
block|}
comment|// No operation needs to be performed on non numeric converters.
if|if
condition|(
operator|!
name|isNumericConverter
argument_list|(
name|converter
argument_list|)
condition|)
block|{
name|nextCell
argument_list|(
name|cellLimit
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|collectCells
argument_list|(
name|currentColumnCells
argument_list|,
name|currentAggOp
argument_list|,
name|cell
argument_list|,
name|alreadySeenAggDim
argument_list|,
operator|(
name|NumericValueConverter
operator|)
name|converter
argument_list|)
expr_stmt|;
name|nextCell
argument_list|(
name|cellLimit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|currentColumnCells
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|emitCells
argument_list|(
name|cells
argument_list|,
name|currentColumnCells
argument_list|,
name|currentAggOp
argument_list|,
operator|(
name|NumericValueConverter
operator|)
name|converter
argument_list|)
expr_stmt|;
block|}
return|return
name|hasMore
argument_list|()
return|;
block|}
DECL|method|getCurrentAggOp (Cell cell)
specifier|private
name|AggregationOperation
name|getCurrentAggOp
parameter_list|(
name|Cell
name|cell
parameter_list|)
block|{
name|List
argument_list|<
name|Tag
argument_list|>
name|tags
init|=
name|Tag
operator|.
name|asList
argument_list|(
name|cell
operator|.
name|getTagsArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsLength
argument_list|()
argument_list|)
decl_stmt|;
comment|// We assume that all the operations for a particular column are the same
return|return
name|TimelineStorageUtils
operator|.
name|getAggregationOperationFromTagsList
argument_list|(
name|tags
argument_list|)
return|;
block|}
comment|/**    * resets the parameters to an intialized state for next loop iteration.    *    * @param cell    * @param currentAggOp    * @param currentColumnCells    * @param alreadySeenAggDim    * @param collectedButNotEmitted    */
DECL|method|resetState (SortedSet<Cell> currentColumnCells, Set<String> alreadySeenAggDim)
specifier|private
name|void
name|resetState
parameter_list|(
name|SortedSet
argument_list|<
name|Cell
argument_list|>
name|currentColumnCells
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|alreadySeenAggDim
parameter_list|)
block|{
name|currentColumnCells
operator|.
name|clear
argument_list|()
expr_stmt|;
name|alreadySeenAggDim
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|collectCells (SortedSet<Cell> currentColumnCells, AggregationOperation currentAggOp, Cell cell, Set<String> alreadySeenAggDim, NumericValueConverter converter)
specifier|private
name|void
name|collectCells
parameter_list|(
name|SortedSet
argument_list|<
name|Cell
argument_list|>
name|currentColumnCells
parameter_list|,
name|AggregationOperation
name|currentAggOp
parameter_list|,
name|Cell
name|cell
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|alreadySeenAggDim
parameter_list|,
name|NumericValueConverter
name|converter
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentAggOp
operator|==
literal|null
condition|)
block|{
comment|// not a min/max/metric cell, so just return it as is
name|currentColumnCells
operator|.
name|add
argument_list|(
name|cell
argument_list|)
expr_stmt|;
name|nextCell
argument_list|(
name|limit
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|currentAggOp
condition|)
block|{
case|case
name|MIN
case|:
if|if
condition|(
name|currentColumnCells
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|currentColumnCells
operator|.
name|add
argument_list|(
name|cell
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Cell
name|currentMinCell
init|=
name|currentColumnCells
operator|.
name|first
argument_list|()
decl_stmt|;
name|Cell
name|newMinCell
init|=
name|compareCellValues
argument_list|(
name|currentMinCell
argument_list|,
name|cell
argument_list|,
name|currentAggOp
argument_list|,
name|converter
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|currentMinCell
operator|.
name|equals
argument_list|(
name|newMinCell
argument_list|)
condition|)
block|{
name|currentColumnCells
operator|.
name|remove
argument_list|(
name|currentMinCell
argument_list|)
expr_stmt|;
name|currentColumnCells
operator|.
name|add
argument_list|(
name|newMinCell
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|MAX
case|:
if|if
condition|(
name|currentColumnCells
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|currentColumnCells
operator|.
name|add
argument_list|(
name|cell
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Cell
name|currentMaxCell
init|=
name|currentColumnCells
operator|.
name|first
argument_list|()
decl_stmt|;
name|Cell
name|newMaxCell
init|=
name|compareCellValues
argument_list|(
name|currentMaxCell
argument_list|,
name|cell
argument_list|,
name|currentAggOp
argument_list|,
name|converter
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|currentMaxCell
operator|.
name|equals
argument_list|(
name|newMaxCell
argument_list|)
condition|)
block|{
name|currentColumnCells
operator|.
name|remove
argument_list|(
name|currentMaxCell
argument_list|)
expr_stmt|;
name|currentColumnCells
operator|.
name|add
argument_list|(
name|newMaxCell
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SUM
case|:
case|case
name|SUM_FINAL
case|:
comment|// only if this app has not been seen yet, add to current column cells
name|List
argument_list|<
name|Tag
argument_list|>
name|tags
init|=
name|Tag
operator|.
name|asList
argument_list|(
name|cell
operator|.
name|getTagsArray
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsOffset
argument_list|()
argument_list|,
name|cell
operator|.
name|getTagsLength
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|aggDim
init|=
name|getAggregationCompactionDimension
argument_list|(
name|tags
argument_list|)
decl_stmt|;
comment|// If this agg dimension has already been seen, since they show up in
comment|// sorted order, we drop the rest which are older. In other words, this
comment|// cell is older than previously seen cells for that agg dim.
if|if
condition|(
operator|!
name|alreadySeenAggDim
operator|.
name|contains
argument_list|(
name|aggDim
argument_list|)
condition|)
block|{
comment|// Not seen this agg dim, hence consider this cell in our working set
name|currentColumnCells
operator|.
name|add
argument_list|(
name|cell
argument_list|)
expr_stmt|;
name|alreadySeenAggDim
operator|.
name|add
argument_list|(
name|aggDim
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
comment|// end of switch case
block|}
comment|/*    * Processes the cells in input param currentColumnCells and populates    * List<Cell> cells as the output based on the input AggregationOperation    * parameter.    */
DECL|method|emitCells (List<Cell> cells, SortedSet<Cell> currentColumnCells, AggregationOperation currentAggOp, NumericValueConverter converter)
specifier|private
name|int
name|emitCells
parameter_list|(
name|List
argument_list|<
name|Cell
argument_list|>
name|cells
parameter_list|,
name|SortedSet
argument_list|<
name|Cell
argument_list|>
name|currentColumnCells
parameter_list|,
name|AggregationOperation
name|currentAggOp
parameter_list|,
name|NumericValueConverter
name|converter
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|(
name|currentColumnCells
operator|==
literal|null
operator|)
operator|||
operator|(
name|currentColumnCells
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|currentAggOp
operator|==
literal|null
condition|)
block|{
name|cells
operator|.
name|addAll
argument_list|(
name|currentColumnCells
argument_list|)
expr_stmt|;
return|return
name|currentColumnCells
operator|.
name|size
argument_list|()
return|;
block|}
switch|switch
condition|(
name|currentAggOp
condition|)
block|{
case|case
name|MIN
case|:
case|case
name|MAX
case|:
name|cells
operator|.
name|addAll
argument_list|(
name|currentColumnCells
argument_list|)
expr_stmt|;
return|return
name|currentColumnCells
operator|.
name|size
argument_list|()
return|;
case|case
name|SUM
case|:
case|case
name|SUM_FINAL
case|:
name|Cell
name|sumCell
init|=
name|processSummation
argument_list|(
name|currentColumnCells
argument_list|,
name|converter
argument_list|)
decl_stmt|;
name|cells
operator|.
name|add
argument_list|(
name|sumCell
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
name|cells
operator|.
name|addAll
argument_list|(
name|currentColumnCells
argument_list|)
expr_stmt|;
return|return
name|currentColumnCells
operator|.
name|size
argument_list|()
return|;
block|}
block|}
comment|/*    * Returns a cell whose value is the sum of all cell values in the input set.    * The new cell created has the timestamp of the most recent metric cell. The    * sum of a metric for a flow run is the summation at the point of the last    * metric update in that flow till that time.    */
DECL|method|processSummation (SortedSet<Cell> currentColumnCells, NumericValueConverter converter)
specifier|private
name|Cell
name|processSummation
parameter_list|(
name|SortedSet
argument_list|<
name|Cell
argument_list|>
name|currentColumnCells
parameter_list|,
name|NumericValueConverter
name|converter
parameter_list|)
throws|throws
name|IOException
block|{
name|Number
name|sum
init|=
literal|0
decl_stmt|;
name|Number
name|currentValue
init|=
literal|0
decl_stmt|;
name|long
name|ts
init|=
literal|0L
decl_stmt|;
name|long
name|mostCurrentTimestamp
init|=
literal|0L
decl_stmt|;
name|Cell
name|mostRecentCell
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Cell
name|cell
range|:
name|currentColumnCells
control|)
block|{
name|currentValue
operator|=
operator|(
name|Number
operator|)
name|converter
operator|.
name|decodeValue
argument_list|(
name|CellUtil
operator|.
name|cloneValue
argument_list|(
name|cell
argument_list|)
argument_list|)
expr_stmt|;
name|ts
operator|=
name|cell
operator|.
name|getTimestamp
argument_list|()
expr_stmt|;
if|if
condition|(
name|mostCurrentTimestamp
operator|<
name|ts
condition|)
block|{
name|mostCurrentTimestamp
operator|=
name|ts
expr_stmt|;
name|mostRecentCell
operator|=
name|cell
expr_stmt|;
block|}
name|sum
operator|=
name|converter
operator|.
name|add
argument_list|(
name|sum
argument_list|,
name|currentValue
argument_list|)
expr_stmt|;
block|}
name|byte
index|[]
name|sumBytes
init|=
name|converter
operator|.
name|encodeValue
argument_list|(
name|sum
argument_list|)
decl_stmt|;
name|Cell
name|sumCell
init|=
name|createNewCell
argument_list|(
name|mostRecentCell
argument_list|,
name|sumBytes
argument_list|)
decl_stmt|;
return|return
name|sumCell
return|;
block|}
comment|/**    * Determines which cell is to be returned based on the values in each cell    * and the comparison operation MIN or MAX.    *    * @param previouslyChosenCell    * @param currentCell    * @param currentAggOp    * @return the cell which is the min (or max) cell    * @throws IOException    */
DECL|method|compareCellValues (Cell previouslyChosenCell, Cell currentCell, AggregationOperation currentAggOp, NumericValueConverter converter)
specifier|private
name|Cell
name|compareCellValues
parameter_list|(
name|Cell
name|previouslyChosenCell
parameter_list|,
name|Cell
name|currentCell
parameter_list|,
name|AggregationOperation
name|currentAggOp
parameter_list|,
name|NumericValueConverter
name|converter
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|previouslyChosenCell
operator|==
literal|null
condition|)
block|{
return|return
name|currentCell
return|;
block|}
try|try
block|{
name|Number
name|previouslyChosenCellValue
init|=
operator|(
name|Number
operator|)
name|converter
operator|.
name|decodeValue
argument_list|(
name|CellUtil
operator|.
name|cloneValue
argument_list|(
name|previouslyChosenCell
argument_list|)
argument_list|)
decl_stmt|;
name|Number
name|currentCellValue
init|=
operator|(
name|Number
operator|)
name|converter
operator|.
name|decodeValue
argument_list|(
name|CellUtil
operator|.
name|cloneValue
argument_list|(
name|currentCell
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|currentAggOp
condition|)
block|{
case|case
name|MIN
case|:
if|if
condition|(
name|converter
operator|.
name|compare
argument_list|(
name|currentCellValue
argument_list|,
name|previouslyChosenCellValue
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|// new value is minimum, hence return this cell
return|return
name|currentCell
return|;
block|}
else|else
block|{
comment|// previously chosen value is miniumum, hence return previous min cell
return|return
name|previouslyChosenCell
return|;
block|}
case|case
name|MAX
case|:
if|if
condition|(
name|converter
operator|.
name|compare
argument_list|(
name|currentCellValue
argument_list|,
name|previouslyChosenCellValue
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|// new value is max, hence return this cell
return|return
name|currentCell
return|;
block|}
else|else
block|{
comment|// previously chosen value is max, hence return previous max cell
return|return
name|previouslyChosenCell
return|;
block|}
default|default:
return|return
name|currentCell
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"caught iae during conversion to long "
argument_list|,
name|iae
argument_list|)
expr_stmt|;
return|return
name|currentCell
return|;
block|}
block|}
DECL|method|createNewCell (Cell origCell, byte[] newValue)
specifier|private
name|Cell
name|createNewCell
parameter_list|(
name|Cell
name|origCell
parameter_list|,
name|byte
index|[]
name|newValue
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|CellUtil
operator|.
name|createCell
argument_list|(
name|CellUtil
operator|.
name|cloneRow
argument_list|(
name|origCell
argument_list|)
argument_list|,
name|CellUtil
operator|.
name|cloneFamily
argument_list|(
name|origCell
argument_list|)
argument_list|,
name|CellUtil
operator|.
name|cloneQualifier
argument_list|(
name|origCell
argument_list|)
argument_list|,
name|origCell
operator|.
name|getTimestamp
argument_list|()
argument_list|,
name|KeyValue
operator|.
name|Type
operator|.
name|Put
operator|.
name|getCode
argument_list|()
argument_list|,
name|newValue
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|flowRunScanner
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Called to signal the start of the next() call by the scanner.    */
DECL|method|startNext ()
specifier|public
name|void
name|startNext
parameter_list|()
block|{
name|currentRow
operator|=
literal|null
expr_stmt|;
block|}
comment|/**    * Returns whether or not the underlying scanner has more rows.    *    * @return true, if there are more cells to return, false otherwise.    */
DECL|method|hasMore ()
specifier|public
name|boolean
name|hasMore
parameter_list|()
block|{
return|return
name|currentIndex
operator|<
name|availableCells
operator|.
name|size
argument_list|()
condition|?
literal|true
else|:
name|hasMore
return|;
block|}
comment|/**    * Returns the next available cell for the current row and advances the    * pointer to the next cell. This method can be called multiple times in a row    * to advance through all the available cells.    *    * @param cellLimit    *          the limit of number of cells to return if the next batch must be    *          fetched by the wrapped scanner    * @return the next available cell or null if no more cells are available for    *         the current row    * @throws IOException if any problem is encountered while grabbing the next    *     cell.    */
DECL|method|nextCell (int cellLimit)
specifier|public
name|Cell
name|nextCell
parameter_list|(
name|int
name|cellLimit
parameter_list|)
throws|throws
name|IOException
block|{
name|Cell
name|cell
init|=
name|peekAtNextCell
argument_list|(
name|cellLimit
argument_list|)
decl_stmt|;
if|if
condition|(
name|cell
operator|!=
literal|null
condition|)
block|{
name|currentIndex
operator|++
expr_stmt|;
block|}
return|return
name|cell
return|;
block|}
comment|/**    * Returns the next available cell for the current row, without advancing the    * pointer. Calling this method multiple times in a row will continue to    * return the same cell.    *    * @param cellLimit    *          the limit of number of cells to return if the next batch must be    *          fetched by the wrapped scanner    * @return the next available cell or null if no more cells are available for    *         the current row    * @throws IOException if any problem is encountered while grabbing the next    *     cell.    */
DECL|method|peekAtNextCell (int cellLimit)
specifier|public
name|Cell
name|peekAtNextCell
parameter_list|(
name|int
name|cellLimit
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentIndex
operator|>=
name|availableCells
operator|.
name|size
argument_list|()
condition|)
block|{
comment|// done with current batch
name|availableCells
operator|.
name|clear
argument_list|()
expr_stmt|;
name|currentIndex
operator|=
literal|0
expr_stmt|;
name|hasMore
operator|=
name|flowRunScanner
operator|.
name|next
argument_list|(
name|availableCells
argument_list|,
name|cellLimit
argument_list|)
expr_stmt|;
block|}
name|Cell
name|cell
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|currentIndex
operator|<
name|availableCells
operator|.
name|size
argument_list|()
condition|)
block|{
name|cell
operator|=
name|availableCells
operator|.
name|get
argument_list|(
name|currentIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentRow
operator|==
literal|null
condition|)
block|{
name|currentRow
operator|=
name|CellUtil
operator|.
name|cloneRow
argument_list|(
name|cell
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|CellUtil
operator|.
name|matchingRow
argument_list|(
name|cell
argument_list|,
name|currentRow
argument_list|)
condition|)
block|{
comment|// moved on to the next row
comment|// don't use the current cell
comment|// also signal no more cells for this row
return|return
literal|null
return|;
block|}
block|}
return|return
name|cell
return|;
block|}
comment|/*    * (non-Javadoc)    *    * @see org.apache.hadoop.hbase.regionserver.RegionScanner#getMaxResultSize()    */
annotation|@
name|Override
DECL|method|getMaxResultSize ()
specifier|public
name|long
name|getMaxResultSize
parameter_list|()
block|{
if|if
condition|(
name|regionScanner
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"RegionScanner.isFilterDone() called when the flow "
operator|+
literal|"scanner's scanner is not a RegionScanner"
argument_list|)
throw|;
block|}
return|return
name|regionScanner
operator|.
name|getMaxResultSize
argument_list|()
return|;
block|}
comment|/*    * (non-Javadoc)    *    * @see org.apache.hadoop.hbase.regionserver.RegionScanner#getMvccReadPoint()    */
annotation|@
name|Override
DECL|method|getMvccReadPoint ()
specifier|public
name|long
name|getMvccReadPoint
parameter_list|()
block|{
if|if
condition|(
name|regionScanner
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"RegionScanner.isFilterDone() called when the flow "
operator|+
literal|"scanner's internal scanner is not a RegionScanner"
argument_list|)
throw|;
block|}
return|return
name|regionScanner
operator|.
name|getMvccReadPoint
argument_list|()
return|;
block|}
comment|/*    * (non-Javadoc)    *    * @see org.apache.hadoop.hbase.regionserver.RegionScanner#isFilterDone()    */
annotation|@
name|Override
DECL|method|isFilterDone ()
specifier|public
name|boolean
name|isFilterDone
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|regionScanner
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"RegionScanner.isFilterDone() called when the flow "
operator|+
literal|"scanner's internal scanner is not a RegionScanner"
argument_list|)
throw|;
block|}
return|return
name|regionScanner
operator|.
name|isFilterDone
argument_list|()
return|;
block|}
comment|/*    * (non-Javadoc)    *    * @see org.apache.hadoop.hbase.regionserver.RegionScanner#reseek(byte[])    */
annotation|@
name|Override
DECL|method|reseek (byte[] bytes)
specifier|public
name|boolean
name|reseek
parameter_list|(
name|byte
index|[]
name|bytes
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|regionScanner
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"RegionScanner.reseek() called when the flow "
operator|+
literal|"scanner's internal scanner is not a RegionScanner"
argument_list|)
throw|;
block|}
return|return
name|regionScanner
operator|.
name|reseek
argument_list|(
name|bytes
argument_list|)
return|;
block|}
block|}
end_class

end_unit

