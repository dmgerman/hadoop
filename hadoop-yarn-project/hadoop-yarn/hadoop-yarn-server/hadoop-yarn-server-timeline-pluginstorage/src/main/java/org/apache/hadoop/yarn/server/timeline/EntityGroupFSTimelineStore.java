begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with this  * work for additional information regarding copyright ownership.  The ASF  * licenses this file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *<p/>  * http://www.apache.org/licenses/LICENSE-2.0  *<p/>  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the  * License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.server.timeline
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|timeline
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|CompositeService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|ServiceOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|CallerContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationAttemptId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|YarnApplicationState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|timeline
operator|.
name|TimelineDomain
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|timeline
operator|.
name|TimelineDomains
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|timeline
operator|.
name|TimelineEntities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|timeline
operator|.
name|TimelineEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|timeline
operator|.
name|TimelineEntityGroupId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|timeline
operator|.
name|TimelineEvents
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|timeline
operator|.
name|TimelinePutResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|api
operator|.
name|YarnClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|ApplicationNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|timeline
operator|.
name|TimelineDataManager
operator|.
name|CheckAcl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|timeline
operator|.
name|security
operator|.
name|TimelineACLsManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|ConverterUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|JsonFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|map
operator|.
name|MappingJsonFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|map
operator|.
name|ObjectMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|xc
operator|.
name|JaxbAnnotationIntrospector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|UndeclaredThrowableException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_comment
comment|/**  * Plugin timeline storage to support timeline server v1.5 API. This storage  * uses a file system to store timeline entities in their groups.  */
end_comment

begin_class
DECL|class|EntityGroupFSTimelineStore
specifier|public
class|class
name|EntityGroupFSTimelineStore
extends|extends
name|CompositeService
implements|implements
name|TimelineStore
block|{
DECL|field|DOMAIN_LOG_PREFIX
specifier|static
specifier|final
name|String
name|DOMAIN_LOG_PREFIX
init|=
literal|"domainlog-"
decl_stmt|;
DECL|field|SUMMARY_LOG_PREFIX
specifier|static
specifier|final
name|String
name|SUMMARY_LOG_PREFIX
init|=
literal|"summarylog-"
decl_stmt|;
DECL|field|ENTITY_LOG_PREFIX
specifier|static
specifier|final
name|String
name|ENTITY_LOG_PREFIX
init|=
literal|"entitylog-"
decl_stmt|;
DECL|field|ATS_V15_SERVER_DFS_CALLER_CTXT
specifier|static
specifier|final
name|String
name|ATS_V15_SERVER_DFS_CALLER_CTXT
init|=
literal|"yarn_ats_server_v1_5"
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|EntityGroupFSTimelineStore
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|ACTIVE_DIR_PERMISSION
specifier|private
specifier|static
specifier|final
name|FsPermission
name|ACTIVE_DIR_PERMISSION
init|=
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|01777
argument_list|)
decl_stmt|;
DECL|field|DONE_DIR_PERMISSION
specifier|private
specifier|static
specifier|final
name|FsPermission
name|DONE_DIR_PERMISSION
init|=
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0700
argument_list|)
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|EnumSet
argument_list|<
name|YarnApplicationState
argument_list|>
DECL|field|APP_FINAL_STATES
name|APP_FINAL_STATES
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|YarnApplicationState
operator|.
name|FAILED
argument_list|,
name|YarnApplicationState
operator|.
name|KILLED
argument_list|,
name|YarnApplicationState
operator|.
name|FINISHED
argument_list|)
decl_stmt|;
comment|// Active dir:<activeRoot>/appId/attemptId/cacheId.log
comment|// Done dir:<doneRoot>/cluster_ts/hash1/hash2/appId/attemptId/cacheId.log
DECL|field|APP_DONE_DIR_PREFIX_FORMAT
specifier|private
specifier|static
specifier|final
name|String
name|APP_DONE_DIR_PREFIX_FORMAT
init|=
literal|"%d"
operator|+
name|Path
operator|.
name|SEPARATOR
comment|// cluster timestamp
operator|+
literal|"%04d"
operator|+
name|Path
operator|.
name|SEPARATOR
comment|// app num / 1,000,000
operator|+
literal|"%03d"
operator|+
name|Path
operator|.
name|SEPARATOR
comment|// (app num / 1000) % 1000
operator|+
literal|"%s"
operator|+
name|Path
operator|.
name|SEPARATOR
decl_stmt|;
comment|// full app id
comment|// Indicates when to force release a cache item even if there are active
comment|// readers. Enlarge this factor may increase memory usage for the reader since
comment|// there may be more cache items "hanging" in memory but not in cache.
DECL|field|CACHE_ITEM_OVERFLOW_FACTOR
specifier|private
specifier|static
specifier|final
name|int
name|CACHE_ITEM_OVERFLOW_FACTOR
init|=
literal|2
decl_stmt|;
DECL|field|yarnClient
specifier|private
name|YarnClient
name|yarnClient
decl_stmt|;
DECL|field|summaryStore
specifier|private
name|TimelineStore
name|summaryStore
decl_stmt|;
DECL|field|aclManager
specifier|private
name|TimelineACLsManager
name|aclManager
decl_stmt|;
DECL|field|summaryTdm
specifier|private
name|TimelineDataManager
name|summaryTdm
decl_stmt|;
DECL|field|appIdLogMap
specifier|private
name|ConcurrentMap
argument_list|<
name|ApplicationId
argument_list|,
name|AppLogs
argument_list|>
name|appIdLogMap
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|ApplicationId
argument_list|,
name|AppLogs
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|executor
specifier|private
name|ScheduledThreadPoolExecutor
name|executor
decl_stmt|;
DECL|field|stopExecutors
specifier|private
name|AtomicBoolean
name|stopExecutors
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|field|fs
specifier|private
name|FileSystem
name|fs
decl_stmt|;
DECL|field|objMapper
specifier|private
name|ObjectMapper
name|objMapper
decl_stmt|;
DECL|field|jsonFactory
specifier|private
name|JsonFactory
name|jsonFactory
decl_stmt|;
DECL|field|activeRootPath
specifier|private
name|Path
name|activeRootPath
decl_stmt|;
DECL|field|doneRootPath
specifier|private
name|Path
name|doneRootPath
decl_stmt|;
DECL|field|logRetainMillis
specifier|private
name|long
name|logRetainMillis
decl_stmt|;
DECL|field|unknownActiveMillis
specifier|private
name|long
name|unknownActiveMillis
decl_stmt|;
DECL|field|appCacheMaxSize
specifier|private
name|int
name|appCacheMaxSize
init|=
literal|0
decl_stmt|;
DECL|field|cacheIdPlugins
specifier|private
name|List
argument_list|<
name|TimelineEntityGroupPlugin
argument_list|>
name|cacheIdPlugins
decl_stmt|;
DECL|field|cachedLogs
specifier|private
name|Map
argument_list|<
name|TimelineEntityGroupId
argument_list|,
name|EntityCacheItem
argument_list|>
name|cachedLogs
decl_stmt|;
annotation|@
name|VisibleForTesting
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|field|metrics
name|EntityGroupFSTimelineStoreMetrics
name|metrics
decl_stmt|;
DECL|method|EntityGroupFSTimelineStore ()
specifier|public
name|EntityGroupFSTimelineStore
parameter_list|()
block|{
name|super
argument_list|(
name|EntityGroupFSTimelineStore
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|serviceInit (Configuration conf)
specifier|protected
name|void
name|serviceInit
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
name|metrics
operator|=
name|EntityGroupFSTimelineStoreMetrics
operator|.
name|create
argument_list|()
expr_stmt|;
name|summaryStore
operator|=
name|createSummaryStore
argument_list|()
expr_stmt|;
name|addService
argument_list|(
name|summaryStore
argument_list|)
expr_stmt|;
name|long
name|logRetainSecs
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS
argument_list|,
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETAIN_SECONDS_DEFAULT
argument_list|)
decl_stmt|;
name|logRetainMillis
operator|=
name|logRetainSecs
operator|*
literal|1000
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Cleaner set to delete logs older than {} seconds"
argument_list|,
name|logRetainSecs
argument_list|)
expr_stmt|;
name|long
name|unknownActiveSecs
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS
argument_list|,
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_UNKNOWN_ACTIVE_SECONDS_DEFAULT
argument_list|)
decl_stmt|;
name|unknownActiveMillis
operator|=
name|unknownActiveSecs
operator|*
literal|1000
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Unknown apps will be treated as complete after {} seconds"
argument_list|,
name|unknownActiveSecs
argument_list|)
expr_stmt|;
name|appCacheMaxSize
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE
argument_list|,
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_APP_CACHE_SIZE_DEFAULT
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Application cache size is {}"
argument_list|,
name|appCacheMaxSize
argument_list|)
expr_stmt|;
name|cachedLogs
operator|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|LinkedHashMap
argument_list|<
name|TimelineEntityGroupId
argument_list|,
name|EntityCacheItem
argument_list|>
argument_list|(
name|appCacheMaxSize
operator|+
literal|1
argument_list|,
literal|0.75f
argument_list|,
literal|true
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|boolean
name|removeEldestEntry
parameter_list|(
name|Map
operator|.
name|Entry
argument_list|<
name|TimelineEntityGroupId
argument_list|,
name|EntityCacheItem
argument_list|>
name|eldest
parameter_list|)
block|{
if|if
condition|(
name|super
operator|.
name|size
argument_list|()
operator|>
name|appCacheMaxSize
condition|)
block|{
name|TimelineEntityGroupId
name|groupId
init|=
name|eldest
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Evicting {} due to space limitations"
argument_list|,
name|groupId
argument_list|)
expr_stmt|;
name|EntityCacheItem
name|cacheItem
init|=
name|eldest
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|int
name|activeStores
init|=
name|EntityCacheItem
operator|.
name|getActiveStores
argument_list|()
decl_stmt|;
if|if
condition|(
name|activeStores
operator|>
name|appCacheMaxSize
operator|*
name|CACHE_ITEM_OVERFLOW_FACTOR
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Force release cache {} since {} stores are active"
argument_list|,
name|groupId
argument_list|,
name|activeStores
argument_list|)
expr_stmt|;
name|cacheItem
operator|.
name|forceRelease
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Try release cache {}"
argument_list|,
name|groupId
argument_list|)
expr_stmt|;
name|cacheItem
operator|.
name|tryRelease
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|cacheItem
operator|.
name|getAppLogs
argument_list|()
operator|.
name|isDone
argument_list|()
condition|)
block|{
name|appIdLogMap
operator|.
name|remove
argument_list|(
name|groupId
operator|.
name|getApplicationId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|metrics
operator|.
name|incrCacheEvicts
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|cacheIdPlugins
operator|=
name|loadPlugIns
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// Initialize yarn client for application status
name|yarnClient
operator|=
name|createAndInitYarnClient
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// if non-null, hook its lifecycle up
name|addIfService
argument_list|(
name|yarnClient
argument_list|)
expr_stmt|;
name|activeRootPath
operator|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_ACTIVE_DIR
argument_list|,
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_ACTIVE_DIR_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|doneRootPath
operator|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_DONE_DIR
argument_list|,
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_DONE_DIR_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|=
name|activeRootPath
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|CallerContext
operator|.
name|setCurrent
argument_list|(
operator|new
name|CallerContext
operator|.
name|Builder
argument_list|(
name|ATS_V15_SERVER_DFS_CALLER_CTXT
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
name|super
operator|.
name|serviceInit
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
DECL|method|loadPlugIns (Configuration conf)
specifier|private
name|List
argument_list|<
name|TimelineEntityGroupPlugin
argument_list|>
name|loadPlugIns
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|RuntimeException
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|pluginNames
init|=
name|conf
operator|.
name|getTrimmedStringCollection
argument_list|(
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_ENTITY_GROUP_PLUGIN_CLASSES
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|TimelineEntityGroupPlugin
argument_list|>
name|pluginList
init|=
operator|new
name|LinkedList
argument_list|<
name|TimelineEntityGroupPlugin
argument_list|>
argument_list|()
decl_stmt|;
name|Exception
name|caught
init|=
literal|null
decl_stmt|;
for|for
control|(
specifier|final
name|String
name|name
range|:
name|pluginNames
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying to load plugin class {}"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|TimelineEntityGroupPlugin
name|cacheIdPlugin
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|conf
operator|.
name|getClassByName
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|cacheIdPlugin
operator|=
operator|(
name|TimelineEntityGroupPlugin
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|clazz
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error loading plugin "
operator|+
name|name
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|caught
operator|=
name|e
expr_stmt|;
block|}
if|if
condition|(
name|cacheIdPlugin
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"No class defined for "
operator|+
name|name
argument_list|,
name|caught
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Load plugin class {}"
argument_list|,
name|cacheIdPlugin
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|pluginList
operator|.
name|add
argument_list|(
name|cacheIdPlugin
argument_list|)
expr_stmt|;
block|}
return|return
name|pluginList
return|;
block|}
DECL|method|createSummaryStore ()
specifier|private
name|TimelineStore
name|createSummaryStore
parameter_list|()
block|{
return|return
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|getConfig
argument_list|()
operator|.
name|getClass
argument_list|(
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_SUMMARY_STORE
argument_list|,
name|LeveldbTimelineStore
operator|.
name|class
argument_list|,
name|TimelineStore
operator|.
name|class
argument_list|)
argument_list|,
name|getConfig
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|serviceStart ()
specifier|protected
name|void
name|serviceStart
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|serviceStart
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting {}"
argument_list|,
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|summaryStore
operator|.
name|start
argument_list|()
expr_stmt|;
name|Configuration
name|conf
init|=
name|getConfig
argument_list|()
decl_stmt|;
name|aclManager
operator|=
operator|new
name|TimelineACLsManager
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|aclManager
operator|.
name|setTimelineStore
argument_list|(
name|summaryStore
argument_list|)
expr_stmt|;
name|summaryTdm
operator|=
operator|new
name|TimelineDataManager
argument_list|(
name|summaryStore
argument_list|,
name|aclManager
argument_list|)
expr_stmt|;
name|summaryTdm
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|addService
argument_list|(
name|summaryTdm
argument_list|)
expr_stmt|;
comment|// start child services that aren't already started
name|super
operator|.
name|serviceStart
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|activeRootPath
argument_list|)
condition|)
block|{
name|fs
operator|.
name|mkdirs
argument_list|(
name|activeRootPath
argument_list|)
expr_stmt|;
name|fs
operator|.
name|setPermission
argument_list|(
name|activeRootPath
argument_list|,
name|ACTIVE_DIR_PERMISSION
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|doneRootPath
argument_list|)
condition|)
block|{
name|fs
operator|.
name|mkdirs
argument_list|(
name|doneRootPath
argument_list|)
expr_stmt|;
name|fs
operator|.
name|setPermission
argument_list|(
name|doneRootPath
argument_list|,
name|DONE_DIR_PERMISSION
argument_list|)
expr_stmt|;
block|}
name|objMapper
operator|=
operator|new
name|ObjectMapper
argument_list|()
expr_stmt|;
name|objMapper
operator|.
name|setAnnotationIntrospector
argument_list|(
operator|new
name|JaxbAnnotationIntrospector
argument_list|()
argument_list|)
expr_stmt|;
name|jsonFactory
operator|=
operator|new
name|MappingJsonFactory
argument_list|(
name|objMapper
argument_list|)
expr_stmt|;
specifier|final
name|long
name|scanIntervalSecs
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_SCAN_INTERVAL_SECONDS
argument_list|,
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_SCAN_INTERVAL_SECONDS_DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|long
name|cleanerIntervalSecs
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_CLEANER_INTERVAL_SECONDS
argument_list|,
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_CLEANER_INTERVAL_SECONDS_DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numThreads
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_THREADS
argument_list|,
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_THREADS_DEFAULT
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Scanning active directory {} every {} seconds"
argument_list|,
name|activeRootPath
argument_list|,
name|scanIntervalSecs
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Cleaning logs every {} seconds"
argument_list|,
name|cleanerIntervalSecs
argument_list|)
expr_stmt|;
name|executor
operator|=
operator|new
name|ScheduledThreadPoolExecutor
argument_list|(
name|numThreads
argument_list|,
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setNameFormat
argument_list|(
literal|"EntityLogPluginWorker #%d"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
name|executor
operator|.
name|scheduleAtFixedRate
argument_list|(
operator|new
name|EntityLogScanner
argument_list|()
argument_list|,
literal|0
argument_list|,
name|scanIntervalSecs
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
name|executor
operator|.
name|scheduleAtFixedRate
argument_list|(
operator|new
name|EntityLogCleaner
argument_list|()
argument_list|,
name|cleanerIntervalSecs
argument_list|,
name|cleanerIntervalSecs
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|serviceStop ()
specifier|protected
name|void
name|serviceStop
parameter_list|()
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping {}"
argument_list|,
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|stopExecutors
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|executor
operator|!=
literal|null
condition|)
block|{
name|executor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
name|executor
operator|.
name|isTerminating
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting for executor to terminate"
argument_list|)
expr_stmt|;
name|boolean
name|terminated
init|=
name|executor
operator|.
name|awaitTermination
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
decl_stmt|;
if|if
condition|(
name|terminated
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Executor terminated"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Executor did not terminate"
argument_list|)
expr_stmt|;
name|executor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
block|}
block|}
synchronized|synchronized
init|(
name|cachedLogs
init|)
block|{
for|for
control|(
name|EntityCacheItem
name|cacheItem
range|:
name|cachedLogs
operator|.
name|values
argument_list|()
control|)
block|{
name|ServiceOperations
operator|.
name|stopQuietly
argument_list|(
name|cacheItem
operator|.
name|getStore
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|CallerContext
operator|.
name|setCurrent
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|super
operator|.
name|serviceStop
argument_list|()
expr_stmt|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|VisibleForTesting
DECL|method|scanActiveLogs ()
name|int
name|scanActiveLogs
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|startTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|iter
init|=
name|list
argument_list|(
name|activeRootPath
argument_list|)
decl_stmt|;
name|int
name|logsToScanCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|FileStatus
name|stat
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|stat
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|ApplicationId
name|appId
init|=
name|parseApplicationId
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|appId
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"scan logs for {} in {}"
argument_list|,
name|appId
argument_list|,
name|stat
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|logsToScanCount
operator|++
expr_stmt|;
name|AppLogs
name|logs
init|=
name|getAndSetActiveLog
argument_list|(
name|appId
argument_list|,
name|stat
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|executor
operator|.
name|execute
argument_list|(
operator|new
name|ActiveLogParser
argument_list|(
name|logs
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unable to parse entry {}"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|metrics
operator|.
name|addActiveLogDirScanTime
argument_list|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|startTime
argument_list|)
expr_stmt|;
return|return
name|logsToScanCount
return|;
block|}
comment|/**    * List a directory, returning an iterator which will fail fast if this    * service has been stopped    * @param path path to list    * @return an iterator over the contents of the directory    * @throws IOException    */
DECL|method|list (Path path)
specifier|private
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|list
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|StoppableRemoteIterator
argument_list|(
name|fs
operator|.
name|listStatusIterator
argument_list|(
name|path
argument_list|)
argument_list|)
return|;
block|}
DECL|method|createAndPutAppLogsIfAbsent (ApplicationId appId, Path appDirPath, AppState appState)
specifier|private
name|AppLogs
name|createAndPutAppLogsIfAbsent
parameter_list|(
name|ApplicationId
name|appId
parameter_list|,
name|Path
name|appDirPath
parameter_list|,
name|AppState
name|appState
parameter_list|)
block|{
name|AppLogs
name|appLogs
init|=
operator|new
name|AppLogs
argument_list|(
name|appId
argument_list|,
name|appDirPath
argument_list|,
name|appState
argument_list|)
decl_stmt|;
name|AppLogs
name|oldAppLogs
init|=
name|appIdLogMap
operator|.
name|putIfAbsent
argument_list|(
name|appId
argument_list|,
name|appLogs
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldAppLogs
operator|!=
literal|null
condition|)
block|{
name|appLogs
operator|=
name|oldAppLogs
expr_stmt|;
block|}
return|return
name|appLogs
return|;
block|}
DECL|method|getAndSetActiveLog (ApplicationId appId, Path appDirPath)
specifier|private
name|AppLogs
name|getAndSetActiveLog
parameter_list|(
name|ApplicationId
name|appId
parameter_list|,
name|Path
name|appDirPath
parameter_list|)
block|{
name|AppLogs
name|appLogs
init|=
name|appIdLogMap
operator|.
name|get
argument_list|(
name|appId
argument_list|)
decl_stmt|;
if|if
condition|(
name|appLogs
operator|==
literal|null
condition|)
block|{
name|appLogs
operator|=
name|createAndPutAppLogsIfAbsent
argument_list|(
name|appId
argument_list|,
name|appDirPath
argument_list|,
name|AppState
operator|.
name|ACTIVE
argument_list|)
expr_stmt|;
block|}
return|return
name|appLogs
return|;
block|}
comment|// searches for the app logs and returns it if found else null
DECL|method|getAndSetAppLogs (ApplicationId applicationId)
specifier|private
name|AppLogs
name|getAndSetAppLogs
parameter_list|(
name|ApplicationId
name|applicationId
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Looking for app logs mapped for app id {}"
argument_list|,
name|applicationId
argument_list|)
expr_stmt|;
name|AppLogs
name|appLogs
init|=
name|appIdLogMap
operator|.
name|get
argument_list|(
name|applicationId
argument_list|)
decl_stmt|;
if|if
condition|(
name|appLogs
operator|==
literal|null
condition|)
block|{
name|AppState
name|appState
init|=
name|AppState
operator|.
name|UNKNOWN
decl_stmt|;
name|Path
name|appDirPath
init|=
name|getDoneAppPath
argument_list|(
name|applicationId
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|appDirPath
argument_list|)
condition|)
block|{
name|appState
operator|=
name|AppState
operator|.
name|COMPLETED
expr_stmt|;
block|}
else|else
block|{
name|appDirPath
operator|=
name|getActiveAppPath
argument_list|(
name|applicationId
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|appDirPath
argument_list|)
condition|)
block|{
name|appState
operator|=
name|AppState
operator|.
name|ACTIVE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|appState
operator|!=
name|AppState
operator|.
name|UNKNOWN
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Create and try to add new appLogs to appIdLogMap for {}"
argument_list|,
name|applicationId
argument_list|)
expr_stmt|;
name|appLogs
operator|=
name|createAndPutAppLogsIfAbsent
argument_list|(
name|applicationId
argument_list|,
name|appDirPath
argument_list|,
name|appState
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|appLogs
return|;
block|}
comment|/**    * Main function for entity log cleaner. This method performs depth first    * search from a given dir path for all application log dirs. Once found, it    * will decide if the directory should be cleaned up and then clean them.    *    * @param dirpath the root directory the cleaner should start with. Note that    *                dirpath should be a directory that contains a set of    *                application log directories. The cleaner method will not    *                work if the given dirpath itself is an application log dir.    * @param fs    * @param retainMillis    * @throws IOException    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|VisibleForTesting
DECL|method|cleanLogs (Path dirpath, FileSystem fs, long retainMillis)
name|void
name|cleanLogs
parameter_list|(
name|Path
name|dirpath
parameter_list|,
name|FileSystem
name|fs
parameter_list|,
name|long
name|retainMillis
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|now
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
comment|// Depth first search from root directory for all application log dirs
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|iter
init|=
name|list
argument_list|(
name|dirpath
argument_list|)
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|FileStatus
name|stat
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|stat
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
comment|// If current is an application log dir, decide if we need to remove it
comment|// and remove if necessary.
comment|// Otherwise, keep iterating into it.
name|ApplicationId
name|appId
init|=
name|parseApplicationId
argument_list|(
name|dirpath
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|appId
operator|!=
literal|null
condition|)
block|{
comment|// Application log dir
if|if
condition|(
name|shouldCleanAppLogDir
argument_list|(
name|dirpath
argument_list|,
name|now
argument_list|,
name|fs
argument_list|,
name|retainMillis
argument_list|)
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleting {}"
argument_list|,
name|dirpath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|delete
argument_list|(
name|dirpath
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to remove "
operator|+
name|dirpath
argument_list|)
expr_stmt|;
block|}
name|metrics
operator|.
name|incrLogsDirsCleaned
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to remove "
operator|+
name|dirpath
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// Keep cleaning inside
name|cleanLogs
argument_list|(
name|stat
operator|.
name|getPath
argument_list|()
argument_list|,
name|fs
argument_list|,
name|retainMillis
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|shouldCleanAppLogDir (Path appLogPath, long now, FileSystem fs, long logRetainMillis)
specifier|private
specifier|static
name|boolean
name|shouldCleanAppLogDir
parameter_list|(
name|Path
name|appLogPath
parameter_list|,
name|long
name|now
parameter_list|,
name|FileSystem
name|fs
parameter_list|,
name|long
name|logRetainMillis
parameter_list|)
throws|throws
name|IOException
block|{
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|iter
init|=
name|fs
operator|.
name|listStatusIterator
argument_list|(
name|appLogPath
argument_list|)
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|FileStatus
name|stat
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|-
name|stat
operator|.
name|getModificationTime
argument_list|()
operator|<=
name|logRetainMillis
condition|)
block|{
comment|// found a dir entry that is fresh enough to prevent
comment|// cleaning this directory.
name|LOG
operator|.
name|debug
argument_list|(
literal|"{} not being cleaned due to {}"
argument_list|,
name|appLogPath
argument_list|,
name|stat
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Otherwise, keep searching files inside for directories.
if|if
condition|(
name|stat
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|shouldCleanAppLogDir
argument_list|(
name|stat
operator|.
name|getPath
argument_list|()
argument_list|,
name|now
argument_list|,
name|fs
argument_list|,
name|logRetainMillis
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|// converts the String to an ApplicationId or null if conversion failed
DECL|method|parseApplicationId (String appIdStr)
specifier|private
specifier|static
name|ApplicationId
name|parseApplicationId
parameter_list|(
name|String
name|appIdStr
parameter_list|)
block|{
name|ApplicationId
name|appId
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|appIdStr
operator|.
name|startsWith
argument_list|(
name|ApplicationId
operator|.
name|appIdStrPrefix
argument_list|)
condition|)
block|{
try|try
block|{
name|appId
operator|=
name|ApplicationId
operator|.
name|fromString
argument_list|(
name|appIdStr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|appId
operator|=
literal|null
expr_stmt|;
block|}
block|}
return|return
name|appId
return|;
block|}
DECL|method|getActiveAppPath (ApplicationId appId)
specifier|private
name|Path
name|getActiveAppPath
parameter_list|(
name|ApplicationId
name|appId
parameter_list|)
block|{
return|return
operator|new
name|Path
argument_list|(
name|activeRootPath
argument_list|,
name|appId
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getDoneAppPath (ApplicationId appId)
specifier|private
name|Path
name|getDoneAppPath
parameter_list|(
name|ApplicationId
name|appId
parameter_list|)
block|{
comment|// cut up the app ID into mod(1000) buckets
name|int
name|appNum
init|=
name|appId
operator|.
name|getId
argument_list|()
decl_stmt|;
name|appNum
operator|/=
literal|1000
expr_stmt|;
name|int
name|bucket2
init|=
name|appNum
operator|%
literal|1000
decl_stmt|;
name|int
name|bucket1
init|=
name|appNum
operator|/
literal|1000
decl_stmt|;
return|return
operator|new
name|Path
argument_list|(
name|doneRootPath
argument_list|,
name|String
operator|.
name|format
argument_list|(
name|APP_DONE_DIR_PREFIX_FORMAT
argument_list|,
name|appId
operator|.
name|getClusterTimestamp
argument_list|()
argument_list|,
name|bucket1
argument_list|,
name|bucket2
argument_list|,
name|appId
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Create and initialize the YARN Client. Tests may override/mock this.    * If they return null, then {@link #getAppState(ApplicationId)} MUST    * also be overridden    * @param conf configuration    * @return the yarn client, or null.    *    */
annotation|@
name|VisibleForTesting
DECL|method|createAndInitYarnClient (Configuration conf)
specifier|protected
name|YarnClient
name|createAndInitYarnClient
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|YarnClient
name|client
init|=
name|YarnClient
operator|.
name|createYarnClient
argument_list|()
decl_stmt|;
name|client
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
return|return
name|client
return|;
block|}
comment|/**    * Get the application state.    * @param appId application ID    * @return the state or {@link AppState#UNKNOWN} if it could not    * be determined    * @throws IOException on IO problems    */
annotation|@
name|VisibleForTesting
DECL|method|getAppState (ApplicationId appId)
specifier|protected
name|AppState
name|getAppState
parameter_list|(
name|ApplicationId
name|appId
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getAppState
argument_list|(
name|appId
argument_list|,
name|yarnClient
argument_list|)
return|;
block|}
comment|/**    * Ask the RM for the state of the application.    * This method has to be synchronized to control traffic to RM    * @param appId application ID    * @param yarnClient    * @return the state or {@link AppState#UNKNOWN} if it could not    * be determined    * @throws IOException    */
DECL|method|getAppState (ApplicationId appId, YarnClient yarnClient)
specifier|private
specifier|static
specifier|synchronized
name|AppState
name|getAppState
parameter_list|(
name|ApplicationId
name|appId
parameter_list|,
name|YarnClient
name|yarnClient
parameter_list|)
throws|throws
name|IOException
block|{
name|AppState
name|appState
init|=
name|AppState
operator|.
name|ACTIVE
decl_stmt|;
try|try
block|{
name|ApplicationReport
name|report
init|=
name|yarnClient
operator|.
name|getApplicationReport
argument_list|(
name|appId
argument_list|)
decl_stmt|;
name|YarnApplicationState
name|yarnState
init|=
name|report
operator|.
name|getYarnApplicationState
argument_list|()
decl_stmt|;
if|if
condition|(
name|APP_FINAL_STATES
operator|.
name|contains
argument_list|(
name|yarnState
argument_list|)
condition|)
block|{
name|appState
operator|=
name|AppState
operator|.
name|COMPLETED
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ApplicationNotFoundException
name|e
parameter_list|)
block|{
name|appState
operator|=
name|AppState
operator|.
name|UNKNOWN
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|YarnException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|appState
return|;
block|}
comment|/**    * Application states,    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|VisibleForTesting
DECL|enum|AppState
specifier|public
enum|enum
name|AppState
block|{
DECL|enumConstant|ACTIVE
name|ACTIVE
block|,
DECL|enumConstant|UNKNOWN
name|UNKNOWN
block|,
DECL|enumConstant|COMPLETED
name|COMPLETED
block|}
DECL|class|AppLogs
class|class
name|AppLogs
block|{
DECL|field|appId
specifier|private
name|ApplicationId
name|appId
decl_stmt|;
DECL|field|appDirPath
specifier|private
name|Path
name|appDirPath
decl_stmt|;
DECL|field|appState
specifier|private
name|AppState
name|appState
decl_stmt|;
DECL|field|summaryLogs
specifier|private
name|List
argument_list|<
name|LogInfo
argument_list|>
name|summaryLogs
init|=
operator|new
name|ArrayList
argument_list|<
name|LogInfo
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|detailLogs
specifier|private
name|List
argument_list|<
name|LogInfo
argument_list|>
name|detailLogs
init|=
operator|new
name|ArrayList
argument_list|<
name|LogInfo
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|AppLogs (ApplicationId appId, Path appPath, AppState state)
specifier|public
name|AppLogs
parameter_list|(
name|ApplicationId
name|appId
parameter_list|,
name|Path
name|appPath
parameter_list|,
name|AppState
name|state
parameter_list|)
block|{
name|this
operator|.
name|appId
operator|=
name|appId
expr_stmt|;
name|appDirPath
operator|=
name|appPath
expr_stmt|;
name|appState
operator|=
name|state
expr_stmt|;
block|}
DECL|method|isDone ()
specifier|public
specifier|synchronized
name|boolean
name|isDone
parameter_list|()
block|{
return|return
name|appState
operator|==
name|AppState
operator|.
name|COMPLETED
return|;
block|}
DECL|method|getAppId ()
specifier|public
specifier|synchronized
name|ApplicationId
name|getAppId
parameter_list|()
block|{
return|return
name|appId
return|;
block|}
DECL|method|getAppDirPath ()
specifier|public
specifier|synchronized
name|Path
name|getAppDirPath
parameter_list|()
block|{
return|return
name|appDirPath
return|;
block|}
DECL|method|getSummaryLogs ()
specifier|synchronized
name|List
argument_list|<
name|LogInfo
argument_list|>
name|getSummaryLogs
parameter_list|()
block|{
return|return
name|summaryLogs
return|;
block|}
DECL|method|getDetailLogs ()
specifier|synchronized
name|List
argument_list|<
name|LogInfo
argument_list|>
name|getDetailLogs
parameter_list|()
block|{
return|return
name|detailLogs
return|;
block|}
DECL|method|parseSummaryLogs ()
specifier|public
specifier|synchronized
name|void
name|parseSummaryLogs
parameter_list|()
throws|throws
name|IOException
block|{
name|parseSummaryLogs
argument_list|(
name|summaryTdm
argument_list|)
expr_stmt|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|VisibleForTesting
DECL|method|parseSummaryLogs (TimelineDataManager tdm)
specifier|synchronized
name|void
name|parseSummaryLogs
parameter_list|(
name|TimelineDataManager
name|tdm
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|startTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isDone
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Try to parse summary log for log {} in {}"
argument_list|,
name|appId
argument_list|,
name|appDirPath
argument_list|)
expr_stmt|;
name|appState
operator|=
name|getAppState
argument_list|(
name|appId
argument_list|)
expr_stmt|;
name|long
name|recentLogModTime
init|=
name|scanForLogs
argument_list|()
decl_stmt|;
if|if
condition|(
name|appState
operator|==
name|AppState
operator|.
name|UNKNOWN
condition|)
block|{
if|if
condition|(
name|Time
operator|.
name|now
argument_list|()
operator|-
name|recentLogModTime
operator|>
name|unknownActiveMillis
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"{} state is UNKNOWN and logs are stale, assuming COMPLETED"
argument_list|,
name|appId
argument_list|)
expr_stmt|;
name|appState
operator|=
name|AppState
operator|.
name|COMPLETED
expr_stmt|;
block|}
block|}
block|}
name|List
argument_list|<
name|LogInfo
argument_list|>
name|removeList
init|=
operator|new
name|ArrayList
argument_list|<
name|LogInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|LogInfo
name|log
range|:
name|summaryLogs
control|)
block|{
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|log
operator|.
name|getPath
argument_list|(
name|appDirPath
argument_list|)
argument_list|)
condition|)
block|{
name|long
name|summaryEntityParsed
init|=
name|log
operator|.
name|parseForStore
argument_list|(
name|tdm
argument_list|,
name|appDirPath
argument_list|,
name|isDone
argument_list|()
argument_list|,
name|jsonFactory
argument_list|,
name|objMapper
argument_list|,
name|fs
argument_list|)
decl_stmt|;
name|metrics
operator|.
name|incrEntitiesReadToSummary
argument_list|(
name|summaryEntityParsed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The log may have been removed, remove the log
name|removeList
operator|.
name|add
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"File {} no longer exists, remove it from log list"
argument_list|,
name|log
operator|.
name|getPath
argument_list|(
name|appDirPath
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|summaryLogs
operator|.
name|removeAll
argument_list|(
name|removeList
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|addSummaryLogReadTime
argument_list|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|startTime
argument_list|)
expr_stmt|;
block|}
comment|// scans for new logs and returns the modification timestamp of the
comment|// most recently modified log
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|VisibleForTesting
DECL|method|scanForLogs ()
name|long
name|scanForLogs
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"scanForLogs on {}"
argument_list|,
name|appDirPath
argument_list|)
expr_stmt|;
name|long
name|newestModTime
init|=
literal|0
decl_stmt|;
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|iterAttempt
init|=
name|list
argument_list|(
name|appDirPath
argument_list|)
decl_stmt|;
while|while
condition|(
name|iterAttempt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|FileStatus
name|statAttempt
init|=
name|iterAttempt
operator|.
name|next
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"scanForLogs on {}"
argument_list|,
name|statAttempt
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|statAttempt
operator|.
name|isDirectory
argument_list|()
operator|||
operator|!
name|statAttempt
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
name|ApplicationAttemptId
operator|.
name|appAttemptIdStrPrefix
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Scanner skips for unknown dir/file {}"
argument_list|,
name|statAttempt
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|String
name|attemptDirName
init|=
name|statAttempt
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|iterCache
init|=
name|list
argument_list|(
name|statAttempt
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|iterCache
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|FileStatus
name|statCache
init|=
name|iterCache
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|statCache
operator|.
name|isFile
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|String
name|filename
init|=
name|statCache
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// We should only update time for log files.
name|boolean
name|shouldSetTime
init|=
literal|true
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"scan for log file: {}"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|.
name|startsWith
argument_list|(
name|DOMAIN_LOG_PREFIX
argument_list|)
condition|)
block|{
name|addSummaryLog
argument_list|(
name|attemptDirName
argument_list|,
name|filename
argument_list|,
name|statCache
operator|.
name|getOwner
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filename
operator|.
name|startsWith
argument_list|(
name|SUMMARY_LOG_PREFIX
argument_list|)
condition|)
block|{
name|addSummaryLog
argument_list|(
name|attemptDirName
argument_list|,
name|filename
argument_list|,
name|statCache
operator|.
name|getOwner
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filename
operator|.
name|startsWith
argument_list|(
name|ENTITY_LOG_PREFIX
argument_list|)
condition|)
block|{
name|addDetailLog
argument_list|(
name|attemptDirName
argument_list|,
name|filename
argument_list|,
name|statCache
operator|.
name|getOwner
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shouldSetTime
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|shouldSetTime
condition|)
block|{
name|newestModTime
operator|=
name|Math
operator|.
name|max
argument_list|(
name|statCache
operator|.
name|getModificationTime
argument_list|()
argument_list|,
name|newestModTime
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// if there are no logs in the directory then use the modification
comment|// time of the directory itself
if|if
condition|(
name|newestModTime
operator|==
literal|0
condition|)
block|{
name|newestModTime
operator|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|appDirPath
argument_list|)
operator|.
name|getModificationTime
argument_list|()
expr_stmt|;
block|}
return|return
name|newestModTime
return|;
block|}
DECL|method|addSummaryLog (String attemptDirName, String filename, String owner, boolean isDomainLog)
specifier|private
name|void
name|addSummaryLog
parameter_list|(
name|String
name|attemptDirName
parameter_list|,
name|String
name|filename
parameter_list|,
name|String
name|owner
parameter_list|,
name|boolean
name|isDomainLog
parameter_list|)
block|{
for|for
control|(
name|LogInfo
name|log
range|:
name|summaryLogs
control|)
block|{
if|if
condition|(
name|log
operator|.
name|getFilename
argument_list|()
operator|.
name|equals
argument_list|(
name|filename
argument_list|)
operator|&&
name|log
operator|.
name|getAttemptDirName
argument_list|()
operator|.
name|equals
argument_list|(
name|attemptDirName
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Incoming log {} not present in my summaryLogs list, add it"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|LogInfo
name|log
decl_stmt|;
if|if
condition|(
name|isDomainLog
condition|)
block|{
name|log
operator|=
operator|new
name|DomainLogInfo
argument_list|(
name|attemptDirName
argument_list|,
name|filename
argument_list|,
name|owner
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|=
operator|new
name|EntityLogInfo
argument_list|(
name|attemptDirName
argument_list|,
name|filename
argument_list|,
name|owner
argument_list|)
expr_stmt|;
block|}
name|summaryLogs
operator|.
name|add
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
DECL|method|addDetailLog (String attemptDirName, String filename, String owner)
specifier|private
name|void
name|addDetailLog
parameter_list|(
name|String
name|attemptDirName
parameter_list|,
name|String
name|filename
parameter_list|,
name|String
name|owner
parameter_list|)
block|{
for|for
control|(
name|LogInfo
name|log
range|:
name|detailLogs
control|)
block|{
if|if
condition|(
name|log
operator|.
name|getFilename
argument_list|()
operator|.
name|equals
argument_list|(
name|filename
argument_list|)
operator|&&
name|log
operator|.
name|getAttemptDirName
argument_list|()
operator|.
name|equals
argument_list|(
name|attemptDirName
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
name|detailLogs
operator|.
name|add
argument_list|(
operator|new
name|EntityLogInfo
argument_list|(
name|attemptDirName
argument_list|,
name|filename
argument_list|,
name|owner
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|moveToDone ()
specifier|public
specifier|synchronized
name|void
name|moveToDone
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|doneAppPath
init|=
name|getDoneAppPath
argument_list|(
name|appId
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|doneAppPath
operator|.
name|equals
argument_list|(
name|appDirPath
argument_list|)
condition|)
block|{
name|Path
name|donePathParent
init|=
name|doneAppPath
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|donePathParent
argument_list|)
condition|)
block|{
name|fs
operator|.
name|mkdirs
argument_list|(
name|donePathParent
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Application {} is done, trying to move to done dir {}"
argument_list|,
name|appId
argument_list|,
name|doneAppPath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|rename
argument_list|(
name|appDirPath
argument_list|,
name|doneAppPath
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Rename "
operator|+
name|appDirPath
operator|+
literal|" to "
operator|+
name|doneAppPath
operator|+
literal|" failed"
argument_list|)
throw|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Moved {} to {}"
argument_list|,
name|appDirPath
argument_list|,
name|doneAppPath
argument_list|)
expr_stmt|;
block|}
name|appDirPath
operator|=
name|doneAppPath
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Extract any nested throwable forwarded from IPC operations.    * @param e exception    * @return either the exception passed an an argument, or any nested    * exception which was wrapped inside an {@link UndeclaredThrowableException}    */
DECL|method|extract (Exception e)
specifier|private
name|Throwable
name|extract
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|Throwable
name|t
init|=
name|e
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|UndeclaredThrowableException
operator|&&
name|e
operator|.
name|getCause
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|t
operator|=
name|e
operator|.
name|getCause
argument_list|()
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
DECL|class|EntityLogScanner
specifier|private
class|class
name|EntityLogScanner
implements|implements
name|Runnable
block|{
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Active scan starting"
argument_list|)
expr_stmt|;
try|try
block|{
name|int
name|scanned
init|=
name|scanActiveLogs
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Scanned {} active applications"
argument_list|,
name|scanned
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|Throwable
name|t
init|=
name|extract
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|InterruptedException
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"File scanner interrupted"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error scanning active files"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Active scan complete"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|ActiveLogParser
specifier|private
class|class
name|ActiveLogParser
implements|implements
name|Runnable
block|{
DECL|field|appLogs
specifier|private
name|AppLogs
name|appLogs
decl_stmt|;
DECL|method|ActiveLogParser (AppLogs logs)
specifier|public
name|ActiveLogParser
parameter_list|(
name|AppLogs
name|logs
parameter_list|)
block|{
name|appLogs
operator|=
name|logs
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Begin parsing summary logs. "
argument_list|)
expr_stmt|;
name|appLogs
operator|.
name|parseSummaryLogs
argument_list|()
expr_stmt|;
if|if
condition|(
name|appLogs
operator|.
name|isDone
argument_list|()
condition|)
block|{
name|appLogs
operator|.
name|moveToDone
argument_list|()
expr_stmt|;
name|appIdLogMap
operator|.
name|remove
argument_list|(
name|appLogs
operator|.
name|getAppId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"End parsing summary logs. "
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|Throwable
name|t
init|=
name|extract
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|InterruptedException
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Log parser interrupted"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error processing logs for "
operator|+
name|appLogs
operator|.
name|getAppId
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|class|EntityLogCleaner
specifier|private
class|class
name|EntityLogCleaner
implements|implements
name|Runnable
block|{
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Cleaner starting"
argument_list|)
expr_stmt|;
name|long
name|startTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
try|try
block|{
name|cleanLogs
argument_list|(
name|doneRootPath
argument_list|,
name|fs
argument_list|,
name|logRetainMillis
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|Throwable
name|t
init|=
name|extract
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|InterruptedException
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cleaner interrupted"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error cleaning files"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|metrics
operator|.
name|addLogCleanTime
argument_list|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|startTime
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Cleaner finished"
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|VisibleForTesting
DECL|method|setFs (FileSystem incomingFs)
name|void
name|setFs
parameter_list|(
name|FileSystem
name|incomingFs
parameter_list|)
block|{
name|this
operator|.
name|fs
operator|=
name|incomingFs
expr_stmt|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|VisibleForTesting
DECL|method|setCachedLogs (TimelineEntityGroupId groupId, EntityCacheItem cacheItem)
name|void
name|setCachedLogs
parameter_list|(
name|TimelineEntityGroupId
name|groupId
parameter_list|,
name|EntityCacheItem
name|cacheItem
parameter_list|)
block|{
name|cacheItem
operator|.
name|incrRefs
argument_list|()
expr_stmt|;
name|cachedLogs
operator|.
name|put
argument_list|(
name|groupId
argument_list|,
name|cacheItem
argument_list|)
expr_stmt|;
block|}
DECL|method|getTimelineStoresFromCacheIds ( Set<TimelineEntityGroupId> groupIds, String entityType, List<EntityCacheItem> cacheItems)
specifier|private
name|List
argument_list|<
name|TimelineStore
argument_list|>
name|getTimelineStoresFromCacheIds
parameter_list|(
name|Set
argument_list|<
name|TimelineEntityGroupId
argument_list|>
name|groupIds
parameter_list|,
name|String
name|entityType
parameter_list|,
name|List
argument_list|<
name|EntityCacheItem
argument_list|>
name|cacheItems
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|TimelineStore
argument_list|>
name|stores
init|=
operator|new
name|LinkedList
argument_list|<
name|TimelineStore
argument_list|>
argument_list|()
decl_stmt|;
comment|// For now we just handle one store in a context. We return the first
comment|// non-null storage for the group ids.
for|for
control|(
name|TimelineEntityGroupId
name|groupId
range|:
name|groupIds
control|)
block|{
name|TimelineStore
name|storeForId
init|=
name|getCachedStore
argument_list|(
name|groupId
argument_list|,
name|cacheItems
argument_list|)
decl_stmt|;
if|if
condition|(
name|storeForId
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding {} as a store for the query"
argument_list|,
name|storeForId
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|stores
operator|.
name|add
argument_list|(
name|storeForId
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|incrGetEntityToDetailOps
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stores
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using summary store for {}"
argument_list|,
name|entityType
argument_list|)
expr_stmt|;
name|stores
operator|.
name|add
argument_list|(
name|this
operator|.
name|summaryStore
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|incrGetEntityToSummaryOps
argument_list|()
expr_stmt|;
block|}
return|return
name|stores
return|;
block|}
DECL|method|getTimelineStoresForRead (String entityId, String entityType, List<EntityCacheItem> cacheItems)
specifier|protected
name|List
argument_list|<
name|TimelineStore
argument_list|>
name|getTimelineStoresForRead
parameter_list|(
name|String
name|entityId
parameter_list|,
name|String
name|entityType
parameter_list|,
name|List
argument_list|<
name|EntityCacheItem
argument_list|>
name|cacheItems
parameter_list|)
throws|throws
name|IOException
block|{
name|Set
argument_list|<
name|TimelineEntityGroupId
argument_list|>
name|groupIds
init|=
operator|new
name|HashSet
argument_list|<
name|TimelineEntityGroupId
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|TimelineEntityGroupPlugin
name|cacheIdPlugin
range|:
name|cacheIdPlugins
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying plugin {} for id {} and type {}"
argument_list|,
name|cacheIdPlugin
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|entityId
argument_list|,
name|entityType
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|TimelineEntityGroupId
argument_list|>
name|idsFromPlugin
init|=
name|cacheIdPlugin
operator|.
name|getTimelineEntityGroupId
argument_list|(
name|entityId
argument_list|,
name|entityType
argument_list|)
decl_stmt|;
if|if
condition|(
name|idsFromPlugin
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Plugin returned null "
operator|+
name|cacheIdPlugin
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Plugin returned ids: "
operator|+
name|idsFromPlugin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idsFromPlugin
operator|!=
literal|null
condition|)
block|{
name|groupIds
operator|.
name|addAll
argument_list|(
name|idsFromPlugin
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"plugin {} returns a non-null value on query"
argument_list|,
name|cacheIdPlugin
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|getTimelineStoresFromCacheIds
argument_list|(
name|groupIds
argument_list|,
name|entityType
argument_list|,
name|cacheItems
argument_list|)
return|;
block|}
DECL|method|getTimelineStoresForRead (String entityType, NameValuePair primaryFilter, Collection<NameValuePair> secondaryFilters, List<EntityCacheItem> cacheItems)
specifier|private
name|List
argument_list|<
name|TimelineStore
argument_list|>
name|getTimelineStoresForRead
parameter_list|(
name|String
name|entityType
parameter_list|,
name|NameValuePair
name|primaryFilter
parameter_list|,
name|Collection
argument_list|<
name|NameValuePair
argument_list|>
name|secondaryFilters
parameter_list|,
name|List
argument_list|<
name|EntityCacheItem
argument_list|>
name|cacheItems
parameter_list|)
throws|throws
name|IOException
block|{
name|Set
argument_list|<
name|TimelineEntityGroupId
argument_list|>
name|groupIds
init|=
operator|new
name|HashSet
argument_list|<
name|TimelineEntityGroupId
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|TimelineEntityGroupPlugin
name|cacheIdPlugin
range|:
name|cacheIdPlugins
control|)
block|{
name|Set
argument_list|<
name|TimelineEntityGroupId
argument_list|>
name|idsFromPlugin
init|=
name|cacheIdPlugin
operator|.
name|getTimelineEntityGroupId
argument_list|(
name|entityType
argument_list|,
name|primaryFilter
argument_list|,
name|secondaryFilters
argument_list|)
decl_stmt|;
if|if
condition|(
name|idsFromPlugin
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"plugin {} returns a non-null value on query {}"
argument_list|,
name|cacheIdPlugin
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|idsFromPlugin
argument_list|)
expr_stmt|;
name|groupIds
operator|.
name|addAll
argument_list|(
name|idsFromPlugin
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|getTimelineStoresFromCacheIds
argument_list|(
name|groupIds
argument_list|,
name|entityType
argument_list|,
name|cacheItems
argument_list|)
return|;
block|}
comment|// find a cached timeline store or null if it cannot be located
DECL|method|getCachedStore (TimelineEntityGroupId groupId, List<EntityCacheItem> cacheItems)
specifier|private
name|TimelineStore
name|getCachedStore
parameter_list|(
name|TimelineEntityGroupId
name|groupId
parameter_list|,
name|List
argument_list|<
name|EntityCacheItem
argument_list|>
name|cacheItems
parameter_list|)
throws|throws
name|IOException
block|{
name|EntityCacheItem
name|cacheItem
decl_stmt|;
synchronized|synchronized
init|(
name|this
operator|.
name|cachedLogs
init|)
block|{
comment|// Note that the content in the cache log storage may be stale.
name|cacheItem
operator|=
name|this
operator|.
name|cachedLogs
operator|.
name|get
argument_list|(
name|groupId
argument_list|)
expr_stmt|;
if|if
condition|(
name|cacheItem
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Set up new cache item for id {}"
argument_list|,
name|groupId
argument_list|)
expr_stmt|;
name|cacheItem
operator|=
operator|new
name|EntityCacheItem
argument_list|(
name|groupId
argument_list|,
name|getConfig
argument_list|()
argument_list|,
name|fs
argument_list|)
expr_stmt|;
name|AppLogs
name|appLogs
init|=
name|getAndSetAppLogs
argument_list|(
name|groupId
operator|.
name|getApplicationId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|appLogs
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Set applogs {} for group id {}"
argument_list|,
name|appLogs
argument_list|,
name|groupId
argument_list|)
expr_stmt|;
name|cacheItem
operator|.
name|setAppLogs
argument_list|(
name|appLogs
argument_list|)
expr_stmt|;
name|this
operator|.
name|cachedLogs
operator|.
name|put
argument_list|(
name|groupId
argument_list|,
name|cacheItem
argument_list|)
expr_stmt|;
comment|// Add the reference by the cache
name|cacheItem
operator|.
name|incrRefs
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"AppLogs for groupId {} is set to null!"
argument_list|,
name|groupId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|TimelineStore
name|store
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|cacheItem
operator|.
name|getAppLogs
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|AppLogs
name|appLogs
init|=
name|cacheItem
operator|.
name|getAppLogs
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"try refresh cache {} {}"
argument_list|,
name|groupId
argument_list|,
name|appLogs
operator|.
name|getAppId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Add the reference by the store
name|cacheItem
operator|.
name|incrRefs
argument_list|()
expr_stmt|;
name|cacheItems
operator|.
name|add
argument_list|(
name|cacheItem
argument_list|)
expr_stmt|;
name|store
operator|=
name|cacheItem
operator|.
name|refreshCache
argument_list|(
name|aclManager
argument_list|,
name|jsonFactory
argument_list|,
name|objMapper
argument_list|,
name|metrics
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"AppLogs for group id {} is null"
argument_list|,
name|groupId
argument_list|)
expr_stmt|;
block|}
return|return
name|store
return|;
block|}
DECL|method|tryReleaseCacheItems (List<EntityCacheItem> relatedCacheItems)
specifier|protected
name|void
name|tryReleaseCacheItems
parameter_list|(
name|List
argument_list|<
name|EntityCacheItem
argument_list|>
name|relatedCacheItems
parameter_list|)
block|{
for|for
control|(
name|EntityCacheItem
name|item
range|:
name|relatedCacheItems
control|)
block|{
name|item
operator|.
name|tryRelease
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getEntities (String entityType, Long limit, Long windowStart, Long windowEnd, String fromId, Long fromTs, NameValuePair primaryFilter, Collection<NameValuePair> secondaryFilters, EnumSet<Field> fieldsToRetrieve, CheckAcl checkAcl)
specifier|public
name|TimelineEntities
name|getEntities
parameter_list|(
name|String
name|entityType
parameter_list|,
name|Long
name|limit
parameter_list|,
name|Long
name|windowStart
parameter_list|,
name|Long
name|windowEnd
parameter_list|,
name|String
name|fromId
parameter_list|,
name|Long
name|fromTs
parameter_list|,
name|NameValuePair
name|primaryFilter
parameter_list|,
name|Collection
argument_list|<
name|NameValuePair
argument_list|>
name|secondaryFilters
parameter_list|,
name|EnumSet
argument_list|<
name|Field
argument_list|>
name|fieldsToRetrieve
parameter_list|,
name|CheckAcl
name|checkAcl
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"getEntities type={} primary={}"
argument_list|,
name|entityType
argument_list|,
name|primaryFilter
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|EntityCacheItem
argument_list|>
name|relatedCacheItems
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|TimelineStore
argument_list|>
name|stores
init|=
name|getTimelineStoresForRead
argument_list|(
name|entityType
argument_list|,
name|primaryFilter
argument_list|,
name|secondaryFilters
argument_list|,
name|relatedCacheItems
argument_list|)
decl_stmt|;
name|TimelineEntities
name|returnEntities
init|=
operator|new
name|TimelineEntities
argument_list|()
decl_stmt|;
for|for
control|(
name|TimelineStore
name|store
range|:
name|stores
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Try timeline store {} for the request"
argument_list|,
name|store
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|TimelineEntities
name|entities
init|=
name|store
operator|.
name|getEntities
argument_list|(
name|entityType
argument_list|,
name|limit
argument_list|,
name|windowStart
argument_list|,
name|windowEnd
argument_list|,
name|fromId
argument_list|,
name|fromTs
argument_list|,
name|primaryFilter
argument_list|,
name|secondaryFilters
argument_list|,
name|fieldsToRetrieve
argument_list|,
name|checkAcl
argument_list|)
decl_stmt|;
if|if
condition|(
name|entities
operator|!=
literal|null
condition|)
block|{
name|returnEntities
operator|.
name|addEntities
argument_list|(
name|entities
operator|.
name|getEntities
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|tryReleaseCacheItems
argument_list|(
name|relatedCacheItems
argument_list|)
expr_stmt|;
return|return
name|returnEntities
return|;
block|}
annotation|@
name|Override
DECL|method|getEntity (String entityId, String entityType, EnumSet<Field> fieldsToRetrieve)
specifier|public
name|TimelineEntity
name|getEntity
parameter_list|(
name|String
name|entityId
parameter_list|,
name|String
name|entityType
parameter_list|,
name|EnumSet
argument_list|<
name|Field
argument_list|>
name|fieldsToRetrieve
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"getEntity type={} id={}"
argument_list|,
name|entityType
argument_list|,
name|entityId
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|EntityCacheItem
argument_list|>
name|relatedCacheItems
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|TimelineStore
argument_list|>
name|stores
init|=
name|getTimelineStoresForRead
argument_list|(
name|entityId
argument_list|,
name|entityType
argument_list|,
name|relatedCacheItems
argument_list|)
decl_stmt|;
for|for
control|(
name|TimelineStore
name|store
range|:
name|stores
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Try timeline store {}:{} for the request"
argument_list|,
name|store
operator|.
name|getName
argument_list|()
argument_list|,
name|store
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|TimelineEntity
name|e
init|=
name|store
operator|.
name|getEntity
argument_list|(
name|entityId
argument_list|,
name|entityType
argument_list|,
name|fieldsToRetrieve
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
block|{
name|tryReleaseCacheItems
argument_list|(
name|relatedCacheItems
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"getEntity: Found nothing"
argument_list|)
expr_stmt|;
name|tryReleaseCacheItems
argument_list|(
name|relatedCacheItems
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|getEntityTimelines (String entityType, SortedSet<String> entityIds, Long limit, Long windowStart, Long windowEnd, Set<String> eventTypes)
specifier|public
name|TimelineEvents
name|getEntityTimelines
parameter_list|(
name|String
name|entityType
parameter_list|,
name|SortedSet
argument_list|<
name|String
argument_list|>
name|entityIds
parameter_list|,
name|Long
name|limit
parameter_list|,
name|Long
name|windowStart
parameter_list|,
name|Long
name|windowEnd
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|eventTypes
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"getEntityTimelines type={} ids={}"
argument_list|,
name|entityType
argument_list|,
name|entityIds
argument_list|)
expr_stmt|;
name|TimelineEvents
name|returnEvents
init|=
operator|new
name|TimelineEvents
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|EntityCacheItem
argument_list|>
name|relatedCacheItems
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|entityId
range|:
name|entityIds
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"getEntityTimeline type={} id={}"
argument_list|,
name|entityType
argument_list|,
name|entityId
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|TimelineStore
argument_list|>
name|stores
init|=
name|getTimelineStoresForRead
argument_list|(
name|entityId
argument_list|,
name|entityType
argument_list|,
name|relatedCacheItems
argument_list|)
decl_stmt|;
for|for
control|(
name|TimelineStore
name|store
range|:
name|stores
control|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Try timeline store {}:{} for the request"
argument_list|,
name|store
operator|.
name|getName
argument_list|()
argument_list|,
name|store
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|SortedSet
argument_list|<
name|String
argument_list|>
name|entityIdSet
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
name|entityIdSet
operator|.
name|add
argument_list|(
name|entityId
argument_list|)
expr_stmt|;
name|TimelineEvents
name|events
init|=
name|store
operator|.
name|getEntityTimelines
argument_list|(
name|entityType
argument_list|,
name|entityIdSet
argument_list|,
name|limit
argument_list|,
name|windowStart
argument_list|,
name|windowEnd
argument_list|,
name|eventTypes
argument_list|)
decl_stmt|;
if|if
condition|(
name|events
operator|!=
literal|null
condition|)
block|{
name|returnEvents
operator|.
name|addEvents
argument_list|(
name|events
operator|.
name|getAllEvents
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|tryReleaseCacheItems
argument_list|(
name|relatedCacheItems
argument_list|)
expr_stmt|;
return|return
name|returnEvents
return|;
block|}
annotation|@
name|Override
DECL|method|getDomain (String domainId)
specifier|public
name|TimelineDomain
name|getDomain
parameter_list|(
name|String
name|domainId
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|summaryStore
operator|.
name|getDomain
argument_list|(
name|domainId
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getDomains (String owner)
specifier|public
name|TimelineDomains
name|getDomains
parameter_list|(
name|String
name|owner
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|summaryStore
operator|.
name|getDomains
argument_list|(
name|owner
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|put (TimelineEntities data)
specifier|public
name|TimelinePutResponse
name|put
parameter_list|(
name|TimelineEntities
name|data
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|summaryStore
operator|.
name|put
argument_list|(
name|data
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|put (TimelineDomain domain)
specifier|public
name|void
name|put
parameter_list|(
name|TimelineDomain
name|domain
parameter_list|)
throws|throws
name|IOException
block|{
name|summaryStore
operator|.
name|put
argument_list|(
name|domain
argument_list|)
expr_stmt|;
block|}
comment|/**    * This is a special remote iterator whose {@link #hasNext()} method    * returns false if {@link #stopExecutors} is true.    *    * This provides an implicit shutdown of all iterative file list and scan    * operations without needing to implement it in the while loops themselves.    */
DECL|class|StoppableRemoteIterator
specifier|private
class|class
name|StoppableRemoteIterator
implements|implements
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
block|{
DECL|field|remote
specifier|private
specifier|final
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|remote
decl_stmt|;
DECL|method|StoppableRemoteIterator (RemoteIterator<FileStatus> remote)
specifier|public
name|StoppableRemoteIterator
parameter_list|(
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|remote
parameter_list|)
block|{
name|this
operator|.
name|remote
operator|=
name|remote
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|!
name|stopExecutors
operator|.
name|get
argument_list|()
operator|&&
name|remote
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|FileStatus
name|next
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|remote
operator|.
name|next
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

