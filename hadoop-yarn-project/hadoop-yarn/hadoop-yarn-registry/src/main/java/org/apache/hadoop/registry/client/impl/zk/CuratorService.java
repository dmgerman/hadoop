begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.registry.client.impl.zk
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|impl
operator|.
name|zk
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|ensemble
operator|.
name|EnsembleProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|ensemble
operator|.
name|fixed
operator|.
name|FixedEnsembleProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|CuratorFramework
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|CuratorFrameworkFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|api
operator|.
name|BackgroundCallback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|api
operator|.
name|CreateBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|api
operator|.
name|DeleteBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|api
operator|.
name|GetChildrenBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|recipes
operator|.
name|cache
operator|.
name|TreeCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|recipes
operator|.
name|cache
operator|.
name|TreeCacheEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|recipes
operator|.
name|cache
operator|.
name|TreeCacheListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|retry
operator|.
name|BoundedExponentialBackoffRetry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathIsNotEmptyDirectoryException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|api
operator|.
name|RegistryConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryPathUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|exceptions
operator|.
name|AuthenticationFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|exceptions
operator|.
name|NoChildrenForEphemeralsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|exceptions
operator|.
name|NoPathPermissionsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|exceptions
operator|.
name|RegistryIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|CompositeService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|ServiceStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|CreateMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|ZooDefs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|ACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Stat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * This service binds to Zookeeper via Apache Curator. It is more  * generic than just the YARN service registry; it does not implement  * any of the Registry Operations API.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|CuratorService
specifier|public
class|class
name|CuratorService
extends|extends
name|CompositeService
implements|implements
name|RegistryConstants
implements|,
name|RegistryBindingSource
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|CuratorService
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * the Curator binding.    */
DECL|field|curator
specifier|private
name|CuratorFramework
name|curator
decl_stmt|;
comment|/**    * Path to the registry root.    */
DECL|field|registryRoot
specifier|private
name|String
name|registryRoot
decl_stmt|;
comment|/**    * Supplied binding source. This defaults to being this    * service itself.    */
DECL|field|bindingSource
specifier|private
specifier|final
name|RegistryBindingSource
name|bindingSource
decl_stmt|;
comment|/**    * Security service.    */
DECL|field|registrySecurity
specifier|private
name|RegistrySecurity
name|registrySecurity
decl_stmt|;
comment|/**    * the connection binding text for messages.    */
DECL|field|connectionDescription
specifier|private
name|String
name|connectionDescription
decl_stmt|;
comment|/**    * Security connection diagnostics.    */
DECL|field|securityConnectionDiagnostics
specifier|private
name|String
name|securityConnectionDiagnostics
init|=
literal|""
decl_stmt|;
comment|/**    * Provider of curator "ensemble"; offers a basis for    * more flexible bonding in future.    */
DECL|field|ensembleProvider
specifier|private
name|EnsembleProvider
name|ensembleProvider
decl_stmt|;
comment|/**    * Registry tree cache.    */
DECL|field|treeCache
specifier|private
name|TreeCache
name|treeCache
decl_stmt|;
comment|/**    * Construct the service.    *    * @param name          service name    * @param bindingSource source of binding information.    *                      If null: use this instance    */
DECL|method|CuratorService (String name, RegistryBindingSource bindingSource)
specifier|public
name|CuratorService
parameter_list|(
name|String
name|name
parameter_list|,
name|RegistryBindingSource
name|bindingSource
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bindingSource
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|bindingSource
operator|=
name|bindingSource
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|bindingSource
operator|=
name|this
expr_stmt|;
block|}
block|}
comment|/**    * Create an instance using this service as the binding source (i.e. read    * configuration options from the registry).    *    * @param name service name    */
DECL|method|CuratorService (String name)
specifier|public
name|CuratorService
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
argument_list|(
name|name
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Init the service.    * This is where the security bindings are set up.    *    * @param conf configuration of the service    * @throws Exception    */
annotation|@
name|Override
DECL|method|serviceInit (Configuration conf)
specifier|protected
name|void
name|serviceInit
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
name|registryRoot
operator|=
name|conf
operator|.
name|getTrimmed
argument_list|(
name|KEY_REGISTRY_ZK_ROOT
argument_list|,
name|DEFAULT_ZK_REGISTRY_ROOT
argument_list|)
expr_stmt|;
comment|// create and add the registy service
name|registrySecurity
operator|=
operator|new
name|RegistrySecurity
argument_list|(
literal|"registry security"
argument_list|)
expr_stmt|;
name|addService
argument_list|(
name|registrySecurity
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating Registry with root {}"
argument_list|,
name|registryRoot
argument_list|)
expr_stmt|;
block|}
name|super
operator|.
name|serviceInit
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Start the service.    * This is where the curator instance is started.    *    * @throws Exception    */
annotation|@
name|Override
DECL|method|serviceStart ()
specifier|protected
name|void
name|serviceStart
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|serviceStart
argument_list|()
expr_stmt|;
comment|// create the curator; rely on the registry security code
comment|// to set up the JVM context and curator
name|curator
operator|=
name|createCurator
argument_list|()
expr_stmt|;
block|}
comment|/**    * Close the ZK connection if it is open.    */
annotation|@
name|Override
DECL|method|serviceStop ()
specifier|protected
name|void
name|serviceStop
parameter_list|()
throws|throws
name|Exception
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|curator
argument_list|)
expr_stmt|;
if|if
condition|(
name|treeCache
operator|!=
literal|null
condition|)
block|{
name|treeCache
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|super
operator|.
name|serviceStop
argument_list|()
expr_stmt|;
block|}
comment|/**    * Internal check that a service is in the live state.    *    * @throws ServiceStateException if not    */
DECL|method|checkServiceLive ()
specifier|private
name|void
name|checkServiceLive
parameter_list|()
throws|throws
name|ServiceStateException
block|{
if|if
condition|(
operator|!
name|isInState
argument_list|(
name|STATE
operator|.
name|STARTED
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ServiceStateException
argument_list|(
literal|"Service "
operator|+
name|getName
argument_list|()
operator|+
literal|" is in wrong state: "
operator|+
name|getServiceState
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Flag to indicate whether or not the registry is secure.    * Valid once the service is inited.    *    * @return service security policy    */
DECL|method|isSecure ()
specifier|public
name|boolean
name|isSecure
parameter_list|()
block|{
return|return
name|registrySecurity
operator|.
name|isSecureRegistry
argument_list|()
return|;
block|}
comment|/**    * Get the registry security helper.    *    * @return the registry security helper    */
DECL|method|getRegistrySecurity ()
specifier|protected
name|RegistrySecurity
name|getRegistrySecurity
parameter_list|()
block|{
return|return
name|registrySecurity
return|;
block|}
comment|/**    * Build the security diagnostics string.    *    * @return a string for diagnostics    */
DECL|method|buildSecurityDiagnostics ()
specifier|protected
name|String
name|buildSecurityDiagnostics
parameter_list|()
block|{
comment|// build up the security connection diags
if|if
condition|(
operator|!
name|isSecure
argument_list|()
condition|)
block|{
return|return
literal|"security disabled"
return|;
block|}
else|else
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"secure cluster; "
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|registrySecurity
operator|.
name|buildSecurityDiagnostics
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Create a new curator instance off the root path; using configuration    * options provided in the service configuration to set timeouts and    * retry policy.    *    * @return the newly created creator    */
DECL|method|createCurator ()
specifier|private
name|CuratorFramework
name|createCurator
parameter_list|()
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
name|getConfig
argument_list|()
decl_stmt|;
name|createEnsembleProvider
argument_list|()
expr_stmt|;
name|int
name|sessionTimeout
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|KEY_REGISTRY_ZK_SESSION_TIMEOUT
argument_list|,
name|DEFAULT_ZK_SESSION_TIMEOUT
argument_list|)
decl_stmt|;
name|int
name|connectionTimeout
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|KEY_REGISTRY_ZK_CONNECTION_TIMEOUT
argument_list|,
name|DEFAULT_ZK_CONNECTION_TIMEOUT
argument_list|)
decl_stmt|;
name|int
name|retryTimes
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|KEY_REGISTRY_ZK_RETRY_TIMES
argument_list|,
name|DEFAULT_ZK_RETRY_TIMES
argument_list|)
decl_stmt|;
name|int
name|retryInterval
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|KEY_REGISTRY_ZK_RETRY_INTERVAL
argument_list|,
name|DEFAULT_ZK_RETRY_INTERVAL
argument_list|)
decl_stmt|;
name|int
name|retryCeiling
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|KEY_REGISTRY_ZK_RETRY_CEILING
argument_list|,
name|DEFAULT_ZK_RETRY_CEILING
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Creating CuratorService with connection {}"
argument_list|,
name|connectionDescription
argument_list|)
expr_stmt|;
name|CuratorFramework
name|framework
decl_stmt|;
synchronized|synchronized
init|(
name|CuratorService
operator|.
name|class
init|)
block|{
comment|// set the security options
comment|// build up the curator itself
name|CuratorFrameworkFactory
operator|.
name|Builder
name|builder
init|=
name|CuratorFrameworkFactory
operator|.
name|builder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|ensembleProvider
argument_list|(
name|ensembleProvider
argument_list|)
operator|.
name|connectionTimeoutMs
argument_list|(
name|connectionTimeout
argument_list|)
operator|.
name|sessionTimeoutMs
argument_list|(
name|sessionTimeout
argument_list|)
operator|.
name|retryPolicy
argument_list|(
operator|new
name|BoundedExponentialBackoffRetry
argument_list|(
name|retryInterval
argument_list|,
name|retryCeiling
argument_list|,
name|retryTimes
argument_list|)
argument_list|)
expr_stmt|;
comment|// set up the builder AND any JVM context
name|registrySecurity
operator|.
name|applySecurityEnvironment
argument_list|(
name|builder
argument_list|)
expr_stmt|;
comment|//log them
name|securityConnectionDiagnostics
operator|=
name|buildSecurityDiagnostics
argument_list|()
expr_stmt|;
name|framework
operator|=
name|builder
operator|.
name|build
argument_list|()
expr_stmt|;
name|framework
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
return|return
name|framework
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|" "
operator|+
name|bindingDiagnosticDetails
argument_list|()
return|;
block|}
comment|/**    * Get the binding diagnostics.    *    * @return a diagnostics string valid after the service is started.    */
DECL|method|bindingDiagnosticDetails ()
specifier|public
name|String
name|bindingDiagnosticDetails
parameter_list|()
block|{
return|return
literal|" Connection=\""
operator|+
name|connectionDescription
operator|+
literal|"\""
operator|+
literal|" root=\""
operator|+
name|registryRoot
operator|+
literal|"\""
operator|+
literal|" "
operator|+
name|securityConnectionDiagnostics
return|;
block|}
comment|/**    * Create a full path from the registry root and the supplied subdir.    *    * @param path path of operation    * @return an absolute path    * @throws IllegalArgumentException if the path is invalide    */
DECL|method|createFullPath (String path)
specifier|protected
name|String
name|createFullPath
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|RegistryPathUtils
operator|.
name|createFullPath
argument_list|(
name|registryRoot
argument_list|,
name|path
argument_list|)
return|;
block|}
comment|/**    * Get the registry binding source ... this can be used to    * create new ensemble providers    *    * @return the registry binding source in use    */
DECL|method|getBindingSource ()
specifier|public
name|RegistryBindingSource
name|getBindingSource
parameter_list|()
block|{
return|return
name|bindingSource
return|;
block|}
comment|/**    * Create the ensemble provider for this registry, by invoking    * {@link RegistryBindingSource#supplyBindingInformation()} on    * the provider stored in {@link #bindingSource}.    * Sets {@link #ensembleProvider} to that value;    * sets {@link #connectionDescription} to the binding info    * for use in toString and logging;    */
DECL|method|createEnsembleProvider ()
specifier|protected
name|void
name|createEnsembleProvider
parameter_list|()
block|{
name|BindingInformation
name|binding
init|=
name|bindingSource
operator|.
name|supplyBindingInformation
argument_list|()
decl_stmt|;
name|connectionDescription
operator|=
name|binding
operator|.
name|description
operator|+
literal|" "
operator|+
name|securityConnectionDiagnostics
expr_stmt|;
name|ensembleProvider
operator|=
name|binding
operator|.
name|ensembleProvider
expr_stmt|;
block|}
comment|/**    * Supply the binding information.    * This implementation returns a fixed ensemble bonded to    * the quorum supplied by {@link #buildConnectionString()}.    *    * @return the binding information    */
annotation|@
name|Override
DECL|method|supplyBindingInformation ()
specifier|public
name|BindingInformation
name|supplyBindingInformation
parameter_list|()
block|{
name|BindingInformation
name|binding
init|=
operator|new
name|BindingInformation
argument_list|()
decl_stmt|;
name|String
name|connectString
init|=
name|buildConnectionString
argument_list|()
decl_stmt|;
name|binding
operator|.
name|ensembleProvider
operator|=
operator|new
name|FixedEnsembleProvider
argument_list|(
name|connectString
argument_list|)
expr_stmt|;
name|binding
operator|.
name|description
operator|=
literal|"fixed ZK quorum \""
operator|+
name|connectString
operator|+
literal|"\""
expr_stmt|;
return|return
name|binding
return|;
block|}
comment|/**    * Override point: get the connection string used to connect to    * the ZK service.    *    * @return a registry quorum    */
DECL|method|buildConnectionString ()
specifier|protected
name|String
name|buildConnectionString
parameter_list|()
block|{
return|return
name|getConfig
argument_list|()
operator|.
name|getTrimmed
argument_list|(
name|KEY_REGISTRY_ZK_QUORUM
argument_list|,
name|DEFAULT_REGISTRY_ZK_QUORUM
argument_list|)
return|;
block|}
comment|/**    * Create an IOE when an operation fails.    *    * @param path      path of operation    * @param operation operation attempted    * @param exception caught the exception caught    * @return an IOE to throw that contains the path and operation details.    */
DECL|method|operationFailure (String path, String operation, Exception exception)
specifier|protected
name|IOException
name|operationFailure
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|operation
parameter_list|,
name|Exception
name|exception
parameter_list|)
block|{
return|return
name|operationFailure
argument_list|(
name|path
argument_list|,
name|operation
argument_list|,
name|exception
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Create an IOE when an operation fails.    *    * @param path      path of operation    * @param operation operation attempted    * @param exception caught the exception caught    * @return an IOE to throw that contains the path and operation details.    */
DECL|method|operationFailure (String path, String operation, Exception exception, List<ACL> acls)
specifier|protected
name|IOException
name|operationFailure
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|operation
parameter_list|,
name|Exception
name|exception
parameter_list|,
name|List
argument_list|<
name|ACL
argument_list|>
name|acls
parameter_list|)
block|{
name|IOException
name|ioe
decl_stmt|;
name|String
name|aclList
init|=
literal|"["
operator|+
name|RegistrySecurity
operator|.
name|aclsToString
argument_list|(
name|acls
argument_list|)
operator|+
literal|"]"
decl_stmt|;
if|if
condition|(
name|exception
operator|instanceof
name|KeeperException
operator|.
name|NoNodeException
condition|)
block|{
name|ioe
operator|=
operator|new
name|PathNotFoundException
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exception
operator|instanceof
name|KeeperException
operator|.
name|NodeExistsException
condition|)
block|{
name|ioe
operator|=
operator|new
name|FileAlreadyExistsException
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exception
operator|instanceof
name|KeeperException
operator|.
name|NoAuthException
condition|)
block|{
name|ioe
operator|=
operator|new
name|NoPathPermissionsException
argument_list|(
name|path
argument_list|,
literal|"Not authorized to access path; ACLs: "
operator|+
name|aclList
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exception
operator|instanceof
name|KeeperException
operator|.
name|NotEmptyException
condition|)
block|{
name|ioe
operator|=
operator|new
name|PathIsNotEmptyDirectoryException
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exception
operator|instanceof
name|KeeperException
operator|.
name|AuthFailedException
condition|)
block|{
name|ioe
operator|=
operator|new
name|AuthenticationFailedException
argument_list|(
name|path
argument_list|,
literal|"Authentication Failed: "
operator|+
name|exception
operator|+
literal|"; "
operator|+
name|securityConnectionDiagnostics
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exception
operator|instanceof
name|KeeperException
operator|.
name|NoChildrenForEphemeralsException
condition|)
block|{
name|ioe
operator|=
operator|new
name|NoChildrenForEphemeralsException
argument_list|(
name|path
argument_list|,
literal|"Cannot create a path under an ephemeral node: "
operator|+
name|exception
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exception
operator|instanceof
name|KeeperException
operator|.
name|InvalidACLException
condition|)
block|{
comment|// this is a security exception of a kind
comment|// include the ACLs to help the diagnostics
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"Path access failure "
argument_list|)
operator|.
name|append
argument_list|(
name|aclList
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|securityConnectionDiagnostics
argument_list|)
expr_stmt|;
name|ioe
operator|=
operator|new
name|NoPathPermissionsException
argument_list|(
name|path
argument_list|,
name|builder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ioe
operator|=
operator|new
name|RegistryIOException
argument_list|(
name|path
argument_list|,
literal|"Failure of "
operator|+
name|operation
operator|+
literal|" on "
operator|+
name|path
operator|+
literal|": "
operator|+
name|exception
operator|.
name|toString
argument_list|()
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioe
operator|.
name|getCause
argument_list|()
operator|==
literal|null
condition|)
block|{
name|ioe
operator|.
name|initCause
argument_list|(
name|exception
argument_list|)
expr_stmt|;
block|}
return|return
name|ioe
return|;
block|}
comment|/**    * Create a path if it does not exist.    * The check is poll + create; there's a risk that another process    * may create the same path before the create() operation is executed/    * propagated to the ZK node polled.    *    * @param path          path to create    * @param acl           ACL for path -used when creating a new entry    * @param createParents flag to trigger parent creation    * @return true iff the path was created    * @throws IOException    */
annotation|@
name|VisibleForTesting
DECL|method|maybeCreate (String path, CreateMode mode, List<ACL> acl, boolean createParents)
specifier|public
name|boolean
name|maybeCreate
parameter_list|(
name|String
name|path
parameter_list|,
name|CreateMode
name|mode
parameter_list|,
name|List
argument_list|<
name|ACL
argument_list|>
name|acl
parameter_list|,
name|boolean
name|createParents
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|zkMkPath
argument_list|(
name|path
argument_list|,
name|mode
argument_list|,
name|createParents
argument_list|,
name|acl
argument_list|)
return|;
block|}
comment|/**    * Stat the file.    *    * @param path path of operation    * @return a curator stat entry    * @throws IOException           on a failure    * @throws PathNotFoundException if the path was not found    */
DECL|method|zkStat (String path)
specifier|public
name|Stat
name|zkStat
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|checkServiceLive
argument_list|()
expr_stmt|;
name|String
name|fullpath
init|=
name|createFullPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|Stat
name|stat
decl_stmt|;
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Stat {}"
argument_list|,
name|fullpath
argument_list|)
expr_stmt|;
block|}
name|stat
operator|=
name|curator
operator|.
name|checkExists
argument_list|()
operator|.
name|forPath
argument_list|(
name|fullpath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|operationFailure
argument_list|(
name|fullpath
argument_list|,
literal|"read()"
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|stat
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|PathNotFoundException
argument_list|(
name|path
argument_list|)
throw|;
block|}
return|return
name|stat
return|;
block|}
comment|/**    * Get the ACLs of a path.    *    * @param path path of operation    * @return a possibly empty list of ACLs    * @throws IOException    */
DECL|method|zkGetACLS (String path)
specifier|public
name|List
argument_list|<
name|ACL
argument_list|>
name|zkGetACLS
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|checkServiceLive
argument_list|()
expr_stmt|;
name|String
name|fullpath
init|=
name|createFullPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ACL
argument_list|>
name|acls
decl_stmt|;
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"GetACLS {}"
argument_list|,
name|fullpath
argument_list|)
expr_stmt|;
block|}
name|acls
operator|=
name|curator
operator|.
name|getACL
argument_list|()
operator|.
name|forPath
argument_list|(
name|fullpath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|operationFailure
argument_list|(
name|fullpath
argument_list|,
literal|"read()"
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|acls
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|PathNotFoundException
argument_list|(
name|path
argument_list|)
throw|;
block|}
return|return
name|acls
return|;
block|}
comment|/**    * Probe for a path existing.    *    * @param path path of operation    * @return true if the path was visible from the ZK server    * queried.    * @throws IOException on any exception other than    *                     {@link PathNotFoundException}    */
DECL|method|zkPathExists (String path)
specifier|public
name|boolean
name|zkPathExists
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|checkServiceLive
argument_list|()
expr_stmt|;
try|try
block|{
comment|// if zkStat(path) returns without throwing an exception, the return value
comment|// is guaranteed to be not null
name|zkStat
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|PathNotFoundException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Verify a path exists.    *    * @param path path of operation    * @throws PathNotFoundException if the path is absent    * @throws IOException    */
DECL|method|zkPathMustExist (String path)
specifier|public
name|String
name|zkPathMustExist
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|zkStat
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
comment|/**    * Create a directory. It is not an error if it already exists.    *    * @param path          path to create    * @param mode          mode for path    * @param createParents flag to trigger parent creation    * @param acls          ACL for path    * @throws IOException any problem    */
DECL|method|zkMkPath (String path, CreateMode mode, boolean createParents, List<ACL> acls)
specifier|public
name|boolean
name|zkMkPath
parameter_list|(
name|String
name|path
parameter_list|,
name|CreateMode
name|mode
parameter_list|,
name|boolean
name|createParents
parameter_list|,
name|List
argument_list|<
name|ACL
argument_list|>
name|acls
parameter_list|)
throws|throws
name|IOException
block|{
name|checkServiceLive
argument_list|()
expr_stmt|;
name|path
operator|=
name|createFullPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|acls
operator|==
literal|null
operator|||
name|acls
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoPathPermissionsException
argument_list|(
name|path
argument_list|,
literal|"Empty ACL list"
argument_list|)
throw|;
block|}
try|try
block|{
name|RegistrySecurity
operator|.
name|AclListInfo
name|aclInfo
init|=
operator|new
name|RegistrySecurity
operator|.
name|AclListInfo
argument_list|(
name|acls
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating path {} with mode {} and ACL {}"
argument_list|,
name|path
argument_list|,
name|mode
argument_list|,
name|aclInfo
argument_list|)
expr_stmt|;
block|}
name|CreateBuilder
name|createBuilder
init|=
name|curator
operator|.
name|create
argument_list|()
decl_stmt|;
name|createBuilder
operator|.
name|withMode
argument_list|(
name|mode
argument_list|)
operator|.
name|withACL
argument_list|(
name|acls
argument_list|)
expr_stmt|;
if|if
condition|(
name|createParents
condition|)
block|{
name|createBuilder
operator|.
name|creatingParentsIfNeeded
argument_list|()
expr_stmt|;
block|}
name|createBuilder
operator|.
name|forPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NodeExistsException
name|e
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"path already present: {}"
argument_list|,
name|path
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|operationFailure
argument_list|(
name|path
argument_list|,
literal|"mkdir() "
argument_list|,
name|e
argument_list|,
name|acls
argument_list|)
throw|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Recursively make a path.    *    * @param path path to create    * @param acl  ACL for path    * @throws IOException any problem    */
DECL|method|zkMkParentPath (String path, List<ACL> acl)
specifier|public
name|void
name|zkMkParentPath
parameter_list|(
name|String
name|path
parameter_list|,
name|List
argument_list|<
name|ACL
argument_list|>
name|acl
parameter_list|)
throws|throws
name|IOException
block|{
comment|// split path into elements
name|zkMkPath
argument_list|(
name|RegistryPathUtils
operator|.
name|parentOf
argument_list|(
name|path
argument_list|)
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|,
literal|true
argument_list|,
name|acl
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a path with given data. byte[0] is used for a path    * without data.    *    * @param path path of operation    * @param data initial data    * @param acls    * @throws IOException    */
DECL|method|zkCreate (String path, CreateMode mode, byte[] data, List<ACL> acls)
specifier|public
name|void
name|zkCreate
parameter_list|(
name|String
name|path
parameter_list|,
name|CreateMode
name|mode
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
name|List
argument_list|<
name|ACL
argument_list|>
name|acls
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|data
operator|!=
literal|null
argument_list|,
literal|"null data"
argument_list|)
expr_stmt|;
name|checkServiceLive
argument_list|()
expr_stmt|;
name|String
name|fullpath
init|=
name|createFullPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating {} with {} bytes of data and ACL {}"
argument_list|,
name|fullpath
argument_list|,
name|data
operator|.
name|length
argument_list|,
operator|new
name|RegistrySecurity
operator|.
name|AclListInfo
argument_list|(
name|acls
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|curator
operator|.
name|create
argument_list|()
operator|.
name|withMode
argument_list|(
name|mode
argument_list|)
operator|.
name|withACL
argument_list|(
name|acls
argument_list|)
operator|.
name|forPath
argument_list|(
name|fullpath
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|operationFailure
argument_list|(
name|fullpath
argument_list|,
literal|"create()"
argument_list|,
name|e
argument_list|,
name|acls
argument_list|)
throw|;
block|}
block|}
comment|/**    * Update the data for a path.    *    * @param path path of operation    * @param data new data    * @throws IOException    */
DECL|method|zkUpdate (String path, byte[] data)
specifier|public
name|void
name|zkUpdate
parameter_list|(
name|String
name|path
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|data
operator|!=
literal|null
argument_list|,
literal|"null data"
argument_list|)
expr_stmt|;
name|checkServiceLive
argument_list|()
expr_stmt|;
name|path
operator|=
name|createFullPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Updating {} with {} bytes"
argument_list|,
name|path
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|curator
operator|.
name|setData
argument_list|()
operator|.
name|forPath
argument_list|(
name|path
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|operationFailure
argument_list|(
name|path
argument_list|,
literal|"update()"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Create or update an entry.    *    * @param path      path    * @param data      data    * @param acl       ACL for path -used when creating a new entry    * @param overwrite enable overwrite    * @return true if the entry was created, false if it was simply updated.    * @throws IOException    */
DECL|method|zkSet (String path, CreateMode mode, byte[] data, List<ACL> acl, boolean overwrite)
specifier|public
name|boolean
name|zkSet
parameter_list|(
name|String
name|path
parameter_list|,
name|CreateMode
name|mode
parameter_list|,
name|byte
index|[]
name|data
parameter_list|,
name|List
argument_list|<
name|ACL
argument_list|>
name|acl
parameter_list|,
name|boolean
name|overwrite
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|data
operator|!=
literal|null
argument_list|,
literal|"null data"
argument_list|)
expr_stmt|;
name|checkServiceLive
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|zkPathExists
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|zkCreate
argument_list|(
name|path
argument_list|,
name|mode
argument_list|,
name|data
argument_list|,
name|acl
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
if|if
condition|(
name|overwrite
condition|)
block|{
name|zkUpdate
argument_list|(
name|path
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
name|path
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Delete a directory/directory tree.    * It is not an error to delete a path that does not exist.    *    * @param path               path of operation    * @param recursive          flag to trigger recursive deletion    * @param backgroundCallback callback; this being set converts the operation    *                           into an async/background operation.    *                           task    * @throws IOException on problems other than no-such-path    */
DECL|method|zkDelete (String path, boolean recursive, BackgroundCallback backgroundCallback)
specifier|public
name|void
name|zkDelete
parameter_list|(
name|String
name|path
parameter_list|,
name|boolean
name|recursive
parameter_list|,
name|BackgroundCallback
name|backgroundCallback
parameter_list|)
throws|throws
name|IOException
block|{
name|checkServiceLive
argument_list|()
expr_stmt|;
name|String
name|fullpath
init|=
name|createFullPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Deleting {}"
argument_list|,
name|fullpath
argument_list|)
expr_stmt|;
block|}
name|DeleteBuilder
name|delete
init|=
name|curator
operator|.
name|delete
argument_list|()
decl_stmt|;
if|if
condition|(
name|recursive
condition|)
block|{
name|delete
operator|.
name|deletingChildrenIfNeeded
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|backgroundCallback
operator|!=
literal|null
condition|)
block|{
name|delete
operator|.
name|inBackground
argument_list|(
name|backgroundCallback
argument_list|)
expr_stmt|;
block|}
name|delete
operator|.
name|forPath
argument_list|(
name|fullpath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|e
parameter_list|)
block|{
comment|// not an error
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|operationFailure
argument_list|(
name|fullpath
argument_list|,
literal|"delete()"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * List all children of a path.    *    * @param path path of operation    * @return a possibly empty list of children    * @throws IOException    */
DECL|method|zkList (String path)
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|zkList
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|checkServiceLive
argument_list|()
expr_stmt|;
name|String
name|fullpath
init|=
name|createFullPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"ls {}"
argument_list|,
name|fullpath
argument_list|)
expr_stmt|;
block|}
name|GetChildrenBuilder
name|builder
init|=
name|curator
operator|.
name|getChildren
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|children
init|=
name|builder
operator|.
name|forPath
argument_list|(
name|fullpath
argument_list|)
decl_stmt|;
return|return
name|children
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|operationFailure
argument_list|(
name|path
argument_list|,
literal|"ls()"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Read data on a path.    *    * @param path path of operation    * @return the data    * @throws IOException read failure    */
DECL|method|zkRead (String path)
specifier|public
name|byte
index|[]
name|zkRead
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|checkServiceLive
argument_list|()
expr_stmt|;
name|String
name|fullpath
init|=
name|createFullPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reading {}"
argument_list|,
name|fullpath
argument_list|)
expr_stmt|;
block|}
return|return
name|curator
operator|.
name|getData
argument_list|()
operator|.
name|forPath
argument_list|(
name|fullpath
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|operationFailure
argument_list|(
name|fullpath
argument_list|,
literal|"read()"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Return a path dumper instance which can do a full dump    * of the registry tree in its<code>toString()</code>    * operation.    *    * @param verbose verbose flag - includes more details (such as ACLs)    * @return a class to dump the registry    */
DECL|method|dumpPath (boolean verbose)
specifier|public
name|ZKPathDumper
name|dumpPath
parameter_list|(
name|boolean
name|verbose
parameter_list|)
block|{
return|return
operator|new
name|ZKPathDumper
argument_list|(
name|curator
argument_list|,
name|registryRoot
argument_list|,
name|verbose
argument_list|)
return|;
block|}
comment|/**    * Add a new write access entry for all future write operations.    *    * @param id   ID to use    * @param pass password    * @throws IOException on any failure to build the digest    */
DECL|method|addWriteAccessor (String id, String pass)
specifier|public
name|boolean
name|addWriteAccessor
parameter_list|(
name|String
name|id
parameter_list|,
name|String
name|pass
parameter_list|)
throws|throws
name|IOException
block|{
name|RegistrySecurity
name|security
init|=
name|getRegistrySecurity
argument_list|()
decl_stmt|;
name|ACL
name|digestACL
init|=
operator|new
name|ACL
argument_list|(
name|ZooDefs
operator|.
name|Perms
operator|.
name|ALL
argument_list|,
name|security
operator|.
name|toDigestId
argument_list|(
name|security
operator|.
name|digest
argument_list|(
name|id
argument_list|,
name|pass
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|security
operator|.
name|addDigestACL
argument_list|(
name|digestACL
argument_list|)
return|;
block|}
comment|/**    * Clear all write accessors.    */
DECL|method|clearWriteAccessors ()
specifier|public
name|void
name|clearWriteAccessors
parameter_list|()
block|{
name|getRegistrySecurity
argument_list|()
operator|.
name|resetDigestACLs
argument_list|()
expr_stmt|;
block|}
comment|/**    * Diagnostics method to dump a registry robustly.    * Any exception raised is swallowed.    *    * @param verbose verbose path dump    * @return the registry tree    */
DECL|method|dumpRegistryRobustly (boolean verbose)
specifier|protected
name|String
name|dumpRegistryRobustly
parameter_list|(
name|boolean
name|verbose
parameter_list|)
block|{
try|try
block|{
name|ZKPathDumper
name|pathDumper
init|=
name|dumpPath
argument_list|(
name|verbose
argument_list|)
decl_stmt|;
return|return
name|pathDumper
operator|.
name|toString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// ignore
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring exception:  {}"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
comment|/**    * Registers a listener to path related events.    *    * @param listener the listener.    * @return a handle allowing for the management of the listener.    * @throws Exception if registration fails due to error.    */
DECL|method|registerPathListener (final PathListener listener)
specifier|public
name|ListenerHandle
name|registerPathListener
parameter_list|(
specifier|final
name|PathListener
name|listener
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|TreeCacheListener
name|pathChildrenCacheListener
init|=
operator|new
name|TreeCacheListener
argument_list|()
block|{
specifier|public
name|void
name|childEvent
parameter_list|(
name|CuratorFramework
name|curatorFramework
parameter_list|,
name|TreeCacheEvent
name|event
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|path
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|event
operator|!=
literal|null
operator|&&
name|event
operator|.
name|getData
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|path
operator|=
name|event
operator|.
name|getData
argument_list|()
operator|.
name|getPath
argument_list|()
expr_stmt|;
block|}
assert|assert
name|event
operator|!=
literal|null
assert|;
switch|switch
condition|(
name|event
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|NODE_ADDED
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Informing listener of added node {}"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|listener
operator|.
name|nodeAdded
argument_list|(
name|path
argument_list|)
expr_stmt|;
break|break;
case|case
name|NODE_REMOVED
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Informing listener of removed node {}"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|listener
operator|.
name|nodeRemoved
argument_list|(
name|path
argument_list|)
expr_stmt|;
break|break;
case|case
name|NODE_UPDATED
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Informing listener of updated node {}"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|listener
operator|.
name|nodeAdded
argument_list|(
name|path
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// do nothing
break|break;
block|}
block|}
block|}
decl_stmt|;
name|treeCache
operator|.
name|getListenable
argument_list|()
operator|.
name|addListener
argument_list|(
name|pathChildrenCacheListener
argument_list|)
expr_stmt|;
return|return
operator|new
name|ListenerHandle
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|treeCache
operator|.
name|getListenable
argument_list|()
operator|.
name|removeListener
argument_list|(
name|pathChildrenCacheListener
argument_list|)
expr_stmt|;
block|}
block|}
return|;
block|}
comment|// TODO: should caches be stopped and then restarted if need be?
comment|/**    * Create the tree cache that monitors the registry for node addition, update,    * and deletion.    *    * @throws Exception if any issue arises during monitoring.    */
DECL|method|monitorRegistryEntries ()
specifier|public
name|void
name|monitorRegistryEntries
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|registryPath
init|=
name|getConfig
argument_list|()
operator|.
name|get
argument_list|(
name|RegistryConstants
operator|.
name|KEY_REGISTRY_ZK_ROOT
argument_list|,
name|RegistryConstants
operator|.
name|DEFAULT_ZK_REGISTRY_ROOT
argument_list|)
decl_stmt|;
name|treeCache
operator|=
operator|new
name|TreeCache
argument_list|(
name|curator
argument_list|,
name|registryPath
argument_list|)
expr_stmt|;
name|treeCache
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

