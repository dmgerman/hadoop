begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.registry.server.dns
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|server
operator|.
name|dns
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|filefilter
operator|.
name|IOFileFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|net
operator|.
name|util
operator|.
name|Base64
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|net
operator|.
name|util
operator|.
name|SubnetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|api
operator|.
name|DNSOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|ServiceRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|yarn
operator|.
name|YarnRegistryAttributes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|AbstractService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|concurrent
operator|.
name|HadoopExecutors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|CNAMERecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|DClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|DNSKEYRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|DNSSEC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|DSRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|ExtendedFlags
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|ExtendedResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|Flags
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|Header
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|Lookup
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|NSRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|Name
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|NameTooLongException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|OPTRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|Opcode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|RRSIGRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|RRset
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|Rcode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|Record
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|Resolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|ResolverConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|SOARecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|Section
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|SetResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|SimpleResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|TSIG
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|TSIGRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|TextParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|xbill
operator|.
name|DNS
operator|.
name|Zone
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|NetworkInterface
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|DatagramChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ServerSocketChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|SocketChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|KeyFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchAlgorithmException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivateKey
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|spec
operator|.
name|InvalidKeySpecException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|spec
operator|.
name|RSAPrivateKeySpec
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|api
operator|.
name|RegistryConstants
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * A DNS service reflecting the state of the YARN registry.  Records are created  * based on service records available in the YARN ZK-based registry.  */
end_comment

begin_class
DECL|class|RegistryDNS
specifier|public
class|class
name|RegistryDNS
extends|extends
name|AbstractService
implements|implements
name|DNSOperations
implements|,
name|ZoneSelector
block|{
DECL|field|CONTAINER
specifier|public
specifier|static
specifier|final
name|String
name|CONTAINER
init|=
literal|"container"
decl_stmt|;
DECL|field|FLAG_DNSSECOK
specifier|static
specifier|final
name|int
name|FLAG_DNSSECOK
init|=
literal|1
decl_stmt|;
DECL|field|FLAG_SIGONLY
specifier|static
specifier|final
name|int
name|FLAG_SIGONLY
init|=
literal|2
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|RegistryDNS
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|IN_ADDR_ARPA
specifier|public
specifier|static
specifier|final
name|String
name|IN_ADDR_ARPA
init|=
literal|"in-addr.arpa."
decl_stmt|;
DECL|field|ZONE_SUFFIX
specifier|public
specifier|static
specifier|final
name|String
name|ZONE_SUFFIX
init|=
literal|".zone"
decl_stmt|;
DECL|field|executor
specifier|private
name|ExecutorService
name|executor
decl_stmt|;
DECL|field|zoneLock
specifier|private
name|ReentrantReadWriteLock
name|zoneLock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
DECL|field|readLock
specifier|private
name|CloseableLock
name|readLock
init|=
operator|new
name|CloseableLock
argument_list|(
name|zoneLock
operator|.
name|readLock
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|writeLock
specifier|private
name|CloseableLock
name|writeLock
init|=
operator|new
name|CloseableLock
argument_list|(
name|zoneLock
operator|.
name|writeLock
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|domainName
specifier|private
name|String
name|domainName
decl_stmt|;
DECL|field|ttl
specifier|private
name|long
name|ttl
init|=
literal|0L
decl_stmt|;
DECL|field|USER_NAME
specifier|private
specifier|static
specifier|final
name|Pattern
name|USER_NAME
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"/users/(\\w*)/?"
argument_list|)
decl_stmt|;
DECL|field|dnssecEnabled
specifier|private
name|Boolean
name|dnssecEnabled
decl_stmt|;
DECL|field|privateKey
specifier|private
name|PrivateKey
name|privateKey
decl_stmt|;
DECL|field|dnsKeyRecs
specifier|private
name|ConcurrentMap
argument_list|<
name|Name
argument_list|,
name|DNSKEYRecord
argument_list|>
name|dnsKeyRecs
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|zones
specifier|private
name|ConcurrentMap
argument_list|<
name|Name
argument_list|,
name|Zone
argument_list|>
name|zones
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|bindHost
specifier|private
name|Name
name|bindHost
decl_stmt|;
DECL|field|channelsInitialized
specifier|private
name|boolean
name|channelsInitialized
init|=
literal|false
decl_stmt|;
comment|/**    * Lock to update resolver only once per request.    */
DECL|field|resolverUpdateLock
specifier|private
specifier|final
name|Object
name|resolverUpdateLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|/**    * Whether resolver update has been requested.    */
DECL|field|resolverUpdateRequested
specifier|private
name|boolean
name|resolverUpdateRequested
init|=
literal|true
decl_stmt|;
comment|/**    * Construct the service.    *    * @param name service name    */
DECL|method|RegistryDNS (String name)
specifier|public
name|RegistryDNS
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|executor
operator|=
name|HadoopExecutors
operator|.
name|newCachedThreadPool
argument_list|(
operator|new
name|ThreadFactory
argument_list|()
block|{
specifier|private
name|AtomicInteger
name|counter
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|1
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|Thread
name|newThread
parameter_list|(
name|Runnable
name|r
parameter_list|)
block|{
return|return
operator|new
name|Thread
argument_list|(
name|r
argument_list|,
literal|"RegistryDNS "
operator|+
name|counter
operator|.
name|getAndIncrement
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|initializeChannels (Configuration conf)
specifier|public
name|void
name|initializeChannels
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|channelsInitialized
condition|)
block|{
return|return;
block|}
name|channelsInitialized
operator|=
literal|true
expr_stmt|;
name|int
name|port
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|KEY_DNS_PORT
argument_list|,
name|DEFAULT_DNS_PORT
argument_list|)
decl_stmt|;
name|InetAddress
name|addr
init|=
name|InetAddress
operator|.
name|getLocalHost
argument_list|()
decl_stmt|;
name|String
name|bindAddress
init|=
name|conf
operator|.
name|get
argument_list|(
name|KEY_DNS_BIND_ADDRESS
argument_list|)
decl_stmt|;
if|if
condition|(
name|bindAddress
operator|!=
literal|null
condition|)
block|{
name|addr
operator|=
name|InetAddress
operator|.
name|getByName
argument_list|(
name|bindAddress
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Opening TCP and UDP channels on {} port {}"
argument_list|,
name|addr
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|addNIOUDP
argument_list|(
name|addr
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|addNIOTCP
argument_list|(
name|addr
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
comment|/**    * Initialize registryDNS to use /etc/resolv.conf values    * as default resolvers.    */
DECL|method|updateDNSServer (Configuration conf)
specifier|private
name|void
name|updateDNSServer
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
synchronized|synchronized
init|(
name|resolverUpdateLock
init|)
block|{
if|if
condition|(
operator|!
name|resolverUpdateRequested
condition|)
block|{
return|return;
block|}
name|int
name|port
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|KEY_DNS_PORT
argument_list|,
name|DEFAULT_DNS_PORT
argument_list|)
decl_stmt|;
name|resolverUpdateRequested
operator|=
literal|false
expr_stmt|;
name|List
argument_list|<
name|InetAddress
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|InetAddress
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
comment|// If resolv.conf contains the server's own IP address,
comment|// and RegistryDNS handles the lookup.  Local IP address
comment|// must be filter out from default resolvers to prevent
comment|// self recursive loop.
if|if
condition|(
name|port
operator|!=
literal|53
condition|)
block|{
comment|// When registryDNS is not running on default port,
comment|// registryDNS can utilize local DNS server as upstream lookup.
throw|throw
operator|new
name|SocketException
argument_list|(
literal|"Bypass filtering local DNS server."
argument_list|)
throw|;
block|}
name|Enumeration
argument_list|<
name|NetworkInterface
argument_list|>
name|net
init|=
name|NetworkInterface
operator|.
name|getNetworkInterfaces
argument_list|()
decl_stmt|;
while|while
condition|(
name|net
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|NetworkInterface
name|n
init|=
operator|(
name|NetworkInterface
operator|)
name|net
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Enumeration
argument_list|<
name|InetAddress
argument_list|>
name|ee
init|=
name|n
operator|.
name|getInetAddresses
argument_list|()
decl_stmt|;
while|while
condition|(
name|ee
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|InetAddress
name|i
init|=
operator|(
name|InetAddress
operator|)
name|ee
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|list
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|SocketException
name|e
parameter_list|)
block|{       }
name|ResolverConfig
operator|.
name|refresh
argument_list|()
expr_stmt|;
name|ExtendedResolver
name|resolver
decl_stmt|;
try|try
block|{
name|resolver
operator|=
operator|new
name|ExtendedResolver
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownHostException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Can not resolve DNS servers: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|Resolver
name|check
range|:
name|resolver
operator|.
name|getResolvers
argument_list|()
control|)
block|{
if|if
condition|(
name|check
operator|instanceof
name|SimpleResolver
condition|)
block|{
name|InetAddress
name|address
init|=
operator|(
operator|(
name|SimpleResolver
operator|)
name|check
operator|)
operator|.
name|getAddress
argument_list|()
operator|.
name|getAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|list
operator|.
name|contains
argument_list|(
name|address
argument_list|)
condition|)
block|{
name|resolver
operator|.
name|deleteResolver
argument_list|(
name|check
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|check
operator|.
name|setTimeout
argument_list|(
literal|30
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Not simple resolver!!!?"
operator|+
name|check
argument_list|)
expr_stmt|;
block|}
block|}
synchronized|synchronized
init|(
name|Lookup
operator|.
name|class
init|)
block|{
name|Lookup
operator|.
name|setDefaultResolver
argument_list|(
name|resolver
argument_list|)
expr_stmt|;
name|Lookup
operator|.
name|setDefaultSearchPath
argument_list|(
name|ResolverConfig
operator|.
name|getCurrentConfig
argument_list|()
operator|.
name|searchPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|StringBuilder
name|message
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|"DNS servers: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ResolverConfig
operator|.
name|getCurrentConfig
argument_list|()
operator|.
name|servers
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|server
range|:
name|ResolverConfig
operator|.
name|getCurrentConfig
argument_list|()
operator|.
name|servers
argument_list|()
control|)
block|{
name|message
operator|.
name|append
argument_list|(
name|server
argument_list|)
expr_stmt|;
name|message
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
name|message
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Initializes the registry.    *    * @param conf the hadoop configuration    * @throws Exception if there are tcp/udp issues    */
annotation|@
name|Override
DECL|method|serviceInit (Configuration conf)
specifier|protected
name|void
name|serviceInit
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
name|super
operator|.
name|serviceInit
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// create the zone.  for now create a "dummy" SOA record
try|try
block|{
name|updateDNSServer
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|setDomainName
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|initializeZones
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|initializeChannels
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error initializing Registry DNS Server"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Initializes the registry based on available parameters in the hadoop    * configuration.    *    * @param conf the hadoop configuration    * @return the listener port    * @throws IOException    */
DECL|method|initializeZones (Configuration conf)
name|void
name|initializeZones
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|ttl
operator|=
name|conf
operator|.
name|getTimeDuration
argument_list|(
name|KEY_DNS_TTL
argument_list|,
literal|1L
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
name|RecordCreatorFactory
operator|.
name|setTtl
argument_list|(
name|ttl
argument_list|)
expr_stmt|;
name|setDNSSECEnabled
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|initializeZonesFromFiles
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|Zone
name|registryZone
init|=
name|configureZone
argument_list|(
name|Name
operator|.
name|fromString
argument_list|(
name|domainName
argument_list|)
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|zones
operator|.
name|put
argument_list|(
name|registryZone
operator|.
name|getOrigin
argument_list|()
argument_list|,
name|registryZone
argument_list|)
expr_stmt|;
name|initializeReverseLookupZone
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"DNS zones: "
argument_list|)
operator|.
name|append
argument_list|(
name|System
operator|.
name|lineSeparator
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Name
argument_list|,
name|Zone
argument_list|>
name|entry
range|:
name|zones
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|System
operator|.
name|lineSeparator
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|builder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Signs zone records if necessary (DNSSEC enabled).  Zones may not have    * their NS and SOA records signed if they were initialized from master files.    */
DECL|method|signZones ()
specifier|private
name|void
name|signZones
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|isDNSSECEnabled
argument_list|()
condition|)
block|{
name|Collection
argument_list|<
name|Zone
argument_list|>
name|zoneCollection
init|=
name|zones
operator|.
name|values
argument_list|()
decl_stmt|;
for|for
control|(
name|Zone
name|zone
range|:
name|zoneCollection
control|)
block|{
name|Iterator
name|itor
init|=
name|zone
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|itor
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|RRset
name|rRset
init|=
operator|(
name|RRset
operator|)
name|itor
operator|.
name|next
argument_list|()
decl_stmt|;
name|Iterator
name|sigs
init|=
name|rRset
operator|.
name|sigs
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|sigs
operator|.
name|hasNext
argument_list|()
condition|)
block|{
try|try
block|{
name|signSiteRecord
argument_list|(
name|zone
argument_list|,
name|rRset
operator|.
name|first
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DNSSEC
operator|.
name|DNSSECException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/**    * Initializes a zone by reading any zone file by the same name in the    * designated zone file directory.    *    * @param conf the Hadoop configuration object.    * @throws IOException    */
DECL|method|initializeZonesFromFiles (Configuration conf)
specifier|private
name|void
name|initializeZonesFromFiles
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// should this be in HDFS?
name|String
name|zonesDir
init|=
name|conf
operator|.
name|get
argument_list|(
name|KEY_DNS_ZONES_DIR
argument_list|)
decl_stmt|;
if|if
condition|(
name|zonesDir
operator|!=
literal|null
condition|)
block|{
name|Iterator
argument_list|<
name|File
argument_list|>
name|iterator
init|=
name|FileUtils
operator|.
name|iterateFiles
argument_list|(
operator|new
name|File
argument_list|(
name|zonesDir
argument_list|)
argument_list|,
operator|new
name|IOFileFilter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|accept
parameter_list|(
name|File
name|file
parameter_list|)
block|{
return|return
name|file
operator|.
name|getName
argument_list|()
operator|.
name|endsWith
argument_list|(
name|ZONE_SUFFIX
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|accept
parameter_list|(
name|File
name|file
parameter_list|,
name|String
name|s
parameter_list|)
block|{
return|return
name|s
operator|.
name|endsWith
argument_list|(
name|ZONE_SUFFIX
argument_list|)
return|;
block|}
block|}
argument_list|,
literal|null
argument_list|)
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|File
name|file
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|file
operator|.
name|getName
argument_list|()
decl_stmt|;
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|name
operator|.
name|indexOf
argument_list|(
name|ZONE_SUFFIX
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Zone
name|zone
init|=
operator|new
name|SecureableZone
argument_list|(
name|Name
operator|.
name|fromString
argument_list|(
name|name
argument_list|)
argument_list|,
name|file
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
decl_stmt|;
name|zones
operator|.
name|putIfAbsent
argument_list|(
name|zone
operator|.
name|getOrigin
argument_list|()
argument_list|,
name|zone
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Return the number of zones in the map.    *    * @return number of zones in the map    */
annotation|@
name|VisibleForTesting
DECL|method|getZoneCount ()
specifier|protected
name|int
name|getZoneCount
parameter_list|()
block|{
return|return
name|zones
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Initializes the reverse lookup zone (mapping IP to name).    *    * @param conf the Hadoop configuration.    * @throws IOException if the DNSSEC key can not be read.    */
DECL|method|initializeReverseLookupZone (Configuration conf)
specifier|private
name|void
name|initializeReverseLookupZone
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Determine if the subnet should be split into
comment|// multiple reverse zones, this can be necessary in
comment|// network configurations where the hosts and containers
comment|// are part of the same subnet (i.e. the containers only use
comment|// part of the subnet).
name|Boolean
name|shouldSplitReverseZone
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|KEY_DNS_SPLIT_REVERSE_ZONE
argument_list|,
name|DEFAULT_DNS_SPLIT_REVERSE_ZONE
argument_list|)
decl_stmt|;
if|if
condition|(
name|shouldSplitReverseZone
condition|)
block|{
name|int
name|subnetCount
init|=
name|ReverseZoneUtils
operator|.
name|getSubnetCountForReverseZones
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|addSplitReverseZones
argument_list|(
name|conf
argument_list|,
name|subnetCount
argument_list|)
expr_stmt|;
comment|// Single reverse zone
block|}
else|else
block|{
name|Name
name|reverseLookupZoneName
init|=
name|getReverseZoneName
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|reverseLookupZoneName
operator|==
literal|null
condition|)
block|{
comment|// reverse lookup disabled
return|return;
block|}
name|Zone
name|reverseLookupZone
init|=
name|configureZone
argument_list|(
name|reverseLookupZoneName
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|zones
operator|.
name|put
argument_list|(
name|reverseLookupZone
operator|.
name|getOrigin
argument_list|()
argument_list|,
name|reverseLookupZone
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Create the zones based on the zone count.    *    * @param conf        the Hadoop configuration.    * @param subnetCount number of subnets to create reverse zones for.    * @throws IOException if the DNSSEC key can not be read.    */
annotation|@
name|VisibleForTesting
DECL|method|addSplitReverseZones (Configuration conf, int subnetCount)
specifier|protected
name|void
name|addSplitReverseZones
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|int
name|subnetCount
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|subnet
init|=
name|conf
operator|.
name|get
argument_list|(
name|KEY_DNS_ZONE_SUBNET
argument_list|)
decl_stmt|;
name|String
name|range
init|=
name|conf
operator|.
name|get
argument_list|(
name|KEY_DNS_SPLIT_REVERSE_ZONE_RANGE
argument_list|)
decl_stmt|;
comment|// Add the split reverse zones
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|subnetCount
condition|;
name|idx
operator|++
control|)
block|{
name|Name
name|reverseLookupZoneName
init|=
name|getReverseZoneName
argument_list|(
name|ReverseZoneUtils
operator|.
name|getReverseZoneNetworkAddress
argument_list|(
name|subnet
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|range
argument_list|)
argument_list|,
name|idx
argument_list|)
argument_list|)
decl_stmt|;
name|Zone
name|reverseLookupZone
init|=
name|configureZone
argument_list|(
name|reverseLookupZoneName
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|zones
operator|.
name|put
argument_list|(
name|reverseLookupZone
operator|.
name|getOrigin
argument_list|()
argument_list|,
name|reverseLookupZone
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Returns the list of reverse lookup zones.    *    * @param conf the hadoop configuration.    * @return the list of reverse zone names required based on the configuration    * properties.    */
DECL|method|getReverseZoneName (Configuration conf)
specifier|protected
name|Name
name|getReverseZoneName
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|Name
name|name
init|=
literal|null
decl_stmt|;
name|String
name|zoneSubnet
init|=
name|getZoneSubnet
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|zoneSubnet
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Zone subnet is not configured.  Reverse lookups disabled"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// is there a netmask
name|String
name|mask
init|=
name|conf
operator|.
name|get
argument_list|(
name|KEY_DNS_ZONE_MASK
argument_list|)
decl_stmt|;
if|if
condition|(
name|mask
operator|!=
literal|null
condition|)
block|{
comment|// get the range of IPs
name|SubnetUtils
name|utils
init|=
operator|new
name|SubnetUtils
argument_list|(
name|zoneSubnet
argument_list|,
name|mask
argument_list|)
decl_stmt|;
name|name
operator|=
name|getReverseZoneName
argument_list|(
name|utils
argument_list|,
name|zoneSubnet
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|getReverseZoneName
argument_list|(
name|zoneSubnet
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|name
return|;
block|}
comment|/**    * Return the subnet for the zone.  this should be a network address for the    * subnet (ends in ".0").    *    * @param conf the hadoop configuration.    * @return the zone subnet.    */
DECL|method|getZoneSubnet (Configuration conf)
specifier|private
name|String
name|getZoneSubnet
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|subnet
init|=
name|conf
operator|.
name|get
argument_list|(
name|KEY_DNS_ZONE_SUBNET
argument_list|)
decl_stmt|;
if|if
condition|(
name|subnet
operator|!=
literal|null
condition|)
block|{
specifier|final
name|String
index|[]
name|bytes
init|=
name|subnet
operator|.
name|split
argument_list|(
literal|"\\."
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes
operator|.
name|length
operator|==
literal|3
condition|)
block|{
name|subnet
operator|+=
literal|".0"
expr_stmt|;
block|}
block|}
return|return
name|subnet
return|;
block|}
comment|/**    * Return the reverse zone name based on the address.    *    * @param networkAddress the network address.    * @return the reverse zone name.    */
DECL|method|getReverseZoneName (String networkAddress)
specifier|private
name|Name
name|getReverseZoneName
parameter_list|(
name|String
name|networkAddress
parameter_list|)
block|{
return|return
name|getReverseZoneName
argument_list|(
literal|null
argument_list|,
name|networkAddress
argument_list|)
return|;
block|}
comment|/**    * Return the reverse zone name based on the address.    *    * @param utils          subnet utils    * @param networkAddress the network address.    * @return the reverse zone name.    */
DECL|method|getReverseZoneName (SubnetUtils utils, String networkAddress)
specifier|private
name|Name
name|getReverseZoneName
parameter_list|(
name|SubnetUtils
name|utils
parameter_list|,
name|String
name|networkAddress
parameter_list|)
block|{
name|Name
name|reverseZoneName
init|=
literal|null
decl_stmt|;
name|boolean
name|isLargeNetwork
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|utils
operator|!=
literal|null
condition|)
block|{
name|isLargeNetwork
operator|=
name|utils
operator|.
name|getInfo
argument_list|()
operator|.
name|getAddressCount
argument_list|()
operator|>
literal|256
expr_stmt|;
block|}
specifier|final
name|String
index|[]
name|bytes
init|=
name|networkAddress
operator|.
name|split
argument_list|(
literal|"\\."
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes
operator|.
name|length
operator|==
literal|4
condition|)
block|{
name|String
name|reverseLookupZoneName
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isLargeNetwork
condition|)
block|{
name|reverseLookupZoneName
operator|=
name|String
operator|.
name|format
argument_list|(
literal|"%s.%s.%s"
argument_list|,
name|bytes
index|[
literal|1
index|]
argument_list|,
name|bytes
index|[
literal|0
index|]
argument_list|,
name|IN_ADDR_ARPA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reverseLookupZoneName
operator|=
name|String
operator|.
name|format
argument_list|(
literal|"%s.%s.%s.%s"
argument_list|,
name|bytes
index|[
literal|2
index|]
argument_list|,
name|bytes
index|[
literal|1
index|]
argument_list|,
name|bytes
index|[
literal|0
index|]
argument_list|,
name|IN_ADDR_ARPA
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|reverseZoneName
operator|=
name|Name
operator|.
name|fromString
argument_list|(
name|reverseLookupZoneName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TextParseException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to convert {} to DNS name"
argument_list|,
name|reverseLookupZoneName
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|reverseZoneName
return|;
block|}
comment|/**    * Create the zone and its related zone associated DNS records  (NS, SOA).    *    * @param zoneName domain name of the zone    * @param conf     configuration reference.    * @return the zone.    * @throws IOException    */
DECL|method|configureZone (Name zoneName, Configuration conf)
specifier|private
name|Zone
name|configureZone
parameter_list|(
name|Name
name|zoneName
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|bindHost
operator|=
name|Name
operator|.
name|fromString
argument_list|(
name|InetAddress
operator|.
name|getLocalHost
argument_list|()
operator|.
name|getCanonicalHostName
argument_list|()
operator|+
literal|"."
argument_list|)
expr_stmt|;
name|SOARecord
name|soaRecord
init|=
operator|new
name|SOARecord
argument_list|(
name|zoneName
argument_list|,
name|DClass
operator|.
name|IN
argument_list|,
name|ttl
argument_list|,
name|bindHost
argument_list|,
name|bindHost
argument_list|,
name|getSerial
argument_list|()
argument_list|,
literal|86000
argument_list|,
literal|7200
argument_list|,
literal|1209600
argument_list|,
literal|600
argument_list|)
decl_stmt|;
name|NSRecord
name|nsRecord
init|=
operator|new
name|NSRecord
argument_list|(
name|zoneName
argument_list|,
name|DClass
operator|.
name|IN
argument_list|,
name|ttl
argument_list|,
name|bindHost
argument_list|)
decl_stmt|;
name|Zone
name|zone
init|=
name|zones
operator|.
name|get
argument_list|(
name|zoneName
argument_list|)
decl_stmt|;
if|if
condition|(
name|zone
operator|==
literal|null
condition|)
block|{
name|zone
operator|=
operator|new
name|SecureableZone
argument_list|(
name|zoneName
argument_list|,
operator|new
name|Record
index|[]
block|{
name|soaRecord
block|,
name|nsRecord
block|}
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|enableDNSSECIfNecessary
argument_list|(
name|zone
argument_list|,
name|conf
argument_list|,
name|soaRecord
argument_list|,
name|nsRecord
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InvalidKeySpecException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|DNSSEC
operator|.
name|DNSSECException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|zone
return|;
block|}
comment|/**    * Return a serial number based on the current date and time.    *    * @return the serial number.    */
DECL|method|getSerial ()
specifier|private
name|long
name|getSerial
parameter_list|()
block|{
name|Date
name|curDate
init|=
operator|new
name|Date
argument_list|()
decl_stmt|;
name|SimpleDateFormat
name|simpleDateFormat
init|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"yyyyMMddHH"
argument_list|)
decl_stmt|;
name|String
name|serial
init|=
name|simpleDateFormat
operator|.
name|format
argument_list|(
name|curDate
argument_list|)
decl_stmt|;
return|return
name|Long
operator|.
name|parseLong
argument_list|(
name|serial
argument_list|)
return|;
block|}
comment|/**    * Set the value of the DNSSEC enabled property.    *    * @param conf the Hadoop configuration.    */
annotation|@
name|VisibleForTesting
DECL|method|setDNSSECEnabled (Configuration conf)
specifier|protected
name|void
name|setDNSSECEnabled
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|dnssecEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|KEY_DNSSEC_ENABLED
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Is DNSSEC enabled?    *    * @return true if enabled, false otherwise.    */
DECL|method|isDNSSECEnabled ()
specifier|private
name|boolean
name|isDNSSECEnabled
parameter_list|()
block|{
return|return
name|dnssecEnabled
return|;
block|}
comment|/**    * Load the required public/private keys, create the zone DNSKEY record, and    * sign the zone level records.    *    * @param zone      the zone.    * @param conf      the configuration.    * @param soaRecord the SOA record.    * @param nsRecord  the NS record.    * @throws IOException    * @throws NoSuchAlgorithmException    * @throws InvalidKeySpecException    * @throws DNSSEC.DNSSECException    */
DECL|method|enableDNSSECIfNecessary (Zone zone, Configuration conf, SOARecord soaRecord, NSRecord nsRecord)
specifier|private
name|void
name|enableDNSSECIfNecessary
parameter_list|(
name|Zone
name|zone
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|SOARecord
name|soaRecord
parameter_list|,
name|NSRecord
name|nsRecord
parameter_list|)
throws|throws
name|IOException
throws|,
name|NoSuchAlgorithmException
throws|,
name|InvalidKeySpecException
throws|,
name|DNSSEC
operator|.
name|DNSSECException
block|{
if|if
condition|(
name|isDNSSECEnabled
argument_list|()
condition|)
block|{
comment|// read in the DNSKEY and create the DNSKEYRecord
comment|// TODO:  reading these out of config seems wrong...
name|String
name|publicKey
init|=
name|conf
operator|.
name|get
argument_list|(
name|KEY_DNSSEC_PUBLIC_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|publicKey
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"DNSSEC Key not configured"
argument_list|)
throw|;
block|}
comment|//TODO - perhaps read in actual DNSKEY record structure?
name|Name
name|zoneName
init|=
name|zone
operator|.
name|getOrigin
argument_list|()
decl_stmt|;
name|DNSKEYRecord
name|dnskeyRecord
init|=
name|dnsKeyRecs
operator|.
name|get
argument_list|(
name|zoneName
argument_list|)
decl_stmt|;
if|if
condition|(
name|dnskeyRecord
operator|==
literal|null
condition|)
block|{
name|byte
index|[]
name|key
init|=
name|Base64
operator|.
name|decodeBase64
argument_list|(
name|publicKey
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
decl_stmt|;
name|dnskeyRecord
operator|=
operator|new
name|DNSKEYRecord
argument_list|(
name|zoneName
argument_list|,
name|DClass
operator|.
name|IN
argument_list|,
name|ttl
argument_list|,
name|DNSKEYRecord
operator|.
name|Flags
operator|.
name|ZONE_KEY
argument_list|,
name|DNSKEYRecord
operator|.
name|Protocol
operator|.
name|DNSSEC
argument_list|,
name|DNSSEC
operator|.
name|Algorithm
operator|.
name|RSASHA256
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|dnsKeyRecs
operator|.
name|putIfAbsent
argument_list|(
name|zoneName
argument_list|,
name|dnskeyRecord
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Registering {}"
argument_list|,
name|dnskeyRecord
argument_list|)
expr_stmt|;
try|try
init|(
name|CloseableLock
name|lock
init|=
name|writeLock
operator|.
name|lock
argument_list|()
init|)
block|{
name|zone
operator|.
name|addRecord
argument_list|(
name|dnskeyRecord
argument_list|)
expr_stmt|;
name|String
name|privateKeyFile
init|=
name|conf
operator|.
name|get
argument_list|(
name|KEY_DNSSEC_PRIVATE_KEY_FILE
argument_list|,
name|DEFAULT_DNSSEC_PRIVATE_KEY_FILE
argument_list|)
decl_stmt|;
name|Properties
name|props
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
try|try
init|(
name|FileInputStream
name|inputStream
init|=
operator|new
name|FileInputStream
argument_list|(
name|privateKeyFile
argument_list|)
init|)
block|{
name|props
operator|.
name|load
argument_list|(
name|inputStream
argument_list|)
expr_stmt|;
block|}
name|String
name|privateModulus
init|=
name|props
operator|.
name|getProperty
argument_list|(
literal|"Modulus"
argument_list|)
decl_stmt|;
name|String
name|privateExponent
init|=
name|props
operator|.
name|getProperty
argument_list|(
literal|"PrivateExponent"
argument_list|)
decl_stmt|;
name|RSAPrivateKeySpec
name|privateSpec
init|=
operator|new
name|RSAPrivateKeySpec
argument_list|(
operator|new
name|BigInteger
argument_list|(
literal|1
argument_list|,
name|Base64
operator|.
name|decodeBase64
argument_list|(
name|privateModulus
argument_list|)
argument_list|)
argument_list|,
operator|new
name|BigInteger
argument_list|(
literal|1
argument_list|,
name|Base64
operator|.
name|decodeBase64
argument_list|(
name|privateExponent
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|KeyFactory
name|factory
init|=
name|KeyFactory
operator|.
name|getInstance
argument_list|(
literal|"RSA"
argument_list|)
decl_stmt|;
name|privateKey
operator|=
name|factory
operator|.
name|generatePrivate
argument_list|(
name|privateSpec
argument_list|)
expr_stmt|;
name|signSiteRecord
argument_list|(
name|zone
argument_list|,
name|dnskeyRecord
argument_list|)
expr_stmt|;
name|signSiteRecord
argument_list|(
name|zone
argument_list|,
name|soaRecord
argument_list|)
expr_stmt|;
name|signSiteRecord
argument_list|(
name|zone
argument_list|,
name|nsRecord
argument_list|)
expr_stmt|;
block|}
comment|// create required DS records
comment|// domain
comment|//      DSRecord dsRecord = new DSRecord(zoneName, DClass.IN, ttl,
comment|//                                       DSRecord.Digest.SHA1, dnskeyRecord);
comment|//      zone.addRecord(dsRecord);
comment|//      signSiteRecord(zone, dsRecord);
block|}
block|}
comment|/**    * Sign a DNS record.    *    * @param zone   the zone reference    * @param record the record to sign.    * @throws DNSSEC.DNSSECException    */
DECL|method|signSiteRecord (Zone zone, Record record)
specifier|private
name|void
name|signSiteRecord
parameter_list|(
name|Zone
name|zone
parameter_list|,
name|Record
name|record
parameter_list|)
throws|throws
name|DNSSEC
operator|.
name|DNSSECException
block|{
name|RRset
name|rrset
init|=
name|zone
operator|.
name|findExactMatch
argument_list|(
name|record
operator|.
name|getName
argument_list|()
argument_list|,
name|record
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
name|Calendar
name|cal
init|=
name|Calendar
operator|.
name|getInstance
argument_list|()
decl_stmt|;
name|Date
name|inception
init|=
name|cal
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|cal
operator|.
name|add
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Date
name|expiration
init|=
name|cal
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|RRSIGRecord
name|rrsigRecord
init|=
name|DNSSEC
operator|.
name|sign
argument_list|(
name|rrset
argument_list|,
name|dnsKeyRecs
operator|.
name|get
argument_list|(
name|zone
operator|.
name|getOrigin
argument_list|()
argument_list|)
argument_list|,
name|privateKey
argument_list|,
name|inception
argument_list|,
name|expiration
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding {}"
argument_list|,
name|record
argument_list|)
expr_stmt|;
name|rrset
operator|.
name|addRR
argument_list|(
name|rrsigRecord
argument_list|)
expr_stmt|;
block|}
comment|/**    * Sets the zone/domain name.  The name will be read from the configuration    * and the code will ensure the name is absolute.    *    * @param conf the configuration.    * @throws IOException    */
DECL|method|setDomainName (Configuration conf)
name|void
name|setDomainName
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|domainName
operator|=
name|conf
operator|.
name|get
argument_list|(
name|KEY_DNS_DOMAIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|domainName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No DNS domain name specified"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|domainName
operator|.
name|endsWith
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
name|domainName
operator|+=
literal|"."
expr_stmt|;
block|}
block|}
comment|/**    * Stops the registry.    *    * @throws Exception if the service stop generates an issue.    */
annotation|@
name|Override
DECL|method|serviceStop ()
specifier|protected
name|void
name|serviceStop
parameter_list|()
throws|throws
name|Exception
block|{
name|stopExecutor
argument_list|()
expr_stmt|;
name|super
operator|.
name|serviceStop
argument_list|()
expr_stmt|;
block|}
comment|/**    * Shuts down the leveraged executor service.    */
DECL|method|stopExecutor ()
specifier|protected
specifier|synchronized
name|void
name|stopExecutor
parameter_list|()
block|{
if|if
condition|(
name|executor
operator|!=
literal|null
condition|)
block|{
name|executor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Creates a DNS error response.    *    * @param in the byte array detailing the error.    * @return the error message, in bytes    */
DECL|method|formErrorMessage (byte[] in)
specifier|public
name|byte
index|[]
name|formErrorMessage
parameter_list|(
name|byte
index|[]
name|in
parameter_list|)
block|{
name|Header
name|header
decl_stmt|;
try|try
block|{
name|header
operator|=
operator|new
name|Header
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|buildErrorMessage
argument_list|(
name|header
argument_list|,
name|Rcode
operator|.
name|FORMERR
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Process a TCP request.    *    * @param ch the socket channel for the request.    * @throws IOException if the tcp processing generates an issue.    */
DECL|method|nioTCPClient (SocketChannel ch)
specifier|public
name|void
name|nioTCPClient
parameter_list|(
name|SocketChannel
name|ch
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
comment|// query sizes are small, so the following two lines should work
comment|// in all instances
name|ByteBuffer
name|buf
init|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
literal|1024
argument_list|)
decl_stmt|;
name|ch
operator|.
name|read
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|.
name|flip
argument_list|()
expr_stmt|;
name|int
name|messageLength
init|=
name|getMessgeLength
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|byte
index|[]
name|in
init|=
operator|new
name|byte
index|[
name|messageLength
index|]
decl_stmt|;
name|buf
operator|.
name|get
argument_list|(
name|in
argument_list|,
literal|0
argument_list|,
name|messageLength
argument_list|)
expr_stmt|;
name|Message
name|query
decl_stmt|;
name|byte
index|[]
name|response
decl_stmt|;
try|try
block|{
name|query
operator|=
operator|new
name|Message
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"received TCP query {}"
argument_list|,
name|query
operator|.
name|getQuestion
argument_list|()
argument_list|)
expr_stmt|;
name|response
operator|=
name|generateReply
argument_list|(
name|query
argument_list|,
name|ch
operator|.
name|socket
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|==
literal|null
condition|)
block|{
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|response
operator|=
name|formErrorMessage
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
name|ByteBuffer
name|out
init|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|response
operator|.
name|length
operator|+
literal|2
argument_list|)
decl_stmt|;
name|out
operator|.
name|clear
argument_list|()
expr_stmt|;
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
literal|2
index|]
decl_stmt|;
name|data
index|[
literal|1
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|response
operator|.
name|length
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|response
operator|.
name|length
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|out
operator|.
name|put
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|out
operator|.
name|put
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|out
operator|.
name|flip
argument_list|()
expr_stmt|;
while|while
condition|(
name|out
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
name|ch
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|NetUtils
operator|.
name|wrapException
argument_list|(
name|ch
operator|.
name|socket
argument_list|()
operator|.
name|getInetAddress
argument_list|()
operator|.
name|getHostName
argument_list|()
argument_list|,
name|ch
operator|.
name|socket
argument_list|()
operator|.
name|getPort
argument_list|()
argument_list|,
name|ch
operator|.
name|socket
argument_list|()
operator|.
name|getLocalAddress
argument_list|()
operator|.
name|getHostName
argument_list|()
argument_list|,
name|ch
operator|.
name|socket
argument_list|()
operator|.
name|getLocalPort
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Calculate the inbound message length, which is related in the message as an    * unsigned short value.    *    * @param buf the byte buffer containing the message.    * @return the message length    * @throws EOFException    */
DECL|method|getMessgeLength (ByteBuffer buf)
specifier|private
name|int
name|getMessgeLength
parameter_list|(
name|ByteBuffer
name|buf
parameter_list|)
throws|throws
name|EOFException
block|{
name|int
name|ch1
init|=
name|buf
operator|.
name|get
argument_list|()
decl_stmt|;
name|int
name|ch2
init|=
name|buf
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|ch1
operator||
name|ch2
operator|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|()
throw|;
block|}
return|return
operator|(
name|ch1
operator|<<
literal|8
operator|)
operator|+
operator|(
name|ch2
operator|&
literal|0xff
operator|)
return|;
block|}
comment|/**    * Monitor the TCP socket for inbound requests.    *    * @param serverSocketChannel the server socket channel    * @param addr                the local inet address    * @param port                the listener (local) port    * @throws Exception if the tcp processing fails.    */
DECL|method|serveNIOTCP (ServerSocketChannel serverSocketChannel, InetAddress addr, int port)
specifier|public
name|void
name|serveNIOTCP
parameter_list|(
name|ServerSocketChannel
name|serverSocketChannel
parameter_list|,
name|InetAddress
name|addr
parameter_list|,
name|int
name|port
parameter_list|)
throws|throws
name|Exception
block|{
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|SocketChannel
name|socketChannel
init|=
name|serverSocketChannel
operator|.
name|accept
argument_list|()
decl_stmt|;
if|if
condition|(
name|socketChannel
operator|!=
literal|null
condition|)
block|{
name|executor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|nioTCPClient
argument_list|(
name|socketChannel
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|500
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|NetUtils
operator|.
name|wrapException
argument_list|(
name|addr
operator|.
name|getHostName
argument_list|()
argument_list|,
name|port
argument_list|,
name|addr
operator|.
name|getHostName
argument_list|()
argument_list|,
name|port
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Open the TCP listener.    *    * @param addr the host address.    * @param port the host port.    * @return the created server socket channel.    * @throws IOException    */
DECL|method|openTCPChannel (InetAddress addr, int port)
specifier|private
name|ServerSocketChannel
name|openTCPChannel
parameter_list|(
name|InetAddress
name|addr
parameter_list|,
name|int
name|port
parameter_list|)
throws|throws
name|IOException
block|{
name|ServerSocketChannel
name|serverSocketChannel
init|=
name|ServerSocketChannel
operator|.
name|open
argument_list|()
decl_stmt|;
try|try
block|{
name|serverSocketChannel
operator|.
name|socket
argument_list|()
operator|.
name|bind
argument_list|(
operator|new
name|InetSocketAddress
argument_list|(
name|addr
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|serverSocketChannel
operator|.
name|configureBlocking
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|NetUtils
operator|.
name|wrapException
argument_list|(
literal|null
argument_list|,
literal|0
argument_list|,
name|InetAddress
operator|.
name|getLocalHost
argument_list|()
operator|.
name|getHostName
argument_list|()
argument_list|,
name|port
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|serverSocketChannel
return|;
block|}
comment|/**    * Create the thread (Callable) monitoring the TCP listener.    *    * @param addr host address.    * @param port host port.    * @throws Exception if the tcp listener generates an error.    */
DECL|method|addNIOTCP (final InetAddress addr, final int port)
specifier|public
name|void
name|addNIOTCP
parameter_list|(
specifier|final
name|InetAddress
name|addr
parameter_list|,
specifier|final
name|int
name|port
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|ServerSocketChannel
name|tcpChannel
init|=
name|openTCPChannel
argument_list|(
name|addr
argument_list|,
name|port
argument_list|)
decl_stmt|;
name|executor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|call
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|serveNIOTCP
argument_list|(
name|tcpChannel
argument_list|,
name|addr
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error initializing DNS TCP listener"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create the thread monitoring the socket for inbound UDP requests.    *    * @param addr host address.    * @param port host port.    * @throws Exception if the UDP listener creation generates an error.    */
DECL|method|addNIOUDP (final InetAddress addr, final int port)
specifier|public
name|void
name|addNIOUDP
parameter_list|(
specifier|final
name|InetAddress
name|addr
parameter_list|,
specifier|final
name|int
name|port
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|DatagramChannel
name|udpChannel
init|=
name|openUDPChannel
argument_list|(
name|addr
argument_list|,
name|port
argument_list|)
decl_stmt|;
name|executor
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|call
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
name|serveNIOUDP
argument_list|(
name|udpChannel
argument_list|,
name|addr
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error initializing DNS UDP listener"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
literal|true
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Process an inbound UDP request.    *    * @param channel the UDP datagram channel.    * @param addr    local host address.    * @param port    local port.    * @throws IOException if the UDP processing fails.    */
DECL|method|serveNIOUDP (DatagramChannel channel, InetAddress addr, int port)
specifier|private
name|void
name|serveNIOUDP
parameter_list|(
name|DatagramChannel
name|channel
parameter_list|,
name|InetAddress
name|addr
parameter_list|,
name|int
name|port
parameter_list|)
throws|throws
name|Exception
block|{
name|SocketAddress
name|remoteAddress
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ByteBuffer
name|input
init|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
literal|4096
argument_list|)
decl_stmt|;
name|ByteBuffer
name|output
init|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
literal|4096
argument_list|)
decl_stmt|;
name|byte
index|[]
name|in
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|input
operator|.
name|clear
argument_list|()
expr_stmt|;
try|try
block|{
name|remoteAddress
operator|=
name|channel
operator|.
name|receive
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Error during message receipt"
argument_list|,
name|e
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Message
name|query
decl_stmt|;
name|byte
index|[]
name|response
init|=
literal|null
decl_stmt|;
try|try
block|{
name|int
name|position
init|=
name|input
operator|.
name|position
argument_list|()
decl_stmt|;
name|in
operator|=
operator|new
name|byte
index|[
name|position
index|]
expr_stmt|;
name|input
operator|.
name|flip
argument_list|()
expr_stmt|;
name|input
operator|.
name|get
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|query
operator|=
operator|new
name|Message
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{}: received UDP query {}"
argument_list|,
name|remoteAddress
argument_list|,
name|query
operator|.
name|getQuestion
argument_list|()
argument_list|)
expr_stmt|;
name|response
operator|=
name|generateReply
argument_list|(
name|query
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|response
operator|=
name|formErrorMessage
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|clear
argument_list|()
expr_stmt|;
name|output
operator|.
name|put
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|output
operator|.
name|flip
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"{}:  sending response"
argument_list|,
name|remoteAddress
argument_list|)
expr_stmt|;
name|channel
operator|.
name|send
argument_list|(
name|output
argument_list|,
name|remoteAddress
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|IOException
operator|&&
name|remoteAddress
operator|!=
literal|null
condition|)
block|{
throw|throw
name|NetUtils
operator|.
name|wrapException
argument_list|(
name|addr
operator|.
name|getHostName
argument_list|()
argument_list|,
name|port
argument_list|,
operator|(
operator|(
name|InetSocketAddress
operator|)
name|remoteAddress
operator|)
operator|.
name|getHostName
argument_list|()
argument_list|,
operator|(
operator|(
name|InetSocketAddress
operator|)
name|remoteAddress
operator|)
operator|.
name|getPort
argument_list|()
argument_list|,
operator|(
name|IOException
operator|)
name|e
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
block|}
comment|/**    * Create and UDP listener socket.    *    * @param addr host address.    * @param port host port.    * @return    * @throws IOException if listener creation fails.    */
DECL|method|openUDPChannel (InetAddress addr, int port)
specifier|private
name|DatagramChannel
name|openUDPChannel
parameter_list|(
name|InetAddress
name|addr
parameter_list|,
name|int
name|port
parameter_list|)
throws|throws
name|IOException
block|{
name|DatagramChannel
name|channel
init|=
name|DatagramChannel
operator|.
name|open
argument_list|()
decl_stmt|;
try|try
block|{
name|channel
operator|.
name|socket
argument_list|()
operator|.
name|bind
argument_list|(
operator|new
name|InetSocketAddress
argument_list|(
name|addr
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
name|NetUtils
operator|.
name|wrapException
argument_list|(
literal|null
argument_list|,
literal|0
argument_list|,
name|InetAddress
operator|.
name|getLocalHost
argument_list|()
operator|.
name|getHostName
argument_list|()
argument_list|,
name|port
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|channel
return|;
block|}
comment|/**    * Create an error message.    *    * @param header   the response header.    * @param rcode    the response code.    * @param question the question record.    * @return  the error message.    */
DECL|method|buildErrorMessage (Header header, int rcode, Record question)
name|byte
index|[]
name|buildErrorMessage
parameter_list|(
name|Header
name|header
parameter_list|,
name|int
name|rcode
parameter_list|,
name|Record
name|question
parameter_list|)
block|{
name|Message
name|response
init|=
operator|new
name|Message
argument_list|()
decl_stmt|;
name|response
operator|.
name|setHeader
argument_list|(
name|header
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|response
operator|.
name|removeAllRecords
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|response
operator|.
name|addRecord
argument_list|(
name|question
argument_list|,
name|Section
operator|.
name|QUESTION
argument_list|)
expr_stmt|;
name|header
operator|.
name|setRcode
argument_list|(
name|rcode
argument_list|)
expr_stmt|;
return|return
name|response
operator|.
name|toWire
argument_list|()
return|;
block|}
comment|/**    * Generate an error message based on inbound query.    *    * @param query the query.    * @param rcode the response code for the specific error.    * @return the error message.    */
DECL|method|errorMessage (Message query, int rcode)
specifier|public
name|byte
index|[]
name|errorMessage
parameter_list|(
name|Message
name|query
parameter_list|,
name|int
name|rcode
parameter_list|)
block|{
return|return
name|buildErrorMessage
argument_list|(
name|query
operator|.
name|getHeader
argument_list|()
argument_list|,
name|rcode
argument_list|,
name|query
operator|.
name|getQuestion
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Generate the response for the inbound DNS query.    *    * @param query the query.    * @param s     the socket associated with the query.    * @return the response, in bytes.    * @throws IOException if reply generation fails.    */
DECL|method|generateReply (Message query, Socket s)
name|byte
index|[]
name|generateReply
parameter_list|(
name|Message
name|query
parameter_list|,
name|Socket
name|s
parameter_list|)
throws|throws
name|IOException
block|{
name|Header
name|header
decl_stmt|;
name|boolean
name|badversion
decl_stmt|;
name|int
name|maxLength
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|OPTRecord
name|queryOPT
init|=
name|query
operator|.
name|getOPT
argument_list|()
decl_stmt|;
name|maxLength
operator|=
name|getMaxLength
argument_list|(
name|s
argument_list|,
name|queryOPT
argument_list|)
expr_stmt|;
name|header
operator|=
name|query
operator|.
name|getHeader
argument_list|()
expr_stmt|;
if|if
condition|(
name|header
operator|.
name|getFlag
argument_list|(
name|Flags
operator|.
name|QR
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"returning null"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|header
operator|.
name|getRcode
argument_list|()
operator|!=
name|Rcode
operator|.
name|NOERROR
condition|)
block|{
return|return
name|errorMessage
argument_list|(
name|query
argument_list|,
name|Rcode
operator|.
name|FORMERR
argument_list|)
return|;
block|}
if|if
condition|(
name|header
operator|.
name|getOpcode
argument_list|()
operator|!=
name|Opcode
operator|.
name|QUERY
condition|)
block|{
return|return
name|errorMessage
argument_list|(
name|query
argument_list|,
name|Rcode
operator|.
name|NOTIMP
argument_list|)
return|;
block|}
name|Record
name|queryRecord
init|=
name|query
operator|.
name|getQuestion
argument_list|()
decl_stmt|;
if|if
condition|(
name|queryOPT
operator|!=
literal|null
operator|&&
operator|(
name|queryOPT
operator|.
name|getFlags
argument_list|()
operator|&
name|ExtendedFlags
operator|.
name|DO
operator|)
operator|!=
literal|0
condition|)
block|{
name|flags
operator|=
name|FLAG_DNSSECOK
expr_stmt|;
block|}
name|Message
name|response
init|=
operator|new
name|Message
argument_list|(
name|query
operator|.
name|getHeader
argument_list|()
operator|.
name|getID
argument_list|()
argument_list|)
decl_stmt|;
name|response
operator|.
name|getHeader
argument_list|()
operator|.
name|setFlag
argument_list|(
name|Flags
operator|.
name|QR
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
operator|.
name|getHeader
argument_list|()
operator|.
name|getFlag
argument_list|(
name|Flags
operator|.
name|RD
argument_list|)
condition|)
block|{
name|response
operator|.
name|getHeader
argument_list|()
operator|.
name|setFlag
argument_list|(
name|Flags
operator|.
name|RD
argument_list|)
expr_stmt|;
name|response
operator|.
name|getHeader
argument_list|()
operator|.
name|setFlag
argument_list|(
name|Flags
operator|.
name|RA
argument_list|)
expr_stmt|;
block|}
name|response
operator|.
name|addRecord
argument_list|(
name|queryRecord
argument_list|,
name|Section
operator|.
name|QUESTION
argument_list|)
expr_stmt|;
name|Name
name|name
init|=
name|queryRecord
operator|.
name|getName
argument_list|()
decl_stmt|;
name|int
name|type
init|=
name|queryRecord
operator|.
name|getType
argument_list|()
decl_stmt|;
name|int
name|dclass
init|=
name|queryRecord
operator|.
name|getDClass
argument_list|()
decl_stmt|;
name|TSIGRecord
name|queryTSIG
init|=
name|query
operator|.
name|getTSIG
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|Type
operator|.
name|AXFR
operator|&&
name|s
operator|!=
literal|null
condition|)
block|{
return|return
name|doAXFR
argument_list|(
name|name
argument_list|,
name|query
argument_list|,
literal|null
argument_list|,
name|queryTSIG
argument_list|,
name|s
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|Type
operator|.
name|isRR
argument_list|(
name|type
argument_list|)
operator|&&
name|type
operator|!=
name|Type
operator|.
name|ANY
condition|)
block|{
return|return
name|errorMessage
argument_list|(
name|query
argument_list|,
name|Rcode
operator|.
name|NOTIMP
argument_list|)
return|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"calling addAnswer"
argument_list|)
expr_stmt|;
name|byte
name|rcode
init|=
name|addAnswer
argument_list|(
name|response
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|dclass
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
decl_stmt|;
if|if
condition|(
name|rcode
operator|!=
name|Rcode
operator|.
name|NOERROR
condition|)
block|{
name|rcode
operator|=
name|remoteLookup
argument_list|(
name|response
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|response
operator|.
name|getHeader
argument_list|()
operator|.
name|setRcode
argument_list|(
name|rcode
argument_list|)
expr_stmt|;
block|}
name|addAdditional
argument_list|(
name|response
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|queryOPT
operator|!=
literal|null
condition|)
block|{
name|int
name|optflags
init|=
operator|(
name|flags
operator|==
name|FLAG_DNSSECOK
operator|)
condition|?
name|ExtendedFlags
operator|.
name|DO
else|:
literal|0
decl_stmt|;
name|OPTRecord
name|opt
init|=
operator|new
name|OPTRecord
argument_list|(
operator|(
name|short
operator|)
literal|4096
argument_list|,
name|rcode
operator|>>>
literal|16
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|,
name|optflags
argument_list|)
decl_stmt|;
name|response
operator|.
name|addRecord
argument_list|(
name|opt
argument_list|,
name|Section
operator|.
name|ADDITIONAL
argument_list|)
expr_stmt|;
block|}
return|return
name|response
operator|.
name|toWire
argument_list|(
name|maxLength
argument_list|)
return|;
block|}
comment|/**    * Lookup record from upstream DNS servers.    */
DECL|method|remoteLookup (Message response, Name name)
specifier|private
name|byte
name|remoteLookup
parameter_list|(
name|Message
name|response
parameter_list|,
name|Name
name|name
parameter_list|)
block|{
comment|// Forward lookup to primary DNS servers
name|Record
index|[]
name|answers
init|=
name|getRecords
argument_list|(
name|name
argument_list|,
name|Type
operator|.
name|ANY
argument_list|)
decl_stmt|;
try|try
block|{
for|for
control|(
name|Record
name|r
range|:
name|answers
control|)
block|{
if|if
condition|(
name|r
operator|.
name|getType
argument_list|()
operator|==
name|Type
operator|.
name|SOA
condition|)
block|{
name|response
operator|.
name|addRecord
argument_list|(
name|r
argument_list|,
name|Section
operator|.
name|AUTHORITY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|response
operator|.
name|addRecord
argument_list|(
name|r
argument_list|,
name|Section
operator|.
name|ANSWER
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|NullPointerException
name|e
parameter_list|)
block|{
return|return
name|Rcode
operator|.
name|NXDOMAIN
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
return|return
name|Rcode
operator|.
name|SERVFAIL
return|;
block|}
return|return
name|Rcode
operator|.
name|NOERROR
return|;
block|}
comment|/**    * Requests records for the given resource name.    *    * @param name - query string    * @param type - type of DNS record to lookup    * @return DNS records    */
DECL|method|getRecords (Name name, int type)
specifier|protected
name|Record
index|[]
name|getRecords
parameter_list|(
name|Name
name|name
parameter_list|,
name|int
name|type
parameter_list|)
block|{
try|try
block|{
return|return
operator|new
name|Lookup
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
operator|.
name|run
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|NullPointerException
decl||
name|ExceptionInInitializerError
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Fail to lookup: "
operator|+
name|name
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Create a query to forward to the primary DNS server (if configured).    * NOTE:  Experimental    *    * @param query the inbound query.    * @return the query to forward to the primary server.    * @throws NameTooLongException    * @throws TextParseException if query creation fails.    */
DECL|method|createPrimaryQuery (Message query)
specifier|private
name|Message
name|createPrimaryQuery
parameter_list|(
name|Message
name|query
parameter_list|)
throws|throws
name|NameTooLongException
throws|,
name|TextParseException
block|{
name|Name
name|name
init|=
name|query
operator|.
name|getQuestion
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|labels
argument_list|()
operator|>
literal|0
operator|&&
name|name
operator|.
name|labels
argument_list|()
operator|<=
literal|2
condition|)
block|{
comment|// short relative or absolute name.  this code may not be necessary -
comment|// OS resolution utilities probably append the search paths defined
comment|// in resolv.conf prior to the lookup
name|int
name|id
init|=
name|query
operator|.
name|getHeader
argument_list|()
operator|.
name|getID
argument_list|()
decl_stmt|;
name|String
name|queryName
init|=
name|name
operator|.
name|getLabelString
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Name
name|qualifiedName
init|=
name|Name
operator|.
name|concatenate
argument_list|(
name|Name
operator|.
name|fromString
argument_list|(
name|queryName
argument_list|)
argument_list|,
name|Name
operator|.
name|fromString
argument_list|(
name|domainName
argument_list|)
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Received query {}.  Forwarding query {}"
argument_list|,
name|name
argument_list|,
name|qualifiedName
argument_list|)
expr_stmt|;
name|Record
name|question
init|=
name|Record
operator|.
name|newRecord
argument_list|(
name|qualifiedName
argument_list|,
name|query
operator|.
name|getQuestion
argument_list|()
operator|.
name|getType
argument_list|()
argument_list|,
name|query
operator|.
name|getQuestion
argument_list|()
operator|.
name|getDClass
argument_list|()
argument_list|)
decl_stmt|;
name|query
operator|=
name|Message
operator|.
name|newQuery
argument_list|(
name|question
argument_list|)
expr_stmt|;
name|query
operator|.
name|getHeader
argument_list|()
operator|.
name|setID
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
return|return
name|query
return|;
block|}
comment|/**    * Calculate the max length for a response.    *    * @param s        the request socket.    * @param queryOPT describes Extended DNS (EDNS) properties of a Message.    * @return  the length of the response.    */
DECL|method|getMaxLength (Socket s, OPTRecord queryOPT)
specifier|private
name|int
name|getMaxLength
parameter_list|(
name|Socket
name|s
parameter_list|,
name|OPTRecord
name|queryOPT
parameter_list|)
block|{
name|int
name|maxLength
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|maxLength
operator|=
literal|65535
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|queryOPT
operator|!=
literal|null
condition|)
block|{
name|maxLength
operator|=
name|Math
operator|.
name|max
argument_list|(
name|queryOPT
operator|.
name|getPayloadSize
argument_list|()
argument_list|,
literal|512
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|maxLength
operator|=
literal|512
expr_stmt|;
block|}
return|return
name|maxLength
return|;
block|}
comment|/**    * Add additional information to a DNS response section if a glue name is    * specified.    *    * @param response the response message.    * @param section  the section of the response (e.g. ANSWER, AUTHORITY)    * @param flags the flags.    */
DECL|method|addAdditional2 (Message response, int section, int flags)
specifier|private
name|void
name|addAdditional2
parameter_list|(
name|Message
name|response
parameter_list|,
name|int
name|section
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|Record
index|[]
name|records
init|=
name|response
operator|.
name|getSectionArray
argument_list|(
name|section
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|records
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Record
name|r
init|=
name|records
index|[
name|i
index|]
decl_stmt|;
name|Name
name|glueName
init|=
name|r
operator|.
name|getAdditionalName
argument_list|()
decl_stmt|;
if|if
condition|(
name|glueName
operator|!=
literal|null
condition|)
block|{
name|addGlue
argument_list|(
name|response
argument_list|,
name|glueName
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Process any additional records indicated for both the ANSWER and AUTHORITY    * sections of the response.    *    * @param response the response message.    * @param flags the flags.    */
DECL|method|addAdditional (Message response, int flags)
specifier|private
name|void
name|addAdditional
parameter_list|(
name|Message
name|response
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|addAdditional2
argument_list|(
name|response
argument_list|,
name|Section
operator|.
name|ANSWER
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|addAdditional2
argument_list|(
name|response
argument_list|,
name|Section
operator|.
name|AUTHORITY
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the specific record indicated by the "glue", or the mapping to a    * specific host.    *    * @param response the response message.    * @param name     the name of the glue record.    * @param flags    the flags.    */
DECL|method|addGlue (Message response, Name name, int flags)
specifier|private
name|void
name|addGlue
parameter_list|(
name|Message
name|response
parameter_list|,
name|Name
name|name
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|RRset
name|a
init|=
name|findExactMatch
argument_list|(
name|name
argument_list|,
name|Type
operator|.
name|A
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|addRRset
argument_list|(
name|name
argument_list|,
name|response
argument_list|,
name|a
argument_list|,
name|Section
operator|.
name|ADDITIONAL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/**    * Find the record set that matches the requested name and type.    *    * @param name the requested name.    * @param type the record type.    * @return the set of records with the given name and type.    */
DECL|method|findExactMatch (Name name, int type)
specifier|public
name|RRset
name|findExactMatch
parameter_list|(
name|Name
name|name
parameter_list|,
name|int
name|type
parameter_list|)
block|{
try|try
init|(
name|CloseableLock
name|lock
init|=
name|readLock
operator|.
name|lock
argument_list|()
init|)
block|{
name|Zone
name|zone
init|=
name|findBestZone
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|zone
operator|!=
literal|null
condition|)
block|{
return|return
name|zone
operator|.
name|findExactMatch
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Find the zone that correlates to the provided name.    *    * @param name the name to be matched to a zone.    * @return the zone.    */
DECL|method|findBestZone (Name name)
annotation|@
name|Override
specifier|public
name|Zone
name|findBestZone
parameter_list|(
name|Name
name|name
parameter_list|)
block|{
name|Zone
name|foundzone
init|=
literal|null
decl_stmt|;
name|foundzone
operator|=
name|zones
operator|.
name|get
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundzone
operator|!=
literal|null
condition|)
block|{
return|return
name|foundzone
return|;
block|}
name|int
name|labels
init|=
name|name
operator|.
name|labels
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|labels
condition|;
name|i
operator|++
control|)
block|{
name|Name
name|tname
init|=
operator|new
name|Name
argument_list|(
name|name
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|foundzone
operator|=
name|zones
operator|.
name|get
argument_list|(
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|foundzone
operator|!=
literal|null
condition|)
block|{
return|return
name|foundzone
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Add the answer section to the response.    *    * @param response   the response message.    * @param name       the name of the answer record.    * @param type       the type of record.    * @param dclass     the DNS class.    * @param iterations iteration count.    * @param flags    * @return the response code.    */
DECL|method|addAnswer (Message response, Name name, int type, int dclass, int iterations, int flags)
name|byte
name|addAnswer
parameter_list|(
name|Message
name|response
parameter_list|,
name|Name
name|name
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|dclass
parameter_list|,
name|int
name|iterations
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|SetResponse
name|sr
init|=
literal|null
decl_stmt|;
name|byte
name|rcode
init|=
name|Rcode
operator|.
name|NOERROR
decl_stmt|;
if|if
condition|(
name|iterations
operator|>
literal|6
condition|)
block|{
return|return
name|Rcode
operator|.
name|NOERROR
return|;
block|}
if|if
condition|(
name|type
operator|==
name|Type
operator|.
name|SIG
operator|||
name|type
operator|==
name|Type
operator|.
name|RRSIG
condition|)
block|{
name|type
operator|=
name|Type
operator|.
name|ANY
expr_stmt|;
name|flags
operator||=
name|FLAG_SIGONLY
expr_stmt|;
block|}
name|Zone
name|zone
init|=
name|findBestZone
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"finding record"
argument_list|)
expr_stmt|;
try|try
init|(
name|CloseableLock
name|lock
init|=
name|readLock
operator|.
name|lock
argument_list|()
init|)
block|{
if|if
condition|(
name|zone
operator|!=
literal|null
condition|)
block|{
name|sr
operator|=
name|zone
operator|.
name|findRecords
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rcode
operator|=
name|Rcode
operator|.
name|NOTAUTH
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"found local record? {}"
argument_list|,
name|sr
operator|!=
literal|null
operator|&&
name|sr
operator|.
name|isSuccessful
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|sr
operator|.
name|isCNAME
argument_list|()
condition|)
block|{
name|CNAMERecord
name|cname
init|=
name|sr
operator|.
name|getCNAME
argument_list|()
decl_stmt|;
name|RRset
name|rrset
init|=
name|zone
operator|.
name|findExactMatch
argument_list|(
name|cname
operator|.
name|getName
argument_list|()
argument_list|,
name|Type
operator|.
name|CNAME
argument_list|)
decl_stmt|;
name|addRRset
argument_list|(
name|name
argument_list|,
name|response
argument_list|,
name|rrset
argument_list|,
name|Section
operator|.
name|ANSWER
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|iterations
operator|==
literal|0
condition|)
block|{
name|response
operator|.
name|getHeader
argument_list|()
operator|.
name|setFlag
argument_list|(
name|Flags
operator|.
name|AA
argument_list|)
expr_stmt|;
block|}
name|rcode
operator|=
name|addAnswer
argument_list|(
name|response
argument_list|,
name|cname
operator|.
name|getTarget
argument_list|()
argument_list|,
name|type
argument_list|,
name|dclass
argument_list|,
name|iterations
operator|+
literal|1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sr
operator|.
name|isNXDOMAIN
argument_list|()
condition|)
block|{
name|response
operator|.
name|getHeader
argument_list|()
operator|.
name|setRcode
argument_list|(
name|Rcode
operator|.
name|NXDOMAIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDNSSECEnabled
argument_list|()
condition|)
block|{
try|try
block|{
name|addNXT
argument_list|(
name|response
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to add NXTRecord to AUTHORITY Section"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|addSOA
argument_list|(
name|response
argument_list|,
name|zone
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|iterations
operator|==
literal|0
condition|)
block|{
name|response
operator|.
name|getHeader
argument_list|()
operator|.
name|setFlag
argument_list|(
name|Flags
operator|.
name|AA
argument_list|)
expr_stmt|;
block|}
name|rcode
operator|=
name|Rcode
operator|.
name|NXDOMAIN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sr
operator|.
name|isNXRRSET
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No data found the given name {} and type {}"
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|addSOA
argument_list|(
name|response
argument_list|,
name|zone
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|iterations
operator|==
literal|0
condition|)
block|{
name|response
operator|.
name|getHeader
argument_list|()
operator|.
name|setFlag
argument_list|(
name|Flags
operator|.
name|AA
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sr
operator|.
name|isSuccessful
argument_list|()
condition|)
block|{
name|RRset
index|[]
name|rrsets
init|=
name|sr
operator|.
name|answers
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"found answers {}"
argument_list|,
name|rrsets
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rrsets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|addRRset
argument_list|(
name|name
argument_list|,
name|response
argument_list|,
name|rrsets
index|[
name|i
index|]
argument_list|,
name|Section
operator|.
name|ANSWER
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|addNS
argument_list|(
name|response
argument_list|,
name|zone
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|iterations
operator|==
literal|0
condition|)
block|{
name|response
operator|.
name|getHeader
argument_list|()
operator|.
name|setFlag
argument_list|(
name|Flags
operator|.
name|AA
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|zone
operator|!=
literal|null
condition|)
block|{
name|Name
name|defaultDomain
init|=
literal|null
decl_stmt|;
try|try
block|{
name|defaultDomain
operator|=
name|Name
operator|.
name|fromString
argument_list|(
name|domainName
argument_list|)
expr_stmt|;
name|zone
operator|=
name|zones
operator|.
name|get
argument_list|(
name|defaultDomain
argument_list|)
expr_stmt|;
name|addNS
argument_list|(
name|response
argument_list|,
name|zone
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|iterations
operator|==
literal|0
condition|)
block|{
name|response
operator|.
name|getHeader
argument_list|()
operator|.
name|setFlag
argument_list|(
name|Flags
operator|.
name|AA
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|TextParseException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to obtain default zone for unknown name response"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|rcode
return|;
block|}
comment|/**    * Add the SOA record (describes the properties of the zone) to the authority    * section of the response.    *    * @param response the response message.    * @param zone     the DNS zone.    */
DECL|method|addSOA (Message response, Zone zone, int flags)
specifier|private
name|void
name|addSOA
parameter_list|(
name|Message
name|response
parameter_list|,
name|Zone
name|zone
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|RRset
name|soa
init|=
name|zone
operator|.
name|findExactMatch
argument_list|(
name|zone
operator|.
name|getOrigin
argument_list|()
argument_list|,
name|Type
operator|.
name|SOA
argument_list|)
decl_stmt|;
name|addRRset
argument_list|(
name|soa
operator|.
name|getName
argument_list|()
argument_list|,
name|response
argument_list|,
name|soa
argument_list|,
name|Section
operator|.
name|AUTHORITY
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the NXT record to the authority    * section of the response.    *    * @param response the response message.    */
DECL|method|addNXT (Message response, int flags)
specifier|private
name|void
name|addNXT
parameter_list|(
name|Message
name|response
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|DNSSEC
operator|.
name|DNSSECException
throws|,
name|IOException
block|{
name|Record
name|nxtRecord
init|=
name|getNXTRecord
argument_list|(
name|response
operator|.
name|getSectionArray
argument_list|(
name|Section
operator|.
name|QUESTION
argument_list|)
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|Zone
name|zone
init|=
name|findBestZone
argument_list|(
name|nxtRecord
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|addRecordCommand
operator|.
name|exec
argument_list|(
name|zone
argument_list|,
name|nxtRecord
argument_list|)
expr_stmt|;
name|RRset
name|nxtRR
init|=
name|zone
operator|.
name|findExactMatch
argument_list|(
name|nxtRecord
operator|.
name|getName
argument_list|()
argument_list|,
name|Type
operator|.
name|NXT
argument_list|)
decl_stmt|;
name|addRRset
argument_list|(
name|nxtRecord
operator|.
name|getName
argument_list|()
argument_list|,
name|response
argument_list|,
name|nxtRR
argument_list|,
name|Section
operator|.
name|AUTHORITY
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|removeRecordCommand
operator|.
name|exec
argument_list|(
name|zone
argument_list|,
name|nxtRecord
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return an NXT record required to validate negative responses.  If there is    * an issue returning the NXT record, a SOA record will be returned.    *    * @param query the query record.    * @return an NXT record.    */
DECL|method|getNXTRecord (Record query)
specifier|private
name|Record
name|getNXTRecord
parameter_list|(
name|Record
name|query
parameter_list|)
block|{
name|Record
name|response
init|=
literal|null
decl_stmt|;
name|SecureableZone
name|zone
init|=
operator|(
name|SecureableZone
operator|)
name|findBestZone
argument_list|(
name|query
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|zone
operator|!=
literal|null
condition|)
block|{
name|response
operator|=
name|zone
operator|.
name|getNXTRecord
argument_list|(
name|query
argument_list|,
name|zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|==
literal|null
condition|)
block|{
name|response
operator|=
name|zone
operator|.
name|getSOA
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|response
return|;
block|}
comment|/**    * Add the name server info to the authority section.    *    * @param response the response message.    * @param zone     the DNS zone.    * @param flags    the flags.    */
DECL|method|addNS (Message response, Zone zone, int flags)
specifier|private
name|void
name|addNS
parameter_list|(
name|Message
name|response
parameter_list|,
name|Zone
name|zone
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|RRset
name|nsRecords
init|=
name|zone
operator|.
name|getNS
argument_list|()
decl_stmt|;
name|addRRset
argument_list|(
name|nsRecords
operator|.
name|getName
argument_list|()
argument_list|,
name|response
argument_list|,
name|nsRecords
argument_list|,
name|Section
operator|.
name|AUTHORITY
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add the provided record set to the response section specified.    *    * @param name     the name associated with the record set.    * @param response the response message.    * @param rrset    the record set.    * @param section  the response section to which the record set will be added.    * @param flags    the flags.    */
DECL|method|addRRset (Name name, Message response, RRset rrset, int section, int flags)
specifier|private
name|void
name|addRRset
parameter_list|(
name|Name
name|name
parameter_list|,
name|Message
name|response
parameter_list|,
name|RRset
name|rrset
parameter_list|,
name|int
name|section
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
for|for
control|(
name|int
name|s
init|=
literal|1
init|;
name|s
operator|<=
name|section
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|response
operator|.
name|findRRset
argument_list|(
name|name
argument_list|,
name|rrset
operator|.
name|getType
argument_list|()
argument_list|,
name|s
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|FLAG_SIGONLY
operator|)
operator|==
literal|0
condition|)
block|{
name|Iterator
name|it
init|=
name|rrset
operator|.
name|rrs
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Record
name|r
init|=
operator|(
name|Record
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|getName
argument_list|()
operator|.
name|isWild
argument_list|()
operator|&&
operator|!
name|name
operator|.
name|isWild
argument_list|()
condition|)
block|{
name|r
operator|=
name|r
operator|.
name|withName
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|response
operator|.
name|addRecord
argument_list|(
name|r
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|FLAG_SIGONLY
operator||
name|FLAG_DNSSECOK
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|Iterator
name|it
init|=
name|rrset
operator|.
name|sigs
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Record
name|r
init|=
operator|(
name|Record
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|.
name|getName
argument_list|()
operator|.
name|isWild
argument_list|()
operator|&&
operator|!
name|name
operator|.
name|isWild
argument_list|()
condition|)
block|{
name|r
operator|=
name|r
operator|.
name|withName
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|response
operator|.
name|addRecord
argument_list|(
name|r
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Perform a zone transfer.    *    * @param name  the zone name.    * @param query the query.    * @param tsig  the query signature.    * @param qtsig the signature record.    * @param s     the connection socket.    * @return      an error message if there is no matching zone    * or null due to error.    */
DECL|method|doAXFR (Name name, Message query, TSIG tsig, TSIGRecord qtsig, Socket s)
name|byte
index|[]
name|doAXFR
parameter_list|(
name|Name
name|name
parameter_list|,
name|Message
name|query
parameter_list|,
name|TSIG
name|tsig
parameter_list|,
name|TSIGRecord
name|qtsig
parameter_list|,
name|Socket
name|s
parameter_list|)
block|{
name|boolean
name|first
init|=
literal|true
decl_stmt|;
name|Zone
name|zone
init|=
name|findBestZone
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|zone
operator|==
literal|null
condition|)
block|{
return|return
name|errorMessage
argument_list|(
name|query
argument_list|,
name|Rcode
operator|.
name|REFUSED
argument_list|)
return|;
block|}
name|Iterator
name|it
init|=
name|zone
operator|.
name|AXFR
argument_list|()
decl_stmt|;
try|try
block|{
name|DataOutputStream
name|dataOut
decl_stmt|;
name|dataOut
operator|=
operator|new
name|DataOutputStream
argument_list|(
name|s
operator|.
name|getOutputStream
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|id
init|=
name|query
operator|.
name|getHeader
argument_list|()
operator|.
name|getID
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|RRset
name|rrset
init|=
operator|(
name|RRset
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|Message
name|response
init|=
operator|new
name|Message
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|Header
name|header
init|=
name|response
operator|.
name|getHeader
argument_list|()
decl_stmt|;
name|header
operator|.
name|setFlag
argument_list|(
name|Flags
operator|.
name|QR
argument_list|)
expr_stmt|;
name|header
operator|.
name|setFlag
argument_list|(
name|Flags
operator|.
name|AA
argument_list|)
expr_stmt|;
name|addRRset
argument_list|(
name|rrset
operator|.
name|getName
argument_list|()
argument_list|,
name|response
argument_list|,
name|rrset
argument_list|,
name|Section
operator|.
name|ANSWER
argument_list|,
name|FLAG_DNSSECOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsig
operator|!=
literal|null
condition|)
block|{
name|tsig
operator|.
name|applyStream
argument_list|(
name|response
argument_list|,
name|qtsig
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|qtsig
operator|=
name|response
operator|.
name|getTSIG
argument_list|()
expr_stmt|;
block|}
name|first
operator|=
literal|false
expr_stmt|;
name|byte
index|[]
name|out
init|=
name|response
operator|.
name|toWire
argument_list|()
decl_stmt|;
name|dataOut
operator|.
name|writeShort
argument_list|(
name|out
operator|.
name|length
argument_list|)
expr_stmt|;
name|dataOut
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"AXFR failed"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|s
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{     }
return|return
literal|null
return|;
block|}
comment|/**    * Perform the registry operation (register or delete).  This method will take    * the provided service record and either add or remove the DNS records    * indicated.    *    * @param path    the ZK path for the service record.    * @param record  the service record.    * @param command the registry command (REGISTER or DELETE).    * @throws IOException if the is an error performing registry operation.    */
DECL|method|op (String path, ServiceRecord record, RegistryCommand command)
specifier|private
name|void
name|op
parameter_list|(
name|String
name|path
parameter_list|,
name|ServiceRecord
name|record
parameter_list|,
name|RegistryCommand
name|command
parameter_list|)
throws|throws
name|IOException
block|{
name|ServiceRecordProcessor
name|processor
decl_stmt|;
try|try
block|{
name|String
name|yarnPersistanceValue
init|=
name|record
operator|.
name|get
argument_list|(
name|YarnRegistryAttributes
operator|.
name|YARN_PERSISTENCE
argument_list|)
decl_stmt|;
if|if
condition|(
name|yarnPersistanceValue
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|yarnPersistanceValue
operator|.
name|equals
argument_list|(
name|CONTAINER
argument_list|)
condition|)
block|{
comment|// container registration.  the logic to identify and create the
comment|// container entry needs to be enhanced/more accurate and associate
comment|// to correct host
name|processor
operator|=
operator|new
name|ContainerServiceRecordProcessor
argument_list|(
name|record
argument_list|,
name|path
argument_list|,
name|domainName
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating ApplicationServiceRecordProcessor for {}"
argument_list|,
name|yarnPersistanceValue
argument_list|)
expr_stmt|;
name|processor
operator|=
operator|new
name|ApplicationServiceRecordProcessor
argument_list|(
name|record
argument_list|,
name|path
argument_list|,
name|domainName
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|processor
operator|.
name|manageDNSRecords
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Yarn Registry record {} does not contain {} attribute "
argument_list|,
name|record
operator|.
name|toString
argument_list|()
argument_list|,
name|YarnRegistryAttributes
operator|.
name|YARN_PERSISTENCE
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Return the username found in the ZK path.    *    * @param path the ZK path.    * @return the user name.    */
DECL|method|getUsername (String path)
specifier|private
name|String
name|getUsername
parameter_list|(
name|String
name|path
parameter_list|)
block|{
name|String
name|user
init|=
literal|"anonymous"
decl_stmt|;
name|Matcher
name|matcher
init|=
name|USER_NAME
operator|.
name|matcher
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
name|user
operator|=
name|matcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|user
return|;
block|}
comment|/**    * Register DNS records based on the provided service record.    *    * @param path   the ZK path of the service record.    * @param record record providing DNS registration info.    * @throws IOException if registration causes an error.    */
annotation|@
name|Override
DECL|method|register (String path, ServiceRecord record)
specifier|public
name|void
name|register
parameter_list|(
name|String
name|path
parameter_list|,
name|ServiceRecord
name|record
parameter_list|)
throws|throws
name|IOException
block|{
name|op
argument_list|(
name|path
argument_list|,
name|record
argument_list|,
name|addRecordCommand
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete the DNS records generated by the provided service record.    *    * @param path   the ZK path for the given record.    * @param record the service record    * @throws IOException if deletion causes and error.    */
annotation|@
name|Override
DECL|method|delete (String path, ServiceRecord record)
specifier|public
name|void
name|delete
parameter_list|(
name|String
name|path
parameter_list|,
name|ServiceRecord
name|record
parameter_list|)
throws|throws
name|IOException
block|{
name|op
argument_list|(
name|path
argument_list|,
name|record
argument_list|,
name|removeRecordCommand
argument_list|)
expr_stmt|;
block|}
comment|/**    * An interface representing a registry associated function/command (see    * command pattern).    */
DECL|interface|RegistryCommand
interface|interface
name|RegistryCommand
block|{
DECL|method|exec (Zone zone, Record record)
name|void
name|exec
parameter_list|(
name|Zone
name|zone
parameter_list|,
name|Record
name|record
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|getLogDescription ()
name|String
name|getLogDescription
parameter_list|()
function_decl|;
block|}
comment|/**    * The "add record" command.    */
DECL|field|addRecordCommand
specifier|private
specifier|final
name|RegistryCommand
name|addRecordCommand
init|=
operator|new
name|RegistryCommand
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|exec
parameter_list|(
name|Zone
name|zone
parameter_list|,
name|Record
name|record
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|zone
operator|!=
literal|null
condition|)
block|{
try|try
init|(
name|CloseableLock
name|lock
init|=
name|writeLock
operator|.
name|lock
argument_list|()
init|)
block|{
name|zone
operator|.
name|addRecord
argument_list|(
name|record
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Registered {}"
argument_list|,
name|record
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDNSSECEnabled
argument_list|()
condition|)
block|{
name|Calendar
name|cal
init|=
name|Calendar
operator|.
name|getInstance
argument_list|()
decl_stmt|;
name|Date
name|inception
init|=
name|cal
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|cal
operator|.
name|add
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Date
name|expiration
init|=
name|cal
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|RRset
name|rRset
init|=
name|zone
operator|.
name|findExactMatch
argument_list|(
name|record
operator|.
name|getName
argument_list|()
argument_list|,
name|record
operator|.
name|getType
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|DNSKEYRecord
name|dnskeyRecord
init|=
name|dnsKeyRecs
operator|.
name|get
argument_list|(
name|zone
operator|.
name|getOrigin
argument_list|()
argument_list|)
decl_stmt|;
name|RRSIGRecord
name|rrsigRecord
init|=
name|DNSSEC
operator|.
name|sign
argument_list|(
name|rRset
argument_list|,
name|dnskeyRecord
argument_list|,
name|privateKey
argument_list|,
name|inception
argument_list|,
name|expiration
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding {}"
argument_list|,
name|rrsigRecord
argument_list|)
expr_stmt|;
name|rRset
operator|.
name|addRR
argument_list|(
name|rrsigRecord
argument_list|)
expr_stmt|;
comment|//addDSRecord(zone, record.getName(), record.getDClass(),
comment|//  record.getTTL(), inception, expiration);
block|}
catch|catch
parameter_list|(
name|DNSSEC
operator|.
name|DNSSECException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to find zone matching record {}"
argument_list|,
name|record
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Add a DS record associated with the input name.      * @param zone  the zone.      * @param name  the record name.      * @param dClass the DNS class.      * @param dsTtl the ttl value.      * @param inception  the time of inception of the record.      * @param expiration  the expiry time of the record.      * @throws DNSSEC.DNSSECException if the addition of DS record fails.      */
specifier|private
name|void
name|addDSRecord
parameter_list|(
name|Zone
name|zone
parameter_list|,
name|Name
name|name
parameter_list|,
name|int
name|dClass
parameter_list|,
name|long
name|dsTtl
parameter_list|,
name|Date
name|inception
parameter_list|,
name|Date
name|expiration
parameter_list|)
throws|throws
name|DNSSEC
operator|.
name|DNSSECException
block|{
name|RRset
name|rRset
decl_stmt|;
name|RRSIGRecord
name|rrsigRecord
decl_stmt|;
name|DNSKEYRecord
name|dnskeyRecord
init|=
name|dnsKeyRecs
operator|.
name|get
argument_list|(
name|zone
operator|.
name|getOrigin
argument_list|()
argument_list|)
decl_stmt|;
name|DSRecord
name|dsRecord
init|=
operator|new
name|DSRecord
argument_list|(
name|name
argument_list|,
name|dClass
argument_list|,
name|dsTtl
argument_list|,
name|DSRecord
operator|.
name|Digest
operator|.
name|SHA1
argument_list|,
name|dnskeyRecord
argument_list|)
decl_stmt|;
name|zone
operator|.
name|addRecord
argument_list|(
name|dsRecord
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Adding {}"
argument_list|,
name|dsRecord
argument_list|)
expr_stmt|;
name|rRset
operator|=
name|zone
operator|.
name|findExactMatch
argument_list|(
name|dsRecord
operator|.
name|getName
argument_list|()
argument_list|,
name|dsRecord
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
name|rrsigRecord
operator|=
name|DNSSEC
operator|.
name|sign
argument_list|(
name|rRset
argument_list|,
name|dnskeyRecord
argument_list|,
name|privateKey
argument_list|,
name|inception
argument_list|,
name|expiration
argument_list|)
expr_stmt|;
name|rRset
operator|.
name|addRR
argument_list|(
name|rrsigRecord
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|getLogDescription
parameter_list|()
block|{
return|return
literal|"Registering "
return|;
block|}
block|}
decl_stmt|;
comment|/**    * The "remove record" command.    */
DECL|field|removeRecordCommand
specifier|private
specifier|final
name|RegistryCommand
name|removeRecordCommand
init|=
operator|new
name|RegistryCommand
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|exec
parameter_list|(
name|Zone
name|zone
parameter_list|,
name|Record
name|record
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|zone
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to remove record because zone is null: {}"
argument_list|,
name|record
argument_list|)
expr_stmt|;
return|return;
block|}
name|zone
operator|.
name|removeRecord
argument_list|(
name|record
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Removed {}"
argument_list|,
name|record
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDNSSECEnabled
argument_list|()
condition|)
block|{
name|RRset
name|rRset
init|=
name|zone
operator|.
name|findExactMatch
argument_list|(
name|record
operator|.
name|getName
argument_list|()
argument_list|,
name|Type
operator|.
name|DS
argument_list|)
decl_stmt|;
if|if
condition|(
name|rRset
operator|!=
literal|null
condition|)
block|{
name|zone
operator|.
name|removeRecord
argument_list|(
name|rRset
operator|.
name|first
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|String
name|getLogDescription
parameter_list|()
block|{
return|return
literal|"Deleting "
return|;
block|}
block|}
decl_stmt|;
comment|/**    * An implementation allowing for obtaining and releasing a lock.    */
DECL|class|CloseableLock
specifier|public
specifier|static
class|class
name|CloseableLock
implements|implements
name|AutoCloseable
block|{
DECL|field|lock
specifier|private
name|Lock
name|lock
decl_stmt|;
DECL|method|CloseableLock (Lock lock)
specifier|public
name|CloseableLock
parameter_list|(
name|Lock
name|lock
parameter_list|)
block|{
name|this
operator|.
name|lock
operator|=
name|lock
expr_stmt|;
block|}
DECL|method|lock ()
specifier|public
name|CloseableLock
name|lock
parameter_list|()
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
return|return
name|this
return|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

