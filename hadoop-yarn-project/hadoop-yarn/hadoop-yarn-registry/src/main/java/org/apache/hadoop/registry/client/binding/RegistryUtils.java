begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.registry.client.binding
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|api
operator|.
name|RegistryConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|api
operator|.
name|RegistryOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|exceptions
operator|.
name|InvalidPathnameException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|exceptions
operator|.
name|InvalidRecordException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|exceptions
operator|.
name|NoRecordException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|impl
operator|.
name|zk
operator|.
name|RegistryInternalConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|RegistryPathStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|ServiceRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryPathUtils
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * Utility methods for working with a registry.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|RegistryUtils
specifier|public
class|class
name|RegistryUtils
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|RegistryUtils
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Buld the user path -switches to the system path if the user is "".    * It also cross-converts the username to ascii via punycode    * @param username username or ""    * @return the path to the user    */
DECL|method|homePathForUser (String username)
specifier|public
specifier|static
name|String
name|homePathForUser
parameter_list|(
name|String
name|username
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|username
operator|!=
literal|null
argument_list|,
literal|"null user"
argument_list|)
expr_stmt|;
comment|// catch recursion
if|if
condition|(
name|username
operator|.
name|startsWith
argument_list|(
name|RegistryConstants
operator|.
name|PATH_USERS
argument_list|)
condition|)
block|{
return|return
name|username
return|;
block|}
if|if
condition|(
name|username
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|RegistryConstants
operator|.
name|PATH_SYSTEM_SERVICES
return|;
block|}
comment|// convert username to registry name
name|String
name|convertedName
init|=
name|convertUsername
argument_list|(
name|username
argument_list|)
decl_stmt|;
return|return
name|RegistryPathUtils
operator|.
name|join
argument_list|(
name|RegistryConstants
operator|.
name|PATH_USERS
argument_list|,
name|encodeForRegistry
argument_list|(
name|convertedName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Convert the username to that which can be used for registry    * entries. Lower cases it,    * Strip the kerberos realm off a username if needed, and any "/" hostname    * entries    * @param username user    * @return the converted username    */
DECL|method|convertUsername (String username)
specifier|public
specifier|static
name|String
name|convertUsername
parameter_list|(
name|String
name|username
parameter_list|)
block|{
name|String
name|converted
init|=
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|toLowerCase
argument_list|(
name|username
argument_list|)
decl_stmt|;
name|int
name|atSymbol
init|=
name|converted
operator|.
name|indexOf
argument_list|(
literal|'@'
argument_list|)
decl_stmt|;
if|if
condition|(
name|atSymbol
operator|>
literal|0
condition|)
block|{
name|converted
operator|=
name|converted
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|atSymbol
argument_list|)
expr_stmt|;
block|}
name|int
name|slashSymbol
init|=
name|converted
operator|.
name|indexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|slashSymbol
operator|>
literal|0
condition|)
block|{
name|converted
operator|=
name|converted
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|slashSymbol
argument_list|)
expr_stmt|;
block|}
return|return
name|converted
return|;
block|}
comment|/**    * Create a service classpath    * @param user username or ""    * @param serviceClass service name    * @return a full path    */
DECL|method|serviceclassPath (String user, String serviceClass)
specifier|public
specifier|static
name|String
name|serviceclassPath
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|serviceClass
parameter_list|)
block|{
name|String
name|services
init|=
name|join
argument_list|(
name|homePathForUser
argument_list|(
name|user
argument_list|)
argument_list|,
name|RegistryConstants
operator|.
name|PATH_USER_SERVICES
argument_list|)
decl_stmt|;
return|return
name|join
argument_list|(
name|services
argument_list|,
name|serviceClass
argument_list|)
return|;
block|}
comment|/**    * Create a path to a service under a user and service class    * @param user username or ""    * @param serviceClass service name    * @param serviceName service name unique for that user and service class    * @return a full path    */
DECL|method|servicePath (String user, String serviceClass, String serviceName)
specifier|public
specifier|static
name|String
name|servicePath
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|serviceClass
parameter_list|,
name|String
name|serviceName
parameter_list|)
block|{
return|return
name|join
argument_list|(
name|serviceclassPath
argument_list|(
name|user
argument_list|,
name|serviceClass
argument_list|)
argument_list|,
name|serviceName
argument_list|)
return|;
block|}
comment|/**    * Create a path for listing components under a service    * @param user username or ""    * @param serviceClass service name    * @param serviceName service name unique for that user and service class    * @return a full path    */
DECL|method|componentListPath (String user, String serviceClass, String serviceName)
specifier|public
specifier|static
name|String
name|componentListPath
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|serviceClass
parameter_list|,
name|String
name|serviceName
parameter_list|)
block|{
return|return
name|join
argument_list|(
name|servicePath
argument_list|(
name|user
argument_list|,
name|serviceClass
argument_list|,
name|serviceName
argument_list|)
argument_list|,
name|RegistryConstants
operator|.
name|SUBPATH_COMPONENTS
argument_list|)
return|;
block|}
comment|/**    * Create the path to a service record for a component    * @param user username or ""    * @param serviceClass service name    * @param serviceName service name unique for that user and service class    * @param componentName unique name/ID of the component    * @return a full path    */
DECL|method|componentPath (String user, String serviceClass, String serviceName, String componentName)
specifier|public
specifier|static
name|String
name|componentPath
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|serviceClass
parameter_list|,
name|String
name|serviceName
parameter_list|,
name|String
name|componentName
parameter_list|)
block|{
return|return
name|join
argument_list|(
name|componentListPath
argument_list|(
name|user
argument_list|,
name|serviceClass
argument_list|,
name|serviceName
argument_list|)
argument_list|,
name|componentName
argument_list|)
return|;
block|}
comment|/**    * List service records directly under a path    * @param registryOperations registry operations instance    * @param path path to list    * @return a mapping of the service records that were resolved, indexed    * by their full path    * @throws IOException    */
DECL|method|listServiceRecords ( RegistryOperations registryOperations, String path)
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|ServiceRecord
argument_list|>
name|listServiceRecords
parameter_list|(
name|RegistryOperations
name|registryOperations
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|RegistryPathStatus
argument_list|>
name|children
init|=
name|statChildren
argument_list|(
name|registryOperations
argument_list|,
name|path
argument_list|)
decl_stmt|;
return|return
name|extractServiceRecords
argument_list|(
name|registryOperations
argument_list|,
name|path
argument_list|,
name|children
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * List children of a directory and retrieve their    * {@link RegistryPathStatus} values.    *<p>    * This is not an atomic operation; A child may be deleted    * during the iteration through the child entries. If this happens,    * the<code>PathNotFoundException</code> is caught and that child    * entry ommitted.    *    * @param path path    * @return a possibly empty map of child entries listed by    * their short name.    * @throws PathNotFoundException path is not in the registry.    * @throws InvalidPathnameException the path is invalid.    * @throws IOException Any other IO Exception    */
DECL|method|statChildren ( RegistryOperations registryOperations, String path)
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|RegistryPathStatus
argument_list|>
name|statChildren
parameter_list|(
name|RegistryOperations
name|registryOperations
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|PathNotFoundException
throws|,
name|InvalidPathnameException
throws|,
name|IOException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|childNames
init|=
name|registryOperations
operator|.
name|list
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|RegistryPathStatus
argument_list|>
name|results
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|RegistryPathStatus
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|childName
range|:
name|childNames
control|)
block|{
name|String
name|child
init|=
name|join
argument_list|(
name|path
argument_list|,
name|childName
argument_list|)
decl_stmt|;
try|try
block|{
name|RegistryPathStatus
name|stat
init|=
name|registryOperations
operator|.
name|stat
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|results
operator|.
name|put
argument_list|(
name|childName
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PathNotFoundException
name|pnfe
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"stat failed on {}: moved? {}"
argument_list|,
name|child
argument_list|,
name|pnfe
argument_list|,
name|pnfe
argument_list|)
expr_stmt|;
block|}
comment|// and continue
block|}
block|}
return|return
name|results
return|;
block|}
comment|/**    * Get the home path of the current user.    *<p>    *  In an insecure cluster, the environment variable    *<code>HADOOP_USER_NAME</code> is queried<i>first</i>.    *<p>    * This means that in a YARN container where the creator set this    * environment variable to propagate their identity, the defined    * user name is used in preference to the actual user.    *<p>    * In a secure cluster, the kerberos identity of the current user is used.    * @return a path for the current user's home dir.    * @throws RuntimeException if the current user identity cannot be determined    * from the OS/kerberos.    */
DECL|method|homePathForCurrentUser ()
specifier|public
specifier|static
name|String
name|homePathForCurrentUser
parameter_list|()
block|{
name|String
name|shortUserName
init|=
name|currentUsernameUnencoded
argument_list|()
decl_stmt|;
return|return
name|homePathForUser
argument_list|(
name|shortUserName
argument_list|)
return|;
block|}
comment|/**    * Get the current username, before any encoding has been applied.    * @return the current user from the kerberos identity, falling back    * to the user and/or env variables.    */
DECL|method|currentUsernameUnencoded ()
specifier|private
specifier|static
name|String
name|currentUsernameUnencoded
parameter_list|()
block|{
name|String
name|env_hadoop_username
init|=
name|System
operator|.
name|getenv
argument_list|(
name|RegistryInternalConstants
operator|.
name|HADOOP_USER_NAME
argument_list|)
decl_stmt|;
return|return
name|getCurrentUsernameUnencoded
argument_list|(
name|env_hadoop_username
argument_list|)
return|;
block|}
comment|/**    * Get the current username, using the value of the parameter    *<code>env_hadoop_username</code> if it is set on an insecure cluster.    * This ensures that the username propagates correctly across processes    * started by YARN.    *<p>    * This method is primarly made visible for testing.    * @param env_hadoop_username the environment variable    * @return the selected username    * @throws RuntimeException if there is a problem getting the short user    * name of the current user.    */
annotation|@
name|VisibleForTesting
DECL|method|getCurrentUsernameUnencoded (String env_hadoop_username)
specifier|public
specifier|static
name|String
name|getCurrentUsernameUnencoded
parameter_list|(
name|String
name|env_hadoop_username
parameter_list|)
block|{
name|String
name|shortUserName
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|shortUserName
operator|=
name|env_hadoop_username
expr_stmt|;
block|}
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|shortUserName
argument_list|)
condition|)
block|{
try|try
block|{
name|shortUserName
operator|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|shortUserName
return|;
block|}
comment|/**    * Get the current user path formatted for the registry    *<p>    *  In an insecure cluster, the environment variable    *<code>HADOOP_USER_NAME</code> is queried<i>first</i>.    *<p>    * This means that in a YARN container where the creator set this    * environment variable to propagate their identity, the defined    * user name is used in preference to the actual user.    *<p>    * In a secure cluster, the kerberos identity of the current user is used.    * @return the encoded shortname of the current user    * @throws RuntimeException if the current user identity cannot be determined    * from the OS/kerberos.    *    */
DECL|method|currentUser ()
specifier|public
specifier|static
name|String
name|currentUser
parameter_list|()
block|{
name|String
name|shortUserName
init|=
name|currentUsernameUnencoded
argument_list|()
decl_stmt|;
return|return
name|encodeForRegistry
argument_list|(
name|shortUserName
argument_list|)
return|;
block|}
comment|/**    * Extract all service records under a list of stat operations...this    * skips entries that are too short or simply not matching    * @param operations operation support for fetches    * @param parentpath path of the parent of all the entries    * @param stats Collection of stat results    * @return a possibly empty map of fullpath:record.    * @throws IOException for any IO Operation that wasn't ignored.    */
DECL|method|extractServiceRecords ( RegistryOperations operations, String parentpath, Collection<RegistryPathStatus> stats)
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|ServiceRecord
argument_list|>
name|extractServiceRecords
parameter_list|(
name|RegistryOperations
name|operations
parameter_list|,
name|String
name|parentpath
parameter_list|,
name|Collection
argument_list|<
name|RegistryPathStatus
argument_list|>
name|stats
parameter_list|)
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|ServiceRecord
argument_list|>
name|results
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ServiceRecord
argument_list|>
argument_list|(
name|stats
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RegistryPathStatus
name|stat
range|:
name|stats
control|)
block|{
if|if
condition|(
name|stat
operator|.
name|size
operator|>
name|ServiceRecord
operator|.
name|RECORD_TYPE
operator|.
name|length
argument_list|()
condition|)
block|{
comment|// maybe has data
name|String
name|path
init|=
name|join
argument_list|(
name|parentpath
argument_list|,
name|stat
operator|.
name|path
argument_list|)
decl_stmt|;
try|try
block|{
name|ServiceRecord
name|serviceRecord
init|=
name|operations
operator|.
name|resolve
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|results
operator|.
name|put
argument_list|(
name|path
argument_list|,
name|serviceRecord
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|ignored
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"data too short for {}"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InvalidRecordException
name|record
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Invalid record at {}"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NoRecordException
name|record
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No record at {}"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|results
return|;
block|}
comment|/**    * Extract all service records under a list of stat operations...this    * non-atomic action skips entries that are too short or simply not matching.    *<p>    * @param operations operation support for fetches    * @param parentpath path of the parent of all the entries    * @return a possibly empty map of fullpath:record.    * @throws IOException for any IO Operation that wasn't ignored.    */
DECL|method|extractServiceRecords ( RegistryOperations operations, String parentpath, Map<String , RegistryPathStatus> stats)
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|ServiceRecord
argument_list|>
name|extractServiceRecords
parameter_list|(
name|RegistryOperations
name|operations
parameter_list|,
name|String
name|parentpath
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|RegistryPathStatus
argument_list|>
name|stats
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|extractServiceRecords
argument_list|(
name|operations
argument_list|,
name|parentpath
argument_list|,
name|stats
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Extract all service records under a list of stat operations...this    * non-atomic action skips entries that are too short or simply not matching.    *<p>    * @param operations operation support for fetches    * @param parentpath path of the parent of all the entries    * @return a possibly empty map of fullpath:record.    * @throws IOException for any IO Operation that wasn't ignored.    */
DECL|method|extractServiceRecords ( RegistryOperations operations, String parentpath)
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|ServiceRecord
argument_list|>
name|extractServiceRecords
parameter_list|(
name|RegistryOperations
name|operations
parameter_list|,
name|String
name|parentpath
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|extractServiceRecords
argument_list|(
name|operations
argument_list|,
name|parentpath
argument_list|,
name|statChildren
argument_list|(
name|operations
argument_list|,
name|parentpath
argument_list|)
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Static instance of service record marshalling    */
DECL|class|ServiceRecordMarshal
specifier|public
specifier|static
class|class
name|ServiceRecordMarshal
extends|extends
name|JsonSerDeser
argument_list|<
name|ServiceRecord
argument_list|>
block|{
DECL|method|ServiceRecordMarshal ()
specifier|public
name|ServiceRecordMarshal
parameter_list|()
block|{
name|super
argument_list|(
name|ServiceRecord
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

