begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.registry.client.impl.zk
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|impl
operator|.
name|zk
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Splitter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|CuratorFrameworkFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authentication
operator|.
name|util
operator|.
name|KerberosUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|AbstractService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|ServiceStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ZKUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Environment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|ZooDefs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|ACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Id
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|server
operator|.
name|auth
operator|.
name|DigestAuthenticationProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|AppConfigurationEntry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchAlgorithmException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|impl
operator|.
name|zk
operator|.
name|ZookeeperConfigOptions
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|api
operator|.
name|RegistryConstants
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Implement the registry security ... a self contained service for  * testability.  *<p>  * This class contains:  *<ol>  *<li>  *     The registry security policy implementation, configuration reading, ACL  * setup and management  *</li>  *<li>Lots of static helper methods to aid security setup and debugging</li>  *</ol>  */
end_comment

begin_class
DECL|class|RegistrySecurity
specifier|public
class|class
name|RegistrySecurity
extends|extends
name|AbstractService
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|RegistrySecurity
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|E_UNKNOWN_AUTHENTICATION_MECHANISM
specifier|public
specifier|static
specifier|final
name|String
name|E_UNKNOWN_AUTHENTICATION_MECHANISM
init|=
literal|"Unknown/unsupported authentication mechanism; "
decl_stmt|;
comment|/**    * there's no default user to add with permissions, so it would be    * impossible to create nodes with unrestricted user access    */
DECL|field|E_NO_USER_DETERMINED_FOR_ACLS
specifier|public
specifier|static
specifier|final
name|String
name|E_NO_USER_DETERMINED_FOR_ACLS
init|=
literal|"No user for ACLs determinable from current user or registry option "
operator|+
name|KEY_REGISTRY_USER_ACCOUNTS
decl_stmt|;
comment|/**    * Error raised when the registry is tagged as secure but this    * process doesn't have hadoop security enabled.    */
DECL|field|E_NO_KERBEROS
specifier|public
specifier|static
specifier|final
name|String
name|E_NO_KERBEROS
init|=
literal|"Registry security is enabled -but Hadoop security is not enabled"
decl_stmt|;
comment|/**    * Access policy options    */
DECL|enum|AccessPolicy
specifier|private
enum|enum
name|AccessPolicy
block|{
DECL|enumConstant|anon
DECL|enumConstant|sasl
DECL|enumConstant|digest
name|anon
block|,
name|sasl
block|,
name|digest
block|}
comment|/**    * Access mechanism    */
DECL|field|access
specifier|private
name|AccessPolicy
name|access
decl_stmt|;
comment|/**    * User used for digest auth    */
DECL|field|digestAuthUser
specifier|private
name|String
name|digestAuthUser
decl_stmt|;
comment|/**    * Password used for digest auth    */
DECL|field|digestAuthPassword
specifier|private
name|String
name|digestAuthPassword
decl_stmt|;
comment|/**    * Auth data used for digest auth    */
DECL|field|digestAuthData
specifier|private
name|byte
index|[]
name|digestAuthData
decl_stmt|;
comment|/**    * flag set to true if the registry has security enabled.    */
DECL|field|secureRegistry
specifier|private
name|boolean
name|secureRegistry
decl_stmt|;
comment|/**    * An ACL with read-write access for anyone    */
DECL|field|ALL_READWRITE_ACCESS
specifier|public
specifier|static
specifier|final
name|ACL
name|ALL_READWRITE_ACCESS
init|=
operator|new
name|ACL
argument_list|(
name|ZooDefs
operator|.
name|Perms
operator|.
name|ALL
argument_list|,
name|ZooDefs
operator|.
name|Ids
operator|.
name|ANYONE_ID_UNSAFE
argument_list|)
decl_stmt|;
comment|/**    * An ACL with read access for anyone    */
DECL|field|ALL_READ_ACCESS
specifier|public
specifier|static
specifier|final
name|ACL
name|ALL_READ_ACCESS
init|=
operator|new
name|ACL
argument_list|(
name|ZooDefs
operator|.
name|Perms
operator|.
name|READ
argument_list|,
name|ZooDefs
operator|.
name|Ids
operator|.
name|ANYONE_ID_UNSAFE
argument_list|)
decl_stmt|;
comment|/**    * An ACL list containing the {@link #ALL_READWRITE_ACCESS} entry.    * It is copy on write so can be shared without worry    */
DECL|field|WorldReadWriteACL
specifier|public
specifier|static
specifier|final
name|List
argument_list|<
name|ACL
argument_list|>
name|WorldReadWriteACL
decl_stmt|;
static|static
block|{
name|List
argument_list|<
name|ACL
argument_list|>
name|acls
init|=
operator|new
name|ArrayList
argument_list|<
name|ACL
argument_list|>
argument_list|()
decl_stmt|;
name|acls
operator|.
name|add
argument_list|(
name|ALL_READWRITE_ACCESS
argument_list|)
expr_stmt|;
name|WorldReadWriteACL
operator|=
operator|new
name|CopyOnWriteArrayList
argument_list|<
name|ACL
argument_list|>
argument_list|(
name|acls
argument_list|)
expr_stmt|;
block|}
comment|/**    * the list of system ACLs    */
DECL|field|systemACLs
specifier|private
specifier|final
name|List
argument_list|<
name|ACL
argument_list|>
name|systemACLs
init|=
operator|new
name|ArrayList
argument_list|<
name|ACL
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * A list of digest ACLs which can be added to permissions    * âand cleared later.    */
DECL|field|digestACLs
specifier|private
specifier|final
name|List
argument_list|<
name|ACL
argument_list|>
name|digestACLs
init|=
operator|new
name|ArrayList
argument_list|<
name|ACL
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * the default kerberos realm    */
DECL|field|kerberosRealm
specifier|private
name|String
name|kerberosRealm
decl_stmt|;
comment|/**    * Client context    */
DECL|field|jaasClientContext
specifier|private
name|String
name|jaasClientContext
decl_stmt|;
comment|/**    * Client identity    */
DECL|field|jaasClientIdentity
specifier|private
name|String
name|jaasClientIdentity
decl_stmt|;
comment|/**    * Create an instance    * @param name service name    */
DECL|method|RegistrySecurity (String name)
specifier|public
name|RegistrySecurity
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|/**    * Init the service: this sets up security based on the configuration    * @param conf configuration    * @throws Exception    */
annotation|@
name|Override
DECL|method|serviceInit (Configuration conf)
specifier|protected
name|void
name|serviceInit
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
name|super
operator|.
name|serviceInit
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|String
name|auth
init|=
name|conf
operator|.
name|getTrimmed
argument_list|(
name|KEY_REGISTRY_CLIENT_AUTH
argument_list|,
name|REGISTRY_CLIENT_AUTH_ANONYMOUS
argument_list|)
decl_stmt|;
comment|// TODO JDK7 SWITCH
if|if
condition|(
name|REGISTRY_CLIENT_AUTH_KERBEROS
operator|.
name|equals
argument_list|(
name|auth
argument_list|)
condition|)
block|{
name|access
operator|=
name|AccessPolicy
operator|.
name|sasl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|REGISTRY_CLIENT_AUTH_DIGEST
operator|.
name|equals
argument_list|(
name|auth
argument_list|)
condition|)
block|{
name|access
operator|=
name|AccessPolicy
operator|.
name|digest
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|REGISTRY_CLIENT_AUTH_ANONYMOUS
operator|.
name|equals
argument_list|(
name|auth
argument_list|)
condition|)
block|{
name|access
operator|=
name|AccessPolicy
operator|.
name|anon
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|ServiceStateException
argument_list|(
name|E_UNKNOWN_AUTHENTICATION_MECHANISM
operator|+
literal|"\""
operator|+
name|auth
operator|+
literal|"\""
argument_list|)
throw|;
block|}
name|initSecurity
argument_list|()
expr_stmt|;
block|}
comment|/**    * Init security.    *    * After this operation, the {@link #systemACLs} list is valid.    * @throws IOException    */
DECL|method|initSecurity ()
specifier|private
name|void
name|initSecurity
parameter_list|()
throws|throws
name|IOException
block|{
name|secureRegistry
operator|=
name|getConfig
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|KEY_REGISTRY_SECURE
argument_list|,
name|DEFAULT_REGISTRY_SECURE
argument_list|)
expr_stmt|;
name|systemACLs
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|secureRegistry
condition|)
block|{
name|addSystemACL
argument_list|(
name|ALL_READ_ACCESS
argument_list|)
expr_stmt|;
comment|// determine the kerberos realm from JVM and settings
name|kerberosRealm
operator|=
name|getConfig
argument_list|()
operator|.
name|get
argument_list|(
name|KEY_REGISTRY_KERBEROS_REALM
argument_list|,
name|getDefaultRealmInJVM
argument_list|()
argument_list|)
expr_stmt|;
comment|// System Accounts
name|String
name|system
init|=
name|getOrFail
argument_list|(
name|KEY_REGISTRY_SYSTEM_ACCOUNTS
argument_list|,
name|DEFAULT_REGISTRY_SYSTEM_ACCOUNTS
argument_list|)
decl_stmt|;
name|systemACLs
operator|.
name|addAll
argument_list|(
name|buildACLs
argument_list|(
name|system
argument_list|,
name|kerberosRealm
argument_list|,
name|ZooDefs
operator|.
name|Perms
operator|.
name|ALL
argument_list|)
argument_list|)
expr_stmt|;
comment|// user accounts (may be empty, but for digest one user AC must
comment|// be built up
name|String
name|user
init|=
name|getConfig
argument_list|()
operator|.
name|get
argument_list|(
name|KEY_REGISTRY_USER_ACCOUNTS
argument_list|,
name|DEFAULT_REGISTRY_USER_ACCOUNTS
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ACL
argument_list|>
name|userACLs
init|=
name|buildACLs
argument_list|(
name|user
argument_list|,
name|kerberosRealm
argument_list|,
name|ZooDefs
operator|.
name|Perms
operator|.
name|ALL
argument_list|)
decl_stmt|;
comment|// add self if the current user can be determined
name|ACL
name|self
decl_stmt|;
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|self
operator|=
name|createSaslACLFromCurrentUser
argument_list|(
name|ZooDefs
operator|.
name|Perms
operator|.
name|ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|self
operator|!=
literal|null
condition|)
block|{
name|userACLs
operator|.
name|add
argument_list|(
name|self
argument_list|)
expr_stmt|;
block|}
block|}
comment|// here check for UGI having secure on or digest + ID
switch|switch
condition|(
name|access
condition|)
block|{
case|case
name|sasl
case|:
comment|// secure + SASL => has to be authenticated
if|if
condition|(
operator|!
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Kerberos required for secure registry access"
argument_list|)
throw|;
block|}
name|UserGroupInformation
name|currentUser
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
decl_stmt|;
name|jaasClientContext
operator|=
name|getOrFail
argument_list|(
name|KEY_REGISTRY_CLIENT_JAAS_CONTEXT
argument_list|,
name|DEFAULT_REGISTRY_CLIENT_JAAS_CONTEXT
argument_list|)
expr_stmt|;
name|jaasClientIdentity
operator|=
name|currentUser
operator|.
name|getShortUserName
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Auth is SASL user=\"{}\" JAAS context=\"{}\""
argument_list|,
name|jaasClientIdentity
argument_list|,
name|jaasClientContext
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|digest
case|:
name|String
name|id
init|=
name|getOrFail
argument_list|(
name|KEY_REGISTRY_CLIENT_AUTHENTICATION_ID
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|String
name|pass
init|=
name|getOrFail
argument_list|(
name|KEY_REGISTRY_CLIENT_AUTHENTICATION_PASSWORD
argument_list|,
literal|""
argument_list|)
decl_stmt|;
if|if
condition|(
name|userACLs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//
throw|throw
operator|new
name|ServiceStateException
argument_list|(
name|E_NO_USER_DETERMINED_FOR_ACLS
argument_list|)
throw|;
block|}
name|digest
argument_list|(
name|id
argument_list|,
name|pass
argument_list|)
expr_stmt|;
name|ACL
name|acl
init|=
operator|new
name|ACL
argument_list|(
name|ZooDefs
operator|.
name|Perms
operator|.
name|ALL
argument_list|,
name|toDigestId
argument_list|(
name|id
argument_list|,
name|pass
argument_list|)
argument_list|)
decl_stmt|;
name|userACLs
operator|.
name|add
argument_list|(
name|acl
argument_list|)
expr_stmt|;
name|digestAuthUser
operator|=
name|id
expr_stmt|;
name|digestAuthPassword
operator|=
name|pass
expr_stmt|;
name|String
name|authPair
init|=
name|id
operator|+
literal|":"
operator|+
name|pass
decl_stmt|;
name|digestAuthData
operator|=
name|authPair
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Auth is Digest ACL: {}"
argument_list|,
name|aclToString
argument_list|(
name|acl
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|anon
case|:
comment|// nothing is needed; account is read only.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Auth is anonymous"
argument_list|)
expr_stmt|;
block|}
name|userACLs
operator|=
operator|new
name|ArrayList
argument_list|<
name|ACL
argument_list|>
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|systemACLs
operator|.
name|addAll
argument_list|(
name|userACLs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Registry has no security"
argument_list|)
expr_stmt|;
block|}
comment|// wide open cluster, adding system acls
name|systemACLs
operator|.
name|addAll
argument_list|(
name|WorldReadWriteACL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Add another system ACL    * @param acl add ACL    */
DECL|method|addSystemACL (ACL acl)
specifier|public
name|void
name|addSystemACL
parameter_list|(
name|ACL
name|acl
parameter_list|)
block|{
name|systemACLs
operator|.
name|add
argument_list|(
name|acl
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a digest ACL    * @param acl add ACL    */
DECL|method|addDigestACL (ACL acl)
specifier|public
name|boolean
name|addDigestACL
parameter_list|(
name|ACL
name|acl
parameter_list|)
block|{
if|if
condition|(
name|secureRegistry
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Added ACL {}"
argument_list|,
name|aclToString
argument_list|(
name|acl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|digestACLs
operator|.
name|add
argument_list|(
name|acl
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring added ACL - registry is insecure{}"
argument_list|,
name|aclToString
argument_list|(
name|acl
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Reset the digest ACL list    */
DECL|method|resetDigestACLs ()
specifier|public
name|void
name|resetDigestACLs
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Cleared digest ACLs"
argument_list|)
expr_stmt|;
block|}
name|digestACLs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Flag to indicate the cluster is secure    * @return true if the config enabled security    */
DECL|method|isSecureRegistry ()
specifier|public
name|boolean
name|isSecureRegistry
parameter_list|()
block|{
return|return
name|secureRegistry
return|;
block|}
comment|/**    * Get the system principals    * @return the system principals    */
DECL|method|getSystemACLs ()
specifier|public
name|List
argument_list|<
name|ACL
argument_list|>
name|getSystemACLs
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|systemACLs
argument_list|,
literal|"registry security is unitialized"
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|systemACLs
argument_list|)
return|;
block|}
comment|/**    * Get all ACLs needed for a client to use when writing to the repo.    * That is: system ACLs, its own ACL, any digest ACLs    * @return the client ACLs    */
DECL|method|getClientACLs ()
specifier|public
name|List
argument_list|<
name|ACL
argument_list|>
name|getClientACLs
parameter_list|()
block|{
name|List
argument_list|<
name|ACL
argument_list|>
name|clientACLs
init|=
operator|new
name|ArrayList
argument_list|<
name|ACL
argument_list|>
argument_list|(
name|systemACLs
argument_list|)
decl_stmt|;
name|clientACLs
operator|.
name|addAll
argument_list|(
name|digestACLs
argument_list|)
expr_stmt|;
return|return
name|clientACLs
return|;
block|}
comment|/**    * Create a SASL ACL for the user    * @param perms permissions    * @return an ACL for the current user or null if they aren't a kerberos user    * @throws IOException    */
DECL|method|createSaslACLFromCurrentUser (int perms)
specifier|public
name|ACL
name|createSaslACLFromCurrentUser
parameter_list|(
name|int
name|perms
parameter_list|)
throws|throws
name|IOException
block|{
name|UserGroupInformation
name|currentUser
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentUser
operator|.
name|hasKerberosCredentials
argument_list|()
condition|)
block|{
return|return
name|createSaslACL
argument_list|(
name|currentUser
argument_list|,
name|perms
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Given a UGI, create a SASL ACL from it    * @param ugi UGI    * @param perms permissions    * @return a new ACL    */
DECL|method|createSaslACL (UserGroupInformation ugi, int perms)
specifier|public
name|ACL
name|createSaslACL
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
name|int
name|perms
parameter_list|)
block|{
name|String
name|userName
init|=
name|ugi
operator|.
name|getUserName
argument_list|()
decl_stmt|;
return|return
operator|new
name|ACL
argument_list|(
name|perms
argument_list|,
operator|new
name|Id
argument_list|(
name|SCHEME_SASL
argument_list|,
name|userName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get a conf option, throw an exception if it is null/empty    * @param key key    * @param defval default value    * @return the value    * @throws IOException if missing    */
DECL|method|getOrFail (String key, String defval)
specifier|private
name|String
name|getOrFail
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|defval
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|val
init|=
name|getConfig
argument_list|()
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|defval
argument_list|)
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|val
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Missing value for configuration option "
operator|+
name|key
argument_list|)
throw|;
block|}
return|return
name|val
return|;
block|}
comment|/**    * Check for an id:password tuple being valid.    * This test is stricter than that in {@link DigestAuthenticationProvider},    * which splits the string, but doesn't check the contents of each    * half for being non-"".    * @param idPasswordPair id:pass pair    * @return true if the pass is considered valid.    */
DECL|method|isValid (String idPasswordPair)
specifier|public
name|boolean
name|isValid
parameter_list|(
name|String
name|idPasswordPair
parameter_list|)
block|{
name|String
index|[]
name|parts
init|=
name|idPasswordPair
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
return|return
name|parts
operator|.
name|length
operator|==
literal|2
operator|&&
operator|!
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|parts
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|!
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|parts
index|[
literal|1
index|]
argument_list|)
return|;
block|}
comment|/**    * Get the derived kerberos realm.    * @return this is built from the JVM realm, or the configuration if it    * overrides it. If "", it means "don't know".    */
DECL|method|getKerberosRealm ()
specifier|public
name|String
name|getKerberosRealm
parameter_list|()
block|{
return|return
name|kerberosRealm
return|;
block|}
comment|/**    * Generate a base-64 encoded digest of the idPasswordPair pair    * @param idPasswordPair id:password    * @return a string that can be used for authentication    */
DECL|method|digest (String idPasswordPair)
specifier|public
name|String
name|digest
parameter_list|(
name|String
name|idPasswordPair
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|idPasswordPair
argument_list|)
operator|||
operator|!
name|isValid
argument_list|(
name|idPasswordPair
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid id:password: "
operator|+
name|idPasswordPair
argument_list|)
throw|;
block|}
try|try
block|{
return|return
name|DigestAuthenticationProvider
operator|.
name|generateDigest
argument_list|(
name|idPasswordPair
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
name|e
parameter_list|)
block|{
comment|// unlikely since it is standard to the JVM, but maybe JCE restrictions
comment|// could trigger it
throw|throw
operator|new
name|IOException
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Generate a base-64 encoded digest of the idPasswordPair pair    * @param id ID    * @param password pass    * @return a string that can be used for authentication    * @throws IOException    */
DECL|method|digest (String id, String password)
specifier|public
name|String
name|digest
parameter_list|(
name|String
name|id
parameter_list|,
name|String
name|password
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|digest
argument_list|(
name|id
operator|+
literal|":"
operator|+
name|password
argument_list|)
return|;
block|}
comment|/**    * Given a digest, create an ID from it    * @param digest digest    * @return ID    */
DECL|method|toDigestId (String digest)
specifier|public
name|Id
name|toDigestId
parameter_list|(
name|String
name|digest
parameter_list|)
block|{
return|return
operator|new
name|Id
argument_list|(
name|SCHEME_DIGEST
argument_list|,
name|digest
argument_list|)
return|;
block|}
comment|/**    * Create a Digest ID from an id:pass pair    * @param id ID    * @param password password    * @return an ID    * @throws IOException    */
DECL|method|toDigestId (String id, String password)
specifier|public
name|Id
name|toDigestId
parameter_list|(
name|String
name|id
parameter_list|,
name|String
name|password
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|toDigestId
argument_list|(
name|digest
argument_list|(
name|id
argument_list|,
name|password
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Split up a list of the form    *<code>sasl:mapred@,digest:5f55d66, sasl@yarn@EXAMPLE.COM</code>    * into a list of possible ACL values, trimming as needed    *    * The supplied realm is added to entries where    *<ol>    *<li>the string begins "sasl:"</li>    *<li>the string ends with "@"</li>    *</ol>    * No attempt is made to validate any of the acl patterns.    *    * @param aclString list of 0 or more ACLs    * @param realm realm to add    * @return a list of split and potentially patched ACL pairs.    *    */
DECL|method|splitAclPairs (String aclString, String realm)
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|splitAclPairs
parameter_list|(
name|String
name|aclString
parameter_list|,
name|String
name|realm
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|Splitter
operator|.
name|on
argument_list|(
literal|','
argument_list|)
operator|.
name|omitEmptyStrings
argument_list|()
operator|.
name|trimResults
argument_list|()
operator|.
name|split
argument_list|(
name|aclString
argument_list|)
argument_list|)
decl_stmt|;
name|ListIterator
argument_list|<
name|String
argument_list|>
name|listIterator
init|=
name|list
operator|.
name|listIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|listIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|next
init|=
name|listIterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|next
operator|.
name|startsWith
argument_list|(
name|SCHEME_SASL
operator|+
literal|":"
argument_list|)
operator|&&
name|next
operator|.
name|endsWith
argument_list|(
literal|"@"
argument_list|)
condition|)
block|{
name|listIterator
operator|.
name|set
argument_list|(
name|next
operator|+
name|realm
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
comment|/**    * Parse a string down to an ID, adding a realm if needed    * @param idPair id:data tuple    * @param realm realm to add    * @return the ID.    * @throws IllegalArgumentException if the idPair is invalid    */
DECL|method|parse (String idPair, String realm)
specifier|public
name|Id
name|parse
parameter_list|(
name|String
name|idPair
parameter_list|,
name|String
name|realm
parameter_list|)
block|{
name|int
name|firstColon
init|=
name|idPair
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
name|int
name|lastColon
init|=
name|idPair
operator|.
name|lastIndexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstColon
operator|==
operator|-
literal|1
operator|||
name|lastColon
operator|==
operator|-
literal|1
operator|||
name|firstColon
operator|!=
name|lastColon
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"ACL '"
operator|+
name|idPair
operator|+
literal|"' not of expected form scheme:id"
argument_list|)
throw|;
block|}
name|String
name|scheme
init|=
name|idPair
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|firstColon
argument_list|)
decl_stmt|;
name|String
name|id
init|=
name|idPair
operator|.
name|substring
argument_list|(
name|firstColon
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|.
name|endsWith
argument_list|(
literal|"@"
argument_list|)
condition|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|StringUtils
operator|.
name|isNotEmpty
argument_list|(
name|realm
argument_list|)
argument_list|,
literal|"@ suffixed account but no realm %s"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|id
operator|=
name|id
operator|+
name|realm
expr_stmt|;
block|}
return|return
operator|new
name|Id
argument_list|(
name|scheme
argument_list|,
name|id
argument_list|)
return|;
block|}
comment|/**    * Parse the IDs, adding a realm if needed, setting the permissions    * @param principalList id string    * @param realm realm to add    * @param perms permissions    * @return the relevant ACLs    * @throws IOException    */
DECL|method|buildACLs (String principalList, String realm, int perms)
specifier|public
name|List
argument_list|<
name|ACL
argument_list|>
name|buildACLs
parameter_list|(
name|String
name|principalList
parameter_list|,
name|String
name|realm
parameter_list|,
name|int
name|perms
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|aclPairs
init|=
name|splitAclPairs
argument_list|(
name|principalList
argument_list|,
name|realm
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ACL
argument_list|>
name|ids
init|=
operator|new
name|ArrayList
argument_list|<
name|ACL
argument_list|>
argument_list|(
name|aclPairs
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|aclPair
range|:
name|aclPairs
control|)
block|{
name|ACL
name|newAcl
init|=
operator|new
name|ACL
argument_list|()
decl_stmt|;
name|newAcl
operator|.
name|setId
argument_list|(
name|parse
argument_list|(
name|aclPair
argument_list|,
name|realm
argument_list|)
argument_list|)
expr_stmt|;
name|newAcl
operator|.
name|setPerms
argument_list|(
name|perms
argument_list|)
expr_stmt|;
name|ids
operator|.
name|add
argument_list|(
name|newAcl
argument_list|)
expr_stmt|;
block|}
return|return
name|ids
return|;
block|}
comment|/**    * Parse an ACL list. This includes configuration indirection    * {@link ZKUtil#resolveConfIndirection(String)}    * @param zkAclConf configuration string    * @return an ACL list    * @throws IOException on a bad ACL parse    */
DECL|method|parseACLs (String zkAclConf)
specifier|public
name|List
argument_list|<
name|ACL
argument_list|>
name|parseACLs
parameter_list|(
name|String
name|zkAclConf
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|ZKUtil
operator|.
name|parseACLs
argument_list|(
name|ZKUtil
operator|.
name|resolveConfIndirection
argument_list|(
name|zkAclConf
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ZKUtil
operator|.
name|BadAclFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Parsing "
operator|+
name|zkAclConf
operator|+
literal|" :"
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get the appropriate Kerberos Auth module for JAAS entries    * for this JVM.    * @return a JVM-specific kerberos login module classname.    */
DECL|method|getKerberosAuthModuleForJVM ()
specifier|public
specifier|static
name|String
name|getKerberosAuthModuleForJVM
parameter_list|()
block|{
if|if
condition|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.vendor"
argument_list|)
operator|.
name|contains
argument_list|(
literal|"IBM"
argument_list|)
condition|)
block|{
return|return
literal|"com.ibm.security.auth.module.Krb5LoginModule"
return|;
block|}
else|else
block|{
return|return
literal|"com.sun.security.auth.module.Krb5LoginModule"
return|;
block|}
block|}
comment|/**    * JAAS template: {@value}    * Note the semicolon on the last entry    */
DECL|field|JAAS_ENTRY
specifier|private
specifier|static
specifier|final
name|String
name|JAAS_ENTRY
init|=
literal|"%s { \n"
operator|+
literal|" %s required\n"
comment|// kerberos module
operator|+
literal|" keyTab=\"%s\"\n"
operator|+
literal|" principal=\"%s\"\n"
operator|+
literal|" useKeyTab=true\n"
operator|+
literal|" useTicketCache=false\n"
operator|+
literal|" doNotPrompt=true\n"
operator|+
literal|" storeKey=true;\n"
operator|+
literal|"}; \n"
decl_stmt|;
comment|/**    * Create a JAAS entry for insertion    * @param context context of the entry    * @param principal kerberos principal    * @param keytab keytab    * @return a context    */
DECL|method|createJAASEntry ( String context, String principal, File keytab)
specifier|public
name|String
name|createJAASEntry
parameter_list|(
name|String
name|context
parameter_list|,
name|String
name|principal
parameter_list|,
name|File
name|keytab
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|StringUtils
operator|.
name|isNotEmpty
argument_list|(
name|principal
argument_list|)
argument_list|,
literal|"invalid principal"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|StringUtils
operator|.
name|isNotEmpty
argument_list|(
name|context
argument_list|)
argument_list|,
literal|"invalid context"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|keytab
operator|!=
literal|null
operator|&&
name|keytab
operator|.
name|isFile
argument_list|()
argument_list|,
literal|"Keytab null or missing: "
argument_list|)
expr_stmt|;
return|return
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|,
name|JAAS_ENTRY
argument_list|,
name|context
argument_list|,
name|getKerberosAuthModuleForJVM
argument_list|()
argument_list|,
name|keytab
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|principal
argument_list|)
return|;
block|}
comment|/**    * Bind the JVM JAS setting to the specified JAAS file.    *    *<b>Important:</b> once a file has been loaded the JVM doesn't pick up    * changes    * @param jaasFile the JAAS file    */
DECL|method|bindJVMtoJAASFile (File jaasFile)
specifier|public
specifier|static
name|void
name|bindJVMtoJAASFile
parameter_list|(
name|File
name|jaasFile
parameter_list|)
block|{
name|String
name|path
init|=
name|jaasFile
operator|.
name|getAbsolutePath
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Binding {} to {}"
argument_list|,
name|Environment
operator|.
name|JAAS_CONF_KEY
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|setProperty
argument_list|(
name|Environment
operator|.
name|JAAS_CONF_KEY
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the Zookeeper server property    * {@link ZookeeperConfigOptions#PROP_ZK_SERVER_SASL_CONTEXT}    * to the SASL context. When the ZK server starts, this is the context    * which it will read in    * @param contextName the name of the context    */
DECL|method|bindZKToServerJAASContext (String contextName)
specifier|public
specifier|static
name|void
name|bindZKToServerJAASContext
parameter_list|(
name|String
name|contextName
parameter_list|)
block|{
name|System
operator|.
name|setProperty
argument_list|(
name|PROP_ZK_SERVER_SASL_CONTEXT
argument_list|,
name|contextName
argument_list|)
expr_stmt|;
block|}
comment|/**    * Reset any system properties related to JAAS    */
DECL|method|clearJaasSystemProperties ()
specifier|public
specifier|static
name|void
name|clearJaasSystemProperties
parameter_list|()
block|{
name|System
operator|.
name|clearProperty
argument_list|(
name|Environment
operator|.
name|JAAS_CONF_KEY
argument_list|)
expr_stmt|;
block|}
comment|/**    * Resolve the context of an entry. This is an effective test of    * JAAS setup, because it will relay detected problems up    * @param context context name    * @return the entry    * @throws RuntimeException if there is no context entry found    */
DECL|method|validateContext (String context)
specifier|public
specifier|static
name|AppConfigurationEntry
index|[]
name|validateContext
parameter_list|(
name|String
name|context
parameter_list|)
block|{
if|if
condition|(
name|context
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Null context argument"
argument_list|)
throw|;
block|}
if|if
condition|(
name|context
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Empty context argument"
argument_list|)
throw|;
block|}
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
name|configuration
init|=
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|AppConfigurationEntry
index|[]
name|entries
init|=
name|configuration
operator|.
name|getAppConfigurationEntry
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|entries
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Entry \"%s\" not found; "
operator|+
literal|"JAAS config = %s"
argument_list|,
name|context
argument_list|,
name|describeProperty
argument_list|(
name|Environment
operator|.
name|JAAS_CONF_KEY
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|entries
return|;
block|}
comment|/**    * Apply the security environment to this curator instance. This    * may include setting up the ZK system properties for SASL    * @param builder curator builder    */
DECL|method|applySecurityEnvironment (CuratorFrameworkFactory.Builder builder)
specifier|public
name|void
name|applySecurityEnvironment
parameter_list|(
name|CuratorFrameworkFactory
operator|.
name|Builder
name|builder
parameter_list|)
block|{
if|if
condition|(
name|isSecureRegistry
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|access
condition|)
block|{
case|case
name|anon
case|:
name|clearZKSaslClientProperties
argument_list|()
expr_stmt|;
break|break;
case|case
name|digest
case|:
comment|// no SASL
name|clearZKSaslClientProperties
argument_list|()
expr_stmt|;
name|builder
operator|.
name|authorization
argument_list|(
name|SCHEME_DIGEST
argument_list|,
name|digestAuthData
argument_list|)
expr_stmt|;
break|break;
case|case
name|sasl
case|:
comment|// bind to the current identity and context within the JAAS file
name|setZKSaslClientProperties
argument_list|(
name|jaasClientIdentity
argument_list|,
name|jaasClientContext
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Set the client properties. This forces the ZK client into    * failing if it can't auth.    *<b>Important:</b>This is JVM-wide.    * @param username username    * @param context login context    * @throws RuntimeException if the context cannot be found in the current    * JAAS context    */
DECL|method|setZKSaslClientProperties (String username, String context)
specifier|public
specifier|static
name|void
name|setZKSaslClientProperties
parameter_list|(
name|String
name|username
parameter_list|,
name|String
name|context
parameter_list|)
block|{
name|RegistrySecurity
operator|.
name|validateContext
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|enableZookeeperClientSASL
argument_list|()
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
name|PROP_ZK_SASL_CLIENT_USERNAME
argument_list|,
name|username
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
name|PROP_ZK_SASL_CLIENT_CONTEXT
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
comment|/**    * Clear all the ZK SASL Client properties    *<b>Important:</b>This is JVM-wide    */
DECL|method|clearZKSaslClientProperties ()
specifier|public
specifier|static
name|void
name|clearZKSaslClientProperties
parameter_list|()
block|{
name|disableZookeeperClientSASL
argument_list|()
expr_stmt|;
name|System
operator|.
name|clearProperty
argument_list|(
name|PROP_ZK_SASL_CLIENT_CONTEXT
argument_list|)
expr_stmt|;
name|System
operator|.
name|clearProperty
argument_list|(
name|PROP_ZK_SASL_CLIENT_USERNAME
argument_list|)
expr_stmt|;
block|}
comment|/**    * Turn ZK SASL on    *<b>Important:</b>This is JVM-wide    */
DECL|method|enableZookeeperClientSASL ()
specifier|protected
specifier|static
name|void
name|enableZookeeperClientSASL
parameter_list|()
block|{
name|System
operator|.
name|setProperty
argument_list|(
name|PROP_ZK_ENABLE_SASL_CLIENT
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Force disable ZK SASL bindings.    *<b>Important:</b>This is JVM-wide    */
DECL|method|disableZookeeperClientSASL ()
specifier|public
specifier|static
name|void
name|disableZookeeperClientSASL
parameter_list|()
block|{
name|System
operator|.
name|setProperty
argument_list|(
name|ZookeeperConfigOptions
operator|.
name|PROP_ZK_ENABLE_SASL_CLIENT
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Is the system property enabling the SASL client set?    * @return true if the SASL client system property is set.    */
DECL|method|isClientSASLEnabled ()
specifier|public
specifier|static
name|boolean
name|isClientSASLEnabled
parameter_list|()
block|{
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
name|ZookeeperConfigOptions
operator|.
name|PROP_ZK_ENABLE_SASL_CLIENT
argument_list|,
literal|"true"
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Log details about the current Hadoop user at INFO.    * Robust against IOEs when trying to get the current user    */
DECL|method|logCurrentHadoopUser ()
specifier|public
name|void
name|logCurrentHadoopUser
parameter_list|()
block|{
try|try
block|{
name|UserGroupInformation
name|currentUser
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Current user = {}"
argument_list|,
name|currentUser
argument_list|)
expr_stmt|;
name|UserGroupInformation
name|realUser
init|=
name|currentUser
operator|.
name|getRealUser
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Real User = {}"
argument_list|,
name|realUser
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to get current user {}, {}"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Stringify a list of ACLs for logging. Digest ACLs have their    * digest values stripped for security.    * @param acls ACL list    * @return a string for logs, exceptions, ...    */
DECL|method|aclsToString (List<ACL> acls)
specifier|public
specifier|static
name|String
name|aclsToString
parameter_list|(
name|List
argument_list|<
name|ACL
argument_list|>
name|acls
parameter_list|)
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|acls
operator|==
literal|null
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"null ACL"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|builder
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
name|ACL
name|acl
range|:
name|acls
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|aclToString
argument_list|(
name|acl
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Convert an ACL to a string, with any obfuscation needed    * @param acl ACL    * @return ACL string value    */
DECL|method|aclToString (ACL acl)
specifier|public
specifier|static
name|String
name|aclToString
parameter_list|(
name|ACL
name|acl
parameter_list|)
block|{
return|return
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|,
literal|"0x%02x: %s"
argument_list|,
name|acl
operator|.
name|getPerms
argument_list|()
argument_list|,
name|idToString
argument_list|(
name|acl
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Convert an ID to a string, stripping out all but the first few characters    * of any digest auth hash for security reasons    * @param id ID    * @return a string description of a Zookeeper ID    */
DECL|method|idToString (Id id)
specifier|public
specifier|static
name|String
name|idToString
parameter_list|(
name|Id
name|id
parameter_list|)
block|{
name|String
name|s
decl_stmt|;
if|if
condition|(
name|id
operator|.
name|getScheme
argument_list|()
operator|.
name|equals
argument_list|(
name|SCHEME_DIGEST
argument_list|)
condition|)
block|{
name|String
name|ids
init|=
name|id
operator|.
name|getId
argument_list|()
decl_stmt|;
name|int
name|colon
init|=
name|ids
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|colon
operator|>
literal|0
condition|)
block|{
name|ids
operator|=
name|ids
operator|.
name|substring
argument_list|(
name|colon
operator|+
literal|3
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|SCHEME_DIGEST
operator|+
literal|": "
operator|+
name|ids
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|id
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
comment|/**    * Build up low-level security diagnostics to aid debugging    * @return a string to use in diagnostics    */
DECL|method|buildSecurityDiagnostics ()
specifier|public
name|String
name|buildSecurityDiagnostics
parameter_list|()
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|secureRegistry
condition|?
literal|"secure registry; "
else|:
literal|"insecure registry; "
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"Access policy: "
argument_list|)
operator|.
name|append
argument_list|(
name|access
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|", System ACLs: "
argument_list|)
operator|.
name|append
argument_list|(
name|aclsToString
argument_list|(
name|systemACLs
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|UgiInfo
operator|.
name|fromCurrentUser
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|" Kerberos Realm: "
argument_list|)
operator|.
name|append
argument_list|(
name|kerberosRealm
argument_list|)
operator|.
name|append
argument_list|(
literal|" ; "
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|describeProperty
argument_list|(
name|Environment
operator|.
name|JAAS_CONF_KEY
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|sasl
init|=
name|System
operator|.
name|getProperty
argument_list|(
name|PROP_ZK_ENABLE_SASL_CLIENT
argument_list|,
name|DEFAULT_ZK_ENABLE_SASL_CLIENT
argument_list|)
decl_stmt|;
name|boolean
name|saslEnabled
init|=
name|Boolean
operator|.
name|valueOf
argument_list|(
name|sasl
argument_list|)
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|describeProperty
argument_list|(
name|PROP_ZK_ENABLE_SASL_CLIENT
argument_list|,
name|DEFAULT_ZK_ENABLE_SASL_CLIENT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|saslEnabled
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"JAAS Client Identity"
argument_list|)
operator|.
name|append
argument_list|(
literal|"="
argument_list|)
operator|.
name|append
argument_list|(
name|jaasClientIdentity
argument_list|)
operator|.
name|append
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|KEY_REGISTRY_CLIENT_JAAS_CONTEXT
argument_list|)
operator|.
name|append
argument_list|(
literal|"="
argument_list|)
operator|.
name|append
argument_list|(
name|jaasClientContext
argument_list|)
operator|.
name|append
argument_list|(
literal|"; "
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|describeProperty
argument_list|(
name|PROP_ZK_SASL_CLIENT_USERNAME
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|describeProperty
argument_list|(
name|PROP_ZK_SASL_CLIENT_CONTEXT
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|append
argument_list|(
name|describeProperty
argument_list|(
name|PROP_ZK_ALLOW_FAILED_SASL_CLIENTS
argument_list|,
literal|"(undefined but defaults to true)"
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|describeProperty
argument_list|(
name|PROP_ZK_SERVER_MAINTAIN_CONNECTION_DESPITE_SASL_FAILURE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|describeProperty (String name)
specifier|private
specifier|static
name|String
name|describeProperty
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|describeProperty
argument_list|(
name|name
argument_list|,
literal|"(undefined)"
argument_list|)
return|;
block|}
DECL|method|describeProperty (String name, String def)
specifier|private
specifier|static
name|String
name|describeProperty
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|def
parameter_list|)
block|{
return|return
literal|"; "
operator|+
name|name
operator|+
literal|"="
operator|+
name|System
operator|.
name|getProperty
argument_list|(
name|name
argument_list|,
name|def
argument_list|)
return|;
block|}
comment|/**    * Get the default kerberos realm âreturning "" if there    * is no realm or other problem    * @return the default realm of the system if it    * could be determined    */
DECL|method|getDefaultRealmInJVM ()
specifier|public
specifier|static
name|String
name|getDefaultRealmInJVM
parameter_list|()
block|{
try|try
block|{
return|return
name|KerberosUtil
operator|.
name|getDefaultRealm
argument_list|()
return|;
comment|// JDK7
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|ignored
parameter_list|)
block|{
comment|// ignored
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|ignored
parameter_list|)
block|{
comment|// ignored
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|ignored
parameter_list|)
block|{
comment|// ignored
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|ignored
parameter_list|)
block|{
comment|// ignored
block|}
return|return
literal|""
return|;
block|}
comment|/**    * Create an ACL For a user.    * @param ugi User identity    * @return the ACL For the specified user. Ifthe username doesn't end    * in "@" then the realm is added    */
DECL|method|createACLForUser (UserGroupInformation ugi, int perms)
specifier|public
name|ACL
name|createACLForUser
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
name|int
name|perms
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Creating ACL For "
argument_list|,
operator|new
name|UgiInfo
argument_list|(
name|ugi
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|secureRegistry
condition|)
block|{
return|return
name|ALL_READWRITE_ACCESS
return|;
block|}
else|else
block|{
return|return
name|createACLfromUsername
argument_list|(
name|ugi
operator|.
name|getUserName
argument_list|()
argument_list|,
name|perms
argument_list|)
return|;
block|}
block|}
comment|/**    * Given a user name (short or long), create a SASL ACL    * @param username user name; if it doesn't contain an "@" symbol, the    * service's kerberos realm is added    * @param perms permissions    * @return an ACL for the user    */
DECL|method|createACLfromUsername (String username, int perms)
specifier|public
name|ACL
name|createACLfromUsername
parameter_list|(
name|String
name|username
parameter_list|,
name|int
name|perms
parameter_list|)
block|{
if|if
condition|(
operator|!
name|username
operator|.
name|contains
argument_list|(
literal|"@"
argument_list|)
condition|)
block|{
name|username
operator|=
name|username
operator|+
literal|"@"
operator|+
name|kerberosRealm
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Appending kerberos realm to make {}"
argument_list|,
name|username
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|ACL
argument_list|(
name|perms
argument_list|,
operator|new
name|Id
argument_list|(
name|SCHEME_SASL
argument_list|,
name|username
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * On demand string-ifier for UGI with extra details    */
DECL|class|UgiInfo
specifier|public
specifier|static
class|class
name|UgiInfo
block|{
DECL|method|fromCurrentUser ()
specifier|public
specifier|static
name|UgiInfo
name|fromCurrentUser
parameter_list|()
block|{
try|try
block|{
return|return
operator|new
name|UgiInfo
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to get current user {}"
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|new
name|UgiInfo
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
DECL|field|ugi
specifier|private
specifier|final
name|UserGroupInformation
name|ugi
decl_stmt|;
DECL|method|UgiInfo (UserGroupInformation ugi)
specifier|public
name|UgiInfo
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|)
block|{
name|this
operator|.
name|ugi
operator|=
name|ugi
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|ugi
operator|==
literal|null
condition|)
block|{
return|return
literal|"(null ugi)"
return|;
block|}
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|ugi
operator|.
name|getUserName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|ugi
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|" hasKerberosCredentials="
argument_list|)
operator|.
name|append
argument_list|(
name|ugi
operator|.
name|hasKerberosCredentials
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|" isFromKeytab="
argument_list|)
operator|.
name|append
argument_list|(
name|ugi
operator|.
name|isFromKeytab
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|" kerberos is enabled in Hadoop ="
argument_list|)
operator|.
name|append
argument_list|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * on-demand stringifier for a list of ACLs    */
DECL|class|AclListInfo
specifier|public
specifier|static
class|class
name|AclListInfo
block|{
DECL|field|acls
specifier|public
specifier|final
name|List
argument_list|<
name|ACL
argument_list|>
name|acls
decl_stmt|;
DECL|method|AclListInfo (List<ACL> acls)
specifier|public
name|AclListInfo
parameter_list|(
name|List
argument_list|<
name|ACL
argument_list|>
name|acls
parameter_list|)
block|{
name|this
operator|.
name|acls
operator|=
name|acls
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|aclsToString
argument_list|(
name|acls
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

