begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *       http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.service.client.params
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|service
operator|.
name|client
operator|.
name|params
package|;
end_package

begin_import
import|import
name|com
operator|.
name|beust
operator|.
name|jcommander
operator|.
name|JCommander
import|;
end_import

begin_import
import|import
name|com
operator|.
name|beust
operator|.
name|jcommander
operator|.
name|Parameter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|beust
operator|.
name|jcommander
operator|.
name|ParameterDescription
import|;
end_import

begin_import
import|import
name|com
operator|.
name|beust
operator|.
name|jcommander
operator|.
name|ParameterException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|service
operator|.
name|utils
operator|.
name|SliderUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|service
operator|.
name|exceptions
operator|.
name|BadCommandArgumentsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|service
operator|.
name|exceptions
operator|.
name|ErrorStrings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|service
operator|.
name|exceptions
operator|.
name|SliderException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|service
operator|.
name|exceptions
operator|.
name|UsageException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * This class contains the common argument set for all tne entry points,  * and the core parsing logic to verify that the action is on the list  * of allowed actions -and that the remaining number of arguments is  * in the range allowed  */
end_comment

begin_class
DECL|class|CommonArgs
specifier|public
specifier|abstract
class|class
name|CommonArgs
extends|extends
name|ArgOps
implements|implements
name|SliderActions
implements|,
name|Arguments
block|{
DECL|field|log
specifier|protected
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|CommonArgs
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DIFF_BETWEEN_DESCIPTION_AND_COMMAND_NAME
specifier|private
specifier|static
specifier|final
name|int
name|DIFF_BETWEEN_DESCIPTION_AND_COMMAND_NAME
init|=
literal|30
decl_stmt|;
annotation|@
name|Parameter
argument_list|(
name|names
operator|=
name|ARG_HELP
argument_list|,
name|help
operator|=
literal|true
argument_list|)
DECL|field|help
specifier|public
name|boolean
name|help
decl_stmt|;
comment|/**    -D name=value     Define an HBase configuration option which overrides any options in    the configuration XML files of the image or in the image configuration    directory. The values will be persisted.    Configuration options are only passed to the cluster when creating or reconfiguring a cluster.     */
DECL|field|definitionMap
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|definitionMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * System properties    */
DECL|field|syspropsMap
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|syspropsMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * fields    */
DECL|field|commander
specifier|public
specifier|final
name|JCommander
name|commander
decl_stmt|;
DECL|field|args
specifier|private
specifier|final
name|String
index|[]
name|args
decl_stmt|;
DECL|field|coreAction
specifier|private
name|AbstractActionArgs
name|coreAction
decl_stmt|;
comment|/**    * get the name: relies on arg 1 being the cluster name in all operations     * @return the name argument, null if there is none    */
DECL|method|getClusterName ()
specifier|public
name|String
name|getClusterName
parameter_list|()
block|{
return|return
name|coreAction
operator|.
name|getClusterName
argument_list|()
return|;
block|}
DECL|method|CommonArgs (String[] args)
specifier|protected
name|CommonArgs
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|this
operator|.
name|args
operator|=
name|args
expr_stmt|;
name|commander
operator|=
operator|new
name|JCommander
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|CommonArgs (Collection args)
specifier|protected
name|CommonArgs
parameter_list|(
name|Collection
name|args
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|argsAsStrings
init|=
name|SliderUtils
operator|.
name|collectionToStringList
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|this
operator|.
name|args
operator|=
name|argsAsStrings
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|argsAsStrings
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
name|commander
operator|=
operator|new
name|JCommander
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|usage ()
specifier|public
name|String
name|usage
parameter_list|()
block|{
return|return
name|usage
argument_list|(
name|this
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|usage (CommonArgs serviceArgs, String commandOfInterest)
specifier|public
specifier|static
name|String
name|usage
parameter_list|(
name|CommonArgs
name|serviceArgs
parameter_list|,
name|String
name|commandOfInterest
parameter_list|)
block|{
name|String
name|result
init|=
literal|null
decl_stmt|;
name|StringBuilder
name|helperMessage
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|commandOfInterest
operator|==
literal|null
condition|)
block|{
comment|// JCommander.usage is too verbose for a command with many options like
comment|// slider no short version of that is found Instead, we compose our msg by
name|helperMessage
operator|.
name|append
argument_list|(
literal|"\nUsage: service COMMAND [options]\n"
argument_list|)
expr_stmt|;
name|helperMessage
operator|.
name|append
argument_list|(
literal|"where COMMAND is one of\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|jcommand
range|:
name|serviceArgs
operator|.
name|commander
operator|.
name|getCommands
argument_list|()
operator|.
name|keySet
argument_list|()
control|)
block|{
name|helperMessage
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"\t%-"
operator|+
name|DIFF_BETWEEN_DESCIPTION_AND_COMMAND_NAME
operator|+
literal|"s%s"
argument_list|,
name|jcommand
argument_list|,
name|serviceArgs
operator|.
name|commander
operator|.
name|getCommandDescription
argument_list|(
name|jcommand
argument_list|)
operator|+
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|helperMessage
operator|.
name|append
argument_list|(
literal|"Most commands print help when invoked without parameters or with --help"
argument_list|)
expr_stmt|;
name|result
operator|=
name|helperMessage
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|helperMessage
operator|.
name|append
argument_list|(
literal|"\nUsage: service "
argument_list|)
operator|.
name|append
argument_list|(
name|commandOfInterest
argument_list|)
expr_stmt|;
name|helperMessage
operator|.
name|append
argument_list|(
name|serviceArgs
operator|.
name|coreAction
operator|.
name|getMinParams
argument_list|()
operator|>
literal|0
condition|?
literal|"<service>"
else|:
literal|""
argument_list|)
expr_stmt|;
name|helperMessage
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ParameterDescription
name|paramDesc
range|:
name|serviceArgs
operator|.
name|commander
operator|.
name|getCommands
argument_list|()
operator|.
name|get
argument_list|(
name|commandOfInterest
argument_list|)
operator|.
name|getParameters
argument_list|()
control|)
block|{
name|String
name|optional
init|=
name|paramDesc
operator|.
name|getParameter
argument_list|()
operator|.
name|required
argument_list|()
condition|?
literal|"  (required)"
else|:
literal|"  (optional)"
decl_stmt|;
name|String
name|paramName
init|=
name|paramDesc
operator|.
name|getParameterized
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|Boolean
operator|.
name|TYPE
condition|?
name|paramDesc
operator|.
name|getLongestName
argument_list|()
else|:
name|paramDesc
operator|.
name|getLongestName
argument_list|()
operator|+
literal|"<"
operator|+
name|paramDesc
operator|.
name|getParameterized
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|">"
decl_stmt|;
name|helperMessage
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"\t%-"
operator|+
name|DIFF_BETWEEN_DESCIPTION_AND_COMMAND_NAME
operator|+
literal|"s%s"
argument_list|,
name|paramName
argument_list|,
name|paramDesc
operator|.
name|getDescription
argument_list|()
operator|+
name|optional
operator|+
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|helperMessage
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
DECL|method|usage (CommonArgs serviceArgs)
specifier|public
specifier|static
name|String
name|usage
parameter_list|(
name|CommonArgs
name|serviceArgs
parameter_list|)
block|{
return|return
name|usage
argument_list|(
name|serviceArgs
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Parse routine -includes registering the action-specific argument classes    * and postprocess it    * @throws SliderException on any problem    */
DECL|method|parse ()
specifier|public
name|void
name|parse
parameter_list|()
throws|throws
name|SliderException
block|{
name|addActionArguments
argument_list|()
expr_stmt|;
try|try
block|{
name|commander
operator|.
name|parse
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ParameterException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
name|e
argument_list|,
literal|"%s in %s"
argument_list|,
name|e
operator|.
name|toString
argument_list|()
argument_list|,
operator|(
name|args
operator|!=
literal|null
condition|?
operator|(
name|SliderUtils
operator|.
name|join
argument_list|(
name|args
argument_list|,
literal|" "
argument_list|,
literal|false
argument_list|)
operator|)
else|:
literal|"[]"
operator|)
argument_list|)
throw|;
block|}
comment|//now copy back to this class some of the attributes that are common to all
comment|//actions
name|postProcess
argument_list|()
expr_stmt|;
block|}
comment|/**    * Add a command    * @param name action    * @param arg value    */
DECL|method|addAction (String name, Object arg)
specifier|protected
name|void
name|addAction
parameter_list|(
name|String
name|name
parameter_list|,
name|Object
name|arg
parameter_list|)
block|{
name|commander
operator|.
name|addCommand
argument_list|(
name|name
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
DECL|method|addActions (Object... actions)
specifier|protected
name|void
name|addActions
parameter_list|(
name|Object
modifier|...
name|actions
parameter_list|)
block|{
for|for
control|(
name|Object
name|action
range|:
name|actions
control|)
block|{
name|commander
operator|.
name|addCommand
argument_list|(
name|action
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Override point to add a set of actions    */
DECL|method|addActionArguments ()
specifier|protected
name|void
name|addActionArguments
parameter_list|()
block|{    }
comment|/**    * validate args via {@link #validate()}    * then postprocess the arguments    */
DECL|method|postProcess ()
specifier|public
name|void
name|postProcess
parameter_list|()
throws|throws
name|SliderException
block|{
name|applyAction
argument_list|()
expr_stmt|;
name|validate
argument_list|()
expr_stmt|;
comment|//apply entry set
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|syspropsMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|System
operator|.
name|setProperty
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Implementors must implement their action apply routine here    */
DECL|method|applyAction ()
specifier|public
specifier|abstract
name|void
name|applyAction
parameter_list|()
throws|throws
name|SliderException
function_decl|;
comment|/**    * Bind the core action; this extracts any attributes that are used    * across routines    * @param action action to bind    */
DECL|method|bindCoreAction (AbstractActionArgs action)
specifier|protected
name|void
name|bindCoreAction
parameter_list|(
name|AbstractActionArgs
name|action
parameter_list|)
block|{
name|coreAction
operator|=
name|action
expr_stmt|;
name|splitPairs
argument_list|(
name|coreAction
operator|.
name|definitions
argument_list|,
name|definitionMap
argument_list|)
expr_stmt|;
name|splitPairs
argument_list|(
name|coreAction
operator|.
name|sysprops
argument_list|,
name|syspropsMap
argument_list|)
expr_stmt|;
block|}
comment|/**    * Validate the arguments against the action requested    */
DECL|method|validate ()
specifier|public
name|void
name|validate
parameter_list|()
throws|throws
name|BadCommandArgumentsException
throws|,
name|UsageException
block|{
if|if
condition|(
name|coreAction
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UsageException
argument_list|(
name|ErrorStrings
operator|.
name|ERROR_NO_ACTION
operator|+
name|usage
argument_list|()
argument_list|)
throw|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"action={}"
argument_list|,
name|getAction
argument_list|()
argument_list|)
expr_stmt|;
comment|// let the action validate itself
try|try
block|{
name|coreAction
operator|.
name|validate
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BadCommandArgumentsException
name|e
parameter_list|)
block|{
name|String
name|badArgMsgBuilder
init|=
name|e
operator|.
name|getMessage
argument_list|()
operator|+
name|System
operator|.
name|lineSeparator
argument_list|()
operator|+
name|usage
argument_list|(
name|this
argument_list|,
name|coreAction
operator|.
name|getActionName
argument_list|()
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
name|badArgMsgBuilder
argument_list|)
throw|;
block|}
block|}
comment|/**    * Apply all the definitions on the command line to the configuration    * @param conf config    */
DECL|method|applyDefinitions (Configuration conf)
specifier|public
name|void
name|applyDefinitions
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|BadCommandArgumentsException
block|{
name|applyDefinitions
argument_list|(
name|definitionMap
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * If the Filesystem binding was provided, it overrides anything in    * the configuration    * @param conf configuration    */
DECL|method|applyFileSystemBinding (Configuration conf)
specifier|public
name|void
name|applyFileSystemBinding
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|ArgOps
operator|.
name|applyFileSystemBinding
argument_list|(
name|getFilesystemBinding
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
DECL|method|isDebug ()
specifier|public
name|boolean
name|isDebug
parameter_list|()
block|{
return|return
name|coreAction
operator|.
name|debug
return|;
block|}
DECL|method|getFilesystemBinding ()
specifier|public
name|String
name|getFilesystemBinding
parameter_list|()
block|{
return|return
name|coreAction
operator|.
name|filesystemBinding
return|;
block|}
DECL|method|getBasePath ()
specifier|public
name|Path
name|getBasePath
parameter_list|()
block|{
return|return
name|coreAction
operator|.
name|basePath
return|;
block|}
DECL|method|getManager ()
specifier|public
name|String
name|getManager
parameter_list|()
block|{
return|return
name|coreAction
operator|.
name|manager
return|;
block|}
DECL|method|getAction ()
specifier|public
name|String
name|getAction
parameter_list|()
block|{
return|return
name|commander
operator|.
name|getParsedCommand
argument_list|()
return|;
block|}
block|}
end_class

end_unit

