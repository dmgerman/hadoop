begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.applications.distributedshell
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|applications
operator|.
name|distributedshell
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|CommandLine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|GnuParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|HelpFormatter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|AMRMProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|ApplicationConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|ContainerManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|AllocateRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|AllocateResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|FinishApplicationMasterRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|RegisterApplicationMasterResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|StartContainerRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationAttemptId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Container
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerLaunchContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|FinalApplicationStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|LocalResource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|LocalResourceType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|LocalResourceVisibility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Priority
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ResourceRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|AMRMClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|AMRMClient
operator|.
name|ContainerRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|AMRMClientImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnRemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|ipc
operator|.
name|YarnRPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|ConverterUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|Records
import|;
end_import

begin_comment
comment|/**  * An ApplicationMaster for executing shell commands on a set of launched  * containers using the YARN framework.  *   *<p>  * This class is meant to act as an example on how to write yarn-based  * application masters.  *</p>  *   *<p>  * The ApplicationMaster is started on a container by the  *<code>ResourceManager</code>'s launcher. The first thing that the  *<code>ApplicationMaster</code> needs to do is to connect and register itself  * with the<code>ResourceManager</code>. The registration sets up information  * within the<code>ResourceManager</code> regarding what host:port the  * ApplicationMaster is listening on to provide any form of functionality to a  * client as well as a tracking url that a client can use to keep track of  * status/job history if needed.  *</p>  *   *<p>  * The<code>ApplicationMaster</code> needs to send a heartbeat to the  *<code>ResourceManager</code> at regular intervals to inform the  *<code>ResourceManager</code> that it is up and alive. The  * {@link AMRMProtocol#allocate} to the<code>ResourceManager</code> from the  *<code>ApplicationMaster</code> acts as a heartbeat.  *   *<p>  * For the actual handling of the job, the<code>ApplicationMaster</code> has to  * request the<code>ResourceManager</code> via {@link AllocateRequest} for the  * required no. of containers using {@link ResourceRequest} with the necessary  * resource specifications such as node location, computational  * (memory/disk/cpu) resource requirements. The<code>ResourceManager</code>  * responds with an {@link AllocateResponse} that informs the  *<code>ApplicationMaster</code> of the set of newly allocated containers,  * completed containers as well as current state of available resources.  *</p>  *   *<p>  * For each allocated container, the<code>ApplicationMaster</code> can then set  * up the necessary launch context via {@link ContainerLaunchContext} to specify  * the allocated container id, local resources required by the executable, the  * environment to be setup for the executable, commands to execute, etc. and  * submit a {@link StartContainerRequest} to the {@link ContainerManager} to  * launch and execute the defined commands on the given allocated container.  *</p>  *   *<p>  * The<code>ApplicationMaster</code> can monitor the launched container by  * either querying the<code>ResourceManager</code> using  * {@link AMRMProtocol#allocate} to get updates on completed containers or via  * the {@link ContainerManager} by querying for the status of the allocated  * container's {@link ContainerId}.  *  *<p>  * After the job has been completed, the<code>ApplicationMaster</code> has to  * send a {@link FinishApplicationMasterRequest} to the  *<code>ResourceManager</code> to inform it that the  *<code>ApplicationMaster</code> has been completed.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|ApplicationMaster
specifier|public
class|class
name|ApplicationMaster
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ApplicationMaster
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Configuration
DECL|field|conf
specifier|private
name|Configuration
name|conf
decl_stmt|;
comment|// YARN RPC to communicate with the Resource Manager or Node Manager
DECL|field|rpc
specifier|private
name|YarnRPC
name|rpc
decl_stmt|;
comment|// Handle to communicate with the Resource Manager
DECL|field|resourceManager
specifier|private
name|AMRMClient
name|resourceManager
decl_stmt|;
comment|// Application Attempt Id ( combination of attemptId and fail count )
DECL|field|appAttemptID
specifier|private
name|ApplicationAttemptId
name|appAttemptID
decl_stmt|;
comment|// TODO
comment|// For status update for clients - yet to be implemented
comment|// Hostname of the container
DECL|field|appMasterHostname
specifier|private
name|String
name|appMasterHostname
init|=
literal|""
decl_stmt|;
comment|// Port on which the app master listens for status updates from clients
DECL|field|appMasterRpcPort
specifier|private
name|int
name|appMasterRpcPort
init|=
literal|0
decl_stmt|;
comment|// Tracking url to which app master publishes info for clients to monitor
DECL|field|appMasterTrackingUrl
specifier|private
name|String
name|appMasterTrackingUrl
init|=
literal|""
decl_stmt|;
comment|// App Master configuration
comment|// No. of containers to run shell command on
DECL|field|numTotalContainers
specifier|private
name|int
name|numTotalContainers
init|=
literal|1
decl_stmt|;
comment|// Memory to request for the container on which the shell command will run
DECL|field|containerMemory
specifier|private
name|int
name|containerMemory
init|=
literal|10
decl_stmt|;
comment|// Priority of the request
DECL|field|requestPriority
specifier|private
name|int
name|requestPriority
decl_stmt|;
comment|// Simple flag to denote whether all works is done
DECL|field|appDone
specifier|private
name|boolean
name|appDone
init|=
literal|false
decl_stmt|;
comment|// Counter for completed containers ( complete denotes successful or failed )
DECL|field|numCompletedContainers
specifier|private
name|AtomicInteger
name|numCompletedContainers
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|// Allocated container count so that we know how many containers has the RM
comment|// allocated to us
DECL|field|numAllocatedContainers
specifier|private
name|AtomicInteger
name|numAllocatedContainers
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|// Count of failed containers
DECL|field|numFailedContainers
specifier|private
name|AtomicInteger
name|numFailedContainers
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|// Count of containers already requested from the RM
comment|// Needed as once requested, we should not request for containers again.
comment|// Only request for more if the original requirement changes.
DECL|field|numRequestedContainers
specifier|private
name|AtomicInteger
name|numRequestedContainers
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|// Shell command to be executed
DECL|field|shellCommand
specifier|private
name|String
name|shellCommand
init|=
literal|""
decl_stmt|;
comment|// Args to be passed to the shell command
DECL|field|shellArgs
specifier|private
name|String
name|shellArgs
init|=
literal|""
decl_stmt|;
comment|// Env variables to be setup for the shell command
DECL|field|shellEnv
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|shellEnv
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// Location of shell script ( obtained from info set in env )
comment|// Shell script path in fs
DECL|field|shellScriptPath
specifier|private
name|String
name|shellScriptPath
init|=
literal|""
decl_stmt|;
comment|// Timestamp needed for creating a local resource
DECL|field|shellScriptPathTimestamp
specifier|private
name|long
name|shellScriptPathTimestamp
init|=
literal|0
decl_stmt|;
comment|// File length needed for local resource
DECL|field|shellScriptPathLen
specifier|private
name|long
name|shellScriptPathLen
init|=
literal|0
decl_stmt|;
comment|// Hardcoded path to shell script in launch container's local env
DECL|field|ExecShellStringPath
specifier|private
specifier|final
name|String
name|ExecShellStringPath
init|=
literal|"ExecShellScript.sh"
decl_stmt|;
comment|// Launch threads
DECL|field|launchThreads
specifier|private
name|List
argument_list|<
name|Thread
argument_list|>
name|launchThreads
init|=
operator|new
name|ArrayList
argument_list|<
name|Thread
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * @param args Command line args    */
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|boolean
name|result
init|=
literal|false
decl_stmt|;
try|try
block|{
name|ApplicationMaster
name|appMaster
init|=
operator|new
name|ApplicationMaster
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Initializing ApplicationMaster"
argument_list|)
expr_stmt|;
name|boolean
name|doRun
init|=
name|appMaster
operator|.
name|init
argument_list|(
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|doRun
condition|)
block|{
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|appMaster
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Error running ApplicationMaster"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Application Master completed successfully. exiting"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Application Master failed. exiting"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Dump out contents of $CWD and the environment to stdout for debugging    */
DECL|method|dumpOutDebugInfo ()
specifier|private
name|void
name|dumpOutDebugInfo
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Dump debug output"
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|envs
init|=
name|System
operator|.
name|getenv
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
range|:
name|envs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"System env: key="
operator|+
name|env
operator|.
name|getKey
argument_list|()
operator|+
literal|", val="
operator|+
name|env
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"System env: key="
operator|+
name|env
operator|.
name|getKey
argument_list|()
operator|+
literal|", val="
operator|+
name|env
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
name|cmd
init|=
literal|"ls -al"
decl_stmt|;
name|Runtime
name|run
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
decl_stmt|;
name|Process
name|pr
init|=
literal|null
decl_stmt|;
try|try
block|{
name|pr
operator|=
name|run
operator|.
name|exec
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|pr
operator|.
name|waitFor
argument_list|()
expr_stmt|;
name|BufferedReader
name|buf
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|pr
operator|.
name|getInputStream
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|line
init|=
literal|""
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|buf
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"System CWD content: "
operator|+
name|line
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"System CWD content: "
operator|+
name|line
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|ApplicationMaster ()
specifier|public
name|ApplicationMaster
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Set up the configuration and RPC
name|conf
operator|=
operator|new
name|YarnConfiguration
argument_list|()
expr_stmt|;
name|rpc
operator|=
name|YarnRPC
operator|.
name|create
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Parse command line options    *    * @param args Command line args    * @return Whether init successful and run should be invoked    * @throws ParseException    * @throws IOException    */
DECL|method|init (String[] args)
specifier|public
name|boolean
name|init
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|ParseException
throws|,
name|IOException
block|{
name|Options
name|opts
init|=
operator|new
name|Options
argument_list|()
decl_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"app_attempt_id"
argument_list|,
literal|true
argument_list|,
literal|"App Attempt ID. Not to be used unless for testing purposes"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"shell_command"
argument_list|,
literal|true
argument_list|,
literal|"Shell command to be executed by the Application Master"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"shell_script"
argument_list|,
literal|true
argument_list|,
literal|"Location of the shell script to be executed"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"shell_args"
argument_list|,
literal|true
argument_list|,
literal|"Command line args for the shell script"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"shell_env"
argument_list|,
literal|true
argument_list|,
literal|"Environment for shell script. Specified as env_key=env_val pairs"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"container_memory"
argument_list|,
literal|true
argument_list|,
literal|"Amount of memory in MB to be requested to run the shell command"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"num_containers"
argument_list|,
literal|true
argument_list|,
literal|"No. of containers on which the shell command needs to be executed"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"priority"
argument_list|,
literal|true
argument_list|,
literal|"Application Priority. Default 0"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"debug"
argument_list|,
literal|false
argument_list|,
literal|"Dump out debug information"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"help"
argument_list|,
literal|false
argument_list|,
literal|"Print usage"
argument_list|)
expr_stmt|;
name|CommandLine
name|cliParser
init|=
operator|new
name|GnuParser
argument_list|()
operator|.
name|parse
argument_list|(
name|opts
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|printUsage
argument_list|(
name|opts
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No args specified for application master to initialize"
argument_list|)
throw|;
block|}
if|if
condition|(
name|cliParser
operator|.
name|hasOption
argument_list|(
literal|"help"
argument_list|)
condition|)
block|{
name|printUsage
argument_list|(
name|opts
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|cliParser
operator|.
name|hasOption
argument_list|(
literal|"debug"
argument_list|)
condition|)
block|{
name|dumpOutDebugInfo
argument_list|()
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|envs
init|=
name|System
operator|.
name|getenv
argument_list|()
decl_stmt|;
if|if
condition|(
name|envs
operator|.
name|containsKey
argument_list|(
name|ApplicationConstants
operator|.
name|AM_APP_ATTEMPT_ID_ENV
argument_list|)
condition|)
block|{
name|appAttemptID
operator|=
name|ConverterUtils
operator|.
name|toApplicationAttemptId
argument_list|(
name|envs
operator|.
name|get
argument_list|(
name|ApplicationConstants
operator|.
name|AM_APP_ATTEMPT_ID_ENV
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|envs
operator|.
name|containsKey
argument_list|(
name|ApplicationConstants
operator|.
name|AM_CONTAINER_ID_ENV
argument_list|)
condition|)
block|{
if|if
condition|(
name|cliParser
operator|.
name|hasOption
argument_list|(
literal|"app_attempt_id"
argument_list|)
condition|)
block|{
name|String
name|appIdStr
init|=
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"app_attempt_id"
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|appAttemptID
operator|=
name|ConverterUtils
operator|.
name|toApplicationAttemptId
argument_list|(
name|appIdStr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Application Attempt Id not set in the environment"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|ContainerId
name|containerId
init|=
name|ConverterUtils
operator|.
name|toContainerId
argument_list|(
name|envs
operator|.
name|get
argument_list|(
name|ApplicationConstants
operator|.
name|AM_CONTAINER_ID_ENV
argument_list|)
argument_list|)
decl_stmt|;
name|appAttemptID
operator|=
name|containerId
operator|.
name|getApplicationAttemptId
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Application master for app"
operator|+
literal|", appId="
operator|+
name|appAttemptID
operator|.
name|getApplicationId
argument_list|()
operator|.
name|getId
argument_list|()
operator|+
literal|", clustertimestamp="
operator|+
name|appAttemptID
operator|.
name|getApplicationId
argument_list|()
operator|.
name|getClusterTimestamp
argument_list|()
operator|+
literal|", attemptId="
operator|+
name|appAttemptID
operator|.
name|getAttemptId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cliParser
operator|.
name|hasOption
argument_list|(
literal|"shell_command"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No shell command specified to be executed by application master"
argument_list|)
throw|;
block|}
name|shellCommand
operator|=
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"shell_command"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cliParser
operator|.
name|hasOption
argument_list|(
literal|"shell_args"
argument_list|)
condition|)
block|{
name|shellArgs
operator|=
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"shell_args"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cliParser
operator|.
name|hasOption
argument_list|(
literal|"shell_env"
argument_list|)
condition|)
block|{
name|String
name|shellEnvs
index|[]
init|=
name|cliParser
operator|.
name|getOptionValues
argument_list|(
literal|"shell_env"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|env
range|:
name|shellEnvs
control|)
block|{
name|env
operator|=
name|env
operator|.
name|trim
argument_list|()
expr_stmt|;
name|int
name|index
init|=
name|env
operator|.
name|indexOf
argument_list|(
literal|'='
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|shellEnv
operator|.
name|put
argument_list|(
name|env
argument_list|,
literal|""
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|String
name|key
init|=
name|env
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|String
name|val
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|index
operator|<
operator|(
name|env
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
name|val
operator|=
name|env
operator|.
name|substring
argument_list|(
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|shellEnv
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|envs
operator|.
name|containsKey
argument_list|(
name|DSConstants
operator|.
name|DISTRIBUTEDSHELLSCRIPTLOCATION
argument_list|)
condition|)
block|{
name|shellScriptPath
operator|=
name|envs
operator|.
name|get
argument_list|(
name|DSConstants
operator|.
name|DISTRIBUTEDSHELLSCRIPTLOCATION
argument_list|)
expr_stmt|;
if|if
condition|(
name|envs
operator|.
name|containsKey
argument_list|(
name|DSConstants
operator|.
name|DISTRIBUTEDSHELLSCRIPTTIMESTAMP
argument_list|)
condition|)
block|{
name|shellScriptPathTimestamp
operator|=
name|Long
operator|.
name|valueOf
argument_list|(
name|envs
operator|.
name|get
argument_list|(
name|DSConstants
operator|.
name|DISTRIBUTEDSHELLSCRIPTTIMESTAMP
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|envs
operator|.
name|containsKey
argument_list|(
name|DSConstants
operator|.
name|DISTRIBUTEDSHELLSCRIPTLEN
argument_list|)
condition|)
block|{
name|shellScriptPathLen
operator|=
name|Long
operator|.
name|valueOf
argument_list|(
name|envs
operator|.
name|get
argument_list|(
name|DSConstants
operator|.
name|DISTRIBUTEDSHELLSCRIPTLEN
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|shellScriptPath
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
name|shellScriptPathTimestamp
operator|<=
literal|0
operator|||
name|shellScriptPathLen
operator|<=
literal|0
operator|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Illegal values in env for shell script path"
operator|+
literal|", path="
operator|+
name|shellScriptPath
operator|+
literal|", len="
operator|+
name|shellScriptPathLen
operator|+
literal|", timestamp="
operator|+
name|shellScriptPathTimestamp
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal values in env for shell script path"
argument_list|)
throw|;
block|}
block|}
name|containerMemory
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"container_memory"
argument_list|,
literal|"10"
argument_list|)
argument_list|)
expr_stmt|;
name|numTotalContainers
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"num_containers"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|requestPriority
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"priority"
argument_list|,
literal|"0"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Helper function to print usage    *    * @param opts Parsed command line options    */
DECL|method|printUsage (Options opts)
specifier|private
name|void
name|printUsage
parameter_list|(
name|Options
name|opts
parameter_list|)
block|{
operator|new
name|HelpFormatter
argument_list|()
operator|.
name|printHelp
argument_list|(
literal|"ApplicationMaster"
argument_list|,
name|opts
argument_list|)
expr_stmt|;
block|}
comment|/**    * Main run function for the application master    *    * @throws YarnRemoteException    */
DECL|method|run ()
specifier|public
name|boolean
name|run
parameter_list|()
throws|throws
name|YarnRemoteException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting ApplicationMaster"
argument_list|)
expr_stmt|;
comment|// Connect to ResourceManager
name|resourceManager
operator|=
operator|new
name|AMRMClientImpl
argument_list|(
name|appAttemptID
argument_list|)
expr_stmt|;
name|resourceManager
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|resourceManager
operator|.
name|start
argument_list|()
expr_stmt|;
try|try
block|{
comment|// Setup local RPC Server to accept status requests directly from clients
comment|// TODO need to setup a protocol for client to be able to communicate to
comment|// the RPC server
comment|// TODO use the rpc port info to register with the RM for the client to
comment|// send requests to this app master
comment|// Register self with ResourceManager
name|RegisterApplicationMasterResponse
name|response
init|=
name|resourceManager
operator|.
name|registerApplicationMaster
argument_list|(
name|appMasterHostname
argument_list|,
name|appMasterRpcPort
argument_list|,
name|appMasterTrackingUrl
argument_list|)
decl_stmt|;
comment|// Dump out information about cluster capability as seen by the
comment|// resource manager
name|int
name|minMem
init|=
name|response
operator|.
name|getMinimumResourceCapability
argument_list|()
operator|.
name|getMemory
argument_list|()
decl_stmt|;
name|int
name|maxMem
init|=
name|response
operator|.
name|getMaximumResourceCapability
argument_list|()
operator|.
name|getMemory
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Min mem capabililty of resources in this cluster "
operator|+
name|minMem
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Max mem capabililty of resources in this cluster "
operator|+
name|maxMem
argument_list|)
expr_stmt|;
comment|// A resource ask has to be atleast the minimum of the capability of the
comment|// cluster, the value has to be a multiple of the min value and cannot
comment|// exceed the max.
comment|// If it is not an exact multiple of min, the RM will allocate to the
comment|// nearest multiple of min
if|if
condition|(
name|containerMemory
operator|<
name|minMem
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Container memory specified below min threshold of cluster."
operator|+
literal|" Using min value."
operator|+
literal|", specified="
operator|+
name|containerMemory
operator|+
literal|", min="
operator|+
name|minMem
argument_list|)
expr_stmt|;
name|containerMemory
operator|=
name|minMem
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|containerMemory
operator|>
name|maxMem
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Container memory specified above max threshold of cluster."
operator|+
literal|" Using max value."
operator|+
literal|", specified="
operator|+
name|containerMemory
operator|+
literal|", max="
operator|+
name|maxMem
argument_list|)
expr_stmt|;
name|containerMemory
operator|=
name|maxMem
expr_stmt|;
block|}
comment|// Setup heartbeat emitter
comment|// TODO poll RM every now and then with an empty request to let RM know
comment|// that we are alive
comment|// The heartbeat interval after which an AM is timed out by the RM is
comment|// defined by a config setting:
comment|// RM_AM_EXPIRY_INTERVAL_MS with default defined by
comment|// DEFAULT_RM_AM_EXPIRY_INTERVAL_MS
comment|// The allocate calls to the RM count as heartbeats so, for now,
comment|// this additional heartbeat emitter is not required.
comment|// Setup ask for containers from RM
comment|// Send request for containers to RM
comment|// Until we get our fully allocated quota, we keep on polling RM for
comment|// containers
comment|// Keep looping until all the containers are launched and shell script
comment|// executed on them ( regardless of success/failure).
name|int
name|loopCounter
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|numCompletedContainers
operator|.
name|get
argument_list|()
operator|<
name|numTotalContainers
operator|&&
operator|!
name|appDone
condition|)
block|{
name|loopCounter
operator|++
expr_stmt|;
comment|// log current state
name|LOG
operator|.
name|info
argument_list|(
literal|"Current application state: loop="
operator|+
name|loopCounter
operator|+
literal|", appDone="
operator|+
name|appDone
operator|+
literal|", total="
operator|+
name|numTotalContainers
operator|+
literal|", requested="
operator|+
name|numRequestedContainers
operator|+
literal|", completed="
operator|+
name|numCompletedContainers
operator|+
literal|", failed="
operator|+
name|numFailedContainers
operator|+
literal|", currentAllocated="
operator|+
name|numAllocatedContainers
argument_list|)
expr_stmt|;
comment|// Sleep before each loop when asking RM for containers
comment|// to avoid flooding RM with spurious requests when it
comment|// need not have any available containers
comment|// Sleeping for 1000 ms.
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Sleep interrupted "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// No. of containers to request
comment|// For the first loop, askCount will be equal to total containers needed
comment|// From that point on, askCount will always be 0 as current
comment|// implementation does not change its ask on container failures.
name|int
name|askCount
init|=
name|numTotalContainers
operator|-
name|numRequestedContainers
operator|.
name|get
argument_list|()
decl_stmt|;
name|numRequestedContainers
operator|.
name|addAndGet
argument_list|(
name|askCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|askCount
operator|>
literal|0
condition|)
block|{
name|ContainerRequest
name|containerAsk
init|=
name|setupContainerAskForRM
argument_list|(
name|askCount
argument_list|)
decl_stmt|;
name|resourceManager
operator|.
name|addContainerRequest
argument_list|(
name|containerAsk
argument_list|)
expr_stmt|;
block|}
comment|// Send the request to RM
name|LOG
operator|.
name|info
argument_list|(
literal|"Asking RM for containers"
operator|+
literal|", askCount="
operator|+
name|askCount
argument_list|)
expr_stmt|;
name|AllocateResponse
name|allocResp
init|=
name|sendContainerAskToRM
argument_list|()
decl_stmt|;
comment|// Retrieve list of allocated containers from the response
name|List
argument_list|<
name|Container
argument_list|>
name|allocatedContainers
init|=
name|allocResp
operator|.
name|getAllocatedContainers
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Got response from RM for container ask, allocatedCnt="
operator|+
name|allocatedContainers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|numAllocatedContainers
operator|.
name|addAndGet
argument_list|(
name|allocatedContainers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Container
name|allocatedContainer
range|:
name|allocatedContainers
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Launching shell command on a new container."
operator|+
literal|", containerId="
operator|+
name|allocatedContainer
operator|.
name|getId
argument_list|()
operator|+
literal|", containerNode="
operator|+
name|allocatedContainer
operator|.
name|getNodeId
argument_list|()
operator|.
name|getHost
argument_list|()
operator|+
literal|":"
operator|+
name|allocatedContainer
operator|.
name|getNodeId
argument_list|()
operator|.
name|getPort
argument_list|()
operator|+
literal|", containerNodeURI="
operator|+
name|allocatedContainer
operator|.
name|getNodeHttpAddress
argument_list|()
operator|+
literal|", containerState"
operator|+
name|allocatedContainer
operator|.
name|getState
argument_list|()
operator|+
literal|", containerResourceMemory"
operator|+
name|allocatedContainer
operator|.
name|getResource
argument_list|()
operator|.
name|getMemory
argument_list|()
argument_list|)
expr_stmt|;
comment|// + ", containerToken"
comment|// +allocatedContainer.getContainerToken().getIdentifier().toString());
name|LaunchContainerRunnable
name|runnableLaunchContainer
init|=
operator|new
name|LaunchContainerRunnable
argument_list|(
name|allocatedContainer
argument_list|)
decl_stmt|;
name|Thread
name|launchThread
init|=
operator|new
name|Thread
argument_list|(
name|runnableLaunchContainer
argument_list|)
decl_stmt|;
comment|// launch and start the container on a separate thread to keep
comment|// the main thread unblocked
comment|// as all containers may not be allocated at one go.
name|launchThreads
operator|.
name|add
argument_list|(
name|launchThread
argument_list|)
expr_stmt|;
name|launchThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|// Check what the current available resources in the cluster are
comment|// TODO should we do anything if the available resources are not enough?
name|Resource
name|availableResources
init|=
name|allocResp
operator|.
name|getAvailableResources
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Current available resources in the cluster "
operator|+
name|availableResources
argument_list|)
expr_stmt|;
comment|// Check the completed containers
name|List
argument_list|<
name|ContainerStatus
argument_list|>
name|completedContainers
init|=
name|allocResp
operator|.
name|getCompletedContainersStatuses
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Got response from RM for container ask, completedCnt="
operator|+
name|completedContainers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|ContainerStatus
name|containerStatus
range|:
name|completedContainers
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Got container status for containerID="
operator|+
name|containerStatus
operator|.
name|getContainerId
argument_list|()
operator|+
literal|", state="
operator|+
name|containerStatus
operator|.
name|getState
argument_list|()
operator|+
literal|", exitStatus="
operator|+
name|containerStatus
operator|.
name|getExitStatus
argument_list|()
operator|+
literal|", diagnostics="
operator|+
name|containerStatus
operator|.
name|getDiagnostics
argument_list|()
argument_list|)
expr_stmt|;
comment|// non complete containers should not be here
assert|assert
operator|(
name|containerStatus
operator|.
name|getState
argument_list|()
operator|==
name|ContainerState
operator|.
name|COMPLETE
operator|)
assert|;
comment|// increment counters for completed/failed containers
name|int
name|exitStatus
init|=
name|containerStatus
operator|.
name|getExitStatus
argument_list|()
decl_stmt|;
if|if
condition|(
literal|0
operator|!=
name|exitStatus
condition|)
block|{
comment|// container failed
if|if
condition|(
operator|-
literal|100
operator|!=
name|exitStatus
condition|)
block|{
comment|// shell script failed
comment|// counts as completed
name|numCompletedContainers
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|numFailedContainers
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// something else bad happened
comment|// app job did not complete for some reason
comment|// we should re-try as the container was lost for some reason
name|numAllocatedContainers
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
name|numRequestedContainers
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
comment|// we do not need to release the container as it would be done
comment|// by the RM/CM.
block|}
block|}
else|else
block|{
comment|// nothing to do
comment|// container completed successfully
name|numCompletedContainers
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Container completed successfully."
operator|+
literal|", containerId="
operator|+
name|containerStatus
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|numCompletedContainers
operator|.
name|get
argument_list|()
operator|==
name|numTotalContainers
condition|)
block|{
name|appDone
operator|=
literal|true
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Current application state: loop="
operator|+
name|loopCounter
operator|+
literal|", appDone="
operator|+
name|appDone
operator|+
literal|", total="
operator|+
name|numTotalContainers
operator|+
literal|", requested="
operator|+
name|numRequestedContainers
operator|+
literal|", completed="
operator|+
name|numCompletedContainers
operator|+
literal|", failed="
operator|+
name|numFailedContainers
operator|+
literal|", currentAllocated="
operator|+
name|numAllocatedContainers
argument_list|)
expr_stmt|;
comment|// TODO
comment|// Add a timeout handling layer
comment|// for misbehaving shell commands
block|}
comment|// Join all launched threads
comment|// needed for when we time out
comment|// and we need to release containers
for|for
control|(
name|Thread
name|launchThread
range|:
name|launchThreads
control|)
block|{
try|try
block|{
name|launchThread
operator|.
name|join
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Exception thrown in thread join: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|// When the application completes, it should send a finish application
comment|// signal to the RM
name|LOG
operator|.
name|info
argument_list|(
literal|"Application completed. Signalling finish to RM"
argument_list|)
expr_stmt|;
name|FinalApplicationStatus
name|appStatus
decl_stmt|;
name|String
name|appMessage
init|=
literal|null
decl_stmt|;
name|boolean
name|isSuccess
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|numFailedContainers
operator|.
name|get
argument_list|()
operator|==
literal|0
condition|)
block|{
name|appStatus
operator|=
name|FinalApplicationStatus
operator|.
name|SUCCEEDED
expr_stmt|;
block|}
else|else
block|{
name|appStatus
operator|=
name|FinalApplicationStatus
operator|.
name|FAILED
expr_stmt|;
name|appMessage
operator|=
literal|"Diagnostics."
operator|+
literal|", total="
operator|+
name|numTotalContainers
operator|+
literal|", completed="
operator|+
name|numCompletedContainers
operator|.
name|get
argument_list|()
operator|+
literal|", allocated="
operator|+
name|numAllocatedContainers
operator|.
name|get
argument_list|()
operator|+
literal|", failed="
operator|+
name|numFailedContainers
operator|.
name|get
argument_list|()
expr_stmt|;
name|isSuccess
operator|=
literal|false
expr_stmt|;
block|}
name|resourceManager
operator|.
name|unregisterApplicationMaster
argument_list|(
name|appStatus
argument_list|,
name|appMessage
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|isSuccess
return|;
block|}
finally|finally
block|{
name|resourceManager
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Thread to connect to the {@link ContainerManager} and launch the container    * that will execute the shell command.    */
DECL|class|LaunchContainerRunnable
specifier|private
class|class
name|LaunchContainerRunnable
implements|implements
name|Runnable
block|{
comment|// Allocated container
DECL|field|container
name|Container
name|container
decl_stmt|;
comment|// Handle to communicate with ContainerManager
DECL|field|cm
name|ContainerManager
name|cm
decl_stmt|;
comment|/**      * @param lcontainer Allocated container      */
DECL|method|LaunchContainerRunnable (Container lcontainer)
specifier|public
name|LaunchContainerRunnable
parameter_list|(
name|Container
name|lcontainer
parameter_list|)
block|{
name|this
operator|.
name|container
operator|=
name|lcontainer
expr_stmt|;
block|}
comment|/**      * Helper function to connect to CM      */
DECL|method|connectToCM ()
specifier|private
name|void
name|connectToCM
parameter_list|()
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Connecting to ContainerManager for containerid="
operator|+
name|container
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|cmIpPortStr
init|=
name|container
operator|.
name|getNodeId
argument_list|()
operator|.
name|getHost
argument_list|()
operator|+
literal|":"
operator|+
name|container
operator|.
name|getNodeId
argument_list|()
operator|.
name|getPort
argument_list|()
decl_stmt|;
name|InetSocketAddress
name|cmAddress
init|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|cmIpPortStr
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Connecting to ContainerManager at "
operator|+
name|cmIpPortStr
argument_list|)
expr_stmt|;
name|this
operator|.
name|cm
operator|=
operator|(
operator|(
name|ContainerManager
operator|)
name|rpc
operator|.
name|getProxy
argument_list|(
name|ContainerManager
operator|.
name|class
argument_list|,
name|cmAddress
argument_list|,
name|conf
argument_list|)
operator|)
expr_stmt|;
block|}
annotation|@
name|Override
comment|/**      * Connects to CM, sets up container launch context       * for shell command and eventually dispatches the container       * start request to the CM.       */
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// Connect to ContainerManager
name|connectToCM
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Setting up container launch container for containerid="
operator|+
name|container
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|ContainerLaunchContext
name|ctx
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|ContainerLaunchContext
operator|.
name|class
argument_list|)
decl_stmt|;
name|ctx
operator|.
name|setContainerId
argument_list|(
name|container
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setResource
argument_list|(
name|container
operator|.
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|jobUserName
init|=
name|System
operator|.
name|getenv
argument_list|(
name|ApplicationConstants
operator|.
name|Environment
operator|.
name|USER
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
name|ctx
operator|.
name|setUser
argument_list|(
name|jobUserName
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Setting user in ContainerLaunchContext to: "
operator|+
name|jobUserName
argument_list|)
expr_stmt|;
comment|// Set the environment
name|ctx
operator|.
name|setEnvironment
argument_list|(
name|shellEnv
argument_list|)
expr_stmt|;
comment|// Set the local resources
name|Map
argument_list|<
name|String
argument_list|,
name|LocalResource
argument_list|>
name|localResources
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|LocalResource
argument_list|>
argument_list|()
decl_stmt|;
comment|// The container for the eventual shell commands needs its own local
comment|// resources too.
comment|// In this scenario, if a shell script is specified, we need to have it
comment|// copied and made available to the container.
if|if
condition|(
operator|!
name|shellScriptPath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LocalResource
name|shellRsrc
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|LocalResource
operator|.
name|class
argument_list|)
decl_stmt|;
name|shellRsrc
operator|.
name|setType
argument_list|(
name|LocalResourceType
operator|.
name|FILE
argument_list|)
expr_stmt|;
name|shellRsrc
operator|.
name|setVisibility
argument_list|(
name|LocalResourceVisibility
operator|.
name|APPLICATION
argument_list|)
expr_stmt|;
try|try
block|{
name|shellRsrc
operator|.
name|setResource
argument_list|(
name|ConverterUtils
operator|.
name|getYarnUrlFromURI
argument_list|(
operator|new
name|URI
argument_list|(
name|shellScriptPath
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error when trying to use shell script path specified"
operator|+
literal|" in env, path="
operator|+
name|shellScriptPath
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
comment|// A failure scenario on bad input such as invalid shell script path
comment|// We know we cannot continue launching the container
comment|// so we should release it.
comment|// TODO
name|numCompletedContainers
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|numFailedContainers
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return;
block|}
name|shellRsrc
operator|.
name|setTimestamp
argument_list|(
name|shellScriptPathTimestamp
argument_list|)
expr_stmt|;
name|shellRsrc
operator|.
name|setSize
argument_list|(
name|shellScriptPathLen
argument_list|)
expr_stmt|;
name|localResources
operator|.
name|put
argument_list|(
name|ExecShellStringPath
argument_list|,
name|shellRsrc
argument_list|)
expr_stmt|;
block|}
name|ctx
operator|.
name|setLocalResources
argument_list|(
name|localResources
argument_list|)
expr_stmt|;
comment|// Set the necessary command to execute on the allocated container
name|Vector
argument_list|<
name|CharSequence
argument_list|>
name|vargs
init|=
operator|new
name|Vector
argument_list|<
name|CharSequence
argument_list|>
argument_list|(
literal|5
argument_list|)
decl_stmt|;
comment|// Set executable command
name|vargs
operator|.
name|add
argument_list|(
name|shellCommand
argument_list|)
expr_stmt|;
comment|// Set shell script path
if|if
condition|(
operator|!
name|shellScriptPath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|vargs
operator|.
name|add
argument_list|(
name|ExecShellStringPath
argument_list|)
expr_stmt|;
block|}
comment|// Set args for the shell command if any
name|vargs
operator|.
name|add
argument_list|(
name|shellArgs
argument_list|)
expr_stmt|;
comment|// Add log redirect params
name|vargs
operator|.
name|add
argument_list|(
literal|"1>"
operator|+
name|ApplicationConstants
operator|.
name|LOG_DIR_EXPANSION_VAR
operator|+
literal|"/stdout"
argument_list|)
expr_stmt|;
name|vargs
operator|.
name|add
argument_list|(
literal|"2>"
operator|+
name|ApplicationConstants
operator|.
name|LOG_DIR_EXPANSION_VAR
operator|+
literal|"/stderr"
argument_list|)
expr_stmt|;
comment|// Get final commmand
name|StringBuilder
name|command
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|CharSequence
name|str
range|:
name|vargs
control|)
block|{
name|command
operator|.
name|append
argument_list|(
name|str
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|commands
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|commands
operator|.
name|add
argument_list|(
name|command
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|ctx
operator|.
name|setCommands
argument_list|(
name|commands
argument_list|)
expr_stmt|;
name|StartContainerRequest
name|startReq
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|StartContainerRequest
operator|.
name|class
argument_list|)
decl_stmt|;
name|startReq
operator|.
name|setContainerLaunchContext
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
try|try
block|{
name|cm
operator|.
name|startContainer
argument_list|(
name|startReq
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|YarnRemoteException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Start container failed for :"
operator|+
literal|", containerId="
operator|+
name|container
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
comment|// TODO do we need to release this container?
block|}
comment|// Get container status?
comment|// Left commented out as the shell scripts are short lived
comment|// and we are relying on the status for completed containers
comment|// from RM to detect status
comment|// GetContainerStatusRequest statusReq =
comment|// Records.newRecord(GetContainerStatusRequest.class);
comment|// statusReq.setContainerId(container.getId());
comment|// GetContainerStatusResponse statusResp;
comment|// try {
comment|// statusResp = cm.getContainerStatus(statusReq);
comment|// LOG.info("Container Status"
comment|// + ", id=" + container.getId()
comment|// + ", status=" +statusResp.getStatus());
comment|// } catch (YarnRemoteException e) {
comment|// e.printStackTrace();
comment|// }
block|}
block|}
comment|/**    * Setup the request that will be sent to the RM for the container ask.    *    * @param numContainers Containers to ask for from RM    * @return the setup ResourceRequest to be sent to RM    */
DECL|method|setupContainerAskForRM (int numContainers)
specifier|private
name|ContainerRequest
name|setupContainerAskForRM
parameter_list|(
name|int
name|numContainers
parameter_list|)
block|{
comment|// setup requirements for hosts
comment|// using * as any host will do for the distributed shell app
comment|// set the priority for the request
name|Priority
name|pri
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|Priority
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// TODO - what is the range for priority? how to decide?
name|pri
operator|.
name|setPriority
argument_list|(
name|requestPriority
argument_list|)
expr_stmt|;
comment|// Set up resource type requirements
comment|// For now, only memory is supported so we set memory requirements
name|Resource
name|capability
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|Resource
operator|.
name|class
argument_list|)
decl_stmt|;
name|capability
operator|.
name|setMemory
argument_list|(
name|containerMemory
argument_list|)
expr_stmt|;
name|ContainerRequest
name|request
init|=
operator|new
name|ContainerRequest
argument_list|(
name|capability
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|pri
argument_list|,
name|numContainers
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Requested container ask: "
operator|+
name|request
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|request
return|;
block|}
comment|/**    * Ask RM to allocate given no. of containers to this Application Master    *    * @param requestedContainers Containers to ask for from RM    * @return Response from RM to AM with allocated containers    * @throws YarnRemoteException    */
DECL|method|sendContainerAskToRM ()
specifier|private
name|AllocateResponse
name|sendContainerAskToRM
parameter_list|()
throws|throws
name|YarnRemoteException
block|{
name|float
name|progressIndicator
init|=
operator|(
name|float
operator|)
name|numCompletedContainers
operator|.
name|get
argument_list|()
operator|/
name|numTotalContainers
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Sending request to RM for containers"
operator|+
literal|", progress="
operator|+
name|progressIndicator
argument_list|)
expr_stmt|;
return|return
name|resourceManager
operator|.
name|allocate
argument_list|(
name|progressIndicator
argument_list|)
return|;
block|}
block|}
end_class

end_unit

