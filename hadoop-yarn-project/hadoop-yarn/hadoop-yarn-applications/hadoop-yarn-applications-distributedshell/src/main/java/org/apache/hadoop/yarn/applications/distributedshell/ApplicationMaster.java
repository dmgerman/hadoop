begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.applications.distributedshell
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|applications
operator|.
name|distributedshell
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|UndeclaredThrowableException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|CommandLine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|GnuParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|HelpFormatter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|Private
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|DataOutputBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|Credentials
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ExitUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|ApplicationConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|ApplicationConstants
operator|.
name|Environment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|ApplicationMasterProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|ContainerManagementProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|AllocateRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|AllocateResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|FinishApplicationMasterRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|RegisterApplicationMasterResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|StartContainerRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationAttemptId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Container
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerExitStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerLaunchContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|FinalApplicationStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|LocalResource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|LocalResourceType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|LocalResourceVisibility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|NodeReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Priority
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ResourceRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|timeline
operator|.
name|TimelineEntity
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|timeline
operator|.
name|TimelineEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|timeline
operator|.
name|TimelinePutResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|api
operator|.
name|AMRMClient
operator|.
name|ContainerRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|api
operator|.
name|TimelineClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|api
operator|.
name|async
operator|.
name|AMRMClientAsync
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|api
operator|.
name|async
operator|.
name|NMClientAsync
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|api
operator|.
name|async
operator|.
name|impl
operator|.
name|NMClientAsyncImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|security
operator|.
name|AMRMTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|ConverterUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|LogManager
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * An ApplicationMaster for executing shell commands on a set of launched  * containers using the YARN framework.  *   *<p>  * This class is meant to act as an example on how to write yarn-based  * application masters.  *</p>  *   *<p>  * The ApplicationMaster is started on a container by the  *<code>ResourceManager</code>'s launcher. The first thing that the  *<code>ApplicationMaster</code> needs to do is to connect and register itself  * with the<code>ResourceManager</code>. The registration sets up information  * within the<code>ResourceManager</code> regarding what host:port the  * ApplicationMaster is listening on to provide any form of functionality to a  * client as well as a tracking url that a client can use to keep track of  * status/job history if needed. However, in the distributedshell, trackingurl  * and appMasterHost:appMasterRpcPort are not supported.  *</p>  *   *<p>  * The<code>ApplicationMaster</code> needs to send a heartbeat to the  *<code>ResourceManager</code> at regular intervals to inform the  *<code>ResourceManager</code> that it is up and alive. The  * {@link ApplicationMasterProtocol#allocate} to the<code>ResourceManager</code> from the  *<code>ApplicationMaster</code> acts as a heartbeat.  *   *<p>  * For the actual handling of the job, the<code>ApplicationMaster</code> has to  * request the<code>ResourceManager</code> via {@link AllocateRequest} for the  * required no. of containers using {@link ResourceRequest} with the necessary  * resource specifications such as node location, computational  * (memory/disk/cpu) resource requirements. The<code>ResourceManager</code>  * responds with an {@link AllocateResponse} that informs the  *<code>ApplicationMaster</code> of the set of newly allocated containers,  * completed containers as well as current state of available resources.  *</p>  *   *<p>  * For each allocated container, the<code>ApplicationMaster</code> can then set  * up the necessary launch context via {@link ContainerLaunchContext} to specify  * the allocated container id, local resources required by the executable, the  * environment to be setup for the executable, commands to execute, etc. and  * submit a {@link StartContainerRequest} to the {@link ContainerManagementProtocol} to  * launch and execute the defined commands on the given allocated container.  *</p>  *   *<p>  * The<code>ApplicationMaster</code> can monitor the launched container by  * either querying the<code>ResourceManager</code> using  * {@link ApplicationMasterProtocol#allocate} to get updates on completed containers or via  * the {@link ContainerManagementProtocol} by querying for the status of the allocated  * container's {@link ContainerId}.  *  *<p>  * After the job has been completed, the<code>ApplicationMaster</code> has to  * send a {@link FinishApplicationMasterRequest} to the  *<code>ResourceManager</code> to inform it that the  *<code>ApplicationMaster</code> has been completed.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|ApplicationMaster
specifier|public
class|class
name|ApplicationMaster
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ApplicationMaster
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|VisibleForTesting
annotation|@
name|Private
DECL|enum|DSEvent
specifier|public
specifier|static
enum|enum
name|DSEvent
block|{
DECL|enumConstant|DS_APP_ATTEMPT_START
DECL|enumConstant|DS_APP_ATTEMPT_END
DECL|enumConstant|DS_CONTAINER_START
DECL|enumConstant|DS_CONTAINER_END
name|DS_APP_ATTEMPT_START
block|,
name|DS_APP_ATTEMPT_END
block|,
name|DS_CONTAINER_START
block|,
name|DS_CONTAINER_END
block|}
annotation|@
name|VisibleForTesting
annotation|@
name|Private
DECL|enum|DSEntity
specifier|public
specifier|static
enum|enum
name|DSEntity
block|{
DECL|enumConstant|DS_APP_ATTEMPT
DECL|enumConstant|DS_CONTAINER
name|DS_APP_ATTEMPT
block|,
name|DS_CONTAINER
block|}
DECL|field|YARN_SHELL_ID
specifier|private
specifier|static
specifier|final
name|String
name|YARN_SHELL_ID
init|=
literal|"YARN_SHELL_ID"
decl_stmt|;
comment|// Configuration
DECL|field|conf
specifier|private
name|Configuration
name|conf
decl_stmt|;
comment|// Handle to communicate with the Resource Manager
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
DECL|field|amRMClient
specifier|private
name|AMRMClientAsync
name|amRMClient
decl_stmt|;
comment|// In both secure and non-secure modes, this points to the job-submitter.
annotation|@
name|VisibleForTesting
DECL|field|appSubmitterUgi
name|UserGroupInformation
name|appSubmitterUgi
decl_stmt|;
comment|// Handle to communicate with the Node Manager
DECL|field|nmClientAsync
specifier|private
name|NMClientAsync
name|nmClientAsync
decl_stmt|;
comment|// Listen to process the response from the Node Manager
DECL|field|containerListener
specifier|private
name|NMCallbackHandler
name|containerListener
decl_stmt|;
comment|// Application Attempt Id ( combination of attemptId and fail count )
annotation|@
name|VisibleForTesting
DECL|field|appAttemptID
specifier|protected
name|ApplicationAttemptId
name|appAttemptID
decl_stmt|;
comment|// TODO
comment|// For status update for clients - yet to be implemented
comment|// Hostname of the container
DECL|field|appMasterHostname
specifier|private
name|String
name|appMasterHostname
init|=
literal|""
decl_stmt|;
comment|// Port on which the app master listens for status updates from clients
DECL|field|appMasterRpcPort
specifier|private
name|int
name|appMasterRpcPort
init|=
operator|-
literal|1
decl_stmt|;
comment|// Tracking url to which app master publishes info for clients to monitor
DECL|field|appMasterTrackingUrl
specifier|private
name|String
name|appMasterTrackingUrl
init|=
literal|""
decl_stmt|;
comment|// App Master configuration
comment|// No. of containers to run shell command on
annotation|@
name|VisibleForTesting
DECL|field|numTotalContainers
specifier|protected
name|int
name|numTotalContainers
init|=
literal|1
decl_stmt|;
comment|// Memory to request for the container on which the shell command will run
DECL|field|containerMemory
specifier|private
name|int
name|containerMemory
init|=
literal|10
decl_stmt|;
comment|// VirtualCores to request for the container on which the shell command will run
DECL|field|containerVirtualCores
specifier|private
name|int
name|containerVirtualCores
init|=
literal|1
decl_stmt|;
comment|// Priority of the request
DECL|field|requestPriority
specifier|private
name|int
name|requestPriority
decl_stmt|;
comment|// Counter for completed containers ( complete denotes successful or failed )
DECL|field|numCompletedContainers
specifier|private
name|AtomicInteger
name|numCompletedContainers
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|// Allocated container count so that we know how many containers has the RM
comment|// allocated to us
annotation|@
name|VisibleForTesting
DECL|field|numAllocatedContainers
specifier|protected
name|AtomicInteger
name|numAllocatedContainers
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|// Count of failed containers
DECL|field|numFailedContainers
specifier|private
name|AtomicInteger
name|numFailedContainers
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|// Count of containers already requested from the RM
comment|// Needed as once requested, we should not request for containers again.
comment|// Only request for more if the original requirement changes.
annotation|@
name|VisibleForTesting
DECL|field|numRequestedContainers
specifier|protected
name|AtomicInteger
name|numRequestedContainers
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|// Shell command to be executed
DECL|field|shellCommand
specifier|private
name|String
name|shellCommand
init|=
literal|""
decl_stmt|;
comment|// Args to be passed to the shell command
DECL|field|shellArgs
specifier|private
name|String
name|shellArgs
init|=
literal|""
decl_stmt|;
comment|// Env variables to be setup for the shell command
DECL|field|shellEnv
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|shellEnv
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// Location of shell script ( obtained from info set in env )
comment|// Shell script path in fs
DECL|field|scriptPath
specifier|private
name|String
name|scriptPath
init|=
literal|""
decl_stmt|;
comment|// Timestamp needed for creating a local resource
DECL|field|shellScriptPathTimestamp
specifier|private
name|long
name|shellScriptPathTimestamp
init|=
literal|0
decl_stmt|;
comment|// File length needed for local resource
DECL|field|shellScriptPathLen
specifier|private
name|long
name|shellScriptPathLen
init|=
literal|0
decl_stmt|;
comment|// Timeline domain ID
DECL|field|domainId
specifier|private
name|String
name|domainId
init|=
literal|null
decl_stmt|;
comment|// Hardcoded path to shell script in launch container's local env
DECL|field|ExecShellStringPath
specifier|private
specifier|static
specifier|final
name|String
name|ExecShellStringPath
init|=
name|Client
operator|.
name|SCRIPT_PATH
operator|+
literal|".sh"
decl_stmt|;
DECL|field|ExecBatScripStringtPath
specifier|private
specifier|static
specifier|final
name|String
name|ExecBatScripStringtPath
init|=
name|Client
operator|.
name|SCRIPT_PATH
operator|+
literal|".bat"
decl_stmt|;
comment|// Hardcoded path to custom log_properties
DECL|field|log4jPath
specifier|private
specifier|static
specifier|final
name|String
name|log4jPath
init|=
literal|"log4j.properties"
decl_stmt|;
DECL|field|shellCommandPath
specifier|private
specifier|static
specifier|final
name|String
name|shellCommandPath
init|=
literal|"shellCommands"
decl_stmt|;
DECL|field|shellArgsPath
specifier|private
specifier|static
specifier|final
name|String
name|shellArgsPath
init|=
literal|"shellArgs"
decl_stmt|;
DECL|field|done
specifier|private
specifier|volatile
name|boolean
name|done
decl_stmt|;
DECL|field|allTokens
specifier|private
name|ByteBuffer
name|allTokens
decl_stmt|;
comment|// Launch threads
DECL|field|launchThreads
specifier|private
name|List
argument_list|<
name|Thread
argument_list|>
name|launchThreads
init|=
operator|new
name|ArrayList
argument_list|<
name|Thread
argument_list|>
argument_list|()
decl_stmt|;
comment|// Timeline Client
annotation|@
name|VisibleForTesting
DECL|field|timelineClient
name|TimelineClient
name|timelineClient
decl_stmt|;
DECL|field|linux_bash_command
specifier|private
specifier|final
name|String
name|linux_bash_command
init|=
literal|"bash"
decl_stmt|;
DECL|field|windows_command
specifier|private
specifier|final
name|String
name|windows_command
init|=
literal|"cmd /c"
decl_stmt|;
DECL|field|yarnShellIdCounter
specifier|private
name|int
name|yarnShellIdCounter
init|=
literal|1
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|launchedContainers
specifier|protected
specifier|final
name|Set
argument_list|<
name|ContainerId
argument_list|>
name|launchedContainers
init|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|ConcurrentHashMap
argument_list|<
name|ContainerId
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * @param args Command line args    */
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|boolean
name|result
init|=
literal|false
decl_stmt|;
try|try
block|{
name|ApplicationMaster
name|appMaster
init|=
operator|new
name|ApplicationMaster
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Initializing ApplicationMaster"
argument_list|)
expr_stmt|;
name|boolean
name|doRun
init|=
name|appMaster
operator|.
name|init
argument_list|(
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|doRun
condition|)
block|{
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|appMaster
operator|.
name|run
argument_list|()
expr_stmt|;
name|result
operator|=
name|appMaster
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Error running ApplicationMaster"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|LogManager
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|ExitUtil
operator|.
name|terminate
argument_list|(
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Application Master completed successfully. exiting"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Application Master failed. exiting"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Dump out contents of $CWD and the environment to stdout for debugging    */
DECL|method|dumpOutDebugInfo ()
specifier|private
name|void
name|dumpOutDebugInfo
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Dump debug output"
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|envs
init|=
name|System
operator|.
name|getenv
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
range|:
name|envs
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"System env: key="
operator|+
name|env
operator|.
name|getKey
argument_list|()
operator|+
literal|", val="
operator|+
name|env
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"System env: key="
operator|+
name|env
operator|.
name|getKey
argument_list|()
operator|+
literal|", val="
operator|+
name|env
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|BufferedReader
name|buf
init|=
literal|null
decl_stmt|;
try|try
block|{
name|String
name|lines
init|=
name|Shell
operator|.
name|WINDOWS
condition|?
name|Shell
operator|.
name|execCommand
argument_list|(
literal|"cmd"
argument_list|,
literal|"/c"
argument_list|,
literal|"dir"
argument_list|)
else|:
name|Shell
operator|.
name|execCommand
argument_list|(
literal|"ls"
argument_list|,
literal|"-al"
argument_list|)
decl_stmt|;
name|buf
operator|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|StringReader
argument_list|(
name|lines
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|line
init|=
literal|""
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|buf
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"System CWD content: "
operator|+
name|line
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"System CWD content: "
operator|+
name|line
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|ApplicationMaster ()
specifier|public
name|ApplicationMaster
parameter_list|()
block|{
comment|// Set up the configuration
name|conf
operator|=
operator|new
name|YarnConfiguration
argument_list|()
expr_stmt|;
block|}
comment|/**    * Parse command line options    *    * @param args Command line args    * @return Whether init successful and run should be invoked    * @throws ParseException    * @throws IOException    */
DECL|method|init (String[] args)
specifier|public
name|boolean
name|init
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|ParseException
throws|,
name|IOException
block|{
name|Options
name|opts
init|=
operator|new
name|Options
argument_list|()
decl_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"app_attempt_id"
argument_list|,
literal|true
argument_list|,
literal|"App Attempt ID. Not to be used unless for testing purposes"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"shell_env"
argument_list|,
literal|true
argument_list|,
literal|"Environment for shell script. Specified as env_key=env_val pairs"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"container_memory"
argument_list|,
literal|true
argument_list|,
literal|"Amount of memory in MB to be requested to run the shell command"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"container_vcores"
argument_list|,
literal|true
argument_list|,
literal|"Amount of virtual cores to be requested to run the shell command"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"num_containers"
argument_list|,
literal|true
argument_list|,
literal|"No. of containers on which the shell command needs to be executed"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"priority"
argument_list|,
literal|true
argument_list|,
literal|"Application Priority. Default 0"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"debug"
argument_list|,
literal|false
argument_list|,
literal|"Dump out debug information"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"help"
argument_list|,
literal|false
argument_list|,
literal|"Print usage"
argument_list|)
expr_stmt|;
name|CommandLine
name|cliParser
init|=
operator|new
name|GnuParser
argument_list|()
operator|.
name|parse
argument_list|(
name|opts
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|printUsage
argument_list|(
name|opts
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No args specified for application master to initialize"
argument_list|)
throw|;
block|}
comment|//Check whether customer log4j.properties file exists
if|if
condition|(
name|fileExist
argument_list|(
name|log4jPath
argument_list|)
condition|)
block|{
try|try
block|{
name|Log4jPropertyHelper
operator|.
name|updateLog4jConfiguration
argument_list|(
name|ApplicationMaster
operator|.
name|class
argument_list|,
name|log4jPath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Can not set up custom log4j properties. "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cliParser
operator|.
name|hasOption
argument_list|(
literal|"help"
argument_list|)
condition|)
block|{
name|printUsage
argument_list|(
name|opts
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|cliParser
operator|.
name|hasOption
argument_list|(
literal|"debug"
argument_list|)
condition|)
block|{
name|dumpOutDebugInfo
argument_list|()
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|envs
init|=
name|System
operator|.
name|getenv
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|envs
operator|.
name|containsKey
argument_list|(
name|Environment
operator|.
name|CONTAINER_ID
operator|.
name|name
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|cliParser
operator|.
name|hasOption
argument_list|(
literal|"app_attempt_id"
argument_list|)
condition|)
block|{
name|String
name|appIdStr
init|=
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"app_attempt_id"
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|appAttemptID
operator|=
name|ConverterUtils
operator|.
name|toApplicationAttemptId
argument_list|(
name|appIdStr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Application Attempt Id not set in the environment"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|ContainerId
name|containerId
init|=
name|ConverterUtils
operator|.
name|toContainerId
argument_list|(
name|envs
operator|.
name|get
argument_list|(
name|Environment
operator|.
name|CONTAINER_ID
operator|.
name|name
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|appAttemptID
operator|=
name|containerId
operator|.
name|getApplicationAttemptId
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|envs
operator|.
name|containsKey
argument_list|(
name|ApplicationConstants
operator|.
name|APP_SUBMIT_TIME_ENV
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ApplicationConstants
operator|.
name|APP_SUBMIT_TIME_ENV
operator|+
literal|" not set in the environment"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|envs
operator|.
name|containsKey
argument_list|(
name|Environment
operator|.
name|NM_HOST
operator|.
name|name
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|Environment
operator|.
name|NM_HOST
operator|.
name|name
argument_list|()
operator|+
literal|" not set in the environment"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|envs
operator|.
name|containsKey
argument_list|(
name|Environment
operator|.
name|NM_HTTP_PORT
operator|.
name|name
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|Environment
operator|.
name|NM_HTTP_PORT
operator|+
literal|" not set in the environment"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|envs
operator|.
name|containsKey
argument_list|(
name|Environment
operator|.
name|NM_PORT
operator|.
name|name
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|Environment
operator|.
name|NM_PORT
operator|.
name|name
argument_list|()
operator|+
literal|" not set in the environment"
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Application master for app"
operator|+
literal|", appId="
operator|+
name|appAttemptID
operator|.
name|getApplicationId
argument_list|()
operator|.
name|getId
argument_list|()
operator|+
literal|", clustertimestamp="
operator|+
name|appAttemptID
operator|.
name|getApplicationId
argument_list|()
operator|.
name|getClusterTimestamp
argument_list|()
operator|+
literal|", attemptId="
operator|+
name|appAttemptID
operator|.
name|getAttemptId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fileExist
argument_list|(
name|shellCommandPath
argument_list|)
operator|&&
name|envs
operator|.
name|get
argument_list|(
name|DSConstants
operator|.
name|DISTRIBUTEDSHELLSCRIPTLOCATION
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No shell command or shell script specified to be executed by application master"
argument_list|)
throw|;
block|}
if|if
condition|(
name|fileExist
argument_list|(
name|shellCommandPath
argument_list|)
condition|)
block|{
name|shellCommand
operator|=
name|readContent
argument_list|(
name|shellCommandPath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fileExist
argument_list|(
name|shellArgsPath
argument_list|)
condition|)
block|{
name|shellArgs
operator|=
name|readContent
argument_list|(
name|shellArgsPath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cliParser
operator|.
name|hasOption
argument_list|(
literal|"shell_env"
argument_list|)
condition|)
block|{
name|String
name|shellEnvs
index|[]
init|=
name|cliParser
operator|.
name|getOptionValues
argument_list|(
literal|"shell_env"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|env
range|:
name|shellEnvs
control|)
block|{
name|env
operator|=
name|env
operator|.
name|trim
argument_list|()
expr_stmt|;
name|int
name|index
init|=
name|env
operator|.
name|indexOf
argument_list|(
literal|'='
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|shellEnv
operator|.
name|put
argument_list|(
name|env
argument_list|,
literal|""
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|String
name|key
init|=
name|env
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|String
name|val
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|index
operator|<
operator|(
name|env
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
name|val
operator|=
name|env
operator|.
name|substring
argument_list|(
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|shellEnv
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|envs
operator|.
name|containsKey
argument_list|(
name|DSConstants
operator|.
name|DISTRIBUTEDSHELLSCRIPTLOCATION
argument_list|)
condition|)
block|{
name|scriptPath
operator|=
name|envs
operator|.
name|get
argument_list|(
name|DSConstants
operator|.
name|DISTRIBUTEDSHELLSCRIPTLOCATION
argument_list|)
expr_stmt|;
if|if
condition|(
name|envs
operator|.
name|containsKey
argument_list|(
name|DSConstants
operator|.
name|DISTRIBUTEDSHELLSCRIPTTIMESTAMP
argument_list|)
condition|)
block|{
name|shellScriptPathTimestamp
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|envs
operator|.
name|get
argument_list|(
name|DSConstants
operator|.
name|DISTRIBUTEDSHELLSCRIPTTIMESTAMP
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|envs
operator|.
name|containsKey
argument_list|(
name|DSConstants
operator|.
name|DISTRIBUTEDSHELLSCRIPTLEN
argument_list|)
condition|)
block|{
name|shellScriptPathLen
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|envs
operator|.
name|get
argument_list|(
name|DSConstants
operator|.
name|DISTRIBUTEDSHELLSCRIPTLEN
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|scriptPath
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|(
name|shellScriptPathTimestamp
operator|<=
literal|0
operator|||
name|shellScriptPathLen
operator|<=
literal|0
operator|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Illegal values in env for shell script path"
operator|+
literal|", path="
operator|+
name|scriptPath
operator|+
literal|", len="
operator|+
name|shellScriptPathLen
operator|+
literal|", timestamp="
operator|+
name|shellScriptPathTimestamp
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal values in env for shell script path"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|envs
operator|.
name|containsKey
argument_list|(
name|DSConstants
operator|.
name|DISTRIBUTEDSHELLTIMELINEDOMAIN
argument_list|)
condition|)
block|{
name|domainId
operator|=
name|envs
operator|.
name|get
argument_list|(
name|DSConstants
operator|.
name|DISTRIBUTEDSHELLTIMELINEDOMAIN
argument_list|)
expr_stmt|;
block|}
name|containerMemory
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"container_memory"
argument_list|,
literal|"10"
argument_list|)
argument_list|)
expr_stmt|;
name|containerVirtualCores
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"container_vcores"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|numTotalContainers
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"num_containers"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|numTotalContainers
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot run distributed shell with no containers"
argument_list|)
throw|;
block|}
name|requestPriority
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"priority"
argument_list|,
literal|"0"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Helper function to print usage    *    * @param opts Parsed command line options    */
DECL|method|printUsage (Options opts)
specifier|private
name|void
name|printUsage
parameter_list|(
name|Options
name|opts
parameter_list|)
block|{
operator|new
name|HelpFormatter
argument_list|()
operator|.
name|printHelp
argument_list|(
literal|"ApplicationMaster"
argument_list|,
name|opts
argument_list|)
expr_stmt|;
block|}
comment|/**    * Main run function for the application master    *    * @throws YarnException    * @throws IOException    */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unchecked"
block|}
argument_list|)
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
throws|throws
name|YarnException
throws|,
name|IOException
throws|,
name|InterruptedException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting ApplicationMaster"
argument_list|)
expr_stmt|;
comment|// Note: Credentials, Token, UserGroupInformation, DataOutputBuffer class
comment|// are marked as LimitedPrivate
name|Credentials
name|credentials
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getCredentials
argument_list|()
decl_stmt|;
name|DataOutputBuffer
name|dob
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
name|credentials
operator|.
name|writeTokenStorageToStream
argument_list|(
name|dob
argument_list|)
expr_stmt|;
comment|// Now remove the AM->RM token so that containers cannot access it.
name|Iterator
argument_list|<
name|Token
argument_list|<
name|?
argument_list|>
argument_list|>
name|iter
init|=
name|credentials
operator|.
name|getAllTokens
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Executing with tokens:"
argument_list|)
expr_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Token
argument_list|<
name|?
argument_list|>
name|token
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|.
name|getKind
argument_list|()
operator|.
name|equals
argument_list|(
name|AMRMTokenIdentifier
operator|.
name|KIND_NAME
argument_list|)
condition|)
block|{
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
name|allTokens
operator|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|dob
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|dob
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
comment|// Create appSubmitterUgi and add original tokens to it
name|String
name|appSubmitterUserName
init|=
name|System
operator|.
name|getenv
argument_list|(
name|ApplicationConstants
operator|.
name|Environment
operator|.
name|USER
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
name|appSubmitterUgi
operator|=
name|UserGroupInformation
operator|.
name|createRemoteUser
argument_list|(
name|appSubmitterUserName
argument_list|)
expr_stmt|;
name|appSubmitterUgi
operator|.
name|addCredentials
argument_list|(
name|credentials
argument_list|)
expr_stmt|;
name|AMRMClientAsync
operator|.
name|AbstractCallbackHandler
name|allocListener
init|=
operator|new
name|RMCallbackHandler
argument_list|()
decl_stmt|;
name|amRMClient
operator|=
name|AMRMClientAsync
operator|.
name|createAMRMClientAsync
argument_list|(
literal|1000
argument_list|,
name|allocListener
argument_list|)
expr_stmt|;
name|amRMClient
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|amRMClient
operator|.
name|start
argument_list|()
expr_stmt|;
name|containerListener
operator|=
name|createNMCallbackHandler
argument_list|()
expr_stmt|;
name|nmClientAsync
operator|=
operator|new
name|NMClientAsyncImpl
argument_list|(
name|containerListener
argument_list|)
expr_stmt|;
name|nmClientAsync
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|nmClientAsync
operator|.
name|start
argument_list|()
expr_stmt|;
name|startTimelineClient
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|timelineClient
operator|!=
literal|null
condition|)
block|{
name|publishApplicationAttemptEvent
argument_list|(
name|timelineClient
argument_list|,
name|appAttemptID
operator|.
name|toString
argument_list|()
argument_list|,
name|DSEvent
operator|.
name|DS_APP_ATTEMPT_START
argument_list|,
name|domainId
argument_list|,
name|appSubmitterUgi
argument_list|)
expr_stmt|;
block|}
comment|// Setup local RPC Server to accept status requests directly from clients
comment|// TODO need to setup a protocol for client to be able to communicate to
comment|// the RPC server
comment|// TODO use the rpc port info to register with the RM for the client to
comment|// send requests to this app master
comment|// Register self with ResourceManager
comment|// This will start heartbeating to the RM
name|appMasterHostname
operator|=
name|NetUtils
operator|.
name|getHostname
argument_list|()
expr_stmt|;
name|RegisterApplicationMasterResponse
name|response
init|=
name|amRMClient
operator|.
name|registerApplicationMaster
argument_list|(
name|appMasterHostname
argument_list|,
name|appMasterRpcPort
argument_list|,
name|appMasterTrackingUrl
argument_list|)
decl_stmt|;
comment|// Dump out information about cluster capability as seen by the
comment|// resource manager
name|int
name|maxMem
init|=
name|response
operator|.
name|getMaximumResourceCapability
argument_list|()
operator|.
name|getMemory
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Max mem capability of resources in this cluster "
operator|+
name|maxMem
argument_list|)
expr_stmt|;
name|int
name|maxVCores
init|=
name|response
operator|.
name|getMaximumResourceCapability
argument_list|()
operator|.
name|getVirtualCores
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Max vcores capability of resources in this cluster "
operator|+
name|maxVCores
argument_list|)
expr_stmt|;
comment|// A resource ask cannot exceed the max.
if|if
condition|(
name|containerMemory
operator|>
name|maxMem
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Container memory specified above max threshold of cluster."
operator|+
literal|" Using max value."
operator|+
literal|", specified="
operator|+
name|containerMemory
operator|+
literal|", max="
operator|+
name|maxMem
argument_list|)
expr_stmt|;
name|containerMemory
operator|=
name|maxMem
expr_stmt|;
block|}
if|if
condition|(
name|containerVirtualCores
operator|>
name|maxVCores
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Container virtual cores specified above max threshold of cluster."
operator|+
literal|" Using max value."
operator|+
literal|", specified="
operator|+
name|containerVirtualCores
operator|+
literal|", max="
operator|+
name|maxVCores
argument_list|)
expr_stmt|;
name|containerVirtualCores
operator|=
name|maxVCores
expr_stmt|;
block|}
name|List
argument_list|<
name|Container
argument_list|>
name|previousAMRunningContainers
init|=
name|response
operator|.
name|getContainersFromPreviousAttempts
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|appAttemptID
operator|+
literal|" received "
operator|+
name|previousAMRunningContainers
operator|.
name|size
argument_list|()
operator|+
literal|" previous attempts' running containers on AM registration."
argument_list|)
expr_stmt|;
for|for
control|(
name|Container
name|container
range|:
name|previousAMRunningContainers
control|)
block|{
name|launchedContainers
operator|.
name|add
argument_list|(
name|container
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|numAllocatedContainers
operator|.
name|addAndGet
argument_list|(
name|previousAMRunningContainers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|numTotalContainersToRequest
init|=
name|numTotalContainers
operator|-
name|previousAMRunningContainers
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// Setup ask for containers from RM
comment|// Send request for containers to RM
comment|// Until we get our fully allocated quota, we keep on polling RM for
comment|// containers
comment|// Keep looping until all the containers are launched and shell script
comment|// executed on them ( regardless of success/failure).
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTotalContainersToRequest
condition|;
operator|++
name|i
control|)
block|{
name|ContainerRequest
name|containerAsk
init|=
name|setupContainerAskForRM
argument_list|()
decl_stmt|;
name|amRMClient
operator|.
name|addContainerRequest
argument_list|(
name|containerAsk
argument_list|)
expr_stmt|;
block|}
name|numRequestedContainers
operator|.
name|set
argument_list|(
name|numTotalContainers
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|startTimelineClient (final Configuration conf)
name|void
name|startTimelineClient
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
throws|,
name|InterruptedException
block|{
try|try
block|{
name|appSubmitterUgi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|run
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_ENABLED
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_TIMELINE_SERVICE_ENABLED
argument_list|)
condition|)
block|{
comment|// Creating the Timeline Client
name|timelineClient
operator|=
name|TimelineClient
operator|.
name|createTimelineClient
argument_list|()
expr_stmt|;
name|timelineClient
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|timelineClient
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|timelineClient
operator|=
literal|null
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Timeline service is not enabled"
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UndeclaredThrowableException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YarnException
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|createNMCallbackHandler ()
name|NMCallbackHandler
name|createNMCallbackHandler
parameter_list|()
block|{
return|return
operator|new
name|NMCallbackHandler
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|finish ()
specifier|protected
name|boolean
name|finish
parameter_list|()
block|{
comment|// wait for completion.
while|while
condition|(
operator|!
name|done
operator|&&
operator|(
name|numCompletedContainers
operator|.
name|get
argument_list|()
operator|!=
name|numTotalContainers
operator|)
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{}
block|}
if|if
condition|(
name|timelineClient
operator|!=
literal|null
condition|)
block|{
name|publishApplicationAttemptEvent
argument_list|(
name|timelineClient
argument_list|,
name|appAttemptID
operator|.
name|toString
argument_list|()
argument_list|,
name|DSEvent
operator|.
name|DS_APP_ATTEMPT_END
argument_list|,
name|domainId
argument_list|,
name|appSubmitterUgi
argument_list|)
expr_stmt|;
block|}
comment|// Join all launched threads
comment|// needed for when we time out
comment|// and we need to release containers
for|for
control|(
name|Thread
name|launchThread
range|:
name|launchThreads
control|)
block|{
try|try
block|{
name|launchThread
operator|.
name|join
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Exception thrown in thread join: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|// When the application completes, it should stop all running containers
name|LOG
operator|.
name|info
argument_list|(
literal|"Application completed. Stopping running containers"
argument_list|)
expr_stmt|;
name|nmClientAsync
operator|.
name|stop
argument_list|()
expr_stmt|;
comment|// When the application completes, it should send a finish application
comment|// signal to the RM
name|LOG
operator|.
name|info
argument_list|(
literal|"Application completed. Signalling finish to RM"
argument_list|)
expr_stmt|;
name|FinalApplicationStatus
name|appStatus
decl_stmt|;
name|String
name|appMessage
init|=
literal|null
decl_stmt|;
name|boolean
name|success
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|numFailedContainers
operator|.
name|get
argument_list|()
operator|==
literal|0
operator|&&
name|numCompletedContainers
operator|.
name|get
argument_list|()
operator|==
name|numTotalContainers
condition|)
block|{
name|appStatus
operator|=
name|FinalApplicationStatus
operator|.
name|SUCCEEDED
expr_stmt|;
block|}
else|else
block|{
name|appStatus
operator|=
name|FinalApplicationStatus
operator|.
name|FAILED
expr_stmt|;
name|appMessage
operator|=
literal|"Diagnostics."
operator|+
literal|", total="
operator|+
name|numTotalContainers
operator|+
literal|", completed="
operator|+
name|numCompletedContainers
operator|.
name|get
argument_list|()
operator|+
literal|", allocated="
operator|+
name|numAllocatedContainers
operator|.
name|get
argument_list|()
operator|+
literal|", failed="
operator|+
name|numFailedContainers
operator|.
name|get
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|appMessage
argument_list|)
expr_stmt|;
name|success
operator|=
literal|false
expr_stmt|;
block|}
try|try
block|{
name|amRMClient
operator|.
name|unregisterApplicationMaster
argument_list|(
name|appStatus
argument_list|,
name|appMessage
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|YarnException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to unregister application"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to unregister application"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|amRMClient
operator|.
name|stop
argument_list|()
expr_stmt|;
comment|// Stop Timeline Client
if|if
condition|(
name|timelineClient
operator|!=
literal|null
condition|)
block|{
name|timelineClient
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|class|RMCallbackHandler
class|class
name|RMCallbackHandler
extends|extends
name|AMRMClientAsync
operator|.
name|AbstractCallbackHandler
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|onContainersCompleted (List<ContainerStatus> completedContainers)
specifier|public
name|void
name|onContainersCompleted
parameter_list|(
name|List
argument_list|<
name|ContainerStatus
argument_list|>
name|completedContainers
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Got response from RM for container ask, completedCnt="
operator|+
name|completedContainers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|ContainerStatus
name|containerStatus
range|:
name|completedContainers
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|appAttemptID
operator|+
literal|" got container status for containerID="
operator|+
name|containerStatus
operator|.
name|getContainerId
argument_list|()
operator|+
literal|", state="
operator|+
name|containerStatus
operator|.
name|getState
argument_list|()
operator|+
literal|", exitStatus="
operator|+
name|containerStatus
operator|.
name|getExitStatus
argument_list|()
operator|+
literal|", diagnostics="
operator|+
name|containerStatus
operator|.
name|getDiagnostics
argument_list|()
argument_list|)
expr_stmt|;
comment|// non complete containers should not be here
assert|assert
operator|(
name|containerStatus
operator|.
name|getState
argument_list|()
operator|==
name|ContainerState
operator|.
name|COMPLETE
operator|)
assert|;
comment|// ignore containers we know nothing about - probably from a previous
comment|// attempt
if|if
condition|(
operator|!
name|launchedContainers
operator|.
name|contains
argument_list|(
name|containerStatus
operator|.
name|getContainerId
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignoring completed status of "
operator|+
name|containerStatus
operator|.
name|getContainerId
argument_list|()
operator|+
literal|"; unknown container(probably launched by previous attempt)"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// increment counters for completed/failed containers
name|int
name|exitStatus
init|=
name|containerStatus
operator|.
name|getExitStatus
argument_list|()
decl_stmt|;
if|if
condition|(
literal|0
operator|!=
name|exitStatus
condition|)
block|{
comment|// container failed
if|if
condition|(
name|ContainerExitStatus
operator|.
name|ABORTED
operator|!=
name|exitStatus
condition|)
block|{
comment|// shell script failed
comment|// counts as completed
name|numCompletedContainers
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|numFailedContainers
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// container was killed by framework, possibly preempted
comment|// we should re-try as the container was lost for some reason
name|numAllocatedContainers
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
name|numRequestedContainers
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
comment|// we do not need to release the container as it would be done
comment|// by the RM
block|}
block|}
else|else
block|{
comment|// nothing to do
comment|// container completed successfully
name|numCompletedContainers
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Container completed successfully."
operator|+
literal|", containerId="
operator|+
name|containerStatus
operator|.
name|getContainerId
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timelineClient
operator|!=
literal|null
condition|)
block|{
name|publishContainerEndEvent
argument_list|(
name|timelineClient
argument_list|,
name|containerStatus
argument_list|,
name|domainId
argument_list|,
name|appSubmitterUgi
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ask for more containers if any failed
name|int
name|askCount
init|=
name|numTotalContainers
operator|-
name|numRequestedContainers
operator|.
name|get
argument_list|()
decl_stmt|;
name|numRequestedContainers
operator|.
name|addAndGet
argument_list|(
name|askCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|askCount
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|askCount
condition|;
operator|++
name|i
control|)
block|{
name|ContainerRequest
name|containerAsk
init|=
name|setupContainerAskForRM
argument_list|()
decl_stmt|;
name|amRMClient
operator|.
name|addContainerRequest
argument_list|(
name|containerAsk
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|numCompletedContainers
operator|.
name|get
argument_list|()
operator|==
name|numTotalContainers
condition|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|onContainersAllocated (List<Container> allocatedContainers)
specifier|public
name|void
name|onContainersAllocated
parameter_list|(
name|List
argument_list|<
name|Container
argument_list|>
name|allocatedContainers
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Got response from RM for container ask, allocatedCnt="
operator|+
name|allocatedContainers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|numAllocatedContainers
operator|.
name|addAndGet
argument_list|(
name|allocatedContainers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Container
name|allocatedContainer
range|:
name|allocatedContainers
control|)
block|{
name|String
name|yarnShellId
init|=
name|Integer
operator|.
name|toString
argument_list|(
name|yarnShellIdCounter
argument_list|)
decl_stmt|;
name|yarnShellIdCounter
operator|++
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Launching shell command on a new container."
operator|+
literal|", containerId="
operator|+
name|allocatedContainer
operator|.
name|getId
argument_list|()
operator|+
literal|", yarnShellId="
operator|+
name|yarnShellId
operator|+
literal|", containerNode="
operator|+
name|allocatedContainer
operator|.
name|getNodeId
argument_list|()
operator|.
name|getHost
argument_list|()
operator|+
literal|":"
operator|+
name|allocatedContainer
operator|.
name|getNodeId
argument_list|()
operator|.
name|getPort
argument_list|()
operator|+
literal|", containerNodeURI="
operator|+
name|allocatedContainer
operator|.
name|getNodeHttpAddress
argument_list|()
operator|+
literal|", containerResourceMemory"
operator|+
name|allocatedContainer
operator|.
name|getResource
argument_list|()
operator|.
name|getMemory
argument_list|()
operator|+
literal|", containerResourceVirtualCores"
operator|+
name|allocatedContainer
operator|.
name|getResource
argument_list|()
operator|.
name|getVirtualCores
argument_list|()
argument_list|)
expr_stmt|;
comment|// + ", containerToken"
comment|// +allocatedContainer.getContainerToken().getIdentifier().toString());
name|Thread
name|launchThread
init|=
name|createLaunchContainerThread
argument_list|(
name|allocatedContainer
argument_list|,
name|yarnShellId
argument_list|)
decl_stmt|;
comment|// launch and start the container on a separate thread to keep
comment|// the main thread unblocked
comment|// as all containers may not be allocated at one go.
name|launchThreads
operator|.
name|add
argument_list|(
name|launchThread
argument_list|)
expr_stmt|;
name|launchedContainers
operator|.
name|add
argument_list|(
name|allocatedContainer
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|launchThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|onContainersResourceChanged (List<Container> containers)
specifier|public
name|void
name|onContainersResourceChanged
parameter_list|(
name|List
argument_list|<
name|Container
argument_list|>
name|containers
parameter_list|)
block|{}
annotation|@
name|Override
DECL|method|onShutdownRequest ()
specifier|public
name|void
name|onShutdownRequest
parameter_list|()
block|{
name|done
operator|=
literal|true
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onNodesUpdated (List<NodeReport> updatedNodes)
specifier|public
name|void
name|onNodesUpdated
parameter_list|(
name|List
argument_list|<
name|NodeReport
argument_list|>
name|updatedNodes
parameter_list|)
block|{}
annotation|@
name|Override
DECL|method|getProgress ()
specifier|public
name|float
name|getProgress
parameter_list|()
block|{
comment|// set progress to deliver to RM on next heartbeat
name|float
name|progress
init|=
operator|(
name|float
operator|)
name|numCompletedContainers
operator|.
name|get
argument_list|()
operator|/
name|numTotalContainers
decl_stmt|;
return|return
name|progress
return|;
block|}
annotation|@
name|Override
DECL|method|onError (Throwable e)
specifier|public
name|void
name|onError
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
name|amRMClient
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|class|NMCallbackHandler
specifier|static
class|class
name|NMCallbackHandler
extends|extends
name|NMClientAsync
operator|.
name|AbstractCallbackHandler
block|{
DECL|field|containers
specifier|private
name|ConcurrentMap
argument_list|<
name|ContainerId
argument_list|,
name|Container
argument_list|>
name|containers
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|ContainerId
argument_list|,
name|Container
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|applicationMaster
specifier|private
specifier|final
name|ApplicationMaster
name|applicationMaster
decl_stmt|;
DECL|method|NMCallbackHandler (ApplicationMaster applicationMaster)
specifier|public
name|NMCallbackHandler
parameter_list|(
name|ApplicationMaster
name|applicationMaster
parameter_list|)
block|{
name|this
operator|.
name|applicationMaster
operator|=
name|applicationMaster
expr_stmt|;
block|}
DECL|method|addContainer (ContainerId containerId, Container container)
specifier|public
name|void
name|addContainer
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|Container
name|container
parameter_list|)
block|{
name|containers
operator|.
name|putIfAbsent
argument_list|(
name|containerId
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onContainerStopped (ContainerId containerId)
specifier|public
name|void
name|onContainerStopped
parameter_list|(
name|ContainerId
name|containerId
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Succeeded to stop Container "
operator|+
name|containerId
argument_list|)
expr_stmt|;
block|}
name|containers
operator|.
name|remove
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onContainerStatusReceived (ContainerId containerId, ContainerStatus containerStatus)
specifier|public
name|void
name|onContainerStatusReceived
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|ContainerStatus
name|containerStatus
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Container Status: id="
operator|+
name|containerId
operator|+
literal|", status="
operator|+
name|containerStatus
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|onContainerStarted (ContainerId containerId, Map<String, ByteBuffer> allServiceResponse)
specifier|public
name|void
name|onContainerStarted
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ByteBuffer
argument_list|>
name|allServiceResponse
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Succeeded to start Container "
operator|+
name|containerId
argument_list|)
expr_stmt|;
block|}
name|Container
name|container
init|=
name|containers
operator|.
name|get
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|container
operator|!=
literal|null
condition|)
block|{
name|applicationMaster
operator|.
name|nmClientAsync
operator|.
name|getContainerStatusAsync
argument_list|(
name|containerId
argument_list|,
name|container
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|applicationMaster
operator|.
name|timelineClient
operator|!=
literal|null
condition|)
block|{
name|ApplicationMaster
operator|.
name|publishContainerStartEvent
argument_list|(
name|applicationMaster
operator|.
name|timelineClient
argument_list|,
name|container
argument_list|,
name|applicationMaster
operator|.
name|domainId
argument_list|,
name|applicationMaster
operator|.
name|appSubmitterUgi
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|onContainerResourceIncreased ( ContainerId containerId, Resource resource)
specifier|public
name|void
name|onContainerResourceIncreased
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|Resource
name|resource
parameter_list|)
block|{}
annotation|@
name|Override
DECL|method|onStartContainerError (ContainerId containerId, Throwable t)
specifier|public
name|void
name|onStartContainerError
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to start Container "
operator|+
name|containerId
argument_list|)
expr_stmt|;
name|containers
operator|.
name|remove
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
name|applicationMaster
operator|.
name|numCompletedContainers
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|applicationMaster
operator|.
name|numFailedContainers
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onGetContainerStatusError ( ContainerId containerId, Throwable t)
specifier|public
name|void
name|onGetContainerStatusError
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to query the status of Container "
operator|+
name|containerId
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onStopContainerError (ContainerId containerId, Throwable t)
specifier|public
name|void
name|onStopContainerError
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to stop Container "
operator|+
name|containerId
argument_list|)
expr_stmt|;
name|containers
operator|.
name|remove
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onIncreaseContainerResourceError ( ContainerId containerId, Throwable t)
specifier|public
name|void
name|onIncreaseContainerResourceError
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{}
block|}
comment|/**    * Thread to connect to the {@link ContainerManagementProtocol} and launch the container    * that will execute the shell command.    */
DECL|class|LaunchContainerRunnable
specifier|private
class|class
name|LaunchContainerRunnable
implements|implements
name|Runnable
block|{
comment|// Allocated container
DECL|field|container
specifier|private
name|Container
name|container
decl_stmt|;
DECL|field|shellId
specifier|private
name|String
name|shellId
decl_stmt|;
DECL|field|containerListener
name|NMCallbackHandler
name|containerListener
decl_stmt|;
comment|/**      * @param lcontainer Allocated container      * @param containerListener Callback handler of the container      */
DECL|method|LaunchContainerRunnable (Container lcontainer, NMCallbackHandler containerListener, String shellId)
specifier|public
name|LaunchContainerRunnable
parameter_list|(
name|Container
name|lcontainer
parameter_list|,
name|NMCallbackHandler
name|containerListener
parameter_list|,
name|String
name|shellId
parameter_list|)
block|{
name|this
operator|.
name|container
operator|=
name|lcontainer
expr_stmt|;
name|this
operator|.
name|containerListener
operator|=
name|containerListener
expr_stmt|;
name|this
operator|.
name|shellId
operator|=
name|shellId
expr_stmt|;
block|}
annotation|@
name|Override
comment|/**      * Connects to CM, sets up container launch context       * for shell command and eventually dispatches the container       * start request to the CM.       */
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Setting up container launch container for containerid="
operator|+
name|container
operator|.
name|getId
argument_list|()
operator|+
literal|" with shellid="
operator|+
name|shellId
argument_list|)
expr_stmt|;
comment|// Set the local resources
name|Map
argument_list|<
name|String
argument_list|,
name|LocalResource
argument_list|>
name|localResources
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|LocalResource
argument_list|>
argument_list|()
decl_stmt|;
comment|// The container for the eventual shell commands needs its own local
comment|// resources too.
comment|// In this scenario, if a shell script is specified, we need to have it
comment|// copied and made available to the container.
if|if
condition|(
operator|!
name|scriptPath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Path
name|renamedScriptPath
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|Shell
operator|.
name|WINDOWS
condition|)
block|{
name|renamedScriptPath
operator|=
operator|new
name|Path
argument_list|(
name|scriptPath
operator|+
literal|".bat"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|renamedScriptPath
operator|=
operator|new
name|Path
argument_list|(
name|scriptPath
operator|+
literal|".sh"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
comment|// rename the script file based on the underlying OS syntax.
name|renameScriptFile
argument_list|(
name|renamedScriptPath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Not able to add suffix (.bat/.sh) to the shell script filename"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// We know we cannot continue launching the container
comment|// so we should release it.
name|numCompletedContainers
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|numFailedContainers
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return;
block|}
name|URL
name|yarnUrl
init|=
literal|null
decl_stmt|;
try|try
block|{
name|yarnUrl
operator|=
name|ConverterUtils
operator|.
name|getYarnUrlFromURI
argument_list|(
operator|new
name|URI
argument_list|(
name|renamedScriptPath
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error when trying to use shell script path specified"
operator|+
literal|" in env, path="
operator|+
name|renamedScriptPath
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// A failure scenario on bad input such as invalid shell script path
comment|// We know we cannot continue launching the container
comment|// so we should release it.
comment|// TODO
name|numCompletedContainers
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|numFailedContainers
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
return|return;
block|}
name|LocalResource
name|shellRsrc
init|=
name|LocalResource
operator|.
name|newInstance
argument_list|(
name|yarnUrl
argument_list|,
name|LocalResourceType
operator|.
name|FILE
argument_list|,
name|LocalResourceVisibility
operator|.
name|APPLICATION
argument_list|,
name|shellScriptPathLen
argument_list|,
name|shellScriptPathTimestamp
argument_list|)
decl_stmt|;
name|localResources
operator|.
name|put
argument_list|(
name|Shell
operator|.
name|WINDOWS
condition|?
name|ExecBatScripStringtPath
else|:
name|ExecShellStringPath
argument_list|,
name|shellRsrc
argument_list|)
expr_stmt|;
name|shellCommand
operator|=
name|Shell
operator|.
name|WINDOWS
condition|?
name|windows_command
else|:
name|linux_bash_command
expr_stmt|;
block|}
comment|// Set the necessary command to execute on the allocated container
name|Vector
argument_list|<
name|CharSequence
argument_list|>
name|vargs
init|=
operator|new
name|Vector
argument_list|<
name|CharSequence
argument_list|>
argument_list|(
literal|5
argument_list|)
decl_stmt|;
comment|// Set executable command
name|vargs
operator|.
name|add
argument_list|(
name|shellCommand
argument_list|)
expr_stmt|;
comment|// Set shell script path
if|if
condition|(
operator|!
name|scriptPath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|vargs
operator|.
name|add
argument_list|(
name|Shell
operator|.
name|WINDOWS
condition|?
name|ExecBatScripStringtPath
else|:
name|ExecShellStringPath
argument_list|)
expr_stmt|;
block|}
comment|// Set args for the shell command if any
name|vargs
operator|.
name|add
argument_list|(
name|shellArgs
argument_list|)
expr_stmt|;
comment|// Add log redirect params
name|vargs
operator|.
name|add
argument_list|(
literal|"1>"
operator|+
name|ApplicationConstants
operator|.
name|LOG_DIR_EXPANSION_VAR
operator|+
literal|"/stdout"
argument_list|)
expr_stmt|;
name|vargs
operator|.
name|add
argument_list|(
literal|"2>"
operator|+
name|ApplicationConstants
operator|.
name|LOG_DIR_EXPANSION_VAR
operator|+
literal|"/stderr"
argument_list|)
expr_stmt|;
comment|// Get final commmand
name|StringBuilder
name|command
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|CharSequence
name|str
range|:
name|vargs
control|)
block|{
name|command
operator|.
name|append
argument_list|(
name|str
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|commands
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|commands
operator|.
name|add
argument_list|(
name|command
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Set up ContainerLaunchContext, setting local resource, environment,
comment|// command and token for constructor.
comment|// Note for tokens: Set up tokens for the container too. Today, for normal
comment|// shell commands, the container in distribute-shell doesn't need any
comment|// tokens. We are populating them mainly for NodeManagers to be able to
comment|// download anyfiles in the distributed file-system. The tokens are
comment|// otherwise also useful in cases, for e.g., when one is running a
comment|// "hadoop dfs" command inside the distributed shell.
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|myShellEnv
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|shellEnv
argument_list|)
decl_stmt|;
name|myShellEnv
operator|.
name|put
argument_list|(
name|YARN_SHELL_ID
argument_list|,
name|shellId
argument_list|)
expr_stmt|;
name|ContainerLaunchContext
name|ctx
init|=
name|ContainerLaunchContext
operator|.
name|newInstance
argument_list|(
name|localResources
argument_list|,
name|myShellEnv
argument_list|,
name|commands
argument_list|,
literal|null
argument_list|,
name|allTokens
operator|.
name|duplicate
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|containerListener
operator|.
name|addContainer
argument_list|(
name|container
operator|.
name|getId
argument_list|()
argument_list|,
name|container
argument_list|)
expr_stmt|;
name|nmClientAsync
operator|.
name|startContainerAsync
argument_list|(
name|container
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|renameScriptFile (final Path renamedScriptPath)
specifier|private
name|void
name|renameScriptFile
parameter_list|(
specifier|final
name|Path
name|renamedScriptPath
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|appSubmitterUgi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|FileSystem
name|fs
init|=
name|renamedScriptPath
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|fs
operator|.
name|rename
argument_list|(
operator|new
name|Path
argument_list|(
name|scriptPath
argument_list|)
argument_list|,
name|renamedScriptPath
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"User "
operator|+
name|appSubmitterUgi
operator|.
name|getUserName
argument_list|()
operator|+
literal|" added suffix(.sh/.bat) to script file as "
operator|+
name|renamedScriptPath
argument_list|)
expr_stmt|;
block|}
comment|/**    * Setup the request that will be sent to the RM for the container ask.    *    * @return the setup ResourceRequest to be sent to RM    */
DECL|method|setupContainerAskForRM ()
specifier|private
name|ContainerRequest
name|setupContainerAskForRM
parameter_list|()
block|{
comment|// setup requirements for hosts
comment|// using * as any host will do for the distributed shell app
comment|// set the priority for the request
comment|// TODO - what is the range for priority? how to decide?
name|Priority
name|pri
init|=
name|Priority
operator|.
name|newInstance
argument_list|(
name|requestPriority
argument_list|)
decl_stmt|;
comment|// Set up resource type requirements
comment|// For now, memory and CPU are supported so we set memory and cpu requirements
name|Resource
name|capability
init|=
name|Resource
operator|.
name|newInstance
argument_list|(
name|containerMemory
argument_list|,
name|containerVirtualCores
argument_list|)
decl_stmt|;
name|ContainerRequest
name|request
init|=
operator|new
name|ContainerRequest
argument_list|(
name|capability
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|pri
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Requested container ask: "
operator|+
name|request
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|request
return|;
block|}
DECL|method|fileExist (String filePath)
specifier|private
name|boolean
name|fileExist
parameter_list|(
name|String
name|filePath
parameter_list|)
block|{
return|return
operator|new
name|File
argument_list|(
name|filePath
argument_list|)
operator|.
name|exists
argument_list|()
return|;
block|}
DECL|method|readContent (String filePath)
specifier|private
name|String
name|readContent
parameter_list|(
name|String
name|filePath
parameter_list|)
throws|throws
name|IOException
block|{
name|DataInputStream
name|ds
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ds
operator|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|filePath
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ds
operator|.
name|readUTF
argument_list|()
return|;
block|}
finally|finally
block|{
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
operator|.
name|closeQuietly
argument_list|(
name|ds
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|publishContainerStartEvent ( final TimelineClient timelineClient, Container container, String domainId, UserGroupInformation ugi)
specifier|private
specifier|static
name|void
name|publishContainerStartEvent
parameter_list|(
specifier|final
name|TimelineClient
name|timelineClient
parameter_list|,
name|Container
name|container
parameter_list|,
name|String
name|domainId
parameter_list|,
name|UserGroupInformation
name|ugi
parameter_list|)
block|{
specifier|final
name|TimelineEntity
name|entity
init|=
operator|new
name|TimelineEntity
argument_list|()
decl_stmt|;
name|entity
operator|.
name|setEntityId
argument_list|(
name|container
operator|.
name|getId
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|entity
operator|.
name|setEntityType
argument_list|(
name|DSEntity
operator|.
name|DS_CONTAINER
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|entity
operator|.
name|setDomainId
argument_list|(
name|domainId
argument_list|)
expr_stmt|;
name|entity
operator|.
name|addPrimaryFilter
argument_list|(
literal|"user"
argument_list|,
name|ugi
operator|.
name|getShortUserName
argument_list|()
argument_list|)
expr_stmt|;
name|TimelineEvent
name|event
init|=
operator|new
name|TimelineEvent
argument_list|()
decl_stmt|;
name|event
operator|.
name|setTimestamp
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|event
operator|.
name|setEventType
argument_list|(
name|DSEvent
operator|.
name|DS_CONTAINER_START
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|event
operator|.
name|addEventInfo
argument_list|(
literal|"Node"
argument_list|,
name|container
operator|.
name|getNodeId
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|event
operator|.
name|addEventInfo
argument_list|(
literal|"Resources"
argument_list|,
name|container
operator|.
name|getResource
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|entity
operator|.
name|addEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
try|try
block|{
name|ugi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|TimelinePutResponse
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|TimelinePutResponse
name|run
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|processTimelineResponseErrors
argument_list|(
name|timelineClient
operator|.
name|putEntities
argument_list|(
name|entity
argument_list|)
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Container start event could not be published for "
operator|+
name|container
operator|.
name|getId
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|e
operator|instanceof
name|UndeclaredThrowableException
condition|?
name|e
operator|.
name|getCause
argument_list|()
else|:
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|publishContainerEndEvent ( final TimelineClient timelineClient, ContainerStatus container, String domainId, UserGroupInformation ugi)
specifier|private
specifier|static
name|void
name|publishContainerEndEvent
parameter_list|(
specifier|final
name|TimelineClient
name|timelineClient
parameter_list|,
name|ContainerStatus
name|container
parameter_list|,
name|String
name|domainId
parameter_list|,
name|UserGroupInformation
name|ugi
parameter_list|)
block|{
specifier|final
name|TimelineEntity
name|entity
init|=
operator|new
name|TimelineEntity
argument_list|()
decl_stmt|;
name|entity
operator|.
name|setEntityId
argument_list|(
name|container
operator|.
name|getContainerId
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|entity
operator|.
name|setEntityType
argument_list|(
name|DSEntity
operator|.
name|DS_CONTAINER
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|entity
operator|.
name|setDomainId
argument_list|(
name|domainId
argument_list|)
expr_stmt|;
name|entity
operator|.
name|addPrimaryFilter
argument_list|(
literal|"user"
argument_list|,
name|ugi
operator|.
name|getShortUserName
argument_list|()
argument_list|)
expr_stmt|;
name|TimelineEvent
name|event
init|=
operator|new
name|TimelineEvent
argument_list|()
decl_stmt|;
name|event
operator|.
name|setTimestamp
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|event
operator|.
name|setEventType
argument_list|(
name|DSEvent
operator|.
name|DS_CONTAINER_END
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|event
operator|.
name|addEventInfo
argument_list|(
literal|"State"
argument_list|,
name|container
operator|.
name|getState
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|event
operator|.
name|addEventInfo
argument_list|(
literal|"Exit Status"
argument_list|,
name|container
operator|.
name|getExitStatus
argument_list|()
argument_list|)
expr_stmt|;
name|entity
operator|.
name|addEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
try|try
block|{
name|TimelinePutResponse
name|response
init|=
name|timelineClient
operator|.
name|putEntities
argument_list|(
name|entity
argument_list|)
decl_stmt|;
name|processTimelineResponseErrors
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|YarnException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Container end event could not be published for "
operator|+
name|container
operator|.
name|getContainerId
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|publishApplicationAttemptEvent ( final TimelineClient timelineClient, String appAttemptId, DSEvent appEvent, String domainId, UserGroupInformation ugi)
specifier|private
specifier|static
name|void
name|publishApplicationAttemptEvent
parameter_list|(
specifier|final
name|TimelineClient
name|timelineClient
parameter_list|,
name|String
name|appAttemptId
parameter_list|,
name|DSEvent
name|appEvent
parameter_list|,
name|String
name|domainId
parameter_list|,
name|UserGroupInformation
name|ugi
parameter_list|)
block|{
specifier|final
name|TimelineEntity
name|entity
init|=
operator|new
name|TimelineEntity
argument_list|()
decl_stmt|;
name|entity
operator|.
name|setEntityId
argument_list|(
name|appAttemptId
argument_list|)
expr_stmt|;
name|entity
operator|.
name|setEntityType
argument_list|(
name|DSEntity
operator|.
name|DS_APP_ATTEMPT
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|entity
operator|.
name|setDomainId
argument_list|(
name|domainId
argument_list|)
expr_stmt|;
name|entity
operator|.
name|addPrimaryFilter
argument_list|(
literal|"user"
argument_list|,
name|ugi
operator|.
name|getShortUserName
argument_list|()
argument_list|)
expr_stmt|;
name|TimelineEvent
name|event
init|=
operator|new
name|TimelineEvent
argument_list|()
decl_stmt|;
name|event
operator|.
name|setEventType
argument_list|(
name|appEvent
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|event
operator|.
name|setTimestamp
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|entity
operator|.
name|addEvent
argument_list|(
name|event
argument_list|)
expr_stmt|;
try|try
block|{
name|TimelinePutResponse
name|response
init|=
name|timelineClient
operator|.
name|putEntities
argument_list|(
name|entity
argument_list|)
decl_stmt|;
name|processTimelineResponseErrors
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|YarnException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"App Attempt "
operator|+
operator|(
name|appEvent
operator|.
name|equals
argument_list|(
name|DSEvent
operator|.
name|DS_APP_ATTEMPT_START
argument_list|)
condition|?
literal|"start"
else|:
literal|"end"
operator|)
operator|+
literal|" event could not be published for "
operator|+
name|appAttemptId
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|processTimelineResponseErrors ( TimelinePutResponse response)
specifier|private
specifier|static
name|TimelinePutResponse
name|processTimelineResponseErrors
parameter_list|(
name|TimelinePutResponse
name|response
parameter_list|)
block|{
name|List
argument_list|<
name|TimelinePutResponse
operator|.
name|TimelinePutError
argument_list|>
name|errors
init|=
name|response
operator|.
name|getErrors
argument_list|()
decl_stmt|;
if|if
condition|(
name|errors
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Timeline entities are successfully put"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|TimelinePutResponse
operator|.
name|TimelinePutError
name|error
range|:
name|errors
control|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error when publishing entity ["
operator|+
name|error
operator|.
name|getEntityType
argument_list|()
operator|+
literal|","
operator|+
name|error
operator|.
name|getEntityId
argument_list|()
operator|+
literal|"], server side error code: "
operator|+
name|error
operator|.
name|getErrorCode
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|response
return|;
block|}
DECL|method|getRMCallbackHandler ()
name|RMCallbackHandler
name|getRMCallbackHandler
parameter_list|()
block|{
return|return
operator|new
name|RMCallbackHandler
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setAmRMClient (AMRMClientAsync client)
name|void
name|setAmRMClient
parameter_list|(
name|AMRMClientAsync
name|client
parameter_list|)
block|{
name|this
operator|.
name|amRMClient
operator|=
name|client
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getNumCompletedContainers ()
name|int
name|getNumCompletedContainers
parameter_list|()
block|{
return|return
name|numCompletedContainers
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getDone ()
name|boolean
name|getDone
parameter_list|()
block|{
return|return
name|done
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|createLaunchContainerThread (Container allocatedContainer, String shellId)
name|Thread
name|createLaunchContainerThread
parameter_list|(
name|Container
name|allocatedContainer
parameter_list|,
name|String
name|shellId
parameter_list|)
block|{
name|LaunchContainerRunnable
name|runnableLaunchContainer
init|=
operator|new
name|LaunchContainerRunnable
argument_list|(
name|allocatedContainer
argument_list|,
name|containerListener
argument_list|,
name|shellId
argument_list|)
decl_stmt|;
return|return
operator|new
name|Thread
argument_list|(
name|runnableLaunchContainer
argument_list|)
return|;
block|}
block|}
end_class

end_unit

