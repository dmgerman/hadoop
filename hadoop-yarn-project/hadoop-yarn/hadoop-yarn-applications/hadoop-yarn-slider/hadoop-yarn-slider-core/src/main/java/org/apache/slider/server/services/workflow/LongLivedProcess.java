begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *       http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.slider.server.services.workflow
package|package
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|services
operator|.
name|workflow
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_comment
comment|/**  * Execute a long-lived process.  *  *<p>  * Hadoop's {@link org.apache.hadoop.util.Shell} class assumes it is executing  * a short lived application; this class allows for the process to run for the  * life of the Java process that forked it.  * It is designed to be embedded inside a YARN service, though this is not  * the sole way that it can be used  *<p>  * Key Features:  *<ol>  *<li>Output is streamed to the output logger provided</li>.  *<li>the input stream is closed as soon as the process starts.</li>  *<li>The most recent lines of output are saved to a linked list</li>.  *<li>A synchronous callback, {@link LongLivedProcessLifecycleEvent},  *   is raised on the start and finish of a process.</li>  *</ol>  *   */
end_comment

begin_class
DECL|class|LongLivedProcess
specifier|public
class|class
name|LongLivedProcess
implements|implements
name|Runnable
block|{
comment|/**    * Limit on number of lines to retain in the "recent" line list:{@value}    */
DECL|field|RECENT_LINE_LOG_LIMIT
specifier|public
specifier|static
specifier|final
name|int
name|RECENT_LINE_LOG_LIMIT
init|=
literal|64
decl_stmt|;
comment|/**    * Const defining the time in millis between polling for new text.    */
DECL|field|STREAM_READER_SLEEP_TIME
specifier|private
specifier|static
specifier|final
name|int
name|STREAM_READER_SLEEP_TIME
init|=
literal|200
decl_stmt|;
comment|/**    * limit on the length of a stream before it triggers an automatic newline.    */
DECL|field|LINE_LENGTH
specifier|private
specifier|static
specifier|final
name|int
name|LINE_LENGTH
init|=
literal|256
decl_stmt|;
DECL|field|processBuilder
specifier|private
specifier|final
name|ProcessBuilder
name|processBuilder
decl_stmt|;
DECL|field|process
specifier|private
name|Process
name|process
decl_stmt|;
DECL|field|exitCode
specifier|private
name|Integer
name|exitCode
init|=
literal|null
decl_stmt|;
DECL|field|name
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|processExecutor
specifier|private
specifier|final
name|ExecutorService
name|processExecutor
decl_stmt|;
DECL|field|logExecutor
specifier|private
specifier|final
name|ExecutorService
name|logExecutor
decl_stmt|;
DECL|field|processStreamReader
specifier|private
name|ProcessStreamReader
name|processStreamReader
decl_stmt|;
comment|//list of recent lines, recorded for extraction into reports
DECL|field|recentLines
specifier|private
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|recentLines
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|recentLineLimit
specifier|private
name|int
name|recentLineLimit
init|=
name|RECENT_LINE_LOG_LIMIT
decl_stmt|;
DECL|field|lifecycleCallback
specifier|private
name|LongLivedProcessLifecycleEvent
name|lifecycleCallback
decl_stmt|;
DECL|field|finalOutputProcessed
specifier|private
specifier|final
name|AtomicBoolean
name|finalOutputProcessed
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|/**    * Log supplied in the constructor for the spawned process -accessible    * to inner classes    */
DECL|field|processLog
specifier|private
name|Logger
name|processLog
decl_stmt|;
comment|/**    * Class log -accessible to inner classes    */
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|LongLivedProcess
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    *  flag to indicate that the process is done    */
DECL|field|finished
specifier|private
specifier|final
name|AtomicBoolean
name|finished
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|/**    * Create an instance    * @param name process name    * @param processLog log for output (or null)    * @param commands command list    */
DECL|method|LongLivedProcess (String name, Logger processLog, List<String> commands)
specifier|public
name|LongLivedProcess
parameter_list|(
name|String
name|name
parameter_list|,
name|Logger
name|processLog
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|commands
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|commands
operator|!=
literal|null
argument_list|,
literal|"commands"
argument_list|)
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|processLog
operator|=
name|processLog
expr_stmt|;
name|ServiceThreadFactory
name|factory
init|=
operator|new
name|ServiceThreadFactory
argument_list|(
name|name
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|processExecutor
operator|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|(
name|factory
argument_list|)
expr_stmt|;
name|logExecutor
operator|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|(
name|factory
argument_list|)
expr_stmt|;
name|processBuilder
operator|=
operator|new
name|ProcessBuilder
argument_list|(
name|commands
argument_list|)
expr_stmt|;
name|processBuilder
operator|.
name|redirectErrorStream
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the limit on recent lines to retain    * @param recentLineLimit size of rolling list of recent lines.    */
DECL|method|setRecentLineLimit (int recentLineLimit)
specifier|public
name|void
name|setRecentLineLimit
parameter_list|(
name|int
name|recentLineLimit
parameter_list|)
block|{
name|this
operator|.
name|recentLineLimit
operator|=
name|recentLineLimit
expr_stmt|;
block|}
comment|/**    * Set an optional application exit callback    * @param lifecycleCallback callback to notify on application exit    */
DECL|method|setLifecycleCallback (LongLivedProcessLifecycleEvent lifecycleCallback)
specifier|public
name|void
name|setLifecycleCallback
parameter_list|(
name|LongLivedProcessLifecycleEvent
name|lifecycleCallback
parameter_list|)
block|{
name|this
operator|.
name|lifecycleCallback
operator|=
name|lifecycleCallback
expr_stmt|;
block|}
comment|/**    * Add an entry to the environment    * @param envVar envVar -must not be null    * @param val value     */
DECL|method|setEnv (String envVar, String val)
specifier|public
name|void
name|setEnv
parameter_list|(
name|String
name|envVar
parameter_list|,
name|String
name|val
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|envVar
operator|!=
literal|null
argument_list|,
literal|"envVar"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|val
operator|!=
literal|null
argument_list|,
literal|"val"
argument_list|)
expr_stmt|;
name|processBuilder
operator|.
name|environment
argument_list|()
operator|.
name|put
argument_list|(
name|envVar
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/**    * Bulk set the environment from a map. This does    * not replace the existing environment, just extend it/overwrite single    * entries.    * @param map map to add    */
DECL|method|putEnvMap (Map<String, String> map)
specifier|public
name|void
name|putEnvMap
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|val
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|setEnv
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get the process environment    * @param variable environment variable    * @return the value or null if there is no match    */
DECL|method|getEnv (String variable)
specifier|public
name|String
name|getEnv
parameter_list|(
name|String
name|variable
parameter_list|)
block|{
return|return
name|processBuilder
operator|.
name|environment
argument_list|()
operator|.
name|get
argument_list|(
name|variable
argument_list|)
return|;
block|}
comment|/**    * Set the process log. Ignored once the process starts    * @param processLog new log ... may be null    */
DECL|method|setProcessLog (Logger processLog)
specifier|public
name|void
name|setProcessLog
parameter_list|(
name|Logger
name|processLog
parameter_list|)
block|{
name|this
operator|.
name|processLog
operator|=
name|processLog
expr_stmt|;
block|}
comment|/**    * Get the process reference    * @return the process -null if the process is  not started    */
DECL|method|getProcess ()
specifier|public
name|Process
name|getProcess
parameter_list|()
block|{
return|return
name|process
return|;
block|}
comment|/**    * Get the process builder -this can be manipulated    * up to the start() operation. As there is no synchronization    * around it, it must only be used in the same thread setting up the commmand.    * @return the process builder    */
DECL|method|getProcessBuilder ()
specifier|public
name|ProcessBuilder
name|getProcessBuilder
parameter_list|()
block|{
return|return
name|processBuilder
return|;
block|}
comment|/**    * Get the command list    * @return the comands    */
DECL|method|getCommands ()
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getCommands
parameter_list|()
block|{
return|return
name|processBuilder
operator|.
name|command
argument_list|()
return|;
block|}
DECL|method|getCommand ()
specifier|public
name|String
name|getCommand
parameter_list|()
block|{
return|return
name|getCommands
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**    * probe to see if the process is running    * @return true iff the process has been started and is not yet finished    */
DECL|method|isRunning ()
specifier|public
name|boolean
name|isRunning
parameter_list|()
block|{
return|return
name|process
operator|!=
literal|null
operator|&&
operator|!
name|finished
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Get the exit code: null until the process has finished    * @return the exit code or null    */
DECL|method|getExitCode ()
specifier|public
name|Integer
name|getExitCode
parameter_list|()
block|{
return|return
name|exitCode
return|;
block|}
comment|/**    * Get the exit code sign corrected: null until the process has finished    * @return the exit code or null    */
DECL|method|getExitCodeSignCorrected ()
specifier|public
name|Integer
name|getExitCodeSignCorrected
parameter_list|()
block|{
name|Integer
name|result
decl_stmt|;
if|if
condition|(
name|exitCode
operator|!=
literal|null
condition|)
block|{
name|result
operator|=
operator|(
name|exitCode
operator|<<
literal|24
operator|)
operator|>>
literal|24
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Stop the process if it is running.    * This will trigger an application completion event with the given exit code    */
DECL|method|stop ()
specifier|public
name|void
name|stop
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isRunning
argument_list|()
condition|)
block|{
return|return;
block|}
name|process
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
comment|/**    * Get a text description of the builder suitable for log output    * @return a multiline string     */
DECL|method|describeBuilder ()
specifier|protected
name|String
name|describeBuilder
parameter_list|()
block|{
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|arg
range|:
name|processBuilder
operator|.
name|command
argument_list|()
control|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
operator|.
name|append
argument_list|(
name|arg
argument_list|)
operator|.
name|append
argument_list|(
literal|"\" "
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Dump the environment to a string builder    * @param buffer the buffer to append to    */
DECL|method|dumpEnv (StringBuilder buffer)
specifier|public
name|void
name|dumpEnv
parameter_list|(
name|StringBuilder
name|buffer
parameter_list|)
block|{
name|buffer
operator|.
name|append
argument_list|(
literal|"\nEnvironment\n-----------"
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
init|=
name|processBuilder
operator|.
name|environment
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|keys
init|=
name|env
operator|.
name|keySet
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|sortedKeys
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|keys
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|sortedKeys
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|key
range|:
name|sortedKeys
control|)
block|{
name|buffer
operator|.
name|append
argument_list|(
name|key
argument_list|)
operator|.
name|append
argument_list|(
literal|"="
argument_list|)
operator|.
name|append
argument_list|(
name|env
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Exec the process    * @return the process    * @throws IOException on aany failure to start the process    * @throws FileNotFoundException if the process could not be found    */
DECL|method|spawnChildProcess ()
specifier|private
name|Process
name|spawnChildProcess
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|process
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Process already started"
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Spawning process:\n "
operator|+
name|describeBuilder
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|process
operator|=
name|processBuilder
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// on windows, upconvert DOS error 2 from ::CreateProcess()
comment|// to its real meaning: FileNotFound
if|if
condition|(
name|e
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
literal|"CreateProcess error=2"
argument_list|)
condition|)
block|{
name|FileNotFoundException
name|fnfe
init|=
operator|new
name|FileNotFoundException
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|fnfe
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|fnfe
throw|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
return|return
name|process
return|;
block|}
comment|/**    * Entry point for waiting for the program to finish    */
annotation|@
name|Override
comment|// Runnable
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|process
argument_list|,
literal|"null process"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Lifecycle callback thread running"
argument_list|)
expr_stmt|;
comment|//notify the callback that the process has started
if|if
condition|(
name|lifecycleCallback
operator|!=
literal|null
condition|)
block|{
name|lifecycleCallback
operator|.
name|onProcessStarted
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
try|try
block|{
comment|//close stdin for the process
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|process
operator|.
name|getOutputStream
argument_list|()
argument_list|)
expr_stmt|;
name|exitCode
operator|=
name|process
operator|.
name|waitFor
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Process wait interrupted -exiting thread"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|//here the process has finished
name|LOG
operator|.
name|debug
argument_list|(
literal|"process {} has finished"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|//tell the logger it has to finish too
name|finished
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// shut down the threads
name|logExecutor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
try|try
block|{
name|logExecutor
operator|.
name|awaitTermination
argument_list|(
literal|60
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{
comment|//ignored
block|}
comment|//now call the callback if it is set
if|if
condition|(
name|lifecycleCallback
operator|!=
literal|null
condition|)
block|{
name|lifecycleCallback
operator|.
name|onProcessExited
argument_list|(
name|this
argument_list|,
name|exitCode
argument_list|,
name|getExitCodeSignCorrected
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Spawn the application    * @throws IOException IO problems    */
DECL|method|start ()
specifier|public
name|void
name|start
parameter_list|()
throws|throws
name|IOException
block|{
name|spawnChildProcess
argument_list|()
expr_stmt|;
name|processStreamReader
operator|=
operator|new
name|ProcessStreamReader
argument_list|(
name|processLog
argument_list|,
name|STREAM_READER_SLEEP_TIME
argument_list|)
expr_stmt|;
name|logExecutor
operator|.
name|submit
argument_list|(
name|processStreamReader
argument_list|)
expr_stmt|;
name|processExecutor
operator|.
name|submit
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the lines of recent output    * @return the last few lines of output; an empty list if there are none    * or the process is not actually running    */
DECL|method|getRecentOutput ()
specifier|public
specifier|synchronized
name|List
argument_list|<
name|String
argument_list|>
name|getRecentOutput
parameter_list|()
block|{
return|return
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|recentLines
argument_list|)
return|;
block|}
comment|/**    * @return whether lines of recent output are empty    */
DECL|method|isRecentOutputEmpty ()
specifier|public
specifier|synchronized
name|boolean
name|isRecentOutputEmpty
parameter_list|()
block|{
return|return
name|recentLines
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**    * Query to see if the final output has been processed    * @return    */
DECL|method|isFinalOutputProcessed ()
specifier|public
name|boolean
name|isFinalOutputProcessed
parameter_list|()
block|{
return|return
name|finalOutputProcessed
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Get the recent output from the process, or [] if not defined    *    * @param finalOutput flag to indicate "wait for the final output of the process"    * @param duration the duration, in ms,     * ro wait for recent output to become non-empty    * @return a possibly empty list    */
DECL|method|getRecentOutput (boolean finalOutput, int duration)
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getRecentOutput
parameter_list|(
name|boolean
name|finalOutput
parameter_list|,
name|int
name|duration
parameter_list|)
block|{
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
while|while
condition|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
operator|<=
name|duration
condition|)
block|{
name|boolean
name|finishedOutput
decl_stmt|;
if|if
condition|(
name|finalOutput
condition|)
block|{
comment|// final flag means block until all data is done
name|finishedOutput
operator|=
name|isFinalOutputProcessed
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// there is some output
name|finishedOutput
operator|=
operator|!
name|isRecentOutputEmpty
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|finishedOutput
condition|)
block|{
break|break;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
name|getRecentOutput
argument_list|()
return|;
block|}
comment|/**    * add the recent line to the list of recent lines; deleting    * an earlier on if the limit is reached.    *    * Implementation note: yes, a circular array would be more    * efficient, especially with some power of two as the modulo,    * but is it worth the complexity and risk of errors for    * something that is only called once per line of IO?    * @param line line to record    * @param isErrorStream is the line from the error stream    * @param logger logger to log to - null for no logging    */
DECL|method|recordRecentLine (String line, boolean isErrorStream, Logger logger)
specifier|private
specifier|synchronized
name|void
name|recordRecentLine
parameter_list|(
name|String
name|line
parameter_list|,
name|boolean
name|isErrorStream
parameter_list|,
name|Logger
name|logger
parameter_list|)
block|{
if|if
condition|(
name|line
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|String
name|entry
init|=
operator|(
name|isErrorStream
condition|?
literal|"[ERR] "
else|:
literal|"[OUT] "
operator|)
operator|+
name|line
decl_stmt|;
name|recentLines
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|recentLines
operator|.
name|size
argument_list|()
operator|>
name|recentLineLimit
condition|)
block|{
name|recentLines
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|logger
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|isErrorStream
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|info
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Class to read data from the two process streams, and, when run in a thread    * to keep running until the<code>done</code> flag is set.     * Lines are fetched from stdout and stderr and logged at info and error    * respectively.    */
DECL|class|ProcessStreamReader
specifier|private
class|class
name|ProcessStreamReader
implements|implements
name|Runnable
block|{
DECL|field|streamLog
specifier|private
specifier|final
name|Logger
name|streamLog
decl_stmt|;
DECL|field|sleepTime
specifier|private
specifier|final
name|int
name|sleepTime
decl_stmt|;
comment|/**      * Create an instance      * @param streamLog log -or null to disable logging (recent entries      * will still be retained)      * @param sleepTime time to sleep when stopping      */
DECL|method|ProcessStreamReader (Logger streamLog, int sleepTime)
specifier|private
name|ProcessStreamReader
parameter_list|(
name|Logger
name|streamLog
parameter_list|,
name|int
name|sleepTime
parameter_list|)
block|{
name|this
operator|.
name|streamLog
operator|=
name|streamLog
expr_stmt|;
name|this
operator|.
name|sleepTime
operator|=
name|sleepTime
expr_stmt|;
block|}
comment|/**      * Return a character if there is one, -1 if nothing is ready yet      * @param reader reader      * @return the value from the reader, or -1 if it is not ready      * @throws IOException IO problems      */
DECL|method|readCharNonBlocking (BufferedReader reader)
specifier|private
name|int
name|readCharNonBlocking
parameter_list|(
name|BufferedReader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|reader
operator|.
name|ready
argument_list|()
condition|)
block|{
return|return
name|reader
operator|.
name|read
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/**      * Read in a line, or, if the limit has been reached, the buffer      * so far      * @param reader source of data      * @param line line to build      * @param limit limit of line length      * @return true if the line can be printed      * @throws IOException IO trouble      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"NestedAssignment"
argument_list|)
DECL|method|readAnyLine (BufferedReader reader, StringBuilder line, int limit)
specifier|private
name|boolean
name|readAnyLine
parameter_list|(
name|BufferedReader
name|reader
parameter_list|,
name|StringBuilder
name|line
parameter_list|,
name|int
name|limit
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|next
decl_stmt|;
while|while
condition|(
operator|(
operator|-
literal|1
operator|!=
operator|(
name|next
operator|=
name|readCharNonBlocking
argument_list|(
name|reader
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|next
operator|!=
literal|'\n'
condition|)
block|{
name|line
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|next
argument_list|)
expr_stmt|;
name|limit
operator|--
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|length
argument_list|()
operator|>
name|limit
condition|)
block|{
comment|//enough has been read in to print it any
return|return
literal|true
return|;
block|}
block|}
else|else
block|{
comment|//line end return flag to say so
return|return
literal|true
return|;
block|}
block|}
comment|//here the end of the stream is hit, or the limit
return|return
literal|false
return|;
block|}
annotation|@
name|Override
comment|//Runnable
annotation|@
name|SuppressWarnings
argument_list|(
literal|"IOResourceOpenedButNotSafelyClosed"
argument_list|)
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|BufferedReader
name|errReader
init|=
literal|null
decl_stmt|;
name|BufferedReader
name|outReader
init|=
literal|null
decl_stmt|;
name|StringBuilder
name|outLine
init|=
operator|new
name|StringBuilder
argument_list|(
name|LINE_LENGTH
argument_list|)
decl_stmt|;
name|StringBuilder
name|errorLine
init|=
operator|new
name|StringBuilder
argument_list|(
name|LINE_LENGTH
argument_list|)
decl_stmt|;
try|try
block|{
name|errReader
operator|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|process
operator|.
name|getErrorStream
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|outReader
operator|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|process
operator|.
name|getInputStream
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|finished
operator|.
name|get
argument_list|()
condition|)
block|{
name|boolean
name|processed
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|readAnyLine
argument_list|(
name|errReader
argument_list|,
name|errorLine
argument_list|,
name|LINE_LENGTH
argument_list|)
condition|)
block|{
name|recordRecentLine
argument_list|(
name|errorLine
operator|.
name|toString
argument_list|()
argument_list|,
literal|true
argument_list|,
name|streamLog
argument_list|)
expr_stmt|;
name|errorLine
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|processed
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|readAnyLine
argument_list|(
name|outReader
argument_list|,
name|outLine
argument_list|,
name|LINE_LENGTH
argument_list|)
condition|)
block|{
name|recordRecentLine
argument_list|(
name|outLine
operator|.
name|toString
argument_list|()
argument_list|,
literal|false
argument_list|,
name|streamLog
argument_list|)
expr_stmt|;
name|outLine
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|processed
operator||=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|processed
operator|&&
operator|!
name|finished
operator|.
name|get
argument_list|()
condition|)
block|{
comment|//nothing processed: wait a bit for data.
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|//ignore this, rely on the done flag
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// finished: cleanup
comment|//print the current error line then stream through the rest
name|recordFinalOutput
argument_list|(
name|errReader
argument_list|,
name|errorLine
argument_list|,
literal|true
argument_list|,
name|streamLog
argument_list|)
expr_stmt|;
comment|//now do the info line
name|recordFinalOutput
argument_list|(
name|outReader
argument_list|,
name|outLine
argument_list|,
literal|false
argument_list|,
name|streamLog
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignored
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"encountered {}"
argument_list|,
name|ignored
argument_list|,
name|ignored
argument_list|)
expr_stmt|;
comment|//process connection has been torn down
block|}
finally|finally
block|{
comment|// close streams
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|errReader
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|outReader
argument_list|)
expr_stmt|;
comment|//mark output as done
name|finalOutputProcessed
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Record the final output of a process stream      * @param reader reader of output      * @param lineBuilder string builder into which line is built      * @param isErrorStream flag to indicate whether or not this is the      * is the line from the error stream      * @param logger logger to log to      * @throws IOException      */
DECL|method|recordFinalOutput (BufferedReader reader, StringBuilder lineBuilder, boolean isErrorStream, Logger logger)
specifier|protected
name|void
name|recordFinalOutput
parameter_list|(
name|BufferedReader
name|reader
parameter_list|,
name|StringBuilder
name|lineBuilder
parameter_list|,
name|boolean
name|isErrorStream
parameter_list|,
name|Logger
name|logger
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|line
init|=
name|lineBuilder
operator|.
name|toString
argument_list|()
decl_stmt|;
name|recordRecentLine
argument_list|(
name|line
argument_list|,
name|isErrorStream
argument_list|,
name|logger
argument_list|)
expr_stmt|;
name|line
operator|=
name|reader
operator|.
name|readLine
argument_list|()
expr_stmt|;
while|while
condition|(
name|line
operator|!=
literal|null
condition|)
block|{
name|recordRecentLine
argument_list|(
name|line
argument_list|,
name|isErrorStream
argument_list|,
name|logger
argument_list|)
expr_stmt|;
name|line
operator|=
name|reader
operator|.
name|readLine
argument_list|()
expr_stmt|;
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
break|break;
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

