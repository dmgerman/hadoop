begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.slider.server.servicemonitor
package|package
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|servicemonitor
package|;
end_package

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * This is the entry point to do work. A list of probes is taken in, in order of  * booting. Once live they go to the live probes list.  *  * The dependency probes are a set of probes for dependent services, all of which  * must be live before boot probes commence.  *  * The boot probes are executed and are allowed to fail; failure is interpreted as "not yet live"  *  * Once all boot probes are live, the live list is used for probes; these must not fail.  *  * There is no timeout on dependency probe bootstrap time, because of the notion that  * restarting this service will have no effect on the dependencies.   */
end_comment

begin_class
DECL|class|ProbeWorker
specifier|public
class|class
name|ProbeWorker
implements|implements
name|Runnable
block|{
DECL|field|log
specifier|protected
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ProbeWorker
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|FAILED_TO_BOOT
specifier|public
specifier|static
specifier|final
name|String
name|FAILED_TO_BOOT
init|=
literal|"Monitored service failed to bootstrap after "
decl_stmt|;
DECL|field|FAILURE_OF_A_LIVE_PROBE_DURING_BOOTSTRAPPING
specifier|public
specifier|static
specifier|final
name|String
name|FAILURE_OF_A_LIVE_PROBE_DURING_BOOTSTRAPPING
init|=
literal|"Failure of a live probe during bootstrapping"
decl_stmt|;
DECL|field|monitorProbes
specifier|private
specifier|final
name|List
argument_list|<
name|Probe
argument_list|>
name|monitorProbes
decl_stmt|;
DECL|field|dependencyProbes
specifier|private
specifier|final
name|List
argument_list|<
name|Probe
argument_list|>
name|dependencyProbes
decl_stmt|;
DECL|field|interval
specifier|public
specifier|final
name|int
name|interval
decl_stmt|;
DECL|field|lastStatus
specifier|protected
specifier|volatile
name|ProbeStatus
name|lastStatus
decl_stmt|;
DECL|field|lastFailingBootstrapProbe
specifier|protected
specifier|volatile
name|ProbeStatus
name|lastFailingBootstrapProbe
decl_stmt|;
DECL|field|currentProbe
specifier|protected
specifier|volatile
name|Probe
name|currentProbe
decl_stmt|;
DECL|field|mustExit
specifier|private
specifier|volatile
name|boolean
name|mustExit
decl_stmt|;
DECL|field|bootstrapTimeout
specifier|private
specifier|final
name|int
name|bootstrapTimeout
decl_stmt|;
DECL|field|bootstrapEndtime
specifier|private
name|long
name|bootstrapEndtime
decl_stmt|;
DECL|field|reportHandler
specifier|private
name|ProbeReportHandler
name|reportHandler
decl_stmt|;
DECL|field|probePhase
specifier|private
specifier|volatile
name|ProbePhase
name|probePhase
init|=
name|ProbePhase
operator|.
name|INIT
decl_stmt|;
comment|/**    * Create a probe worker    * @param monitorProbes list of probes that must boot and then go live -after which    * they must stay live.    * @param dependencyProbes the list of dependency probes that must all succeed before    * any attempt to probe the direct probe list is performed. Once the     * dependency phase has completed, these probes are never checked again.    * @param interval probe interval in milliseconds.    * @param bootstrapTimeout timeout for bootstrap in milliseconds    */
DECL|method|ProbeWorker (List<Probe> monitorProbes, List<Probe> dependencyProbes, int interval, int bootstrapTimeout)
specifier|public
name|ProbeWorker
parameter_list|(
name|List
argument_list|<
name|Probe
argument_list|>
name|monitorProbes
parameter_list|,
name|List
argument_list|<
name|Probe
argument_list|>
name|dependencyProbes
parameter_list|,
name|int
name|interval
parameter_list|,
name|int
name|bootstrapTimeout
parameter_list|)
block|{
name|this
operator|.
name|monitorProbes
operator|=
name|monitorProbes
expr_stmt|;
name|this
operator|.
name|dependencyProbes
operator|=
name|dependencyProbes
operator|!=
literal|null
condition|?
name|dependencyProbes
else|:
operator|new
name|ArrayList
argument_list|<
name|Probe
argument_list|>
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|interval
operator|=
name|interval
expr_stmt|;
name|lastStatus
operator|=
operator|new
name|ProbeStatus
argument_list|(
name|now
argument_list|()
argument_list|,
literal|"Initial status"
argument_list|)
expr_stmt|;
name|lastStatus
operator|.
name|setProbePhase
argument_list|(
name|ProbePhase
operator|.
name|INIT
argument_list|)
expr_stmt|;
name|this
operator|.
name|bootstrapTimeout
operator|=
name|bootstrapTimeout
expr_stmt|;
block|}
DECL|method|init ()
specifier|public
name|void
name|init
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|Probe
name|probe
range|:
name|monitorProbes
control|)
block|{
name|probe
operator|.
name|init
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Probe
name|probe
range|:
name|dependencyProbes
control|)
block|{
name|probe
operator|.
name|init
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|setReportHandler (ProbeReportHandler reportHandler)
specifier|public
name|void
name|setReportHandler
parameter_list|(
name|ProbeReportHandler
name|reportHandler
parameter_list|)
block|{
name|this
operator|.
name|reportHandler
operator|=
name|reportHandler
expr_stmt|;
block|}
DECL|method|setMustExit ()
specifier|public
name|void
name|setMustExit
parameter_list|()
block|{
name|this
operator|.
name|mustExit
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|getLastStatus ()
specifier|public
name|ProbeStatus
name|getLastStatus
parameter_list|()
block|{
return|return
name|lastStatus
return|;
block|}
DECL|method|getCurrentProbe ()
specifier|public
specifier|synchronized
name|Probe
name|getCurrentProbe
parameter_list|()
block|{
return|return
name|currentProbe
return|;
block|}
DECL|method|getProbePhase ()
specifier|public
name|ProbePhase
name|getProbePhase
parameter_list|()
block|{
return|return
name|probePhase
return|;
block|}
comment|/**    * Enter the new process state, and report it to the report handler.    * This is synchronized just to make sure there isn't more than one    * invocation at the same time.    * @param status the new process status    */
DECL|method|enterProbePhase (ProbePhase status)
specifier|private
specifier|synchronized
name|void
name|enterProbePhase
parameter_list|(
name|ProbePhase
name|status
parameter_list|)
block|{
name|this
operator|.
name|probePhase
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|reportHandler
operator|!=
literal|null
condition|)
block|{
name|reportHandler
operator|.
name|probeProcessStateChange
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Report the probe status to the listener -setting the probe phase field    * before doing so.    * The value is also stored in the {@link #lastStatus} field    * @param status the new status    */
DECL|method|reportProbeStatus (ProbeStatus status)
specifier|private
name|void
name|reportProbeStatus
parameter_list|(
name|ProbeStatus
name|status
parameter_list|)
block|{
name|ProbePhase
name|phase
init|=
name|getProbePhase
argument_list|()
decl_stmt|;
name|status
operator|.
name|setProbePhase
argument_list|(
name|phase
argument_list|)
expr_stmt|;
name|lastStatus
operator|=
name|status
expr_stmt|;
name|reportHandler
operator|.
name|probeResult
argument_list|(
name|phase
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
comment|/**    * Ping one probe. Logs the operation at debug level; sets the field<code>currentProbe</code>    * to the probe for the duration of the operation -this is used when identifying the    * cause of a hung reporting loop    * @param probe probe to ping    * @param live flag to indicate whether or not the operation is live or bootstrapping    * @return the status of the ping    * @throws ProbeInterruptedException if the probe has been told to exit    */
DECL|method|ping (Probe probe, boolean live)
specifier|private
name|ProbeStatus
name|ping
parameter_list|(
name|Probe
name|probe
parameter_list|,
name|boolean
name|live
parameter_list|)
throws|throws
name|ProbeInterruptedException
block|{
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Executing "
operator|+
name|probe
argument_list|)
expr_stmt|;
block|}
name|checkForExitRequest
argument_list|()
expr_stmt|;
name|currentProbe
operator|=
name|probe
expr_stmt|;
try|try
block|{
return|return
name|probe
operator|.
name|ping
argument_list|(
name|live
argument_list|)
return|;
block|}
finally|finally
block|{
name|currentProbe
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**    * Check for an exit request -and convert it to an exception if made    * @throws ProbeInterruptedException iff {@link #mustExit} is true    */
DECL|method|checkForExitRequest ()
specifier|private
name|void
name|checkForExitRequest
parameter_list|()
throws|throws
name|ProbeInterruptedException
block|{
if|if
condition|(
name|mustExit
condition|)
block|{
throw|throw
operator|new
name|ProbeInterruptedException
argument_list|()
throw|;
block|}
block|}
comment|/**    * Check the dependencies.     * The moment a failing test is reached the call returns without    * any reporting.    *    * All successful probes are reported, so as to keep the heartbeats happy.    *    * @return the status of the last dependency check. If this is a success    * them every probe passed.    */
DECL|method|checkDependencyProbes ()
specifier|private
name|ProbeStatus
name|checkDependencyProbes
parameter_list|()
throws|throws
name|ProbeInterruptedException
block|{
name|ProbeStatus
name|status
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Probe
name|dependency
range|:
name|dependencyProbes
control|)
block|{
comment|//ping them, making clear they are not to run any bootstrap logic
name|status
operator|=
name|ping
argument_list|(
name|dependency
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
operator|.
name|isSuccess
argument_list|()
condition|)
block|{
comment|//the first failure means the rest of the list can be skipped
break|break;
block|}
name|reportProbeStatus
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
comment|//return the last status
return|return
name|status
return|;
block|}
comment|/**    * Run through all the dependency probes and report their outcomes successes (even if they fail)    * @return true iff all the probes have succeeded.    * @throws ProbeInterruptedException if the process was interrupted.    */
DECL|method|checkAndReportDependencyProbes ()
specifier|public
name|boolean
name|checkAndReportDependencyProbes
parameter_list|()
throws|throws
name|ProbeInterruptedException
block|{
name|ProbeStatus
name|status
decl_stmt|;
name|status
operator|=
name|checkDependencyProbes
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|null
operator|&&
operator|!
name|status
operator|.
name|isSuccess
argument_list|()
condition|)
block|{
comment|//during dependency checking, a failure is still reported as a success
name|status
operator|.
name|markAsSuccessful
argument_list|()
expr_stmt|;
name|reportProbeStatus
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|//then return without checking anything else
return|return
literal|false
return|;
block|}
comment|//all dependencies are done.
return|return
literal|true
return|;
block|}
comment|/**    * Begin bootstrapping by telling each probe that they have started.    * This sets the timeouts up, as well as permits any other set-up actions    * to begin.    */
DECL|method|beginBootstrapProbes ()
specifier|private
name|void
name|beginBootstrapProbes
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|bootstrapEndtime
operator|=
name|now
argument_list|()
operator|+
name|bootstrapTimeout
expr_stmt|;
block|}
for|for
control|(
name|Probe
name|probe
range|:
name|monitorProbes
control|)
block|{
name|probe
operator|.
name|beginBootstrap
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|now ()
specifier|private
name|long
name|now
parameter_list|()
block|{
return|return
name|System
operator|.
name|currentTimeMillis
argument_list|()
return|;
block|}
comment|/**    * Check the bootstrap probe list. All successful probes get reported.    * The first unsuccessful probe will be returned and not reported (left for policy upstream).    * If the failing probe has timed out, that is turned into a {@link ProbeFailedException}    * @return the last (unsuccessful) probe, or null if they all succeeded    * @throws ProbeInterruptedException interrupts    * @throws ProbeFailedException on a boot timeout    */
DECL|method|checkBootstrapProbes ()
specifier|private
name|boolean
name|checkBootstrapProbes
parameter_list|()
throws|throws
name|ProbeInterruptedException
throws|,
name|ProbeFailedException
block|{
name|verifyBootstrapHasNotTimedOut
argument_list|()
expr_stmt|;
name|boolean
name|probeFailed
init|=
literal|false
decl_stmt|;
comment|//now run through all the bootstrap probes
for|for
control|(
name|Probe
name|probe
range|:
name|monitorProbes
control|)
block|{
comment|//ping them
name|ProbeStatus
name|status
init|=
name|ping
argument_list|(
name|probe
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|status
operator|.
name|isSuccess
argument_list|()
condition|)
block|{
name|probeFailed
operator|=
literal|true
expr_stmt|;
name|lastFailingBootstrapProbe
operator|=
name|status
expr_stmt|;
name|probe
operator|.
name|failureCount
operator|++
expr_stmt|;
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Booting probe failed: "
operator|+
name|status
argument_list|)
expr_stmt|;
block|}
comment|//at this point check to see if the timeout has occurred -and if so, force in the last probe status.
comment|//this is a failure but not a timeout
comment|//during boot, a failure of a probe that hasn't booted is still reported as a success
if|if
condition|(
operator|!
name|probe
operator|.
name|isBooted
argument_list|()
condition|)
block|{
comment|//so the success bit is flipped
name|status
operator|.
name|markAsSuccessful
argument_list|()
expr_stmt|;
name|reportProbeStatus
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//the probe had booted but then it switched to failing
comment|//update the status unedited
name|reportProbeStatus
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|//then fail
throw|throw
name|raiseProbeFailure
argument_list|(
name|status
argument_list|,
name|FAILURE_OF_A_LIVE_PROBE_DURING_BOOTSTRAPPING
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|//this probe is working
if|if
condition|(
operator|!
name|probe
operator|.
name|isBooted
argument_list|()
condition|)
block|{
comment|//if it is new, mark it as live
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Booting probe is now live: "
operator|+
name|probe
argument_list|)
expr_stmt|;
block|}
name|probe
operator|.
name|endBootstrap
argument_list|()
expr_stmt|;
comment|//tell the report handler that another probe has booted
name|reportHandler
operator|.
name|probeBooted
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
comment|//push out its status
name|reportProbeStatus
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|probe
operator|.
name|successCount
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|!
name|probeFailed
return|;
block|}
DECL|method|getBootstrapTimeout ()
specifier|public
name|int
name|getBootstrapTimeout
parameter_list|()
block|{
return|return
name|bootstrapTimeout
return|;
block|}
comment|/**    * This checks that bootstrap operations have not timed out    * @throws ProbeFailedException if the bootstrap has failed    */
DECL|method|verifyBootstrapHasNotTimedOut ()
specifier|public
name|void
name|verifyBootstrapHasNotTimedOut
parameter_list|()
throws|throws
name|ProbeFailedException
block|{
comment|//first step -look for a timeout
if|if
condition|(
name|isBootstrapTimeExceeded
argument_list|()
condition|)
block|{
name|String
name|text
init|=
name|FAILED_TO_BOOT
operator|+
name|MonitorUtils
operator|.
name|millisToHumanTime
argument_list|(
name|bootstrapTimeout
argument_list|)
decl_stmt|;
name|ProbeStatus
name|status
decl_stmt|;
if|if
condition|(
name|lastFailingBootstrapProbe
operator|!=
literal|null
condition|)
block|{
name|status
operator|=
name|lastFailingBootstrapProbe
expr_stmt|;
name|status
operator|.
name|setSuccess
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
operator|new
name|ProbeStatus
argument_list|()
expr_stmt|;
name|status
operator|.
name|finish
argument_list|(
literal|null
argument_list|,
literal|false
argument_list|,
name|text
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
throw|throw
name|raiseProbeFailure
argument_list|(
name|status
argument_list|,
name|text
argument_list|)
throw|;
block|}
block|}
comment|/**    * predicate that gets current time and checks for its time being exceeded.    * @return true iff the current time is> the end time    */
DECL|method|isBootstrapTimeExceeded ()
specifier|public
specifier|synchronized
name|boolean
name|isBootstrapTimeExceeded
parameter_list|()
block|{
return|return
name|now
argument_list|()
operator|>
name|bootstrapEndtime
return|;
block|}
comment|/**    * run through all the bootstrap probes and see if they are live.    * @return true iff all boot probes succeeded    * @throws ProbeInterruptedException the probe interruption flags    * @throws ProbeFailedException if a probe failed.    */
DECL|method|checkAndReportBootstrapProbes ()
specifier|public
name|boolean
name|checkAndReportBootstrapProbes
parameter_list|()
throws|throws
name|ProbeInterruptedException
throws|,
name|ProbeFailedException
block|{
if|if
condition|(
name|bootstrapTimeout
operator|<=
literal|0
condition|)
block|{
comment|//there is no period of grace for bootstrapping probes, so return true saying
comment|//this phase is complete
return|return
literal|true
return|;
block|}
comment|//now the bootstrapping probes
return|return
name|checkBootstrapProbes
argument_list|()
return|;
block|}
comment|/**    * run through all the live probes, pinging and reporting them.    * A single probe failure is turned into an exception    * @throws ProbeFailedException a probe failed    * @throws ProbeInterruptedException the probe process was explicitly interrupted    */
DECL|method|checkAndReportLiveProbes ()
specifier|protected
name|void
name|checkAndReportLiveProbes
parameter_list|()
throws|throws
name|ProbeFailedException
throws|,
name|ProbeInterruptedException
block|{
name|ProbeStatus
name|status
init|=
literal|null
decl_stmt|;
comment|//go through the live list
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Checking live probes"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Probe
name|probe
range|:
name|monitorProbes
control|)
block|{
name|status
operator|=
name|ping
argument_list|(
name|probe
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|reportProbeStatus
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
operator|.
name|isSuccess
argument_list|()
condition|)
block|{
throw|throw
name|raiseProbeFailure
argument_list|(
name|status
argument_list|,
literal|"Failure of probe in \"live\" monitor"
argument_list|)
throw|;
block|}
name|probe
operator|.
name|successCount
operator|++
expr_stmt|;
block|}
comment|//here all is well, so notify the reporter
name|reportHandler
operator|.
name|liveProbeCycleCompleted
argument_list|()
expr_stmt|;
block|}
comment|/**    * Run the set of probes relevant for this phase of the probe lifecycle.    * @throws ProbeFailedException a probe failed    * @throws ProbeInterruptedException the probe process was explicitly interrupted    */
DECL|method|executeProbePhases ()
specifier|protected
name|void
name|executeProbePhases
parameter_list|()
throws|throws
name|ProbeFailedException
throws|,
name|ProbeInterruptedException
block|{
switch|switch
condition|(
name|probePhase
condition|)
block|{
case|case
name|INIT
case|:
name|enterProbePhase
argument_list|(
name|ProbePhase
operator|.
name|DEPENDENCY_CHECKING
argument_list|)
expr_stmt|;
comment|//fall through straight into the dependency check
case|case
name|DEPENDENCY_CHECKING
case|:
if|if
condition|(
name|checkAndReportDependencyProbes
argument_list|()
condition|)
block|{
name|enterProbePhase
argument_list|(
name|ProbePhase
operator|.
name|BOOTSTRAPPING
argument_list|)
expr_stmt|;
name|beginBootstrapProbes
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|BOOTSTRAPPING
case|:
if|if
condition|(
name|checkAndReportBootstrapProbes
argument_list|()
condition|)
block|{
name|enterProbePhase
argument_list|(
name|ProbePhase
operator|.
name|LIVE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LIVE
case|:
name|checkAndReportLiveProbes
argument_list|()
expr_stmt|;
break|break;
case|case
name|TERMINATING
case|:
default|default:
comment|//do nothing.
break|break;
block|}
block|}
comment|/**    * Raise a probe failure; injecting the phase into the status result first    *    * @param status ping result    * @param text optional text -null or "" means "none"    * @return an exception ready to throw    */
DECL|method|raiseProbeFailure (ProbeStatus status, String text)
specifier|private
name|ProbeFailedException
name|raiseProbeFailure
parameter_list|(
name|ProbeStatus
name|status
parameter_list|,
name|String
name|text
parameter_list|)
block|{
name|status
operator|.
name|setProbePhase
argument_list|(
name|probePhase
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Probe failed: "
operator|+
name|status
argument_list|)
expr_stmt|;
return|return
operator|new
name|ProbeFailedException
argument_list|(
name|text
argument_list|,
name|status
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|int
name|size
init|=
name|monitorProbes
operator|.
name|size
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Probe Worker Starting; "
operator|+
name|size
operator|+
literal|" probe"
operator|+
name|MonitorUtils
operator|.
name|toPlural
argument_list|(
name|size
argument_list|)
operator|+
literal|":"
argument_list|)
expr_stmt|;
name|enterProbePhase
argument_list|(
name|ProbePhase
operator|.
name|DEPENDENCY_CHECKING
argument_list|)
expr_stmt|;
for|for
control|(
name|Probe
name|probe
range|:
name|monitorProbes
control|)
block|{
name|log
operator|.
name|info
argument_list|(
name|probe
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|mustExit
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|interval
argument_list|)
expr_stmt|;
name|executeProbePhases
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ProbeFailedException
name|e
parameter_list|)
block|{
comment|//relay to the inner loop handler
name|probeFailed
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|interrupted
parameter_list|)
block|{
break|break;
block|}
catch|catch
parameter_list|(
name|ProbeInterruptedException
name|e
parameter_list|)
block|{
comment|//exit raised.
comment|//this will be true, just making extra-sure
break|break;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Probe Worker Exiting"
argument_list|)
expr_stmt|;
name|enterProbePhase
argument_list|(
name|ProbePhase
operator|.
name|TERMINATING
argument_list|)
expr_stmt|;
block|}
DECL|method|probeFailed (ProbeFailedException e)
specifier|protected
name|void
name|probeFailed
parameter_list|(
name|ProbeFailedException
name|e
parameter_list|)
block|{
name|reportHandler
operator|.
name|probeFailure
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

