begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.slider.core.main
package|package
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|main
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ExitUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ShutdownHookManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|YarnUncaughtExceptionHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_comment
comment|/**  * A class to launch any service by name.  *   * It's designed to be subclassed for custom entry points.  *   *   * Workflow  *<ol>  *<li>An instance of the class is created</li>  *<li>If it implements RunService, it is given the binding args off the CLI</li>  *<li>Its service.init() and service.start() methods are called.</li>  *<li>If it implements RunService, runService() is called and its return  *   code used as the exit code.</li>  *<li>Otherwise: it waits for the service to stop, assuming in its start() method  *   it begins work</li>  *<li>If an exception returned an exit code, that becomes the exit code of the  *   command.</li>  *</ol>  * Error and warning messages are logged to stderr. Why? If the classpath  * is wrong& logger configurations not on it, then no error messages by  * the started app will be seen and the caller is left trying to debug  * using exit codes.   *   */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"UseOfSystemOutOrSystemErr"
argument_list|)
DECL|class|ServiceLauncher
specifier|public
class|class
name|ServiceLauncher
parameter_list|<
name|S
extends|extends
name|Service
parameter_list|>
implements|implements
name|LauncherExitCodes
implements|,
name|IrqHandler
operator|.
name|Interrupted
implements|,
name|Thread
operator|.
name|UncaughtExceptionHandler
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ServiceLauncher
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|PRIORITY
specifier|protected
specifier|static
specifier|final
name|int
name|PRIORITY
init|=
literal|30
decl_stmt|;
DECL|field|NAME
specifier|public
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"ServiceLauncher"
decl_stmt|;
comment|/**    * Name of the "--conf" argument.     */
DECL|field|ARG_CONF
specifier|public
specifier|static
specifier|final
name|String
name|ARG_CONF
init|=
literal|"--conf"
decl_stmt|;
DECL|field|USAGE_MESSAGE
specifier|public
specifier|static
specifier|final
name|String
name|USAGE_MESSAGE
init|=
literal|"Usage: "
operator|+
name|NAME
operator|+
literal|" classname ["
operator|+
name|ARG_CONF
operator|+
literal|"<conf file>]<service arguments> | "
decl_stmt|;
DECL|field|SHUTDOWN_TIME_ON_INTERRUPT
specifier|static
specifier|final
name|int
name|SHUTDOWN_TIME_ON_INTERRUPT
init|=
literal|30
operator|*
literal|1000
decl_stmt|;
DECL|field|service
specifier|private
specifier|volatile
name|S
name|service
decl_stmt|;
DECL|field|serviceExitCode
specifier|private
name|int
name|serviceExitCode
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"MismatchedQueryAndUpdateOfCollection"
argument_list|)
DECL|field|interruptHandlers
specifier|private
specifier|final
name|List
argument_list|<
name|IrqHandler
argument_list|>
name|interruptHandlers
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|field|configuration
specifier|private
name|Configuration
name|configuration
decl_stmt|;
DECL|field|serviceClassName
specifier|private
name|String
name|serviceClassName
decl_stmt|;
DECL|field|signalAlreadyReceived
specifier|private
specifier|static
name|AtomicBoolean
name|signalAlreadyReceived
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|/**    * Create an instance of the launcher    * @param serviceClassName classname of the service    */
DECL|method|ServiceLauncher (String serviceClassName)
specifier|public
name|ServiceLauncher
parameter_list|(
name|String
name|serviceClassName
parameter_list|)
block|{
name|this
operator|.
name|serviceClassName
operator|=
name|serviceClassName
expr_stmt|;
block|}
comment|/**    * Get the service. Null until and unless    * {@link #launchService(Configuration, String[], boolean)} has completed    * @return the service    */
DECL|method|getService ()
specifier|public
name|S
name|getService
parameter_list|()
block|{
return|return
name|service
return|;
block|}
comment|/**    * Get the configuration constructed from the command line arguments    * @return the configuration used to create the service    */
DECL|method|getConfiguration ()
specifier|public
name|Configuration
name|getConfiguration
parameter_list|()
block|{
return|return
name|configuration
return|;
block|}
comment|/**    * The exit code from a successful service execution    * @return the exit code.     */
DECL|method|getServiceExitCode ()
specifier|public
name|int
name|getServiceExitCode
parameter_list|()
block|{
return|return
name|serviceExitCode
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ServiceLauncher for "
operator|+
name|serviceClassName
return|;
block|}
comment|/**    * Launch the service, by creating it, initing it, starting it and then    * maybe running it. {@link RunService#bindArgs(Configuration, String...)} is invoked    * on the service between creation and init.    *    * All exceptions that occur are propagated upwards.    *    * If the method returns a status code, it means that it got as far starting    * the service, and if it implements {@link RunService}, that the     * method {@link RunService#runService()} has completed.     *    * At this point, the service is returned by {@link #getService()}.    *    * @param conf configuration    * @param processedArgs arguments after the configuration parameters    * have been stripped out.    * @param addProcessHooks should process failure handlers be added to    * terminate this service on shutdown. Tests should set this to false.    * @throws ClassNotFoundException classname not on the classpath    * @throws IllegalAccessException not allowed at the class    * @throws InstantiationException not allowed to instantiate it    * @throws InterruptedException thread interrupted    * @throws Throwable any other failure    */
DECL|method|launchService (Configuration conf, String[] processedArgs, boolean addProcessHooks)
specifier|public
name|int
name|launchService
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
index|[]
name|processedArgs
parameter_list|,
name|boolean
name|addProcessHooks
parameter_list|)
throws|throws
name|Throwable
block|{
name|instantiateService
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// add any process shutdown hooks
if|if
condition|(
name|addProcessHooks
condition|)
block|{
name|ServiceShutdownHook
name|shutdownHook
init|=
operator|new
name|ServiceShutdownHook
argument_list|(
name|service
argument_list|)
decl_stmt|;
name|ShutdownHookManager
operator|.
name|get
argument_list|()
operator|.
name|addShutdownHook
argument_list|(
name|shutdownHook
argument_list|,
name|PRIORITY
argument_list|)
expr_stmt|;
block|}
name|RunService
name|runService
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|service
operator|instanceof
name|RunService
condition|)
block|{
comment|//if its a runService, pass in the conf and arguments before init)
name|runService
operator|=
operator|(
name|RunService
operator|)
name|service
expr_stmt|;
name|configuration
operator|=
name|runService
operator|.
name|bindArgs
argument_list|(
name|configuration
argument_list|,
name|processedArgs
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|configuration
argument_list|,
literal|"null configuration returned by bindArgs()"
argument_list|)
expr_stmt|;
block|}
comment|//some class constructors init; here this is picked up on.
if|if
condition|(
operator|!
name|service
operator|.
name|isInState
argument_list|(
name|Service
operator|.
name|STATE
operator|.
name|INITED
argument_list|)
condition|)
block|{
name|service
operator|.
name|init
argument_list|(
name|configuration
argument_list|)
expr_stmt|;
block|}
name|service
operator|.
name|start
argument_list|()
expr_stmt|;
name|int
name|exitCode
init|=
name|EXIT_SUCCESS
decl_stmt|;
if|if
condition|(
name|runService
operator|!=
literal|null
condition|)
block|{
comment|//assume that runnable services are meant to run from here
name|exitCode
operator|=
name|runService
operator|.
name|runService
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Service exited with exit code {}"
argument_list|,
name|exitCode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//run the service until it stops or an interrupt happens on a different thread.
name|LOG
operator|.
name|debug
argument_list|(
literal|"waiting for service threads to terminate"
argument_list|)
expr_stmt|;
name|service
operator|.
name|waitForServiceToStop
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|//exit
name|serviceExitCode
operator|=
name|exitCode
expr_stmt|;
return|return
name|serviceExitCode
return|;
block|}
comment|/**    * Instantiate the service defined in<code>serviceClassName</code>    * . Sets the<code>configuration</code> field    * to the configuration, and<code>service</code> to the service.    *    * @param conf configuration to use    * @throws ClassNotFoundException classname not on the classpath    * @throws IllegalAccessException not allowed at the class    * @throws InstantiationException not allowed to instantiate it    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|instantiateService (Configuration conf)
specifier|public
name|Service
name|instantiateService
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|ClassNotFoundException
throws|,
name|InstantiationException
throws|,
name|IllegalAccessException
throws|,
name|ExitUtil
operator|.
name|ExitException
throws|,
name|NoSuchMethodException
throws|,
name|InvocationTargetException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|conf
operator|!=
literal|null
argument_list|,
literal|"null conf"
argument_list|)
expr_stmt|;
name|configuration
operator|=
name|conf
expr_stmt|;
comment|//Instantiate the class -this requires the service to have a public
comment|// zero-argument constructor
name|Class
argument_list|<
name|?
argument_list|>
name|serviceClass
init|=
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getClassLoader
argument_list|()
operator|.
name|loadClass
argument_list|(
name|serviceClassName
argument_list|)
decl_stmt|;
name|Object
name|instance
init|=
name|serviceClass
operator|.
name|getConstructor
argument_list|()
operator|.
name|newInstance
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|instance
operator|instanceof
name|Service
operator|)
condition|)
block|{
comment|//not a service
throw|throw
operator|new
name|ExitUtil
operator|.
name|ExitException
argument_list|(
name|EXIT_COMMAND_ARGUMENT_ERROR
argument_list|,
literal|"Not a Service class: "
operator|+
name|serviceClassName
argument_list|)
throw|;
block|}
name|service
operator|=
operator|(
name|S
operator|)
name|instance
expr_stmt|;
return|return
name|service
return|;
block|}
comment|/**    * Register this class as the handler for the control-C interrupt.    * Can be overridden for testing.    */
DECL|method|registerInterruptHandler ()
specifier|protected
name|void
name|registerInterruptHandler
parameter_list|()
block|{
try|try
block|{
name|interruptHandlers
operator|.
name|add
argument_list|(
operator|new
name|IrqHandler
argument_list|(
name|IrqHandler
operator|.
name|CONTROL_C
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|interruptHandlers
operator|.
name|add
argument_list|(
operator|new
name|IrqHandler
argument_list|(
name|IrqHandler
operator|.
name|SIGTERM
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|error
argument_list|(
literal|"Signal handler setup failed : {}"
operator|+
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * The service has been interrupted -try to shut down the service.    * Give the service time to do this before the exit operation is called     * @param interruptData the interrupted data.    */
annotation|@
name|Override
DECL|method|interrupted (IrqHandler.InterruptData interruptData)
specifier|public
name|void
name|interrupted
parameter_list|(
name|IrqHandler
operator|.
name|InterruptData
name|interruptData
parameter_list|)
block|{
name|String
name|message
init|=
literal|"Service interrupted by "
operator|+
name|interruptData
operator|.
name|toString
argument_list|()
decl_stmt|;
name|warn
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|signalAlreadyReceived
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"Repeated interrupt: escalating to a JVM halt"
argument_list|)
expr_stmt|;
comment|// signal already received. On a second request to a hard JVM
comment|// halt and so bypass any blocking shutdown hooks.
name|ExitUtil
operator|.
name|halt
argument_list|(
name|EXIT_INTERRUPTED
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
name|int
name|shutdownTimeMillis
init|=
name|SHUTDOWN_TIME_ON_INTERRUPT
decl_stmt|;
comment|//start an async shutdown thread with a timeout
name|ServiceForcedShutdown
name|forcedShutdown
init|=
operator|new
name|ServiceForcedShutdown
argument_list|(
name|shutdownTimeMillis
argument_list|)
decl_stmt|;
name|Thread
name|thread
init|=
operator|new
name|Thread
argument_list|(
name|forcedShutdown
argument_list|)
decl_stmt|;
name|thread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
comment|//wait for that thread to finish
try|try
block|{
name|thread
operator|.
name|join
argument_list|(
name|shutdownTimeMillis
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{
comment|//ignored
block|}
if|if
condition|(
operator|!
name|forcedShutdown
operator|.
name|isServiceStopped
argument_list|()
condition|)
block|{
name|warn
argument_list|(
literal|"Service did not shut down in time"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|EXIT_INTERRUPTED
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
comment|/**    * Uncaught exception handler.    * If an error is raised: shutdown    * The state of the system is unknown at this point -attempting    * a clean shutdown is dangerous. Instead: exit    * @param thread thread that failed    * @param exception exception    */
annotation|@
name|Override
DECL|method|uncaughtException (Thread thread, Throwable exception)
specifier|public
name|void
name|uncaughtException
parameter_list|(
name|Thread
name|thread
parameter_list|,
name|Throwable
name|exception
parameter_list|)
block|{
if|if
condition|(
name|ShutdownHookManager
operator|.
name|get
argument_list|()
operator|.
name|isShutdownInProgress
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Thread {} threw an error during shutdown: {}."
argument_list|,
name|thread
operator|.
name|toString
argument_list|()
argument_list|,
name|exception
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exception
operator|instanceof
name|Error
condition|)
block|{
try|try
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Thread {} threw an error: {}. Shutting down"
argument_list|,
name|thread
operator|.
name|toString
argument_list|()
argument_list|,
name|exception
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|err
parameter_list|)
block|{
comment|// We don't want to not exit because of an issue with logging
block|}
if|if
condition|(
name|exception
operator|instanceof
name|OutOfMemoryError
condition|)
block|{
comment|// After catching an OOM java says it is undefined behavior, so don't
comment|// even try to clean up or we can get stuck on shutdown.
try|try
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Halting due to Out Of Memory Error..."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|err
parameter_list|)
block|{
comment|// Again we don't want to exit because of logging issues.
block|}
name|ExitUtil
operator|.
name|halt
argument_list|(
name|EXIT_EXCEPTION_THROWN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// error other than OutOfMemory
name|exit
argument_list|(
name|convertToExitException
argument_list|(
name|exception
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// simple exception in a thread. There's a policy decision here:
comment|// terminate the service vs. keep going after a thread has failed
name|LOG
operator|.
name|error
argument_list|(
literal|"Thread {} threw an exception: {}"
argument_list|,
name|thread
operator|.
name|toString
argument_list|()
argument_list|,
name|exception
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Print a warning: currently this goes to stderr    * @param text    */
DECL|method|warn (String text)
specifier|protected
name|void
name|warn
parameter_list|(
name|String
name|text
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
comment|/**    * Report an error. The message is printed to stderr; the exception    * is logged via the current logger.    * @param message message for the user    * @param thrown the exception thrown    */
DECL|method|error (String message, Throwable thrown)
specifier|protected
name|void
name|error
parameter_list|(
name|String
name|message
parameter_list|,
name|Throwable
name|thrown
parameter_list|)
block|{
name|String
name|text
init|=
literal|"Exception: "
operator|+
name|message
decl_stmt|;
name|warn
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|text
argument_list|,
name|thrown
argument_list|)
expr_stmt|;
block|}
comment|/**    * Exit the code.    * This is method can be overridden for testing, throwing an     * exception instead. Any subclassed method MUST raise an     *<code>ExitUtil.ExitException</code> instance.    * The service launcher code assumes that after this method is invoked,    * no other code in the same method is called.    * @param exitCode code to exit    */
DECL|method|exit (int exitCode, String message)
specifier|protected
name|void
name|exit
parameter_list|(
name|int
name|exitCode
parameter_list|,
name|String
name|message
parameter_list|)
block|{
name|ExitUtil
operator|.
name|terminate
argument_list|(
name|exitCode
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
comment|/**    * Exit off an exception. This can be subclassed for testing    * @param ee exit exception    */
DECL|method|exit (ExitUtil.ExitException ee)
specifier|protected
name|void
name|exit
parameter_list|(
name|ExitUtil
operator|.
name|ExitException
name|ee
parameter_list|)
block|{
name|ExitUtil
operator|.
name|terminate
argument_list|(
name|ee
operator|.
name|status
argument_list|,
name|ee
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the service name via {@link Service#getName()}.    * If the service is not instantiated, the classname is returned instead.    * @return the service name    */
DECL|method|getServiceName ()
specifier|public
name|String
name|getServiceName
parameter_list|()
block|{
name|Service
name|s
init|=
name|service
decl_stmt|;
name|String
name|name
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|name
operator|=
name|s
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignored
parameter_list|)
block|{
comment|// ignored
block|}
block|}
if|if
condition|(
name|name
operator|!=
literal|null
condition|)
block|{
return|return
literal|"service "
operator|+
name|name
return|;
block|}
else|else
block|{
return|return
literal|"service classname "
operator|+
name|serviceClassName
return|;
block|}
block|}
comment|/**    * Parse the command line, building a configuration from it, then    * launch the service and wait for it to finish. finally, exit    * passing the status code to the #exit(int) method.    * @param args arguments to the service. arg[0] is     * assumed to be the service classname and is automatically    */
DECL|method|launchServiceAndExit (List<String> args)
specifier|public
name|void
name|launchServiceAndExit
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|args
parameter_list|)
block|{
name|registerInterruptHandler
argument_list|()
expr_stmt|;
comment|//Currently the config just the default
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|String
index|[]
name|processedArgs
init|=
name|extractConfigurationArgs
argument_list|(
name|conf
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|ExitUtil
operator|.
name|ExitException
name|ee
init|=
name|launchServiceRobustly
argument_list|(
name|conf
argument_list|,
name|processedArgs
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|flush
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|ee
argument_list|)
expr_stmt|;
block|}
comment|/**    * Extract the configuration arguments and apply them to the configuration,    * building an array of processed arguments to hand down to the service.    *    * @param conf configuration to update    * @param args main arguments. args[0] is assumed to be the service    * classname and is skipped    * @return the processed list.    */
DECL|method|extractConfigurationArgs (Configuration conf, List<String> args)
specifier|public
specifier|static
name|String
index|[]
name|extractConfigurationArgs
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|args
parameter_list|)
block|{
comment|//convert args to a list
name|int
name|argCount
init|=
name|args
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|argCount
operator|<=
literal|1
condition|)
block|{
return|return
operator|new
name|String
index|[
literal|0
index|]
return|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|argsList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|argCount
argument_list|)
decl_stmt|;
name|ListIterator
argument_list|<
name|String
argument_list|>
name|arguments
init|=
name|args
operator|.
name|listIterator
argument_list|()
decl_stmt|;
comment|//skip that first entry
name|arguments
operator|.
name|next
argument_list|()
expr_stmt|;
while|while
condition|(
name|arguments
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|String
name|arg
init|=
name|arguments
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|arg
operator|.
name|equals
argument_list|(
name|ARG_CONF
argument_list|)
condition|)
block|{
comment|//the argument is a --conf file tuple: extract the path and load
comment|//it in as a configuration resource.
comment|//increment the loop iterator
if|if
condition|(
operator|!
name|arguments
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|//overshot the end of the file
name|exitWithMessage
argument_list|(
name|EXIT_COMMAND_ARGUMENT_ERROR
argument_list|,
name|ARG_CONF
operator|+
literal|": missing configuration file after "
argument_list|)
expr_stmt|;
block|}
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|arguments
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
name|exitWithMessage
argument_list|(
name|EXIT_COMMAND_ARGUMENT_ERROR
argument_list|,
name|ARG_CONF
operator|+
literal|": configuration file not found: "
operator|+
name|file
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|conf
operator|.
name|addResource
argument_list|(
name|file
operator|.
name|toURI
argument_list|()
operator|.
name|toURL
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MalformedURLException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"File {} cannot be converted to URL"
argument_list|,
name|file
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|exitWithMessage
argument_list|(
name|EXIT_COMMAND_ARGUMENT_ERROR
argument_list|,
name|ARG_CONF
operator|+
literal|": configuration file path invalid: "
operator|+
name|file
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|argsList
operator|.
name|add
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
name|String
index|[]
name|processedArgs
init|=
operator|new
name|String
index|[
name|argsList
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|argsList
operator|.
name|toArray
argument_list|(
name|processedArgs
argument_list|)
expr_stmt|;
return|return
name|processedArgs
return|;
block|}
comment|/**    * Launch a service catching all exceptions and downgrading them to exit codes    * after logging.    * @param conf configuration to use    * @param processedArgs command line after the launcher-specific arguments have    * been stripped out    * @return an exit exception, which will have a status code of 0 if it worked    */
DECL|method|launchServiceRobustly (Configuration conf, String[] processedArgs)
specifier|public
name|ExitUtil
operator|.
name|ExitException
name|launchServiceRobustly
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
index|[]
name|processedArgs
parameter_list|)
block|{
name|ExitUtil
operator|.
name|ExitException
name|exitException
decl_stmt|;
try|try
block|{
name|int
name|exitCode
init|=
name|launchService
argument_list|(
name|conf
argument_list|,
name|processedArgs
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|service
operator|!=
literal|null
condition|)
block|{
name|Throwable
name|failure
init|=
name|service
operator|.
name|getFailureCause
argument_list|()
decl_stmt|;
if|if
condition|(
name|failure
operator|!=
literal|null
condition|)
block|{
comment|//the service exited with a failure.
comment|//check what state it is in
name|Service
operator|.
name|STATE
name|failureState
init|=
name|service
operator|.
name|getFailureState
argument_list|()
decl_stmt|;
if|if
condition|(
name|failureState
operator|==
name|Service
operator|.
name|STATE
operator|.
name|STOPPED
condition|)
block|{
comment|//the failure occurred during shutdown, not important enough to bother
comment|//the user as it may just scare them
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failure during shutdown:{} "
argument_list|,
name|failure
argument_list|,
name|failure
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//throw it for the catch handlers to deal with
throw|throw
name|failure
throw|;
block|}
block|}
block|}
name|exitException
operator|=
operator|new
name|ExitUtil
operator|.
name|ExitException
argument_list|(
name|exitCode
argument_list|,
literal|"In "
operator|+
name|serviceClassName
argument_list|)
expr_stmt|;
comment|// either the service succeeded, or an error raised during shutdown,
comment|// which we don't worry that much about
block|}
catch|catch
parameter_list|(
name|ExitUtil
operator|.
name|ExitException
name|ee
parameter_list|)
block|{
name|exitException
operator|=
name|ee
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|thrown
parameter_list|)
block|{
name|exitException
operator|=
name|convertToExitException
argument_list|(
name|thrown
argument_list|)
expr_stmt|;
block|}
return|return
name|exitException
return|;
block|}
comment|/**    * Convert the exception to one that can be handed off to ExitUtils;    * if it is of the write type it is passed throw as is. If not, a     * new exception with the exit code {@link #EXIT_EXCEPTION_THROWN}    * is created, with the argument<code>thrown</code> as the inner cause    * @param thrown the exception thrown    * @return an exception to terminate the process with    */
DECL|method|convertToExitException (Throwable thrown)
specifier|protected
name|ExitUtil
operator|.
name|ExitException
name|convertToExitException
parameter_list|(
name|Throwable
name|thrown
parameter_list|)
block|{
name|ExitUtil
operator|.
name|ExitException
name|exitException
decl_stmt|;
name|int
name|exitCode
decl_stmt|;
name|String
name|message
init|=
name|thrown
operator|.
name|getMessage
argument_list|()
decl_stmt|;
if|if
condition|(
name|message
operator|==
literal|null
condition|)
block|{
name|message
operator|=
name|thrown
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|thrown
operator|instanceof
name|ExitCodeProvider
condition|)
block|{
name|exitCode
operator|=
operator|(
operator|(
name|ExitCodeProvider
operator|)
name|thrown
operator|)
operator|.
name|getExitCode
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"While running {}: {}"
argument_list|,
name|getServiceName
argument_list|()
argument_list|,
name|message
argument_list|,
name|thrown
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// not any of the service launcher exceptions -assume something worse
name|error
argument_list|(
name|message
argument_list|,
name|thrown
argument_list|)
expr_stmt|;
name|exitCode
operator|=
name|EXIT_EXCEPTION_THROWN
expr_stmt|;
block|}
name|exitException
operator|=
operator|new
name|ExitUtil
operator|.
name|ExitException
argument_list|(
name|exitCode
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|exitException
operator|.
name|initCause
argument_list|(
name|thrown
argument_list|)
expr_stmt|;
return|return
name|exitException
return|;
block|}
comment|/**    * Build a log message for starting up and shutting down.     * This was grabbed from the ToolRunner code.    * @param classname the class of the server    * @param args arguments    */
DECL|method|startupShutdownMessage (String classname, List<String> args)
specifier|public
specifier|static
name|String
name|startupShutdownMessage
parameter_list|(
name|String
name|classname
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|args
parameter_list|)
block|{
specifier|final
name|String
name|hostname
init|=
name|NetUtils
operator|.
name|getHostname
argument_list|()
decl_stmt|;
return|return
name|toStartupShutdownString
argument_list|(
literal|"STARTUP_MSG: "
argument_list|,
operator|new
name|String
index|[]
block|{
literal|"Starting "
operator|+
name|classname
block|,
literal|"  host = "
operator|+
name|hostname
block|,
literal|"  args = "
operator|+
name|args
block|,
literal|"  version = "
operator|+
name|VersionInfo
operator|.
name|getVersion
argument_list|()
block|,
literal|"  classpath = "
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.class.path"
argument_list|)
block|,
literal|"  build = "
operator|+
name|VersionInfo
operator|.
name|getUrl
argument_list|()
operator|+
literal|" -r "
operator|+
name|VersionInfo
operator|.
name|getRevision
argument_list|()
operator|+
literal|"; compiled by '"
operator|+
name|VersionInfo
operator|.
name|getUser
argument_list|()
operator|+
literal|"' on "
operator|+
name|VersionInfo
operator|.
name|getDate
argument_list|()
block|,
literal|"  java = "
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.version"
argument_list|)
block|}
argument_list|)
return|;
block|}
comment|/**    * Exit with a printed message    * @param status status code    * @param message message    */
DECL|method|exitWithMessage (int status, String message)
specifier|private
specifier|static
name|void
name|exitWithMessage
parameter_list|(
name|int
name|status
parameter_list|,
name|String
name|message
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|ExitUtil
operator|.
name|terminate
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
DECL|method|toStartupShutdownString (String prefix, String[] msg)
specifier|private
specifier|static
name|String
name|toStartupShutdownString
parameter_list|(
name|String
name|prefix
parameter_list|,
name|String
index|[]
name|msg
parameter_list|)
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"\n/************************************************************"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|msg
control|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
operator|.
name|append
argument_list|(
name|prefix
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
literal|"\n************************************************************/"
argument_list|)
expr_stmt|;
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * forced shutdown runnable.    */
DECL|class|ServiceForcedShutdown
specifier|protected
class|class
name|ServiceForcedShutdown
implements|implements
name|Runnable
block|{
DECL|field|shutdownTimeMillis
specifier|private
specifier|final
name|int
name|shutdownTimeMillis
decl_stmt|;
DECL|field|serviceStopped
specifier|private
name|boolean
name|serviceStopped
decl_stmt|;
DECL|method|ServiceForcedShutdown (int shutdownTimeoutMillis)
specifier|public
name|ServiceForcedShutdown
parameter_list|(
name|int
name|shutdownTimeoutMillis
parameter_list|)
block|{
name|this
operator|.
name|shutdownTimeMillis
operator|=
name|shutdownTimeoutMillis
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|service
operator|!=
literal|null
condition|)
block|{
name|service
operator|.
name|stop
argument_list|()
expr_stmt|;
name|serviceStopped
operator|=
name|service
operator|.
name|waitForServiceToStop
argument_list|(
name|shutdownTimeMillis
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|serviceStopped
operator|=
literal|true
expr_stmt|;
block|}
block|}
DECL|method|isServiceStopped ()
specifier|private
name|boolean
name|isServiceStopped
parameter_list|()
block|{
return|return
name|serviceStopped
return|;
block|}
block|}
comment|/**    * The real main function, which takes the arguments as a list    * arg 0 must be the service classname    * @param argsList the list of arguments    */
DECL|method|serviceMain (List<String> argsList)
specifier|public
specifier|static
name|void
name|serviceMain
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|argsList
parameter_list|)
block|{
if|if
condition|(
name|argsList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|exitWithMessage
argument_list|(
name|EXIT_USAGE
argument_list|,
name|USAGE_MESSAGE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|serviceClassName
init|=
name|argsList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|startupShutdownMessage
argument_list|(
name|serviceClassName
argument_list|,
name|argsList
argument_list|)
argument_list|)
expr_stmt|;
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|arg
range|:
name|argsList
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
operator|.
name|append
argument_list|(
name|arg
argument_list|)
operator|.
name|append
argument_list|(
literal|"\" "
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
name|builder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Thread
operator|.
name|setDefaultUncaughtExceptionHandler
argument_list|(
operator|new
name|YarnUncaughtExceptionHandler
argument_list|()
argument_list|)
expr_stmt|;
name|ServiceLauncher
name|serviceLauncher
init|=
operator|new
name|ServiceLauncher
argument_list|<>
argument_list|(
name|serviceClassName
argument_list|)
decl_stmt|;
name|serviceLauncher
operator|.
name|launchServiceAndExit
argument_list|(
name|argsList
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This is the main entry point for the service launcher.    * @param args command line arguments.    */
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|argsList
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|serviceMain
argument_list|(
name|argsList
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

