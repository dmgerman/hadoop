begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.slider.providers
package|package
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|providers
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|ApplicationConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|LocalResource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|ClusterDescription
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|InternalKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|OptionKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|ResourceKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|RoleKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|SliderKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|SliderFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|SliderUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|conf
operator|.
name|AggregateConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|conf
operator|.
name|ConfTreeOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|conf
operator|.
name|MapOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|BadCommandArgumentsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|BadConfigException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|SliderException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|SliderInternalStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_comment
comment|/**  * this is a factoring out of methods handy for providers. It's bonded to a log at  * construction time  */
end_comment

begin_class
DECL|class|ProviderUtils
specifier|public
class|class
name|ProviderUtils
implements|implements
name|RoleKeys
block|{
DECL|field|log
specifier|protected
specifier|final
name|Logger
name|log
decl_stmt|;
comment|/**    * Create an instace    * @param log log directory to use -usually the provider    */
DECL|method|ProviderUtils (Logger log)
specifier|public
name|ProviderUtils
parameter_list|(
name|Logger
name|log
parameter_list|)
block|{
name|this
operator|.
name|log
operator|=
name|log
expr_stmt|;
block|}
comment|/**    * Add oneself to the classpath. This does not work    * on minicluster test runs where the JAR is not built up    * @param providerResources map of provider resources to add these entries to    * @param provider provider to add    * @param jarName name of the jar to use    * @param sliderFileSystem target filesystem    * @param tempPath path in the cluster FS for temp files    * @param libdir relative directory to place resources    * @param miniClusterTestRun    * @return true if the class was found in a JAR    *     * @throws FileNotFoundException if the JAR was not found and this is NOT    * a mini cluster test run    * @throws IOException IO problems    * @throws SliderException any Slider problem    */
DECL|method|addProviderJar (Map<String, LocalResource> providerResources, Object provider, String jarName, SliderFileSystem sliderFileSystem, Path tempPath, String libdir, boolean miniClusterTestRun)
specifier|public
specifier|static
name|boolean
name|addProviderJar
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|LocalResource
argument_list|>
name|providerResources
parameter_list|,
name|Object
name|provider
parameter_list|,
name|String
name|jarName
parameter_list|,
name|SliderFileSystem
name|sliderFileSystem
parameter_list|,
name|Path
name|tempPath
parameter_list|,
name|String
name|libdir
parameter_list|,
name|boolean
name|miniClusterTestRun
parameter_list|)
throws|throws
name|IOException
throws|,
name|SliderException
block|{
try|try
block|{
name|SliderUtils
operator|.
name|putJar
argument_list|(
name|providerResources
argument_list|,
name|sliderFileSystem
argument_list|,
name|provider
operator|.
name|getClass
argument_list|()
argument_list|,
name|tempPath
argument_list|,
name|libdir
argument_list|,
name|jarName
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
if|if
condition|(
name|miniClusterTestRun
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
block|}
comment|/**    * Add/overwrite the agent tarball (overwritten every time application is restarted)    * @param provider    * @param tarName    * @param sliderFileSystem    * @param agentDir    * @return true the location could be determined and the file added    * @throws IOException    */
DECL|method|addAgentTar (Object provider, String tarName, SliderFileSystem sliderFileSystem, Path agentDir)
specifier|public
specifier|static
name|boolean
name|addAgentTar
parameter_list|(
name|Object
name|provider
parameter_list|,
name|String
name|tarName
parameter_list|,
name|SliderFileSystem
name|sliderFileSystem
parameter_list|,
name|Path
name|agentDir
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|localFile
init|=
name|SliderUtils
operator|.
name|findContainingJar
argument_list|(
name|provider
operator|.
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|localFile
operator|!=
literal|null
condition|)
block|{
name|String
name|parentDir
init|=
name|localFile
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|Path
name|agentTarPath
init|=
operator|new
name|Path
argument_list|(
name|parentDir
argument_list|,
name|tarName
argument_list|)
decl_stmt|;
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
operator|.
name|copyFromLocalFile
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
name|agentTarPath
argument_list|,
name|agentDir
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Add a set of dependencies to the provider resources being built up,    * by copying them from the local classpath to the remote one, then    * registering them    * @param providerResources map of provider resources to add these entries to    * @param sliderFileSystem target filesystem    * @param tempPath path in the cluster FS for temp files    * @param libdir relative directory to place resources    * @param resources list of resource names (e.g. "hbase.jar"    * @param classes list of classes where classes[i] refers to a class in    * resources[i]    * @throws IOException IO problems    * @throws SliderException any Slider problem    */
DECL|method|addDependencyJars (Map<String, LocalResource> providerResources, SliderFileSystem sliderFileSystem, Path tempPath, String libdir, String[] resources, Class[] classes )
specifier|public
specifier|static
name|void
name|addDependencyJars
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|LocalResource
argument_list|>
name|providerResources
parameter_list|,
name|SliderFileSystem
name|sliderFileSystem
parameter_list|,
name|Path
name|tempPath
parameter_list|,
name|String
name|libdir
parameter_list|,
name|String
index|[]
name|resources
parameter_list|,
name|Class
index|[]
name|classes
parameter_list|)
throws|throws
name|IOException
throws|,
name|SliderException
block|{
if|if
condition|(
name|resources
operator|.
name|length
operator|!=
name|classes
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|SliderInternalStateException
argument_list|(
literal|"mismatch in Jar names [%d] and classes [%d]"
argument_list|,
name|resources
operator|.
name|length
argument_list|,
name|classes
operator|.
name|length
argument_list|)
throw|;
block|}
name|int
name|size
init|=
name|resources
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|String
name|jarName
init|=
name|resources
index|[
name|i
index|]
decl_stmt|;
name|Class
name|clazz
init|=
name|classes
index|[
name|i
index|]
decl_stmt|;
name|SliderUtils
operator|.
name|putJar
argument_list|(
name|providerResources
argument_list|,
name|sliderFileSystem
argument_list|,
name|clazz
argument_list|,
name|tempPath
argument_list|,
name|libdir
argument_list|,
name|jarName
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Loads all dependency jars from the default path    * @param providerResources map of provider resources to add these entries to    * @param sliderFileSystem target filesystem    * @param tempPath path in the cluster FS for temp files    * @param libDir relative directory to place resources    * @param libLocalSrcDir explicitly supplied local libs dir    * @throws IOException    * @throws SliderException    */
DECL|method|addAllDependencyJars (Map<String, LocalResource> providerResources, SliderFileSystem sliderFileSystem, Path tempPath, String libDir, String libLocalSrcDir)
specifier|public
specifier|static
name|void
name|addAllDependencyJars
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|LocalResource
argument_list|>
name|providerResources
parameter_list|,
name|SliderFileSystem
name|sliderFileSystem
parameter_list|,
name|Path
name|tempPath
parameter_list|,
name|String
name|libDir
parameter_list|,
name|String
name|libLocalSrcDir
parameter_list|)
throws|throws
name|IOException
throws|,
name|SliderException
block|{
name|String
name|libSrcToUse
init|=
name|libLocalSrcDir
decl_stmt|;
if|if
condition|(
name|SliderUtils
operator|.
name|isSet
argument_list|(
name|libLocalSrcDir
argument_list|)
condition|)
block|{
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|libLocalSrcDir
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
operator|||
operator|!
name|file
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"Supplied lib src dir %s is not valid"
argument_list|,
name|libLocalSrcDir
argument_list|)
throw|;
block|}
block|}
name|SliderUtils
operator|.
name|putAllJars
argument_list|(
name|providerResources
argument_list|,
name|sliderFileSystem
argument_list|,
name|tempPath
argument_list|,
name|libDir
argument_list|,
name|libSrcToUse
argument_list|)
expr_stmt|;
block|}
comment|/**    * build the log directory    * @return the log dir    */
DECL|method|getLogdir ()
specifier|public
name|String
name|getLogdir
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|logdir
init|=
name|System
operator|.
name|getenv
argument_list|(
literal|"LOGDIR"
argument_list|)
decl_stmt|;
if|if
condition|(
name|logdir
operator|==
literal|null
condition|)
block|{
name|logdir
operator|=
name|SliderKeys
operator|.
name|TMP_LOGDIR_PREFIX
operator|+
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
expr_stmt|;
block|}
return|return
name|logdir
return|;
block|}
DECL|method|validateNodeCount (AggregateConf instanceDescription, String name, int min, int max)
specifier|public
name|void
name|validateNodeCount
parameter_list|(
name|AggregateConf
name|instanceDescription
parameter_list|,
name|String
name|name
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
throws|throws
name|BadCommandArgumentsException
block|{
name|MapOperations
name|component
init|=
name|instanceDescription
operator|.
name|getResourceOperations
argument_list|()
operator|.
name|getComponent
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|component
operator|==
literal|null
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|count
operator|=
name|component
operator|.
name|getOptionInt
argument_list|(
name|ResourceKeys
operator|.
name|COMPONENT_INSTANCES
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|validateNodeCount
argument_list|(
name|name
argument_list|,
name|count
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
block|}
comment|/**    * Validate the node count and heap size values of a node class     *<p>    * If max&lt;= 0:  min&lt;= count    * If max&gt; 0:  min&lt;= count&lt;= max    * @param name node class name    * @param count requested node count    * @param min requested heap size    * @param max maximum value.     * @throws BadCommandArgumentsException if the values are out of range    */
DECL|method|validateNodeCount (String name, int count, int min, int max)
specifier|public
name|void
name|validateNodeCount
parameter_list|(
name|String
name|name
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|)
throws|throws
name|BadCommandArgumentsException
block|{
if|if
condition|(
name|count
operator|<
name|min
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"requested no of %s nodes: %d is below the minimum of %d"
argument_list|,
name|name
argument_list|,
name|count
argument_list|,
name|min
argument_list|)
throw|;
block|}
if|if
condition|(
name|max
operator|>
literal|0
operator|&&
name|count
operator|>
name|max
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"requested no of %s nodes: %d is above the maximum of %d"
argument_list|,
name|name
argument_list|,
name|count
argument_list|,
name|max
argument_list|)
throw|;
block|}
block|}
comment|/**    * copy all options beginning site. into the site.xml    * @param clusterSpec cluster specification    * @param sitexml map for XML file to build up    */
DECL|method|propagateSiteOptions (ClusterDescription clusterSpec, Map<String, String> sitexml)
specifier|public
name|void
name|propagateSiteOptions
parameter_list|(
name|ClusterDescription
name|clusterSpec
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|sitexml
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|options
init|=
name|clusterSpec
operator|.
name|options
decl_stmt|;
name|propagateSiteOptions
argument_list|(
name|options
argument_list|,
name|sitexml
argument_list|)
expr_stmt|;
block|}
DECL|method|propagateSiteOptions (Map<String, String> options, Map<String, String> sitexml)
specifier|public
name|void
name|propagateSiteOptions
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|options
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|sitexml
parameter_list|)
block|{
name|propagateSiteOptions
argument_list|(
name|options
argument_list|,
name|sitexml
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
DECL|method|propagateSiteOptions (Map<String, String> options, Map<String, String> sitexml, String configName)
specifier|public
name|void
name|propagateSiteOptions
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|options
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|sitexml
parameter_list|,
name|String
name|configName
parameter_list|)
block|{
name|propagateSiteOptions
argument_list|(
name|options
argument_list|,
name|sitexml
argument_list|,
name|configName
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|propagateSiteOptions (Map<String, String> options, Map<String, String> sitexml, String configName, Map<String,String> tokenMap)
specifier|public
name|void
name|propagateSiteOptions
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|options
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|sitexml
parameter_list|,
name|String
name|configName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|tokenMap
parameter_list|)
block|{
name|String
name|prefix
init|=
name|OptionKeys
operator|.
name|SITE_XML_PREFIX
operator|+
operator|(
operator|!
name|configName
operator|.
name|isEmpty
argument_list|()
condition|?
name|configName
operator|+
literal|"."
else|:
literal|""
operator|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|options
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
name|String
name|envName
init|=
name|key
operator|.
name|substring
argument_list|(
name|prefix
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|envName
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|String
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|tokenMap
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|token
range|:
name|tokenMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|value
operator|=
name|value
operator|.
name|replaceAll
argument_list|(
name|Pattern
operator|.
name|quote
argument_list|(
name|token
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
name|token
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|sitexml
operator|.
name|put
argument_list|(
name|envName
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Propagate an option from the cluster specification option map    * to the site XML map, using the site key for the name    * @param global global config spec    * @param optionKey key in the option map    * @param sitexml  map for XML file to build up    * @param siteKey key to assign the value to in the site XML    * @throws BadConfigException if the option is missing from the cluster spec    */
DECL|method|propagateOption (MapOperations global, String optionKey, Map<String, String> sitexml, String siteKey)
specifier|public
name|void
name|propagateOption
parameter_list|(
name|MapOperations
name|global
parameter_list|,
name|String
name|optionKey
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|sitexml
parameter_list|,
name|String
name|siteKey
parameter_list|)
throws|throws
name|BadConfigException
block|{
name|sitexml
operator|.
name|put
argument_list|(
name|siteKey
argument_list|,
name|global
operator|.
name|getMandatoryOption
argument_list|(
name|optionKey
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Build the image dir. This path is relative and only valid at the far end    * @param instanceDefinition instance definition    * @param bindir bin subdir    * @param script script in bin subdir    * @return the path to the script    * @throws FileNotFoundException if a file is not found, or it is not a directory*     */
DECL|method|buildPathToHomeDir (AggregateConf instanceDefinition, String bindir, String script)
specifier|public
name|String
name|buildPathToHomeDir
parameter_list|(
name|AggregateConf
name|instanceDefinition
parameter_list|,
name|String
name|bindir
parameter_list|,
name|String
name|script
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|BadConfigException
block|{
name|MapOperations
name|globalOptions
init|=
name|instanceDefinition
operator|.
name|getInternalOperations
argument_list|()
operator|.
name|getGlobalOptions
argument_list|()
decl_stmt|;
name|String
name|applicationHome
init|=
name|globalOptions
operator|.
name|get
argument_list|(
name|InternalKeys
operator|.
name|INTERNAL_APPLICATION_HOME
argument_list|)
decl_stmt|;
name|String
name|imagePath
init|=
name|globalOptions
operator|.
name|get
argument_list|(
name|InternalKeys
operator|.
name|INTERNAL_APPLICATION_IMAGE_PATH
argument_list|)
decl_stmt|;
return|return
name|buildPathToHomeDir
argument_list|(
name|imagePath
argument_list|,
name|applicationHome
argument_list|,
name|bindir
argument_list|,
name|script
argument_list|)
return|;
block|}
DECL|method|buildPathToHomeDir (String imagePath, String applicationHome, String bindir, String script)
specifier|public
name|String
name|buildPathToHomeDir
parameter_list|(
name|String
name|imagePath
parameter_list|,
name|String
name|applicationHome
parameter_list|,
name|String
name|bindir
parameter_list|,
name|String
name|script
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
name|String
name|path
decl_stmt|;
name|File
name|scriptFile
decl_stmt|;
if|if
condition|(
name|imagePath
operator|!=
literal|null
condition|)
block|{
name|File
name|tarball
init|=
operator|new
name|File
argument_list|(
name|SliderKeys
operator|.
name|LOCAL_TARBALL_INSTALL_SUBDIR
argument_list|)
decl_stmt|;
name|scriptFile
operator|=
name|findBinScriptInExpandedArchive
argument_list|(
name|tarball
argument_list|,
name|bindir
argument_list|,
name|script
argument_list|)
expr_stmt|;
comment|// now work back from the script to build the relative path
comment|// to the binary which will be valid remote or local
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|SliderKeys
operator|.
name|LOCAL_TARBALL_INSTALL_SUBDIR
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
comment|//for the script, we want the name of ../..
name|File
name|archive
init|=
name|scriptFile
operator|.
name|getParentFile
argument_list|()
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|archive
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|path
operator|=
name|builder
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// using a home directory which is required to be present on
comment|// the local system -so will be absolute and resolvable
name|File
name|homedir
init|=
operator|new
name|File
argument_list|(
name|applicationHome
argument_list|)
decl_stmt|;
name|path
operator|=
name|homedir
operator|.
name|getAbsolutePath
argument_list|()
expr_stmt|;
comment|//this is absolute, resolve its entire path
name|SliderUtils
operator|.
name|verifyIsDir
argument_list|(
name|homedir
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|File
name|bin
init|=
operator|new
name|File
argument_list|(
name|homedir
argument_list|,
name|bindir
argument_list|)
decl_stmt|;
name|SliderUtils
operator|.
name|verifyIsDir
argument_list|(
name|bin
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|scriptFile
operator|=
operator|new
name|File
argument_list|(
name|bin
argument_list|,
name|script
argument_list|)
expr_stmt|;
name|SliderUtils
operator|.
name|verifyFileExists
argument_list|(
name|scriptFile
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
return|return
name|path
return|;
block|}
comment|/**    * Build the image dir. This path is relative and only valid at the far end    * @param instance instance options    * @param bindir bin subdir    * @param script script in bin subdir    * @return the path to the script    * @throws FileNotFoundException if a file is not found, or it is not a directory*     */
DECL|method|buildPathToScript (AggregateConf instance, String bindir, String script)
specifier|public
name|String
name|buildPathToScript
parameter_list|(
name|AggregateConf
name|instance
parameter_list|,
name|String
name|bindir
parameter_list|,
name|String
name|script
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
return|return
name|buildPathToScript
argument_list|(
name|instance
operator|.
name|getInternalOperations
argument_list|()
argument_list|,
name|bindir
argument_list|,
name|script
argument_list|)
return|;
block|}
comment|/**    * Build the image dir. This path is relative and only valid at the far end    * @param internal internal options    * @param bindir bin subdir    * @param script script in bin subdir    * @return the path to the script    * @throws FileNotFoundException if a file is not found, or it is not a directory*     */
DECL|method|buildPathToScript (ConfTreeOperations internal, String bindir, String script)
specifier|public
name|String
name|buildPathToScript
parameter_list|(
name|ConfTreeOperations
name|internal
parameter_list|,
name|String
name|bindir
parameter_list|,
name|String
name|script
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
name|String
name|homedir
init|=
name|buildPathToHomeDir
argument_list|(
name|internal
operator|.
name|get
argument_list|(
name|InternalKeys
operator|.
name|INTERNAL_APPLICATION_IMAGE_PATH
argument_list|)
argument_list|,
name|internal
operator|.
name|get
argument_list|(
name|InternalKeys
operator|.
name|INTERNAL_APPLICATION_HOME
argument_list|)
argument_list|,
name|bindir
argument_list|,
name|script
argument_list|)
decl_stmt|;
return|return
name|buildScriptPath
argument_list|(
name|bindir
argument_list|,
name|script
argument_list|,
name|homedir
argument_list|)
return|;
block|}
DECL|method|buildScriptPath (String bindir, String script, String homedir)
specifier|public
name|String
name|buildScriptPath
parameter_list|(
name|String
name|bindir
parameter_list|,
name|String
name|script
parameter_list|,
name|String
name|homedir
parameter_list|)
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
name|homedir
argument_list|)
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|bindir
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|script
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|convertToAppRelativePath (File file)
specifier|public
specifier|static
name|String
name|convertToAppRelativePath
parameter_list|(
name|File
name|file
parameter_list|)
block|{
return|return
name|convertToAppRelativePath
argument_list|(
name|file
operator|.
name|getPath
argument_list|()
argument_list|)
return|;
block|}
DECL|method|convertToAppRelativePath (String path)
specifier|public
specifier|static
name|String
name|convertToAppRelativePath
parameter_list|(
name|String
name|path
parameter_list|)
block|{
return|return
name|ApplicationConstants
operator|.
name|Environment
operator|.
name|PWD
operator|.
name|$
argument_list|()
operator|+
literal|"/"
operator|+
name|path
return|;
block|}
DECL|method|validatePathReferencesLocalDir (String meaning, String path)
specifier|public
specifier|static
name|void
name|validatePathReferencesLocalDir
parameter_list|(
name|String
name|meaning
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|BadConfigException
block|{
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|BadConfigException
argument_list|(
literal|"%s directory %s not found"
argument_list|,
name|meaning
argument_list|,
name|file
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|file
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|BadConfigException
argument_list|(
literal|"%s is not a directory: %s"
argument_list|,
name|meaning
argument_list|,
name|file
argument_list|)
throw|;
block|}
block|}
comment|/**    * get the user name    * @return the user name    */
DECL|method|getUserName ()
specifier|public
name|String
name|getUserName
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
return|;
block|}
comment|/**    * Find a script in an expanded archive    * @param base base directory    * @param bindir bin subdir    * @param script script in bin subdir    * @return the path to the script    * @throws FileNotFoundException if a file is not found, or it is not a directory    */
DECL|method|findBinScriptInExpandedArchive (File base, String bindir, String script)
specifier|public
name|File
name|findBinScriptInExpandedArchive
parameter_list|(
name|File
name|base
parameter_list|,
name|String
name|bindir
parameter_list|,
name|String
name|script
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
name|SliderUtils
operator|.
name|verifyIsDir
argument_list|(
name|base
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|File
index|[]
name|ls
init|=
name|base
operator|.
name|listFiles
argument_list|()
decl_stmt|;
if|if
condition|(
name|ls
operator|==
literal|null
condition|)
block|{
comment|//here for the IDE to be happy, as the previous check will pick this case
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Failed to list directory "
operator|+
name|base
argument_list|)
throw|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"Found {} entries in {}"
argument_list|,
name|ls
operator|.
name|length
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|File
argument_list|>
name|directories
init|=
operator|new
name|LinkedList
argument_list|<
name|File
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|dirs
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|File
name|file
range|:
name|ls
control|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"{}"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|directories
operator|.
name|add
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|dirs
operator|.
name|append
argument_list|(
name|file
operator|.
name|getPath
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|directories
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Too many directories in archive to identify binary: "
operator|+
name|dirs
argument_list|)
throw|;
block|}
if|if
condition|(
name|directories
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"No directory found in archive "
operator|+
name|base
argument_list|)
throw|;
block|}
name|File
name|archive
init|=
name|directories
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|File
name|bin
init|=
operator|new
name|File
argument_list|(
name|archive
argument_list|,
name|bindir
argument_list|)
decl_stmt|;
name|SliderUtils
operator|.
name|verifyIsDir
argument_list|(
name|bin
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|File
name|scriptFile
init|=
operator|new
name|File
argument_list|(
name|bin
argument_list|,
name|script
argument_list|)
decl_stmt|;
name|SliderUtils
operator|.
name|verifyFileExists
argument_list|(
name|scriptFile
argument_list|,
name|log
argument_list|)
expr_stmt|;
return|return
name|scriptFile
return|;
block|}
comment|/**    * Return any additional arguments (argv) to provide when starting this role    *     * @param roleOptions    *          The options for this role    * @return A non-null String which contains command line arguments for this role, or the empty string.    */
DECL|method|getAdditionalArgs (Map<String,String> roleOptions)
specifier|public
specifier|static
name|String
name|getAdditionalArgs
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|roleOptions
parameter_list|)
block|{
if|if
condition|(
name|roleOptions
operator|.
name|containsKey
argument_list|(
name|RoleKeys
operator|.
name|ROLE_ADDITIONAL_ARGS
argument_list|)
condition|)
block|{
name|String
name|additionalArgs
init|=
name|roleOptions
operator|.
name|get
argument_list|(
name|RoleKeys
operator|.
name|ROLE_ADDITIONAL_ARGS
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|additionalArgs
condition|)
block|{
return|return
name|additionalArgs
return|;
block|}
block|}
return|return
literal|""
return|;
block|}
DECL|method|getRoleResourceRequirement (String val, int defVal, int maxVal)
specifier|public
name|int
name|getRoleResourceRequirement
parameter_list|(
name|String
name|val
parameter_list|,
name|int
name|defVal
parameter_list|,
name|int
name|maxVal
parameter_list|)
block|{
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
name|val
operator|=
name|Integer
operator|.
name|toString
argument_list|(
name|defVal
argument_list|)
expr_stmt|;
block|}
name|Integer
name|intVal
decl_stmt|;
if|if
condition|(
name|ResourceKeys
operator|.
name|YARN_RESOURCE_MAX
operator|.
name|equals
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|intVal
operator|=
name|maxVal
expr_stmt|;
block|}
else|else
block|{
name|intVal
operator|=
name|Integer
operator|.
name|decode
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|intVal
return|;
block|}
block|}
end_class

end_unit

