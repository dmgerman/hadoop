begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *       http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.slider.api
package|package
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|types
operator|.
name|ApplicationLivenessInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|SliderUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|BadConfigException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|providers
operator|.
name|SliderProviderFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|JsonGenerationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|JsonParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|annotate
operator|.
name|JsonIgnore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|annotate
operator|.
name|JsonIgnoreProperties
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|map
operator|.
name|JsonMappingException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|map
operator|.
name|ObjectMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|map
operator|.
name|SerializationConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|map
operator|.
name|annotate
operator|.
name|JsonSerialize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|OptionKeys
operator|.
name|INTERNAL_APPLICATION_HOME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|OptionKeys
operator|.
name|INTERNAL_APPLICATION_IMAGE_PATH
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|OptionKeys
operator|.
name|ZOOKEEPER_PATH
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|OptionKeys
operator|.
name|ZOOKEEPER_QUORUM
import|;
end_import

begin_comment
comment|/**  * Represents a cluster specification; designed to be sendable over the wire  * and persisted in JSON by way of Jackson.  *   * When used in cluster status operations the<code>info</code>  * and<code>statistics</code> maps contain information about the cluster.  *   * As a wire format it is less efficient in both xfer and ser/deser than   * a binary format, but by having one unified format for wire and persistence,  * the code paths are simplified.  *  * This was the original single-file specification/model used in the Hoya  * precursor to Slider. Its now retained primarily as a way to publish  * the current state of the application, or at least a fraction thereof ...  * the larger set of information from the REST API is beyond the scope of  * this structure.  */
end_comment

begin_class
annotation|@
name|JsonIgnoreProperties
argument_list|(
name|ignoreUnknown
operator|=
literal|true
argument_list|)
annotation|@
name|JsonSerialize
argument_list|(
name|include
operator|=
name|JsonSerialize
operator|.
name|Inclusion
operator|.
name|NON_NULL
argument_list|)
DECL|class|ClusterDescription
specifier|public
class|class
name|ClusterDescription
implements|implements
name|Cloneable
block|{
specifier|protected
specifier|static
specifier|final
name|Logger
DECL|field|log
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ClusterDescription
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|UTF_8
specifier|private
specifier|static
specifier|final
name|String
name|UTF_8
init|=
literal|"UTF-8"
decl_stmt|;
comment|/**    * version counter    */
DECL|field|version
specifier|public
name|String
name|version
init|=
literal|"1.0"
decl_stmt|;
comment|/**    * Name of the cluster    */
DECL|field|name
specifier|public
name|String
name|name
decl_stmt|;
comment|/**    * Type of cluster    */
DECL|field|type
specifier|public
name|String
name|type
init|=
name|SliderProviderFactory
operator|.
name|DEFAULT_CLUSTER_TYPE
decl_stmt|;
comment|/**    * State of the cluster    */
DECL|field|state
specifier|public
name|int
name|state
decl_stmt|;
comment|/*    State list for both clusters and nodes in them. Ordered so that destroyed follows    stopped.        Some of the states are only used for recording    the persistent state of the cluster and are not    seen in node descriptions    */
comment|/**    * Specification is incomplete& cannot    * be used: {@value}    */
DECL|field|STATE_INCOMPLETE
specifier|public
specifier|static
specifier|final
name|int
name|STATE_INCOMPLETE
init|=
name|StateValues
operator|.
name|STATE_INCOMPLETE
decl_stmt|;
comment|/**    * Spec has been submitted: {@value}    */
DECL|field|STATE_SUBMITTED
specifier|public
specifier|static
specifier|final
name|int
name|STATE_SUBMITTED
init|=
name|StateValues
operator|.
name|STATE_SUBMITTED
decl_stmt|;
comment|/**    * Cluster created: {@value}    */
DECL|field|STATE_CREATED
specifier|public
specifier|static
specifier|final
name|int
name|STATE_CREATED
init|=
name|StateValues
operator|.
name|STATE_CREATED
decl_stmt|;
comment|/**    * Live: {@value}    */
DECL|field|STATE_LIVE
specifier|public
specifier|static
specifier|final
name|int
name|STATE_LIVE
init|=
name|StateValues
operator|.
name|STATE_LIVE
decl_stmt|;
comment|/**    * Stopped    */
DECL|field|STATE_STOPPED
specifier|public
specifier|static
specifier|final
name|int
name|STATE_STOPPED
init|=
name|StateValues
operator|.
name|STATE_STOPPED
decl_stmt|;
comment|/**    * destroyed    */
DECL|field|STATE_DESTROYED
specifier|public
specifier|static
specifier|final
name|int
name|STATE_DESTROYED
init|=
name|StateValues
operator|.
name|STATE_DESTROYED
decl_stmt|;
comment|/**    * When was the cluster specification created?    * This is not the time a cluster was thawed; that will    * be in the<code>info</code> section.    */
DECL|field|createTime
specifier|public
name|long
name|createTime
decl_stmt|;
comment|/**    * When was the cluster specification last updated    */
DECL|field|updateTime
specifier|public
name|long
name|updateTime
decl_stmt|;
comment|/**    * URL path to the original configuration    * files; these are re-read when     * restoring a cluster    */
DECL|field|originConfigurationPath
specifier|public
name|String
name|originConfigurationPath
decl_stmt|;
comment|/**    * URL path to the generated configuration    */
DECL|field|generatedConfigurationPath
specifier|public
name|String
name|generatedConfigurationPath
decl_stmt|;
comment|/**    * This is where the data goes    */
DECL|field|dataPath
specifier|public
name|String
name|dataPath
decl_stmt|;
comment|/**    * cluster-specific options -to control both    * the Slider AM and the application that it deploys    */
DECL|field|options
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|options
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * cluster information    * This is only valid when querying the cluster status.    */
DECL|field|info
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|info
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Statistics. This is only relevant when querying the cluster status    */
DECL|field|statistics
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|statistics
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Instances: role->count    */
DECL|field|instances
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|instances
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Role options,     * role -> option -> value    */
DECL|field|roles
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|roles
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * List of key-value pairs to add to a client config to set up the client    */
DECL|field|clientProperties
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|clientProperties
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Status information    */
DECL|field|status
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|status
decl_stmt|;
comment|/**    * Liveness information; the same as returned    * on the<code>live/liveness/</code> URL    */
DECL|field|liveness
specifier|public
name|ApplicationLivenessInformation
name|liveness
decl_stmt|;
comment|/**    * Creator.    */
DECL|method|ClusterDescription ()
specifier|public
name|ClusterDescription
parameter_list|()
block|{   }
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
try|try
block|{
return|return
name|toJsonString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Failed to convert CD to JSON "
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|super
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Shallow clone    * @return a shallow clone    * @throws CloneNotSupportedException    */
annotation|@
name|Override
DECL|method|clone ()
specifier|public
name|Object
name|clone
parameter_list|()
throws|throws
name|CloneNotSupportedException
block|{
return|return
name|super
operator|.
name|clone
argument_list|()
return|;
block|}
comment|/**    * A deep clone of the spec. This is done inefficiently with a ser/derser    * @return the cluster description    */
DECL|method|deepClone ()
specifier|public
name|ClusterDescription
name|deepClone
parameter_list|()
block|{
try|try
block|{
return|return
name|fromJson
argument_list|(
name|toJsonString
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Save a cluster description to a hadoop filesystem    * @param fs filesystem    * @param path path    * @param overwrite should any existing file be overwritten    * @throws IOException IO exception    */
DECL|method|save (FileSystem fs, Path path, boolean overwrite)
specifier|public
name|void
name|save
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|boolean
name|overwrite
parameter_list|)
throws|throws
name|IOException
block|{
name|FSDataOutputStream
name|dataOutputStream
init|=
name|fs
operator|.
name|create
argument_list|(
name|path
argument_list|,
name|overwrite
argument_list|)
decl_stmt|;
name|writeJsonAsBytes
argument_list|(
name|dataOutputStream
argument_list|)
expr_stmt|;
block|}
comment|/**    * Save a cluster description to the local filesystem    * @param file file    * @throws IOException IO excpetion    */
DECL|method|save (File file)
specifier|public
name|void
name|save
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Saving to {}"
argument_list|,
name|file
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|getParentFile
argument_list|()
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Failed to mkdirs for {}"
argument_list|,
name|file
operator|.
name|getParentFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|DataOutputStream
name|dataOutputStream
init|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|file
argument_list|)
argument_list|)
decl_stmt|;
name|writeJsonAsBytes
argument_list|(
name|dataOutputStream
argument_list|)
expr_stmt|;
block|}
comment|/**    * Write the json as bytes -then close the file    * @param dataOutputStream an outout stream that will always be closed    * @throws IOException any failure    */
DECL|method|writeJsonAsBytes (DataOutputStream dataOutputStream)
specifier|private
name|void
name|writeJsonAsBytes
parameter_list|(
name|DataOutputStream
name|dataOutputStream
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|String
name|json
init|=
name|toJsonString
argument_list|()
decl_stmt|;
name|byte
index|[]
name|b
init|=
name|json
operator|.
name|getBytes
argument_list|(
name|UTF_8
argument_list|)
decl_stmt|;
name|dataOutputStream
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|dataOutputStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Load from the filesystem    * @param fs filesystem    * @param path path    * @return a loaded CD    * @throws IOException IO problems    */
DECL|method|load (FileSystem fs, Path path)
specifier|public
specifier|static
name|ClusterDescription
name|load
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
throws|,
name|JsonParseException
throws|,
name|JsonMappingException
block|{
name|FileStatus
name|status
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|byte
index|[]
name|b
init|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|status
operator|.
name|getLen
argument_list|()
index|]
decl_stmt|;
name|FSDataInputStream
name|dataInputStream
init|=
name|fs
operator|.
name|open
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|int
name|count
init|=
name|dataInputStream
operator|.
name|read
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|String
name|json
init|=
operator|new
name|String
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|count
argument_list|,
name|UTF_8
argument_list|)
decl_stmt|;
return|return
name|fromJson
argument_list|(
name|json
argument_list|)
return|;
block|}
comment|/**    * Make a deep copy of the class    * @param source source    * @return the copy    */
DECL|method|copy (ClusterDescription source)
specifier|public
specifier|static
name|ClusterDescription
name|copy
parameter_list|(
name|ClusterDescription
name|source
parameter_list|)
block|{
comment|//currently the copy is done by a generate/save. Inefficient but it goes
comment|//down the tree nicely
try|try
block|{
return|return
name|fromJson
argument_list|(
name|source
operator|.
name|toJsonString
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"ClusterDescription copy failed "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Convert to a JSON string    * @return a JSON string description    * @throws IOException Problems mapping/writing the object    */
DECL|method|toJsonString ()
specifier|public
name|String
name|toJsonString
parameter_list|()
throws|throws
name|IOException
throws|,
name|JsonGenerationException
throws|,
name|JsonMappingException
block|{
name|ObjectMapper
name|mapper
init|=
operator|new
name|ObjectMapper
argument_list|()
decl_stmt|;
name|mapper
operator|.
name|configure
argument_list|(
name|SerializationConfig
operator|.
name|Feature
operator|.
name|INDENT_OUTPUT
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|mapper
operator|.
name|writeValueAsString
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * Convert from JSON    * @param json input    * @return the parsed JSON    * @throws IOException IO    * @throws JsonMappingException failure to map from the JSON to this class    */
DECL|method|fromJson (String json)
specifier|public
specifier|static
name|ClusterDescription
name|fromJson
parameter_list|(
name|String
name|json
parameter_list|)
throws|throws
name|IOException
throws|,
name|JsonParseException
throws|,
name|JsonMappingException
block|{
name|ObjectMapper
name|mapper
init|=
operator|new
name|ObjectMapper
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|mapper
operator|.
name|readValue
argument_list|(
name|json
argument_list|,
name|ClusterDescription
operator|.
name|class
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Exception while parsing json : "
operator|+
name|e
operator|+
literal|"\n"
operator|+
name|json
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**      * Convert from input stream      * @param is input stream of cluster description      * @return the parsed JSON      * @throws IOException IO      * @throws JsonMappingException failure to map from the JSON to this class      */
DECL|method|fromStream (InputStream is)
specifier|public
specifier|static
name|ClusterDescription
name|fromStream
parameter_list|(
name|InputStream
name|is
parameter_list|)
throws|throws
name|IOException
throws|,
name|JsonParseException
throws|,
name|JsonMappingException
block|{
if|if
condition|(
name|is
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Empty Stream"
argument_list|)
throw|;
block|}
name|ObjectMapper
name|mapper
init|=
operator|new
name|ObjectMapper
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|mapper
operator|.
name|readValue
argument_list|(
name|is
argument_list|,
name|ClusterDescription
operator|.
name|class
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Exception while parsing input stream : {}"
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Convert from a JSON file    * @param jsonFile input file    * @return the parsed JSON    * @throws IOException IO problems    * @throws JsonMappingException failure to map from the JSON to this class    */
DECL|method|fromFile (File jsonFile)
specifier|public
specifier|static
name|ClusterDescription
name|fromFile
parameter_list|(
name|File
name|jsonFile
parameter_list|)
throws|throws
name|IOException
throws|,
name|JsonParseException
throws|,
name|JsonMappingException
block|{
name|ObjectMapper
name|mapper
init|=
operator|new
name|ObjectMapper
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|mapper
operator|.
name|readValue
argument_list|(
name|jsonFile
argument_list|,
name|ClusterDescription
operator|.
name|class
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Exception while parsing json file {}"
argument_list|,
name|jsonFile
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Set a cluster option: a key val pair in the options {} section    * @param key key option name    * @param val value option value    */
DECL|method|setOption (String key, String val)
specifier|public
name|void
name|setOption
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|val
parameter_list|)
block|{
name|options
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set a cluster option if it is unset. If it is already set,    * in the Cluster Description, it is left alone    * @param key key key to query/set    * @param val value value    */
DECL|method|setOptionifUnset (String key, String val)
specifier|public
name|void
name|setOptionifUnset
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|val
parameter_list|)
block|{
if|if
condition|(
name|options
operator|.
name|get
argument_list|(
name|key
argument_list|)
operator|==
literal|null
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set an integer option -it's converted to a string before saving    * @param option option name    * @param val integer value    */
DECL|method|setOption (String option, int val)
specifier|public
name|void
name|setOption
parameter_list|(
name|String
name|option
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|setOption
argument_list|(
name|option
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set a boolean option    * @param option option name    * @param val bool value    */
DECL|method|setOption (String option, boolean val)
specifier|public
name|void
name|setOption
parameter_list|(
name|String
name|option
parameter_list|,
name|boolean
name|val
parameter_list|)
block|{
name|setOption
argument_list|(
name|option
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get a cluster option or value    *    * @param key option key    * @param defVal option val    * @return resolved value or default    */
DECL|method|getOption (String key, String defVal)
specifier|public
name|String
name|getOption
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|defVal
parameter_list|)
block|{
name|String
name|val
init|=
name|options
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|val
operator|!=
literal|null
condition|?
name|val
else|:
name|defVal
return|;
block|}
comment|/**    * Get a cluster option or value    *    * @param key mandatory key    * @return the value    * @throws BadConfigException if the option is missing    */
DECL|method|getMandatoryOption (String key)
specifier|public
name|String
name|getMandatoryOption
parameter_list|(
name|String
name|key
parameter_list|)
throws|throws
name|BadConfigException
block|{
name|String
name|val
init|=
name|options
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|BadConfigException
argument_list|(
literal|"Missing option "
operator|+
name|key
argument_list|)
throw|;
block|}
return|return
name|val
return|;
block|}
comment|/**    * Get an integer option; use {@link Integer#decode(String)} so as to take hex    * oct and bin values too.    *    * @param option option name    * @param defVal default value    * @return parsed value    * @throws NumberFormatException if the role could not be parsed.    */
DECL|method|getOptionInt (String option, int defVal)
specifier|public
name|int
name|getOptionInt
parameter_list|(
name|String
name|option
parameter_list|,
name|int
name|defVal
parameter_list|)
block|{
name|String
name|val
init|=
name|getOption
argument_list|(
name|option
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|defVal
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|Integer
operator|.
name|decode
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|/**    * Verify that an option is set: that is defined AND non-empty    * @param key key to verify    * @throws BadConfigException    */
DECL|method|verifyOptionSet (String key)
specifier|public
name|void
name|verifyOptionSet
parameter_list|(
name|String
name|key
parameter_list|)
throws|throws
name|BadConfigException
block|{
if|if
condition|(
name|SliderUtils
operator|.
name|isUnset
argument_list|(
name|getOption
argument_list|(
name|key
argument_list|,
literal|null
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BadConfigException
argument_list|(
literal|"Unset cluster option %s"
argument_list|,
name|key
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get an option as a boolean. Note that {@link Boolean#valueOf(String)}    * is used for parsing -its policy of what is true vs false applies.    * @param option name    * @param defVal default    * @return the option.    */
DECL|method|getOptionBool (String option, boolean defVal)
specifier|public
name|boolean
name|getOptionBool
parameter_list|(
name|String
name|option
parameter_list|,
name|boolean
name|defVal
parameter_list|)
block|{
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|getOption
argument_list|(
name|option
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|defVal
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get a role option    * @param role role to get from    * @param option option name    * @param defVal default value    * @return resolved value    */
DECL|method|getRoleOpt (String role, String option, String defVal)
specifier|public
name|String
name|getRoleOpt
parameter_list|(
name|String
name|role
parameter_list|,
name|String
name|option
parameter_list|,
name|String
name|defVal
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|roleopts
init|=
name|getRole
argument_list|(
name|role
argument_list|)
decl_stmt|;
if|if
condition|(
name|roleopts
operator|==
literal|null
condition|)
block|{
return|return
name|defVal
return|;
block|}
name|String
name|val
init|=
name|roleopts
operator|.
name|get
argument_list|(
name|option
argument_list|)
decl_stmt|;
return|return
name|val
operator|!=
literal|null
condition|?
name|val
else|:
name|defVal
return|;
block|}
comment|/**    * Get a mandatory role option    * @param role role to get from    * @param option option name    * @return resolved value    * @throws BadConfigException if the option is not defined    */
DECL|method|getMandatoryRoleOpt (String role, String option)
specifier|public
name|String
name|getMandatoryRoleOpt
parameter_list|(
name|String
name|role
parameter_list|,
name|String
name|option
parameter_list|)
throws|throws
name|BadConfigException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|roleopts
init|=
name|getRole
argument_list|(
name|role
argument_list|)
decl_stmt|;
if|if
condition|(
name|roleopts
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|BadConfigException
argument_list|(
literal|"Missing role %s "
argument_list|,
name|role
argument_list|)
throw|;
block|}
name|String
name|val
init|=
name|roleopts
operator|.
name|get
argument_list|(
name|option
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|BadConfigException
argument_list|(
literal|"Missing option '%s' in role %s "
argument_list|,
name|option
argument_list|,
name|role
argument_list|)
throw|;
block|}
return|return
name|val
return|;
block|}
comment|/**    * Get a mandatory integer role option    * @param role role to get from    * @param option option name    * @return resolved value    * @throws BadConfigException if the option is not defined    */
DECL|method|getMandatoryRoleOptInt (String role, String option)
specifier|public
name|int
name|getMandatoryRoleOptInt
parameter_list|(
name|String
name|role
parameter_list|,
name|String
name|option
parameter_list|)
throws|throws
name|BadConfigException
block|{
name|getMandatoryRoleOpt
argument_list|(
name|role
argument_list|,
name|option
argument_list|)
expr_stmt|;
return|return
name|getRoleOptInt
argument_list|(
name|role
argument_list|,
name|option
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * look up a role and return its options    * @param role role    * @return role mapping or null    */
DECL|method|getRole (String role)
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getRole
parameter_list|(
name|String
name|role
parameter_list|)
block|{
return|return
name|roles
operator|.
name|get
argument_list|(
name|role
argument_list|)
return|;
block|}
comment|/**    * Get a role -adding it to the roleopts map if    * none with that name exists    * @param role role    * @return role mapping    */
DECL|method|getOrAddRole (String role)
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getOrAddRole
parameter_list|(
name|String
name|role
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
init|=
name|getRole
argument_list|(
name|role
argument_list|)
decl_stmt|;
if|if
condition|(
name|map
operator|==
literal|null
condition|)
block|{
name|map
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|roles
operator|.
name|put
argument_list|(
name|role
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
name|map
return|;
block|}
comment|/*    * return the Set of role names    */
annotation|@
name|JsonIgnore
DECL|method|getRoleNames ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getRoleNames
parameter_list|()
block|{
return|return
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|roles
operator|.
name|keySet
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get a role whose presence is mandatory    * @param role role name    * @return the mapping    * @throws BadConfigException if the role is not there    */
DECL|method|getMandatoryRole (String role)
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getMandatoryRole
parameter_list|(
name|String
name|role
parameter_list|)
throws|throws
name|BadConfigException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|roleOptions
init|=
name|getRole
argument_list|(
name|role
argument_list|)
decl_stmt|;
if|if
condition|(
name|roleOptions
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|BadConfigException
argument_list|(
literal|"Missing role "
operator|+
name|role
argument_list|)
throw|;
block|}
return|return
name|roleOptions
return|;
block|}
comment|/**    * Get an integer role option; use {@link Integer#decode(String)} so as to take hex    * oct and bin values too.    *    * @param role role to get from    * @param option option name    * @param defVal default value    * @return parsed value    * @throws NumberFormatException if the role could not be parsed.    */
DECL|method|getRoleOptInt (String role, String option, int defVal)
specifier|public
name|int
name|getRoleOptInt
parameter_list|(
name|String
name|role
parameter_list|,
name|String
name|option
parameter_list|,
name|int
name|defVal
parameter_list|)
block|{
name|String
name|val
init|=
name|getRoleOpt
argument_list|(
name|role
argument_list|,
name|option
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|defVal
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|Integer
operator|.
name|decode
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|/**    * Get an integer role option; use {@link Integer#decode(String)} so as to take hex    * oct and bin values too.    *    * @param role role to get from    * @param option option name    * @param defVal default value    * @return parsed value    * @throws NumberFormatException if the role could not be parsed.    */
DECL|method|getRoleOptLong (String role, String option, long defVal)
specifier|public
name|long
name|getRoleOptLong
parameter_list|(
name|String
name|role
parameter_list|,
name|String
name|option
parameter_list|,
name|long
name|defVal
parameter_list|)
block|{
name|String
name|val
init|=
name|getRoleOpt
argument_list|(
name|role
argument_list|,
name|option
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|defVal
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|Long
operator|.
name|decode
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|/**    * Set a role option, creating the role if necessary    * @param role role name    * @param option option name    * @param val value    */
DECL|method|setRoleOpt (String role, String option, String val)
specifier|public
name|void
name|setRoleOpt
parameter_list|(
name|String
name|role
parameter_list|,
name|String
name|option
parameter_list|,
name|String
name|val
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|roleopts
init|=
name|getOrAddRole
argument_list|(
name|role
argument_list|)
decl_stmt|;
name|roleopts
operator|.
name|put
argument_list|(
name|option
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set an integer role option, creating the role if necessary    * @param role role name    * @param option option name    * @param val integer value    */
DECL|method|setRoleOpt (String role, String option, int val)
specifier|public
name|void
name|setRoleOpt
parameter_list|(
name|String
name|role
parameter_list|,
name|String
name|option
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|setRoleOpt
argument_list|(
name|role
argument_list|,
name|option
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set a role option of any object, using its string value.    * This works for (Boxed) numeric values as well as other objects    * @param role role name    * @param option option name    * @param val non-null value    */
DECL|method|setRoleOpt (String role, String option, Object val)
specifier|public
name|void
name|setRoleOpt
parameter_list|(
name|String
name|role
parameter_list|,
name|String
name|option
parameter_list|,
name|Object
name|val
parameter_list|)
block|{
name|setRoleOpt
argument_list|(
name|role
argument_list|,
name|option
argument_list|,
name|val
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the value of a role requirement (cores, RAM, etc).    * These are returned as integers, but there is special handling of the     * string {@link ResourceKeys#YARN_RESOURCE_MAX}, which triggers    * the return of the maximum value.    * @param role role to get from    * @param option option name    * @param defVal default value    * @param maxVal value to return if the max val is requested    * @return parsed value    * @throws NumberFormatException if the role could not be parsed.    */
DECL|method|getRoleResourceRequirement (String role, String option, int defVal, int maxVal)
specifier|public
name|int
name|getRoleResourceRequirement
parameter_list|(
name|String
name|role
parameter_list|,
name|String
name|option
parameter_list|,
name|int
name|defVal
parameter_list|,
name|int
name|maxVal
parameter_list|)
block|{
name|String
name|val
init|=
name|getRoleOpt
argument_list|(
name|role
argument_list|,
name|option
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|defVal
argument_list|)
argument_list|)
decl_stmt|;
name|Integer
name|intVal
decl_stmt|;
if|if
condition|(
name|ResourceKeys
operator|.
name|YARN_RESOURCE_MAX
operator|.
name|equals
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|intVal
operator|=
name|maxVal
expr_stmt|;
block|}
else|else
block|{
name|intVal
operator|=
name|Integer
operator|.
name|decode
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|intVal
return|;
block|}
comment|/**    * Set the time for an information (human, machine) timestamp pair of fields.    * The human time is the time in millis converted via the {@link Date} class.    * @param keyHumanTime name of human time key    * @param keyMachineTime name of machine time    * @param time timestamp    */
DECL|method|setInfoTime (String keyHumanTime, String keyMachineTime, long time)
specifier|public
name|void
name|setInfoTime
parameter_list|(
name|String
name|keyHumanTime
parameter_list|,
name|String
name|keyMachineTime
parameter_list|,
name|long
name|time
parameter_list|)
block|{
name|SliderUtils
operator|.
name|setInfoTime
argument_list|(
name|info
argument_list|,
name|keyHumanTime
argument_list|,
name|keyMachineTime
argument_list|,
name|time
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set an information string. This is content that is only valid in status    * reports.    * @param key key    * @param value string value    */
annotation|@
name|JsonIgnore
DECL|method|setInfo (String key, String value)
specifier|public
name|void
name|setInfo
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|value
parameter_list|)
block|{
name|info
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get an information string. This is content that is only valid in status    * reports.    * @param key key    * @return the value or null    */
annotation|@
name|JsonIgnore
DECL|method|getInfo (String key)
specifier|public
name|String
name|getInfo
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
name|info
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/**    * Get an information string. This is content that is only valid in status    * reports.    * @param key key    * @return the value or null    */
annotation|@
name|JsonIgnore
DECL|method|getInfoBool (String key)
specifier|public
name|boolean
name|getInfoBool
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|String
name|val
init|=
name|info
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|!=
literal|null
condition|)
block|{
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|val
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|JsonIgnore
DECL|method|getZkHosts ()
specifier|public
name|String
name|getZkHosts
parameter_list|()
throws|throws
name|BadConfigException
block|{
return|return
name|getMandatoryOption
argument_list|(
name|ZOOKEEPER_QUORUM
argument_list|)
return|;
block|}
comment|/**    * Set the hosts for the ZK quorum    * @param zkHosts a comma separated list of hosts    */
annotation|@
name|JsonIgnore
DECL|method|setZkHosts (String zkHosts)
specifier|public
name|void
name|setZkHosts
parameter_list|(
name|String
name|zkHosts
parameter_list|)
block|{
name|setOption
argument_list|(
name|ZOOKEEPER_QUORUM
argument_list|,
name|zkHosts
argument_list|)
expr_stmt|;
block|}
annotation|@
name|JsonIgnore
DECL|method|getZkPath ()
specifier|public
name|String
name|getZkPath
parameter_list|()
throws|throws
name|BadConfigException
block|{
return|return
name|getMandatoryOption
argument_list|(
name|ZOOKEEPER_PATH
argument_list|)
return|;
block|}
annotation|@
name|JsonIgnore
DECL|method|setZkPath (String zkPath)
specifier|public
name|void
name|setZkPath
parameter_list|(
name|String
name|zkPath
parameter_list|)
block|{
name|setOption
argument_list|(
name|ZOOKEEPER_PATH
argument_list|,
name|zkPath
argument_list|)
expr_stmt|;
block|}
comment|/**    * HBase home: if non-empty defines where a copy of HBase is preinstalled    */
annotation|@
name|JsonIgnore
DECL|method|getApplicationHome ()
specifier|public
name|String
name|getApplicationHome
parameter_list|()
block|{
return|return
name|getOption
argument_list|(
name|INTERNAL_APPLICATION_HOME
argument_list|,
literal|""
argument_list|)
return|;
block|}
annotation|@
name|JsonIgnore
DECL|method|setApplicationHome (String applicationHome)
specifier|public
name|void
name|setApplicationHome
parameter_list|(
name|String
name|applicationHome
parameter_list|)
block|{
name|setOption
argument_list|(
name|INTERNAL_APPLICATION_HOME
argument_list|,
name|applicationHome
argument_list|)
expr_stmt|;
block|}
comment|/**    * The path in HDFS where the HBase image is    */
annotation|@
name|JsonIgnore
DECL|method|getImagePath ()
specifier|public
name|String
name|getImagePath
parameter_list|()
block|{
return|return
name|getOption
argument_list|(
name|INTERNAL_APPLICATION_IMAGE_PATH
argument_list|,
literal|""
argument_list|)
return|;
block|}
comment|/**    * Set the path in HDFS where the HBase image is    */
annotation|@
name|JsonIgnore
DECL|method|setImagePath (String imagePath)
specifier|public
name|void
name|setImagePath
parameter_list|(
name|String
name|imagePath
parameter_list|)
block|{
name|setOption
argument_list|(
name|INTERNAL_APPLICATION_IMAGE_PATH
argument_list|,
name|imagePath
argument_list|)
expr_stmt|;
block|}
comment|/**    * Query for the image path being set (non null/non empty)    * @return true if there is a path in the image path option    */
annotation|@
name|JsonIgnore
DECL|method|isImagePathSet ()
specifier|public
name|boolean
name|isImagePathSet
parameter_list|()
block|{
return|return
name|SliderUtils
operator|.
name|isSet
argument_list|(
name|getImagePath
argument_list|()
argument_list|)
return|;
block|}
block|}
end_class

end_unit

