begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.slider.server.appmaster.state
package|package
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|state
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|types
operator|.
name|NodeEntryInformation
import|;
end_import

begin_comment
comment|/**  * Information about the state of a role on a specific node instance.  * No fields are synchronized; sync on the instance to work with it  *<p>  * The two fields `releasing` and `requested` are used to track the ongoing  * state of YARN requests; they do not need to be persisted across stop/start  * cycles. They may be relevant across AM restart, but without other data  * structures in the AM, not enough to track what the AM was up to before  * it was restarted. The strategy will be to ignore unexpected allocation  * responses (which may come from pre-restart) requests, while treating  * unexpected container release responses as failures.  *<p>  * The `active` counter is only decremented after a container release response  * has been received.  *<p>  *  */
end_comment

begin_class
DECL|class|NodeEntry
specifier|public
class|class
name|NodeEntry
implements|implements
name|Cloneable
block|{
DECL|field|rolePriority
specifier|public
specifier|final
name|int
name|rolePriority
decl_stmt|;
DECL|method|NodeEntry (int rolePriority)
specifier|public
name|NodeEntry
parameter_list|(
name|int
name|rolePriority
parameter_list|)
block|{
name|this
operator|.
name|rolePriority
operator|=
name|rolePriority
expr_stmt|;
block|}
comment|/**    * instance explicitly requested on this node: it's OK if an allocation    * comes in that has not been (and when that happens, this count should     * not drop).    */
DECL|field|requested
specifier|private
name|int
name|requested
decl_stmt|;
comment|/** number of starting instances */
DECL|field|starting
specifier|private
name|int
name|starting
decl_stmt|;
comment|/** incrementing counter of instances that failed to start */
DECL|field|startFailed
specifier|private
name|int
name|startFailed
decl_stmt|;
comment|/** incrementing counter of instances that failed */
DECL|field|failed
specifier|private
name|int
name|failed
decl_stmt|;
comment|/**    * Counter of "failed recently" events. These are all failures    * which have happened since it was last reset.    */
DECL|field|failedRecently
specifier|private
name|int
name|failedRecently
decl_stmt|;
comment|/** incrementing counter of instances that have been pre-empted. */
DECL|field|preempted
specifier|private
name|int
name|preempted
decl_stmt|;
comment|/**    * Number of live nodes.     */
DECL|field|live
specifier|private
name|int
name|live
decl_stmt|;
comment|/** number of containers being released off this node */
DECL|field|releasing
specifier|private
name|int
name|releasing
decl_stmt|;
comment|/** timestamp of last use */
DECL|field|lastUsed
specifier|private
name|long
name|lastUsed
decl_stmt|;
comment|/**    * Is the node available for assignments? That is, it is    * not running any instances of this type, nor are there    * any requests oustanding for it.    * @return true if a new request could be issued without taking    * the number of instances&gt; 1.    */
DECL|method|isAvailable ()
specifier|public
specifier|synchronized
name|boolean
name|isAvailable
parameter_list|()
block|{
return|return
name|live
operator|+
name|requested
operator|+
name|starting
operator|-
name|releasing
operator|<=
literal|0
return|;
block|}
comment|/**    * Are the anti-affinity constraints held. That is, zero or one    * node running or starting    * @return true if the constraint holds.    */
DECL|method|isAntiAffinityConstraintHeld ()
specifier|public
specifier|synchronized
name|boolean
name|isAntiAffinityConstraintHeld
parameter_list|()
block|{
return|return
operator|(
name|live
operator|-
name|releasing
operator|+
name|starting
operator|)
operator|<=
literal|1
return|;
block|}
comment|/**    * return no of active instances -those that could be released as they    * are live and not already being released    * @return a number, possibly 0    */
DECL|method|getActive ()
specifier|public
specifier|synchronized
name|int
name|getActive
parameter_list|()
block|{
return|return
operator|(
name|live
operator|-
name|releasing
operator|)
return|;
block|}
comment|/**    * Return true if the node is not busy, and it    * has not been used since the absolute time    * @param absoluteTime time    * @return true if the node could be cleaned up    */
DECL|method|notUsedSince (long absoluteTime)
specifier|public
specifier|synchronized
name|boolean
name|notUsedSince
parameter_list|(
name|long
name|absoluteTime
parameter_list|)
block|{
return|return
name|isAvailable
argument_list|()
operator|&&
name|lastUsed
operator|<
name|absoluteTime
return|;
block|}
DECL|method|getLive ()
specifier|public
specifier|synchronized
name|int
name|getLive
parameter_list|()
block|{
return|return
name|live
return|;
block|}
DECL|method|getStarting ()
specifier|public
name|int
name|getStarting
parameter_list|()
block|{
return|return
name|starting
return|;
block|}
comment|/**    * Set the live value directly -used on AM restart    * @param v value    */
DECL|method|setLive (int v)
specifier|public
specifier|synchronized
name|void
name|setLive
parameter_list|(
name|int
name|v
parameter_list|)
block|{
name|live
operator|=
name|v
expr_stmt|;
block|}
DECL|method|incLive ()
specifier|private
specifier|synchronized
name|void
name|incLive
parameter_list|()
block|{
operator|++
name|live
expr_stmt|;
block|}
DECL|method|decLive ()
specifier|private
specifier|synchronized
name|void
name|decLive
parameter_list|()
block|{
name|live
operator|=
name|RoleHistoryUtils
operator|.
name|decToFloor
argument_list|(
name|live
argument_list|)
expr_stmt|;
block|}
DECL|method|onStarting ()
specifier|public
specifier|synchronized
name|void
name|onStarting
parameter_list|()
block|{
operator|++
name|starting
expr_stmt|;
block|}
DECL|method|decStarting ()
specifier|private
name|void
name|decStarting
parameter_list|()
block|{
name|starting
operator|=
name|RoleHistoryUtils
operator|.
name|decToFloor
argument_list|(
name|starting
argument_list|)
expr_stmt|;
block|}
DECL|method|onStartCompleted ()
specifier|public
specifier|synchronized
name|void
name|onStartCompleted
parameter_list|()
block|{
name|decStarting
argument_list|()
expr_stmt|;
name|incLive
argument_list|()
expr_stmt|;
block|}
comment|/**    * start failed -decrement the starting flag.    * @return true if the node is now available    */
DECL|method|onStartFailed ()
specifier|public
specifier|synchronized
name|boolean
name|onStartFailed
parameter_list|()
block|{
name|decStarting
argument_list|()
expr_stmt|;
operator|++
name|startFailed
expr_stmt|;
return|return
name|containerCompleted
argument_list|(
literal|false
argument_list|,
name|ContainerOutcome
operator|.
name|Failed
argument_list|)
return|;
block|}
comment|/**    * no of requests made of this role of this node. If it goes above    * 1 there's a problem    */
DECL|method|getRequested ()
specifier|public
specifier|synchronized
name|int
name|getRequested
parameter_list|()
block|{
return|return
name|requested
return|;
block|}
comment|/**    * request a node:     */
DECL|method|request ()
specifier|public
specifier|synchronized
name|void
name|request
parameter_list|()
block|{
operator|++
name|requested
expr_stmt|;
block|}
comment|/**    * A request made explicitly to this node has completed    */
DECL|method|requestCompleted ()
specifier|public
specifier|synchronized
name|void
name|requestCompleted
parameter_list|()
block|{
name|requested
operator|=
name|RoleHistoryUtils
operator|.
name|decToFloor
argument_list|(
name|requested
argument_list|)
expr_stmt|;
block|}
comment|/**    * No of instances in release state    */
DECL|method|getReleasing ()
specifier|public
specifier|synchronized
name|int
name|getReleasing
parameter_list|()
block|{
return|return
name|releasing
return|;
block|}
comment|/**    * Release an instance -which is no longer marked as active    */
DECL|method|release ()
specifier|public
specifier|synchronized
name|void
name|release
parameter_list|()
block|{
name|releasing
operator|++
expr_stmt|;
block|}
comment|/**    * completion event, which can be a planned or unplanned    * planned: dec our release count    * unplanned: dec our live count    * @param wasReleased true if this was planned    * @param outcome    * @return true if this node is now available    */
DECL|method|containerCompleted (boolean wasReleased, ContainerOutcome outcome)
specifier|public
specifier|synchronized
name|boolean
name|containerCompleted
parameter_list|(
name|boolean
name|wasReleased
parameter_list|,
name|ContainerOutcome
name|outcome
parameter_list|)
block|{
if|if
condition|(
name|wasReleased
condition|)
block|{
name|releasing
operator|=
name|RoleHistoryUtils
operator|.
name|decToFloor
argument_list|(
name|releasing
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// for the node, we use the outcome of the faiure to decide
comment|// whether this is potentially "node-related"
switch|switch
condition|(
name|outcome
condition|)
block|{
comment|// general "any reason" app failure
case|case
name|Failed
case|:
comment|// specific node failure
case|case
name|Node_failure
case|:
operator|++
name|failed
expr_stmt|;
operator|++
name|failedRecently
expr_stmt|;
break|break;
case|case
name|Preempted
case|:
name|preempted
operator|++
expr_stmt|;
break|break;
comment|// failures which are node-independent
case|case
name|Failed_limits_exceeded
case|:
case|case
name|Completed
case|:
default|default:
break|break;
block|}
block|}
name|decLive
argument_list|()
expr_stmt|;
return|return
name|isAvailable
argument_list|()
return|;
block|}
comment|/**    * Time last used.    */
DECL|method|getLastUsed ()
specifier|public
specifier|synchronized
name|long
name|getLastUsed
parameter_list|()
block|{
return|return
name|lastUsed
return|;
block|}
DECL|method|setLastUsed (long lastUsed)
specifier|public
specifier|synchronized
name|void
name|setLastUsed
parameter_list|(
name|long
name|lastUsed
parameter_list|)
block|{
name|this
operator|.
name|lastUsed
operator|=
name|lastUsed
expr_stmt|;
block|}
DECL|method|getStartFailed ()
specifier|public
specifier|synchronized
name|int
name|getStartFailed
parameter_list|()
block|{
return|return
name|startFailed
return|;
block|}
DECL|method|getFailed ()
specifier|public
specifier|synchronized
name|int
name|getFailed
parameter_list|()
block|{
return|return
name|failed
return|;
block|}
DECL|method|getFailedRecently ()
specifier|public
specifier|synchronized
name|int
name|getFailedRecently
parameter_list|()
block|{
return|return
name|failedRecently
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setFailedRecently (int failedRecently)
specifier|public
specifier|synchronized
name|void
name|setFailedRecently
parameter_list|(
name|int
name|failedRecently
parameter_list|)
block|{
name|this
operator|.
name|failedRecently
operator|=
name|failedRecently
expr_stmt|;
block|}
DECL|method|getPreempted ()
specifier|public
specifier|synchronized
name|int
name|getPreempted
parameter_list|()
block|{
return|return
name|preempted
return|;
block|}
comment|/**    * Reset the failed recently count.    */
DECL|method|resetFailedRecently ()
specifier|public
specifier|synchronized
name|void
name|resetFailedRecently
parameter_list|()
block|{
name|failedRecently
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"NodeEntry{"
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"priority="
argument_list|)
operator|.
name|append
argument_list|(
name|rolePriority
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", requested="
argument_list|)
operator|.
name|append
argument_list|(
name|requested
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", starting="
argument_list|)
operator|.
name|append
argument_list|(
name|starting
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", live="
argument_list|)
operator|.
name|append
argument_list|(
name|live
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", releasing="
argument_list|)
operator|.
name|append
argument_list|(
name|releasing
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", lastUsed="
argument_list|)
operator|.
name|append
argument_list|(
name|lastUsed
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", failedRecently="
argument_list|)
operator|.
name|append
argument_list|(
name|failedRecently
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", preempted="
argument_list|)
operator|.
name|append
argument_list|(
name|preempted
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", startFailed="
argument_list|)
operator|.
name|append
argument_list|(
name|startFailed
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Produced a serialized form which can be served up as JSON    * @return a summary of the current role status.    */
DECL|method|serialize ()
specifier|public
specifier|synchronized
name|NodeEntryInformation
name|serialize
parameter_list|()
block|{
name|NodeEntryInformation
name|info
init|=
operator|new
name|NodeEntryInformation
argument_list|()
decl_stmt|;
name|info
operator|.
name|priority
operator|=
name|rolePriority
expr_stmt|;
name|info
operator|.
name|requested
operator|=
name|requested
expr_stmt|;
name|info
operator|.
name|releasing
operator|=
name|releasing
expr_stmt|;
name|info
operator|.
name|starting
operator|=
name|starting
expr_stmt|;
name|info
operator|.
name|startFailed
operator|=
name|startFailed
expr_stmt|;
name|info
operator|.
name|failed
operator|=
name|failed
expr_stmt|;
name|info
operator|.
name|failedRecently
operator|=
name|failedRecently
expr_stmt|;
name|info
operator|.
name|preempted
operator|=
name|preempted
expr_stmt|;
name|info
operator|.
name|live
operator|=
name|live
expr_stmt|;
name|info
operator|.
name|lastUsed
operator|=
name|lastUsed
expr_stmt|;
return|return
name|info
return|;
block|}
annotation|@
name|Override
DECL|method|clone ()
specifier|public
name|Object
name|clone
parameter_list|()
throws|throws
name|CloneNotSupportedException
block|{
return|return
name|super
operator|.
name|clone
argument_list|()
return|;
block|}
block|}
end_class

end_unit

