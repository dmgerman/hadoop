begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.slider.server.appmaster.state
package|package
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|state
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Container
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|NodeReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|NodeState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|types
operator|.
name|NodeInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|SliderUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|BadConfigException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|providers
operator|.
name|ProviderRole
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|management
operator|.
name|BoolMetric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|management
operator|.
name|Timestamp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|operations
operator|.
name|AbstractRMOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|operations
operator|.
name|UpdateBlacklistOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|avro
operator|.
name|LoadedRoleHistory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|avro
operator|.
name|NodeEntryRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|avro
operator|.
name|RoleHistoryHeader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|avro
operator|.
name|RoleHistoryWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_comment
comment|/**  * The Role History.  *<p>  * Synchronization policy: all public operations are synchronized.  * Protected methods are in place for testing -no guarantees are made.  *<p>  * Inner classes have no synchronization guarantees; they should be manipulated   * in these classes and not externally.  *<p>  * Note that as well as some methods marked visible for testing, there  * is the option for the time generator method, {@link #now()} to  * be overridden so that a repeatable time series can be used.  *   */
end_comment

begin_class
DECL|class|RoleHistory
specifier|public
class|class
name|RoleHistory
block|{
DECL|field|log
specifier|protected
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|RoleHistory
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|providerRoles
specifier|private
specifier|final
name|List
argument_list|<
name|ProviderRole
argument_list|>
name|providerRoles
decl_stmt|;
comment|/** the roles in here are shared with App State */
DECL|field|roleStatusMap
specifier|private
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|RoleStatus
argument_list|>
name|roleStatusMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|recordFactory
specifier|private
specifier|final
name|AbstractClusterServices
name|recordFactory
decl_stmt|;
DECL|field|startTime
specifier|private
name|long
name|startTime
decl_stmt|;
comment|/** Time when saved */
DECL|field|saveTime
specifier|private
specifier|final
name|Timestamp
name|saveTime
init|=
operator|new
name|Timestamp
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/** If the history was loaded, the time at which the history was saved.    * That is: the time the data was valid */
DECL|field|thawedDataTime
specifier|private
specifier|final
name|Timestamp
name|thawedDataTime
init|=
operator|new
name|Timestamp
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|nodemap
specifier|private
name|NodeMap
name|nodemap
decl_stmt|;
DECL|field|roleSize
specifier|private
name|int
name|roleSize
decl_stmt|;
DECL|field|dirty
specifier|private
specifier|final
name|BoolMetric
name|dirty
init|=
operator|new
name|BoolMetric
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|field|filesystem
specifier|private
name|FileSystem
name|filesystem
decl_stmt|;
DECL|field|historyPath
specifier|private
name|Path
name|historyPath
decl_stmt|;
DECL|field|historyWriter
specifier|private
name|RoleHistoryWriter
name|historyWriter
init|=
operator|new
name|RoleHistoryWriter
argument_list|()
decl_stmt|;
comment|/**    * When were the nodes updated in a {@link #onNodesUpdated(List)} call?    * If zero: never.    */
DECL|field|nodesUpdatedTime
specifier|private
specifier|final
name|Timestamp
name|nodesUpdatedTime
init|=
operator|new
name|Timestamp
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|nodeUpdateReceived
specifier|private
specifier|final
name|BoolMetric
name|nodeUpdateReceived
init|=
operator|new
name|BoolMetric
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|field|outstandingRequests
specifier|private
name|OutstandingRequestTracker
name|outstandingRequests
init|=
operator|new
name|OutstandingRequestTracker
argument_list|()
decl_stmt|;
comment|/**    * For each role, lists nodes that are available for data-local allocation,    * ordered by more recently released - to accelerate node selection.    * That is, they are "recently used nodes"    */
DECL|field|recentNodes
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|LinkedList
argument_list|<
name|NodeInstance
argument_list|>
argument_list|>
name|recentNodes
decl_stmt|;
comment|/**    * Instantiate    * @param roles initial role list    * @param recordFactory yarn record factory    * @throws BadConfigException    */
DECL|method|RoleHistory (Collection<RoleStatus> roles, AbstractClusterServices recordFactory)
specifier|public
name|RoleHistory
parameter_list|(
name|Collection
argument_list|<
name|RoleStatus
argument_list|>
name|roles
parameter_list|,
name|AbstractClusterServices
name|recordFactory
parameter_list|)
throws|throws
name|BadConfigException
block|{
name|this
operator|.
name|recordFactory
operator|=
name|recordFactory
expr_stmt|;
name|roleSize
operator|=
name|roles
operator|.
name|size
argument_list|()
expr_stmt|;
name|providerRoles
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|roleSize
argument_list|)
expr_stmt|;
for|for
control|(
name|RoleStatus
name|role
range|:
name|roles
control|)
block|{
name|addNewRole
argument_list|(
name|role
argument_list|)
expr_stmt|;
block|}
name|reset
argument_list|()
expr_stmt|;
block|}
comment|/**    * Reset the variables -this does not adjust the fixed attributes    * of the history, but the nodemap and failed node map are cleared.    */
DECL|method|reset ()
specifier|protected
specifier|synchronized
name|void
name|reset
parameter_list|()
throws|throws
name|BadConfigException
block|{
name|nodemap
operator|=
operator|new
name|NodeMap
argument_list|(
name|roleSize
argument_list|)
expr_stmt|;
name|resetAvailableNodeLists
argument_list|()
expr_stmt|;
name|outstandingRequests
operator|=
operator|new
name|OutstandingRequestTracker
argument_list|()
expr_stmt|;
block|}
comment|/**    * safety check: make sure the role is unique amongst    * the role stats...which is extended with the new role    * @param roleStatus role    * @throws ArrayIndexOutOfBoundsException    * @throws BadConfigException    */
DECL|method|putRole (RoleStatus roleStatus)
specifier|protected
name|void
name|putRole
parameter_list|(
name|RoleStatus
name|roleStatus
parameter_list|)
throws|throws
name|BadConfigException
block|{
name|int
name|index
init|=
name|roleStatus
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|BadConfigException
argument_list|(
literal|"Provider "
operator|+
name|roleStatus
operator|+
literal|" id is out of range"
argument_list|)
throw|;
block|}
if|if
condition|(
name|roleStatusMap
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|BadConfigException
argument_list|(
name|roleStatus
operator|.
name|toString
argument_list|()
operator|+
literal|" id duplicates that of "
operator|+
name|roleStatusMap
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|)
throw|;
block|}
name|roleStatusMap
operator|.
name|put
argument_list|(
name|index
argument_list|,
name|roleStatus
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a new role    * @param roleStatus new role    */
DECL|method|addNewRole (RoleStatus roleStatus)
specifier|public
name|void
name|addNewRole
parameter_list|(
name|RoleStatus
name|roleStatus
parameter_list|)
throws|throws
name|BadConfigException
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Validating/adding new role to role history: {} "
argument_list|,
name|roleStatus
argument_list|)
expr_stmt|;
name|putRole
argument_list|(
name|roleStatus
argument_list|)
expr_stmt|;
name|this
operator|.
name|providerRoles
operator|.
name|add
argument_list|(
name|roleStatus
operator|.
name|getProviderRole
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Lookup a role by ID    * @param roleId role Id    * @return role or null if not found    */
DECL|method|lookupRole (int roleId)
specifier|public
name|ProviderRole
name|lookupRole
parameter_list|(
name|int
name|roleId
parameter_list|)
block|{
for|for
control|(
name|ProviderRole
name|role
range|:
name|providerRoles
control|)
block|{
if|if
condition|(
name|role
operator|.
name|id
operator|==
name|roleId
condition|)
block|{
return|return
name|role
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Clear the lists of available nodes    */
DECL|method|resetAvailableNodeLists ()
specifier|private
specifier|synchronized
name|void
name|resetAvailableNodeLists
parameter_list|()
block|{
name|recentNodes
operator|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|(
name|roleSize
argument_list|)
expr_stmt|;
block|}
comment|/**    * Prepare the history for re-reading its state.    *<p>    * This intended for use by the RoleWriter logic.    * @throws BadConfigException if there is a problem rebuilding the state    */
DECL|method|prepareForReading (RoleHistoryHeader header)
specifier|private
name|void
name|prepareForReading
parameter_list|(
name|RoleHistoryHeader
name|header
parameter_list|)
throws|throws
name|BadConfigException
block|{
name|reset
argument_list|()
expr_stmt|;
name|int
name|roleCountInSource
init|=
name|header
operator|.
name|getRoles
argument_list|()
decl_stmt|;
if|if
condition|(
name|roleCountInSource
operator|!=
name|roleSize
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Number of roles in source {}"
operator|+
literal|" does not match the expected number of {}"
argument_list|,
name|roleCountInSource
argument_list|,
name|roleSize
argument_list|)
expr_stmt|;
block|}
comment|//record when the data was loaded
name|setThawedDataTime
argument_list|(
name|header
operator|.
name|getSaved
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * rebuild the placement history from the loaded role history    * @param loadedRoleHistory loaded history    * @return the number of entries discarded    * @throws BadConfigException if there is a problem rebuilding the state    */
annotation|@
name|VisibleForTesting
DECL|method|rebuild (LoadedRoleHistory loadedRoleHistory)
specifier|public
specifier|synchronized
name|int
name|rebuild
parameter_list|(
name|LoadedRoleHistory
name|loadedRoleHistory
parameter_list|)
throws|throws
name|BadConfigException
block|{
name|RoleHistoryHeader
name|header
init|=
name|loadedRoleHistory
operator|.
name|getHeader
argument_list|()
decl_stmt|;
name|prepareForReading
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|int
name|discarded
init|=
literal|0
decl_stmt|;
name|Long
name|saved
init|=
name|header
operator|.
name|getSaved
argument_list|()
decl_stmt|;
for|for
control|(
name|NodeEntryRecord
name|nodeEntryRecord
range|:
name|loadedRoleHistory
operator|.
name|records
control|)
block|{
name|Integer
name|roleId
init|=
name|nodeEntryRecord
operator|.
name|getRole
argument_list|()
decl_stmt|;
name|NodeEntry
name|nodeEntry
init|=
operator|new
name|NodeEntry
argument_list|(
name|roleId
argument_list|)
decl_stmt|;
name|nodeEntry
operator|.
name|setLastUsed
argument_list|(
name|nodeEntryRecord
operator|.
name|getLastUsed
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodeEntryRecord
operator|.
name|getActive
argument_list|()
condition|)
block|{
comment|//if active at the time of save, make the last used time the save time
name|nodeEntry
operator|.
name|setLastUsed
argument_list|(
name|saved
argument_list|)
expr_stmt|;
block|}
name|String
name|hostname
init|=
name|SliderUtils
operator|.
name|sequenceToString
argument_list|(
name|nodeEntryRecord
operator|.
name|getHost
argument_list|()
argument_list|)
decl_stmt|;
name|ProviderRole
name|providerRole
init|=
name|lookupRole
argument_list|(
name|roleId
argument_list|)
decl_stmt|;
if|if
condition|(
name|providerRole
operator|==
literal|null
condition|)
block|{
comment|// discarding entry
name|log
operator|.
name|info
argument_list|(
literal|"Discarding history entry with unknown role: {} on host {}"
argument_list|,
name|roleId
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|discarded
operator|++
expr_stmt|;
block|}
else|else
block|{
name|NodeInstance
name|instance
init|=
name|getOrCreateNodeInstance
argument_list|(
name|hostname
argument_list|)
decl_stmt|;
name|instance
operator|.
name|set
argument_list|(
name|roleId
argument_list|,
name|nodeEntry
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|discarded
return|;
block|}
DECL|method|getStartTime ()
specifier|public
specifier|synchronized
name|long
name|getStartTime
parameter_list|()
block|{
return|return
name|startTime
return|;
block|}
DECL|method|getSaveTime ()
specifier|public
specifier|synchronized
name|long
name|getSaveTime
parameter_list|()
block|{
return|return
name|saveTime
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|getThawedDataTime ()
specifier|public
name|long
name|getThawedDataTime
parameter_list|()
block|{
return|return
name|thawedDataTime
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|setThawedDataTime (long thawedDataTime)
specifier|public
name|void
name|setThawedDataTime
parameter_list|(
name|long
name|thawedDataTime
parameter_list|)
block|{
name|this
operator|.
name|thawedDataTime
operator|.
name|set
argument_list|(
name|thawedDataTime
argument_list|)
expr_stmt|;
block|}
DECL|method|getRoleSize ()
specifier|public
specifier|synchronized
name|int
name|getRoleSize
parameter_list|()
block|{
return|return
name|roleSize
return|;
block|}
comment|/**    * Get the total size of the cluster -the number of NodeInstances    * @return a count    */
DECL|method|getClusterSize ()
specifier|public
specifier|synchronized
name|int
name|getClusterSize
parameter_list|()
block|{
return|return
name|nodemap
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|isDirty ()
specifier|public
specifier|synchronized
name|boolean
name|isDirty
parameter_list|()
block|{
return|return
name|dirty
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|setDirty (boolean dirty)
specifier|public
specifier|synchronized
name|void
name|setDirty
parameter_list|(
name|boolean
name|dirty
parameter_list|)
block|{
name|this
operator|.
name|dirty
operator|.
name|set
argument_list|(
name|dirty
argument_list|)
expr_stmt|;
block|}
comment|/**    * Tell the history that it has been saved; marks itself as clean    * @param timestamp timestamp -updates the savetime field    */
DECL|method|saved (long timestamp)
specifier|public
specifier|synchronized
name|void
name|saved
parameter_list|(
name|long
name|timestamp
parameter_list|)
block|{
name|setDirty
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|saveTime
operator|.
name|set
argument_list|(
name|timestamp
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get a clone of the nodemap.    * The instances inside are not cloned    * @return the map    */
DECL|method|cloneNodemap ()
specifier|public
specifier|synchronized
name|NodeMap
name|cloneNodemap
parameter_list|()
block|{
return|return
operator|(
name|NodeMap
operator|)
name|nodemap
operator|.
name|clone
argument_list|()
return|;
block|}
comment|/**    * Get snapshot of the node map    * @return a snapshot of the current node state    * @param naming naming map of priority to enty name; entries must be unique.    * It's OK to be incomplete, for those the list falls back to numbers.    */
DECL|method|getNodeInformationSnapshot ( Map<Integer, String> naming)
specifier|public
specifier|synchronized
name|Map
argument_list|<
name|String
argument_list|,
name|NodeInformation
argument_list|>
name|getNodeInformationSnapshot
parameter_list|(
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|naming
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|NodeInformation
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|nodemap
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|NodeInstance
argument_list|>
name|entry
range|:
name|nodemap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|result
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|serialize
argument_list|(
name|naming
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Get the information on a node    * @param hostname hostname    * @param naming naming map of priority to enty name; entries must be unique.    * It's OK to be incomplete, for those the list falls back to numbers.    * @return the information about that host, or null if there is none    */
DECL|method|getNodeInformation (String hostname, Map<Integer, String> naming)
specifier|public
specifier|synchronized
name|NodeInformation
name|getNodeInformation
parameter_list|(
name|String
name|hostname
parameter_list|,
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|naming
parameter_list|)
block|{
name|NodeInstance
name|nodeInstance
init|=
name|nodemap
operator|.
name|get
argument_list|(
name|hostname
argument_list|)
decl_stmt|;
return|return
name|nodeInstance
operator|!=
literal|null
condition|?
name|nodeInstance
operator|.
name|serialize
argument_list|(
name|naming
argument_list|)
else|:
literal|null
return|;
block|}
comment|/**    * Get the node instance for the specific node -creating it if needed    * @param hostname node address    * @return the instance    */
DECL|method|getOrCreateNodeInstance (String hostname)
specifier|public
specifier|synchronized
name|NodeInstance
name|getOrCreateNodeInstance
parameter_list|(
name|String
name|hostname
parameter_list|)
block|{
comment|//convert to a string
return|return
name|nodemap
operator|.
name|getOrCreate
argument_list|(
name|hostname
argument_list|)
return|;
block|}
comment|/**    * Insert a list of nodes into the map; overwrite any with that name.    * This is a bulk operation for testing.    * Important: this does not update the available node lists, these    * must be rebuilt afterwards.    * @param nodes collection of nodes.    */
annotation|@
name|VisibleForTesting
DECL|method|insert (Collection<NodeInstance> nodes)
specifier|public
specifier|synchronized
name|void
name|insert
parameter_list|(
name|Collection
argument_list|<
name|NodeInstance
argument_list|>
name|nodes
parameter_list|)
block|{
name|nodemap
operator|.
name|insert
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get current time. overrideable for test subclasses    * @return current time in millis    */
DECL|method|now ()
specifier|protected
name|long
name|now
parameter_list|()
block|{
return|return
name|System
operator|.
name|currentTimeMillis
argument_list|()
return|;
block|}
comment|/**    * Mark ourselves as dirty    */
DECL|method|touch ()
specifier|public
name|void
name|touch
parameter_list|()
block|{
name|setDirty
argument_list|(
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
name|saveHistoryIfDirty
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Failed to save history file "
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * reset the failed recently counters    */
DECL|method|resetFailedRecently ()
specifier|public
specifier|synchronized
name|void
name|resetFailedRecently
parameter_list|()
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Resetting failure history"
argument_list|)
expr_stmt|;
name|nodemap
operator|.
name|resetFailedRecently
argument_list|()
expr_stmt|;
block|}
comment|/**    * Get the path used for history files    * @return the directory used for history files    */
DECL|method|getHistoryPath ()
specifier|public
name|Path
name|getHistoryPath
parameter_list|()
block|{
return|return
name|historyPath
return|;
block|}
comment|/**    * Save the history to its location using the timestamp as part of    * the filename. The saveTime and dirty fields are updated    * @param time timestamp timestamp to use as the save time    * @return the path saved to    * @throws IOException IO problems    */
annotation|@
name|VisibleForTesting
DECL|method|saveHistory (long time)
specifier|public
specifier|synchronized
name|Path
name|saveHistory
parameter_list|(
name|long
name|time
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|filename
init|=
name|historyWriter
operator|.
name|createHistoryFilename
argument_list|(
name|historyPath
argument_list|,
name|time
argument_list|)
decl_stmt|;
name|historyWriter
operator|.
name|write
argument_list|(
name|filesystem
argument_list|,
name|filename
argument_list|,
literal|true
argument_list|,
name|this
argument_list|,
name|time
argument_list|)
expr_stmt|;
name|saved
argument_list|(
name|time
argument_list|)
expr_stmt|;
return|return
name|filename
return|;
block|}
comment|/**    * Save the history with the current timestamp if it is dirty;    * return the path saved to if this is the case    * @return the path or null if the history was not saved    * @throws IOException failed to save for some reason    */
DECL|method|saveHistoryIfDirty ()
specifier|public
specifier|synchronized
name|Path
name|saveHistoryIfDirty
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|isDirty
argument_list|()
condition|)
block|{
return|return
name|saveHistory
argument_list|(
name|now
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Start up    * @param fs filesystem     * @param historyDir path in FS for history    * @return true if the history was thawed    */
DECL|method|onStart (FileSystem fs, Path historyDir)
specifier|public
name|boolean
name|onStart
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|historyDir
parameter_list|)
throws|throws
name|BadConfigException
block|{
assert|assert
name|filesystem
operator|==
literal|null
assert|;
name|filesystem
operator|=
name|fs
expr_stmt|;
name|historyPath
operator|=
name|historyDir
expr_stmt|;
name|startTime
operator|=
name|now
argument_list|()
expr_stmt|;
comment|//assume the history is being thawed; this will downgrade as appropriate
return|return
name|onThaw
argument_list|()
return|;
block|}
comment|/**    * Handler for bootstrap event: there was no history to thaw    */
DECL|method|onBootstrap ()
specifier|public
name|void
name|onBootstrap
parameter_list|()
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Role history bootstrapped"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Handle the start process<i>after the history has been rebuilt</i>,    * and after any gc/purge    */
DECL|method|onThaw ()
specifier|public
specifier|synchronized
name|boolean
name|onThaw
parameter_list|()
throws|throws
name|BadConfigException
block|{
assert|assert
name|filesystem
operator|!=
literal|null
assert|;
assert|assert
name|historyPath
operator|!=
literal|null
assert|;
name|boolean
name|thawSuccessful
init|=
literal|false
decl_stmt|;
comment|//load in files from data dir
name|LoadedRoleHistory
name|loadedRoleHistory
init|=
literal|null
decl_stmt|;
try|try
block|{
name|loadedRoleHistory
operator|=
name|historyWriter
operator|.
name|loadFromHistoryDir
argument_list|(
name|filesystem
argument_list|,
name|historyPath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Exception trying to load history from {}"
argument_list|,
name|historyPath
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loadedRoleHistory
operator|!=
literal|null
condition|)
block|{
name|rebuild
argument_list|(
name|loadedRoleHistory
argument_list|)
expr_stmt|;
name|thawSuccessful
operator|=
literal|true
expr_stmt|;
name|Path
name|loadPath
init|=
name|loadedRoleHistory
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"loaded history from {}"
argument_list|,
name|loadPath
argument_list|)
expr_stmt|;
comment|// delete any old entries
try|try
block|{
name|int
name|count
init|=
name|historyWriter
operator|.
name|purgeOlderHistoryEntries
argument_list|(
name|filesystem
argument_list|,
name|loadPath
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Deleted {} old history entries"
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Ignoring exception raised while trying to delete old entries"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|//start is then completed
name|buildRecentNodeLists
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//fallback to bootstrap procedure
name|onBootstrap
argument_list|()
expr_stmt|;
block|}
return|return
name|thawSuccessful
return|;
block|}
comment|/**    * (After the start), rebuild the availability data structures    */
annotation|@
name|VisibleForTesting
DECL|method|buildRecentNodeLists ()
specifier|public
specifier|synchronized
name|void
name|buildRecentNodeLists
parameter_list|()
block|{
name|resetAvailableNodeLists
argument_list|()
expr_stmt|;
comment|// build the list of available nodes
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|NodeInstance
argument_list|>
name|entry
range|:
name|nodemap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|NodeInstance
name|ni
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|roleSize
condition|;
name|i
operator|++
control|)
block|{
name|NodeEntry
name|nodeEntry
init|=
name|ni
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeEntry
operator|!=
literal|null
operator|&&
name|nodeEntry
operator|.
name|isAvailable
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Adding {} for role {}"
argument_list|,
name|ni
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|listRecentNodesForRoleId
argument_list|(
name|i
argument_list|)
operator|.
name|add
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// sort the resulting arrays
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|roleSize
condition|;
name|i
operator|++
control|)
block|{
name|sortRecentNodeList
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get the nodes for an ID -may be null    * @param id role ID    * @return potentially null list    */
annotation|@
name|VisibleForTesting
DECL|method|getRecentNodesForRoleId (int id)
specifier|public
name|List
argument_list|<
name|NodeInstance
argument_list|>
name|getRecentNodesForRoleId
parameter_list|(
name|int
name|id
parameter_list|)
block|{
return|return
name|recentNodes
operator|.
name|get
argument_list|(
name|id
argument_list|)
return|;
block|}
comment|/**    * Get a possibly empty list of suggested nodes for a role.    * @param id role ID    * @return list    */
DECL|method|listRecentNodesForRoleId (int id)
specifier|private
name|LinkedList
argument_list|<
name|NodeInstance
argument_list|>
name|listRecentNodesForRoleId
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|LinkedList
argument_list|<
name|NodeInstance
argument_list|>
name|instances
init|=
name|recentNodes
operator|.
name|get
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|instances
operator|==
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// recheck in the synchronized block and recreate
if|if
condition|(
name|recentNodes
operator|.
name|get
argument_list|(
name|id
argument_list|)
operator|==
literal|null
condition|)
block|{
name|recentNodes
operator|.
name|put
argument_list|(
name|id
argument_list|,
operator|new
name|LinkedList
argument_list|<
name|NodeInstance
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|instances
operator|=
name|recentNodes
operator|.
name|get
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|instances
return|;
block|}
comment|/**    * Sort a the recent node list for a single role    * @param role role to sort    */
DECL|method|sortRecentNodeList (int role)
specifier|private
name|void
name|sortRecentNodeList
parameter_list|(
name|int
name|role
parameter_list|)
block|{
name|List
argument_list|<
name|NodeInstance
argument_list|>
name|nodesForRoleId
init|=
name|getRecentNodesForRoleId
argument_list|(
name|role
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodesForRoleId
operator|!=
literal|null
condition|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|nodesForRoleId
argument_list|,
operator|new
name|NodeInstance
operator|.
name|Preferred
argument_list|(
name|role
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|updateBlacklist ( Collection<RoleStatus> roleStatuses)
specifier|public
specifier|synchronized
name|UpdateBlacklistOperation
name|updateBlacklist
parameter_list|(
name|Collection
argument_list|<
name|RoleStatus
argument_list|>
name|roleStatuses
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|blacklistAdditions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|blacklistRemovals
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|NodeInstance
argument_list|>
name|nodeInstanceEntry
range|:
name|nodemap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|boolean
name|shouldBeBlacklisted
init|=
literal|false
decl_stmt|;
name|String
name|nodeHost
init|=
name|nodeInstanceEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|NodeInstance
name|nodeInstance
init|=
name|nodeInstanceEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
for|for
control|(
name|RoleStatus
name|roleStatus
range|:
name|roleStatuses
control|)
block|{
if|if
condition|(
name|nodeInstance
operator|.
name|exceedsFailureThreshold
argument_list|(
name|roleStatus
argument_list|)
condition|)
block|{
name|shouldBeBlacklisted
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|shouldBeBlacklisted
condition|)
block|{
if|if
condition|(
operator|!
name|nodeInstance
operator|.
name|isBlacklisted
argument_list|()
condition|)
block|{
name|blacklistAdditions
operator|.
name|add
argument_list|(
name|nodeHost
argument_list|)
expr_stmt|;
name|nodeInstance
operator|.
name|setBlacklisted
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|nodeInstance
operator|.
name|isBlacklisted
argument_list|()
condition|)
block|{
name|blacklistRemovals
operator|.
name|add
argument_list|(
name|nodeHost
argument_list|)
expr_stmt|;
name|nodeInstance
operator|.
name|setBlacklisted
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|blacklistAdditions
operator|.
name|isEmpty
argument_list|()
operator|&&
name|blacklistRemovals
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|UpdateBlacklistOperation
argument_list|(
name|blacklistAdditions
argument_list|,
name|blacklistRemovals
argument_list|)
return|;
block|}
comment|/**    * Find a node for use    * @param role role    * @return the instance, or null for none    */
annotation|@
name|VisibleForTesting
DECL|method|findRecentNodeForNewInstance (RoleStatus role)
specifier|public
specifier|synchronized
name|NodeInstance
name|findRecentNodeForNewInstance
parameter_list|(
name|RoleStatus
name|role
parameter_list|)
block|{
if|if
condition|(
operator|!
name|role
operator|.
name|isPlacementDesired
argument_list|()
condition|)
block|{
comment|// no data locality policy
return|return
literal|null
return|;
block|}
name|int
name|roleId
init|=
name|role
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|boolean
name|strictPlacement
init|=
name|role
operator|.
name|isStrictPlacement
argument_list|()
decl_stmt|;
name|NodeInstance
name|nodeInstance
init|=
literal|null
decl_stmt|;
comment|// Get the list of possible targets.
comment|// This is a live list: changes here are preserved
name|List
argument_list|<
name|NodeInstance
argument_list|>
name|targets
init|=
name|getRecentNodesForRoleId
argument_list|(
name|roleId
argument_list|)
decl_stmt|;
if|if
condition|(
name|targets
operator|==
literal|null
condition|)
block|{
comment|// nothing to allocate on
return|return
literal|null
return|;
block|}
name|int
name|cnt
init|=
name|targets
operator|.
name|size
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"There are {} node(s) to consider for {}"
argument_list|,
name|cnt
argument_list|,
name|role
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cnt
operator|&&
name|nodeInstance
operator|==
literal|null
condition|;
name|i
operator|++
control|)
block|{
name|NodeInstance
name|candidate
init|=
name|targets
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|candidate
operator|.
name|getActiveRoleInstances
argument_list|(
name|roleId
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|// no active instances: check failure statistics
if|if
condition|(
name|strictPlacement
operator|||
operator|(
name|candidate
operator|.
name|isOnline
argument_list|()
operator|&&
operator|!
name|candidate
operator|.
name|exceedsFailureThreshold
argument_list|(
name|role
argument_list|)
operator|)
condition|)
block|{
name|targets
operator|.
name|remove
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|// exit criteria for loop is now met
name|nodeInstance
operator|=
name|candidate
expr_stmt|;
block|}
else|else
block|{
comment|// too many failures for this node
name|log
operator|.
name|info
argument_list|(
literal|"Recent node failures is higher than threshold {}. Not requesting host {}"
argument_list|,
name|role
operator|.
name|getNodeFailureThreshold
argument_list|()
argument_list|,
name|candidate
operator|.
name|hostname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|nodeInstance
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"No node found for {}"
argument_list|,
name|role
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|nodeInstance
return|;
block|}
comment|/**    * Find a node for use    * @param role role    * @return the instance, or null for none    */
annotation|@
name|VisibleForTesting
DECL|method|findNodeForNewAAInstance (RoleStatus role)
specifier|public
specifier|synchronized
name|List
argument_list|<
name|NodeInstance
argument_list|>
name|findNodeForNewAAInstance
parameter_list|(
name|RoleStatus
name|role
parameter_list|)
block|{
comment|// all nodes that are live and can host the role; no attempt to exclude ones
comment|// considered failing
return|return
name|nodemap
operator|.
name|findAllNodesForRole
argument_list|(
name|role
operator|.
name|getKey
argument_list|()
argument_list|,
name|role
operator|.
name|getLabelExpression
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Request an instance on a given node.    * An outstanding request is created& tracked, with the     * relevant node entry for that role updated.    *<p>    * The role status entries will also be tracked    *<p>    * Returns the request that is now being tracked.    * If the node instance is not null, it's details about the role is incremented    *    * @param node node to target or null for "any"    * @param role role to request    * @return the request    */
DECL|method|requestInstanceOnNode ( NodeInstance node, RoleStatus role, Resource resource)
specifier|public
specifier|synchronized
name|OutstandingRequest
name|requestInstanceOnNode
parameter_list|(
name|NodeInstance
name|node
parameter_list|,
name|RoleStatus
name|role
parameter_list|,
name|Resource
name|resource
parameter_list|)
block|{
name|OutstandingRequest
name|outstanding
init|=
name|outstandingRequests
operator|.
name|newRequest
argument_list|(
name|node
argument_list|,
name|role
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
name|outstanding
operator|.
name|buildContainerRequest
argument_list|(
name|resource
argument_list|,
name|role
argument_list|,
name|now
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|outstanding
return|;
block|}
comment|/**    * Find a node for a role and request an instance on that (or a location-less    * instance)    * @param role role status    * @return a request ready to go, or null if this is an AA request and no    * location can be found.    */
DECL|method|requestContainerForRole (RoleStatus role)
specifier|public
specifier|synchronized
name|OutstandingRequest
name|requestContainerForRole
parameter_list|(
name|RoleStatus
name|role
parameter_list|)
block|{
if|if
condition|(
name|role
operator|.
name|isAntiAffinePlacement
argument_list|()
condition|)
block|{
return|return
name|requestContainerForAARole
argument_list|(
name|role
argument_list|)
return|;
block|}
else|else
block|{
name|Resource
name|resource
init|=
name|recordFactory
operator|.
name|newResource
argument_list|()
decl_stmt|;
name|role
operator|.
name|copyResourceRequirements
argument_list|(
name|resource
argument_list|)
expr_stmt|;
name|NodeInstance
name|node
init|=
name|findRecentNodeForNewInstance
argument_list|(
name|role
argument_list|)
decl_stmt|;
return|return
name|requestInstanceOnNode
argument_list|(
name|node
argument_list|,
name|role
argument_list|,
name|resource
argument_list|)
return|;
block|}
block|}
comment|/**    * Find a node for an AA role and request an instance on that (or a location-less    * instance)    * @param role role status    * @return a request ready to go, or null if no location can be found.    */
DECL|method|requestContainerForAARole (RoleStatus role)
specifier|public
specifier|synchronized
name|OutstandingRequest
name|requestContainerForAARole
parameter_list|(
name|RoleStatus
name|role
parameter_list|)
block|{
name|List
argument_list|<
name|NodeInstance
argument_list|>
name|nodes
init|=
name|findNodeForNewAAInstance
argument_list|(
name|role
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|nodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|OutstandingRequest
name|outstanding
init|=
name|outstandingRequests
operator|.
name|newAARequest
argument_list|(
name|role
operator|.
name|getKey
argument_list|()
argument_list|,
name|nodes
argument_list|,
name|role
operator|.
name|getLabelExpression
argument_list|()
argument_list|)
decl_stmt|;
name|Resource
name|resource
init|=
name|recordFactory
operator|.
name|newResource
argument_list|()
decl_stmt|;
name|role
operator|.
name|copyResourceRequirements
argument_list|(
name|resource
argument_list|)
expr_stmt|;
name|outstanding
operator|.
name|buildContainerRequest
argument_list|(
name|resource
argument_list|,
name|role
argument_list|,
name|now
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|outstanding
return|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"No suitable location for {}"
argument_list|,
name|role
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Get the list of active nodes ... walks the node map so    * is {@code O(nodes)}    * @param role role index    * @return a possibly empty list of nodes with an instance of that node    */
DECL|method|listActiveNodes (int role)
specifier|public
specifier|synchronized
name|List
argument_list|<
name|NodeInstance
argument_list|>
name|listActiveNodes
parameter_list|(
name|int
name|role
parameter_list|)
block|{
return|return
name|nodemap
operator|.
name|listActiveNodes
argument_list|(
name|role
argument_list|)
return|;
block|}
comment|/**    * Get the node entry of a container    * @param container container to look up    * @return the entry    * @throws RuntimeException if the container has no hostname    */
DECL|method|getOrCreateNodeEntry (Container container)
specifier|public
name|NodeEntry
name|getOrCreateNodeEntry
parameter_list|(
name|Container
name|container
parameter_list|)
block|{
return|return
name|getOrCreateNodeInstance
argument_list|(
name|container
argument_list|)
operator|.
name|getOrCreate
argument_list|(
name|container
argument_list|)
return|;
block|}
comment|/**    * Get the node instance of a container -always returns something    * @param container container to look up    * @return a (possibly new) node instance    * @throws RuntimeException if the container has no hostname    */
DECL|method|getOrCreateNodeInstance (Container container)
specifier|public
specifier|synchronized
name|NodeInstance
name|getOrCreateNodeInstance
parameter_list|(
name|Container
name|container
parameter_list|)
block|{
return|return
name|nodemap
operator|.
name|getOrCreate
argument_list|(
name|RoleHistoryUtils
operator|.
name|hostnameOf
argument_list|(
name|container
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get the node instance of a host if defined    * @param hostname hostname to look up    * @return a node instance or null    * @throws RuntimeException if the container has no hostname    */
DECL|method|getExistingNodeInstance (String hostname)
specifier|public
specifier|synchronized
name|NodeInstance
name|getExistingNodeInstance
parameter_list|(
name|String
name|hostname
parameter_list|)
block|{
return|return
name|nodemap
operator|.
name|get
argument_list|(
name|hostname
argument_list|)
return|;
block|}
comment|/**    * Get the node instance of a container<i>if there's an entry in the history</i>    * @param container container to look up    * @return a node instance or null    * @throws RuntimeException if the container has no hostname    */
DECL|method|getExistingNodeInstance (Container container)
specifier|public
specifier|synchronized
name|NodeInstance
name|getExistingNodeInstance
parameter_list|(
name|Container
name|container
parameter_list|)
block|{
return|return
name|nodemap
operator|.
name|get
argument_list|(
name|RoleHistoryUtils
operator|.
name|hostnameOf
argument_list|(
name|container
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Perform any pre-allocation operations on the list of allocated containers    * based on knowledge of system state.     * Currently this places requested hosts ahead of unrequested ones.    * @param allocatedContainers list of allocated containers    * @return list of containers potentially reordered    */
DECL|method|prepareAllocationList (List<Container> allocatedContainers)
specifier|public
specifier|synchronized
name|List
argument_list|<
name|Container
argument_list|>
name|prepareAllocationList
parameter_list|(
name|List
argument_list|<
name|Container
argument_list|>
name|allocatedContainers
parameter_list|)
block|{
comment|//partition into requested and unrequested
name|List
argument_list|<
name|Container
argument_list|>
name|requested
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|allocatedContainers
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Container
argument_list|>
name|unrequested
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|allocatedContainers
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|outstandingRequests
operator|.
name|partitionRequests
argument_list|(
name|this
argument_list|,
name|allocatedContainers
argument_list|,
name|requested
argument_list|,
name|unrequested
argument_list|)
expr_stmt|;
comment|//give the unrequested ones lower priority
name|requested
operator|.
name|addAll
argument_list|(
name|unrequested
argument_list|)
expr_stmt|;
return|return
name|requested
return|;
block|}
comment|/**    * A container has been allocated on a node -update the data structures    * @param container container    * @param desiredCount desired #of instances    * @param actualCount current count of instances    * @return The allocation outcome    */
DECL|method|onContainerAllocated (Container container, long desiredCount, long actualCount)
specifier|public
specifier|synchronized
name|ContainerAllocationResults
name|onContainerAllocated
parameter_list|(
name|Container
name|container
parameter_list|,
name|long
name|desiredCount
parameter_list|,
name|long
name|actualCount
parameter_list|)
block|{
name|int
name|role
init|=
name|ContainerPriority
operator|.
name|extractRole
argument_list|(
name|container
argument_list|)
decl_stmt|;
name|String
name|hostname
init|=
name|RoleHistoryUtils
operator|.
name|hostnameOf
argument_list|(
name|container
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|NodeInstance
argument_list|>
name|nodeInstances
init|=
name|listRecentNodesForRoleId
argument_list|(
name|role
argument_list|)
decl_stmt|;
name|ContainerAllocationResults
name|outcome
init|=
name|outstandingRequests
operator|.
name|onContainerAllocated
argument_list|(
name|role
argument_list|,
name|hostname
argument_list|,
name|container
argument_list|)
decl_stmt|;
if|if
condition|(
name|desiredCount
operator|<=
name|actualCount
condition|)
block|{
comment|// all outstanding requests have been satisfied
comment|// clear all the lists, so returning nodes to the available set
name|List
argument_list|<
name|NodeInstance
argument_list|>
name|hosts
init|=
name|outstandingRequests
operator|.
name|resetOutstandingRequests
argument_list|(
name|role
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|hosts
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|//add the list
name|log
operator|.
name|info
argument_list|(
literal|"Adding {} hosts for role {}"
argument_list|,
name|hosts
operator|.
name|size
argument_list|()
argument_list|,
name|role
argument_list|)
expr_stmt|;
name|nodeInstances
operator|.
name|addAll
argument_list|(
name|hosts
argument_list|)
expr_stmt|;
name|sortRecentNodeList
argument_list|(
name|role
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|outcome
return|;
block|}
comment|/**    * A container has been assigned to a role instance on a node -update the data structures    * @param container container    */
DECL|method|onContainerAssigned (Container container)
specifier|public
name|void
name|onContainerAssigned
parameter_list|(
name|Container
name|container
parameter_list|)
block|{
name|NodeInstance
name|node
init|=
name|getOrCreateNodeInstance
argument_list|(
name|container
argument_list|)
decl_stmt|;
name|NodeEntry
name|nodeEntry
init|=
name|node
operator|.
name|getOrCreate
argument_list|(
name|container
argument_list|)
decl_stmt|;
name|nodeEntry
operator|.
name|onStarting
argument_list|()
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Node {} has updated NodeEntry {}"
argument_list|,
name|node
argument_list|,
name|nodeEntry
argument_list|)
expr_stmt|;
block|}
comment|/**    * Event: a container start has been submitted    * @param container container being started    * @param instance instance bound to the container    */
DECL|method|onContainerStartSubmitted (Container container, RoleInstance instance)
specifier|public
name|void
name|onContainerStartSubmitted
parameter_list|(
name|Container
name|container
parameter_list|,
name|RoleInstance
name|instance
parameter_list|)
block|{
comment|// no actions here
block|}
comment|/**    * Container start event    * @param container container that just started    */
DECL|method|onContainerStarted (Container container)
specifier|public
name|void
name|onContainerStarted
parameter_list|(
name|Container
name|container
parameter_list|)
block|{
name|NodeEntry
name|nodeEntry
init|=
name|getOrCreateNodeEntry
argument_list|(
name|container
argument_list|)
decl_stmt|;
name|nodeEntry
operator|.
name|onStartCompleted
argument_list|()
expr_stmt|;
name|touch
argument_list|()
expr_stmt|;
block|}
comment|/**    * A container failed to start: update the node entry state    * and return the container to the queue    * @param container container that failed    * @return true if the node was queued    */
DECL|method|onNodeManagerContainerStartFailed (Container container)
specifier|public
name|boolean
name|onNodeManagerContainerStartFailed
parameter_list|(
name|Container
name|container
parameter_list|)
block|{
return|return
name|markContainerFinished
argument_list|(
name|container
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
name|ContainerOutcome
operator|.
name|Failed
argument_list|)
return|;
block|}
comment|/**    * Does the RoleHistory have enough information about the YARN cluster    * to start placing AA requests? That is: has it the node map and    * any label information needed?    * @return true if the caller can start requesting AA nodes    */
DECL|method|canPlaceAANodes ()
specifier|public
name|boolean
name|canPlaceAANodes
parameter_list|()
block|{
return|return
name|nodeUpdateReceived
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Get the last time the nodes were updated from YARN    * @return the update time or zero if never updated.    */
DECL|method|getNodesUpdatedTime ()
specifier|public
name|long
name|getNodesUpdatedTime
parameter_list|()
block|{
return|return
name|nodesUpdatedTime
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Update failedNodes and nodemap based on the node state    *    * @param updatedNodes list of updated nodes    * @return true if a review should be triggered.    */
DECL|method|onNodesUpdated (List<NodeReport> updatedNodes)
specifier|public
specifier|synchronized
name|boolean
name|onNodesUpdated
parameter_list|(
name|List
argument_list|<
name|NodeReport
argument_list|>
name|updatedNodes
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Updating {} nodes"
argument_list|,
name|updatedNodes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|nodesUpdatedTime
operator|.
name|set
argument_list|(
name|now
argument_list|()
argument_list|)
expr_stmt|;
name|nodeUpdateReceived
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|int
name|printed
init|=
literal|0
decl_stmt|;
name|boolean
name|triggerReview
init|=
literal|false
decl_stmt|;
for|for
control|(
name|NodeReport
name|updatedNode
range|:
name|updatedNodes
control|)
block|{
name|String
name|hostname
init|=
name|updatedNode
operator|.
name|getNodeId
argument_list|()
operator|==
literal|null
condition|?
literal|""
else|:
name|updatedNode
operator|.
name|getNodeId
argument_list|()
operator|.
name|getHost
argument_list|()
decl_stmt|;
name|NodeState
name|nodeState
init|=
name|updatedNode
operator|.
name|getNodeState
argument_list|()
decl_stmt|;
if|if
condition|(
name|hostname
operator|.
name|isEmpty
argument_list|()
operator|||
name|nodeState
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Ignoring incomplete update"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
name|printed
operator|++
operator|<
literal|10
condition|)
block|{
comment|// log the first few, but avoid overloading the logs for a full cluster
comment|// update
name|log
operator|.
name|debug
argument_list|(
literal|"Node \"{}\" is in state {}"
argument_list|,
name|hostname
argument_list|,
name|nodeState
argument_list|)
expr_stmt|;
block|}
comment|// update the node; this also creates an instance if needed
name|boolean
name|updated
init|=
name|nodemap
operator|.
name|updateNode
argument_list|(
name|hostname
argument_list|,
name|updatedNode
argument_list|)
decl_stmt|;
name|triggerReview
operator||=
name|updated
expr_stmt|;
block|}
return|return
name|triggerReview
return|;
block|}
comment|/**    * A container release request was issued    * @param container container submitted    */
DECL|method|onContainerReleaseSubmitted (Container container)
specifier|public
name|void
name|onContainerReleaseSubmitted
parameter_list|(
name|Container
name|container
parameter_list|)
block|{
name|NodeEntry
name|nodeEntry
init|=
name|getOrCreateNodeEntry
argument_list|(
name|container
argument_list|)
decl_stmt|;
name|nodeEntry
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
comment|/**    * App state notified of a container completed     * @param container completed container    * @return true if the node was queued    */
DECL|method|onReleaseCompleted (Container container)
specifier|public
name|boolean
name|onReleaseCompleted
parameter_list|(
name|Container
name|container
parameter_list|)
block|{
return|return
name|markContainerFinished
argument_list|(
name|container
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
name|ContainerOutcome
operator|.
name|Failed
argument_list|)
return|;
block|}
comment|/**    * App state notified of a container completed -but as    * it wasn't being released it is marked as failed    *    * @param container completed container    * @param shortLived was the container short lived?    * @param outcome    * @return true if the node is considered available for work    */
DECL|method|onFailedContainer (Container container, boolean shortLived, ContainerOutcome outcome)
specifier|public
name|boolean
name|onFailedContainer
parameter_list|(
name|Container
name|container
parameter_list|,
name|boolean
name|shortLived
parameter_list|,
name|ContainerOutcome
name|outcome
parameter_list|)
block|{
return|return
name|markContainerFinished
argument_list|(
name|container
argument_list|,
literal|false
argument_list|,
name|shortLived
argument_list|,
name|outcome
argument_list|)
return|;
block|}
comment|/**    * Mark a container finished; if it was released then that is treated    * differently. history is {@code touch()}-ed    *    *    * @param container completed container    * @param wasReleased was the container released?    * @param shortLived was the container short lived?    * @param outcome    * @return true if the node was queued    */
DECL|method|markContainerFinished (Container container, boolean wasReleased, boolean shortLived, ContainerOutcome outcome)
specifier|protected
specifier|synchronized
name|boolean
name|markContainerFinished
parameter_list|(
name|Container
name|container
parameter_list|,
name|boolean
name|wasReleased
parameter_list|,
name|boolean
name|shortLived
parameter_list|,
name|ContainerOutcome
name|outcome
parameter_list|)
block|{
name|NodeEntry
name|nodeEntry
init|=
name|getOrCreateNodeEntry
argument_list|(
name|container
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Finished container for node {}, released={}, shortlived={}"
argument_list|,
name|nodeEntry
operator|.
name|rolePriority
argument_list|,
name|wasReleased
argument_list|,
name|shortLived
argument_list|)
expr_stmt|;
name|boolean
name|available
decl_stmt|;
if|if
condition|(
name|shortLived
condition|)
block|{
name|nodeEntry
operator|.
name|onStartFailed
argument_list|()
expr_stmt|;
name|available
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|available
operator|=
name|nodeEntry
operator|.
name|containerCompleted
argument_list|(
name|wasReleased
argument_list|,
name|outcome
argument_list|)
expr_stmt|;
name|maybeQueueNodeForWork
argument_list|(
name|container
argument_list|,
name|nodeEntry
argument_list|,
name|available
argument_list|)
expr_stmt|;
block|}
name|touch
argument_list|()
expr_stmt|;
return|return
name|available
return|;
block|}
comment|/**    * If the node is marked as available; queue it for assignments.    * Unsynced: requires caller to be in a sync block.    * @param container completed container    * @param nodeEntry node    * @param available available flag    * @return true if the node was queued    */
DECL|method|maybeQueueNodeForWork (Container container, NodeEntry nodeEntry, boolean available)
specifier|private
name|boolean
name|maybeQueueNodeForWork
parameter_list|(
name|Container
name|container
parameter_list|,
name|NodeEntry
name|nodeEntry
parameter_list|,
name|boolean
name|available
parameter_list|)
block|{
if|if
condition|(
name|available
condition|)
block|{
comment|//node is free
name|nodeEntry
operator|.
name|setLastUsed
argument_list|(
name|now
argument_list|()
argument_list|)
expr_stmt|;
name|NodeInstance
name|ni
init|=
name|getOrCreateNodeInstance
argument_list|(
name|container
argument_list|)
decl_stmt|;
name|int
name|roleId
init|=
name|ContainerPriority
operator|.
name|extractRole
argument_list|(
name|container
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Node {} is now available for role id {}"
argument_list|,
name|ni
argument_list|,
name|roleId
argument_list|)
expr_stmt|;
name|listRecentNodesForRoleId
argument_list|(
name|roleId
argument_list|)
operator|.
name|addFirst
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
return|return
name|available
return|;
block|}
comment|/**    * Print the history to the log. This is for testing and diagnostics     */
DECL|method|dump ()
specifier|public
specifier|synchronized
name|void
name|dump
parameter_list|()
block|{
for|for
control|(
name|ProviderRole
name|role
range|:
name|providerRoles
control|)
block|{
name|log
operator|.
name|info
argument_list|(
name|role
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|NodeInstance
argument_list|>
name|instances
init|=
name|listRecentNodesForRoleId
argument_list|(
name|role
operator|.
name|id
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"  available: "
operator|+
name|instances
operator|.
name|size
argument_list|()
operator|+
literal|" "
operator|+
name|SliderUtils
operator|.
name|joinWithInnerSeparator
argument_list|(
literal|" "
argument_list|,
name|instances
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Nodes in Cluster: {}"
argument_list|,
name|getClusterSize
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|NodeInstance
name|node
range|:
name|nodemap
operator|.
name|values
argument_list|()
control|)
block|{
name|log
operator|.
name|info
argument_list|(
name|node
operator|.
name|toFullString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Build the mapping entry for persisting to the role history    * @return a mapping object    */
DECL|method|buildMappingForHistoryFile ()
specifier|public
specifier|synchronized
name|Map
argument_list|<
name|CharSequence
argument_list|,
name|Integer
argument_list|>
name|buildMappingForHistoryFile
parameter_list|()
block|{
name|Map
argument_list|<
name|CharSequence
argument_list|,
name|Integer
argument_list|>
name|mapping
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|getRoleSize
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|ProviderRole
name|role
range|:
name|providerRoles
control|)
block|{
name|mapping
operator|.
name|put
argument_list|(
name|role
operator|.
name|name
argument_list|,
name|role
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
return|return
name|mapping
return|;
block|}
comment|/**    * Get a clone of the available list    * @param role role index    * @return a clone of the list    */
annotation|@
name|VisibleForTesting
DECL|method|cloneRecentNodeList (int role)
specifier|public
name|List
argument_list|<
name|NodeInstance
argument_list|>
name|cloneRecentNodeList
parameter_list|(
name|int
name|role
parameter_list|)
block|{
return|return
operator|new
name|LinkedList
argument_list|<>
argument_list|(
name|listRecentNodesForRoleId
argument_list|(
name|role
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get a snapshot of the outstanding placed request list    * @return a list of the requests outstanding at the time of requesting    */
annotation|@
name|VisibleForTesting
DECL|method|listPlacedRequests ()
specifier|public
name|List
argument_list|<
name|OutstandingRequest
argument_list|>
name|listPlacedRequests
parameter_list|()
block|{
return|return
name|outstandingRequests
operator|.
name|listPlacedRequests
argument_list|()
return|;
block|}
comment|/**    * Get a snapshot of the outstanding placed request list    * @return a list of the requests outstanding at the time of requesting    */
annotation|@
name|VisibleForTesting
DECL|method|listOpenRequests ()
specifier|public
name|List
argument_list|<
name|OutstandingRequest
argument_list|>
name|listOpenRequests
parameter_list|()
block|{
return|return
name|outstandingRequests
operator|.
name|listOpenRequests
argument_list|()
return|;
block|}
comment|/**    * Escalate operation as triggered by external timer.    * @return a (usually empty) list of cancel/request operations.    */
DECL|method|escalateOutstandingRequests ()
specifier|public
specifier|synchronized
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|escalateOutstandingRequests
parameter_list|()
block|{
return|return
name|outstandingRequests
operator|.
name|escalateOutstandingRequests
argument_list|(
name|now
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Escalate operation as triggered by external timer.    * @return a (usually empty) list of cancel/request operations.    */
DECL|method|cancelOutstandingAARequests ()
specifier|public
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|cancelOutstandingAARequests
parameter_list|()
block|{
return|return
name|outstandingRequests
operator|.
name|cancelOutstandingAARequests
argument_list|()
return|;
block|}
comment|/**    * Cancel a number of outstanding requests for a role -that is, not    * actual containers, just requests for new ones.    * @param role role    * @param toCancel number to cancel    * @return a list of cancellable operations.    */
DECL|method|cancelRequestsForRole (RoleStatus role, int toCancel)
specifier|public
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|cancelRequestsForRole
parameter_list|(
name|RoleStatus
name|role
parameter_list|,
name|int
name|toCancel
parameter_list|)
block|{
return|return
name|role
operator|.
name|isAntiAffinePlacement
argument_list|()
condition|?
name|cancelRequestsForAARole
argument_list|(
name|role
argument_list|,
name|toCancel
argument_list|)
else|:
name|cancelRequestsForSimpleRole
argument_list|(
name|role
argument_list|,
name|toCancel
argument_list|)
return|;
block|}
comment|/**    * Build the list of requests to cancel from the outstanding list.    * @param role role    * @param toCancel number to cancel    * @return a list of cancellable operations.    */
DECL|method|cancelRequestsForSimpleRole (RoleStatus role, int toCancel)
specifier|private
specifier|synchronized
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|cancelRequestsForSimpleRole
parameter_list|(
name|RoleStatus
name|role
parameter_list|,
name|int
name|toCancel
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|toCancel
operator|>
literal|0
argument_list|,
literal|"trying to cancel invalid number of requests: "
operator|+
name|toCancel
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|toCancel
argument_list|)
decl_stmt|;
comment|// first scan through the unplaced request list to find all of a role
name|int
name|roleId
init|=
name|role
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|OutstandingRequest
argument_list|>
name|requests
init|=
name|outstandingRequests
operator|.
name|extractOpenRequestsForRole
argument_list|(
name|roleId
argument_list|,
name|toCancel
argument_list|)
decl_stmt|;
comment|// are there any left?
name|int
name|remaining
init|=
name|toCancel
operator|-
name|requests
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// ask for some placed nodes
name|requests
operator|.
name|addAll
argument_list|(
name|outstandingRequests
operator|.
name|extractPlacedRequestsForRole
argument_list|(
name|roleId
argument_list|,
name|remaining
argument_list|)
argument_list|)
expr_stmt|;
comment|// build cancellations
for|for
control|(
name|OutstandingRequest
name|request
range|:
name|requests
control|)
block|{
name|results
operator|.
name|add
argument_list|(
name|request
operator|.
name|createCancelOperation
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
comment|/**    * Build the list of requests to cancel for an AA role. This reduces the number    * of outstanding pending requests first, then cancels any active request,    * before finally asking for any placed containers    * @param role role    * @param toCancel number to cancel    * @return a list of cancellable operations.    */
DECL|method|cancelRequestsForAARole (RoleStatus role, int toCancel)
specifier|private
specifier|synchronized
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|cancelRequestsForAARole
parameter_list|(
name|RoleStatus
name|role
parameter_list|,
name|int
name|toCancel
parameter_list|)
block|{
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|toCancel
argument_list|)
decl_stmt|;
name|int
name|roleId
init|=
name|role
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|OutstandingRequest
argument_list|>
name|requests
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|toCancel
argument_list|)
decl_stmt|;
comment|// there may be pending requests which can be cancelled here
name|long
name|pending
init|=
name|role
operator|.
name|getAAPending
argument_list|()
decl_stmt|;
if|if
condition|(
name|pending
operator|>
literal|0
condition|)
block|{
comment|// there are some pending ones which can be cancelled first
name|long
name|pendingToCancel
init|=
name|Math
operator|.
name|min
argument_list|(
name|pending
argument_list|,
name|toCancel
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Cancelling {} pending AA allocations, leaving {}"
argument_list|,
name|toCancel
argument_list|,
name|pendingToCancel
argument_list|)
expr_stmt|;
name|role
operator|.
name|setAAPending
argument_list|(
name|pending
operator|-
name|pendingToCancel
argument_list|)
expr_stmt|;
name|toCancel
operator|-=
name|pendingToCancel
expr_stmt|;
block|}
if|if
condition|(
name|toCancel
operator|>
literal|0
operator|&&
name|role
operator|.
name|isAARequestOutstanding
argument_list|()
condition|)
block|{
comment|// not enough
name|log
operator|.
name|info
argument_list|(
literal|"Cancelling current AA request"
argument_list|)
expr_stmt|;
comment|// find the single entry which may be running
name|requests
operator|=
name|outstandingRequests
operator|.
name|extractOpenRequestsForRole
argument_list|(
name|roleId
argument_list|,
name|toCancel
argument_list|)
expr_stmt|;
name|role
operator|.
name|cancelOutstandingAARequest
argument_list|()
expr_stmt|;
name|toCancel
operator|--
expr_stmt|;
block|}
comment|// ask for some excess nodes
if|if
condition|(
name|toCancel
operator|>
literal|0
condition|)
block|{
name|requests
operator|.
name|addAll
argument_list|(
name|outstandingRequests
operator|.
name|extractPlacedRequestsForRole
argument_list|(
name|roleId
argument_list|,
name|toCancel
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// build cancellations
for|for
control|(
name|OutstandingRequest
name|request
range|:
name|requests
control|)
block|{
name|results
operator|.
name|add
argument_list|(
name|request
operator|.
name|createCancelOperation
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
block|}
end_class

end_unit

