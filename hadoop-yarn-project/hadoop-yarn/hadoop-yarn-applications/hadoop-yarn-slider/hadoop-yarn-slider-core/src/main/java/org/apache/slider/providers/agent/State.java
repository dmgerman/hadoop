begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.slider.providers.agent
package|package
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|providers
operator|.
name|agent
package|;
end_package

begin_comment
comment|/** The states a component instance can be. */
end_comment

begin_enum
DECL|enum|State
specifier|public
enum|enum
name|State
block|{
DECL|enumConstant|INIT
name|INIT
block|,
comment|// Not installed
DECL|enumConstant|INSTALLING
name|INSTALLING
block|,
comment|// Being installed
DECL|enumConstant|INSTALLED
name|INSTALLED
block|,
comment|// Installed (or stopped)
DECL|enumConstant|STARTING
name|STARTING
block|,
comment|// Starting
DECL|enumConstant|STARTED
name|STARTED
block|,
comment|// Started
DECL|enumConstant|INSTALL_FAILED
name|INSTALL_FAILED
block|,
comment|// Install failed, start failure in INSTALLED
DECL|enumConstant|UPGRADING
name|UPGRADING
block|,
comment|// Undergoing upgrade, perform necessary pre-upgrade steps
DECL|enumConstant|UPGRADED
name|UPGRADED
block|,
comment|// Pre-upgrade steps completed
DECL|enumConstant|STOPPING
name|STOPPING
block|,
comment|// Stop has been issued
DECL|enumConstant|STOPPED
name|STOPPED
block|,
comment|// Agent has stopped
DECL|enumConstant|TERMINATING
name|TERMINATING
block|;
comment|// Terminate signal to ask the agent to kill itself
comment|// No need for state TERMINATED (as the agent is dead by then)
comment|/**    * Indicates whether or not it is a valid state to produce a command.    *    * @return true if command can be issued for this state.    */
DECL|method|canIssueCommands ()
specifier|public
name|boolean
name|canIssueCommands
parameter_list|()
block|{
switch|switch
condition|(
name|this
condition|)
block|{
case|case
name|INSTALLING
case|:
case|case
name|STARTING
case|:
case|case
name|UPGRADING
case|:
case|case
name|STOPPING
case|:
case|case
name|TERMINATING
case|:
return|return
literal|false
return|;
default|default:
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Returns valid command in this state.    *    * @return command allowed in this state.    */
DECL|method|getSupportedCommand ()
specifier|public
name|Command
name|getSupportedCommand
parameter_list|()
block|{
return|return
name|getSupportedCommand
argument_list|(
literal|false
argument_list|)
return|;
block|}
DECL|method|getSupportedCommand (boolean isInUpgradeMode)
specifier|public
name|Command
name|getSupportedCommand
parameter_list|(
name|boolean
name|isInUpgradeMode
parameter_list|)
block|{
return|return
name|getSupportedCommand
argument_list|(
name|isInUpgradeMode
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|getSupportedCommand (boolean isInUpgradeMode, boolean stopInitiated)
specifier|public
name|Command
name|getSupportedCommand
parameter_list|(
name|boolean
name|isInUpgradeMode
parameter_list|,
name|boolean
name|stopInitiated
parameter_list|)
block|{
switch|switch
condition|(
name|this
condition|)
block|{
case|case
name|INIT
case|:
case|case
name|INSTALL_FAILED
case|:
return|return
name|Command
operator|.
name|INSTALL
return|;
case|case
name|INSTALLED
case|:
return|return
name|Command
operator|.
name|START
return|;
case|case
name|STARTED
case|:
return|return
name|isInUpgradeMode
condition|?
name|Command
operator|.
name|UPGRADE
else|:
operator|(
name|stopInitiated
operator|)
condition|?
name|Command
operator|.
name|STOP
else|:
name|Command
operator|.
name|NOP
return|;
case|case
name|UPGRADED
case|:
return|return
name|Command
operator|.
name|STOP
return|;
case|case
name|STOPPED
case|:
return|return
name|Command
operator|.
name|TERMINATE
return|;
default|default:
return|return
name|Command
operator|.
name|NOP
return|;
block|}
block|}
comment|/**    * Returns next state based on the command result.    *    * @return next state.    */
DECL|method|getNextState (CommandResult result)
specifier|public
name|State
name|getNextState
parameter_list|(
name|CommandResult
name|result
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|IN_PROGRESS
case|:
if|if
condition|(
name|this
operator|==
name|State
operator|.
name|INSTALLING
operator|||
name|this
operator|==
name|State
operator|.
name|STARTING
operator|||
name|this
operator|==
name|State
operator|.
name|UPGRADING
operator|||
name|this
operator|==
name|State
operator|.
name|STOPPING
operator|||
name|this
operator|==
name|State
operator|.
name|TERMINATING
condition|)
block|{
return|return
name|this
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|result
operator|+
literal|" is not valid for "
operator|+
name|this
argument_list|)
throw|;
block|}
case|case
name|COMPLETED
case|:
if|if
condition|(
name|this
operator|==
name|State
operator|.
name|INSTALLING
condition|)
block|{
return|return
name|State
operator|.
name|INSTALLED
return|;
block|}
elseif|else
if|if
condition|(
name|this
operator|==
name|State
operator|.
name|STARTING
condition|)
block|{
return|return
name|State
operator|.
name|STARTED
return|;
block|}
elseif|else
if|if
condition|(
name|this
operator|==
name|State
operator|.
name|UPGRADING
condition|)
block|{
return|return
name|State
operator|.
name|UPGRADED
return|;
block|}
elseif|else
if|if
condition|(
name|this
operator|==
name|State
operator|.
name|STOPPING
condition|)
block|{
return|return
name|State
operator|.
name|STOPPED
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|result
operator|+
literal|" is not valid for "
operator|+
name|this
argument_list|)
throw|;
block|}
case|case
name|FAILED
case|:
if|if
condition|(
name|this
operator|==
name|State
operator|.
name|INSTALLING
condition|)
block|{
return|return
name|State
operator|.
name|INSTALL_FAILED
return|;
block|}
elseif|else
if|if
condition|(
name|this
operator|==
name|State
operator|.
name|STARTING
condition|)
block|{
return|return
name|State
operator|.
name|INSTALLED
return|;
block|}
elseif|else
if|if
condition|(
name|this
operator|==
name|State
operator|.
name|UPGRADING
condition|)
block|{
comment|// if pre-upgrade failed, force stop now, so mark it upgraded
comment|// what other options can be exposed to app owner?
return|return
name|State
operator|.
name|UPGRADED
return|;
block|}
elseif|else
if|if
condition|(
name|this
operator|==
name|State
operator|.
name|STOPPING
condition|)
block|{
comment|// if stop fails, force mark it stopped (and let container terminate)
return|return
name|State
operator|.
name|STOPPED
return|;
block|}
elseif|else
if|if
condition|(
name|this
operator|==
name|State
operator|.
name|STOPPED
condition|)
block|{
comment|// if in stopped state, force mark it as terminating
return|return
name|State
operator|.
name|TERMINATING
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|result
operator|+
literal|" is not valid for "
operator|+
name|this
argument_list|)
throw|;
block|}
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Bad command result "
operator|+
name|result
argument_list|)
throw|;
block|}
block|}
comment|/**    * Returns next state based on the command.    *    * @return next state.    */
DECL|method|getNextState (Command command)
specifier|public
name|State
name|getNextState
parameter_list|(
name|Command
name|command
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|INSTALL
case|:
if|if
condition|(
name|this
operator|==
name|State
operator|.
name|INIT
operator|||
name|this
operator|==
name|State
operator|.
name|INSTALL_FAILED
condition|)
block|{
return|return
name|State
operator|.
name|INSTALLING
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|command
operator|+
literal|" is not valid for "
operator|+
name|this
argument_list|)
throw|;
block|}
case|case
name|INSTALL_ADDON
case|:
if|if
condition|(
name|this
operator|==
name|State
operator|.
name|INIT
operator|||
name|this
operator|==
name|State
operator|.
name|INSTALL_FAILED
condition|)
block|{
return|return
name|State
operator|.
name|INSTALLING
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|command
operator|+
literal|" is not valid for "
operator|+
name|this
argument_list|)
throw|;
block|}
case|case
name|START
case|:
if|if
condition|(
name|this
operator|==
name|State
operator|.
name|INSTALLED
condition|)
block|{
return|return
name|State
operator|.
name|STARTING
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|command
operator|+
literal|" is not valid for "
operator|+
name|this
argument_list|)
throw|;
block|}
case|case
name|UPGRADE
case|:
if|if
condition|(
name|this
operator|==
name|State
operator|.
name|STARTED
condition|)
block|{
return|return
name|State
operator|.
name|UPGRADING
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|command
operator|+
literal|" is not valid for "
operator|+
name|this
argument_list|)
throw|;
block|}
case|case
name|STOP
case|:
if|if
condition|(
name|this
operator|==
name|State
operator|.
name|STARTED
operator|||
name|this
operator|==
name|State
operator|.
name|UPGRADED
condition|)
block|{
return|return
name|State
operator|.
name|STOPPING
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|command
operator|+
literal|" is not valid for "
operator|+
name|this
argument_list|)
throw|;
block|}
case|case
name|TERMINATE
case|:
if|if
condition|(
name|this
operator|==
name|State
operator|.
name|STOPPED
condition|)
block|{
return|return
name|State
operator|.
name|TERMINATING
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|command
operator|+
literal|" is not valid for "
operator|+
name|this
argument_list|)
throw|;
block|}
case|case
name|NOP
case|:
return|return
name|this
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Bad command "
operator|+
name|command
argument_list|)
throw|;
block|}
block|}
DECL|method|couldHaveIssued (Command command)
specifier|public
name|boolean
name|couldHaveIssued
parameter_list|(
name|Command
name|command
parameter_list|)
block|{
if|if
condition|(
operator|(
name|this
operator|==
name|State
operator|.
name|INSTALLING
operator|&&
name|command
operator|==
name|Command
operator|.
name|INSTALL
operator|)
operator|||
operator|(
name|this
operator|==
name|State
operator|.
name|STARTING
operator|&&
name|command
operator|==
name|Command
operator|.
name|START
operator|)
operator|||
operator|(
name|this
operator|==
name|State
operator|.
name|UPGRADING
operator|&&
name|command
operator|==
name|Command
operator|.
name|UPGRADE
operator|)
operator|||
operator|(
name|this
operator|==
name|State
operator|.
name|STOPPING
operator|&&
operator|(
name|command
operator|==
name|Command
operator|.
name|STOP
operator|||
name|command
operator|==
name|Command
operator|.
name|NOP
operator|)
operator|)
operator|||
operator|(
name|this
operator|==
name|State
operator|.
name|TERMINATING
operator|&&
name|command
operator|==
name|Command
operator|.
name|TERMINATE
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
end_enum

end_unit

