begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.slider.server.appmaster.state
package|package
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|state
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Priority
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|api
operator|.
name|AMRMClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|api
operator|.
name|InvalidContainerRequestException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|Resources
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|SliderUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|operations
operator|.
name|CancelSingleRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * Tracks an outstanding request. This is used to correlate an allocation response  * with the node and role used in the request.  *<p>  * The node identifier may be null -which indicates that a request was made without  * a specific target node  *<p>  * Equality and the hash code are based<i>only</i> on the role and hostname,  * which are fixed in the constructor. This means that a simple   * instance constructed with (role, hostname) can be used to look up  * a complete request instance in the {@link OutstandingRequestTracker} map  */
end_comment

begin_class
DECL|class|OutstandingRequest
specifier|public
specifier|final
class|class
name|OutstandingRequest
extends|extends
name|RoleHostnamePair
block|{
DECL|field|log
specifier|protected
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|OutstandingRequest
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Node the request is for -may be null    */
DECL|field|node
specifier|public
specifier|final
name|NodeInstance
name|node
decl_stmt|;
comment|/**    * A list of all possible nodes to list in an AA request. For a non-AA    * request where {@link #node} is set, element 0 of the list is the same    * value.    */
DECL|field|nodes
specifier|public
specifier|final
name|List
argument_list|<
name|NodeInstance
argument_list|>
name|nodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|/**    * Optional label. This is cached as the request option (explicit-location + label) is forbidden,    * yet the label needs to be retained for escalation.    */
DECL|field|label
specifier|public
name|String
name|label
decl_stmt|;
comment|/**    * Requested time in millis.    *<p>    * Only valid after {@link #buildContainerRequest(Resource, RoleStatus, long)}    */
DECL|field|issuedRequest
specifier|private
name|AMRMClient
operator|.
name|ContainerRequest
name|issuedRequest
decl_stmt|;
comment|/**    * Requested time in millis.    *<p>    * Only valid after {@link #buildContainerRequest(Resource, RoleStatus, long)}    */
DECL|field|requestedTimeMillis
specifier|private
name|long
name|requestedTimeMillis
decl_stmt|;
comment|/**    * Time in millis after which escalation should be triggered..    *<p>    * Only valid after {@link #buildContainerRequest(Resource, RoleStatus, long)}    */
DECL|field|escalationTimeoutMillis
specifier|private
name|long
name|escalationTimeoutMillis
decl_stmt|;
comment|/**    * Has the placement request been escalated?    */
DECL|field|escalated
specifier|private
name|boolean
name|escalated
decl_stmt|;
comment|/**    * Flag to indicate that escalation is allowed    */
DECL|field|mayEscalate
specifier|private
name|boolean
name|mayEscalate
decl_stmt|;
comment|/**    * Priority of request; only valid after the request is built up    */
DECL|field|priority
specifier|private
name|int
name|priority
init|=
operator|-
literal|1
decl_stmt|;
comment|/**    * Is this an Anti-affine request which should be cancelled on    * a cluster resize?    */
DECL|field|antiAffine
specifier|private
name|boolean
name|antiAffine
init|=
literal|false
decl_stmt|;
comment|/**    * Create a request    * @param roleId role    * @param node node -can be null    */
DECL|method|OutstandingRequest (int roleId, NodeInstance node)
specifier|public
name|OutstandingRequest
parameter_list|(
name|int
name|roleId
parameter_list|,
name|NodeInstance
name|node
parameter_list|)
block|{
name|super
argument_list|(
name|roleId
argument_list|,
name|node
operator|!=
literal|null
condition|?
name|node
operator|.
name|hostname
else|:
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|nodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create an outstanding request with the given role and hostname    * Important: this is useful only for map lookups -the other constructor    * with the NodeInstance parameter is needed to generate node-specific    * container requests    * @param roleId role    * @param hostname hostname    */
DECL|method|OutstandingRequest (int roleId, String hostname)
specifier|public
name|OutstandingRequest
parameter_list|(
name|int
name|roleId
parameter_list|,
name|String
name|hostname
parameter_list|)
block|{
name|super
argument_list|(
name|roleId
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|this
operator|.
name|node
operator|=
literal|null
expr_stmt|;
block|}
comment|/**    * Create an Anti-affine reques, including all listed nodes (there must be one)    * as targets.    * @param roleId role    * @param nodes list of nodes    */
DECL|method|OutstandingRequest (int roleId, List<NodeInstance> nodes)
specifier|public
name|OutstandingRequest
parameter_list|(
name|int
name|roleId
parameter_list|,
name|List
argument_list|<
name|NodeInstance
argument_list|>
name|nodes
parameter_list|)
block|{
name|super
argument_list|(
name|roleId
argument_list|,
name|nodes
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|hostname
argument_list|)
expr_stmt|;
name|this
operator|.
name|node
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|antiAffine
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|nodes
operator|.
name|addAll
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
block|}
comment|/**    * Is the request located in the cluster, that is: does it have a node.    * @return true if a node instance was supplied in the constructor    */
DECL|method|isLocated ()
specifier|public
name|boolean
name|isLocated
parameter_list|()
block|{
return|return
name|node
operator|!=
literal|null
return|;
block|}
DECL|method|getRequestedTimeMillis ()
specifier|public
name|long
name|getRequestedTimeMillis
parameter_list|()
block|{
return|return
name|requestedTimeMillis
return|;
block|}
DECL|method|getEscalationTimeoutMillis ()
specifier|public
name|long
name|getEscalationTimeoutMillis
parameter_list|()
block|{
return|return
name|escalationTimeoutMillis
return|;
block|}
DECL|method|isEscalated ()
specifier|public
specifier|synchronized
name|boolean
name|isEscalated
parameter_list|()
block|{
return|return
name|escalated
return|;
block|}
DECL|method|mayEscalate ()
specifier|public
name|boolean
name|mayEscalate
parameter_list|()
block|{
return|return
name|mayEscalate
return|;
block|}
DECL|method|getIssuedRequest ()
specifier|public
name|AMRMClient
operator|.
name|ContainerRequest
name|getIssuedRequest
parameter_list|()
block|{
return|return
name|issuedRequest
return|;
block|}
DECL|method|getPriority ()
specifier|public
name|int
name|getPriority
parameter_list|()
block|{
return|return
name|priority
return|;
block|}
DECL|method|isAntiAffine ()
specifier|public
name|boolean
name|isAntiAffine
parameter_list|()
block|{
return|return
name|antiAffine
return|;
block|}
DECL|method|setAntiAffine (boolean antiAffine)
specifier|public
name|void
name|setAntiAffine
parameter_list|(
name|boolean
name|antiAffine
parameter_list|)
block|{
name|this
operator|.
name|antiAffine
operator|=
name|antiAffine
expr_stmt|;
block|}
comment|/**    * Build a container request.    *<p>    *  The value of {@link #node} is used to direct a lot of policy. If null,    *  placement is relaxed.    *  If not null, the choice of whether to use the suggested node    *  is based on the placement policy and failure history.    *<p>    * If the request has an address, it is set in the container request    * (with a flag to enable relaxed priorities).    *<p>    * This operation sets the requested time flag, used for tracking timeouts    * on outstanding requests    * @param resource resource    * @param role role    * @param time time in millis to record as request time    * @return the request to raise    */
DECL|method|buildContainerRequest ( Resource resource, RoleStatus role, long time)
specifier|public
specifier|synchronized
name|AMRMClient
operator|.
name|ContainerRequest
name|buildContainerRequest
parameter_list|(
name|Resource
name|resource
parameter_list|,
name|RoleStatus
name|role
parameter_list|,
name|long
name|time
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|resource
operator|!=
literal|null
argument_list|,
literal|"null `resource` arg"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|role
operator|!=
literal|null
argument_list|,
literal|"null `role` arg"
argument_list|)
expr_stmt|;
comment|// cache label for escalation
name|label
operator|=
name|role
operator|.
name|getLabelExpression
argument_list|()
expr_stmt|;
name|requestedTimeMillis
operator|=
name|time
expr_stmt|;
name|escalationTimeoutMillis
operator|=
name|time
operator|+
name|role
operator|.
name|getPlacementTimeoutSeconds
argument_list|()
operator|*
literal|1000
expr_stmt|;
name|String
index|[]
name|hosts
decl_stmt|;
name|boolean
name|relaxLocality
decl_stmt|;
name|boolean
name|strictPlacement
init|=
name|role
operator|.
name|isStrictPlacement
argument_list|()
decl_stmt|;
name|NodeInstance
name|target
init|=
name|this
operator|.
name|node
decl_stmt|;
name|String
name|nodeLabels
decl_stmt|;
if|if
condition|(
name|isAntiAffine
argument_list|()
condition|)
block|{
name|int
name|size
init|=
name|nodes
operator|.
name|size
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Creating anti-affine request across {} nodes; first node = {}"
argument_list|,
name|size
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|hosts
operator|=
operator|new
name|String
index|[
name|size
index|]
expr_stmt|;
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
name|size
operator|*
literal|16
argument_list|)
decl_stmt|;
name|int
name|c
init|=
literal|0
decl_stmt|;
for|for
control|(
name|NodeInstance
name|nodeInstance
range|:
name|nodes
control|)
block|{
name|hosts
index|[
name|c
operator|++
index|]
operator|=
name|nodeInstance
operator|.
name|hostname
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|nodeInstance
operator|.
name|hostname
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"Full host list: [ {}]"
argument_list|,
name|builder
argument_list|)
expr_stmt|;
name|escalated
operator|=
literal|false
expr_stmt|;
name|mayEscalate
operator|=
literal|false
expr_stmt|;
name|relaxLocality
operator|=
literal|false
expr_stmt|;
name|nodeLabels
operator|=
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target
operator|!=
literal|null
condition|)
block|{
comment|// placed request. Hostname is used in request
name|hosts
operator|=
operator|new
name|String
index|[
literal|1
index|]
expr_stmt|;
name|hosts
index|[
literal|0
index|]
operator|=
name|target
operator|.
name|hostname
expr_stmt|;
comment|// and locality flag is set to false; Slider will decide when
comment|// to relax things
name|relaxLocality
operator|=
literal|false
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Submitting request for container on {}"
argument_list|,
name|hosts
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// enable escalation for all but strict placements.
name|escalated
operator|=
literal|false
expr_stmt|;
name|mayEscalate
operator|=
operator|!
name|strictPlacement
expr_stmt|;
name|nodeLabels
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
comment|// no hosts
name|hosts
operator|=
literal|null
expr_stmt|;
comment|// relax locality is mandatory on an unconstrained placement
name|relaxLocality
operator|=
literal|true
expr_stmt|;
comment|// declare that the the placement is implicitly escalated.
name|escalated
operator|=
literal|true
expr_stmt|;
comment|// and forbid it happening
name|mayEscalate
operator|=
literal|false
expr_stmt|;
name|nodeLabels
operator|=
name|label
expr_stmt|;
block|}
name|Priority
name|pri
init|=
name|ContainerPriority
operator|.
name|createPriority
argument_list|(
name|roleId
argument_list|,
operator|!
name|relaxLocality
argument_list|)
decl_stmt|;
name|priority
operator|=
name|pri
operator|.
name|getPriority
argument_list|()
expr_stmt|;
name|issuedRequest
operator|=
operator|new
name|AMRMClient
operator|.
name|ContainerRequest
argument_list|(
name|resource
argument_list|,
name|hosts
argument_list|,
literal|null
argument_list|,
name|pri
argument_list|,
name|relaxLocality
argument_list|,
name|nodeLabels
argument_list|)
expr_stmt|;
name|validate
argument_list|()
expr_stmt|;
return|return
name|issuedRequest
return|;
block|}
comment|/**    * Build an escalated container request, updating {@link #issuedRequest} with    * the new value.    * @return the new container request, which has the same resource and label requirements    * as the original one, and the same host, but: relaxed placement, and a changed priority    * so as to place it into the relaxed list.    */
DECL|method|escalate ()
specifier|public
specifier|synchronized
name|AMRMClient
operator|.
name|ContainerRequest
name|escalate
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|issuedRequest
argument_list|,
literal|"cannot escalate if request not issued "
operator|+
name|this
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Escalating {}"
argument_list|,
name|this
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|escalated
operator|=
literal|true
expr_stmt|;
comment|// this is now the priority
comment|// it is tagged as unlocated because it needs to go into a different
comment|// set of outstanding requests from the strict placements
name|Priority
name|pri
init|=
name|ContainerPriority
operator|.
name|createPriority
argument_list|(
name|roleId
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// update the field
name|priority
operator|=
name|pri
operator|.
name|getPriority
argument_list|()
expr_stmt|;
name|String
index|[]
name|nodes
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|issuedRequestNodes
init|=
name|issuedRequest
operator|.
name|getNodes
argument_list|()
decl_stmt|;
if|if
condition|(
name|SliderUtils
operator|.
name|isUnset
argument_list|(
name|label
argument_list|)
operator|&&
name|issuedRequestNodes
operator|!=
literal|null
condition|)
block|{
name|nodes
operator|=
name|issuedRequestNodes
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|issuedRequestNodes
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodes
operator|=
literal|null
expr_stmt|;
block|}
name|issuedRequest
operator|=
operator|new
name|AMRMClient
operator|.
name|ContainerRequest
argument_list|(
name|issuedRequest
operator|.
name|getCapability
argument_list|()
argument_list|,
name|nodes
argument_list|,
literal|null
argument_list|,
name|pri
argument_list|,
literal|true
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|validate
argument_list|()
expr_stmt|;
return|return
name|issuedRequest
return|;
block|}
comment|/**    * Mark the request as completed (or canceled).    *<p>    *   Current action: if a node is defined, its request count is decremented    */
DECL|method|completed ()
specifier|public
name|void
name|completed
parameter_list|()
block|{
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|node
operator|.
name|getOrCreate
argument_list|(
name|roleId
argument_list|)
operator|.
name|requestCompleted
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Query to see if the request is available and ready to be escalated    * @param time time to check against    * @return true if escalation should begin    */
DECL|method|shouldEscalate (long time)
specifier|public
specifier|synchronized
name|boolean
name|shouldEscalate
parameter_list|(
name|long
name|time
parameter_list|)
block|{
return|return
name|mayEscalate
operator|&&
operator|!
name|escalated
operator|&&
name|issuedRequest
operator|!=
literal|null
operator|&&
name|escalationTimeoutMillis
operator|<
name|time
return|;
block|}
comment|/**    * Query for the resource requirements matching; always false before a request is issued    * @param resource    * @return    */
DECL|method|resourceRequirementsMatch (Resource resource)
specifier|public
specifier|synchronized
name|boolean
name|resourceRequirementsMatch
parameter_list|(
name|Resource
name|resource
parameter_list|)
block|{
return|return
name|issuedRequest
operator|!=
literal|null
operator|&&
name|Resources
operator|.
name|fitsIn
argument_list|(
name|issuedRequest
operator|.
name|getCapability
argument_list|()
argument_list|,
name|resource
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|boolean
name|requestHasLocation
init|=
name|ContainerPriority
operator|.
name|hasLocation
argument_list|(
name|getPriority
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"OutstandingRequest{"
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"roleId="
argument_list|)
operator|.
name|append
argument_list|(
name|roleId
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", hostname='"
argument_list|)
operator|.
name|append
argument_list|(
name|hostname
argument_list|)
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|", node="
argument_list|)
operator|.
name|append
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", hasLocation="
argument_list|)
operator|.
name|append
argument_list|(
name|requestHasLocation
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", label="
argument_list|)
operator|.
name|append
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", requestedTimeMillis="
argument_list|)
operator|.
name|append
argument_list|(
name|requestedTimeMillis
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", mayEscalate="
argument_list|)
operator|.
name|append
argument_list|(
name|mayEscalate
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", escalated="
argument_list|)
operator|.
name|append
argument_list|(
name|escalated
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", escalationTimeoutMillis="
argument_list|)
operator|.
name|append
argument_list|(
name|escalationTimeoutMillis
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", issuedRequest="
argument_list|)
operator|.
name|append
argument_list|(
name|issuedRequest
operator|!=
literal|null
condition|?
name|SliderUtils
operator|.
name|requestToString
argument_list|(
name|issuedRequest
argument_list|)
else|:
literal|"(null)"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Create a cancel operation    * @return an operation that can be used to cancel the request    */
DECL|method|createCancelOperation ()
specifier|public
name|CancelSingleRequest
name|createCancelOperation
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|issuedRequest
operator|!=
literal|null
argument_list|,
literal|"No issued request to cancel"
argument_list|)
expr_stmt|;
return|return
operator|new
name|CancelSingleRequest
argument_list|(
name|issuedRequest
argument_list|)
return|;
block|}
comment|/**    * Valid if a node label expression specified on container request is valid or    * not. Mimics the logic in AMRMClientImpl, so can be used for preflight checking    * and in mock tests    *    */
DECL|method|validate ()
specifier|public
name|void
name|validate
parameter_list|()
throws|throws
name|InvalidContainerRequestException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|issuedRequest
argument_list|,
literal|"request has not yet been built up"
argument_list|)
expr_stmt|;
name|AMRMClient
operator|.
name|ContainerRequest
name|containerRequest
init|=
name|issuedRequest
decl_stmt|;
name|String
name|requestDetails
init|=
name|this
operator|.
name|toString
argument_list|()
decl_stmt|;
name|validateContainerRequest
argument_list|(
name|containerRequest
argument_list|,
name|priority
argument_list|,
name|requestDetails
argument_list|)
expr_stmt|;
block|}
comment|/**    * Inner Validation logic for container request    * @param containerRequest request    * @param priority raw priority of role    * @param requestDetails details for error messages    */
annotation|@
name|VisibleForTesting
DECL|method|validateContainerRequest (AMRMClient.ContainerRequest containerRequest, int priority, String requestDetails)
specifier|public
specifier|static
name|void
name|validateContainerRequest
parameter_list|(
name|AMRMClient
operator|.
name|ContainerRequest
name|containerRequest
parameter_list|,
name|int
name|priority
parameter_list|,
name|String
name|requestDetails
parameter_list|)
block|{
name|String
name|exp
init|=
name|containerRequest
operator|.
name|getNodeLabelExpression
argument_list|()
decl_stmt|;
name|boolean
name|hasRacks
init|=
name|containerRequest
operator|.
name|getRacks
argument_list|()
operator|!=
literal|null
operator|&&
operator|(
operator|!
name|containerRequest
operator|.
name|getRacks
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
decl_stmt|;
name|boolean
name|hasNodes
init|=
name|containerRequest
operator|.
name|getNodes
argument_list|()
operator|!=
literal|null
operator|&&
operator|(
operator|!
name|containerRequest
operator|.
name|getNodes
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
decl_stmt|;
name|boolean
name|hasLabel
init|=
name|SliderUtils
operator|.
name|isSet
argument_list|(
name|exp
argument_list|)
decl_stmt|;
comment|// Don't support specifying>= 2 node labels in a node label expression now
if|if
condition|(
name|hasLabel
operator|&&
operator|(
name|exp
operator|.
name|contains
argument_list|(
literal|"&&"
argument_list|)
operator|||
name|exp
operator|.
name|contains
argument_list|(
literal|"||"
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|InvalidContainerRequestException
argument_list|(
literal|"Cannot specify more than two node labels"
operator|+
literal|" in a single node label expression: "
operator|+
name|requestDetails
argument_list|)
throw|;
block|}
comment|// Don't allow specify node label against ANY request listing hosts or racks
if|if
condition|(
name|hasLabel
operator|&&
operator|(
name|hasRacks
operator|||
name|hasNodes
operator|)
condition|)
block|{
throw|throw
operator|new
name|InvalidContainerRequestException
argument_list|(
literal|"Cannot specify node label with rack or node: "
operator|+
name|requestDetails
argument_list|)
throw|;
block|}
block|}
comment|/**    * Create a new role/hostname pair for indexing.    * @return a new index.    */
DECL|method|getIndex ()
specifier|public
name|RoleHostnamePair
name|getIndex
parameter_list|()
block|{
return|return
operator|new
name|RoleHostnamePair
argument_list|(
name|roleId
argument_list|,
name|hostname
argument_list|)
return|;
block|}
block|}
end_class

end_unit

