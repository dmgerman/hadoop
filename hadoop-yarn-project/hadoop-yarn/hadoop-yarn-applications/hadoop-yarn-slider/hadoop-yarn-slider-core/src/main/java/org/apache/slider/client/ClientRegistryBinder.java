begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.slider.client
package|package
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|client
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|api
operator|.
name|RegistryConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|api
operator|.
name|RegistryOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryPathUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryTypeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|exceptions
operator|.
name|InvalidRecordException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|impl
operator|.
name|zk
operator|.
name|RegistryInternalConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|Endpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|ServiceRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryPathUtils
operator|.
name|encodeForRegistry
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryUtils
operator|.
name|convertUsername
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryUtils
operator|.
name|getCurrentUsernameUnencoded
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryUtils
operator|.
name|servicePath
import|;
end_import

begin_comment
comment|/**  * Generic code to get the URLs for clients via the registry  */
end_comment

begin_class
DECL|class|ClientRegistryBinder
specifier|public
class|class
name|ClientRegistryBinder
block|{
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ClientRegistryBinder
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|operations
specifier|private
specifier|final
name|RegistryOperations
name|operations
decl_stmt|;
DECL|method|ClientRegistryBinder (RegistryOperations operations)
specifier|public
name|ClientRegistryBinder
parameter_list|(
name|RegistryOperations
name|operations
parameter_list|)
block|{
name|this
operator|.
name|operations
operator|=
name|operations
expr_stmt|;
block|}
comment|/**    * Buld the user path -switches to the system path if the user is "".    * It also cross-converts the username to ascii via punycode    * @param username username or ""    * @return the path to the user    */
DECL|method|homePathForUser (String username)
specifier|public
specifier|static
name|String
name|homePathForUser
parameter_list|(
name|String
name|username
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|username
operator|!=
literal|null
argument_list|,
literal|"null user"
argument_list|)
expr_stmt|;
comment|// catch recursion
if|if
condition|(
name|username
operator|.
name|startsWith
argument_list|(
name|RegistryConstants
operator|.
name|PATH_USERS
argument_list|)
condition|)
block|{
return|return
name|username
return|;
block|}
if|if
condition|(
name|username
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|RegistryConstants
operator|.
name|PATH_SYSTEM_SERVICES
return|;
block|}
comment|// convert username to registry name
name|String
name|convertedName
init|=
name|convertUsername
argument_list|(
name|username
argument_list|)
decl_stmt|;
return|return
name|RegistryPathUtils
operator|.
name|join
argument_list|(
name|RegistryConstants
operator|.
name|PATH_USERS
argument_list|,
name|encodeForRegistry
argument_list|(
name|convertedName
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get the current username, before any encoding has been applied.    * @return the current user from the kerberos identity, falling back    * to the user and/or env variables.    */
DECL|method|currentUsernameUnencoded ()
specifier|public
specifier|static
name|String
name|currentUsernameUnencoded
parameter_list|()
block|{
name|String
name|env_hadoop_username
init|=
name|System
operator|.
name|getenv
argument_list|(
name|RegistryInternalConstants
operator|.
name|HADOOP_USER_NAME
argument_list|)
decl_stmt|;
return|return
name|getCurrentUsernameUnencoded
argument_list|(
name|env_hadoop_username
argument_list|)
return|;
block|}
comment|/**    * Qualify a user.    *<ol>    *<li><code>"~"</code> maps to user home path home</li>    *<li><code>"~user"</code> maps to<code>/users/$user</code></li>    *<li><code>"/"</code> maps to<code>/services/</code></li>    *</ol>    * @param user the username    * @return the base path    */
DECL|method|qualifyUser (String user)
specifier|public
specifier|static
name|String
name|qualifyUser
parameter_list|(
name|String
name|user
parameter_list|)
block|{
comment|// qualify the user
name|String
name|t
init|=
name|user
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
comment|// already resolved
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|t
operator|.
name|equals
argument_list|(
literal|"~"
argument_list|)
condition|)
block|{
comment|// self
return|return
name|currentUsernameUnencoded
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|t
operator|.
name|startsWith
argument_list|(
literal|"~"
argument_list|)
condition|)
block|{
comment|// another user
comment|// convert username to registry name
name|String
name|convertedName
init|=
name|convertUsername
argument_list|(
name|t
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|RegistryPathUtils
operator|.
name|join
argument_list|(
name|RegistryConstants
operator|.
name|PATH_USERS
argument_list|,
name|encodeForRegistry
argument_list|(
name|convertedName
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|"/"
operator|+
name|t
return|;
block|}
block|}
comment|/**    * Look up an external REST API    * @param user user which will be qualified as per {@link #qualifyUser(String)}    * @param serviceClass service class    * @param instance instance name    * @param api API    * @return the API, or an exception is raised.    * @throws IOException    */
DECL|method|lookupExternalRestAPI (String user, String serviceClass, String instance, String api)
specifier|public
name|String
name|lookupExternalRestAPI
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|serviceClass
parameter_list|,
name|String
name|instance
parameter_list|,
name|String
name|api
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|qualified
init|=
name|qualifyUser
argument_list|(
name|user
argument_list|)
decl_stmt|;
name|String
name|path
init|=
name|servicePath
argument_list|(
name|qualified
argument_list|,
name|serviceClass
argument_list|,
name|instance
argument_list|)
decl_stmt|;
name|String
name|restAPI
init|=
name|resolveExternalRestAPI
argument_list|(
name|api
argument_list|,
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|restAPI
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|PathNotFoundException
argument_list|(
name|path
operator|+
literal|" API "
operator|+
name|api
argument_list|)
throw|;
block|}
return|return
name|restAPI
return|;
block|}
comment|/**    * Resolve a service record then return an external REST API exported it.    *    * @param api API to resolve    * @param path path of the service record    * @return null if the record exists but the API is absent or it has no    * REST endpoints.    * @throws IOException resolution problems, as covered in    * {@link RegistryOperations#resolve(String)}    */
DECL|method|resolveExternalRestAPI (String api, String path)
specifier|protected
name|String
name|resolveExternalRestAPI
parameter_list|(
name|String
name|api
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|ServiceRecord
name|record
init|=
name|operations
operator|.
name|resolve
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
name|lookupRestAPI
argument_list|(
name|record
argument_list|,
name|api
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Look up an external REST API endpoint    * @param record service record    * @param api URI of api    * @param external flag to indicate this is an external record    * @return the first endpoint of the implementation, or null if there    * is no entry for the API, implementation or it's the wrong type.    */
DECL|method|lookupRestAPI (ServiceRecord record, String api, boolean external)
specifier|public
specifier|static
name|String
name|lookupRestAPI
parameter_list|(
name|ServiceRecord
name|record
parameter_list|,
name|String
name|api
parameter_list|,
name|boolean
name|external
parameter_list|)
throws|throws
name|InvalidRecordException
block|{
try|try
block|{
name|String
name|url
init|=
literal|null
decl_stmt|;
name|Endpoint
name|endpoint
init|=
name|getEndpoint
argument_list|(
name|record
argument_list|,
name|api
argument_list|,
name|external
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|addresses
init|=
name|RegistryTypeUtils
operator|.
name|retrieveAddressesUriType
argument_list|(
name|endpoint
argument_list|)
decl_stmt|;
if|if
condition|(
name|addresses
operator|!=
literal|null
operator|&&
operator|!
name|addresses
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|url
operator|=
name|addresses
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|url
return|;
block|}
catch|catch
parameter_list|(
name|InvalidRecordException
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"looking for API {}"
argument_list|,
name|api
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Get an endpont by API    * @param record service record    * @param api API    * @param external flag to indicate this is an external record    * @return the endpoint or null    */
DECL|method|getEndpoint (ServiceRecord record, String api, boolean external)
specifier|public
specifier|static
name|Endpoint
name|getEndpoint
parameter_list|(
name|ServiceRecord
name|record
parameter_list|,
name|String
name|api
parameter_list|,
name|boolean
name|external
parameter_list|)
block|{
return|return
name|external
condition|?
name|record
operator|.
name|getExternalEndpoint
argument_list|(
name|api
argument_list|)
else|:
name|record
operator|.
name|getInternalEndpoint
argument_list|(
name|api
argument_list|)
return|;
block|}
block|}
end_class

end_unit

