begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.slider.server.avro
package|package
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|avro
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|avro
operator|.
name|AvroTypeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|avro
operator|.
name|Schema
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|avro
operator|.
name|io
operator|.
name|DatumReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|avro
operator|.
name|io
operator|.
name|DatumWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|avro
operator|.
name|io
operator|.
name|Decoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|avro
operator|.
name|io
operator|.
name|DecoderFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|avro
operator|.
name|io
operator|.
name|Encoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|avro
operator|.
name|io
operator|.
name|EncoderFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|avro
operator|.
name|specific
operator|.
name|SpecificDatumReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|avro
operator|.
name|specific
operator|.
name|SpecificDatumWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|GlobFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|SliderKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|SliderUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|BadConfigException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|state
operator|.
name|NodeEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|state
operator|.
name|NodeInstance
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|state
operator|.
name|RoleHistory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * Write out the role history to an output stream.  */
end_comment

begin_class
DECL|class|RoleHistoryWriter
specifier|public
class|class
name|RoleHistoryWriter
block|{
DECL|field|log
specifier|protected
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|RoleHistoryWriter
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Although Avro is designed to handle some changes, we still keep a version    * marker in the file to catch changes that are fundamentally incompatible    * at the semantic level -changes that require either a different    * parser or get rejected outright.    */
DECL|field|ROLE_HISTORY_VERSION
specifier|public
specifier|static
specifier|final
name|int
name|ROLE_HISTORY_VERSION
init|=
literal|0x01
decl_stmt|;
comment|/**    * Write out the history.    * This does not update the history's dirty/savetime fields    *    * @param out outstream    * @param history history    * @param savetime time in millis for the save time to go in as a record    * @return no of records written    * @throws IOException IO failures    */
DECL|method|write (OutputStream out, RoleHistory history, long savetime)
specifier|public
name|long
name|write
parameter_list|(
name|OutputStream
name|out
parameter_list|,
name|RoleHistory
name|history
parameter_list|,
name|long
name|savetime
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|DatumWriter
argument_list|<
name|RoleHistoryRecord
argument_list|>
name|writer
init|=
operator|new
name|SpecificDatumWriter
argument_list|<>
argument_list|(
name|RoleHistoryRecord
operator|.
name|class
argument_list|)
decl_stmt|;
name|RoleHistoryRecord
name|record
init|=
name|createHeaderRecord
argument_list|(
name|savetime
argument_list|,
name|history
argument_list|)
decl_stmt|;
name|int
name|roles
init|=
name|history
operator|.
name|getRoleSize
argument_list|()
decl_stmt|;
name|Schema
name|schema
init|=
name|record
operator|.
name|getSchema
argument_list|()
decl_stmt|;
name|Encoder
name|encoder
init|=
name|EncoderFactory
operator|.
name|get
argument_list|()
operator|.
name|jsonEncoder
argument_list|(
name|schema
argument_list|,
name|out
argument_list|)
decl_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|record
argument_list|,
name|encoder
argument_list|)
expr_stmt|;
comment|// now write the rolemap record
name|writer
operator|.
name|write
argument_list|(
name|createRolemapRecord
argument_list|(
name|history
argument_list|)
argument_list|,
name|encoder
argument_list|)
expr_stmt|;
name|long
name|count
init|=
literal|0
decl_stmt|;
comment|//now for every role history entry, write out its record
name|Collection
argument_list|<
name|NodeInstance
argument_list|>
name|instances
init|=
name|history
operator|.
name|cloneNodemap
argument_list|()
operator|.
name|values
argument_list|()
decl_stmt|;
for|for
control|(
name|NodeInstance
name|instance
range|:
name|instances
control|)
block|{
for|for
control|(
name|int
name|role
init|=
literal|0
init|;
name|role
operator|<
name|roles
condition|;
name|role
operator|++
control|)
block|{
name|NodeEntry
name|nodeEntry
init|=
name|instance
operator|.
name|get
argument_list|(
name|role
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeEntry
operator|!=
literal|null
condition|)
block|{
name|NodeEntryRecord
name|ner
init|=
name|build
argument_list|(
name|nodeEntry
argument_list|,
name|role
argument_list|,
name|instance
operator|.
name|hostname
argument_list|)
decl_stmt|;
name|record
operator|=
operator|new
name|RoleHistoryRecord
argument_list|(
name|ner
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|record
argument_list|,
name|encoder
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|// footer
name|RoleHistoryFooter
name|footer
init|=
operator|new
name|RoleHistoryFooter
argument_list|()
decl_stmt|;
name|footer
operator|.
name|setCount
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
operator|new
name|RoleHistoryRecord
argument_list|(
name|footer
argument_list|)
argument_list|,
name|encoder
argument_list|)
expr_stmt|;
name|encoder
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|count
return|;
block|}
finally|finally
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Create the header record    * @param savetime time of save    * @param history history    * @return a record to place at the head of the file    */
DECL|method|createHeaderRecord (long savetime, RoleHistory history)
specifier|private
name|RoleHistoryRecord
name|createHeaderRecord
parameter_list|(
name|long
name|savetime
parameter_list|,
name|RoleHistory
name|history
parameter_list|)
block|{
name|RoleHistoryHeader
name|header
init|=
operator|new
name|RoleHistoryHeader
argument_list|()
decl_stmt|;
name|header
operator|.
name|setVersion
argument_list|(
name|ROLE_HISTORY_VERSION
argument_list|)
expr_stmt|;
name|header
operator|.
name|setSaved
argument_list|(
name|savetime
argument_list|)
expr_stmt|;
name|header
operator|.
name|setSavedx
argument_list|(
name|Long
operator|.
name|toHexString
argument_list|(
name|savetime
argument_list|)
argument_list|)
expr_stmt|;
name|header
operator|.
name|setSavedate
argument_list|(
name|SliderUtils
operator|.
name|toGMTString
argument_list|(
name|savetime
argument_list|)
argument_list|)
expr_stmt|;
name|header
operator|.
name|setRoles
argument_list|(
name|history
operator|.
name|getRoleSize
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|RoleHistoryRecord
argument_list|(
name|header
argument_list|)
return|;
block|}
comment|/**    * Create the rolemap record    * @param history history    * @return a record to insert into the file    */
DECL|method|createRolemapRecord (RoleHistory history)
specifier|private
name|RoleHistoryRecord
name|createRolemapRecord
parameter_list|(
name|RoleHistory
name|history
parameter_list|)
block|{
name|RoleHistoryMapping
name|entry
init|=
operator|new
name|RoleHistoryMapping
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|CharSequence
argument_list|,
name|Integer
argument_list|>
name|mapping
init|=
name|history
operator|.
name|buildMappingForHistoryFile
argument_list|()
decl_stmt|;
name|entry
operator|.
name|setRolemap
argument_list|(
name|mapping
argument_list|)
expr_stmt|;
return|return
operator|new
name|RoleHistoryRecord
argument_list|(
name|entry
argument_list|)
return|;
block|}
comment|/**    * Write the history information to a file    *    * @param fs filesystem    * @param path path    * @param overwrite overwrite flag    * @param history history    * @param savetime time in millis for the save time to go in as a record    * @return no of records written    * @throws IOException IO failures    */
DECL|method|write (FileSystem fs, Path path, boolean overwrite, RoleHistory history, long savetime)
specifier|public
name|long
name|write
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|RoleHistory
name|history
parameter_list|,
name|long
name|savetime
parameter_list|)
throws|throws
name|IOException
block|{
name|FSDataOutputStream
name|out
init|=
name|fs
operator|.
name|create
argument_list|(
name|path
argument_list|,
name|overwrite
argument_list|)
decl_stmt|;
return|return
name|write
argument_list|(
name|out
argument_list|,
name|history
argument_list|,
name|savetime
argument_list|)
return|;
block|}
comment|/**    * Create the filename for a history file    * @param time time value    * @return a filename such that later filenames sort later in the directory    */
DECL|method|createHistoryFilename (Path historyPath, long time)
specifier|public
name|Path
name|createHistoryFilename
parameter_list|(
name|Path
name|historyPath
parameter_list|,
name|long
name|time
parameter_list|)
block|{
name|String
name|filename
init|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|,
name|SliderKeys
operator|.
name|HISTORY_FILENAME_CREATION_PATTERN
argument_list|,
name|time
argument_list|)
decl_stmt|;
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|historyPath
argument_list|,
name|filename
argument_list|)
decl_stmt|;
return|return
name|path
return|;
block|}
comment|/**    * Build a {@link NodeEntryRecord} from a node entry; include whether    * the node is in use and when it was last used.    * @param entry entry count    * @param role role index    * @param hostname name    * @return the record    */
DECL|method|build (NodeEntry entry, int role, String hostname)
specifier|private
name|NodeEntryRecord
name|build
parameter_list|(
name|NodeEntry
name|entry
parameter_list|,
name|int
name|role
parameter_list|,
name|String
name|hostname
parameter_list|)
block|{
name|NodeEntryRecord
name|record
init|=
operator|new
name|NodeEntryRecord
argument_list|(
name|hostname
argument_list|,
name|role
argument_list|,
name|entry
operator|.
name|getLive
argument_list|()
operator|>
literal|0
argument_list|,
name|entry
operator|.
name|getLastUsed
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|record
return|;
block|}
comment|/**    * Read a history, returning one that is ready to have its onThaw()     * method called    * @param in input source    * @return no. of entries read    * @throws IOException problems    */
DECL|method|read (InputStream in)
specifier|public
name|LoadedRoleHistory
name|read
parameter_list|(
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|BadConfigException
block|{
try|try
block|{
name|LoadedRoleHistory
name|loadedRoleHistory
init|=
operator|new
name|LoadedRoleHistory
argument_list|()
decl_stmt|;
name|DatumReader
argument_list|<
name|RoleHistoryRecord
argument_list|>
name|reader
init|=
operator|new
name|SpecificDatumReader
argument_list|<>
argument_list|(
name|RoleHistoryRecord
operator|.
name|class
argument_list|)
decl_stmt|;
name|Decoder
name|decoder
init|=
name|DecoderFactory
operator|.
name|get
argument_list|()
operator|.
name|jsonDecoder
argument_list|(
name|RoleHistoryRecord
operator|.
name|getClassSchema
argument_list|()
argument_list|,
name|in
argument_list|)
decl_stmt|;
comment|//read header : no entry -> EOF
name|RoleHistoryRecord
name|record
init|=
name|reader
operator|.
name|read
argument_list|(
literal|null
argument_list|,
name|decoder
argument_list|)
decl_stmt|;
if|if
condition|(
name|record
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Role History Header not found at start of file."
argument_list|)
throw|;
block|}
name|Object
name|entry
init|=
name|record
operator|.
name|getEntry
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|entry
operator|instanceof
name|RoleHistoryHeader
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Role History Header not found at start of file"
argument_list|)
throw|;
block|}
name|RoleHistoryHeader
name|header
init|=
operator|(
name|RoleHistoryHeader
operator|)
name|entry
decl_stmt|;
if|if
condition|(
name|header
operator|.
name|getVersion
argument_list|()
operator|!=
name|ROLE_HISTORY_VERSION
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Can't read role file version %04x -need %04x"
argument_list|,
name|header
operator|.
name|getVersion
argument_list|()
argument_list|,
name|ROLE_HISTORY_VERSION
argument_list|)
argument_list|)
throw|;
block|}
name|loadedRoleHistory
operator|.
name|setHeader
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|RoleHistoryFooter
name|footer
init|=
literal|null
decl_stmt|;
name|int
name|records
init|=
literal|0
decl_stmt|;
comment|//go through reading data
try|try
block|{
while|while
condition|(
name|footer
operator|==
literal|null
condition|)
block|{
name|record
operator|=
name|reader
operator|.
name|read
argument_list|(
literal|null
argument_list|,
name|decoder
argument_list|)
expr_stmt|;
if|if
condition|(
name|record
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Null record after "
operator|+
name|records
operator|+
literal|" records"
argument_list|)
throw|;
block|}
name|entry
operator|=
name|record
operator|.
name|getEntry
argument_list|()
expr_stmt|;
if|if
condition|(
name|entry
operator|instanceof
name|RoleHistoryHeader
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Duplicate Role History Header found"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|instanceof
name|RoleHistoryMapping
condition|)
block|{
comment|// role history mapping entry
if|if
condition|(
operator|!
name|loadedRoleHistory
operator|.
name|roleMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// duplicate role maps are viewed as something to warn over, rather than fail
name|log
operator|.
name|warn
argument_list|(
literal|"Duplicate role map; ignoring"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RoleHistoryMapping
name|historyMapping
init|=
operator|(
name|RoleHistoryMapping
operator|)
name|entry
decl_stmt|;
name|loadedRoleHistory
operator|.
name|buildMapping
argument_list|(
name|historyMapping
operator|.
name|getRolemap
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|entry
operator|instanceof
name|NodeEntryRecord
condition|)
block|{
comment|// normal record
name|records
operator|++
expr_stmt|;
name|NodeEntryRecord
name|nodeEntryRecord
init|=
operator|(
name|NodeEntryRecord
operator|)
name|entry
decl_stmt|;
name|loadedRoleHistory
operator|.
name|add
argument_list|(
name|nodeEntryRecord
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|instanceof
name|RoleHistoryFooter
condition|)
block|{
comment|//tail end of the file
name|footer
operator|=
operator|(
name|RoleHistoryFooter
operator|)
name|entry
expr_stmt|;
block|}
else|else
block|{
comment|// this is to handle future versions, such as when rolling back
comment|// from a later version of slider
name|log
operator|.
name|warn
argument_list|(
literal|"Discarding unknown record {}"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
name|EOFException
name|ex
init|=
operator|new
name|EOFException
argument_list|(
literal|"End of file reached after "
operator|+
name|records
operator|+
literal|" records"
argument_list|)
decl_stmt|;
name|ex
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|ex
throw|;
block|}
comment|// at this point there should be no data left.
comment|// check by reading and expecting a -1
if|if
condition|(
name|in
operator|.
name|read
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// footer is in stream before the last record
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"File footer reached before end of file -after "
operator|+
name|records
operator|+
literal|" records"
argument_list|)
throw|;
block|}
if|if
condition|(
name|records
operator|!=
name|footer
operator|.
name|getCount
argument_list|()
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"mismatch between no of records saved {} and number read {}"
argument_list|,
name|footer
operator|.
name|getCount
argument_list|()
argument_list|,
name|records
argument_list|)
expr_stmt|;
block|}
return|return
name|loadedRoleHistory
return|;
block|}
finally|finally
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Read a role history from a path in a filesystem    * @param fs filesystem    * @param path path to the file    * @return the records read    * @throws IOException any problem    */
DECL|method|read (FileSystem fs, Path path)
specifier|public
name|LoadedRoleHistory
name|read
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
throws|,
name|BadConfigException
block|{
name|FSDataInputStream
name|instream
init|=
name|fs
operator|.
name|open
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
name|read
argument_list|(
name|instream
argument_list|)
return|;
block|}
comment|/**    * Read from a resource in the classpath -used for testing    * @param resource resource    * @return the records read    * @throws IOException any problem    */
DECL|method|read (String resource)
specifier|public
name|LoadedRoleHistory
name|read
parameter_list|(
name|String
name|resource
parameter_list|)
throws|throws
name|IOException
throws|,
name|BadConfigException
block|{
return|return
name|read
argument_list|(
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getClassLoader
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
name|resource
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Find all history entries in a dir. The dir is created if it is    * not already defined.    *     * The scan uses the match pattern {@link SliderKeys#HISTORY_FILENAME_MATCH_PATTERN}    * while dropping empty files and directories which match the pattern.    * The list is then sorted with a comparator that sorts on filename,    * relying on the filename of newer created files being later than the old ones.    *     *     *    * @param fs filesystem    * @param dir dir to scan    * @param includeEmptyFiles should empty files be included in the result?    * @return a possibly empty list    * @throws IOException IO problems    * @throws FileNotFoundException if the target dir is actually a path    */
DECL|method|findAllHistoryEntries (FileSystem fs, Path dir, boolean includeEmptyFiles)
specifier|public
name|List
argument_list|<
name|Path
argument_list|>
name|findAllHistoryEntries
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|dir
parameter_list|,
name|boolean
name|includeEmptyFiles
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|fs
operator|!=
literal|null
assert|;
assert|assert
name|dir
operator|!=
literal|null
assert|;
if|if
condition|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|fs
operator|.
name|mkdirs
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|fs
operator|.
name|isDirectory
argument_list|(
name|dir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Not a directory "
operator|+
name|dir
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|PathFilter
name|filter
init|=
operator|new
name|GlobFilter
argument_list|(
name|SliderKeys
operator|.
name|HISTORY_FILENAME_GLOB_PATTERN
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|stats
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|dir
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|paths
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|(
name|stats
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|stat
range|:
name|stats
control|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Possible entry: {}"
argument_list|,
name|stat
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|.
name|isFile
argument_list|()
operator|&&
operator|(
name|includeEmptyFiles
operator|||
name|stat
operator|.
name|getLen
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
name|paths
operator|.
name|add
argument_list|(
name|stat
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|sortHistoryPaths
argument_list|(
name|paths
argument_list|)
expr_stmt|;
return|return
name|paths
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|sortHistoryPaths (List<Path> paths)
specifier|public
specifier|static
name|void
name|sortHistoryPaths
parameter_list|(
name|List
argument_list|<
name|Path
argument_list|>
name|paths
parameter_list|)
block|{
name|Collections
operator|.
name|sort
argument_list|(
name|paths
argument_list|,
operator|new
name|NewerFilesFirst
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Iterate through the paths until one can be loaded    * @param paths paths to load    * @return the loaded history including the path -or null if all failed to load    */
DECL|method|attemptToReadHistory (FileSystem fileSystem, List<Path> paths)
specifier|public
name|LoadedRoleHistory
name|attemptToReadHistory
parameter_list|(
name|FileSystem
name|fileSystem
parameter_list|,
name|List
argument_list|<
name|Path
argument_list|>
name|paths
parameter_list|)
throws|throws
name|BadConfigException
block|{
name|ListIterator
argument_list|<
name|Path
argument_list|>
name|pathIterator
init|=
name|paths
operator|.
name|listIterator
argument_list|()
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|LoadedRoleHistory
name|history
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|!
name|success
operator|&&
name|pathIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Path
name|path
init|=
name|pathIterator
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|history
operator|=
name|read
argument_list|(
name|fileSystem
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|//success
name|success
operator|=
literal|true
expr_stmt|;
name|history
operator|.
name|setPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Failed to read {}"
argument_list|,
name|path
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AvroTypeException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Failed to parse {}"
argument_list|,
name|path
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// low level event logged @ warn level
name|log
operator|.
name|warn
argument_list|(
literal|"Exception while reading {}"
argument_list|,
name|path
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|history
return|;
block|}
comment|/**    * Try to load the history from a directory -a failure to load a specific    * file is downgraded to a log and the next older path attempted instead    * @param fs filesystem    * @param dir dir to load from    * @return the history loaded, including the path    * @throws IOException if indexing the history directory fails.     */
DECL|method|loadFromHistoryDir (FileSystem fs, Path dir)
specifier|public
name|LoadedRoleHistory
name|loadFromHistoryDir
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|dir
parameter_list|)
throws|throws
name|IOException
throws|,
name|BadConfigException
block|{
assert|assert
name|fs
operator|!=
literal|null
operator|:
literal|"null filesystem"
assert|;
name|List
argument_list|<
name|Path
argument_list|>
name|entries
init|=
name|findAllHistoryEntries
argument_list|(
name|fs
argument_list|,
name|dir
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|attemptToReadHistory
argument_list|(
name|fs
argument_list|,
name|entries
argument_list|)
return|;
block|}
comment|/**    * Delete all old history entries older than the one we want to keep. This    * uses the filename ordering to determine age, not timestamps    * @param fileSystem filesystem    * @param keep path to keep -used in thresholding the files    * @return the number of files deleted    * @throws FileNotFoundException if the path to keep is not present (safety    * check to stop the entire dir being purged)    * @throws IOException IO problems    */
DECL|method|purgeOlderHistoryEntries (FileSystem fileSystem, Path keep)
specifier|public
name|int
name|purgeOlderHistoryEntries
parameter_list|(
name|FileSystem
name|fileSystem
parameter_list|,
name|Path
name|keep
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|fileSystem
operator|!=
literal|null
operator|:
literal|"null filesystem"
assert|;
if|if
condition|(
operator|!
name|fileSystem
operator|.
name|exists
argument_list|(
name|keep
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|keep
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|Path
name|dir
init|=
name|keep
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Purging entries in {} up to {}"
argument_list|,
name|dir
argument_list|,
name|keep
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|paths
init|=
name|findAllHistoryEntries
argument_list|(
name|fileSystem
argument_list|,
name|dir
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|paths
argument_list|,
operator|new
name|OlderFilesFirst
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|deleteCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Path
name|path
range|:
name|paths
control|)
block|{
if|if
condition|(
name|path
operator|.
name|equals
argument_list|(
name|keep
argument_list|)
condition|)
block|{
break|break;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Deleting {}"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|deleteCount
operator|++
expr_stmt|;
name|fileSystem
operator|.
name|delete
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|deleteCount
return|;
block|}
block|}
end_class

end_unit

