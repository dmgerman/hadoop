begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.slider.core.launch
package|package
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|launch
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|DataOutputBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|Credentials
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SecurityUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|AbstractDelegationTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|ClientRMProxy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|api
operator|.
name|TimelineClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|api
operator|.
name|YarnClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|HAUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|security
operator|.
name|client
operator|.
name|TimelineDelegationTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|ConverterUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|SliderXmlConfKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
operator|.
name|HADOOP_TOKEN_FILE_LOCATION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Utils to work with credentials and tokens.  *  * Designed to be movable to Hadoop core  */
end_comment

begin_class
DECL|class|CredentialUtils
specifier|public
specifier|final
class|class
name|CredentialUtils
block|{
DECL|field|JOB_CREDENTIALS_BINARY
specifier|public
specifier|static
specifier|final
name|String
name|JOB_CREDENTIALS_BINARY
init|=
name|SliderXmlConfKeys
operator|.
name|MAPREDUCE_JOB_CREDENTIALS_BINARY
decl_stmt|;
DECL|method|CredentialUtils ()
specifier|private
name|CredentialUtils
parameter_list|()
block|{   }
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|CredentialUtils
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Save credentials to a byte buffer. Returns null if there were no    * credentials to save    * @param credentials credential set    * @return a byte buffer of serialized tokens    * @throws IOException if the credentials could not be written to the stream    */
DECL|method|marshallCredentials (Credentials credentials)
specifier|public
specifier|static
name|ByteBuffer
name|marshallCredentials
parameter_list|(
name|Credentials
name|credentials
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteBuffer
name|buffer
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|credentials
operator|.
name|getAllTokens
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|DataOutputBuffer
name|dob
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
try|try
block|{
name|credentials
operator|.
name|writeTokenStorageToStream
argument_list|(
name|dob
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|dob
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|buffer
operator|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|dob
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|dob
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
return|;
block|}
DECL|method|locateEnvCredentials (Map<String, String> env, Configuration conf, StringBuffer sourceTextOut)
specifier|public
specifier|static
name|File
name|locateEnvCredentials
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|StringBuffer
name|sourceTextOut
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
name|String
name|tokenFilename
init|=
name|env
operator|.
name|get
argument_list|(
name|HADOOP_TOKEN_FILE_LOCATION
argument_list|)
decl_stmt|;
name|String
name|source
init|=
literal|"environment variable "
operator|+
name|HADOOP_TOKEN_FILE_LOCATION
decl_stmt|;
if|if
condition|(
name|tokenFilename
operator|==
literal|null
condition|)
block|{
name|tokenFilename
operator|=
name|conf
operator|.
name|get
argument_list|(
name|JOB_CREDENTIALS_BINARY
argument_list|)
expr_stmt|;
name|source
operator|=
literal|"configuration option "
operator|+
name|JOB_CREDENTIALS_BINARY
expr_stmt|;
block|}
if|if
condition|(
name|tokenFilename
operator|!=
literal|null
condition|)
block|{
comment|// use delegation tokens, i.e. from Oozie
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|tokenFilename
operator|.
name|trim
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|details
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Token File %s from %s"
argument_list|,
name|file
argument_list|,
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"No "
operator|+
name|details
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|file
operator|.
name|isFile
argument_list|()
operator|&&
operator|!
name|file
operator|.
name|canRead
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Cannot read "
operator|+
name|details
argument_list|)
throw|;
block|}
name|sourceTextOut
operator|.
name|append
argument_list|(
name|details
argument_list|)
expr_stmt|;
return|return
name|file
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Load the credentials from the environment. This looks at    * the value of {@link UserGroupInformation#HADOOP_TOKEN_FILE_LOCATION}    * and attempts to read in the value    * @param env environment to resolve the variable from    * @param conf configuration use when reading the tokens    * @return a set of credentials, or null if the environment did not    * specify any    * @throws IOException if a location for credentials was defined, but    * the credentials could not be loaded.    */
DECL|method|loadTokensFromEnvironment (Map<String, String> env, Configuration conf)
specifier|public
specifier|static
name|Credentials
name|loadTokensFromEnvironment
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|StringBuffer
name|origin
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|File
name|file
init|=
name|locateEnvCredentials
argument_list|(
name|env
argument_list|,
name|conf
argument_list|,
name|origin
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Using {}"
argument_list|,
name|origin
argument_list|)
expr_stmt|;
return|return
name|Credentials
operator|.
name|readTokenStorageFile
argument_list|(
name|file
argument_list|,
name|conf
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Save credentials to a file    * @param file file to save to (will be overwritten)    * @param credentials credentials to write    * @throws IOException    */
DECL|method|saveTokens (File file, Credentials credentials)
specifier|public
specifier|static
name|void
name|saveTokens
parameter_list|(
name|File
name|file
parameter_list|,
name|Credentials
name|credentials
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|DataOutputStream
name|daos
init|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|file
argument_list|)
argument_list|)
init|)
block|{
name|credentials
operator|.
name|writeTokenStorageToStream
argument_list|(
name|daos
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Look up and return the resource manager's principal. This method    * automatically does the<code>_HOST</code> replacement in the principal and    * correctly handles HA resource manager configurations.    *    * From: YARN-4629    * @param conf the {@link Configuration} file from which to read the    * principal    * @return the resource manager's principal string    * @throws IOException thrown if there's an error replacing the host name    */
DECL|method|getRMPrincipal (Configuration conf)
specifier|public
specifier|static
name|String
name|getRMPrincipal
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|principal
init|=
name|conf
operator|.
name|get
argument_list|(
name|RM_PRINCIPAL
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|String
name|hostname
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|principal
operator|.
name|isEmpty
argument_list|()
argument_list|,
literal|"Not set: "
operator|+
name|RM_PRINCIPAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAUtil
operator|.
name|isHAEnabled
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|YarnConfiguration
name|yarnConf
init|=
operator|new
name|YarnConfiguration
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|yarnConf
operator|.
name|get
argument_list|(
name|RM_HA_ID
argument_list|)
operator|==
literal|null
condition|)
block|{
comment|// If RM_HA_ID is not configured, use the first of RM_HA_IDS.
comment|// Any valid RM HA ID should work.
name|String
index|[]
name|rmIds
init|=
name|yarnConf
operator|.
name|getStrings
argument_list|(
name|RM_HA_IDS
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|(
name|rmIds
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|rmIds
operator|.
name|length
operator|>
literal|0
operator|)
argument_list|,
literal|"Not set "
operator|+
name|RM_HA_IDS
argument_list|)
expr_stmt|;
name|yarnConf
operator|.
name|set
argument_list|(
name|RM_HA_ID
argument_list|,
name|rmIds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|hostname
operator|=
name|yarnConf
operator|.
name|getSocketAddr
argument_list|(
name|RM_ADDRESS
argument_list|,
name|DEFAULT_RM_ADDRESS
argument_list|,
name|DEFAULT_RM_PORT
argument_list|)
operator|.
name|getHostName
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|hostname
operator|=
name|conf
operator|.
name|getSocketAddr
argument_list|(
name|RM_ADDRESS
argument_list|,
name|DEFAULT_RM_ADDRESS
argument_list|,
name|DEFAULT_RM_PORT
argument_list|)
operator|.
name|getHostName
argument_list|()
expr_stmt|;
block|}
return|return
name|SecurityUtil
operator|.
name|getServerPrincipal
argument_list|(
name|principal
argument_list|,
name|hostname
argument_list|)
return|;
block|}
comment|/**    * Create and add any filesystem delegation tokens with    * the RM(s) configured to be able to renew them. Returns null    * on an insecure cluster (i.e. harmless)    * @param conf configuration    * @param fs filesystem    * @param credentials credentials to update    * @return a list of all added tokens.    * @throws IOException    */
DECL|method|addRMRenewableFSDelegationTokens (Configuration conf, FileSystem fs, Credentials credentials)
specifier|public
specifier|static
name|Token
argument_list|<
name|?
argument_list|>
index|[]
name|addRMRenewableFSDelegationTokens
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FileSystem
name|fs
parameter_list|,
name|Credentials
name|credentials
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|conf
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|credentials
operator|!=
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
return|return
name|fs
operator|.
name|addDelegationTokens
argument_list|(
name|CredentialUtils
operator|.
name|getRMPrincipal
argument_list|(
name|conf
argument_list|)
argument_list|,
name|credentials
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Add an FS delegation token which can be renewed by the current user    * @param fs filesystem    * @param credentials credentials to update    * @throws IOException problems.    */
DECL|method|addSelfRenewableFSDelegationTokens ( FileSystem fs, Credentials credentials)
specifier|public
specifier|static
name|void
name|addSelfRenewableFSDelegationTokens
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Credentials
name|credentials
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|fs
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|credentials
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|fs
operator|.
name|addDelegationTokens
argument_list|(
name|getSelfRenewer
argument_list|()
argument_list|,
name|credentials
argument_list|)
expr_stmt|;
block|}
DECL|method|getSelfRenewer ()
specifier|public
specifier|static
name|String
name|getSelfRenewer
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
return|;
block|}
comment|/**    * Create and add an RM delegation token to the credentials    * @param yarnClient Yarn Client    * @param credentials to add token to    * @return the token which was added    * @throws IOException    * @throws YarnException    */
DECL|method|addRMDelegationToken (YarnClient yarnClient, Credentials credentials)
specifier|public
specifier|static
name|Token
argument_list|<
name|TokenIdentifier
argument_list|>
name|addRMDelegationToken
parameter_list|(
name|YarnClient
name|yarnClient
parameter_list|,
name|Credentials
name|credentials
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
name|Configuration
name|conf
init|=
name|yarnClient
operator|.
name|getConfig
argument_list|()
decl_stmt|;
name|Text
name|rmPrincipal
init|=
operator|new
name|Text
argument_list|(
name|CredentialUtils
operator|.
name|getRMPrincipal
argument_list|(
name|conf
argument_list|)
argument_list|)
decl_stmt|;
name|Text
name|rmDTService
init|=
name|ClientRMProxy
operator|.
name|getRMDelegationTokenService
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Token
argument_list|<
name|TokenIdentifier
argument_list|>
name|rmDelegationToken
init|=
name|ConverterUtils
operator|.
name|convertFromYarn
argument_list|(
name|yarnClient
operator|.
name|getRMDelegationToken
argument_list|(
name|rmPrincipal
argument_list|)
argument_list|,
name|rmDTService
argument_list|)
decl_stmt|;
name|credentials
operator|.
name|addToken
argument_list|(
name|rmDelegationToken
operator|.
name|getService
argument_list|()
argument_list|,
name|rmDelegationToken
argument_list|)
expr_stmt|;
return|return
name|rmDelegationToken
return|;
block|}
DECL|method|maybeAddTimelineToken ( Configuration conf, Credentials credentials)
specifier|public
specifier|static
name|Token
argument_list|<
name|TimelineDelegationTokenIdentifier
argument_list|>
name|maybeAddTimelineToken
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Credentials
name|credentials
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|YarnConfiguration
operator|.
name|TIMELINE_SERVICE_ENABLED
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Timeline service enabled -fetching token"
argument_list|)
expr_stmt|;
try|try
init|(
name|TimelineClient
name|timelineClient
init|=
name|TimelineClient
operator|.
name|createTimelineClient
argument_list|()
init|)
block|{
name|timelineClient
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|timelineClient
operator|.
name|start
argument_list|()
expr_stmt|;
name|Token
argument_list|<
name|TimelineDelegationTokenIdentifier
argument_list|>
name|token
init|=
name|timelineClient
operator|.
name|getDelegationToken
argument_list|(
name|CredentialUtils
operator|.
name|getRMPrincipal
argument_list|(
name|conf
argument_list|)
argument_list|)
decl_stmt|;
name|credentials
operator|.
name|addToken
argument_list|(
name|token
operator|.
name|getService
argument_list|()
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return
name|token
return|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Timeline service is disabled"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Filter a list of tokens from a set of credentials    * @param credentials credential source (a new credential set os re    * @param filter List of tokens to strip out    * @return a new, filtered, set of credentials    */
DECL|method|filterTokens (Credentials credentials, List<Text> filter)
specifier|public
specifier|static
name|Credentials
name|filterTokens
parameter_list|(
name|Credentials
name|credentials
parameter_list|,
name|List
argument_list|<
name|Text
argument_list|>
name|filter
parameter_list|)
block|{
name|Credentials
name|result
init|=
operator|new
name|Credentials
argument_list|(
name|credentials
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
argument_list|>
name|iter
init|=
name|result
operator|.
name|getAllTokens
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|token
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Token {}"
argument_list|,
name|token
operator|.
name|getKind
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter
operator|.
name|contains
argument_list|(
name|token
operator|.
name|getKind
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Filtering token {}"
argument_list|,
name|token
operator|.
name|getKind
argument_list|()
argument_list|)
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
DECL|method|dumpTokens (Credentials credentials, String separator)
specifier|public
specifier|static
name|String
name|dumpTokens
parameter_list|(
name|Credentials
name|credentials
parameter_list|,
name|String
name|separator
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
argument_list|>
name|sorted
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|credentials
operator|.
name|getAllTokens
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|sorted
argument_list|,
operator|new
name|TokenComparator
argument_list|()
argument_list|)
expr_stmt|;
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|(
name|sorted
operator|.
name|size
argument_list|()
operator|*
literal|128
argument_list|)
decl_stmt|;
for|for
control|(
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|token
range|:
name|sorted
control|)
block|{
name|buffer
operator|.
name|append
argument_list|(
name|tokenToString
argument_list|(
name|token
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|separator
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Create a string for people to look at    * @param token token to convert to a string form    * @return a printable view of the token    */
DECL|method|tokenToString (Token<? extends TokenIdentifier> token)
specifier|public
specifier|static
name|String
name|tokenToString
parameter_list|(
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|token
parameter_list|)
block|{
name|DateFormat
name|df
init|=
name|DateFormat
operator|.
name|getDateTimeInstance
argument_list|(
name|DateFormat
operator|.
name|SHORT
argument_list|,
name|DateFormat
operator|.
name|SHORT
argument_list|)
decl_stmt|;
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|(
literal|128
argument_list|)
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|token
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|TokenIdentifier
name|ti
init|=
name|token
operator|.
name|decodeIdentifier
argument_list|()
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
literal|"; "
argument_list|)
operator|.
name|append
argument_list|(
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|instanceof
name|AbstractDelegationTokenIdentifier
condition|)
block|{
comment|// details in human readable form, and compensate for information HDFS DT omits
name|AbstractDelegationTokenIdentifier
name|dt
init|=
operator|(
name|AbstractDelegationTokenIdentifier
operator|)
name|ti
decl_stmt|;
name|buffer
operator|.
name|append
argument_list|(
literal|"; Renewer: "
argument_list|)
operator|.
name|append
argument_list|(
name|dt
operator|.
name|getRenewer
argument_list|()
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
literal|"; Issued: "
argument_list|)
operator|.
name|append
argument_list|(
name|df
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|(
name|dt
operator|.
name|getIssueDate
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
literal|"; Max Date: "
argument_list|)
operator|.
name|append
argument_list|(
name|df
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|(
name|dt
operator|.
name|getMaxDate
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|//marshall problem; not ours
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to decode {}: {}"
argument_list|,
name|token
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Get the expiry time of a token.    * @param token token to examine    * @return the time in milliseconds after which the token is invalid.    * @throws IOException    */
DECL|method|getTokenExpiryTime (Token token)
specifier|public
specifier|static
name|long
name|getTokenExpiryTime
parameter_list|(
name|Token
name|token
parameter_list|)
throws|throws
name|IOException
block|{
name|TokenIdentifier
name|identifier
init|=
name|token
operator|.
name|decodeIdentifier
argument_list|()
decl_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|identifier
operator|instanceof
name|AbstractDelegationTokenIdentifier
argument_list|,
literal|"Token %s of type: %s has an identifier which cannot be examined: %s"
argument_list|,
name|token
argument_list|,
name|token
operator|.
name|getClass
argument_list|()
argument_list|,
name|identifier
argument_list|)
expr_stmt|;
name|AbstractDelegationTokenIdentifier
name|id
init|=
operator|(
name|AbstractDelegationTokenIdentifier
operator|)
name|identifier
decl_stmt|;
return|return
name|id
operator|.
name|getMaxDate
argument_list|()
return|;
block|}
DECL|class|TokenComparator
specifier|private
specifier|static
class|class
name|TokenComparator
implements|implements
name|Comparator
argument_list|<
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
argument_list|>
implements|,
name|Serializable
block|{
annotation|@
name|Override
DECL|method|compare (Token<? extends TokenIdentifier> left, Token<? extends TokenIdentifier> right)
specifier|public
name|int
name|compare
parameter_list|(
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|left
parameter_list|,
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|right
parameter_list|)
block|{
return|return
name|left
operator|.
name|getKind
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|compareTo
argument_list|(
name|right
operator|.
name|getKind
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

