begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *       http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.slider.server.appmaster
package|package
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
package|;
end_package

begin_import
import|import
name|com
operator|.
name|codahale
operator|.
name|metrics
operator|.
name|MetricRegistry
import|;
end_import

begin_import
import|import
name|com
operator|.
name|codahale
operator|.
name|metrics
operator|.
name|health
operator|.
name|HealthCheckRegistry
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|BlockingService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|collections
operator|.
name|CollectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|http
operator|.
name|HttpConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|api
operator|.
name|RegistryOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryPathUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryTypeUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|ServiceRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|yarn
operator|.
name|PersistencePolicies
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|yarn
operator|.
name|YarnRegistryAttributes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|server
operator|.
name|integration
operator|.
name|RMRegistryOperationsService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|Credentials
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|ServiceOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|ServiceStateChangeListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|ApplicationConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|RegisterApplicationMasterResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationAccessType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationAttemptId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationAttemptReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Container
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerLaunchContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|FinalApplicationStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|NodeReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|NodeState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Priority
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|api
operator|.
name|AMRMClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|api
operator|.
name|async
operator|.
name|AMRMClientAsync
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|api
operator|.
name|async
operator|.
name|NMClientAsync
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|api
operator|.
name|async
operator|.
name|impl
operator|.
name|NMClientAsyncImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|InvalidApplicationMasterRequestException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|ipc
operator|.
name|YarnRPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|security
operator|.
name|AMRMTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|security
operator|.
name|client
operator|.
name|ClientToAMTokenSecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|security
operator|.
name|client
operator|.
name|TimelineDelegationTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|ConverterUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|webapp
operator|.
name|WebAppException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|webapp
operator|.
name|WebApps
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|webapp
operator|.
name|util
operator|.
name|WebAppUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|ClusterDescription
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|InternalKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|ResourceKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|RoleKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|StatusKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|proto
operator|.
name|SliderClusterAPI
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|client
operator|.
name|SliderYarnClientImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|SliderExitCodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|SliderKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|AbstractActionArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|SliderAMArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|SliderAMCreateAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|SliderActions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|ConfigHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|PortScanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|SliderFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|SliderUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|SliderVersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|buildutils
operator|.
name|InstanceIO
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|conf
operator|.
name|AggregateConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|conf
operator|.
name|ConfTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|conf
operator|.
name|ConfTreeOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|conf
operator|.
name|MapOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|BadConfigException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|SliderException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|SliderInternalStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|TriggerClusterTeardownException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|launch
operator|.
name|CredentialUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|main
operator|.
name|ExitCodeProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|main
operator|.
name|LauncherExitCodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|main
operator|.
name|RunService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|main
operator|.
name|ServiceLauncher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|registry
operator|.
name|info
operator|.
name|CustomRegistryConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|providers
operator|.
name|ProviderCompleted
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|providers
operator|.
name|ProviderRole
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|providers
operator|.
name|ProviderService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|providers
operator|.
name|SliderProviderFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|providers
operator|.
name|slideram
operator|.
name|SliderAMClientProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|providers
operator|.
name|slideram
operator|.
name|SliderAMProviderService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|actions
operator|.
name|ActionRegisterServiceInstance
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|actions
operator|.
name|ActionStopSlider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|actions
operator|.
name|ActionUpgradeContainers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|actions
operator|.
name|AsyncAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|actions
operator|.
name|EscalateOutstandingRequests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|actions
operator|.
name|QueueExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|actions
operator|.
name|QueueService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|actions
operator|.
name|RegisterComponentInstance
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|actions
operator|.
name|RenewingAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|actions
operator|.
name|ResetFailureWindow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|actions
operator|.
name|ReviewAndFlexApplicationSize
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|actions
operator|.
name|UnregisterComponentInstance
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|management
operator|.
name|MetricsAndMonitoring
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|management
operator|.
name|YarnServiceHealthCheck
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|monkey
operator|.
name|ChaosKillAM
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|monkey
operator|.
name|ChaosKillContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|monkey
operator|.
name|ChaosMonkeyService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|operations
operator|.
name|AbstractRMOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|operations
operator|.
name|AsyncRMOperationHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|operations
operator|.
name|ProviderNotifyingOperationHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|operations
operator|.
name|RMOperationHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|rpc
operator|.
name|RpcBinder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|rpc
operator|.
name|SliderAMPolicyProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|rpc
operator|.
name|SliderClusterProtocolPBImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|rpc
operator|.
name|SliderIPCService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|security
operator|.
name|SecurityConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|state
operator|.
name|AppState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|state
operator|.
name|AppStateBindingInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|state
operator|.
name|ContainerAssignment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|state
operator|.
name|ProviderAppState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|state
operator|.
name|RoleInstance
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|web
operator|.
name|SliderAMWebApp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|web
operator|.
name|WebAppApi
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|web
operator|.
name|WebAppApiImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|web
operator|.
name|rest
operator|.
name|InsecureAmFilterInitializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|web
operator|.
name|rest
operator|.
name|RestPaths
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|web
operator|.
name|rest
operator|.
name|application
operator|.
name|ApplicationResouceContentCacheFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|web
operator|.
name|rest
operator|.
name|application
operator|.
name|resources
operator|.
name|ContentCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|services
operator|.
name|utility
operator|.
name|AbstractSliderLaunchedService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|services
operator|.
name|utility
operator|.
name|WebAppService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|services
operator|.
name|workflow
operator|.
name|ServiceThreadFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|services
operator|.
name|workflow
operator|.
name|WorkflowExecutorService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|services
operator|.
name|workflow
operator|.
name|WorkflowRpcService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|services
operator|.
name|yarnregistry
operator|.
name|YarnRegistryViewForProviders
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|Constants
operator|.
name|HADOOP_JAAS_DEBUG
import|;
end_import

begin_comment
comment|/**  * This is the AM, which directly implements the callbacks from the AM and NM  */
end_comment

begin_class
DECL|class|SliderAppMaster
specifier|public
class|class
name|SliderAppMaster
extends|extends
name|AbstractSliderLaunchedService
implements|implements
name|AMRMClientAsync
operator|.
name|CallbackHandler
implements|,
name|NMClientAsync
operator|.
name|CallbackHandler
implements|,
name|RunService
implements|,
name|SliderExitCodes
implements|,
name|SliderKeys
implements|,
name|ServiceStateChangeListener
implements|,
name|RoleKeys
implements|,
name|ProviderCompleted
implements|,
name|AppMasterActionOperations
block|{
DECL|field|log
specifier|protected
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SliderAppMaster
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * log for YARN events    */
DECL|field|LOG_YARN
specifier|protected
specifier|static
specifier|final
name|Logger
name|LOG_YARN
init|=
name|log
decl_stmt|;
DECL|field|SERVICE_CLASSNAME_SHORT
specifier|public
specifier|static
specifier|final
name|String
name|SERVICE_CLASSNAME_SHORT
init|=
literal|"SliderAppMaster"
decl_stmt|;
DECL|field|SERVICE_CLASSNAME
specifier|public
specifier|static
specifier|final
name|String
name|SERVICE_CLASSNAME
init|=
literal|"org.apache.slider.server.appmaster."
operator|+
name|SERVICE_CLASSNAME_SHORT
decl_stmt|;
DECL|field|HEARTBEAT_INTERVAL
specifier|public
specifier|static
specifier|final
name|int
name|HEARTBEAT_INTERVAL
init|=
literal|1000
decl_stmt|;
DECL|field|NUM_RPC_HANDLERS
specifier|public
specifier|static
specifier|final
name|int
name|NUM_RPC_HANDLERS
init|=
literal|5
decl_stmt|;
comment|/**    * Metrics and monitoring services.    * Deployed in {@link #serviceInit(Configuration)}    */
DECL|field|metricsAndMonitoring
specifier|private
specifier|final
name|MetricsAndMonitoring
name|metricsAndMonitoring
init|=
operator|new
name|MetricsAndMonitoring
argument_list|()
decl_stmt|;
comment|/**    * metrics registry    */
DECL|field|metrics
specifier|public
name|MetricRegistry
name|metrics
decl_stmt|;
comment|/** Error string on chaos monkey launch failure action: {@value} */
DECL|field|E_TRIGGERED_LAUNCH_FAILURE
specifier|public
specifier|static
specifier|final
name|String
name|E_TRIGGERED_LAUNCH_FAILURE
init|=
literal|"Chaos monkey triggered launch failure"
decl_stmt|;
comment|/** YARN RPC to communicate with the Resource Manager or Node Manager */
DECL|field|yarnRPC
specifier|private
name|YarnRPC
name|yarnRPC
decl_stmt|;
comment|/** Handle to communicate with the Resource Manager*/
annotation|@
name|SuppressWarnings
argument_list|(
literal|"FieldAccessedSynchronizedAndUnsynchronized"
argument_list|)
DECL|field|asyncRMClient
specifier|private
name|AMRMClientAsync
name|asyncRMClient
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"FieldAccessedSynchronizedAndUnsynchronized"
argument_list|)
DECL|field|rmOperationHandler
specifier|private
name|RMOperationHandler
name|rmOperationHandler
decl_stmt|;
DECL|field|providerRMOperationHandler
specifier|private
name|RMOperationHandler
name|providerRMOperationHandler
decl_stmt|;
comment|/** Handle to communicate with the Node Manager*/
annotation|@
name|SuppressWarnings
argument_list|(
literal|"FieldAccessedSynchronizedAndUnsynchronized"
argument_list|)
DECL|field|nmClientAsync
specifier|public
name|NMClientAsync
name|nmClientAsync
decl_stmt|;
comment|/**    * Credentials for propagating down to launched containers    */
DECL|field|containerCredentials
specifier|private
name|Credentials
name|containerCredentials
decl_stmt|;
comment|/**    * Slider IPC: Real service handler    */
DECL|field|sliderIPCService
specifier|private
name|SliderIPCService
name|sliderIPCService
decl_stmt|;
comment|/**    * Slider IPC: binding    */
DECL|field|rpcService
specifier|private
name|WorkflowRpcService
name|rpcService
decl_stmt|;
comment|/**    * Secret manager    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"FieldAccessedSynchronizedAndUnsynchronized"
argument_list|)
DECL|field|secretManager
specifier|private
name|ClientToAMTokenSecretManager
name|secretManager
decl_stmt|;
comment|/** Hostname of the container*/
DECL|field|appMasterHostname
specifier|private
name|String
name|appMasterHostname
init|=
literal|""
decl_stmt|;
comment|/* Port on which the app master listens for status updates from clients*/
DECL|field|appMasterRpcPort
specifier|private
name|int
name|appMasterRpcPort
init|=
literal|0
decl_stmt|;
comment|/** Tracking url to which app master publishes info for clients to monitor*/
annotation|@
name|SuppressWarnings
argument_list|(
literal|"FieldAccessedSynchronizedAndUnsynchronized"
argument_list|)
DECL|field|appMasterTrackingUrl
specifier|private
name|String
name|appMasterTrackingUrl
init|=
literal|""
decl_stmt|;
comment|/** Proxied app master URL (as retrieved from AM report at launch time) */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"FieldAccessedSynchronizedAndUnsynchronized"
argument_list|)
DECL|field|appMasterProxiedUrl
specifier|private
name|String
name|appMasterProxiedUrl
init|=
literal|""
decl_stmt|;
comment|/** Application Attempt Id ( combination of attemptId and fail count )*/
DECL|field|appAttemptID
specifier|private
name|ApplicationAttemptId
name|appAttemptID
decl_stmt|;
comment|/**    * App ACLs    */
DECL|field|applicationACLs
specifier|protected
name|Map
argument_list|<
name|ApplicationAccessType
argument_list|,
name|String
argument_list|>
name|applicationACLs
decl_stmt|;
comment|/**    * Ongoing state of the cluster: containers, nodes they    * live on, etc.    */
DECL|field|appState
specifier|private
specifier|final
name|AppState
name|appState
init|=
operator|new
name|AppState
argument_list|(
operator|new
name|ProtobufClusterServices
argument_list|()
argument_list|,
name|metricsAndMonitoring
argument_list|)
decl_stmt|;
comment|/**    * App state for external objects. This is almost entirely    * a read-only view of the application state. To change the state,    * Providers (or anything else) are expected to queue async changes.    */
DECL|field|stateForProviders
specifier|private
specifier|final
name|ProviderAppState
name|stateForProviders
init|=
operator|new
name|ProviderAppState
argument_list|(
literal|"undefined"
argument_list|,
name|appState
argument_list|)
decl_stmt|;
comment|/**    * model the state using locks and conditions    */
DECL|field|AMExecutionStateLock
specifier|private
specifier|final
name|ReentrantLock
name|AMExecutionStateLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
DECL|field|isAMCompleted
specifier|private
specifier|final
name|Condition
name|isAMCompleted
init|=
name|AMExecutionStateLock
operator|.
name|newCondition
argument_list|()
decl_stmt|;
comment|/**    * Flag set if the AM is to be shutdown    */
DECL|field|amCompletionFlag
specifier|private
specifier|final
name|AtomicBoolean
name|amCompletionFlag
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|/**    * Flag set during the init process    */
DECL|field|initCompleted
specifier|private
specifier|final
name|AtomicBoolean
name|initCompleted
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|/**    * Flag to set if the process exit code was set before shutdown started    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"FieldAccessedSynchronizedAndUnsynchronized"
argument_list|)
DECL|field|spawnedProcessExitedBeforeShutdownTriggered
specifier|private
name|boolean
name|spawnedProcessExitedBeforeShutdownTriggered
decl_stmt|;
comment|/** Arguments passed in : raw*/
annotation|@
name|SuppressWarnings
argument_list|(
literal|"FieldAccessedSynchronizedAndUnsynchronized"
argument_list|)
DECL|field|serviceArgs
specifier|private
name|SliderAMArgs
name|serviceArgs
decl_stmt|;
comment|/**    * ID of the AM container    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"FieldAccessedSynchronizedAndUnsynchronized"
argument_list|)
DECL|field|appMasterContainerID
specifier|private
name|ContainerId
name|appMasterContainerID
decl_stmt|;
comment|/**    * Monkey Service -may be null    */
DECL|field|monkey
specifier|private
name|ChaosMonkeyService
name|monkey
decl_stmt|;
comment|/**    * ProviderService of this cluster    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"FieldAccessedSynchronizedAndUnsynchronized"
argument_list|)
DECL|field|providerService
specifier|private
name|ProviderService
name|providerService
decl_stmt|;
comment|/**    * The YARN registry service    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"FieldAccessedSynchronizedAndUnsynchronized"
argument_list|)
DECL|field|registryOperations
specifier|private
name|RegistryOperations
name|registryOperations
decl_stmt|;
comment|/**    * The stop request received...the exit details are extracted    * from this    */
DECL|field|stopAction
specifier|private
specifier|volatile
name|ActionStopSlider
name|stopAction
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"FieldAccessedSynchronizedAndUnsynchronized"
argument_list|)
DECL|field|launchService
specifier|private
name|RoleLaunchService
name|launchService
decl_stmt|;
comment|//username -null if it is not known/not to be set
annotation|@
name|SuppressWarnings
argument_list|(
literal|"FieldAccessedSynchronizedAndUnsynchronized"
argument_list|)
DECL|field|hadoop_user_name
specifier|private
name|String
name|hadoop_user_name
decl_stmt|;
DECL|field|service_user_name
specifier|private
name|String
name|service_user_name
decl_stmt|;
DECL|field|webApp
specifier|private
name|SliderAMWebApp
name|webApp
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"FieldAccessedSynchronizedAndUnsynchronized"
argument_list|)
DECL|field|rpcServiceAddress
specifier|private
name|InetSocketAddress
name|rpcServiceAddress
decl_stmt|;
DECL|field|sliderAMProvider
specifier|private
name|SliderAMProviderService
name|sliderAMProvider
decl_stmt|;
comment|/**    * Executor.    * Assigned in {@link #serviceInit(Configuration)}    */
DECL|field|executorService
specifier|private
name|WorkflowExecutorService
argument_list|<
name|ExecutorService
argument_list|>
name|executorService
decl_stmt|;
comment|/**    * Action queues. Created at instance creation, but    * added as a child and inited in {@link #serviceInit(Configuration)}    */
DECL|field|actionQueues
specifier|private
specifier|final
name|QueueService
name|actionQueues
init|=
operator|new
name|QueueService
argument_list|()
decl_stmt|;
DECL|field|agentOpsUrl
specifier|private
name|String
name|agentOpsUrl
decl_stmt|;
DECL|field|agentStatusUrl
specifier|private
name|String
name|agentStatusUrl
decl_stmt|;
DECL|field|yarnRegistryOperations
specifier|private
name|YarnRegistryViewForProviders
name|yarnRegistryOperations
decl_stmt|;
comment|//private FsDelegationTokenManager fsDelegationTokenManager;
DECL|field|amRegistrationData
specifier|private
name|RegisterApplicationMasterResponse
name|amRegistrationData
decl_stmt|;
DECL|field|portScanner
specifier|private
name|PortScanner
name|portScanner
decl_stmt|;
DECL|field|securityConfiguration
specifier|private
name|SecurityConfiguration
name|securityConfiguration
decl_stmt|;
comment|/**    * Is security enabled?    * Set early on in the {@link #createAndRunCluster(String)} operation.    */
DECL|field|securityEnabled
specifier|private
name|boolean
name|securityEnabled
decl_stmt|;
DECL|field|contentCache
specifier|private
name|ContentCache
name|contentCache
decl_stmt|;
comment|/**    * resource limits    */
DECL|field|maximumResourceCapability
specifier|private
name|Resource
name|maximumResourceCapability
decl_stmt|;
comment|/**    * Service Constructor    */
DECL|method|SliderAppMaster ()
specifier|public
name|SliderAppMaster
parameter_list|()
block|{
name|super
argument_list|(
name|SERVICE_CLASSNAME_SHORT
argument_list|)
expr_stmt|;
operator|new
name|HdfsConfiguration
argument_list|()
expr_stmt|;
operator|new
name|YarnConfiguration
argument_list|()
expr_stmt|;
block|}
comment|/* =================================================================== */
comment|/* service lifecycle methods */
comment|/* =================================================================== */
annotation|@
name|Override
comment|//AbstractService
DECL|method|serviceInit (Configuration conf)
specifier|public
specifier|synchronized
name|void
name|serviceInit
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
comment|// slider client if found
name|Configuration
name|customConf
init|=
name|SliderUtils
operator|.
name|loadSliderClientXML
argument_list|()
decl_stmt|;
comment|// Load in the server configuration - if it is actually on the Classpath
name|URL
name|serverXmlUrl
init|=
name|ConfigHelper
operator|.
name|getResourceUrl
argument_list|(
name|SLIDER_SERVER_XML
argument_list|)
decl_stmt|;
if|if
condition|(
name|serverXmlUrl
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Loading {} at {}"
argument_list|,
name|SLIDER_SERVER_XML
argument_list|,
name|serverXmlUrl
argument_list|)
expr_stmt|;
name|Configuration
name|serverConf
init|=
name|ConfigHelper
operator|.
name|loadFromResource
argument_list|(
name|SLIDER_SERVER_XML
argument_list|)
decl_stmt|;
name|ConfigHelper
operator|.
name|mergeConfigurations
argument_list|(
name|customConf
argument_list|,
name|serverConf
argument_list|,
name|SLIDER_SERVER_XML
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|serviceArgs
operator|.
name|applyDefinitions
argument_list|(
name|customConf
argument_list|)
expr_stmt|;
name|serviceArgs
operator|.
name|applyFileSystemBinding
argument_list|(
name|customConf
argument_list|)
expr_stmt|;
comment|// conf now contains all customizations
name|AbstractActionArgs
name|action
init|=
name|serviceArgs
operator|.
name|getCoreAction
argument_list|()
decl_stmt|;
name|SliderAMCreateAction
name|createAction
init|=
operator|(
name|SliderAMCreateAction
operator|)
name|action
decl_stmt|;
comment|// sort out the location of the AM
name|String
name|rmAddress
init|=
name|createAction
operator|.
name|getRmAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|rmAddress
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Setting RM address from the command line: {}"
argument_list|,
name|rmAddress
argument_list|)
expr_stmt|;
name|SliderUtils
operator|.
name|setRmSchedulerAddress
argument_list|(
name|customConf
argument_list|,
name|rmAddress
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"AM configuration:\n{}"
argument_list|,
name|ConfigHelper
operator|.
name|dumpConfigToString
argument_list|(
name|customConf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|envs
range|:
name|System
operator|.
name|getenv
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"System env {}={}"
argument_list|,
name|envs
operator|.
name|getKey
argument_list|()
argument_list|,
name|envs
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ConfigHelper
operator|.
name|mergeConfigurations
argument_list|(
name|conf
argument_list|,
name|customConf
argument_list|,
name|SLIDER_CLIENT_XML
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|//init security with our conf
if|if
condition|(
name|SliderUtils
operator|.
name|isHadoopClusterSecure
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Secure mode with kerberos realm {}"
argument_list|,
name|SliderUtils
operator|.
name|getKerberosRealm
argument_list|()
argument_list|)
expr_stmt|;
name|UserGroupInformation
operator|.
name|setConfiguration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|UserGroupInformation
name|ugi
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Authenticating as {}"
argument_list|,
name|ugi
argument_list|)
expr_stmt|;
name|SliderUtils
operator|.
name|verifyPrincipalSet
argument_list|(
name|conf
argument_list|,
name|DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Cluster is insecure"
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Login user is {}"
argument_list|,
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
argument_list|)
expr_stmt|;
comment|//look at settings of Hadoop Auth, to pick up a problem seen once
name|checkAndWarnForAuthTokenProblems
argument_list|()
expr_stmt|;
comment|// validate server env
name|boolean
name|dependencyChecks
init|=
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
name|KEY_SLIDER_AM_DEPENDENCY_CHECKS_DISABLED
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|SliderUtils
operator|.
name|validateSliderServerEnvironment
argument_list|(
name|log
argument_list|,
name|dependencyChecks
argument_list|)
expr_stmt|;
comment|// create and register monitoring services
name|addService
argument_list|(
name|metricsAndMonitoring
argument_list|)
expr_stmt|;
name|metrics
operator|=
name|metricsAndMonitoring
operator|.
name|getMetrics
argument_list|()
expr_stmt|;
comment|/* TODO: turn these one once the metrics testing is more under control     metrics.registerAll(new ThreadStatesGaugeSet());     metrics.registerAll(new MemoryUsageGaugeSet());     metrics.registerAll(new GarbageCollectorMetricSet());  */
name|contentCache
operator|=
name|ApplicationResouceContentCacheFactory
operator|.
name|createContentCache
argument_list|(
name|stateForProviders
argument_list|)
expr_stmt|;
name|executorService
operator|=
operator|new
name|WorkflowExecutorService
argument_list|<>
argument_list|(
literal|"AmExecutor"
argument_list|,
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
literal|2
argument_list|,
operator|new
name|ServiceThreadFactory
argument_list|(
literal|"AmExecutor"
argument_list|,
literal|true
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|addService
argument_list|(
name|executorService
argument_list|)
expr_stmt|;
name|addService
argument_list|(
name|actionQueues
argument_list|)
expr_stmt|;
comment|//init all child services
name|super
operator|.
name|serviceInit
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|serviceStart ()
specifier|protected
name|void
name|serviceStart
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|serviceStart
argument_list|()
expr_stmt|;
name|HealthCheckRegistry
name|health
init|=
name|metricsAndMonitoring
operator|.
name|getHealth
argument_list|()
decl_stmt|;
name|health
operator|.
name|register
argument_list|(
literal|"AM Health"
argument_list|,
operator|new
name|YarnServiceHealthCheck
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Start the queue processing    */
DECL|method|startQueueProcessing ()
specifier|private
name|void
name|startQueueProcessing
parameter_list|()
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Queue Processing started"
argument_list|)
expr_stmt|;
name|executorService
operator|.
name|execute
argument_list|(
name|actionQueues
argument_list|)
expr_stmt|;
name|executorService
operator|.
name|execute
argument_list|(
operator|new
name|QueueExecutor
argument_list|(
name|this
argument_list|,
name|actionQueues
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* =================================================================== */
comment|/* RunService methods called from ServiceLauncher */
comment|/* =================================================================== */
comment|/**    * pick up the args from the service launcher    * @param config configuration    * @param args argument list    */
annotation|@
name|Override
comment|// RunService
DECL|method|bindArgs (Configuration config, String... args)
specifier|public
name|Configuration
name|bindArgs
parameter_list|(
name|Configuration
name|config
parameter_list|,
name|String
modifier|...
name|args
parameter_list|)
throws|throws
name|Exception
block|{
comment|// let the superclass process it
name|Configuration
name|superConf
init|=
name|super
operator|.
name|bindArgs
argument_list|(
name|config
argument_list|,
name|args
argument_list|)
decl_stmt|;
comment|// add the slider XML config
name|ConfigHelper
operator|.
name|injectSliderXMLResource
argument_list|()
expr_stmt|;
comment|//yarn-ify
name|YarnConfiguration
name|yarnConfiguration
init|=
operator|new
name|YarnConfiguration
argument_list|(
name|superConf
argument_list|)
decl_stmt|;
name|serviceArgs
operator|=
operator|new
name|SliderAMArgs
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|serviceArgs
operator|.
name|parse
argument_list|()
expr_stmt|;
return|return
name|SliderUtils
operator|.
name|patchConfiguration
argument_list|(
name|yarnConfiguration
argument_list|)
return|;
block|}
comment|/**    * this is called by service launcher; when it returns the application finishes    * @return the exit code to return by the app    * @throws Throwable    */
annotation|@
name|Override
DECL|method|runService ()
specifier|public
name|int
name|runService
parameter_list|()
throws|throws
name|Throwable
block|{
name|SliderVersionInfo
operator|.
name|loadAndPrintVersionInfo
argument_list|(
name|log
argument_list|)
expr_stmt|;
comment|//dump the system properties if in debug mode
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"System properties:\n"
operator|+
name|SliderUtils
operator|.
name|propertiesToString
argument_list|(
name|System
operator|.
name|getProperties
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//choose the action
name|String
name|action
init|=
name|serviceArgs
operator|.
name|getAction
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|actionArgs
init|=
name|serviceArgs
operator|.
name|getActionArgs
argument_list|()
decl_stmt|;
name|int
name|exitCode
decl_stmt|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|SliderActions
operator|.
name|ACTION_HELP
case|:
name|log
operator|.
name|info
argument_list|(
literal|"{}: {}"
argument_list|,
name|getName
argument_list|()
argument_list|,
name|serviceArgs
operator|.
name|usage
argument_list|()
argument_list|)
expr_stmt|;
name|exitCode
operator|=
name|SliderExitCodes
operator|.
name|EXIT_USAGE
expr_stmt|;
break|break;
case|case
name|SliderActions
operator|.
name|ACTION_CREATE
case|:
name|exitCode
operator|=
name|createAndRunCluster
argument_list|(
name|actionArgs
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SliderException
argument_list|(
literal|"Unimplemented: "
operator|+
name|action
argument_list|)
throw|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Exiting AM; final exit code = {}"
argument_list|,
name|exitCode
argument_list|)
expr_stmt|;
return|return
name|exitCode
return|;
block|}
comment|/**    * Initialize a newly created service then add it.     * Because the service is not started, this MUST be done before    * the AM itself starts, or it is explicitly added after    * @param service the service to init    */
DECL|method|initAndAddService (Service service)
specifier|public
name|Service
name|initAndAddService
parameter_list|(
name|Service
name|service
parameter_list|)
block|{
name|service
operator|.
name|init
argument_list|(
name|getConfig
argument_list|()
argument_list|)
expr_stmt|;
name|addService
argument_list|(
name|service
argument_list|)
expr_stmt|;
return|return
name|service
return|;
block|}
comment|/* =================================================================== */
comment|/**    * Create and run the cluster.    * @param clustername cluster name    * @return exit code    * @throws Throwable on a failure    */
DECL|method|createAndRunCluster (String clustername)
specifier|private
name|int
name|createAndRunCluster
parameter_list|(
name|String
name|clustername
parameter_list|)
throws|throws
name|Throwable
block|{
comment|//load the cluster description from the cd argument
name|String
name|sliderClusterDir
init|=
name|serviceArgs
operator|.
name|getSliderClusterURI
argument_list|()
decl_stmt|;
name|URI
name|sliderClusterURI
init|=
operator|new
name|URI
argument_list|(
name|sliderClusterDir
argument_list|)
decl_stmt|;
name|Path
name|clusterDirPath
init|=
operator|new
name|Path
argument_list|(
name|sliderClusterURI
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Application defined at {}"
argument_list|,
name|sliderClusterURI
argument_list|)
expr_stmt|;
name|SliderFileSystem
name|fs
init|=
name|getClusterFS
argument_list|()
decl_stmt|;
comment|// build up information about the running application -this
comment|// will be passed down to the cluster status
name|MapOperations
name|appInformation
init|=
operator|new
name|MapOperations
argument_list|()
decl_stmt|;
name|AggregateConf
name|instanceDefinition
init|=
name|InstanceIO
operator|.
name|loadInstanceDefinitionUnresolved
argument_list|(
name|fs
argument_list|,
name|clusterDirPath
argument_list|)
decl_stmt|;
name|instanceDefinition
operator|.
name|setName
argument_list|(
name|clustername
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Deploying cluster {}:"
argument_list|,
name|instanceDefinition
argument_list|)
expr_stmt|;
comment|// and resolve it
name|AggregateConf
name|resolvedInstance
init|=
operator|new
name|AggregateConf
argument_list|(
name|instanceDefinition
argument_list|)
decl_stmt|;
name|resolvedInstance
operator|.
name|resolve
argument_list|()
expr_stmt|;
name|stateForProviders
operator|.
name|setApplicationName
argument_list|(
name|clustername
argument_list|)
expr_stmt|;
name|Configuration
name|serviceConf
init|=
name|getConfig
argument_list|()
decl_stmt|;
comment|// extend AM configuration with component resource
name|MapOperations
name|amConfiguration
init|=
name|resolvedInstance
operator|.
name|getAppConfOperations
argument_list|()
operator|.
name|getComponent
argument_list|(
name|COMPONENT_AM
argument_list|)
decl_stmt|;
comment|// and patch configuration with prefix
if|if
condition|(
name|amConfiguration
operator|!=
literal|null
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|sliderAppConfKeys
init|=
name|amConfiguration
operator|.
name|prefixedWith
argument_list|(
literal|"slider."
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|sliderAppConfKeys
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|k
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|v
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|boolean
name|exists
init|=
name|serviceConf
operator|.
name|get
argument_list|(
name|k
argument_list|)
operator|!=
literal|null
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"{} {} to {}"
argument_list|,
operator|(
name|exists
condition|?
literal|"Overwriting"
else|:
literal|"Setting"
operator|)
argument_list|,
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|serviceConf
operator|.
name|set
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
name|securityConfiguration
operator|=
operator|new
name|SecurityConfiguration
argument_list|(
name|serviceConf
argument_list|,
name|resolvedInstance
argument_list|,
name|clustername
argument_list|)
expr_stmt|;
comment|// obtain security state
name|securityEnabled
operator|=
name|securityConfiguration
operator|.
name|isSecurityEnabled
argument_list|()
expr_stmt|;
comment|// set the global security flag for the instance definition
name|instanceDefinition
operator|.
name|getAppConfOperations
argument_list|()
operator|.
name|set
argument_list|(
name|KEY_SECURITY_ENABLED
argument_list|,
name|securityEnabled
argument_list|)
expr_stmt|;
comment|// triggers resolution and snapshotting for agent
name|appState
operator|.
name|setInitialInstanceDefinition
argument_list|(
name|instanceDefinition
argument_list|)
expr_stmt|;
name|File
name|confDir
init|=
name|getLocalConfDir
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|confDir
operator|.
name|exists
argument_list|()
operator|||
operator|!
name|confDir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Conf dir {} does not exist."
argument_list|,
name|confDir
argument_list|)
expr_stmt|;
name|File
name|parentFile
init|=
name|confDir
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Parent dir {}:\n{}"
argument_list|,
name|parentFile
argument_list|,
name|SliderUtils
operator|.
name|listDir
argument_list|(
name|parentFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//get our provider
name|MapOperations
name|globalInternalOptions
init|=
name|getGlobalInternalOptions
argument_list|()
decl_stmt|;
name|String
name|providerType
init|=
name|globalInternalOptions
operator|.
name|getMandatoryOption
argument_list|(
name|InternalKeys
operator|.
name|INTERNAL_PROVIDER_NAME
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Cluster provider type is {}"
argument_list|,
name|providerType
argument_list|)
expr_stmt|;
name|SliderProviderFactory
name|factory
init|=
name|SliderProviderFactory
operator|.
name|createSliderProviderFactory
argument_list|(
name|providerType
argument_list|)
decl_stmt|;
name|providerService
operator|=
name|factory
operator|.
name|createServerProvider
argument_list|()
expr_stmt|;
comment|// init the provider BUT DO NOT START IT YET
name|initAndAddService
argument_list|(
name|providerService
argument_list|)
expr_stmt|;
name|providerRMOperationHandler
operator|=
operator|new
name|ProviderNotifyingOperationHandler
argument_list|(
name|providerService
argument_list|)
expr_stmt|;
comment|// create a slider AM provider
name|sliderAMProvider
operator|=
operator|new
name|SliderAMProviderService
argument_list|()
expr_stmt|;
name|initAndAddService
argument_list|(
name|sliderAMProvider
argument_list|)
expr_stmt|;
name|InetSocketAddress
name|rmSchedulerAddress
init|=
name|SliderUtils
operator|.
name|getRmSchedulerAddress
argument_list|(
name|serviceConf
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"RM is at {}"
argument_list|,
name|rmSchedulerAddress
argument_list|)
expr_stmt|;
name|yarnRPC
operator|=
name|YarnRPC
operator|.
name|create
argument_list|(
name|serviceConf
argument_list|)
expr_stmt|;
comment|// set up the YARN client. This may require patching in the RM client-API address if it
comment|// is (somehow) unset server-side.    String clientRMaddr = serviceConf.get(YarnConfiguration.RM_ADDRESS);
name|InetSocketAddress
name|clientRpcAddress
init|=
name|SliderUtils
operator|.
name|getRmAddress
argument_list|(
name|serviceConf
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SliderUtils
operator|.
name|isAddressDefined
argument_list|(
name|clientRpcAddress
argument_list|)
condition|)
block|{
comment|// client addr is being unset. We can lift it from the other RM APIs
name|log
operator|.
name|warn
argument_list|(
literal|"Yarn RM address was unbound; attempting to fix up"
argument_list|)
expr_stmt|;
name|serviceConf
operator|.
name|set
argument_list|(
name|YarnConfiguration
operator|.
name|RM_ADDRESS
argument_list|,
name|String
operator|.
name|format
argument_list|(
literal|"%s:%d"
argument_list|,
name|rmSchedulerAddress
operator|.
name|getHostString
argument_list|()
argument_list|,
name|clientRpcAddress
operator|.
name|getPort
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*      * Extract the container ID. This is then      * turned into an (incomplete) container      */
name|appMasterContainerID
operator|=
name|ConverterUtils
operator|.
name|toContainerId
argument_list|(
name|SliderUtils
operator|.
name|mandatoryEnvVariable
argument_list|(
name|ApplicationConstants
operator|.
name|Environment
operator|.
name|CONTAINER_ID
operator|.
name|name
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|appAttemptID
operator|=
name|appMasterContainerID
operator|.
name|getApplicationAttemptId
argument_list|()
expr_stmt|;
name|ApplicationId
name|appid
init|=
name|appAttemptID
operator|.
name|getApplicationId
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"AM for ID {}"
argument_list|,
name|appid
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|appInformation
operator|.
name|put
argument_list|(
name|StatusKeys
operator|.
name|INFO_AM_CONTAINER_ID
argument_list|,
name|appMasterContainerID
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|appInformation
operator|.
name|put
argument_list|(
name|StatusKeys
operator|.
name|INFO_AM_APP_ID
argument_list|,
name|appid
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|appInformation
operator|.
name|put
argument_list|(
name|StatusKeys
operator|.
name|INFO_AM_ATTEMPT_ID
argument_list|,
name|appAttemptID
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|envVars
decl_stmt|;
name|List
argument_list|<
name|Container
argument_list|>
name|liveContainers
decl_stmt|;
comment|/*      * It is critical this section is synchronized, to stop async AM events      * arriving while registering a restarting AM.      */
synchronized|synchronized
init|(
name|appState
init|)
block|{
name|int
name|heartbeatInterval
init|=
name|HEARTBEAT_INTERVAL
decl_stmt|;
comment|// configure AM to wait forever for RM
name|getConfig
argument_list|()
operator|.
name|setLong
argument_list|(
name|YarnConfiguration
operator|.
name|RESOURCEMANAGER_CONNECT_MAX_WAIT_MS
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|getConfig
argument_list|()
operator|.
name|unset
argument_list|(
name|YarnConfiguration
operator|.
name|CLIENT_FAILOVER_MAX_ATTEMPTS
argument_list|)
expr_stmt|;
comment|// add the RM client -this brings the callbacks in
name|asyncRMClient
operator|=
name|AMRMClientAsync
operator|.
name|createAMRMClientAsync
argument_list|(
name|heartbeatInterval
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|addService
argument_list|(
name|asyncRMClient
argument_list|)
expr_stmt|;
comment|//now bring it up
name|deployChildService
argument_list|(
name|asyncRMClient
argument_list|)
expr_stmt|;
comment|// nmclient relays callbacks back to this class
name|nmClientAsync
operator|=
operator|new
name|NMClientAsyncImpl
argument_list|(
literal|"nmclient"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|deployChildService
argument_list|(
name|nmClientAsync
argument_list|)
expr_stmt|;
comment|// set up secret manager
name|secretManager
operator|=
operator|new
name|ClientToAMTokenSecretManager
argument_list|(
name|appAttemptID
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|securityEnabled
condition|)
block|{
comment|// fix up the ACLs if they are not set
name|String
name|acls
init|=
name|serviceConf
operator|.
name|get
argument_list|(
name|KEY_PROTOCOL_ACL
argument_list|)
decl_stmt|;
if|if
condition|(
name|acls
operator|==
literal|null
condition|)
block|{
name|getConfig
argument_list|()
operator|.
name|set
argument_list|(
name|KEY_PROTOCOL_ACL
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
block|}
block|}
comment|//bring up the Slider RPC service
name|buildPortScanner
argument_list|(
name|instanceDefinition
argument_list|)
expr_stmt|;
name|startSliderRPCServer
argument_list|(
name|instanceDefinition
argument_list|)
expr_stmt|;
name|rpcServiceAddress
operator|=
name|rpcService
operator|.
name|getConnectAddress
argument_list|()
expr_stmt|;
name|appMasterHostname
operator|=
name|rpcServiceAddress
operator|.
name|getAddress
argument_list|()
operator|.
name|getCanonicalHostName
argument_list|()
expr_stmt|;
name|appMasterRpcPort
operator|=
name|rpcServiceAddress
operator|.
name|getPort
argument_list|()
expr_stmt|;
name|appMasterTrackingUrl
operator|=
literal|null
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"AM Server is listening at {}:{}"
argument_list|,
name|appMasterHostname
argument_list|,
name|appMasterRpcPort
argument_list|)
expr_stmt|;
name|appInformation
operator|.
name|put
argument_list|(
name|StatusKeys
operator|.
name|INFO_AM_HOSTNAME
argument_list|,
name|appMasterHostname
argument_list|)
expr_stmt|;
name|appInformation
operator|.
name|set
argument_list|(
name|StatusKeys
operator|.
name|INFO_AM_RPC_PORT
argument_list|,
name|appMasterRpcPort
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Starting Yarn registry"
argument_list|)
expr_stmt|;
name|registryOperations
operator|=
name|startRegistryOperationsService
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
name|registryOperations
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|//build the role map
name|List
argument_list|<
name|ProviderRole
argument_list|>
name|providerRoles
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|providerService
operator|.
name|getRoles
argument_list|()
argument_list|)
decl_stmt|;
name|providerRoles
operator|.
name|addAll
argument_list|(
name|SliderAMClientProvider
operator|.
name|ROLES
argument_list|)
expr_stmt|;
comment|// Start up the WebApp and track the URL for it
name|MapOperations
name|component
init|=
name|instanceDefinition
operator|.
name|getAppConfOperations
argument_list|()
operator|.
name|getComponent
argument_list|(
name|SliderKeys
operator|.
name|COMPONENT_AM
argument_list|)
decl_stmt|;
comment|// Web service endpoints: initialize
name|WebAppApiImpl
name|webAppApi
init|=
operator|new
name|WebAppApiImpl
argument_list|(
name|stateForProviders
argument_list|,
name|providerService
argument_list|,
name|registryOperations
argument_list|,
name|metricsAndMonitoring
argument_list|,
name|actionQueues
argument_list|,
name|this
argument_list|,
name|contentCache
argument_list|)
decl_stmt|;
name|initAMFilterOptions
argument_list|(
name|serviceConf
argument_list|)
expr_stmt|;
name|int
name|webAppPort
init|=
name|deployWebApplication
argument_list|(
name|webAppApi
argument_list|)
decl_stmt|;
name|String
name|scheme
init|=
name|WebAppUtils
operator|.
name|HTTP_PREFIX
decl_stmt|;
name|appMasterTrackingUrl
operator|=
name|scheme
operator|+
name|appMasterHostname
operator|+
literal|":"
operator|+
name|webAppPort
expr_stmt|;
name|appInformation
operator|.
name|put
argument_list|(
name|StatusKeys
operator|.
name|INFO_AM_WEB_URL
argument_list|,
name|appMasterTrackingUrl
operator|+
literal|"/"
argument_list|)
expr_stmt|;
name|appInformation
operator|.
name|set
argument_list|(
name|StatusKeys
operator|.
name|INFO_AM_WEB_PORT
argument_list|,
name|webAppPort
argument_list|)
expr_stmt|;
comment|// *****************************************************
comment|// Register self with ResourceManager
comment|// This will start heartbeating to the RM
comment|// address = SliderUtils.getRmSchedulerAddress(asyncRMClient.getConfig());
comment|// *****************************************************
name|log
operator|.
name|info
argument_list|(
literal|"Connecting to RM at {}; AM tracking URL={}"
argument_list|,
name|appMasterRpcPort
argument_list|,
name|appMasterTrackingUrl
argument_list|)
expr_stmt|;
name|amRegistrationData
operator|=
name|asyncRMClient
operator|.
name|registerApplicationMaster
argument_list|(
name|appMasterHostname
argument_list|,
name|appMasterRpcPort
argument_list|,
name|appMasterTrackingUrl
argument_list|)
expr_stmt|;
name|maximumResourceCapability
operator|=
name|amRegistrationData
operator|.
name|getMaximumResourceCapability
argument_list|()
expr_stmt|;
name|int
name|minMemory
init|=
name|serviceConf
operator|.
name|getInt
argument_list|(
name|RM_SCHEDULER_MINIMUM_ALLOCATION_MB
argument_list|,
name|DEFAULT_RM_SCHEDULER_MINIMUM_ALLOCATION_MB
argument_list|)
decl_stmt|;
comment|// validate scheduler vcores allocation setting
name|int
name|minCores
init|=
name|serviceConf
operator|.
name|getInt
argument_list|(
name|RM_SCHEDULER_MINIMUM_ALLOCATION_VCORES
argument_list|,
name|DEFAULT_RM_SCHEDULER_MINIMUM_ALLOCATION_VCORES
argument_list|)
decl_stmt|;
name|int
name|maxMemory
init|=
name|maximumResourceCapability
operator|.
name|getMemory
argument_list|()
decl_stmt|;
name|int
name|maxCores
init|=
name|maximumResourceCapability
operator|.
name|getVirtualCores
argument_list|()
decl_stmt|;
name|appState
operator|.
name|setContainerLimits
argument_list|(
name|minMemory
argument_list|,
name|maxMemory
argument_list|,
name|minCores
argument_list|,
name|maxCores
argument_list|)
expr_stmt|;
comment|// build the handler for RM request/release operations; this uses
comment|// the max value as part of its lookup
name|rmOperationHandler
operator|=
operator|new
name|AsyncRMOperationHandler
argument_list|(
name|asyncRMClient
argument_list|,
name|maximumResourceCapability
argument_list|)
expr_stmt|;
comment|// set the RM-defined maximum cluster values
name|appInformation
operator|.
name|put
argument_list|(
name|ResourceKeys
operator|.
name|YARN_CORES
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|maxCores
argument_list|)
argument_list|)
expr_stmt|;
name|appInformation
operator|.
name|put
argument_list|(
name|ResourceKeys
operator|.
name|YARN_MEMORY
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|maxMemory
argument_list|)
argument_list|)
expr_stmt|;
name|processAMCredentials
argument_list|(
name|securityConfiguration
argument_list|)
expr_stmt|;
if|if
condition|(
name|securityEnabled
condition|)
block|{
name|secretManager
operator|.
name|setMasterKey
argument_list|(
name|amRegistrationData
operator|.
name|getClientToAMTokenMasterKey
argument_list|()
operator|.
name|array
argument_list|()
argument_list|)
expr_stmt|;
name|applicationACLs
operator|=
name|amRegistrationData
operator|.
name|getApplicationACLs
argument_list|()
expr_stmt|;
comment|//tell the server what the ACLs are
name|rpcService
operator|.
name|getServer
argument_list|()
operator|.
name|refreshServiceAcl
argument_list|(
name|serviceConf
argument_list|,
operator|new
name|SliderAMPolicyProvider
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|securityConfiguration
operator|.
name|isKeytabProvided
argument_list|()
condition|)
block|{
comment|// perform keytab based login to establish kerberos authenticated
comment|// principal.  Can do so now since AM registration with RM above required
comment|// tokens associated to principal
name|String
name|principal
init|=
name|securityConfiguration
operator|.
name|getPrincipal
argument_list|()
decl_stmt|;
name|File
name|localKeytabFile
init|=
name|securityConfiguration
operator|.
name|getKeytabFile
argument_list|(
name|instanceDefinition
argument_list|)
decl_stmt|;
comment|// Now log in...
name|login
argument_list|(
name|principal
argument_list|,
name|localKeytabFile
argument_list|)
expr_stmt|;
comment|// obtain new FS reference that should be kerberos based and different
comment|// than the previously cached reference
name|fs
operator|=
operator|new
name|SliderFileSystem
argument_list|(
name|serviceConf
argument_list|)
expr_stmt|;
block|}
block|}
comment|// YARN client.
comment|// Important: this is only valid at startup, and must be executed within
comment|// the right UGI context. Use with care.
name|SliderYarnClientImpl
name|yarnClient
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|NodeReport
argument_list|>
name|nodeReports
decl_stmt|;
try|try
block|{
name|yarnClient
operator|=
operator|new
name|SliderYarnClientImpl
argument_list|()
expr_stmt|;
name|yarnClient
operator|.
name|init
argument_list|(
name|getConfig
argument_list|()
argument_list|)
expr_stmt|;
name|yarnClient
operator|.
name|start
argument_list|()
expr_stmt|;
name|nodeReports
operator|=
name|getNodeReports
argument_list|(
name|yarnClient
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Yarn node report count: {}"
argument_list|,
name|nodeReports
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// look up the application itself -this is needed to get the proxied
comment|// URL of the AM, for registering endpoints.
comment|// this call must be made after the AM has registered itself, obviously
name|ApplicationAttemptReport
name|report
init|=
name|getApplicationAttemptReport
argument_list|(
name|yarnClient
argument_list|)
decl_stmt|;
name|appMasterProxiedUrl
operator|=
name|report
operator|.
name|getTrackingUrl
argument_list|()
expr_stmt|;
if|if
condition|(
name|SliderUtils
operator|.
name|isUnset
argument_list|(
name|appMasterProxiedUrl
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Proxied URL is not set in application report"
argument_list|)
expr_stmt|;
name|appMasterProxiedUrl
operator|=
name|appMasterTrackingUrl
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|// at this point yarnClient is no longer needed.
comment|// stop it immediately
name|ServiceOperations
operator|.
name|stop
argument_list|(
name|yarnClient
argument_list|)
expr_stmt|;
name|yarnClient
operator|=
literal|null
expr_stmt|;
block|}
comment|// extract container list
name|liveContainers
operator|=
name|amRegistrationData
operator|.
name|getContainersFromPreviousAttempts
argument_list|()
expr_stmt|;
comment|//now validate the installation
name|Configuration
name|providerConf
init|=
name|providerService
operator|.
name|loadProviderConfigurationInformation
argument_list|(
name|confDir
argument_list|)
decl_stmt|;
name|providerService
operator|.
name|initializeApplicationConfiguration
argument_list|(
name|instanceDefinition
argument_list|,
name|fs
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|providerService
operator|.
name|validateApplicationConfiguration
argument_list|(
name|instanceDefinition
argument_list|,
name|confDir
argument_list|,
name|securityEnabled
argument_list|)
expr_stmt|;
comment|//determine the location for the role history data
name|Path
name|historyDir
init|=
operator|new
name|Path
argument_list|(
name|clusterDirPath
argument_list|,
name|HISTORY_DIR_NAME
argument_list|)
decl_stmt|;
comment|//build the instance
name|AppStateBindingInfo
name|binding
init|=
operator|new
name|AppStateBindingInfo
argument_list|()
decl_stmt|;
name|binding
operator|.
name|instanceDefinition
operator|=
name|instanceDefinition
expr_stmt|;
name|binding
operator|.
name|serviceConfig
operator|=
name|serviceConf
expr_stmt|;
name|binding
operator|.
name|publishedProviderConf
operator|=
name|providerConf
expr_stmt|;
name|binding
operator|.
name|roles
operator|=
name|providerRoles
expr_stmt|;
name|binding
operator|.
name|fs
operator|=
name|fs
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
name|binding
operator|.
name|historyPath
operator|=
name|historyDir
expr_stmt|;
name|binding
operator|.
name|liveContainers
operator|=
name|liveContainers
expr_stmt|;
name|binding
operator|.
name|applicationInfo
operator|=
name|appInformation
expr_stmt|;
name|binding
operator|.
name|releaseSelector
operator|=
name|providerService
operator|.
name|createContainerReleaseSelector
argument_list|()
expr_stmt|;
name|binding
operator|.
name|nodeReports
operator|=
name|nodeReports
expr_stmt|;
name|appState
operator|.
name|buildInstance
argument_list|(
name|binding
argument_list|)
expr_stmt|;
name|providerService
operator|.
name|rebuildContainerDetails
argument_list|(
name|liveContainers
argument_list|,
name|instanceDefinition
operator|.
name|getName
argument_list|()
argument_list|,
name|appState
operator|.
name|getRolePriorityMap
argument_list|()
argument_list|)
expr_stmt|;
comment|// add the AM to the list of nodes in the cluster
name|appState
operator|.
name|buildAppMasterNode
argument_list|(
name|appMasterContainerID
argument_list|,
name|appMasterHostname
argument_list|,
name|webAppPort
argument_list|,
name|appMasterHostname
operator|+
literal|":"
operator|+
name|webAppPort
argument_list|)
expr_stmt|;
comment|// build up environment variables that the AM wants set in every container
comment|// irrespective of provider and role.
name|envVars
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
if|if
condition|(
name|hadoop_user_name
operator|!=
literal|null
condition|)
block|{
name|envVars
operator|.
name|put
argument_list|(
name|HADOOP_USER_NAME
argument_list|,
name|hadoop_user_name
argument_list|)
expr_stmt|;
block|}
name|String
name|debug_kerberos
init|=
name|System
operator|.
name|getenv
argument_list|(
name|HADOOP_JAAS_DEBUG
argument_list|)
decl_stmt|;
if|if
condition|(
name|debug_kerberos
operator|!=
literal|null
condition|)
block|{
name|envVars
operator|.
name|put
argument_list|(
name|HADOOP_JAAS_DEBUG
argument_list|,
name|debug_kerberos
argument_list|)
expr_stmt|;
block|}
block|}
name|String
name|rolesTmpSubdir
init|=
name|appMasterContainerID
operator|.
name|toString
argument_list|()
operator|+
literal|"/roles"
decl_stmt|;
name|String
name|amTmpDir
init|=
name|globalInternalOptions
operator|.
name|getMandatoryOption
argument_list|(
name|InternalKeys
operator|.
name|INTERNAL_AM_TMP_DIR
argument_list|)
decl_stmt|;
name|Path
name|tmpDirPath
init|=
operator|new
name|Path
argument_list|(
name|amTmpDir
argument_list|)
decl_stmt|;
name|Path
name|launcherTmpDirPath
init|=
operator|new
name|Path
argument_list|(
name|tmpDirPath
argument_list|,
name|rolesTmpSubdir
argument_list|)
decl_stmt|;
name|fs
operator|.
name|getFileSystem
argument_list|()
operator|.
name|mkdirs
argument_list|(
name|launcherTmpDirPath
argument_list|)
expr_stmt|;
comment|//launcher service
name|launchService
operator|=
operator|new
name|RoleLaunchService
argument_list|(
name|actionQueues
argument_list|,
name|providerService
argument_list|,
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
name|getGeneratedConfDir
argument_list|()
argument_list|)
argument_list|,
name|envVars
argument_list|,
name|launcherTmpDirPath
argument_list|)
expr_stmt|;
name|deployChildService
argument_list|(
name|launchService
argument_list|)
expr_stmt|;
name|appState
operator|.
name|noteAMLaunched
argument_list|()
expr_stmt|;
comment|//Give the provider access to the state, and AM
name|providerService
operator|.
name|bind
argument_list|(
name|stateForProviders
argument_list|,
name|actionQueues
argument_list|,
name|liveContainers
argument_list|)
expr_stmt|;
name|sliderAMProvider
operator|.
name|bind
argument_list|(
name|stateForProviders
argument_list|,
name|actionQueues
argument_list|,
name|liveContainers
argument_list|)
expr_stmt|;
comment|// chaos monkey
name|maybeStartMonkey
argument_list|()
expr_stmt|;
comment|// setup token renewal and expiry handling for long lived apps
comment|//    if (!securityConfiguration.isKeytabProvided()&&
comment|//        SliderUtils.isHadoopClusterSecure(getConfig())) {
comment|//      fsDelegationTokenManager = new FsDelegationTokenManager(actionQueues);
comment|//      fsDelegationTokenManager.acquireDelegationToken(getConfig());
comment|//    }
comment|// if not a secure cluster, extract the username -it will be
comment|// propagated to workers
if|if
condition|(
operator|!
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|hadoop_user_name
operator|=
name|System
operator|.
name|getenv
argument_list|(
name|HADOOP_USER_NAME
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
name|HADOOP_USER_NAME
operator|+
literal|"='{}'"
argument_list|,
name|hadoop_user_name
argument_list|)
expr_stmt|;
block|}
name|service_user_name
operator|=
name|RegistryUtils
operator|.
name|currentUser
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Registry service username ={}"
argument_list|,
name|service_user_name
argument_list|)
expr_stmt|;
comment|// declare the cluster initialized
name|log
operator|.
name|info
argument_list|(
literal|"Application Master Initialization Completed"
argument_list|)
expr_stmt|;
name|initCompleted
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|scheduleFailureWindowResets
argument_list|(
name|instanceDefinition
operator|.
name|getResources
argument_list|()
argument_list|)
expr_stmt|;
name|scheduleEscalation
argument_list|(
name|instanceDefinition
operator|.
name|getInternal
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
comment|// schedule YARN Registry registration
name|queue
argument_list|(
operator|new
name|ActionRegisterServiceInstance
argument_list|(
name|clustername
argument_list|,
name|appid
argument_list|)
argument_list|)
expr_stmt|;
comment|// log the YARN and web UIs
name|log
operator|.
name|info
argument_list|(
literal|"RM Webapp address {}"
argument_list|,
name|serviceConf
operator|.
name|get
argument_list|(
name|YarnConfiguration
operator|.
name|RM_WEBAPP_ADDRESS
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Slider webapp address {} proxied at {}"
argument_list|,
name|appMasterTrackingUrl
argument_list|,
name|appMasterProxiedUrl
argument_list|)
expr_stmt|;
comment|// Start the Slider AM provider
name|sliderAMProvider
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// launch the real provider; this is expected to trigger a callback that
comment|// starts the node review process
name|launchProviderService
argument_list|(
name|instanceDefinition
argument_list|,
name|confDir
argument_list|)
expr_stmt|;
comment|// start handling any scheduled events
name|startQueueProcessing
argument_list|()
expr_stmt|;
comment|//now block waiting to be told to exit the process
name|waitForAMCompletionSignal
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Exception : {}"
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// call the AM stop command as if it had been queued (but without
comment|// going via the queue, which may not have started
name|onAMStop
argument_list|(
operator|new
name|ActionStopSlider
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//shutdown time
return|return
name|finish
argument_list|()
return|;
block|}
comment|/**    * Get the YARN application Attempt report as the logged in user    * @param yarnClient client to the RM    * @return the application report    * @throws YarnException    * @throws IOException    * @throws InterruptedException    */
DECL|method|getApplicationAttemptReport ( final SliderYarnClientImpl yarnClient)
specifier|private
name|ApplicationAttemptReport
name|getApplicationAttemptReport
parameter_list|(
specifier|final
name|SliderYarnClientImpl
name|yarnClient
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
throws|,
name|InterruptedException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|yarnClient
argument_list|,
literal|"Null Yarn client"
argument_list|)
expr_stmt|;
name|ApplicationAttemptReport
name|report
decl_stmt|;
if|if
condition|(
name|securityEnabled
condition|)
block|{
name|UserGroupInformation
name|ugi
init|=
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
decl_stmt|;
name|report
operator|=
name|ugi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|ApplicationAttemptReport
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ApplicationAttemptReport
name|run
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|yarnClient
operator|.
name|getApplicationAttemptReport
argument_list|(
name|appAttemptID
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|report
operator|=
name|yarnClient
operator|.
name|getApplicationAttemptReport
argument_list|(
name|appAttemptID
argument_list|)
expr_stmt|;
block|}
return|return
name|report
return|;
block|}
comment|/**    * List the node reports: uses {@link SliderYarnClientImpl} as the login user    * @param yarnClient client to the RM    * @return the node reports    * @throws IOException    * @throws YarnException    * @throws InterruptedException    */
DECL|method|getNodeReports (final SliderYarnClientImpl yarnClient)
specifier|private
name|List
argument_list|<
name|NodeReport
argument_list|>
name|getNodeReports
parameter_list|(
specifier|final
name|SliderYarnClientImpl
name|yarnClient
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
throws|,
name|InterruptedException
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|yarnClient
argument_list|,
literal|"Null Yarn client"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|NodeReport
argument_list|>
name|nodeReports
decl_stmt|;
if|if
condition|(
name|securityEnabled
condition|)
block|{
name|nodeReports
operator|=
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|List
argument_list|<
name|NodeReport
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|NodeReport
argument_list|>
name|run
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|yarnClient
operator|.
name|getNodeReports
argument_list|(
name|NodeState
operator|.
name|RUNNING
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodeReports
operator|=
name|yarnClient
operator|.
name|getNodeReports
argument_list|(
name|NodeState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Yarn node report count: {}"
argument_list|,
name|nodeReports
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|nodeReports
return|;
block|}
comment|/**    * Deploy the web application.    *<p>    *   Creates and starts the web application, and adds a    *<code>WebAppService</code> service under the AM, to ensure    *   a managed web application shutdown.    * @param webAppApi web app API instance    * @return port the web application is deployed on    * @throws IOException general problems starting the webapp (network, etc)    * @throws WebAppException other issues    */
DECL|method|deployWebApplication (WebAppApiImpl webAppApi)
specifier|private
name|int
name|deployWebApplication
parameter_list|(
name|WebAppApiImpl
name|webAppApi
parameter_list|)
throws|throws
name|IOException
throws|,
name|SliderException
block|{
try|try
block|{
name|webApp
operator|=
operator|new
name|SliderAMWebApp
argument_list|(
name|webAppApi
argument_list|)
expr_stmt|;
name|HttpConfig
operator|.
name|Policy
name|policy
init|=
name|HttpConfig
operator|.
name|Policy
operator|.
name|HTTP_ONLY
decl_stmt|;
name|int
name|port
init|=
name|getPortToRequest
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Launching web application at port {} with policy {}"
argument_list|,
name|port
argument_list|,
name|policy
argument_list|)
expr_stmt|;
name|WebApps
operator|.
name|$for
argument_list|(
name|SliderAMWebApp
operator|.
name|BASE_PATH
argument_list|,
name|WebAppApi
operator|.
name|class
argument_list|,
name|webAppApi
argument_list|,
name|RestPaths
operator|.
name|WS_CONTEXT
argument_list|)
operator|.
name|withHttpPolicy
argument_list|(
name|getConfig
argument_list|()
argument_list|,
name|policy
argument_list|)
operator|.
name|at
argument_list|(
literal|"0.0.0.0"
argument_list|,
name|port
argument_list|,
literal|true
argument_list|)
operator|.
name|inDevMode
argument_list|()
operator|.
name|start
argument_list|(
name|webApp
argument_list|)
expr_stmt|;
name|WebAppService
argument_list|<
name|SliderAMWebApp
argument_list|>
name|webAppService
init|=
operator|new
name|WebAppService
argument_list|<>
argument_list|(
literal|"slider"
argument_list|,
name|webApp
argument_list|)
decl_stmt|;
name|deployChildService
argument_list|(
name|webAppService
argument_list|)
expr_stmt|;
return|return
name|webApp
operator|.
name|port
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|WebAppException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
name|e
operator|.
name|getCause
argument_list|()
throw|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
block|}
comment|/**    * Process the initial user to obtain the set of user    * supplied credentials (tokens were passed in by client).    * Removes the AM/RM token.    * If a keytab has been provided, also strip the HDFS delegation token.    * @param securityConfig slider security config    * @throws IOException    */
DECL|method|processAMCredentials (SecurityConfiguration securityConfig)
specifier|private
name|void
name|processAMCredentials
parameter_list|(
name|SecurityConfiguration
name|securityConfig
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|Text
argument_list|>
name|filteredTokens
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|filteredTokens
operator|.
name|add
argument_list|(
name|AMRMTokenIdentifier
operator|.
name|KIND_NAME
argument_list|)
expr_stmt|;
name|filteredTokens
operator|.
name|add
argument_list|(
name|TimelineDelegationTokenIdentifier
operator|.
name|KIND_NAME
argument_list|)
expr_stmt|;
name|boolean
name|keytabProvided
init|=
name|securityConfig
operator|.
name|isKeytabProvided
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Slider AM Security Mode: {}"
argument_list|,
name|keytabProvided
condition|?
literal|"KEYTAB"
else|:
literal|"TOKEN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|keytabProvided
condition|)
block|{
name|filteredTokens
operator|.
name|add
argument_list|(
name|DelegationTokenIdentifier
operator|.
name|HDFS_DELEGATION_KIND
argument_list|)
expr_stmt|;
block|}
name|containerCredentials
operator|=
name|CredentialUtils
operator|.
name|filterTokens
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getCredentials
argument_list|()
argument_list|,
name|filteredTokens
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
name|CredentialUtils
operator|.
name|dumpTokens
argument_list|(
name|containerCredentials
argument_list|,
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Build up the port scanner. This may include setting a port range.    */
DECL|method|buildPortScanner (AggregateConf instanceDefinition)
specifier|private
name|void
name|buildPortScanner
parameter_list|(
name|AggregateConf
name|instanceDefinition
parameter_list|)
throws|throws
name|BadConfigException
block|{
name|portScanner
operator|=
operator|new
name|PortScanner
argument_list|()
expr_stmt|;
name|String
name|portRange
init|=
name|instanceDefinition
operator|.
name|getAppConfOperations
argument_list|()
operator|.
name|getGlobalOptions
argument_list|()
operator|.
name|getOption
argument_list|(
name|SliderKeys
operator|.
name|KEY_ALLOWED_PORT_RANGE
argument_list|,
literal|"0"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
literal|"0"
operator|.
name|equals
argument_list|(
name|portRange
argument_list|)
condition|)
block|{
name|portScanner
operator|.
name|setPortRange
argument_list|(
name|portRange
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Locate a port to request for a service such as RPC or web/REST.    * This uses port range definitions in the<code>instanceDefinition</code>    * to fix the port range if one is set.    *<p>    * The port returned is available at the time of the request; there are    * no guarantees as to how long that situation will last.    * @return the port to request.    * @throws SliderException    */
DECL|method|getPortToRequest ()
specifier|private
name|int
name|getPortToRequest
parameter_list|()
throws|throws
name|SliderException
throws|,
name|IOException
block|{
return|return
name|portScanner
operator|.
name|getAvailablePort
argument_list|()
return|;
block|}
DECL|method|login (String principal, File localKeytabFile)
specifier|protected
name|void
name|login
parameter_list|(
name|String
name|principal
parameter_list|,
name|File
name|localKeytabFile
parameter_list|)
throws|throws
name|IOException
throws|,
name|SliderException
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Logging in as {} with keytab {}"
argument_list|,
name|principal
argument_list|,
name|localKeytabFile
argument_list|)
expr_stmt|;
name|UserGroupInformation
operator|.
name|loginUserFromKeytab
argument_list|(
name|principal
argument_list|,
name|localKeytabFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|validateLoginUser
argument_list|(
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Ensure that the user is generated from a keytab and has no HDFS delegation    * tokens.    *    * @param user user to validate    * @throws SliderException    */
DECL|method|validateLoginUser (UserGroupInformation user)
specifier|protected
name|void
name|validateLoginUser
parameter_list|(
name|UserGroupInformation
name|user
parameter_list|)
throws|throws
name|SliderException
block|{
if|if
condition|(
operator|!
name|user
operator|.
name|isFromKeytab
argument_list|()
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"User is not holding on a keytab in a secure deployment:"
operator|+
literal|" slider will fail as tokens expire"
argument_list|)
expr_stmt|;
block|}
name|Credentials
name|credentials
init|=
name|user
operator|.
name|getCredentials
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
argument_list|>
name|iter
init|=
name|credentials
operator|.
name|getAllTokens
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|token
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Token {}"
argument_list|,
name|token
operator|.
name|getKind
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|.
name|getKind
argument_list|()
operator|.
name|equals
argument_list|(
name|DelegationTokenIdentifier
operator|.
name|HDFS_DELEGATION_KIND
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"HDFS delegation token {}.  Removing..."
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Set up the AM filter     * @param serviceConf configuration to patch    */
DECL|method|initAMFilterOptions (Configuration serviceConf)
specifier|private
name|void
name|initAMFilterOptions
parameter_list|(
name|Configuration
name|serviceConf
parameter_list|)
block|{
comment|// IP filtering
name|String
name|amFilterName
init|=
name|AM_FILTER_NAME
decl_stmt|;
comment|// This is here until YARN supports proxy& redirect operations
comment|// on verbs other than GET, and is only supported for testing
if|if
condition|(
name|X_DEV_INSECURE_REQUIRED
operator|&&
name|serviceConf
operator|.
name|getBoolean
argument_list|(
name|X_DEV_INSECURE_WS
argument_list|,
name|X_DEV_INSECURE_DEFAULT
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Insecure filter enabled: REST operations are unauthenticated"
argument_list|)
expr_stmt|;
name|amFilterName
operator|=
name|InsecureAmFilterInitializer
operator|.
name|NAME
expr_stmt|;
block|}
name|serviceConf
operator|.
name|set
argument_list|(
name|HADOOP_HTTP_FILTER_INITIALIZERS
argument_list|,
name|amFilterName
argument_list|)
expr_stmt|;
block|}
comment|/**    * This registers the service instance and its external values    * @param instanceName name of this instance    * @param appId application ID    * @throws IOException    */
DECL|method|registerServiceInstance (String instanceName, ApplicationId appId)
specifier|public
name|void
name|registerServiceInstance
parameter_list|(
name|String
name|instanceName
parameter_list|,
name|ApplicationId
name|appId
parameter_list|)
throws|throws
name|IOException
block|{
comment|// the registry is running, so register services
name|URL
name|amWebURI
init|=
operator|new
name|URL
argument_list|(
name|appMasterProxiedUrl
argument_list|)
decl_stmt|;
comment|//Give the provider restricted access to the state, registry
name|setupInitialRegistryPaths
argument_list|()
expr_stmt|;
name|yarnRegistryOperations
operator|=
operator|new
name|YarnRegistryViewForProviders
argument_list|(
name|registryOperations
argument_list|,
name|service_user_name
argument_list|,
name|SliderKeys
operator|.
name|APP_TYPE
argument_list|,
name|instanceName
argument_list|,
name|appAttemptID
argument_list|)
expr_stmt|;
name|providerService
operator|.
name|bindToYarnRegistry
argument_list|(
name|yarnRegistryOperations
argument_list|)
expr_stmt|;
name|sliderAMProvider
operator|.
name|bindToYarnRegistry
argument_list|(
name|yarnRegistryOperations
argument_list|)
expr_stmt|;
comment|// Yarn registry
name|ServiceRecord
name|serviceRecord
init|=
operator|new
name|ServiceRecord
argument_list|()
decl_stmt|;
name|serviceRecord
operator|.
name|set
argument_list|(
name|YarnRegistryAttributes
operator|.
name|YARN_ID
argument_list|,
name|appId
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|serviceRecord
operator|.
name|set
argument_list|(
name|YarnRegistryAttributes
operator|.
name|YARN_PERSISTENCE
argument_list|,
name|PersistencePolicies
operator|.
name|APPLICATION
argument_list|)
expr_stmt|;
name|serviceRecord
operator|.
name|description
operator|=
literal|"Slider Application Master"
expr_stmt|;
name|serviceRecord
operator|.
name|addExternalEndpoint
argument_list|(
name|RegistryTypeUtils
operator|.
name|ipcEndpoint
argument_list|(
name|CustomRegistryConstants
operator|.
name|AM_IPC_PROTOCOL
argument_list|,
name|rpcServiceAddress
argument_list|)
argument_list|)
expr_stmt|;
comment|// internal services
name|sliderAMProvider
operator|.
name|applyInitialRegistryDefinitions
argument_list|(
name|amWebURI
argument_list|,
name|serviceRecord
argument_list|)
expr_stmt|;
comment|// provider service dynamic definitions.
name|providerService
operator|.
name|applyInitialRegistryDefinitions
argument_list|(
name|amWebURI
argument_list|,
name|serviceRecord
argument_list|)
expr_stmt|;
comment|// set any provided attributes
name|setProvidedServiceRecordAttributes
argument_list|(
name|getInstanceDefinition
argument_list|()
operator|.
name|getAppConfOperations
argument_list|()
operator|.
name|getComponent
argument_list|(
name|SliderKeys
operator|.
name|COMPONENT_AM
argument_list|)
argument_list|,
name|serviceRecord
argument_list|)
expr_stmt|;
comment|// register the service's entry
name|log
operator|.
name|info
argument_list|(
literal|"Service Record \n{}"
argument_list|,
name|serviceRecord
argument_list|)
expr_stmt|;
name|yarnRegistryOperations
operator|.
name|registerSelf
argument_list|(
name|serviceRecord
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Registered service under {}; absolute path {}"
argument_list|,
name|yarnRegistryOperations
operator|.
name|getSelfRegistrationPath
argument_list|()
argument_list|,
name|yarnRegistryOperations
operator|.
name|getAbsoluteSelfRegistrationPath
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|isFirstAttempt
init|=
literal|1
operator|==
name|appAttemptID
operator|.
name|getAttemptId
argument_list|()
decl_stmt|;
comment|// delete the children in case there are any and this is an AM startup.
comment|// just to make sure everything underneath is purged
if|if
condition|(
name|isFirstAttempt
condition|)
block|{
name|yarnRegistryOperations
operator|.
name|deleteChildren
argument_list|(
name|yarnRegistryOperations
operator|.
name|getSelfRegistrationPath
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * TODO: purge this once RM is doing the work    * @throws IOException    */
DECL|method|setupInitialRegistryPaths ()
specifier|protected
name|void
name|setupInitialRegistryPaths
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|registryOperations
operator|instanceof
name|RMRegistryOperationsService
condition|)
block|{
name|RMRegistryOperationsService
name|rmRegOperations
init|=
operator|(
name|RMRegistryOperationsService
operator|)
name|registryOperations
decl_stmt|;
name|rmRegOperations
operator|.
name|initUserRegistryAsync
argument_list|(
name|service_user_name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Handler for {@link RegisterComponentInstance action}    * Register/re-register an ephemeral container that is already in the app state    * @param id the component    * @param description component description    * @param type component type    * @return true if the component is registered    */
DECL|method|registerComponent (ContainerId id, String description, String type)
specifier|public
name|boolean
name|registerComponent
parameter_list|(
name|ContainerId
name|id
parameter_list|,
name|String
name|description
parameter_list|,
name|String
name|type
parameter_list|)
throws|throws
name|IOException
block|{
name|RoleInstance
name|instance
init|=
name|appState
operator|.
name|getOwnedContainer
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|instance
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// this is where component registrations  go
name|log
operator|.
name|info
argument_list|(
literal|"Registering component {}"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|String
name|cid
init|=
name|RegistryPathUtils
operator|.
name|encodeYarnID
argument_list|(
name|id
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|ServiceRecord
name|container
init|=
operator|new
name|ServiceRecord
argument_list|()
decl_stmt|;
name|container
operator|.
name|set
argument_list|(
name|YarnRegistryAttributes
operator|.
name|YARN_ID
argument_list|,
name|cid
argument_list|)
expr_stmt|;
name|container
operator|.
name|description
operator|=
name|description
expr_stmt|;
name|container
operator|.
name|set
argument_list|(
name|YarnRegistryAttributes
operator|.
name|YARN_PERSISTENCE
argument_list|,
name|PersistencePolicies
operator|.
name|CONTAINER
argument_list|)
expr_stmt|;
name|MapOperations
name|compOps
init|=
name|getInstanceDefinition
argument_list|()
operator|.
name|getAppConfOperations
argument_list|()
operator|.
name|getComponent
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|setProvidedServiceRecordAttributes
argument_list|(
name|compOps
argument_list|,
name|container
argument_list|)
expr_stmt|;
try|try
block|{
name|yarnRegistryOperations
operator|.
name|putComponent
argument_list|(
name|cid
argument_list|,
name|container
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Failed to register container {}/{}: {}"
argument_list|,
name|id
argument_list|,
name|description
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|setProvidedServiceRecordAttributes (MapOperations ops, ServiceRecord record)
specifier|protected
name|void
name|setProvidedServiceRecordAttributes
parameter_list|(
name|MapOperations
name|ops
parameter_list|,
name|ServiceRecord
name|record
parameter_list|)
block|{
name|String
name|prefix
init|=
name|RoleKeys
operator|.
name|SERVICE_RECORD_ATTRIBUTE_PREFIX
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|ops
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|substring
argument_list|(
name|prefix
operator|.
name|length
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
name|record
operator|.
name|set
argument_list|(
name|key
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Handler for {@link UnregisterComponentInstance}    *     * unregister a component. At the time this message is received,    * the component may not have been registered    * @param id the component    */
DECL|method|unregisterComponent (ContainerId id)
specifier|public
name|void
name|unregisterComponent
parameter_list|(
name|ContainerId
name|id
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Unregistering component {}"
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|yarnRegistryOperations
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Processing unregister component event before initialization "
operator|+
literal|"completed; init flag ={}"
argument_list|,
name|initCompleted
argument_list|)
expr_stmt|;
return|return;
block|}
name|String
name|cid
init|=
name|RegistryPathUtils
operator|.
name|encodeYarnID
argument_list|(
name|id
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|yarnRegistryOperations
operator|.
name|deleteComponent
argument_list|(
name|cid
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Failed to delete container {} : {}"
argument_list|,
name|id
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * looks for a specific case where a token file is provided as an environment    * variable, yet the file is not there.    *     * This surfaced (once) in HBase, where its HDFS library was looking for this,    * and somehow the token was missing. This is a check in the AM so that    * if the problem re-occurs, the AM can fail with a more meaningful message.    *     */
DECL|method|checkAndWarnForAuthTokenProblems ()
specifier|private
name|void
name|checkAndWarnForAuthTokenProblems
parameter_list|()
block|{
name|String
name|fileLocation
init|=
name|System
operator|.
name|getenv
argument_list|(
name|UserGroupInformation
operator|.
name|HADOOP_TOKEN_FILE_LOCATION
argument_list|)
decl_stmt|;
if|if
condition|(
name|fileLocation
operator|!=
literal|null
condition|)
block|{
name|File
name|tokenFile
init|=
operator|new
name|File
argument_list|(
name|fileLocation
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tokenFile
operator|.
name|exists
argument_list|()
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Token file {} specified in {} not found"
argument_list|,
name|tokenFile
argument_list|,
name|UserGroupInformation
operator|.
name|HADOOP_TOKEN_FILE_LOCATION
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Build the configuration directory passed in or of the target FS    * @return the file    */
DECL|method|getLocalConfDir ()
specifier|public
name|File
name|getLocalConfDir
parameter_list|()
block|{
name|File
name|confdir
init|=
operator|new
name|File
argument_list|(
name|SliderKeys
operator|.
name|PROPAGATED_CONF_DIR_NAME
argument_list|)
operator|.
name|getAbsoluteFile
argument_list|()
decl_stmt|;
return|return
name|confdir
return|;
block|}
comment|/**    * Get the path to the DFS configuration that is defined in the cluster specification     * @return the generated configuration dir    */
DECL|method|getGeneratedConfDir ()
specifier|public
name|String
name|getGeneratedConfDir
parameter_list|()
block|{
return|return
name|getGlobalInternalOptions
argument_list|()
operator|.
name|get
argument_list|(
name|InternalKeys
operator|.
name|INTERNAL_GENERATED_CONF_PATH
argument_list|)
return|;
block|}
comment|/**    * Get the global internal options for the AM    * @return a map to access the internals    */
DECL|method|getGlobalInternalOptions ()
specifier|public
name|MapOperations
name|getGlobalInternalOptions
parameter_list|()
block|{
return|return
name|getInstanceDefinition
argument_list|()
operator|.
name|getInternalOperations
argument_list|()
operator|.
name|getGlobalOptions
argument_list|()
return|;
block|}
comment|/**    * Get the filesystem of this cluster    * @return the FS of the config    */
DECL|method|getClusterFS ()
specifier|public
name|SliderFileSystem
name|getClusterFS
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|SliderFileSystem
argument_list|(
name|getConfig
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get the AM log    * @return the log of the AM    */
DECL|method|getLog ()
specifier|public
specifier|static
name|Logger
name|getLog
parameter_list|()
block|{
return|return
name|log
return|;
block|}
comment|/**    * Get the application state    * @return the application state    */
DECL|method|getAppState ()
specifier|public
name|AppState
name|getAppState
parameter_list|()
block|{
return|return
name|appState
return|;
block|}
comment|/**    * Block until it is signalled that the AM is done    */
DECL|method|waitForAMCompletionSignal ()
specifier|private
name|void
name|waitForAMCompletionSignal
parameter_list|()
block|{
name|AMExecutionStateLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|amCompletionFlag
operator|.
name|get
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"blocking until signalled to terminate"
argument_list|)
expr_stmt|;
name|isAMCompleted
operator|.
name|awaitUninterruptibly
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|AMExecutionStateLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Signal that the AM is complete .. queues it in a separate thread    *    * @param stopActionRequest request containing shutdown details    */
DECL|method|signalAMComplete (ActionStopSlider stopActionRequest)
specifier|public
specifier|synchronized
name|void
name|signalAMComplete
parameter_list|(
name|ActionStopSlider
name|stopActionRequest
parameter_list|)
block|{
comment|// this is a queued action: schedule it through the queues
name|schedule
argument_list|(
name|stopActionRequest
argument_list|)
expr_stmt|;
block|}
comment|/**    * Signal that the AM is complete    *    * @param stopActionRequest request containing shutdown details    */
DECL|method|onAMStop (ActionStopSlider stopActionRequest)
specifier|public
specifier|synchronized
name|void
name|onAMStop
parameter_list|(
name|ActionStopSlider
name|stopActionRequest
parameter_list|)
block|{
name|AMExecutionStateLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|amCompletionFlag
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
comment|// first stop request received
name|this
operator|.
name|stopAction
operator|=
name|stopActionRequest
expr_stmt|;
name|isAMCompleted
operator|.
name|signal
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|AMExecutionStateLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * trigger the YARN cluster termination process    * @return the exit code    * @throws Exception if the stop action contained an Exception which implements    * ExitCodeProvider    */
DECL|method|finish ()
specifier|private
specifier|synchronized
name|int
name|finish
parameter_list|()
throws|throws
name|Exception
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|stopAction
argument_list|,
literal|"null stop action"
argument_list|)
expr_stmt|;
name|FinalApplicationStatus
name|appStatus
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Triggering shutdown of the AM: {}"
argument_list|,
name|stopAction
argument_list|)
expr_stmt|;
name|String
name|appMessage
init|=
name|stopAction
operator|.
name|getMessage
argument_list|()
decl_stmt|;
comment|//stop the daemon& grab its exit code
name|int
name|exitCode
init|=
name|stopAction
operator|.
name|getExitCode
argument_list|()
decl_stmt|;
name|Exception
name|exception
init|=
name|stopAction
operator|.
name|getEx
argument_list|()
decl_stmt|;
name|appStatus
operator|=
name|stopAction
operator|.
name|getFinalApplicationStatus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|spawnedProcessExitedBeforeShutdownTriggered
condition|)
block|{
comment|//stopped the forked process but don't worry about its exit code
name|int
name|forkedExitCode
init|=
name|stopForkedProcess
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Stopped forked process: exit code={}"
argument_list|,
name|forkedExitCode
argument_list|)
expr_stmt|;
block|}
comment|// make sure the AM is actually registered. If not, there's no point
comment|// trying to unregister it
if|if
condition|(
name|amRegistrationData
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Application attempt not yet registered; skipping unregistration"
argument_list|)
expr_stmt|;
if|if
condition|(
name|exception
operator|!=
literal|null
condition|)
block|{
throw|throw
name|exception
throw|;
block|}
return|return
name|exitCode
return|;
block|}
comment|//stop any launches in progress
name|launchService
operator|.
name|stop
argument_list|()
expr_stmt|;
comment|//now release all containers
name|releaseAllContainers
argument_list|()
expr_stmt|;
comment|// When the application completes, it should send a finish application
comment|// signal to the RM
name|log
operator|.
name|info
argument_list|(
literal|"Application completed. Signalling finish to RM"
argument_list|)
expr_stmt|;
try|try
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Unregistering AM status={} message={}"
argument_list|,
name|appStatus
argument_list|,
name|appMessage
argument_list|)
expr_stmt|;
name|asyncRMClient
operator|.
name|unregisterApplicationMaster
argument_list|(
name|appStatus
argument_list|,
name|appMessage
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidApplicationMasterRequestException
name|e
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Application not found in YARN application list;"
operator|+
literal|" it may have been terminated/YARN shutdown in progress: {}"
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|YarnException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Failed to unregister application: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exception
operator|!=
literal|null
condition|)
block|{
throw|throw
name|exception
throw|;
block|}
return|return
name|exitCode
return|;
block|}
comment|/**      * Get diagnostics info about containers      */
DECL|method|getContainerDiagnosticInfo ()
specifier|private
name|String
name|getContainerDiagnosticInfo
parameter_list|()
block|{
return|return
name|appState
operator|.
name|getContainerDiagnosticInfo
argument_list|()
return|;
block|}
DECL|method|getProxy (Class protocol, InetSocketAddress addr)
specifier|public
name|Object
name|getProxy
parameter_list|(
name|Class
name|protocol
parameter_list|,
name|InetSocketAddress
name|addr
parameter_list|)
block|{
return|return
name|yarnRPC
operator|.
name|getProxy
argument_list|(
name|protocol
argument_list|,
name|addr
argument_list|,
name|getConfig
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Start the slider RPC server    */
DECL|method|startSliderRPCServer (AggregateConf instanceDefinition)
specifier|private
name|void
name|startSliderRPCServer
parameter_list|(
name|AggregateConf
name|instanceDefinition
parameter_list|)
throws|throws
name|IOException
throws|,
name|SliderException
block|{
name|verifyIPCAccess
argument_list|()
expr_stmt|;
name|sliderIPCService
operator|=
operator|new
name|SliderIPCService
argument_list|(
name|this
argument_list|,
name|stateForProviders
argument_list|,
name|actionQueues
argument_list|,
name|metricsAndMonitoring
argument_list|,
name|contentCache
argument_list|)
expr_stmt|;
name|deployChildService
argument_list|(
name|sliderIPCService
argument_list|)
expr_stmt|;
name|SliderClusterProtocolPBImpl
name|protobufRelay
init|=
operator|new
name|SliderClusterProtocolPBImpl
argument_list|(
name|sliderIPCService
argument_list|)
decl_stmt|;
name|BlockingService
name|blockingService
init|=
name|SliderClusterAPI
operator|.
name|SliderClusterProtocolPB
operator|.
name|newReflectiveBlockingService
argument_list|(
name|protobufRelay
argument_list|)
decl_stmt|;
name|int
name|port
init|=
name|getPortToRequest
argument_list|()
decl_stmt|;
name|InetSocketAddress
name|rpcAddress
init|=
operator|new
name|InetSocketAddress
argument_list|(
literal|"0.0.0.0"
argument_list|,
name|port
argument_list|)
decl_stmt|;
name|rpcService
operator|=
operator|new
name|WorkflowRpcService
argument_list|(
literal|"SliderRPC"
argument_list|,
name|RpcBinder
operator|.
name|createProtobufServer
argument_list|(
name|rpcAddress
argument_list|,
name|getConfig
argument_list|()
argument_list|,
name|secretManager
argument_list|,
name|NUM_RPC_HANDLERS
argument_list|,
name|blockingService
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|deployChildService
argument_list|(
name|rpcService
argument_list|)
expr_stmt|;
block|}
comment|/**    * verify that if the cluster is authed, the ACLs are set.    * @throws BadConfigException if Authorization is set without any ACL    */
DECL|method|verifyIPCAccess ()
specifier|private
name|void
name|verifyIPCAccess
parameter_list|()
throws|throws
name|BadConfigException
block|{
name|boolean
name|authorization
init|=
name|getConfig
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_SECURITY_AUTHORIZATION
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|String
name|acls
init|=
name|getConfig
argument_list|()
operator|.
name|get
argument_list|(
name|KEY_PROTOCOL_ACL
argument_list|)
decl_stmt|;
if|if
condition|(
name|authorization
operator|&&
name|SliderUtils
operator|.
name|isUnset
argument_list|(
name|acls
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BadConfigException
argument_list|(
literal|"Application has IPC authorization enabled in "
operator|+
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_SECURITY_AUTHORIZATION
operator|+
literal|" but no ACLs in "
operator|+
name|KEY_PROTOCOL_ACL
argument_list|)
throw|;
block|}
block|}
comment|/* =================================================================== */
comment|/* AMRMClientAsync callbacks */
comment|/* =================================================================== */
comment|/**    * Callback event when a container is allocated.    *     * The app state is updated with the allocation, and builds up a list    * of assignments and RM operations. The assignments are     * handed off into the pool of service launchers to asynchronously schedule    * container launch operations.    *     * The operations are run in sequence; they are expected to be 0 or more    * release operations (to handle over-allocations)    *     * @param allocatedContainers list of containers that are now ready to be    * given work.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"SynchronizationOnLocalVariableOrMethodParameter"
argument_list|)
annotation|@
name|Override
comment|//AMRMClientAsync
DECL|method|onContainersAllocated (List<Container> allocatedContainers)
specifier|public
name|void
name|onContainersAllocated
parameter_list|(
name|List
argument_list|<
name|Container
argument_list|>
name|allocatedContainers
parameter_list|)
block|{
name|LOG_YARN
operator|.
name|info
argument_list|(
literal|"onContainersAllocated({})"
argument_list|,
name|allocatedContainers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ContainerAssignment
argument_list|>
name|assignments
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|operations
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|//app state makes all the decisions
name|appState
operator|.
name|onContainersAllocated
argument_list|(
name|allocatedContainers
argument_list|,
name|assignments
argument_list|,
name|operations
argument_list|)
expr_stmt|;
comment|//for each assignment: instantiate that role
for|for
control|(
name|ContainerAssignment
name|assignment
range|:
name|assignments
control|)
block|{
try|try
block|{
name|launchService
operator|.
name|launchRole
argument_list|(
name|assignment
argument_list|,
name|getInstanceDefinition
argument_list|()
argument_list|,
name|buildContainerCredentials
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Can be caused by failure to renew credentials with the remote
comment|// service. If so, don't launch the application. Container is retained,
comment|// though YARN will take it away after a timeout.
name|log
operator|.
name|error
argument_list|(
literal|"Failed to build credentials to launch container: {}"
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|//for all the operations, exec them
name|execute
argument_list|(
name|operations
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Diagnostics: {}"
argument_list|,
name|getContainerDiagnosticInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
comment|//AMRMClientAsync
DECL|method|onContainersCompleted (List<ContainerStatus> completedContainers)
specifier|public
specifier|synchronized
name|void
name|onContainersCompleted
parameter_list|(
name|List
argument_list|<
name|ContainerStatus
argument_list|>
name|completedContainers
parameter_list|)
block|{
name|LOG_YARN
operator|.
name|info
argument_list|(
literal|"onContainersCompleted([{}]"
argument_list|,
name|completedContainers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|ContainerStatus
name|status
range|:
name|completedContainers
control|)
block|{
name|ContainerId
name|containerId
init|=
name|status
operator|.
name|getContainerId
argument_list|()
decl_stmt|;
name|LOG_YARN
operator|.
name|info
argument_list|(
literal|"Container Completion for"
operator|+
literal|" containerID={},"
operator|+
literal|" state={},"
operator|+
literal|" exitStatus={},"
operator|+
literal|" diagnostics={}"
argument_list|,
name|containerId
argument_list|,
name|status
operator|.
name|getState
argument_list|()
argument_list|,
name|status
operator|.
name|getExitStatus
argument_list|()
argument_list|,
name|status
operator|.
name|getDiagnostics
argument_list|()
argument_list|)
expr_stmt|;
comment|// non complete containers should not be here
assert|assert
operator|(
name|status
operator|.
name|getState
argument_list|()
operator|==
name|ContainerState
operator|.
name|COMPLETE
operator|)
assert|;
name|AppState
operator|.
name|NodeCompletionResult
name|result
init|=
name|appState
operator|.
name|onCompletedNode
argument_list|(
name|status
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|containerFailed
condition|)
block|{
name|RoleInstance
name|ri
init|=
name|result
operator|.
name|roleInstance
decl_stmt|;
name|log
operator|.
name|error
argument_list|(
literal|"Role instance {} failed "
argument_list|,
name|ri
argument_list|)
expr_stmt|;
block|}
comment|//  known nodes trigger notifications
if|if
condition|(
operator|!
name|result
operator|.
name|unknownNode
condition|)
block|{
name|getProviderService
argument_list|()
operator|.
name|notifyContainerCompleted
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
name|queue
argument_list|(
operator|new
name|UnregisterComponentInstance
argument_list|(
name|containerId
argument_list|,
literal|0
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|reviewRequestAndReleaseNodes
argument_list|(
literal|"onContainersCompleted"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Signal that containers are being upgraded. Containers specified with    * --containers option and all containers of all roles specified with    * --components option are merged and upgraded.    *     * @param upgradeContainersRequest    *          request containing upgrade details    */
DECL|method|onUpgradeContainers ( ActionUpgradeContainers upgradeContainersRequest)
specifier|public
specifier|synchronized
name|void
name|onUpgradeContainers
parameter_list|(
name|ActionUpgradeContainers
name|upgradeContainersRequest
parameter_list|)
throws|throws
name|IOException
throws|,
name|SliderException
block|{
name|LOG_YARN
operator|.
name|info
argument_list|(
literal|"onUpgradeContainers({})"
argument_list|,
name|upgradeContainersRequest
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|containers
init|=
name|upgradeContainersRequest
operator|.
name|getContainers
argument_list|()
operator|==
literal|null
condition|?
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
else|:
name|upgradeContainersRequest
operator|.
name|getContainers
argument_list|()
decl_stmt|;
name|LOG_YARN
operator|.
name|info
argument_list|(
literal|"  Container list provided (total {}) : {}"
argument_list|,
name|containers
operator|.
name|size
argument_list|()
argument_list|,
name|containers
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|components
init|=
name|upgradeContainersRequest
operator|.
name|getComponents
argument_list|()
operator|==
literal|null
condition|?
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
else|:
name|upgradeContainersRequest
operator|.
name|getComponents
argument_list|()
decl_stmt|;
name|LOG_YARN
operator|.
name|info
argument_list|(
literal|"  Component list provided (total {}) : {}"
argument_list|,
name|components
operator|.
name|size
argument_list|()
argument_list|,
name|components
argument_list|)
expr_stmt|;
comment|// If components are specified as well, then grab all the containers of
comment|// each of the components (roles)
if|if
condition|(
name|CollectionUtils
operator|.
name|isNotEmpty
argument_list|(
name|components
argument_list|)
condition|)
block|{
name|Map
argument_list|<
name|ContainerId
argument_list|,
name|RoleInstance
argument_list|>
name|liveContainers
init|=
name|appState
operator|.
name|getLiveContainers
argument_list|()
decl_stmt|;
if|if
condition|(
name|CollectionUtils
operator|.
name|isNotEmpty
argument_list|(
name|liveContainers
operator|.
name|keySet
argument_list|()
argument_list|)
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|roleContainerMap
init|=
name|prepareRoleContainerMap
argument_list|(
name|liveContainers
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|component
range|:
name|components
control|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|roleContainers
init|=
name|roleContainerMap
operator|.
name|get
argument_list|(
name|component
argument_list|)
decl_stmt|;
if|if
condition|(
name|roleContainers
operator|!=
literal|null
condition|)
block|{
name|containers
operator|.
name|addAll
argument_list|(
name|roleContainers
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|LOG_YARN
operator|.
name|info
argument_list|(
literal|"Final list of containers to be upgraded (total {}) : {}"
argument_list|,
name|containers
operator|.
name|size
argument_list|()
argument_list|,
name|containers
argument_list|)
expr_stmt|;
block|}
comment|// create a reverse map of roles -> set of all live containers
DECL|method|prepareRoleContainerMap ( Map<ContainerId, RoleInstance> liveContainers)
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|prepareRoleContainerMap
parameter_list|(
name|Map
argument_list|<
name|ContainerId
argument_list|,
name|RoleInstance
argument_list|>
name|liveContainers
parameter_list|)
block|{
comment|// liveContainers is ensured to be not empty
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|roleContainerMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ContainerId
argument_list|,
name|RoleInstance
argument_list|>
name|liveContainer
range|:
name|liveContainers
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|RoleInstance
name|role
init|=
name|liveContainer
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|roleContainerMap
operator|.
name|containsKey
argument_list|(
name|role
operator|.
name|role
argument_list|)
condition|)
block|{
name|roleContainerMap
operator|.
name|get
argument_list|(
name|role
operator|.
name|role
argument_list|)
operator|.
name|add
argument_list|(
name|liveContainer
operator|.
name|getKey
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|containers
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|containers
operator|.
name|add
argument_list|(
name|liveContainer
operator|.
name|getKey
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|roleContainerMap
operator|.
name|put
argument_list|(
name|role
operator|.
name|role
argument_list|,
name|containers
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|roleContainerMap
return|;
block|}
comment|/**    * Implementation of cluster flexing.    * It should be the only way that anything -even the AM itself on startup-    * asks for nodes.     * @param resources the resource tree    * @throws SliderException slider problems, including invalid configs    * @throws IOException IO problems    */
DECL|method|flexCluster (ConfTree resources)
specifier|public
name|void
name|flexCluster
parameter_list|(
name|ConfTree
name|resources
parameter_list|)
throws|throws
name|IOException
throws|,
name|SliderException
block|{
name|AggregateConf
name|newConf
init|=
operator|new
name|AggregateConf
argument_list|(
name|appState
operator|.
name|getInstanceDefinitionSnapshot
argument_list|()
argument_list|)
decl_stmt|;
name|newConf
operator|.
name|setResources
argument_list|(
name|resources
argument_list|)
expr_stmt|;
comment|// verify the new definition is valid
name|sliderAMProvider
operator|.
name|validateInstanceDefinition
argument_list|(
name|newConf
argument_list|)
expr_stmt|;
name|providerService
operator|.
name|validateInstanceDefinition
argument_list|(
name|newConf
argument_list|)
expr_stmt|;
name|appState
operator|.
name|updateResourceDefinitions
argument_list|(
name|resources
argument_list|)
expr_stmt|;
comment|// reset the scheduled windows...the values
comment|// may have changed
name|appState
operator|.
name|resetFailureCounts
argument_list|()
expr_stmt|;
comment|// ask for more containers if needed
name|reviewRequestAndReleaseNodes
argument_list|(
literal|"flexCluster"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Schedule the failure window    * @param resources the resource tree    * @throws BadConfigException if the window is out of range    */
DECL|method|scheduleFailureWindowResets (ConfTree resources)
specifier|private
name|void
name|scheduleFailureWindowResets
parameter_list|(
name|ConfTree
name|resources
parameter_list|)
throws|throws
name|BadConfigException
block|{
name|ResetFailureWindow
name|reset
init|=
operator|new
name|ResetFailureWindow
argument_list|()
decl_stmt|;
name|ConfTreeOperations
name|ops
init|=
operator|new
name|ConfTreeOperations
argument_list|(
name|resources
argument_list|)
decl_stmt|;
name|MapOperations
name|globals
init|=
name|ops
operator|.
name|getGlobalOptions
argument_list|()
decl_stmt|;
name|long
name|seconds
init|=
name|globals
operator|.
name|getTimeRange
argument_list|(
name|ResourceKeys
operator|.
name|CONTAINER_FAILURE_WINDOW
argument_list|,
name|ResourceKeys
operator|.
name|DEFAULT_CONTAINER_FAILURE_WINDOW_DAYS
argument_list|,
name|ResourceKeys
operator|.
name|DEFAULT_CONTAINER_FAILURE_WINDOW_HOURS
argument_list|,
name|ResourceKeys
operator|.
name|DEFAULT_CONTAINER_FAILURE_WINDOW_MINUTES
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|seconds
operator|>
literal|0
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Scheduling the failure window reset interval to every {} seconds"
argument_list|,
name|seconds
argument_list|)
expr_stmt|;
name|RenewingAction
argument_list|<
name|ResetFailureWindow
argument_list|>
name|renew
init|=
operator|new
name|RenewingAction
argument_list|<>
argument_list|(
name|reset
argument_list|,
name|seconds
argument_list|,
name|seconds
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|actionQueues
operator|.
name|renewing
argument_list|(
literal|"failures"
argument_list|,
name|renew
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Failure window reset interval is not set"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Schedule the escalation action    * @param internal    * @throws BadConfigException    */
DECL|method|scheduleEscalation (ConfTree internal)
specifier|private
name|void
name|scheduleEscalation
parameter_list|(
name|ConfTree
name|internal
parameter_list|)
throws|throws
name|BadConfigException
block|{
name|EscalateOutstandingRequests
name|escalate
init|=
operator|new
name|EscalateOutstandingRequests
argument_list|()
decl_stmt|;
name|ConfTreeOperations
name|ops
init|=
operator|new
name|ConfTreeOperations
argument_list|(
name|internal
argument_list|)
decl_stmt|;
name|int
name|seconds
init|=
name|ops
operator|.
name|getGlobalOptions
argument_list|()
operator|.
name|getOptionInt
argument_list|(
name|InternalKeys
operator|.
name|ESCALATION_CHECK_INTERVAL
argument_list|,
name|InternalKeys
operator|.
name|DEFAULT_ESCALATION_CHECK_INTERVAL
argument_list|)
decl_stmt|;
name|RenewingAction
argument_list|<
name|EscalateOutstandingRequests
argument_list|>
name|renew
init|=
operator|new
name|RenewingAction
argument_list|<>
argument_list|(
name|escalate
argument_list|,
name|seconds
argument_list|,
name|seconds
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|actionQueues
operator|.
name|renewing
argument_list|(
literal|"escalation"
argument_list|,
name|renew
argument_list|)
expr_stmt|;
block|}
comment|/**    * Look at where the current node state is -and whether it should be changed    * @param reason reason for operation    */
DECL|method|reviewRequestAndReleaseNodes (String reason)
specifier|private
specifier|synchronized
name|void
name|reviewRequestAndReleaseNodes
parameter_list|(
name|String
name|reason
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"reviewRequestAndReleaseNodes({})"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|queue
argument_list|(
operator|new
name|ReviewAndFlexApplicationSize
argument_list|(
name|reason
argument_list|,
literal|0
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Handle the event requesting a review ... look at the queue and decide    * whether to act or not    * @param action action triggering the event. It may be put    * back into the queue    * @throws SliderInternalStateException    */
DECL|method|handleReviewAndFlexApplicationSize (ReviewAndFlexApplicationSize action)
specifier|public
name|void
name|handleReviewAndFlexApplicationSize
parameter_list|(
name|ReviewAndFlexApplicationSize
name|action
parameter_list|)
throws|throws
name|SliderInternalStateException
block|{
if|if
condition|(
name|actionQueues
operator|.
name|hasQueuedActionWithAttribute
argument_list|(
name|AsyncAction
operator|.
name|ATTR_REVIEWS_APP_SIZE
operator||
name|AsyncAction
operator|.
name|ATTR_HALTS_APP
argument_list|)
condition|)
block|{
comment|// this operation isn't needed at all -existing duplicate or shutdown due
return|return;
block|}
comment|// if there is an action which changes cluster size, wait
if|if
condition|(
name|actionQueues
operator|.
name|hasQueuedActionWithAttribute
argument_list|(
name|AsyncAction
operator|.
name|ATTR_CHANGES_APP_SIZE
argument_list|)
condition|)
block|{
comment|// place the action at the back of the queue
name|actionQueues
operator|.
name|put
argument_list|(
name|action
argument_list|)
expr_stmt|;
block|}
name|executeNodeReview
argument_list|(
name|action
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
comment|/**    * Look at where the current node state is -and whether it should be changed    */
DECL|method|executeNodeReview (String reason)
specifier|public
specifier|synchronized
name|void
name|executeNodeReview
parameter_list|(
name|String
name|reason
parameter_list|)
throws|throws
name|SliderInternalStateException
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"in executeNodeReview({})"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|amCompletionFlag
operator|.
name|get
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Ignoring node review operation: shutdown in progress"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|allOperations
init|=
name|appState
operator|.
name|reviewRequestAndReleaseNodes
argument_list|()
decl_stmt|;
comment|// tell the provider
name|providerRMOperationHandler
operator|.
name|execute
argument_list|(
name|allOperations
argument_list|)
expr_stmt|;
comment|//now apply the operations
name|execute
argument_list|(
name|allOperations
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TriggerClusterTeardownException
name|e
parameter_list|)
block|{
comment|//App state has decided that it is time to exit
name|log
operator|.
name|error
argument_list|(
literal|"Cluster teardown triggered {}"
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|queue
argument_list|(
operator|new
name|ActionStopSlider
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Escalate operation as triggered by external timer.    *<p>    * Get the list of new operations off the AM, then executest them.    */
DECL|method|escalateOutstandingRequests ()
specifier|public
name|void
name|escalateOutstandingRequests
parameter_list|()
block|{
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|operations
init|=
name|appState
operator|.
name|escalateOutstandingRequests
argument_list|()
decl_stmt|;
name|providerRMOperationHandler
operator|.
name|execute
argument_list|(
name|operations
argument_list|)
expr_stmt|;
name|execute
argument_list|(
name|operations
argument_list|)
expr_stmt|;
block|}
comment|/**    * Shutdown operation: release all containers    */
DECL|method|releaseAllContainers ()
specifier|private
name|void
name|releaseAllContainers
parameter_list|()
block|{
comment|// Add the sleep here (before releasing containers) so that applications get
comment|// time to perform graceful shutdown
try|try
block|{
name|long
name|timeout
init|=
name|getContainerReleaseTimeout
argument_list|()
decl_stmt|;
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Sleep for container release interrupted"
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|operations
init|=
name|appState
operator|.
name|releaseAllContainers
argument_list|()
decl_stmt|;
name|providerRMOperationHandler
operator|.
name|execute
argument_list|(
name|operations
argument_list|)
expr_stmt|;
comment|// now apply the operations
name|execute
argument_list|(
name|operations
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getContainerReleaseTimeout ()
specifier|private
name|long
name|getContainerReleaseTimeout
parameter_list|()
block|{
comment|// Get container release timeout in millis or 0 if the property is not set.
comment|// If non-zero then add the agent heartbeat delay time, since it can take up
comment|// to that much time for agents to receive the stop command.
name|int
name|timeout
init|=
name|getInstanceDefinition
argument_list|()
operator|.
name|getAppConfOperations
argument_list|()
operator|.
name|getGlobalOptions
argument_list|()
operator|.
name|getOptionInt
argument_list|(
name|SliderKeys
operator|.
name|APP_CONTAINER_RELEASE_TIMEOUT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
name|timeout
operator|+=
name|SliderKeys
operator|.
name|APP_CONTAINER_HEARTBEAT_INTERVAL_SEC
expr_stmt|;
block|}
comment|// convert to millis
name|long
name|timeoutInMillis
init|=
name|timeout
operator|*
literal|1000l
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Container release timeout in millis = {}"
argument_list|,
name|timeoutInMillis
argument_list|)
expr_stmt|;
return|return
name|timeoutInMillis
return|;
block|}
comment|/**    * RM wants to shut down the AM    */
annotation|@
name|Override
comment|//AMRMClientAsync
DECL|method|onShutdownRequest ()
specifier|public
name|void
name|onShutdownRequest
parameter_list|()
block|{
name|LOG_YARN
operator|.
name|info
argument_list|(
literal|"Shutdown Request received"
argument_list|)
expr_stmt|;
name|signalAMComplete
argument_list|(
operator|new
name|ActionStopSlider
argument_list|(
literal|"stop"
argument_list|,
name|EXIT_SUCCESS
argument_list|,
name|FinalApplicationStatus
operator|.
name|SUCCEEDED
argument_list|,
literal|"Shutdown requested from RM"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Monitored nodes have been changed    * @param updatedNodes list of updated nodes    */
annotation|@
name|Override
comment|//AMRMClientAsync
DECL|method|onNodesUpdated (List<NodeReport> updatedNodes)
specifier|public
name|void
name|onNodesUpdated
parameter_list|(
name|List
argument_list|<
name|NodeReport
argument_list|>
name|updatedNodes
parameter_list|)
block|{
name|LOG_YARN
operator|.
name|info
argument_list|(
literal|"onNodesUpdated({})"
argument_list|,
name|updatedNodes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Updated nodes {}"
argument_list|,
name|updatedNodes
argument_list|)
expr_stmt|;
comment|// Check if any nodes are lost or revived and update state accordingly
name|AppState
operator|.
name|NodeUpdatedOutcome
name|outcome
init|=
name|appState
operator|.
name|onNodesUpdated
argument_list|(
name|updatedNodes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|outcome
operator|.
name|operations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|execute
argument_list|(
name|outcome
operator|.
name|operations
argument_list|)
expr_stmt|;
block|}
comment|// trigger a review if the cluster changed
if|if
condition|(
name|outcome
operator|.
name|clusterChanged
condition|)
block|{
name|reviewRequestAndReleaseNodes
argument_list|(
literal|"nodes updated"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * heartbeat operation; return the ratio of requested    * to actual    * @return progress    */
annotation|@
name|Override
comment|//AMRMClientAsync
DECL|method|getProgress ()
specifier|public
name|float
name|getProgress
parameter_list|()
block|{
return|return
name|appState
operator|.
name|getApplicationProgressPercentage
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|//AMRMClientAsync
DECL|method|onError (Throwable e)
specifier|public
name|void
name|onError
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG_YARN
operator|.
name|info
argument_list|(
literal|"Ignoring AMRMClientAsync.onError() received {}"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|/* =================================================================== */
comment|/* RMOperationHandlerActions */
comment|/* =================================================================== */
annotation|@
name|Override
DECL|method|execute (List<AbstractRMOperation> operations)
specifier|public
name|void
name|execute
parameter_list|(
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|operations
parameter_list|)
block|{
name|rmOperationHandler
operator|.
name|execute
argument_list|(
name|operations
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|releaseAssignedContainer (ContainerId containerId)
specifier|public
name|void
name|releaseAssignedContainer
parameter_list|(
name|ContainerId
name|containerId
parameter_list|)
block|{
name|rmOperationHandler
operator|.
name|releaseAssignedContainer
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|addContainerRequest (AMRMClient.ContainerRequest req)
specifier|public
name|void
name|addContainerRequest
parameter_list|(
name|AMRMClient
operator|.
name|ContainerRequest
name|req
parameter_list|)
block|{
name|rmOperationHandler
operator|.
name|addContainerRequest
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|cancelContainerRequests (Priority priority1, Priority priority2, int count)
specifier|public
name|int
name|cancelContainerRequests
parameter_list|(
name|Priority
name|priority1
parameter_list|,
name|Priority
name|priority2
parameter_list|,
name|int
name|count
parameter_list|)
block|{
return|return
name|rmOperationHandler
operator|.
name|cancelContainerRequests
argument_list|(
name|priority1
argument_list|,
name|priority2
argument_list|,
name|count
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|cancelSingleRequest (AMRMClient.ContainerRequest request)
specifier|public
name|void
name|cancelSingleRequest
parameter_list|(
name|AMRMClient
operator|.
name|ContainerRequest
name|request
parameter_list|)
block|{
name|rmOperationHandler
operator|.
name|cancelSingleRequest
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
comment|/* =================================================================== */
comment|/* END */
comment|/* =================================================================== */
comment|/**    * Launch the provider service    *    * @param instanceDefinition definition of the service    * @param confDir directory of config data    * @throws IOException    * @throws SliderException    */
DECL|method|launchProviderService (AggregateConf instanceDefinition, File confDir)
specifier|protected
specifier|synchronized
name|void
name|launchProviderService
parameter_list|(
name|AggregateConf
name|instanceDefinition
parameter_list|,
name|File
name|confDir
parameter_list|)
throws|throws
name|IOException
throws|,
name|SliderException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|boolean
name|execStarted
init|=
name|providerService
operator|.
name|exec
argument_list|(
name|instanceDefinition
argument_list|,
name|confDir
argument_list|,
name|env
argument_list|,
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|execStarted
condition|)
block|{
name|providerService
operator|.
name|registerServiceListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|providerService
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// didn't start, so don't register
name|providerService
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// and send the started event ourselves
name|eventCallbackEvent
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* =================================================================== */
comment|/* EventCallback  from the child or ourselves directly */
comment|/* =================================================================== */
annotation|@
name|Override
comment|// ProviderCompleted
DECL|method|eventCallbackEvent (Object parameter)
specifier|public
name|void
name|eventCallbackEvent
parameter_list|(
name|Object
name|parameter
parameter_list|)
block|{
comment|// signalled that the child process is up.
name|appState
operator|.
name|noteAMLive
argument_list|()
expr_stmt|;
comment|// now ask for the cluster nodes
try|try
block|{
name|flexCluster
argument_list|(
name|getInstanceDefinition
argument_list|()
operator|.
name|getResources
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// cluster flex failure: log
name|log
operator|.
name|error
argument_list|(
literal|"Failed to flex cluster nodes: {}"
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// then what? exit
name|queue
argument_list|(
operator|new
name|ActionStopSlider
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * report container loss. If this isn't already known about, react    *    * @param containerId       id of the container which has failed    * @throws SliderException    */
DECL|method|providerLostContainer ( ContainerId containerId)
specifier|public
specifier|synchronized
name|void
name|providerLostContainer
parameter_list|(
name|ContainerId
name|containerId
parameter_list|)
throws|throws
name|SliderException
block|{
name|log
operator|.
name|info
argument_list|(
literal|"containerLostContactWithProvider: container {} lost"
argument_list|,
name|containerId
argument_list|)
expr_stmt|;
name|RoleInstance
name|activeContainer
init|=
name|appState
operator|.
name|getOwnedContainer
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|activeContainer
operator|!=
literal|null
condition|)
block|{
name|execute
argument_list|(
name|appState
operator|.
name|releaseContainer
argument_list|(
name|containerId
argument_list|)
argument_list|)
expr_stmt|;
comment|// ask for more containers if needed
name|log
operator|.
name|info
argument_list|(
literal|"Container released; triggering review"
argument_list|)
expr_stmt|;
name|reviewRequestAndReleaseNodes
argument_list|(
literal|"Loss of container"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Container not in active set - ignoring"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* =================================================================== */
comment|/* ServiceStateChangeListener */
comment|/* =================================================================== */
comment|/**    * Received on listening service termination.    * @param service the service that has changed.    */
annotation|@
name|Override
comment|//ServiceStateChangeListener
DECL|method|stateChanged (Service service)
specifier|public
name|void
name|stateChanged
parameter_list|(
name|Service
name|service
parameter_list|)
block|{
if|if
condition|(
name|service
operator|==
name|providerService
operator|&&
name|service
operator|.
name|isInState
argument_list|(
name|STATE
operator|.
name|STOPPED
argument_list|)
condition|)
block|{
comment|//its the current master process in play
name|int
name|exitCode
init|=
name|providerService
operator|.
name|getExitCode
argument_list|()
decl_stmt|;
name|int
name|mappedProcessExitCode
init|=
name|exitCode
decl_stmt|;
name|boolean
name|shouldTriggerFailure
init|=
operator|!
name|amCompletionFlag
operator|.
name|get
argument_list|()
operator|&&
operator|(
name|mappedProcessExitCode
operator|!=
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|shouldTriggerFailure
condition|)
block|{
name|String
name|reason
init|=
literal|"Spawned process failed with raw "
operator|+
name|exitCode
operator|+
literal|" mapped to "
operator|+
name|mappedProcessExitCode
decl_stmt|;
name|ActionStopSlider
name|stop
init|=
operator|new
name|ActionStopSlider
argument_list|(
literal|"stop"
argument_list|,
name|mappedProcessExitCode
argument_list|,
name|FinalApplicationStatus
operator|.
name|FAILED
argument_list|,
name|reason
argument_list|)
decl_stmt|;
comment|//this wasn't expected: the process finished early
name|spawnedProcessExitedBeforeShutdownTriggered
operator|=
literal|true
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Process has exited with exit code {} mapped to {} -triggering termination"
argument_list|,
name|exitCode
argument_list|,
name|mappedProcessExitCode
argument_list|)
expr_stmt|;
comment|//tell the AM the cluster is complete
name|signalAMComplete
argument_list|(
name|stop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//we don't care
name|log
operator|.
name|info
argument_list|(
literal|"Process has exited with exit code {} mapped to {} -ignoring"
argument_list|,
name|exitCode
argument_list|,
name|mappedProcessExitCode
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|super
operator|.
name|stateChanged
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * stop forked process if it the running process var is not null    * @return the process exit code    */
DECL|method|stopForkedProcess ()
specifier|protected
specifier|synchronized
name|Integer
name|stopForkedProcess
parameter_list|()
block|{
name|providerService
operator|.
name|stop
argument_list|()
expr_stmt|;
return|return
name|providerService
operator|.
name|getExitCode
argument_list|()
return|;
block|}
comment|/**    *  Async start container request    * @param container container    * @param ctx context    * @param instance node details    */
DECL|method|startContainer (Container container, ContainerLaunchContext ctx, RoleInstance instance)
specifier|public
name|void
name|startContainer
parameter_list|(
name|Container
name|container
parameter_list|,
name|ContainerLaunchContext
name|ctx
parameter_list|,
name|RoleInstance
name|instance
parameter_list|)
throws|throws
name|IOException
block|{
name|appState
operator|.
name|containerStartSubmitted
argument_list|(
name|container
argument_list|,
name|instance
argument_list|)
expr_stmt|;
name|nmClientAsync
operator|.
name|startContainerAsync
argument_list|(
name|container
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
comment|/**    * Build the credentials needed for containers. This will include    * getting new delegation tokens for HDFS if the AM is running    * with a keytab.    * @return a buffer of credentials    * @throws IOException    */
DECL|method|buildContainerCredentials ()
specifier|private
name|Credentials
name|buildContainerCredentials
parameter_list|()
throws|throws
name|IOException
block|{
name|Credentials
name|credentials
init|=
operator|new
name|Credentials
argument_list|(
name|containerCredentials
argument_list|)
decl_stmt|;
if|if
condition|(
name|securityConfiguration
operator|.
name|isKeytabProvided
argument_list|()
condition|)
block|{
name|CredentialUtils
operator|.
name|addSelfRenewableFSDelegationTokens
argument_list|(
name|getClusterFS
argument_list|()
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|credentials
argument_list|)
expr_stmt|;
block|}
return|return
name|credentials
return|;
block|}
annotation|@
name|Override
comment|//  NMClientAsync.CallbackHandler
DECL|method|onContainerStopped (ContainerId containerId)
specifier|public
name|void
name|onContainerStopped
parameter_list|(
name|ContainerId
name|containerId
parameter_list|)
block|{
comment|// do nothing but log: container events from the AM
comment|// are the source of container halt details to react to
name|log
operator|.
name|info
argument_list|(
literal|"onContainerStopped {} "
argument_list|,
name|containerId
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
comment|//  NMClientAsync.CallbackHandler
DECL|method|onContainerStarted (ContainerId containerId, Map<String, ByteBuffer> allServiceResponse)
specifier|public
name|void
name|onContainerStarted
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ByteBuffer
argument_list|>
name|allServiceResponse
parameter_list|)
block|{
name|LOG_YARN
operator|.
name|info
argument_list|(
literal|"Started Container {} "
argument_list|,
name|containerId
argument_list|)
expr_stmt|;
name|RoleInstance
name|cinfo
init|=
name|appState
operator|.
name|onNodeManagerContainerStarted
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|cinfo
operator|!=
literal|null
condition|)
block|{
name|LOG_YARN
operator|.
name|info
argument_list|(
literal|"Deployed instance of role {} onto {}"
argument_list|,
name|cinfo
operator|.
name|role
argument_list|,
name|containerId
argument_list|)
expr_stmt|;
comment|//trigger an async container status
name|nmClientAsync
operator|.
name|getContainerStatusAsync
argument_list|(
name|containerId
argument_list|,
name|cinfo
operator|.
name|container
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
comment|// push out a registration
name|queue
argument_list|(
operator|new
name|RegisterComponentInstance
argument_list|(
name|containerId
argument_list|,
name|cinfo
operator|.
name|role
argument_list|,
name|cinfo
operator|.
name|group
argument_list|,
literal|0
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//this is a hypothetical path not seen. We react by warning
name|log
operator|.
name|error
argument_list|(
literal|"Notified of started container that isn't pending {} - releasing"
argument_list|,
name|containerId
argument_list|)
expr_stmt|;
comment|//then release it
name|asyncRMClient
operator|.
name|releaseAssignedContainer
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
comment|//  NMClientAsync.CallbackHandler
DECL|method|onStartContainerError (ContainerId containerId, Throwable t)
specifier|public
name|void
name|onStartContainerError
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
name|LOG_YARN
operator|.
name|error
argument_list|(
literal|"Failed to start Container {}"
argument_list|,
name|containerId
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|appState
operator|.
name|onNodeManagerContainerStartFailed
argument_list|(
name|containerId
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
comment|//  NMClientAsync.CallbackHandler
DECL|method|onContainerStatusReceived (ContainerId containerId, ContainerStatus containerStatus)
specifier|public
name|void
name|onContainerStatusReceived
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|ContainerStatus
name|containerStatus
parameter_list|)
block|{
name|LOG_YARN
operator|.
name|debug
argument_list|(
literal|"Container Status: id={}, status={}"
argument_list|,
name|containerId
argument_list|,
name|containerStatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|providerService
operator|.
name|processContainerStatus
argument_list|(
name|containerId
argument_list|,
name|containerStatus
argument_list|)
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{       }
name|RoleInstance
name|cinfo
init|=
name|appState
operator|.
name|getOwnedContainer
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|cinfo
operator|!=
literal|null
condition|)
block|{
name|LOG_YARN
operator|.
name|info
argument_list|(
literal|"Re-requesting status for role {}, {}"
argument_list|,
name|cinfo
operator|.
name|role
argument_list|,
name|containerId
argument_list|)
expr_stmt|;
comment|//trigger another async container status
name|nmClientAsync
operator|.
name|getContainerStatusAsync
argument_list|(
name|containerId
argument_list|,
name|cinfo
operator|.
name|container
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
comment|//  NMClientAsync.CallbackHandler
DECL|method|onGetContainerStatusError ( ContainerId containerId, Throwable t)
specifier|public
name|void
name|onGetContainerStatusError
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
name|LOG_YARN
operator|.
name|error
argument_list|(
literal|"Failed to query the status of Container {}"
argument_list|,
name|containerId
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
comment|//  NMClientAsync.CallbackHandler
DECL|method|onStopContainerError (ContainerId containerId, Throwable t)
specifier|public
name|void
name|onStopContainerError
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
name|LOG_YARN
operator|.
name|warn
argument_list|(
literal|"Failed to stop Container {}"
argument_list|,
name|containerId
argument_list|)
expr_stmt|;
block|}
DECL|method|getInstanceDefinition ()
specifier|public
name|AggregateConf
name|getInstanceDefinition
parameter_list|()
block|{
return|return
name|appState
operator|.
name|getInstanceDefinition
argument_list|()
return|;
block|}
comment|/**    * This is the status, the live model    */
DECL|method|getClusterDescription ()
specifier|public
name|ClusterDescription
name|getClusterDescription
parameter_list|()
block|{
return|return
name|appState
operator|.
name|getClusterStatus
argument_list|()
return|;
block|}
DECL|method|getProviderService ()
specifier|public
name|ProviderService
name|getProviderService
parameter_list|()
block|{
return|return
name|providerService
return|;
block|}
comment|/**    * Queue an action for immediate execution in the executor thread    * @param action action to execute    */
DECL|method|queue (AsyncAction action)
specifier|public
name|void
name|queue
parameter_list|(
name|AsyncAction
name|action
parameter_list|)
block|{
name|actionQueues
operator|.
name|put
argument_list|(
name|action
argument_list|)
expr_stmt|;
block|}
comment|/**    * Schedule an action    * @param action for delayed execution    */
DECL|method|schedule (AsyncAction action)
specifier|public
name|void
name|schedule
parameter_list|(
name|AsyncAction
name|action
parameter_list|)
block|{
name|actionQueues
operator|.
name|schedule
argument_list|(
name|action
argument_list|)
expr_stmt|;
block|}
comment|/**    * Handle any exception in a thread. If the exception provides an exit    * code, that is the one that will be used    * @param thread thread throwing the exception    * @param exception exception    */
DECL|method|onExceptionInThread (Thread thread, Throwable exception)
specifier|public
name|void
name|onExceptionInThread
parameter_list|(
name|Thread
name|thread
parameter_list|,
name|Throwable
name|exception
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Exception in {}: {}"
argument_list|,
name|thread
operator|.
name|getName
argument_list|()
argument_list|,
name|exception
argument_list|,
name|exception
argument_list|)
expr_stmt|;
comment|// if there is a teardown in progress, ignore it
if|if
condition|(
name|amCompletionFlag
operator|.
name|get
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Ignoring exception: shutdown in progress"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|exitCode
init|=
name|EXIT_EXCEPTION_THROWN
decl_stmt|;
if|if
condition|(
name|exception
operator|instanceof
name|ExitCodeProvider
condition|)
block|{
name|exitCode
operator|=
operator|(
operator|(
name|ExitCodeProvider
operator|)
name|exception
operator|)
operator|.
name|getExitCode
argument_list|()
expr_stmt|;
block|}
name|signalAMComplete
argument_list|(
operator|new
name|ActionStopSlider
argument_list|(
literal|"stop"
argument_list|,
name|exitCode
argument_list|,
name|FinalApplicationStatus
operator|.
name|FAILED
argument_list|,
name|exception
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Start the chaos monkey    * @return true if it started    */
DECL|method|maybeStartMonkey ()
specifier|private
name|boolean
name|maybeStartMonkey
parameter_list|()
block|{
name|MapOperations
name|internals
init|=
name|getGlobalInternalOptions
argument_list|()
decl_stmt|;
name|Boolean
name|enabled
init|=
name|internals
operator|.
name|getOptionBool
argument_list|(
name|InternalKeys
operator|.
name|CHAOS_MONKEY_ENABLED
argument_list|,
name|InternalKeys
operator|.
name|DEFAULT_CHAOS_MONKEY_ENABLED
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|enabled
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Chaos monkey disabled"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|long
name|monkeyInterval
init|=
name|internals
operator|.
name|getTimeRange
argument_list|(
name|InternalKeys
operator|.
name|CHAOS_MONKEY_INTERVAL
argument_list|,
name|InternalKeys
operator|.
name|DEFAULT_CHAOS_MONKEY_INTERVAL_DAYS
argument_list|,
name|InternalKeys
operator|.
name|DEFAULT_CHAOS_MONKEY_INTERVAL_HOURS
argument_list|,
name|InternalKeys
operator|.
name|DEFAULT_CHAOS_MONKEY_INTERVAL_MINUTES
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|monkeyInterval
operator|==
literal|0
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Chaos monkey not configured with a time interval...not enabling"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|long
name|monkeyDelay
init|=
name|internals
operator|.
name|getTimeRange
argument_list|(
name|InternalKeys
operator|.
name|CHAOS_MONKEY_DELAY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|monkeyInterval
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Adding Chaos Monkey scheduled every {} seconds ({} hours -delay {}"
argument_list|,
name|monkeyInterval
argument_list|,
name|monkeyInterval
operator|/
operator|(
literal|60
operator|*
literal|60
operator|)
argument_list|,
name|monkeyDelay
argument_list|)
expr_stmt|;
name|monkey
operator|=
operator|new
name|ChaosMonkeyService
argument_list|(
name|metrics
argument_list|,
name|actionQueues
argument_list|)
expr_stmt|;
name|initAndAddService
argument_list|(
name|monkey
argument_list|)
expr_stmt|;
comment|// configure the targets
comment|// launch failure: special case with explicit failure triggered now
name|int
name|amLaunchFailProbability
init|=
name|internals
operator|.
name|getOptionInt
argument_list|(
name|InternalKeys
operator|.
name|CHAOS_MONKEY_PROBABILITY_AM_LAUNCH_FAILURE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|amLaunchFailProbability
operator|>
literal|0
operator|&&
name|monkey
operator|.
name|chaosCheck
argument_list|(
name|amLaunchFailProbability
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Chaos Monkey has triggered AM Launch failure"
argument_list|)
expr_stmt|;
comment|// trigger a failure
name|ActionStopSlider
name|stop
init|=
operator|new
name|ActionStopSlider
argument_list|(
literal|"stop"
argument_list|,
literal|0
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|,
name|LauncherExitCodes
operator|.
name|EXIT_FALSE
argument_list|,
name|FinalApplicationStatus
operator|.
name|FAILED
argument_list|,
name|E_TRIGGERED_LAUNCH_FAILURE
argument_list|)
decl_stmt|;
name|queue
argument_list|(
name|stop
argument_list|)
expr_stmt|;
block|}
name|int
name|amKillProbability
init|=
name|internals
operator|.
name|getOptionInt
argument_list|(
name|InternalKeys
operator|.
name|CHAOS_MONKEY_PROBABILITY_AM_FAILURE
argument_list|,
name|InternalKeys
operator|.
name|DEFAULT_CHAOS_MONKEY_PROBABILITY_AM_FAILURE
argument_list|)
decl_stmt|;
name|monkey
operator|.
name|addTarget
argument_list|(
literal|"AM killer"
argument_list|,
operator|new
name|ChaosKillAM
argument_list|(
name|actionQueues
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
name|amKillProbability
argument_list|)
expr_stmt|;
name|int
name|containerKillProbability
init|=
name|internals
operator|.
name|getOptionInt
argument_list|(
name|InternalKeys
operator|.
name|CHAOS_MONKEY_PROBABILITY_CONTAINER_FAILURE
argument_list|,
name|InternalKeys
operator|.
name|DEFAULT_CHAOS_MONKEY_PROBABILITY_CONTAINER_FAILURE
argument_list|)
decl_stmt|;
name|monkey
operator|.
name|addTarget
argument_list|(
literal|"Container killer"
argument_list|,
operator|new
name|ChaosKillContainer
argument_list|(
name|appState
argument_list|,
name|actionQueues
argument_list|,
name|rmOperationHandler
argument_list|)
argument_list|,
name|containerKillProbability
argument_list|)
expr_stmt|;
comment|// and schedule it
if|if
condition|(
name|monkey
operator|.
name|schedule
argument_list|(
name|monkeyDelay
argument_list|,
name|monkeyInterval
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Chaos Monkey is running"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Chaos monkey not started"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|/**    * This is the main entry point for the service launcher.    * @param args command line arguments.    */
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
comment|//turn the args to a list
name|List
argument_list|<
name|String
argument_list|>
name|argsList
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|args
argument_list|)
decl_stmt|;
comment|//create a new list, as the ArrayList type doesn't push() on an insert
name|List
argument_list|<
name|String
argument_list|>
name|extendedArgs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|argsList
argument_list|)
decl_stmt|;
comment|//insert the service name
name|extendedArgs
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|SERVICE_CLASSNAME
argument_list|)
expr_stmt|;
comment|//now have the service launcher do its work
name|ServiceLauncher
operator|.
name|serviceMain
argument_list|(
name|extendedArgs
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

