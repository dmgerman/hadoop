begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License. */
end_comment

begin_package
DECL|package|org.apache.slider.client
package|package
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|client
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|collections
operator|.
name|CollectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|ArrayUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|api
operator|.
name|RegistryConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|api
operator|.
name|RegistryOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryPathUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|exceptions
operator|.
name|NoRecordException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|Endpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|RegistryPathStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|ServiceRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|yarn
operator|.
name|YarnRegistryAttributes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|Credentials
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|KerberosDiags
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|alias
operator|.
name|CredentialProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|alias
operator|.
name|CredentialProviderFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|ApplicationConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationTimeoutType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|FinalApplicationStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|LocalResource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|NodeReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|NodeState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|YarnApplicationState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|ApplicationAttemptNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|ApplicationNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|ConverterUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|ClusterDescription
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|ClusterNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|SliderApplicationApi
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|SliderClusterProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|StateValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|proto
operator|.
name|Messages
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|types
operator|.
name|ContainerInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|types
operator|.
name|NodeInformationList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|types
operator|.
name|SliderInstanceDescription
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|client
operator|.
name|ipc
operator|.
name|SliderApplicationIpcClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|client
operator|.
name|ipc
operator|.
name|SliderClusterOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|SliderExitCodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|SliderKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|AbstractActionArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|AbstractClusterBuildingActionArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionAMSuicideArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionClientArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionCreateArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionDependencyArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionDestroyArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionDiagnosticArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionEchoArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionExistsArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionFlexArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionFreezeArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionInstallKeytabArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionInstallPackageArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionKDiagArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionKeytabArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionKillContainerArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionListArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionLookupArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionNodesArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionPackageArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionRegistryArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionResolveArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionResourceArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionStatusArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionThawArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionTokensArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionUpgradeArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|Arguments
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ClientArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|CommonArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|LaunchArgsAccessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|ConfigHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|Duration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|SliderFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|SliderUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|SliderVersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|buildutils
operator|.
name|InstanceBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|buildutils
operator|.
name|InstanceIO
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|conf
operator|.
name|AggregateConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|conf
operator|.
name|ConfTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|conf
operator|.
name|ConfTreeOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|conf
operator|.
name|MapOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|conf
operator|.
name|ResourcesInputPropertiesValidator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|conf
operator|.
name|TemplateInputPropertiesValidator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|BadClusterStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|BadCommandArgumentsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|BadConfigException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|ErrorStrings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|NoSuchNodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|NotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|SliderException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|UnknownApplicationInstanceException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|UsageException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|WaitTimeoutException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|launch
operator|.
name|AppMasterLauncher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|launch
operator|.
name|ClasspathConstructor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|launch
operator|.
name|CredentialUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|launch
operator|.
name|JavaCommandLineBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|launch
operator|.
name|LaunchedApplication
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|launch
operator|.
name|RunningApplication
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|launch
operator|.
name|SerializedApplicationReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|main
operator|.
name|RunService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|persist
operator|.
name|AppDefinitionPersister
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|persist
operator|.
name|ApplicationReportSerDeser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|persist
operator|.
name|ConfPersister
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|persist
operator|.
name|JsonSerDeser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|persist
operator|.
name|LockAcquireFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|registry
operator|.
name|SliderRegistryUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|registry
operator|.
name|YarnAppListClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|registry
operator|.
name|docstore
operator|.
name|ConfigFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|registry
operator|.
name|docstore
operator|.
name|PublishedConfigSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|registry
operator|.
name|docstore
operator|.
name|PublishedConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|registry
operator|.
name|docstore
operator|.
name|PublishedExports
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|registry
operator|.
name|docstore
operator|.
name|PublishedExportsOutputter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|registry
operator|.
name|docstore
operator|.
name|PublishedExportsSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|registry
operator|.
name|retrieve
operator|.
name|RegistryRetriever
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|zk
operator|.
name|BlockingZKWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|zk
operator|.
name|ZKIntegration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|zk
operator|.
name|ZKPathBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|providers
operator|.
name|AbstractClientProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|providers
operator|.
name|SliderProviderFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|providers
operator|.
name|agent
operator|.
name|AgentKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|providers
operator|.
name|docker
operator|.
name|DockerClientProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|providers
operator|.
name|slideram
operator|.
name|SliderAMClientProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|SliderAppMaster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|rpc
operator|.
name|RpcBinder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|services
operator|.
name|security
operator|.
name|SecurityStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|services
operator|.
name|utility
operator|.
name|AbstractSliderLaunchedService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|CreateMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|ZooDefs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|ACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jettison
operator|.
name|json
operator|.
name|JSONException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jettison
operator|.
name|json
operator|.
name|JSONObject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Console
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryUtils
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|InternalKeys
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|OptionKeys
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|ResourceKeys
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|Constants
operator|.
name|HADOOP_JAAS_DEBUG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|SliderActions
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|SliderUtils
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Client service for Slider  */
end_comment

begin_class
DECL|class|SliderClient
specifier|public
class|class
name|SliderClient
extends|extends
name|AbstractSliderLaunchedService
implements|implements
name|RunService
implements|,
name|SliderExitCodes
implements|,
name|SliderKeys
implements|,
name|ErrorStrings
implements|,
name|SliderClientAPI
block|{
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SliderClient
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|E_MUST_BE_A_VALID_JSON_FILE
specifier|public
specifier|static
specifier|final
name|String
name|E_MUST_BE_A_VALID_JSON_FILE
init|=
literal|"Invalid configuration. Must be a valid json file."
decl_stmt|;
DECL|field|E_INVALID_INSTALL_LOCATION
specifier|public
specifier|static
specifier|final
name|String
name|E_INVALID_INSTALL_LOCATION
init|=
literal|"A valid install location must be provided for the client."
decl_stmt|;
DECL|field|E_UNABLE_TO_READ_SUPPLIED_PACKAGE_FILE
specifier|public
specifier|static
specifier|final
name|String
name|E_UNABLE_TO_READ_SUPPLIED_PACKAGE_FILE
init|=
literal|"Unable to read supplied package file"
decl_stmt|;
DECL|field|E_INVALID_APPLICATION_PACKAGE_LOCATION
specifier|public
specifier|static
specifier|final
name|String
name|E_INVALID_APPLICATION_PACKAGE_LOCATION
init|=
literal|"A valid application package location required."
decl_stmt|;
DECL|field|E_INVALID_INSTALL_PATH
specifier|public
specifier|static
specifier|final
name|String
name|E_INVALID_INSTALL_PATH
init|=
literal|"Install path is not a valid directory"
decl_stmt|;
DECL|field|E_INSTALL_PATH_DOES_NOT_EXIST
specifier|public
specifier|static
specifier|final
name|String
name|E_INSTALL_PATH_DOES_NOT_EXIST
init|=
literal|"Install path does not exist"
decl_stmt|;
DECL|field|E_INVALID_APPLICATION_TYPE_NAME
specifier|public
specifier|static
specifier|final
name|String
name|E_INVALID_APPLICATION_TYPE_NAME
init|=
literal|"A valid application type name is required (e.g. HBASE)."
decl_stmt|;
DECL|field|E_USE_REPLACEPKG_TO_OVERWRITE
specifier|public
specifier|static
specifier|final
name|String
name|E_USE_REPLACEPKG_TO_OVERWRITE
init|=
literal|"Use --replacepkg to overwrite."
decl_stmt|;
DECL|field|E_PACKAGE_DOES_NOT_EXIST
specifier|public
specifier|static
specifier|final
name|String
name|E_PACKAGE_DOES_NOT_EXIST
init|=
literal|"Package does not exist"
decl_stmt|;
DECL|field|E_NO_ZOOKEEPER_QUORUM
specifier|public
specifier|static
specifier|final
name|String
name|E_NO_ZOOKEEPER_QUORUM
init|=
literal|"No Zookeeper quorum defined"
decl_stmt|;
DECL|field|E_NO_RESOURCE_MANAGER
specifier|public
specifier|static
specifier|final
name|String
name|E_NO_RESOURCE_MANAGER
init|=
literal|"No valid Resource Manager address provided"
decl_stmt|;
DECL|field|E_PACKAGE_EXISTS
specifier|public
specifier|static
specifier|final
name|String
name|E_PACKAGE_EXISTS
init|=
literal|"Package exists"
decl_stmt|;
DECL|field|clientOutputStream
specifier|private
specifier|static
name|PrintStream
name|clientOutputStream
init|=
name|System
operator|.
name|out
decl_stmt|;
comment|// value should not be changed without updating string find in slider.py
DECL|field|PASSWORD_PROMPT
specifier|private
specifier|static
specifier|final
name|String
name|PASSWORD_PROMPT
init|=
literal|"Enter password for"
decl_stmt|;
DECL|field|serviceArgs
specifier|private
name|ClientArgs
name|serviceArgs
decl_stmt|;
DECL|field|applicationId
specifier|public
name|ApplicationId
name|applicationId
decl_stmt|;
DECL|field|deployedClusterName
specifier|private
name|String
name|deployedClusterName
decl_stmt|;
comment|/**    * Cluster operations against the deployed cluster -will be null    * if no bonding has yet taken place    */
DECL|field|sliderClusterOperations
specifier|private
name|SliderClusterOperations
name|sliderClusterOperations
decl_stmt|;
DECL|field|sliderFileSystem
specifier|protected
name|SliderFileSystem
name|sliderFileSystem
decl_stmt|;
comment|/**    * Yarn client service    */
DECL|field|yarnClient
specifier|private
name|SliderYarnClientImpl
name|yarnClient
decl_stmt|;
DECL|field|yarnAppListClient
specifier|private
name|YarnAppListClient
name|yarnAppListClient
decl_stmt|;
DECL|field|launchedInstanceDefinition
specifier|private
name|AggregateConf
name|launchedInstanceDefinition
decl_stmt|;
comment|/**    * The YARN registry service    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"FieldAccessedSynchronizedAndUnsynchronized"
argument_list|)
DECL|field|registryOperations
specifier|private
name|RegistryOperations
name|registryOperations
decl_stmt|;
comment|/**    * Constructor    */
DECL|method|SliderClient ()
specifier|public
name|SliderClient
parameter_list|()
block|{
name|super
argument_list|(
literal|"Slider Client"
argument_list|)
expr_stmt|;
operator|new
name|HdfsConfiguration
argument_list|()
expr_stmt|;
operator|new
name|YarnConfiguration
argument_list|()
expr_stmt|;
block|}
comment|/**    * This is called<i>Before serviceInit is called</i>    * @param config the initial configuration build up by the    * service launcher.    * @param args argument list list of arguments passed to the command line    * after any launcher-specific commands have been stripped.    * @return the post-binding configuration to pass to the<code>init()</code>    * operation.    * @throws Exception    */
annotation|@
name|Override
DECL|method|bindArgs (Configuration config, String... args)
specifier|public
name|Configuration
name|bindArgs
parameter_list|(
name|Configuration
name|config
parameter_list|,
name|String
modifier|...
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|config
operator|=
name|super
operator|.
name|bindArgs
argument_list|(
name|config
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|serviceArgs
operator|=
operator|new
name|ClientArgs
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|serviceArgs
operator|.
name|parse
argument_list|()
expr_stmt|;
comment|// add the slider XML config
name|ConfigHelper
operator|.
name|injectSliderXMLResource
argument_list|()
expr_stmt|;
comment|// yarn-ify
name|YarnConfiguration
name|yarnConfiguration
init|=
operator|new
name|YarnConfiguration
argument_list|(
name|config
argument_list|)
decl_stmt|;
return|return
name|patchConfiguration
argument_list|(
name|yarnConfiguration
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|serviceInit (Configuration conf)
specifier|protected
name|void
name|serviceInit
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
name|Configuration
name|clientConf
init|=
name|loadSliderClientXML
argument_list|()
decl_stmt|;
name|ConfigHelper
operator|.
name|mergeConfigurations
argument_list|(
name|conf
argument_list|,
name|clientConf
argument_list|,
name|SLIDER_CLIENT_XML
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|serviceArgs
operator|.
name|applyDefinitions
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|serviceArgs
operator|.
name|applyFileSystemBinding
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|AbstractActionArgs
name|coreAction
init|=
name|serviceArgs
operator|.
name|getCoreAction
argument_list|()
decl_stmt|;
comment|// init security with our conf
if|if
condition|(
operator|!
name|coreAction
operator|.
name|disableSecureLogin
argument_list|()
operator|&&
name|isHadoopClusterSecure
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|forceLogin
argument_list|()
expr_stmt|;
name|initProcessSecurity
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|coreAction
operator|.
name|getHadoopServicesRequired
argument_list|()
condition|)
block|{
name|initHadoopBinding
argument_list|()
expr_stmt|;
block|}
name|super
operator|.
name|serviceInit
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Launched service execution. This runs {@link #exec()}    * then catches some exceptions and converts them to exit codes    * @return an exit code    * @throws Throwable    */
annotation|@
name|Override
DECL|method|runService ()
specifier|public
name|int
name|runService
parameter_list|()
throws|throws
name|Throwable
block|{
try|try
block|{
return|return
name|exec
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
decl||
name|PathNotFoundException
name|nfe
parameter_list|)
block|{
throw|throw
operator|new
name|NotFoundException
argument_list|(
name|nfe
argument_list|,
name|nfe
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Execute the command line    * @return an exit code    * @throws Throwable on a failure    */
DECL|method|exec ()
specifier|public
name|int
name|exec
parameter_list|()
throws|throws
name|Throwable
block|{
comment|// choose the action
name|String
name|action
init|=
name|serviceArgs
operator|.
name|getAction
argument_list|()
decl_stmt|;
if|if
condition|(
name|isUnset
argument_list|(
name|action
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SliderException
argument_list|(
name|EXIT_USAGE
argument_list|,
name|serviceArgs
operator|.
name|usage
argument_list|()
argument_list|)
throw|;
block|}
name|int
name|exitCode
init|=
name|EXIT_SUCCESS
decl_stmt|;
name|String
name|clusterName
init|=
name|serviceArgs
operator|.
name|getClusterName
argument_list|()
decl_stmt|;
comment|// actions
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|ACTION_AM_SUICIDE
case|:
name|exitCode
operator|=
name|actionAmSuicide
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionAMSuicideArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_BUILD
case|:
name|exitCode
operator|=
name|actionBuild
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionBuildArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_CLIENT
case|:
name|exitCode
operator|=
name|actionClient
argument_list|(
name|serviceArgs
operator|.
name|getActionClientArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_CREATE
case|:
name|exitCode
operator|=
name|actionCreate
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionCreateArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_DEPENDENCY
case|:
name|exitCode
operator|=
name|actionDependency
argument_list|(
name|serviceArgs
operator|.
name|getActionDependencyArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_DESTROY
case|:
name|exitCode
operator|=
name|actionDestroy
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionDestroyArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_DIAGNOSTICS
case|:
name|exitCode
operator|=
name|actionDiagnostic
argument_list|(
name|serviceArgs
operator|.
name|getActionDiagnosticArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_EXISTS
case|:
name|exitCode
operator|=
name|actionExists
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionExistsArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_FLEX
case|:
name|exitCode
operator|=
name|actionFlex
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionFlexArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_FREEZE
case|:
name|exitCode
operator|=
name|actionFreeze
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionFreezeArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_HELP
case|:
name|log
operator|.
name|info
argument_list|(
name|serviceArgs
operator|.
name|usage
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_KDIAG
case|:
name|exitCode
operator|=
name|actionKDiag
argument_list|(
name|serviceArgs
operator|.
name|getActionKDiagArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_KILL_CONTAINER
case|:
name|exitCode
operator|=
name|actionKillContainer
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionKillContainerArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_INSTALL_KEYTAB
case|:
name|exitCode
operator|=
name|actionInstallKeytab
argument_list|(
name|serviceArgs
operator|.
name|getActionInstallKeytabArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_INSTALL_PACKAGE
case|:
name|exitCode
operator|=
name|actionInstallPkg
argument_list|(
name|serviceArgs
operator|.
name|getActionInstallPackageArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_KEYTAB
case|:
name|exitCode
operator|=
name|actionKeytab
argument_list|(
name|serviceArgs
operator|.
name|getActionKeytabArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_LIST
case|:
name|exitCode
operator|=
name|actionList
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionListArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_LOOKUP
case|:
name|exitCode
operator|=
name|actionLookup
argument_list|(
name|serviceArgs
operator|.
name|getActionLookupArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_NODES
case|:
name|exitCode
operator|=
name|actionNodes
argument_list|(
literal|""
argument_list|,
name|serviceArgs
operator|.
name|getActionNodesArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_PACKAGE
case|:
name|exitCode
operator|=
name|actionPackage
argument_list|(
name|serviceArgs
operator|.
name|getActionPackageArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_REGISTRY
case|:
name|exitCode
operator|=
name|actionRegistry
argument_list|(
name|serviceArgs
operator|.
name|getActionRegistryArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_RESOLVE
case|:
name|exitCode
operator|=
name|actionResolve
argument_list|(
name|serviceArgs
operator|.
name|getActionResolveArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_RESOURCE
case|:
name|exitCode
operator|=
name|actionResource
argument_list|(
name|serviceArgs
operator|.
name|getActionResourceArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_STATUS
case|:
name|exitCode
operator|=
name|actionStatus
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionStatusArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_THAW
case|:
name|exitCode
operator|=
name|actionThaw
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionThawArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_TOKENS
case|:
name|exitCode
operator|=
name|actionTokens
argument_list|(
name|serviceArgs
operator|.
name|getActionTokenArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_UPDATE
case|:
name|exitCode
operator|=
name|actionUpdate
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionUpdateArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_UPGRADE
case|:
name|exitCode
operator|=
name|actionUpgrade
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionUpgradeArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_VERSION
case|:
name|exitCode
operator|=
name|actionVersion
argument_list|()
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SliderException
argument_list|(
name|EXIT_UNIMPLEMENTED
argument_list|,
literal|"Unimplemented: "
operator|+
name|action
argument_list|)
throw|;
block|}
return|return
name|exitCode
return|;
block|}
comment|/**    * Perform everything needed to init the hadoop binding.    * This assumes that the service is already  in inited or started state    * @throws IOException    * @throws SliderException    */
DECL|method|initHadoopBinding ()
specifier|protected
name|void
name|initHadoopBinding
parameter_list|()
throws|throws
name|IOException
throws|,
name|SliderException
block|{
comment|// validate the client
name|validateSliderClientEnvironment
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|//create the YARN client
name|yarnClient
operator|=
operator|new
name|SliderYarnClientImpl
argument_list|()
expr_stmt|;
name|yarnClient
operator|.
name|init
argument_list|(
name|getConfig
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|getServiceState
argument_list|()
operator|==
name|STATE
operator|.
name|STARTED
condition|)
block|{
name|yarnClient
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|addService
argument_list|(
name|yarnClient
argument_list|)
expr_stmt|;
name|yarnAppListClient
operator|=
operator|new
name|YarnAppListClient
argument_list|(
name|yarnClient
argument_list|,
name|getUsername
argument_list|()
argument_list|,
name|getConfig
argument_list|()
argument_list|)
expr_stmt|;
comment|// create the filesystem
name|sliderFileSystem
operator|=
operator|new
name|SliderFileSystem
argument_list|(
name|getConfig
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete the zookeeper node associated with the calling user and the cluster    * TODO: YARN registry operations    **/
annotation|@
name|VisibleForTesting
DECL|method|deleteZookeeperNode (String clusterName)
specifier|public
name|boolean
name|deleteZookeeperNode
parameter_list|(
name|String
name|clusterName
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|String
name|user
init|=
name|getUsername
argument_list|()
decl_stmt|;
name|String
name|zkPath
init|=
name|ZKIntegration
operator|.
name|mkClusterPath
argument_list|(
name|user
argument_list|,
name|clusterName
argument_list|)
decl_stmt|;
name|Exception
name|e
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Configuration
name|config
init|=
name|getConfig
argument_list|()
decl_stmt|;
name|ZKIntegration
name|client
init|=
name|getZkClient
argument_list|(
name|clusterName
argument_list|,
name|user
argument_list|)
decl_stmt|;
if|if
condition|(
name|client
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|client
operator|.
name|exists
argument_list|(
name|zkPath
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Deleting zookeeper path {}"
argument_list|,
name|zkPath
argument_list|)
expr_stmt|;
block|}
name|client
operator|.
name|deleteRecursive
argument_list|(
name|zkPath
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
decl||
name|BadConfigException
decl||
name|KeeperException
name|ex
parameter_list|)
block|{
name|e
operator|=
name|ex
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to recursively delete zk node {}"
argument_list|,
name|zkPath
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Create the zookeeper node associated with the calling user and the cluster    *    * @param clusterName slider application name    * @param nameOnly should the name only be created (i.e. don't create ZK node)    * @return the path, using the policy implemented in    *   {@link ZKIntegration#mkClusterPath(String, String)}    * @throws YarnException    * @throws IOException    */
annotation|@
name|VisibleForTesting
DECL|method|createZookeeperNode (String clusterName, Boolean nameOnly)
specifier|public
name|String
name|createZookeeperNode
parameter_list|(
name|String
name|clusterName
parameter_list|,
name|Boolean
name|nameOnly
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
try|try
block|{
return|return
name|createZookeeperNodeInner
argument_list|(
name|clusterName
argument_list|,
name|nameOnly
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NodeExistsException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InterruptedIOException
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Create the zookeeper node associated with the calling user and the cluster    * -throwing exceptions on any failure    * @param clusterName cluster name    * @param nameOnly create the path, not the node    * @return the path, using the policy implemented in    *   {@link ZKIntegration#mkClusterPath(String, String)}    * @throws YarnException    * @throws IOException    * @throws KeeperException    * @throws InterruptedException    */
annotation|@
name|VisibleForTesting
DECL|method|createZookeeperNodeInner (String clusterName, Boolean nameOnly)
specifier|public
name|String
name|createZookeeperNodeInner
parameter_list|(
name|String
name|clusterName
parameter_list|,
name|Boolean
name|nameOnly
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
throws|,
name|KeeperException
throws|,
name|InterruptedException
block|{
name|String
name|user
init|=
name|getUsername
argument_list|()
decl_stmt|;
name|String
name|zkPath
init|=
name|ZKIntegration
operator|.
name|mkClusterPath
argument_list|(
name|user
argument_list|,
name|clusterName
argument_list|)
decl_stmt|;
if|if
condition|(
name|nameOnly
condition|)
block|{
return|return
name|zkPath
return|;
block|}
name|ZKIntegration
name|client
init|=
name|getZkClient
argument_list|(
name|clusterName
argument_list|,
name|user
argument_list|)
decl_stmt|;
if|if
condition|(
name|client
operator|!=
literal|null
condition|)
block|{
comment|// set up the permissions. This must be done differently on a secure cluster from an insecure
comment|// one
name|List
argument_list|<
name|ACL
argument_list|>
name|zkperms
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|zkperms
operator|.
name|add
argument_list|(
operator|new
name|ACL
argument_list|(
name|ZooDefs
operator|.
name|Perms
operator|.
name|ALL
argument_list|,
name|ZooDefs
operator|.
name|Ids
operator|.
name|AUTH_IDS
argument_list|)
argument_list|)
expr_stmt|;
name|zkperms
operator|.
name|add
argument_list|(
operator|new
name|ACL
argument_list|(
name|ZooDefs
operator|.
name|Perms
operator|.
name|READ
argument_list|,
name|ZooDefs
operator|.
name|Ids
operator|.
name|ANYONE_ID_UNSAFE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zkperms
operator|.
name|add
argument_list|(
operator|new
name|ACL
argument_list|(
name|ZooDefs
operator|.
name|Perms
operator|.
name|ALL
argument_list|,
name|ZooDefs
operator|.
name|Ids
operator|.
name|ANYONE_ID_UNSAFE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|client
operator|.
name|createPath
argument_list|(
name|zkPath
argument_list|,
literal|""
argument_list|,
name|zkperms
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|)
expr_stmt|;
return|return
name|zkPath
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Gets a zookeeper client, returns null if it cannot connect to zookeeper    **/
DECL|method|getZkClient (String clusterName, String user)
specifier|protected
name|ZKIntegration
name|getZkClient
parameter_list|(
name|String
name|clusterName
parameter_list|,
name|String
name|user
parameter_list|)
throws|throws
name|YarnException
block|{
name|String
name|registryQuorum
init|=
name|lookupZKQuorum
argument_list|()
decl_stmt|;
name|ZKIntegration
name|client
init|=
literal|null
decl_stmt|;
try|try
block|{
name|BlockingZKWatcher
name|watcher
init|=
operator|new
name|BlockingZKWatcher
argument_list|()
decl_stmt|;
name|client
operator|=
name|ZKIntegration
operator|.
name|newInstance
argument_list|(
name|registryQuorum
argument_list|,
name|user
argument_list|,
name|clusterName
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
name|watcher
argument_list|,
name|ZKIntegration
operator|.
name|SESSION_TIMEOUT
argument_list|)
expr_stmt|;
name|boolean
name|fromCache
init|=
name|client
operator|.
name|init
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fromCache
condition|)
block|{
name|watcher
operator|.
name|waitForZKConnection
argument_list|(
literal|2
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|client
operator|=
literal|null
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|"Interrupted - unable to connect to zookeeper quorum {}"
argument_list|,
name|registryQuorum
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to connect to zookeeper quorum {}"
argument_list|,
name|registryQuorum
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|client
return|;
block|}
comment|/**    * Keep this signature for backward compatibility with    * force=true by default.    */
annotation|@
name|Override
DECL|method|actionDestroy (String clustername)
specifier|public
name|int
name|actionDestroy
parameter_list|(
name|String
name|clustername
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|ActionDestroyArgs
name|destroyArgs
init|=
operator|new
name|ActionDestroyArgs
argument_list|()
decl_stmt|;
name|destroyArgs
operator|.
name|force
operator|=
literal|true
expr_stmt|;
return|return
name|actionDestroy
argument_list|(
name|clustername
argument_list|,
name|destroyArgs
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|actionDestroy (String clustername, ActionDestroyArgs destroyArgs)
specifier|public
name|int
name|actionDestroy
parameter_list|(
name|String
name|clustername
parameter_list|,
name|ActionDestroyArgs
name|destroyArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
comment|// verify that a live cluster isn't there
name|validateClusterName
argument_list|(
name|clustername
argument_list|)
expr_stmt|;
comment|//no=op, it is now mandatory.
name|verifyBindingsDefined
argument_list|()
expr_stmt|;
name|verifyNoLiveClusters
argument_list|(
name|clustername
argument_list|,
literal|"Destroy"
argument_list|)
expr_stmt|;
name|boolean
name|forceDestroy
init|=
name|destroyArgs
operator|.
name|force
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"actionDestroy({}, force={})"
argument_list|,
name|clustername
argument_list|,
name|forceDestroy
argument_list|)
expr_stmt|;
comment|// create the directory path
name|Path
name|clusterDirectory
init|=
name|sliderFileSystem
operator|.
name|buildClusterDirPath
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
comment|// delete the directory;
name|FileSystem
name|fs
init|=
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|boolean
name|exists
init|=
name|fs
operator|.
name|exists
argument_list|(
name|clusterDirectory
argument_list|)
decl_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Application Instance {} found at {}: destroying"
argument_list|,
name|clustername
argument_list|,
name|clusterDirectory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|forceDestroy
condition|)
block|{
comment|// fail the command if --force is not explicitly specified
throw|throw
operator|new
name|UsageException
argument_list|(
literal|"Destroy will permanently delete directories and registries. "
operator|+
literal|"Reissue this command with the --force option if you want to proceed."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|fs
operator|.
name|delete
argument_list|(
name|clusterDirectory
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Filesystem returned false from delete() operation"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|deleteZookeeperNode
argument_list|(
name|clustername
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to perform node cleanup in Zookeeper."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|clusterDirectory
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Failed to delete {}"
argument_list|,
name|clusterDirectory
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Application Instance {} already destroyed"
argument_list|,
name|clustername
argument_list|)
expr_stmt|;
block|}
comment|// rm the registry entry do not let this block the destroy operations
name|String
name|registryPath
init|=
name|SliderRegistryUtils
operator|.
name|registryPathForInstance
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
try|try
block|{
name|getRegistryOperations
argument_list|()
operator|.
name|delete
argument_list|(
name|registryPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Error deleting registry entry {}: {} "
argument_list|,
name|registryPath
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SliderException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Error binding to registry {} "
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|ApplicationReport
argument_list|>
name|instances
init|=
name|findAllLiveInstances
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
comment|// detect any race leading to cluster creation during the check/destroy process
comment|// and report a problem.
if|if
condition|(
operator|!
name|instances
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SliderException
argument_list|(
name|EXIT_APPLICATION_IN_USE
argument_list|,
name|clustername
operator|+
literal|": "
operator|+
name|E_DESTROY_CREATE_RACE_CONDITION
operator|+
literal|" :"
operator|+
name|instances
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
throw|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Destroyed cluster {}"
argument_list|,
name|clustername
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
annotation|@
name|Override
DECL|method|actionAmSuicide (String clustername, ActionAMSuicideArgs args)
specifier|public
name|int
name|actionAmSuicide
parameter_list|(
name|String
name|clustername
parameter_list|,
name|ActionAMSuicideArgs
name|args
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|SliderClusterOperations
name|clusterOperations
init|=
name|createClusterOperations
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
name|clusterOperations
operator|.
name|amSuicide
argument_list|(
name|args
operator|.
name|message
argument_list|,
name|args
operator|.
name|exitcode
argument_list|,
name|args
operator|.
name|waittime
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
annotation|@
name|Override
DECL|method|createClientProvider (String provider)
specifier|public
name|AbstractClientProvider
name|createClientProvider
parameter_list|(
name|String
name|provider
parameter_list|)
throws|throws
name|SliderException
block|{
name|SliderProviderFactory
name|factory
init|=
name|SliderProviderFactory
operator|.
name|createSliderProviderFactory
argument_list|(
name|provider
argument_list|)
decl_stmt|;
return|return
name|factory
operator|.
name|createClientProvider
argument_list|()
return|;
block|}
comment|/**    * Create the cluster -saving the arguments to a specification file first    * @param clustername cluster name    * @return the status code    * @throws YarnException Yarn problems    * @throws IOException other problems    * @throws BadCommandArgumentsException bad arguments.    */
DECL|method|actionCreate (String clustername, ActionCreateArgs createArgs)
specifier|public
name|int
name|actionCreate
parameter_list|(
name|String
name|clustername
parameter_list|,
name|ActionCreateArgs
name|createArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|actionBuild
argument_list|(
name|clustername
argument_list|,
name|createArgs
argument_list|)
expr_stmt|;
name|Path
name|clusterDirectory
init|=
name|sliderFileSystem
operator|.
name|buildClusterDirPath
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
name|AggregateConf
name|instanceDefinition
init|=
name|loadInstanceDefinitionUnresolved
argument_list|(
name|clustername
argument_list|,
name|clusterDirectory
argument_list|)
decl_stmt|;
try|try
block|{
name|checkForCredentials
argument_list|(
name|getConfig
argument_list|()
argument_list|,
name|instanceDefinition
operator|.
name|getAppConf
argument_list|()
argument_list|,
name|clustername
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
operator|.
name|delete
argument_list|(
name|clusterDirectory
argument_list|,
literal|true
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
name|startCluster
argument_list|(
name|clustername
argument_list|,
name|createArgs
argument_list|,
name|createArgs
operator|.
name|lifetime
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|actionUpgrade (String clustername, ActionUpgradeArgs upgradeArgs)
specifier|public
name|int
name|actionUpgrade
parameter_list|(
name|String
name|clustername
parameter_list|,
name|ActionUpgradeArgs
name|upgradeArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|File
name|template
init|=
name|upgradeArgs
operator|.
name|template
decl_stmt|;
name|File
name|resources
init|=
name|upgradeArgs
operator|.
name|resources
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|containers
init|=
name|upgradeArgs
operator|.
name|containers
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|components
init|=
name|upgradeArgs
operator|.
name|components
decl_stmt|;
comment|// For upgrade spec, let's be little more strict with validation. If either
comment|// --template or --resources is specified, then both needs to be specified.
comment|// Otherwise the internal app config and resources states of the app will be
comment|// unwantedly modified and the change will take effect to the running app
comment|// immediately.
name|require
argument_list|(
operator|!
operator|(
name|template
operator|!=
literal|null
operator|&&
name|resources
operator|==
literal|null
operator|)
argument_list|,
literal|"Option %s must be specified with option %s"
argument_list|,
name|Arguments
operator|.
name|ARG_RESOURCES
argument_list|,
name|Arguments
operator|.
name|ARG_TEMPLATE
argument_list|)
expr_stmt|;
name|require
argument_list|(
operator|!
operator|(
name|resources
operator|!=
literal|null
operator|&&
name|template
operator|==
literal|null
operator|)
argument_list|,
literal|"Option %s must be specified with option %s"
argument_list|,
name|Arguments
operator|.
name|ARG_TEMPLATE
argument_list|,
name|Arguments
operator|.
name|ARG_RESOURCES
argument_list|)
expr_stmt|;
comment|// For upgrade spec, both --template and --resources should be specified
comment|// and neither of --containers or --components should be used
if|if
condition|(
name|template
operator|!=
literal|null
operator|&&
name|resources
operator|!=
literal|null
condition|)
block|{
name|require
argument_list|(
name|CollectionUtils
operator|.
name|isEmpty
argument_list|(
name|containers
argument_list|)
argument_list|,
literal|"Option %s cannot be specified with %s or %s"
argument_list|,
name|Arguments
operator|.
name|ARG_CONTAINERS
argument_list|,
name|Arguments
operator|.
name|ARG_TEMPLATE
argument_list|,
name|Arguments
operator|.
name|ARG_RESOURCES
argument_list|)
expr_stmt|;
name|require
argument_list|(
name|CollectionUtils
operator|.
name|isEmpty
argument_list|(
name|components
argument_list|)
argument_list|,
literal|"Option %s cannot be specified with %s or %s"
argument_list|,
name|Arguments
operator|.
name|ARG_COMPONENTS
argument_list|,
name|Arguments
operator|.
name|ARG_TEMPLATE
argument_list|,
name|Arguments
operator|.
name|ARG_RESOURCES
argument_list|)
expr_stmt|;
comment|// not an error to try to upgrade a stopped cluster, just return success
comment|// code, appropriate log messages have already been dumped
if|if
condition|(
operator|!
name|isAppInRunningState
argument_list|(
name|clustername
argument_list|)
condition|)
block|{
return|return
name|EXIT_SUCCESS
return|;
block|}
comment|// Now initiate the upgrade spec flow
name|buildInstanceDefinition
argument_list|(
name|clustername
argument_list|,
name|upgradeArgs
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|SliderClusterOperations
name|clusterOperations
init|=
name|createClusterOperations
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
name|clusterOperations
operator|.
name|amSuicide
argument_list|(
literal|"AM restarted for application upgrade"
argument_list|,
literal|1
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
comment|// Since neither --template or --resources were specified, it is upgrade
comment|// containers flow. Here any one or both of --containers and --components
comment|// can be specified. If a container is specified with --containers option
comment|// and also belongs to a component type specified with --components, it will
comment|// be upgraded only once.
return|return
name|actionUpgradeContainers
argument_list|(
name|clustername
argument_list|,
name|upgradeArgs
argument_list|)
return|;
block|}
DECL|method|actionUpgradeContainers (String clustername, ActionUpgradeArgs upgradeArgs)
specifier|private
name|int
name|actionUpgradeContainers
parameter_list|(
name|String
name|clustername
parameter_list|,
name|ActionUpgradeArgs
name|upgradeArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|verifyBindingsDefined
argument_list|()
expr_stmt|;
name|validateClusterName
argument_list|(
name|clustername
argument_list|)
expr_stmt|;
name|int
name|waittime
init|=
name|upgradeArgs
operator|.
name|getWaittime
argument_list|()
decl_stmt|;
comment|// ignored for now
name|String
name|text
init|=
literal|"Upgrade containers"
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"actionUpgradeContainers({}, reason={}, wait={})"
argument_list|,
name|clustername
argument_list|,
name|text
argument_list|,
name|waittime
argument_list|)
expr_stmt|;
comment|// not an error to try to upgrade a stopped cluster, just return success
comment|// code, appropriate log messages have already been dumped
if|if
condition|(
operator|!
name|isAppInRunningState
argument_list|(
name|clustername
argument_list|)
condition|)
block|{
return|return
name|EXIT_SUCCESS
return|;
block|}
comment|// Create sets of containers and components to get rid of duplicates and
comment|// for quick lookup during checks below
name|Set
argument_list|<
name|String
argument_list|>
name|containers
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|upgradeArgs
operator|.
name|containers
operator|!=
literal|null
condition|)
block|{
name|containers
operator|.
name|addAll
argument_list|(
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|upgradeArgs
operator|.
name|containers
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|components
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|upgradeArgs
operator|.
name|components
operator|!=
literal|null
condition|)
block|{
name|components
operator|.
name|addAll
argument_list|(
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|upgradeArgs
operator|.
name|components
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// check validity of component names and running containers here
name|List
argument_list|<
name|ContainerInformation
argument_list|>
name|liveContainers
init|=
name|getContainers
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|validContainers
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|validComponents
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ContainerInformation
name|liveContainer
range|:
name|liveContainers
control|)
block|{
name|boolean
name|allContainersAndComponentsAccountedFor
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|CollectionUtils
operator|.
name|isNotEmpty
argument_list|(
name|containers
argument_list|)
condition|)
block|{
if|if
condition|(
name|containers
operator|.
name|contains
argument_list|(
name|liveContainer
operator|.
name|containerId
argument_list|)
condition|)
block|{
name|containers
operator|.
name|remove
argument_list|(
name|liveContainer
operator|.
name|containerId
argument_list|)
expr_stmt|;
name|validContainers
operator|.
name|add
argument_list|(
name|liveContainer
operator|.
name|containerId
argument_list|)
expr_stmt|;
block|}
name|allContainersAndComponentsAccountedFor
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|CollectionUtils
operator|.
name|isNotEmpty
argument_list|(
name|components
argument_list|)
condition|)
block|{
if|if
condition|(
name|components
operator|.
name|contains
argument_list|(
name|liveContainer
operator|.
name|component
argument_list|)
condition|)
block|{
name|components
operator|.
name|remove
argument_list|(
name|liveContainer
operator|.
name|component
argument_list|)
expr_stmt|;
name|validComponents
operator|.
name|add
argument_list|(
name|liveContainer
operator|.
name|component
argument_list|)
expr_stmt|;
block|}
name|allContainersAndComponentsAccountedFor
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|allContainersAndComponentsAccountedFor
condition|)
block|{
break|break;
block|}
block|}
comment|// If any item remains in containers or components then they are invalid.
comment|// Log warning for them and proceed.
if|if
condition|(
name|CollectionUtils
operator|.
name|isNotEmpty
argument_list|(
name|containers
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Invalid set of containers provided {}"
argument_list|,
name|containers
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CollectionUtils
operator|.
name|isNotEmpty
argument_list|(
name|components
argument_list|)
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Invalid set of components provided {}"
argument_list|,
name|components
argument_list|)
expr_stmt|;
block|}
comment|// If not a single valid container or component is specified do not proceed
if|if
condition|(
name|CollectionUtils
operator|.
name|isEmpty
argument_list|(
name|validContainers
argument_list|)
operator|&&
name|CollectionUtils
operator|.
name|isEmpty
argument_list|(
name|validComponents
argument_list|)
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Not a single valid container or component specified. Nothing to do."
argument_list|)
expr_stmt|;
return|return
name|EXIT_NOT_FOUND
return|;
block|}
name|SliderClusterProtocol
name|appMaster
init|=
name|connect
argument_list|(
name|findInstance
argument_list|(
name|clustername
argument_list|)
argument_list|)
decl_stmt|;
name|Messages
operator|.
name|UpgradeContainersRequestProto
name|r
init|=
name|Messages
operator|.
name|UpgradeContainersRequestProto
operator|.
name|newBuilder
argument_list|()
operator|.
name|setMessage
argument_list|(
name|text
argument_list|)
operator|.
name|addAllContainer
argument_list|(
name|validContainers
argument_list|)
operator|.
name|addAllComponent
argument_list|(
name|validComponents
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|appMaster
operator|.
name|upgradeContainers
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Cluster upgrade issued for -"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CollectionUtils
operator|.
name|isNotEmpty
argument_list|(
name|validContainers
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|" Containers (total {}): {}"
argument_list|,
name|validContainers
operator|.
name|size
argument_list|()
argument_list|,
name|validContainers
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CollectionUtils
operator|.
name|isNotEmpty
argument_list|(
name|validComponents
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|" Components (total {}): {}"
argument_list|,
name|validComponents
operator|.
name|size
argument_list|()
argument_list|,
name|validComponents
argument_list|)
expr_stmt|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
comment|// returns true if and only if app is in RUNNING state
DECL|method|isAppInRunningState (String clustername)
specifier|private
name|boolean
name|isAppInRunningState
parameter_list|(
name|String
name|clustername
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
comment|// is this actually a known cluster?
name|sliderFileSystem
operator|.
name|locateInstanceDefinition
argument_list|(
name|clustername
argument_list|)
expr_stmt|;
name|ApplicationReport
name|app
init|=
name|findInstance
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
if|if
condition|(
name|app
operator|==
literal|null
condition|)
block|{
comment|// exit early
name|log
operator|.
name|info
argument_list|(
literal|"Cluster {} not running"
argument_list|,
name|clustername
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"App to upgrade was found: {}:\n{}"
argument_list|,
name|clustername
argument_list|,
operator|new
name|OnDemandReportStringifier
argument_list|(
name|app
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|app
operator|.
name|getYarnApplicationState
argument_list|()
operator|.
name|ordinal
argument_list|()
operator|>=
name|YarnApplicationState
operator|.
name|FINISHED
operator|.
name|ordinal
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Cluster {} is in a terminated state {}. Use command '{}' instead."
argument_list|,
name|clustername
argument_list|,
name|app
operator|.
name|getYarnApplicationState
argument_list|()
argument_list|,
name|ACTION_UPDATE
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// IPC request to upgrade containers is possible if the app is running.
if|if
condition|(
name|app
operator|.
name|getYarnApplicationState
argument_list|()
operator|.
name|ordinal
argument_list|()
operator|<
name|YarnApplicationState
operator|.
name|RUNNING
operator|.
name|ordinal
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Cluster {} is in a pre-running state {}. To upgrade it needs "
operator|+
literal|"to be RUNNING."
argument_list|,
name|clustername
argument_list|,
name|app
operator|.
name|getYarnApplicationState
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|checkForCredentials (Configuration conf, ConfTree tree, String clusterName)
specifier|protected
specifier|static
name|void
name|checkForCredentials
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|ConfTree
name|tree
parameter_list|,
name|String
name|clusterName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|tree
operator|.
name|credentials
operator|==
literal|null
operator|||
name|tree
operator|.
name|credentials
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"No credentials requested"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Console
name|console
init|=
name|System
operator|.
name|console
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|cred
range|:
name|tree
operator|.
name|credentials
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|provider
init|=
name|cred
operator|.
name|getKey
argument_list|()
operator|.
name|replaceAll
argument_list|(
name|Pattern
operator|.
name|quote
argument_list|(
literal|"${CLUSTER_NAME}"
argument_list|)
argument_list|,
name|clusterName
argument_list|)
operator|.
name|replaceAll
argument_list|(
name|Pattern
operator|.
name|quote
argument_list|(
literal|"${CLUSTER}"
argument_list|)
argument_list|,
name|clusterName
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|aliases
init|=
name|cred
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|aliases
operator|==
literal|null
operator|||
name|aliases
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
continue|continue;
block|}
name|Configuration
name|c
init|=
operator|new
name|Configuration
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|c
operator|.
name|set
argument_list|(
name|CredentialProviderFactory
operator|.
name|CREDENTIAL_PROVIDER_PATH
argument_list|,
name|provider
argument_list|)
expr_stmt|;
name|CredentialProvider
name|credentialProvider
init|=
name|CredentialProviderFactory
operator|.
name|getProviders
argument_list|(
name|c
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|existingAliases
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|credentialProvider
operator|.
name|getAliases
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|alias
range|:
name|aliases
control|)
block|{
if|if
condition|(
name|existingAliases
operator|.
name|contains
argument_list|(
name|alias
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Credentials for "
operator|+
name|alias
operator|+
literal|" found in "
operator|+
name|provider
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|console
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to input password for "
operator|+
name|alias
operator|+
literal|" because System.console() is null; provider "
operator|+
name|provider
operator|+
literal|" must be populated manually"
argument_list|)
throw|;
block|}
name|char
index|[]
name|pass
init|=
name|readPassword
argument_list|(
name|alias
argument_list|,
name|console
argument_list|)
decl_stmt|;
name|credentialProvider
operator|.
name|createCredentialEntry
argument_list|(
name|alias
argument_list|,
name|pass
argument_list|)
expr_stmt|;
name|credentialProvider
operator|.
name|flush
argument_list|()
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|pass
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|readOnePassword (String alias)
specifier|private
specifier|static
name|char
index|[]
name|readOnePassword
parameter_list|(
name|String
name|alias
parameter_list|)
throws|throws
name|IOException
block|{
name|Console
name|console
init|=
name|System
operator|.
name|console
argument_list|()
decl_stmt|;
if|if
condition|(
name|console
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to input password for "
operator|+
name|alias
operator|+
literal|" because System.console() is null"
argument_list|)
throw|;
block|}
return|return
name|readPassword
argument_list|(
name|alias
argument_list|,
name|console
argument_list|)
return|;
block|}
DECL|method|readPassword (String alias, Console console)
specifier|private
specifier|static
name|char
index|[]
name|readPassword
parameter_list|(
name|String
name|alias
parameter_list|,
name|Console
name|console
parameter_list|)
throws|throws
name|IOException
block|{
name|char
index|[]
name|cred
init|=
literal|null
decl_stmt|;
name|boolean
name|noMatch
decl_stmt|;
do|do
block|{
name|console
operator|.
name|printf
argument_list|(
literal|"%s %s: \n"
argument_list|,
name|PASSWORD_PROMPT
argument_list|,
name|alias
argument_list|)
expr_stmt|;
name|char
index|[]
name|newPassword1
init|=
name|console
operator|.
name|readPassword
argument_list|()
decl_stmt|;
name|console
operator|.
name|printf
argument_list|(
literal|"%s %s again: \n"
argument_list|,
name|PASSWORD_PROMPT
argument_list|,
name|alias
argument_list|)
expr_stmt|;
name|char
index|[]
name|newPassword2
init|=
name|console
operator|.
name|readPassword
argument_list|()
decl_stmt|;
name|noMatch
operator|=
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|newPassword1
argument_list|,
name|newPassword2
argument_list|)
expr_stmt|;
if|if
condition|(
name|noMatch
condition|)
block|{
if|if
condition|(
name|newPassword1
operator|!=
literal|null
condition|)
name|Arrays
operator|.
name|fill
argument_list|(
name|newPassword1
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Passwords don't match. Try again."
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cred
operator|=
name|newPassword1
expr_stmt|;
block|}
if|if
condition|(
name|newPassword2
operator|!=
literal|null
condition|)
name|Arrays
operator|.
name|fill
argument_list|(
name|newPassword2
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|noMatch
condition|)
do|;
if|if
condition|(
name|cred
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not read credentials for "
operator|+
name|alias
operator|+
literal|" from stdin"
argument_list|)
throw|;
return|return
name|cred
return|;
block|}
annotation|@
name|Override
DECL|method|actionBuild (String clustername, AbstractClusterBuildingActionArgs buildInfo)
specifier|public
name|int
name|actionBuild
parameter_list|(
name|String
name|clustername
parameter_list|,
name|AbstractClusterBuildingActionArgs
name|buildInfo
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|buildInstanceDefinition
argument_list|(
name|clustername
argument_list|,
name|buildInfo
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
annotation|@
name|Override
DECL|method|actionKeytab (ActionKeytabArgs keytabInfo)
specifier|public
name|int
name|actionKeytab
parameter_list|(
name|ActionKeytabArgs
name|keytabInfo
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
if|if
condition|(
name|keytabInfo
operator|.
name|install
condition|)
block|{
return|return
name|actionInstallKeytab
argument_list|(
name|keytabInfo
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|keytabInfo
operator|.
name|delete
condition|)
block|{
return|return
name|actionDeleteKeytab
argument_list|(
name|keytabInfo
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|keytabInfo
operator|.
name|list
condition|)
block|{
return|return
name|actionListKeytab
argument_list|(
name|keytabInfo
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"Keytab option specified not found.\n"
operator|+
name|CommonArgs
operator|.
name|usage
argument_list|(
name|serviceArgs
argument_list|,
name|ACTION_KEYTAB
argument_list|)
argument_list|)
throw|;
block|}
block|}
DECL|method|actionListKeytab (ActionKeytabArgs keytabInfo)
specifier|private
name|int
name|actionListKeytab
parameter_list|(
name|ActionKeytabArgs
name|keytabInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|folder
init|=
name|keytabInfo
operator|.
name|folder
operator|!=
literal|null
condition|?
name|keytabInfo
operator|.
name|folder
else|:
name|StringUtils
operator|.
name|EMPTY
decl_stmt|;
name|Path
name|keytabPath
init|=
name|sliderFileSystem
operator|.
name|buildKeytabInstallationDirPath
argument_list|(
name|folder
argument_list|)
decl_stmt|;
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|files
init|=
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
operator|.
name|listFiles
argument_list|(
name|keytabPath
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Keytabs:"
argument_list|)
expr_stmt|;
while|while
condition|(
name|files
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"\t"
operator|+
name|files
operator|.
name|next
argument_list|()
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
DECL|method|actionDeleteKeytab (ActionKeytabArgs keytabInfo)
specifier|private
name|int
name|actionDeleteKeytab
parameter_list|(
name|ActionKeytabArgs
name|keytabInfo
parameter_list|)
throws|throws
name|BadCommandArgumentsException
throws|,
name|IOException
block|{
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|keytabInfo
operator|.
name|folder
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"A valid destination keytab sub-folder name is required (e.g. 'security').\n"
operator|+
name|CommonArgs
operator|.
name|usage
argument_list|(
name|serviceArgs
argument_list|,
name|ACTION_KEYTAB
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|keytabInfo
operator|.
name|keytab
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"A keytab name is required."
argument_list|)
throw|;
block|}
name|Path
name|pkgPath
init|=
name|sliderFileSystem
operator|.
name|buildKeytabInstallationDirPath
argument_list|(
name|keytabInfo
operator|.
name|folder
argument_list|)
decl_stmt|;
name|Path
name|fileInFs
init|=
operator|new
name|Path
argument_list|(
name|pkgPath
argument_list|,
name|keytabInfo
operator|.
name|keytab
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Deleting keytab {}"
argument_list|,
name|fileInFs
argument_list|)
expr_stmt|;
name|FileSystem
name|sfs
init|=
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|require
argument_list|(
name|sfs
operator|.
name|exists
argument_list|(
name|fileInFs
argument_list|)
argument_list|,
literal|"No keytab to delete found at %s"
argument_list|,
name|fileInFs
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
name|sfs
operator|.
name|delete
argument_list|(
name|fileInFs
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
DECL|method|actionInstallKeytab (ActionKeytabArgs keytabInfo)
specifier|private
name|int
name|actionInstallKeytab
parameter_list|(
name|ActionKeytabArgs
name|keytabInfo
parameter_list|)
throws|throws
name|BadCommandArgumentsException
throws|,
name|IOException
block|{
name|Path
name|srcFile
init|=
literal|null
decl_stmt|;
name|require
argument_list|(
name|isSet
argument_list|(
name|keytabInfo
operator|.
name|folder
argument_list|)
argument_list|,
literal|"A valid destination keytab sub-folder name is required (e.g. 'security').\n"
operator|+
name|CommonArgs
operator|.
name|usage
argument_list|(
name|serviceArgs
argument_list|,
name|ACTION_KEYTAB
argument_list|)
argument_list|)
expr_stmt|;
name|requireArgumentSet
argument_list|(
name|Arguments
operator|.
name|ARG_KEYTAB
argument_list|,
name|keytabInfo
operator|.
name|keytab
argument_list|)
expr_stmt|;
name|File
name|keytabFile
init|=
operator|new
name|File
argument_list|(
name|keytabInfo
operator|.
name|keytab
argument_list|)
decl_stmt|;
name|require
argument_list|(
name|keytabFile
operator|.
name|isFile
argument_list|()
argument_list|,
literal|"Unable to access supplied keytab file at %s"
argument_list|,
name|keytabFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|srcFile
operator|=
operator|new
name|Path
argument_list|(
name|keytabFile
operator|.
name|toURI
argument_list|()
argument_list|)
expr_stmt|;
name|Path
name|pkgPath
init|=
name|sliderFileSystem
operator|.
name|buildKeytabInstallationDirPath
argument_list|(
name|keytabInfo
operator|.
name|folder
argument_list|)
decl_stmt|;
name|FileSystem
name|sfs
init|=
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|sfs
operator|.
name|mkdirs
argument_list|(
name|pkgPath
argument_list|)
expr_stmt|;
name|sfs
operator|.
name|setPermission
argument_list|(
name|pkgPath
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|FsAction
operator|.
name|ALL
argument_list|,
name|FsAction
operator|.
name|NONE
argument_list|,
name|FsAction
operator|.
name|NONE
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|fileInFs
init|=
operator|new
name|Path
argument_list|(
name|pkgPath
argument_list|,
name|srcFile
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Installing keytab {} at {} and overwrite is {}."
argument_list|,
name|srcFile
argument_list|,
name|fileInFs
argument_list|,
name|keytabInfo
operator|.
name|overwrite
argument_list|)
expr_stmt|;
name|require
argument_list|(
operator|!
operator|(
name|sfs
operator|.
name|exists
argument_list|(
name|fileInFs
argument_list|)
operator|&&
operator|!
name|keytabInfo
operator|.
name|overwrite
operator|)
argument_list|,
literal|"Keytab exists at %s. Use --overwrite to overwrite."
argument_list|,
name|fileInFs
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
name|sfs
operator|.
name|copyFromLocalFile
argument_list|(
literal|false
argument_list|,
name|keytabInfo
operator|.
name|overwrite
argument_list|,
name|srcFile
argument_list|,
name|fileInFs
argument_list|)
expr_stmt|;
name|sfs
operator|.
name|setPermission
argument_list|(
name|fileInFs
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|FsAction
operator|.
name|READ_WRITE
argument_list|,
name|FsAction
operator|.
name|NONE
argument_list|,
name|FsAction
operator|.
name|NONE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
annotation|@
name|Override
DECL|method|actionInstallKeytab (ActionInstallKeytabArgs installKeytabInfo)
specifier|public
name|int
name|actionInstallKeytab
parameter_list|(
name|ActionInstallKeytabArgs
name|installKeytabInfo
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"The 'install-keytab' option has been deprecated.  Please use 'keytab --install'."
argument_list|)
expr_stmt|;
return|return
name|actionKeytab
argument_list|(
operator|new
name|ActionKeytabArgs
argument_list|(
name|installKeytabInfo
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|actionInstallPkg (ActionInstallPackageArgs installPkgInfo)
specifier|public
name|int
name|actionInstallPkg
parameter_list|(
name|ActionInstallPackageArgs
name|installPkgInfo
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"The "
operator|+
name|ACTION_INSTALL_PACKAGE
operator|+
literal|" option has been deprecated. Please use '"
operator|+
name|ACTION_PACKAGE
operator|+
literal|" "
operator|+
name|ClientArgs
operator|.
name|ARG_INSTALL
operator|+
literal|"'."
argument_list|)
expr_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|installPkgInfo
operator|.
name|name
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
name|E_INVALID_APPLICATION_TYPE_NAME
operator|+
literal|"\n"
operator|+
name|CommonArgs
operator|.
name|usage
argument_list|(
name|serviceArgs
argument_list|,
name|ACTION_INSTALL_PACKAGE
argument_list|)
argument_list|)
throw|;
block|}
name|Path
name|srcFile
init|=
name|extractPackagePath
argument_list|(
name|installPkgInfo
operator|.
name|packageURI
argument_list|)
decl_stmt|;
comment|// Do not provide new options to install-package command as it is in
comment|// deprecated mode. So version is kept null here. Use package --install.
name|Path
name|pkgPath
init|=
name|sliderFileSystem
operator|.
name|buildPackageDirPath
argument_list|(
name|installPkgInfo
operator|.
name|name
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|FileSystem
name|sfs
init|=
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|sfs
operator|.
name|mkdirs
argument_list|(
name|pkgPath
argument_list|)
expr_stmt|;
name|Path
name|fileInFs
init|=
operator|new
name|Path
argument_list|(
name|pkgPath
argument_list|,
name|srcFile
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Installing package {} at {} and overwrite is {}."
argument_list|,
name|srcFile
argument_list|,
name|fileInFs
argument_list|,
name|installPkgInfo
operator|.
name|replacePkg
argument_list|)
expr_stmt|;
name|require
argument_list|(
operator|!
operator|(
name|sfs
operator|.
name|exists
argument_list|(
name|fileInFs
argument_list|)
operator|&&
operator|!
name|installPkgInfo
operator|.
name|replacePkg
operator|)
argument_list|,
literal|"Package exists at %s. : %s"
argument_list|,
name|fileInFs
operator|.
name|toUri
argument_list|()
argument_list|,
name|E_USE_REPLACEPKG_TO_OVERWRITE
argument_list|)
expr_stmt|;
name|sfs
operator|.
name|copyFromLocalFile
argument_list|(
literal|false
argument_list|,
name|installPkgInfo
operator|.
name|replacePkg
argument_list|,
name|srcFile
argument_list|,
name|fileInFs
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
annotation|@
name|Override
DECL|method|actionResource (ActionResourceArgs resourceInfo)
specifier|public
name|int
name|actionResource
parameter_list|(
name|ActionResourceArgs
name|resourceInfo
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
if|if
condition|(
name|resourceInfo
operator|.
name|help
condition|)
block|{
name|actionHelp
argument_list|(
name|ACTION_RESOURCE
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
elseif|else
if|if
condition|(
name|resourceInfo
operator|.
name|install
condition|)
block|{
return|return
name|actionInstallResource
argument_list|(
name|resourceInfo
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|resourceInfo
operator|.
name|delete
condition|)
block|{
return|return
name|actionDeleteResource
argument_list|(
name|resourceInfo
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|resourceInfo
operator|.
name|list
condition|)
block|{
return|return
name|actionListResource
argument_list|(
name|resourceInfo
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"Resource option specified not found.\n"
operator|+
name|CommonArgs
operator|.
name|usage
argument_list|(
name|serviceArgs
argument_list|,
name|ACTION_RESOURCE
argument_list|)
argument_list|)
throw|;
block|}
block|}
DECL|method|actionListResource (ActionResourceArgs resourceInfo)
specifier|private
name|int
name|actionListResource
parameter_list|(
name|ActionResourceArgs
name|resourceInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|folder
init|=
name|resourceInfo
operator|.
name|folder
operator|!=
literal|null
condition|?
name|resourceInfo
operator|.
name|folder
else|:
name|StringUtils
operator|.
name|EMPTY
decl_stmt|;
name|Path
name|path
init|=
name|sliderFileSystem
operator|.
name|buildResourcePath
argument_list|(
name|folder
argument_list|)
decl_stmt|;
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|files
init|=
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
operator|.
name|listFiles
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Resources:"
argument_list|)
expr_stmt|;
while|while
condition|(
name|files
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"\t"
operator|+
name|files
operator|.
name|next
argument_list|()
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
DECL|method|actionDeleteResource (ActionResourceArgs resourceInfo)
specifier|private
name|int
name|actionDeleteResource
parameter_list|(
name|ActionResourceArgs
name|resourceInfo
parameter_list|)
throws|throws
name|BadCommandArgumentsException
throws|,
name|IOException
block|{
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|resourceInfo
operator|.
name|resource
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"A file name is required."
argument_list|)
throw|;
block|}
name|Path
name|fileInFs
decl_stmt|;
if|if
condition|(
name|resourceInfo
operator|.
name|folder
operator|==
literal|null
condition|)
block|{
name|fileInFs
operator|=
name|sliderFileSystem
operator|.
name|buildResourcePath
argument_list|(
name|resourceInfo
operator|.
name|resource
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fileInFs
operator|=
name|sliderFileSystem
operator|.
name|buildResourcePath
argument_list|(
name|resourceInfo
operator|.
name|folder
argument_list|,
name|resourceInfo
operator|.
name|resource
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Deleting resource {}"
argument_list|,
name|fileInFs
argument_list|)
expr_stmt|;
name|FileSystem
name|sfs
init|=
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|require
argument_list|(
name|sfs
operator|.
name|exists
argument_list|(
name|fileInFs
argument_list|)
argument_list|,
literal|"No resource to delete found at %s"
argument_list|,
name|fileInFs
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
name|sfs
operator|.
name|delete
argument_list|(
name|fileInFs
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
DECL|method|actionInstallResource (ActionResourceArgs resourceInfo)
specifier|private
name|int
name|actionInstallResource
parameter_list|(
name|ActionResourceArgs
name|resourceInfo
parameter_list|)
throws|throws
name|BadCommandArgumentsException
throws|,
name|IOException
block|{
name|Path
name|srcFile
init|=
literal|null
decl_stmt|;
name|String
name|folder
init|=
name|resourceInfo
operator|.
name|folder
operator|!=
literal|null
condition|?
name|resourceInfo
operator|.
name|folder
else|:
name|StringUtils
operator|.
name|EMPTY
decl_stmt|;
name|requireArgumentSet
argument_list|(
name|Arguments
operator|.
name|ARG_RESOURCE
argument_list|,
name|resourceInfo
operator|.
name|resource
argument_list|)
expr_stmt|;
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|resourceInfo
operator|.
name|resource
argument_list|)
decl_stmt|;
name|require
argument_list|(
name|file
operator|.
name|isFile
argument_list|()
operator|||
name|file
operator|.
name|isDirectory
argument_list|()
argument_list|,
literal|"Unable to access supplied file at %s"
argument_list|,
name|file
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|File
index|[]
name|files
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|files
operator|=
name|file
operator|.
name|listFiles
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|files
operator|=
operator|new
name|File
index|[]
block|{
name|file
block|}
expr_stmt|;
block|}
name|Path
name|pkgPath
init|=
name|sliderFileSystem
operator|.
name|buildResourcePath
argument_list|(
name|folder
argument_list|)
decl_stmt|;
name|FileSystem
name|sfs
init|=
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|sfs
operator|.
name|exists
argument_list|(
name|pkgPath
argument_list|)
condition|)
block|{
name|sfs
operator|.
name|mkdirs
argument_list|(
name|pkgPath
argument_list|)
expr_stmt|;
name|sfs
operator|.
name|setPermission
argument_list|(
name|pkgPath
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|FsAction
operator|.
name|ALL
argument_list|,
name|FsAction
operator|.
name|NONE
argument_list|,
name|FsAction
operator|.
name|NONE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|require
argument_list|(
name|sfs
operator|.
name|isDirectory
argument_list|(
name|pkgPath
argument_list|)
argument_list|,
literal|"Specified folder %s exists and is "
operator|+
literal|"not a directory"
argument_list|,
name|folder
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|File
name|f
range|:
name|files
control|)
block|{
name|srcFile
operator|=
operator|new
name|Path
argument_list|(
name|f
operator|.
name|toURI
argument_list|()
argument_list|)
expr_stmt|;
name|Path
name|fileInFs
init|=
operator|new
name|Path
argument_list|(
name|pkgPath
argument_list|,
name|srcFile
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Installing file {} at {} and overwrite is {}."
argument_list|,
name|srcFile
argument_list|,
name|fileInFs
argument_list|,
name|resourceInfo
operator|.
name|overwrite
argument_list|)
expr_stmt|;
name|require
argument_list|(
operator|!
operator|(
name|sfs
operator|.
name|exists
argument_list|(
name|fileInFs
argument_list|)
operator|&&
operator|!
name|resourceInfo
operator|.
name|overwrite
operator|)
argument_list|,
literal|"File exists at %s. Use --overwrite to overwrite."
argument_list|,
name|fileInFs
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
name|sfs
operator|.
name|copyFromLocalFile
argument_list|(
literal|false
argument_list|,
name|resourceInfo
operator|.
name|overwrite
argument_list|,
name|srcFile
argument_list|,
name|fileInFs
argument_list|)
expr_stmt|;
name|sfs
operator|.
name|setPermission
argument_list|(
name|fileInFs
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|FsAction
operator|.
name|READ_WRITE
argument_list|,
name|FsAction
operator|.
name|NONE
argument_list|,
name|FsAction
operator|.
name|NONE
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
annotation|@
name|Override
DECL|method|actionClient (ActionClientArgs clientInfo)
specifier|public
name|int
name|actionClient
parameter_list|(
name|ActionClientArgs
name|clientInfo
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
if|if
condition|(
name|clientInfo
operator|.
name|install
condition|)
block|{
return|return
name|doClientInstall
argument_list|(
name|clientInfo
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|clientInfo
operator|.
name|getCertStore
condition|)
block|{
return|return
name|doCertificateStoreRetrieval
argument_list|(
name|clientInfo
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"Only install, keystore, and truststore commands are supported for the client.\n"
operator|+
name|CommonArgs
operator|.
name|usage
argument_list|(
name|serviceArgs
argument_list|,
name|ACTION_CLIENT
argument_list|)
argument_list|)
throw|;
block|}
block|}
DECL|method|doCertificateStoreRetrieval (ActionClientArgs clientInfo)
specifier|private
name|int
name|doCertificateStoreRetrieval
parameter_list|(
name|ActionClientArgs
name|clientInfo
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
if|if
condition|(
name|clientInfo
operator|.
name|keystore
operator|!=
literal|null
operator|&&
name|clientInfo
operator|.
name|truststore
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"Only one of either keystore or truststore can be retrieved at one time.  "
operator|+
literal|"Retrieval of both should be done separately\n"
operator|+
name|CommonArgs
operator|.
name|usage
argument_list|(
name|serviceArgs
argument_list|,
name|ACTION_CLIENT
argument_list|)
argument_list|)
throw|;
block|}
name|requireArgumentSet
argument_list|(
name|Arguments
operator|.
name|ARG_NAME
argument_list|,
name|clientInfo
operator|.
name|name
argument_list|)
expr_stmt|;
name|File
name|storeFile
init|=
literal|null
decl_stmt|;
name|SecurityStore
operator|.
name|StoreType
name|type
decl_stmt|;
if|if
condition|(
name|clientInfo
operator|.
name|keystore
operator|!=
literal|null
condition|)
block|{
name|storeFile
operator|=
name|clientInfo
operator|.
name|keystore
expr_stmt|;
name|type
operator|=
name|SecurityStore
operator|.
name|StoreType
operator|.
name|keystore
expr_stmt|;
block|}
else|else
block|{
name|storeFile
operator|=
name|clientInfo
operator|.
name|truststore
expr_stmt|;
name|type
operator|=
name|SecurityStore
operator|.
name|StoreType
operator|.
name|truststore
expr_stmt|;
block|}
name|require
argument_list|(
operator|!
name|storeFile
operator|.
name|exists
argument_list|()
argument_list|,
literal|"File %s already exists.  Please remove that file or select a different file name."
argument_list|,
name|storeFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|hostname
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|SecurityStore
operator|.
name|StoreType
operator|.
name|keystore
condition|)
block|{
name|hostname
operator|=
name|clientInfo
operator|.
name|hostname
expr_stmt|;
if|if
condition|(
name|hostname
operator|==
literal|null
condition|)
block|{
name|hostname
operator|=
name|InetAddress
operator|.
name|getLocalHost
argument_list|()
operator|.
name|getCanonicalHostName
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"No hostname specified via command line. Using {}"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
block|}
block|}
name|String
name|password
init|=
name|clientInfo
operator|.
name|password
decl_stmt|;
if|if
condition|(
name|password
operator|==
literal|null
condition|)
block|{
name|String
name|provider
init|=
name|clientInfo
operator|.
name|provider
decl_stmt|;
name|String
name|alias
init|=
name|clientInfo
operator|.
name|alias
decl_stmt|;
if|if
condition|(
name|provider
operator|!=
literal|null
operator|&&
name|alias
operator|!=
literal|null
condition|)
block|{
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|(
name|getConfig
argument_list|()
argument_list|)
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|CredentialProviderFactory
operator|.
name|CREDENTIAL_PROVIDER_PATH
argument_list|,
name|provider
argument_list|)
expr_stmt|;
name|char
index|[]
name|chars
init|=
name|conf
operator|.
name|getPassword
argument_list|(
name|alias
argument_list|)
decl_stmt|;
if|if
condition|(
name|chars
operator|==
literal|null
condition|)
block|{
name|CredentialProvider
name|credentialProvider
init|=
name|CredentialProviderFactory
operator|.
name|getProviders
argument_list|(
name|conf
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|chars
operator|=
name|readOnePassword
argument_list|(
name|alias
argument_list|)
expr_stmt|;
name|credentialProvider
operator|.
name|createCredentialEntry
argument_list|(
name|alias
argument_list|,
name|chars
argument_list|)
expr_stmt|;
name|credentialProvider
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
name|password
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|chars
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|chars
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"No password and no provider/alias pair were provided, "
operator|+
literal|"prompting for password"
argument_list|)
expr_stmt|;
comment|// get a password
name|password
operator|=
name|String
operator|.
name|valueOf
argument_list|(
name|readOnePassword
argument_list|(
name|type
operator|.
name|name
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|byte
index|[]
name|keystore
init|=
name|createClusterOperations
argument_list|(
name|clientInfo
operator|.
name|name
argument_list|)
operator|.
name|getClientCertificateStore
argument_list|(
name|hostname
argument_list|,
literal|"client"
argument_list|,
name|password
argument_list|,
name|type
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
comment|// persist to file
name|FileOutputStream
name|storeFileOutputStream
init|=
literal|null
decl_stmt|;
try|try
block|{
name|storeFileOutputStream
operator|=
operator|new
name|FileOutputStream
argument_list|(
name|storeFile
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|write
argument_list|(
name|keystore
argument_list|,
name|storeFileOutputStream
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unable to persist to file {}"
argument_list|,
name|storeFile
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|storeFileOutputStream
operator|!=
literal|null
condition|)
block|{
name|storeFileOutputStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
DECL|method|doClientInstall (ActionClientArgs clientInfo)
specifier|private
name|int
name|doClientInstall
parameter_list|(
name|ActionClientArgs
name|clientInfo
parameter_list|)
throws|throws
name|IOException
throws|,
name|SliderException
block|{
name|require
argument_list|(
name|clientInfo
operator|.
name|installLocation
operator|!=
literal|null
argument_list|,
name|E_INVALID_INSTALL_LOCATION
operator|+
literal|"\n"
operator|+
name|CommonArgs
operator|.
name|usage
argument_list|(
name|serviceArgs
argument_list|,
name|ACTION_CLIENT
argument_list|)
argument_list|)
expr_stmt|;
name|require
argument_list|(
name|clientInfo
operator|.
name|installLocation
operator|.
name|exists
argument_list|()
argument_list|,
name|E_INSTALL_PATH_DOES_NOT_EXIST
operator|+
literal|": "
operator|+
name|clientInfo
operator|.
name|installLocation
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|require
argument_list|(
name|clientInfo
operator|.
name|installLocation
operator|.
name|isDirectory
argument_list|()
argument_list|,
name|E_INVALID_INSTALL_PATH
operator|+
literal|": "
operator|+
name|clientInfo
operator|.
name|installLocation
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|File
name|pkgFile
decl_stmt|;
name|File
name|tmpDir
init|=
literal|null
decl_stmt|;
name|require
argument_list|(
name|isSet
argument_list|(
name|clientInfo
operator|.
name|packageURI
argument_list|)
operator|||
name|isSet
argument_list|(
name|clientInfo
operator|.
name|name
argument_list|)
argument_list|,
name|E_INVALID_APPLICATION_PACKAGE_LOCATION
argument_list|)
expr_stmt|;
if|if
condition|(
name|isSet
argument_list|(
name|clientInfo
operator|.
name|packageURI
argument_list|)
condition|)
block|{
name|pkgFile
operator|=
operator|new
name|File
argument_list|(
name|clientInfo
operator|.
name|packageURI
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Path
name|appDirPath
init|=
name|sliderFileSystem
operator|.
name|buildAppDefDirPath
argument_list|(
name|clientInfo
operator|.
name|name
argument_list|)
decl_stmt|;
name|Path
name|appDefPath
init|=
operator|new
name|Path
argument_list|(
name|appDirPath
argument_list|,
name|SliderKeys
operator|.
name|DEFAULT_APP_PKG
argument_list|)
decl_stmt|;
name|require
argument_list|(
name|sliderFileSystem
operator|.
name|isFile
argument_list|(
name|appDefPath
argument_list|)
argument_list|,
name|E_INVALID_APPLICATION_PACKAGE_LOCATION
argument_list|)
expr_stmt|;
name|tmpDir
operator|=
name|Files
operator|.
name|createTempDir
argument_list|()
expr_stmt|;
name|pkgFile
operator|=
operator|new
name|File
argument_list|(
name|tmpDir
argument_list|,
name|SliderKeys
operator|.
name|DEFAULT_APP_PKG
argument_list|)
expr_stmt|;
name|sliderFileSystem
operator|.
name|copyHdfsFileToLocal
argument_list|(
name|appDefPath
argument_list|,
name|pkgFile
argument_list|)
expr_stmt|;
block|}
name|require
argument_list|(
name|pkgFile
operator|.
name|isFile
argument_list|()
argument_list|,
name|E_UNABLE_TO_READ_SUPPLIED_PACKAGE_FILE
operator|+
literal|" at %s"
argument_list|,
name|pkgFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|JSONObject
name|config
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|clientInfo
operator|.
name|clientConfig
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|byte
index|[]
name|encoded
init|=
name|Files
operator|.
name|toByteArray
argument_list|(
name|clientInfo
operator|.
name|clientConfig
argument_list|)
decl_stmt|;
name|config
operator|=
operator|new
name|JSONObject
argument_list|(
operator|new
name|String
argument_list|(
name|encoded
argument_list|,
name|Charset
operator|.
name|defaultCharset
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|JSONException
name|jsonEx
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unable to read supplied configuration at {}: {}"
argument_list|,
name|clientInfo
operator|.
name|clientConfig
argument_list|,
name|jsonEx
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Unable to read supplied configuration at {}: {}"
argument_list|,
name|clientInfo
operator|.
name|clientConfig
argument_list|,
name|jsonEx
argument_list|,
name|jsonEx
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|BadConfigException
argument_list|(
name|E_MUST_BE_A_VALID_JSON_FILE
argument_list|,
name|jsonEx
argument_list|)
throw|;
block|}
block|}
comment|// Only INSTALL is supported
name|AbstractClientProvider
name|provider
init|=
name|createClientProvider
argument_list|(
name|SliderProviderFactory
operator|.
name|DEFAULT_CLUSTER_TYPE
argument_list|)
decl_stmt|;
name|provider
operator|.
name|processClientOperation
argument_list|(
name|sliderFileSystem
argument_list|,
name|getRegistryOperations
argument_list|()
argument_list|,
name|getConfig
argument_list|()
argument_list|,
literal|"INSTALL"
argument_list|,
name|clientInfo
operator|.
name|installLocation
argument_list|,
name|pkgFile
argument_list|,
name|config
argument_list|,
name|clientInfo
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
annotation|@
name|Override
DECL|method|actionPackage (ActionPackageArgs actionPackageInfo)
specifier|public
name|int
name|actionPackage
parameter_list|(
name|ActionPackageArgs
name|actionPackageInfo
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|initializeOutputStream
argument_list|(
name|actionPackageInfo
operator|.
name|out
argument_list|)
expr_stmt|;
name|int
name|exitCode
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|actionPackageInfo
operator|.
name|help
condition|)
block|{
name|exitCode
operator|=
name|actionHelp
argument_list|(
name|ACTION_PACKAGE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|actionPackageInfo
operator|.
name|install
condition|)
block|{
name|exitCode
operator|=
name|actionPackageInstall
argument_list|(
name|actionPackageInfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|actionPackageInfo
operator|.
name|delete
condition|)
block|{
name|exitCode
operator|=
name|actionPackageDelete
argument_list|(
name|actionPackageInfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|actionPackageInfo
operator|.
name|list
condition|)
block|{
name|exitCode
operator|=
name|actionPackageList
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|actionPackageInfo
operator|.
name|instances
condition|)
block|{
name|exitCode
operator|=
name|actionPackageInstances
argument_list|()
expr_stmt|;
block|}
name|finalizeOutputStream
argument_list|(
name|actionPackageInfo
operator|.
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|exitCode
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
name|exitCode
return|;
block|}
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"Select valid package operation option"
argument_list|)
throw|;
block|}
DECL|method|initializeOutputStream (String outFile)
specifier|private
name|void
name|initializeOutputStream
parameter_list|(
name|String
name|outFile
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
if|if
condition|(
name|outFile
operator|!=
literal|null
condition|)
block|{
name|clientOutputStream
operator|=
operator|new
name|PrintStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|outFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clientOutputStream
operator|=
name|System
operator|.
name|out
expr_stmt|;
block|}
block|}
DECL|method|finalizeOutputStream (String outFile)
specifier|private
name|void
name|finalizeOutputStream
parameter_list|(
name|String
name|outFile
parameter_list|)
block|{
if|if
condition|(
name|outFile
operator|!=
literal|null
operator|&&
name|clientOutputStream
operator|!=
literal|null
condition|)
block|{
name|clientOutputStream
operator|.
name|flush
argument_list|()
expr_stmt|;
name|clientOutputStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|clientOutputStream
operator|=
name|System
operator|.
name|out
expr_stmt|;
block|}
DECL|method|actionPackageInstances ()
specifier|private
name|int
name|actionPackageInstances
parameter_list|()
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Path
argument_list|>
name|persistentInstances
init|=
name|sliderFileSystem
operator|.
name|listPersistentInstances
argument_list|()
decl_stmt|;
if|if
condition|(
name|persistentInstances
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"No slider cluster specification available"
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
name|String
name|pkgPathValue
init|=
name|sliderFileSystem
operator|.
name|buildPackageDirPath
argument_list|(
name|StringUtils
operator|.
name|EMPTY
argument_list|,
name|StringUtils
operator|.
name|EMPTY
argument_list|)
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|FileSystem
name|fs
init|=
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Path
argument_list|>
argument_list|>
name|instanceItr
init|=
name|persistentInstances
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"List of applications with its package name and path"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"%-25s  %15s  %30s  %s"
argument_list|,
literal|"Cluster Name"
argument_list|,
literal|"Package Name"
argument_list|,
literal|"Package Version"
argument_list|,
literal|"Application Location"
argument_list|)
expr_stmt|;
while|while
condition|(
name|instanceItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Path
argument_list|>
name|entry
init|=
name|instanceItr
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|clusterName
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Path
name|clusterPath
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|AggregateConf
name|instanceDefinition
init|=
name|loadInstanceDefinitionUnresolved
argument_list|(
name|clusterName
argument_list|,
name|clusterPath
argument_list|)
decl_stmt|;
name|Path
name|appDefPath
init|=
literal|null
decl_stmt|;
try|try
block|{
name|appDefPath
operator|=
operator|new
name|Path
argument_list|(
name|getApplicationDefinitionPath
argument_list|(
name|instanceDefinition
operator|.
name|getAppConfOperations
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BadConfigException
name|e
parameter_list|)
block|{
comment|// Invalid cluster state, so move on to next. No need to log anything
comment|// as this is just listing of instances.
continue|continue;
block|}
if|if
condition|(
operator|!
name|appDefPath
operator|.
name|isUriPathAbsolute
argument_list|()
condition|)
block|{
name|appDefPath
operator|=
operator|new
name|Path
argument_list|(
name|fs
operator|.
name|getHomeDirectory
argument_list|()
argument_list|,
name|appDefPath
argument_list|)
expr_stmt|;
block|}
name|String
name|appDefPathStr
init|=
name|appDefPath
operator|.
name|toUri
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|appDefPathStr
operator|.
name|contains
argument_list|(
name|pkgPathValue
argument_list|)
operator|&&
name|fs
operator|.
name|isFile
argument_list|(
name|appDefPath
argument_list|)
condition|)
block|{
name|String
name|packageName
init|=
name|appDefPath
operator|.
name|getParent
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|packageVersion
init|=
name|StringUtils
operator|.
name|EMPTY
decl_stmt|;
if|if
condition|(
name|instanceDefinition
operator|.
name|isVersioned
argument_list|()
condition|)
block|{
name|packageVersion
operator|=
name|packageName
expr_stmt|;
name|packageName
operator|=
name|appDefPath
operator|.
name|getParent
argument_list|()
operator|.
name|getParent
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
name|println
argument_list|(
literal|"%-25s  %15s  %30s  %s"
argument_list|,
name|clusterName
argument_list|,
name|packageName
argument_list|,
name|packageVersion
argument_list|,
name|appDefPathStr
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"{} application definition path {} is not found."
argument_list|,
name|clusterName
argument_list|,
name|appDefPathStr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
DECL|method|actionPackageList ()
specifier|private
name|int
name|actionPackageList
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|pkgPath
init|=
name|sliderFileSystem
operator|.
name|buildPackageDirPath
argument_list|(
name|StringUtils
operator|.
name|EMPTY
argument_list|,
name|StringUtils
operator|.
name|EMPTY
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Package install path : {}"
argument_list|,
name|pkgPath
argument_list|)
expr_stmt|;
name|FileSystem
name|sfs
init|=
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|sfs
operator|.
name|isDirectory
argument_list|(
name|pkgPath
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"No package(s) installed"
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
name|FileStatus
index|[]
name|fileStatus
init|=
name|sfs
operator|.
name|listStatus
argument_list|(
name|pkgPath
argument_list|)
decl_stmt|;
name|boolean
name|hasPackage
init|=
literal|false
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"List of installed packages:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|FileStatus
name|fstat
range|:
name|fileStatus
control|)
block|{
if|if
condition|(
name|fstat
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
name|fstat
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|hasPackage
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hasPackage
condition|)
block|{
name|println
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"No package(s) installed"
argument_list|)
expr_stmt|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
DECL|method|createSummaryMetainfoFile (Path srcFile, Path destFile, boolean overwrite)
specifier|private
name|void
name|createSummaryMetainfoFile
parameter_list|(
name|Path
name|srcFile
parameter_list|,
name|Path
name|destFile
parameter_list|,
name|boolean
name|overwrite
parameter_list|)
throws|throws
name|IOException
block|{
name|FileSystem
name|srcFs
init|=
name|srcFile
operator|.
name|getFileSystem
argument_list|(
name|getConfig
argument_list|()
argument_list|)
decl_stmt|;
try|try
init|(
name|InputStream
name|inputStreamJson
init|=
name|SliderUtils
operator|.
name|getApplicationResourceInputStream
argument_list|(
name|srcFs
argument_list|,
name|srcFile
argument_list|,
literal|"metainfo.json"
argument_list|)
init|;
name|InputStream
name|inputStreamXml
operator|=
name|SliderUtils
operator|.
name|getApplicationResourceInputStream
argument_list|(
name|srcFs
argument_list|,
name|srcFile
argument_list|,
literal|"metainfo.xml"
argument_list|)
init|;
init|)
block|{
name|InputStream
name|inputStream
init|=
literal|null
decl_stmt|;
name|Path
name|summaryFileInFs
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|inputStreamJson
operator|!=
literal|null
condition|)
block|{
name|inputStream
operator|=
name|inputStreamJson
expr_stmt|;
name|summaryFileInFs
operator|=
operator|new
name|Path
argument_list|(
name|destFile
operator|.
name|getParent
argument_list|()
argument_list|,
name|destFile
operator|.
name|getName
argument_list|()
operator|+
literal|".metainfo.json"
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Found JSON metainfo file in package"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inputStreamXml
operator|!=
literal|null
condition|)
block|{
name|inputStream
operator|=
name|inputStreamXml
expr_stmt|;
name|summaryFileInFs
operator|=
operator|new
name|Path
argument_list|(
name|destFile
operator|.
name|getParent
argument_list|()
argument_list|,
name|destFile
operator|.
name|getName
argument_list|()
operator|+
literal|".metainfo.xml"
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Found XML metainfo file in package"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inputStream
operator|!=
literal|null
condition|)
block|{
try|try
init|(
name|FSDataOutputStream
name|dataOutputStream
init|=
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
operator|.
name|create
argument_list|(
name|summaryFileInFs
argument_list|,
name|overwrite
argument_list|)
init|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Creating summary metainfo file"
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|copy
argument_list|(
name|inputStream
argument_list|,
name|dataOutputStream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|actionPackageInstall (ActionPackageArgs actionPackageArgs)
specifier|private
name|int
name|actionPackageInstall
parameter_list|(
name|ActionPackageArgs
name|actionPackageArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|requireArgumentSet
argument_list|(
name|Arguments
operator|.
name|ARG_NAME
argument_list|,
name|actionPackageArgs
operator|.
name|name
argument_list|)
expr_stmt|;
name|Path
name|srcFile
init|=
name|extractPackagePath
argument_list|(
name|actionPackageArgs
operator|.
name|packageURI
argument_list|)
decl_stmt|;
name|Path
name|pkgPath
init|=
name|sliderFileSystem
operator|.
name|buildPackageDirPath
argument_list|(
name|actionPackageArgs
operator|.
name|name
argument_list|,
name|actionPackageArgs
operator|.
name|version
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|pkgPath
argument_list|)
condition|)
block|{
name|fs
operator|.
name|mkdirs
argument_list|(
name|pkgPath
argument_list|)
expr_stmt|;
block|}
name|Path
name|fileInFs
init|=
operator|new
name|Path
argument_list|(
name|pkgPath
argument_list|,
name|srcFile
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|require
argument_list|(
name|actionPackageArgs
operator|.
name|replacePkg
operator|||
operator|!
name|fs
operator|.
name|exists
argument_list|(
name|fileInFs
argument_list|)
argument_list|,
name|E_PACKAGE_EXISTS
operator|+
literal|" at  %s. Use --replacepkg to overwrite."
argument_list|,
name|fileInFs
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Installing package {} to {} (overwrite set to {})"
argument_list|,
name|srcFile
argument_list|,
name|fileInFs
argument_list|,
name|actionPackageArgs
operator|.
name|replacePkg
argument_list|)
expr_stmt|;
name|fs
operator|.
name|copyFromLocalFile
argument_list|(
literal|false
argument_list|,
name|actionPackageArgs
operator|.
name|replacePkg
argument_list|,
name|srcFile
argument_list|,
name|fileInFs
argument_list|)
expr_stmt|;
name|createSummaryMetainfoFile
argument_list|(
name|srcFile
argument_list|,
name|fileInFs
argument_list|,
name|actionPackageArgs
operator|.
name|replacePkg
argument_list|)
expr_stmt|;
name|String
name|destPathWithHomeDir
init|=
name|Path
operator|.
name|getPathWithoutSchemeAndAuthority
argument_list|(
name|fileInFs
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|destHomeDir
init|=
name|Path
operator|.
name|getPathWithoutSchemeAndAuthority
argument_list|(
name|fs
operator|.
name|getHomeDirectory
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|// a somewhat contrived approach to stripping out the home directory and any trailing
comment|// separator; designed to work on windows and unix
name|String
name|destPathWithoutHomeDir
decl_stmt|;
if|if
condition|(
name|destPathWithHomeDir
operator|.
name|startsWith
argument_list|(
name|destHomeDir
argument_list|)
condition|)
block|{
name|destPathWithoutHomeDir
operator|=
name|destPathWithHomeDir
operator|.
name|substring
argument_list|(
name|destHomeDir
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|destPathWithoutHomeDir
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
operator|||
name|destPathWithoutHomeDir
operator|.
name|startsWith
argument_list|(
literal|"\\"
argument_list|)
condition|)
block|{
name|destPathWithoutHomeDir
operator|=
name|destPathWithoutHomeDir
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|destPathWithoutHomeDir
operator|=
name|destPathWithHomeDir
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Set "
operator|+
name|AgentKeys
operator|.
name|APP_DEF
operator|+
literal|" in your app config JSON to {}"
argument_list|,
name|destPathWithoutHomeDir
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
DECL|method|extractPackagePath (String packageURI)
specifier|private
name|Path
name|extractPackagePath
parameter_list|(
name|String
name|packageURI
parameter_list|)
throws|throws
name|BadCommandArgumentsException
block|{
name|require
argument_list|(
name|isSet
argument_list|(
name|packageURI
argument_list|)
argument_list|,
name|E_INVALID_APPLICATION_PACKAGE_LOCATION
argument_list|)
expr_stmt|;
name|File
name|pkgFile
init|=
operator|new
name|File
argument_list|(
name|packageURI
argument_list|)
decl_stmt|;
name|require
argument_list|(
name|pkgFile
operator|.
name|isFile
argument_list|()
argument_list|,
name|E_UNABLE_TO_READ_SUPPLIED_PACKAGE_FILE
operator|+
literal|":  "
operator|+
name|pkgFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|Path
argument_list|(
name|pkgFile
operator|.
name|toURI
argument_list|()
argument_list|)
return|;
block|}
DECL|method|actionPackageDelete (ActionPackageArgs actionPackageArgs)
specifier|private
name|int
name|actionPackageDelete
parameter_list|(
name|ActionPackageArgs
name|actionPackageArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|requireArgumentSet
argument_list|(
name|Arguments
operator|.
name|ARG_NAME
argument_list|,
name|actionPackageArgs
operator|.
name|name
argument_list|)
expr_stmt|;
name|Path
name|pkgPath
init|=
name|sliderFileSystem
operator|.
name|buildPackageDirPath
argument_list|(
name|actionPackageArgs
operator|.
name|name
argument_list|,
name|actionPackageArgs
operator|.
name|version
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|require
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
name|pkgPath
argument_list|)
argument_list|,
name|E_PACKAGE_DOES_NOT_EXIST
operator|+
literal|": %s "
argument_list|,
name|pkgPath
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Deleting package {} at {}."
argument_list|,
name|actionPackageArgs
operator|.
name|name
argument_list|,
name|pkgPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|.
name|delete
argument_list|(
name|pkgPath
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Deleted package {} "
operator|+
name|actionPackageArgs
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Package deletion failed."
argument_list|)
expr_stmt|;
return|return
name|EXIT_NOT_FOUND
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|actionUpdate (String clustername, AbstractClusterBuildingActionArgs buildInfo)
specifier|public
name|int
name|actionUpdate
parameter_list|(
name|String
name|clustername
parameter_list|,
name|AbstractClusterBuildingActionArgs
name|buildInfo
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|buildInstanceDefinition
argument_list|(
name|clustername
argument_list|,
name|buildInfo
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
comment|/**    * Build up the AggregateConfiguration for an application instance then    * persists it    * @param clustername name of the cluster    * @param buildInfo the arguments needed to build the cluster    * @param overwrite true if existing cluster directory can be overwritten    * @param liveClusterAllowed true if live cluster can be modified    * @throws YarnException    * @throws IOException    */
DECL|method|buildInstanceDefinition (String clustername, AbstractClusterBuildingActionArgs buildInfo, boolean overwrite, boolean liveClusterAllowed)
specifier|public
name|void
name|buildInstanceDefinition
parameter_list|(
name|String
name|clustername
parameter_list|,
name|AbstractClusterBuildingActionArgs
name|buildInfo
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|boolean
name|liveClusterAllowed
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|buildInstanceDefinition
argument_list|(
name|clustername
argument_list|,
name|buildInfo
argument_list|,
name|overwrite
argument_list|,
name|liveClusterAllowed
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|buildInstanceDefinition (String clustername, AbstractClusterBuildingActionArgs buildInfo, boolean overwrite, boolean liveClusterAllowed, boolean isUpgradeFlow)
specifier|public
name|void
name|buildInstanceDefinition
parameter_list|(
name|String
name|clustername
parameter_list|,
name|AbstractClusterBuildingActionArgs
name|buildInfo
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|boolean
name|liveClusterAllowed
parameter_list|,
name|boolean
name|isUpgradeFlow
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
comment|// verify that a live cluster isn't there
name|validateClusterName
argument_list|(
name|clustername
argument_list|)
expr_stmt|;
name|verifyBindingsDefined
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|liveClusterAllowed
condition|)
block|{
name|verifyNoLiveClusters
argument_list|(
name|clustername
argument_list|,
literal|"Create"
argument_list|)
expr_stmt|;
block|}
name|Configuration
name|conf
init|=
name|getConfig
argument_list|()
decl_stmt|;
name|String
name|registryQuorum
init|=
name|lookupZKQuorum
argument_list|()
decl_stmt|;
name|Path
name|appconfdir
init|=
name|buildInfo
operator|.
name|getConfdir
argument_list|()
decl_stmt|;
comment|// Provider
name|String
name|providerName
init|=
name|buildInfo
operator|.
name|getProvider
argument_list|()
decl_stmt|;
name|requireArgumentSet
argument_list|(
name|Arguments
operator|.
name|ARG_PROVIDER
argument_list|,
name|providerName
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Provider is {}"
argument_list|,
name|providerName
argument_list|)
expr_stmt|;
name|SliderAMClientProvider
name|sliderAM
init|=
operator|new
name|SliderAMClientProvider
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|AbstractClientProvider
name|provider
init|=
name|createClientProvider
argument_list|(
name|providerName
argument_list|)
decl_stmt|;
name|InstanceBuilder
name|builder
init|=
operator|new
name|InstanceBuilder
argument_list|(
name|sliderFileSystem
argument_list|,
name|getConfig
argument_list|()
argument_list|,
name|clustername
argument_list|)
decl_stmt|;
name|AggregateConf
name|instanceDefinition
init|=
operator|new
name|AggregateConf
argument_list|()
decl_stmt|;
name|ConfTreeOperations
name|appConf
init|=
name|instanceDefinition
operator|.
name|getAppConfOperations
argument_list|()
decl_stmt|;
name|ConfTreeOperations
name|resources
init|=
name|instanceDefinition
operator|.
name|getResourceOperations
argument_list|()
decl_stmt|;
name|ConfTreeOperations
name|internal
init|=
name|instanceDefinition
operator|.
name|getInternalOperations
argument_list|()
decl_stmt|;
comment|//initial definition is set by the providers
name|sliderAM
operator|.
name|prepareInstanceConfiguration
argument_list|(
name|instanceDefinition
argument_list|)
expr_stmt|;
name|provider
operator|.
name|prepareInstanceConfiguration
argument_list|(
name|instanceDefinition
argument_list|)
expr_stmt|;
comment|//load in any specified on the command line
if|if
condition|(
name|buildInfo
operator|.
name|resources
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|resources
operator|.
name|mergeFile
argument_list|(
name|buildInfo
operator|.
name|resources
argument_list|,
operator|new
name|ResourcesInputPropertiesValidator
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|BadConfigException
argument_list|(
name|e
argument_list|,
literal|"incorrect argument to %s: \"%s\" : %s "
argument_list|,
name|Arguments
operator|.
name|ARG_RESOURCES
argument_list|,
name|buildInfo
operator|.
name|resources
argument_list|,
name|e
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|buildInfo
operator|.
name|template
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|appConf
operator|.
name|mergeFile
argument_list|(
name|buildInfo
operator|.
name|template
argument_list|,
operator|new
name|TemplateInputPropertiesValidator
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|BadConfigException
argument_list|(
name|e
argument_list|,
literal|"incorrect argument to %s: \"%s\" : %s "
argument_list|,
name|Arguments
operator|.
name|ARG_TEMPLATE
argument_list|,
name|buildInfo
operator|.
name|template
argument_list|,
name|e
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|isUpgradeFlow
condition|)
block|{
name|ActionUpgradeArgs
name|upgradeInfo
init|=
operator|(
name|ActionUpgradeArgs
operator|)
name|buildInfo
decl_stmt|;
if|if
condition|(
operator|!
name|upgradeInfo
operator|.
name|force
condition|)
block|{
name|validateClientAndClusterResource
argument_list|(
name|clustername
argument_list|,
name|resources
argument_list|)
expr_stmt|;
block|}
block|}
comment|//get the command line options
name|ConfTree
name|cmdLineAppOptions
init|=
name|buildInfo
operator|.
name|buildAppOptionsConfTree
argument_list|()
decl_stmt|;
name|ConfTree
name|cmdLineResourceOptions
init|=
name|buildInfo
operator|.
name|buildResourceOptionsConfTree
argument_list|()
decl_stmt|;
name|appConf
operator|.
name|merge
argument_list|(
name|cmdLineAppOptions
argument_list|)
expr_stmt|;
name|AppDefinitionPersister
name|appDefinitionPersister
init|=
operator|new
name|AppDefinitionPersister
argument_list|(
name|sliderFileSystem
argument_list|)
decl_stmt|;
name|appDefinitionPersister
operator|.
name|processSuppliedDefinitions
argument_list|(
name|clustername
argument_list|,
name|buildInfo
argument_list|,
name|appConf
argument_list|)
expr_stmt|;
comment|// put the role counts into the resources file
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|argsRoleMap
init|=
name|buildInfo
operator|.
name|getComponentMap
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|roleEntry
range|:
name|argsRoleMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|count
init|=
name|roleEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|key
init|=
name|roleEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"{} => {}"
argument_list|,
name|key
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|resources
operator|.
name|getOrAddComponent
argument_list|(
name|key
argument_list|)
operator|.
name|put
argument_list|(
name|COMPONENT_INSTANCES
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
comment|//all CLI role options
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|appOptionMap
init|=
name|buildInfo
operator|.
name|getCompOptionMap
argument_list|()
decl_stmt|;
name|appConf
operator|.
name|mergeComponents
argument_list|(
name|appOptionMap
argument_list|)
expr_stmt|;
comment|//internal picks up core. values only
name|internal
operator|.
name|propagateGlobalKeys
argument_list|(
name|appConf
argument_list|,
literal|"slider."
argument_list|)
expr_stmt|;
name|internal
operator|.
name|propagateGlobalKeys
argument_list|(
name|appConf
argument_list|,
literal|"internal."
argument_list|)
expr_stmt|;
comment|//copy over role. and yarn. values ONLY to the resources
if|if
condition|(
name|PROPAGATE_RESOURCE_OPTION
condition|)
block|{
name|resources
operator|.
name|propagateGlobalKeys
argument_list|(
name|appConf
argument_list|,
literal|"component."
argument_list|)
expr_stmt|;
name|resources
operator|.
name|propagateGlobalKeys
argument_list|(
name|appConf
argument_list|,
literal|"role."
argument_list|)
expr_stmt|;
name|resources
operator|.
name|propagateGlobalKeys
argument_list|(
name|appConf
argument_list|,
literal|"yarn."
argument_list|)
expr_stmt|;
name|resources
operator|.
name|mergeComponentsPrefix
argument_list|(
name|appOptionMap
argument_list|,
literal|"component."
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|resources
operator|.
name|mergeComponentsPrefix
argument_list|(
name|appOptionMap
argument_list|,
literal|"yarn."
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|resources
operator|.
name|mergeComponentsPrefix
argument_list|(
name|appOptionMap
argument_list|,
literal|"role."
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// resource component args
name|appConf
operator|.
name|merge
argument_list|(
name|cmdLineResourceOptions
argument_list|)
expr_stmt|;
name|resources
operator|.
name|merge
argument_list|(
name|cmdLineResourceOptions
argument_list|)
expr_stmt|;
name|resources
operator|.
name|mergeComponents
argument_list|(
name|buildInfo
operator|.
name|getResourceCompOptionMap
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|init
argument_list|(
name|providerName
argument_list|,
name|instanceDefinition
argument_list|)
expr_stmt|;
name|builder
operator|.
name|resolve
argument_list|()
expr_stmt|;
name|builder
operator|.
name|propagateFilename
argument_list|()
expr_stmt|;
name|builder
operator|.
name|propagatePrincipals
argument_list|()
expr_stmt|;
name|builder
operator|.
name|setImageDetailsIfAvailable
argument_list|(
name|buildInfo
operator|.
name|getImage
argument_list|()
argument_list|,
name|buildInfo
operator|.
name|getAppHomeDir
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setQueue
argument_list|(
name|buildInfo
operator|.
name|queue
argument_list|)
expr_stmt|;
name|String
name|quorum
init|=
name|buildInfo
operator|.
name|getZKhosts
argument_list|()
decl_stmt|;
if|if
condition|(
name|isUnset
argument_list|(
name|quorum
argument_list|)
condition|)
block|{
name|quorum
operator|=
name|registryQuorum
expr_stmt|;
block|}
if|if
condition|(
name|isUnset
argument_list|(
name|quorum
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BadConfigException
argument_list|(
name|E_NO_ZOOKEEPER_QUORUM
argument_list|)
throw|;
block|}
name|ZKPathBuilder
name|zkPaths
init|=
operator|new
name|ZKPathBuilder
argument_list|(
name|getAppName
argument_list|()
argument_list|,
name|getUsername
argument_list|()
argument_list|,
name|clustername
argument_list|,
name|registryQuorum
argument_list|,
name|quorum
argument_list|)
decl_stmt|;
name|String
name|zookeeperRoot
init|=
name|buildInfo
operator|.
name|getAppZKPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|isSet
argument_list|(
name|zookeeperRoot
argument_list|)
condition|)
block|{
name|zkPaths
operator|.
name|setAppPath
argument_list|(
name|zookeeperRoot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|createDefaultZkNode
init|=
name|appConf
operator|.
name|getGlobalOptions
argument_list|()
operator|.
name|getOption
argument_list|(
name|AgentKeys
operator|.
name|CREATE_DEF_ZK_NODE
argument_list|,
literal|"false"
argument_list|)
decl_stmt|;
if|if
condition|(
name|createDefaultZkNode
operator|.
name|equals
argument_list|(
literal|"true"
argument_list|)
condition|)
block|{
name|String
name|defaultZKPath
init|=
name|createZookeeperNode
argument_list|(
name|clustername
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"ZK node created for application instance: {}"
argument_list|,
name|defaultZKPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|defaultZKPath
operator|!=
literal|null
condition|)
block|{
name|zkPaths
operator|.
name|setAppPath
argument_list|(
name|defaultZKPath
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// create AppPath if default is being used
name|String
name|defaultZKPath
init|=
name|createZookeeperNode
argument_list|(
name|clustername
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"ZK node assigned to application instance: {}"
argument_list|,
name|defaultZKPath
argument_list|)
expr_stmt|;
name|zkPaths
operator|.
name|setAppPath
argument_list|(
name|defaultZKPath
argument_list|)
expr_stmt|;
block|}
block|}
name|builder
operator|.
name|addZKBinding
argument_list|(
name|zkPaths
argument_list|)
expr_stmt|;
comment|//then propagate any package URI
if|if
condition|(
name|buildInfo
operator|.
name|packageURI
operator|!=
literal|null
condition|)
block|{
name|appConf
operator|.
name|set
argument_list|(
name|AgentKeys
operator|.
name|PACKAGE_PATH
argument_list|,
name|buildInfo
operator|.
name|packageURI
argument_list|)
expr_stmt|;
block|}
name|propagatePythonExecutable
argument_list|(
name|conf
argument_list|,
name|instanceDefinition
argument_list|)
expr_stmt|;
comment|// make any substitutions needed at this stage
name|replaceTokens
argument_list|(
name|appConf
operator|.
name|getConfTree
argument_list|()
argument_list|,
name|getUsername
argument_list|()
argument_list|,
name|clustername
argument_list|)
expr_stmt|;
comment|// TODO: Refactor the validation code and persistence code
try|try
block|{
name|persistInstanceDefinition
argument_list|(
name|overwrite
argument_list|,
name|appconfdir
argument_list|,
name|builder
argument_list|)
expr_stmt|;
name|appDefinitionPersister
operator|.
name|persistPackages
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockAcquireFailedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Failed to get a Lock on {} : {}"
argument_list|,
name|builder
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|BadClusterStateException
argument_list|(
literal|"Failed to save "
operator|+
name|clustername
operator|+
literal|": "
operator|+
name|e
argument_list|)
throw|;
block|}
comment|// providers to validate what there is
comment|// TODO: Validation should be done before persistence
name|AggregateConf
name|instanceDescription
init|=
name|builder
operator|.
name|getInstanceDescription
argument_list|()
decl_stmt|;
name|validateInstanceDefinition
argument_list|(
name|sliderAM
argument_list|,
name|instanceDescription
argument_list|,
name|sliderFileSystem
argument_list|)
expr_stmt|;
name|validateInstanceDefinition
argument_list|(
name|provider
argument_list|,
name|instanceDescription
argument_list|,
name|sliderFileSystem
argument_list|)
expr_stmt|;
block|}
DECL|method|validateClientAndClusterResource (String clustername, ConfTreeOperations clientResources)
specifier|private
name|void
name|validateClientAndClusterResource
parameter_list|(
name|String
name|clustername
parameter_list|,
name|ConfTreeOperations
name|clientResources
parameter_list|)
throws|throws
name|BadClusterStateException
throws|,
name|SliderException
throws|,
name|IOException
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Validating upgrade resource definition with current cluster "
operator|+
literal|"state (components and instance count)"
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|clientComponentInstances
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|componentName
range|:
name|clientResources
operator|.
name|getComponentNames
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|SliderKeys
operator|.
name|COMPONENT_AM
operator|.
name|equals
argument_list|(
name|componentName
argument_list|)
condition|)
block|{
name|clientComponentInstances
operator|.
name|put
argument_list|(
name|componentName
argument_list|,
name|clientResources
operator|.
name|getComponentOptInt
argument_list|(
name|componentName
argument_list|,
name|COMPONENT_INSTANCES
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|AggregateConf
name|clusterConf
init|=
literal|null
decl_stmt|;
try|try
block|{
name|clusterConf
operator|=
name|loadPersistedClusterDescription
argument_list|(
name|clustername
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockAcquireFailedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Failed to get a Lock on cluster resource : {}"
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|BadClusterStateException
argument_list|(
literal|"Failed to load client resource definition "
operator|+
name|clustername
operator|+
literal|": "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|clusterComponentInstances
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|component
range|:
name|clusterConf
operator|.
name|getResources
argument_list|()
operator|.
name|components
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|SliderKeys
operator|.
name|COMPONENT_AM
operator|.
name|equals
argument_list|(
name|component
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|clusterComponentInstances
operator|.
name|put
argument_list|(
name|component
operator|.
name|getKey
argument_list|()
argument_list|,
name|Integer
operator|.
name|decode
argument_list|(
name|component
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|(
name|COMPONENT_INSTANCES
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// client and cluster should be an exact match
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|clientComponentInstanceIt
init|=
name|clientComponentInstances
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|clientComponentInstanceIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|clientComponentInstanceEntry
init|=
name|clientComponentInstanceIt
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|clusterComponentInstances
operator|.
name|containsKey
argument_list|(
name|clientComponentInstanceEntry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
comment|// compare instance count now and remove from both maps if they match
if|if
condition|(
name|clusterComponentInstances
operator|.
name|get
argument_list|(
name|clientComponentInstanceEntry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|intValue
argument_list|()
operator|==
name|clientComponentInstanceEntry
operator|.
name|getValue
argument_list|()
operator|.
name|intValue
argument_list|()
condition|)
block|{
name|clusterComponentInstances
operator|.
name|remove
argument_list|(
name|clientComponentInstanceEntry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|clientComponentInstanceIt
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|clientComponentInstances
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|clusterComponentInstances
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Mismatch found in upgrade resource definition and cluster "
operator|+
literal|"resource state"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|clientComponentInstances
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"The upgrade resource definitions that do not match are:"
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|clientComponentInstanceEntry
range|:
name|clientComponentInstances
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"    Component Name: {}, Instance count: {}"
argument_list|,
name|clientComponentInstanceEntry
operator|.
name|getKey
argument_list|()
argument_list|,
name|clientComponentInstanceEntry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|clusterComponentInstances
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"The cluster resources that do not match are:"
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|clusterComponentInstanceEntry
range|:
name|clusterComponentInstances
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"    Component Name: {}, Instance count: {}"
argument_list|,
name|clusterComponentInstanceEntry
operator|.
name|getKey
argument_list|()
argument_list|,
name|clusterComponentInstanceEntry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
throw|throw
operator|new
name|BadConfigException
argument_list|(
literal|"Resource definition provided for "
operator|+
literal|"upgrade does not match with that of the currently running "
operator|+
literal|"cluster.\nIf you are aware of what you are doing, rerun the "
operator|+
literal|"command with "
operator|+
name|Arguments
operator|.
name|ARG_FORCE
operator|+
literal|" option."
argument_list|)
throw|;
block|}
block|}
DECL|method|persistInstanceDefinition (boolean overwrite, Path appconfdir, InstanceBuilder builder)
specifier|protected
name|void
name|persistInstanceDefinition
parameter_list|(
name|boolean
name|overwrite
parameter_list|,
name|Path
name|appconfdir
parameter_list|,
name|InstanceBuilder
name|builder
parameter_list|)
throws|throws
name|IOException
throws|,
name|SliderException
throws|,
name|LockAcquireFailedException
block|{
name|builder
operator|.
name|persist
argument_list|(
name|appconfdir
argument_list|,
name|overwrite
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|replaceTokens (ConfTree conf, String userName, String clusterName)
specifier|public
specifier|static
name|void
name|replaceTokens
parameter_list|(
name|ConfTree
name|conf
parameter_list|,
name|String
name|userName
parameter_list|,
name|String
name|clusterName
parameter_list|)
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|newglobal
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|conf
operator|.
name|global
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|newglobal
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|replaceTokens
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|userName
argument_list|,
name|clusterName
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|conf
operator|.
name|global
operator|.
name|putAll
argument_list|(
name|newglobal
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|component
range|:
name|conf
operator|.
name|components
operator|.
name|keySet
argument_list|()
control|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|newComponent
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|conf
operator|.
name|components
operator|.
name|get
argument_list|(
name|component
argument_list|)
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|newComponent
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|replaceTokens
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|userName
argument_list|,
name|clusterName
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|conf
operator|.
name|components
operator|.
name|get
argument_list|(
name|component
argument_list|)
operator|.
name|putAll
argument_list|(
name|newComponent
argument_list|)
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|newcred
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|entry
range|:
name|conf
operator|.
name|credentials
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|resultList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|v
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
name|resultList
operator|.
name|add
argument_list|(
name|replaceTokens
argument_list|(
name|v
argument_list|,
name|userName
argument_list|,
name|clusterName
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|newcred
operator|.
name|put
argument_list|(
name|replaceTokens
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|userName
argument_list|,
name|clusterName
argument_list|)
argument_list|,
name|resultList
argument_list|)
expr_stmt|;
block|}
name|conf
operator|.
name|credentials
operator|.
name|clear
argument_list|()
expr_stmt|;
name|conf
operator|.
name|credentials
operator|.
name|putAll
argument_list|(
name|newcred
argument_list|)
expr_stmt|;
block|}
DECL|method|replaceTokens (String s, String userName, String clusterName)
specifier|private
specifier|static
name|String
name|replaceTokens
parameter_list|(
name|String
name|s
parameter_list|,
name|String
name|userName
parameter_list|,
name|String
name|clusterName
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|s
operator|.
name|replaceAll
argument_list|(
name|Pattern
operator|.
name|quote
argument_list|(
literal|"${USER}"
argument_list|)
argument_list|,
name|userName
argument_list|)
operator|.
name|replaceAll
argument_list|(
name|Pattern
operator|.
name|quote
argument_list|(
literal|"${USER_NAME}"
argument_list|)
argument_list|,
name|userName
argument_list|)
return|;
block|}
DECL|method|getClusterDirectoryPermissions (Configuration conf)
specifier|public
name|FsPermission
name|getClusterDirectoryPermissions
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|clusterDirPermsOct
init|=
name|conf
operator|.
name|get
argument_list|(
name|CLUSTER_DIRECTORY_PERMISSIONS
argument_list|,
name|DEFAULT_CLUSTER_DIRECTORY_PERMISSIONS
argument_list|)
decl_stmt|;
return|return
operator|new
name|FsPermission
argument_list|(
name|clusterDirPermsOct
argument_list|)
return|;
block|}
comment|/**    * Verify that the Resource Manager is configured (on a non-HA cluster).    * with a useful error message    * @throws BadCommandArgumentsException the exception raised on an invalid config    */
DECL|method|verifyBindingsDefined ()
specifier|public
name|void
name|verifyBindingsDefined
parameter_list|()
throws|throws
name|BadCommandArgumentsException
block|{
name|InetSocketAddress
name|rmAddr
init|=
name|getRmAddress
argument_list|(
name|getConfig
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|getConfig
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|YarnConfiguration
operator|.
name|RM_HA_ENABLED
argument_list|,
literal|false
argument_list|)
operator|&&
operator|!
name|isAddressDefined
argument_list|(
name|rmAddr
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
name|E_NO_RESOURCE_MANAGER
operator|+
literal|" in the argument "
operator|+
name|Arguments
operator|.
name|ARG_MANAGER
operator|+
literal|" or the configuration property "
operator|+
name|YarnConfiguration
operator|.
name|RM_ADDRESS
operator|+
literal|" value :"
operator|+
name|rmAddr
argument_list|)
throw|;
block|}
block|}
comment|/**    * Load and start a cluster specification.    * This assumes that all validation of args and cluster state    * have already taken place    *    * @param clustername name of the cluster.    * @param launchArgs launch arguments    * @param lifetime    * @return the exit code    * @throws YarnException    * @throws IOException    */
DECL|method|startCluster (String clustername, LaunchArgsAccessor launchArgs, long lifetime)
specifier|protected
name|int
name|startCluster
parameter_list|(
name|String
name|clustername
parameter_list|,
name|LaunchArgsAccessor
name|launchArgs
parameter_list|,
name|long
name|lifetime
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|Path
name|clusterDirectory
init|=
name|sliderFileSystem
operator|.
name|buildClusterDirPath
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
name|AggregateConf
name|instanceDefinition
init|=
name|loadInstanceDefinitionUnresolved
argument_list|(
name|clustername
argument_list|,
name|clusterDirectory
argument_list|)
decl_stmt|;
name|LaunchedApplication
name|launchedApplication
init|=
name|launchApplication
argument_list|(
name|clustername
argument_list|,
name|clusterDirectory
argument_list|,
name|instanceDefinition
argument_list|,
name|serviceArgs
operator|.
name|isDebug
argument_list|()
argument_list|,
name|lifetime
argument_list|)
decl_stmt|;
if|if
condition|(
name|launchArgs
operator|.
name|getOutputFile
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// output file has been requested. Get the app report and serialize it
name|ApplicationReport
name|report
init|=
name|launchedApplication
operator|.
name|getApplicationReport
argument_list|()
decl_stmt|;
name|SerializedApplicationReport
name|sar
init|=
operator|new
name|SerializedApplicationReport
argument_list|(
name|report
argument_list|)
decl_stmt|;
name|sar
operator|.
name|submitTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|ApplicationReportSerDeser
name|serDeser
init|=
operator|new
name|ApplicationReportSerDeser
argument_list|()
decl_stmt|;
name|serDeser
operator|.
name|save
argument_list|(
name|sar
argument_list|,
name|launchArgs
operator|.
name|getOutputFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|waittime
init|=
name|launchArgs
operator|.
name|getWaittime
argument_list|()
decl_stmt|;
if|if
condition|(
name|waittime
operator|>
literal|0
condition|)
block|{
return|return
name|waitForAppRunning
argument_list|(
name|launchedApplication
argument_list|,
name|waittime
argument_list|,
name|waittime
argument_list|)
return|;
block|}
else|else
block|{
comment|// no waiting
return|return
name|EXIT_SUCCESS
return|;
block|}
block|}
comment|/**    * Load the instance definition. It is not resolved at this point    * @param name cluster name    * @param clusterDirectory cluster dir    * @return the loaded configuration    * @throws IOException    * @throws SliderException    * @throws UnknownApplicationInstanceException if the file is not found    */
DECL|method|loadInstanceDefinitionUnresolved (String name, Path clusterDirectory)
specifier|public
name|AggregateConf
name|loadInstanceDefinitionUnresolved
parameter_list|(
name|String
name|name
parameter_list|,
name|Path
name|clusterDirectory
parameter_list|)
throws|throws
name|IOException
throws|,
name|SliderException
block|{
try|try
block|{
name|AggregateConf
name|definition
init|=
name|InstanceIO
operator|.
name|loadInstanceDefinitionUnresolved
argument_list|(
name|sliderFileSystem
argument_list|,
name|clusterDirectory
argument_list|)
decl_stmt|;
name|definition
operator|.
name|setName
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|definition
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
throw|throw
name|UnknownApplicationInstanceException
operator|.
name|unknownInstance
argument_list|(
name|name
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Load the instance definition.     * @param name cluster name    * @param resolved flag to indicate the cluster should be resolved    * @return the loaded configuration    * @throws IOException IO problems    * @throws SliderException slider explicit issues    * @throws UnknownApplicationInstanceException if the file is not found    */
DECL|method|loadInstanceDefinition (String name, boolean resolved)
specifier|public
name|AggregateConf
name|loadInstanceDefinition
parameter_list|(
name|String
name|name
parameter_list|,
name|boolean
name|resolved
parameter_list|)
throws|throws
name|IOException
throws|,
name|SliderException
block|{
name|Path
name|clusterDirectory
init|=
name|sliderFileSystem
operator|.
name|buildClusterDirPath
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|AggregateConf
name|instanceDefinition
init|=
name|loadInstanceDefinitionUnresolved
argument_list|(
name|name
argument_list|,
name|clusterDirectory
argument_list|)
decl_stmt|;
if|if
condition|(
name|resolved
condition|)
block|{
name|instanceDefinition
operator|.
name|resolve
argument_list|()
expr_stmt|;
block|}
return|return
name|instanceDefinition
return|;
block|}
DECL|method|setupAppMasterLauncher (String clustername, Path clusterDirectory, AggregateConf instanceDefinition, boolean debugAM, long lifetime)
specifier|protected
name|AppMasterLauncher
name|setupAppMasterLauncher
parameter_list|(
name|String
name|clustername
parameter_list|,
name|Path
name|clusterDirectory
parameter_list|,
name|AggregateConf
name|instanceDefinition
parameter_list|,
name|boolean
name|debugAM
parameter_list|,
name|long
name|lifetime
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|deployedClusterName
operator|=
name|clustername
expr_stmt|;
name|validateClusterName
argument_list|(
name|clustername
argument_list|)
expr_stmt|;
name|verifyNoLiveClusters
argument_list|(
name|clustername
argument_list|,
literal|"Launch"
argument_list|)
expr_stmt|;
name|Configuration
name|config
init|=
name|getConfig
argument_list|()
decl_stmt|;
name|lookupZKQuorum
argument_list|()
expr_stmt|;
name|boolean
name|clusterSecure
init|=
name|isHadoopClusterSecure
argument_list|(
name|config
argument_list|)
decl_stmt|;
comment|//create the Slider AM provider -this helps set up the AM
name|SliderAMClientProvider
name|sliderAM
init|=
operator|new
name|SliderAMClientProvider
argument_list|(
name|config
argument_list|)
decl_stmt|;
name|instanceDefinition
operator|.
name|resolve
argument_list|()
expr_stmt|;
name|launchedInstanceDefinition
operator|=
name|instanceDefinition
expr_stmt|;
name|ConfTreeOperations
name|internalOperations
init|=
name|instanceDefinition
operator|.
name|getInternalOperations
argument_list|()
decl_stmt|;
name|MapOperations
name|internalOptions
init|=
name|internalOperations
operator|.
name|getGlobalOptions
argument_list|()
decl_stmt|;
name|ConfTreeOperations
name|resourceOperations
init|=
name|instanceDefinition
operator|.
name|getResourceOperations
argument_list|()
decl_stmt|;
name|ConfTreeOperations
name|appOperations
init|=
name|instanceDefinition
operator|.
name|getAppConfOperations
argument_list|()
decl_stmt|;
name|Path
name|generatedConfDirPath
init|=
name|createPathThatMustExist
argument_list|(
name|internalOptions
operator|.
name|getMandatoryOption
argument_list|(
name|INTERNAL_GENERATED_CONF_PATH
argument_list|)
argument_list|)
decl_stmt|;
name|Path
name|snapshotConfPath
init|=
name|createPathThatMustExist
argument_list|(
name|internalOptions
operator|.
name|getMandatoryOption
argument_list|(
name|INTERNAL_SNAPSHOT_CONF_PATH
argument_list|)
argument_list|)
decl_stmt|;
comment|// cluster Provider
name|AbstractClientProvider
name|provider
init|=
name|createClientProvider
argument_list|(
name|internalOptions
operator|.
name|getMandatoryOption
argument_list|(
name|INTERNAL_PROVIDER_NAME
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
name|instanceDefinition
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|MapOperations
name|sliderAMResourceComponent
init|=
name|resourceOperations
operator|.
name|getOrAddComponent
argument_list|(
name|SliderKeys
operator|.
name|COMPONENT_AM
argument_list|)
decl_stmt|;
name|MapOperations
name|resourceGlobalOptions
init|=
name|resourceOperations
operator|.
name|getGlobalOptions
argument_list|()
decl_stmt|;
comment|// add the tags if available
name|Set
argument_list|<
name|String
argument_list|>
name|applicationTags
init|=
name|provider
operator|.
name|getApplicationTags
argument_list|(
name|sliderFileSystem
argument_list|,
name|appOperations
argument_list|)
decl_stmt|;
name|Credentials
name|credentials
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|clusterSecure
condition|)
block|{
comment|// pick up oozie credentials
name|credentials
operator|=
name|CredentialUtils
operator|.
name|loadTokensFromEnvironment
argument_list|(
name|System
operator|.
name|getenv
argument_list|()
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|credentials
operator|==
literal|null
condition|)
block|{
comment|// nothing from oozie, so build up directly
name|credentials
operator|=
operator|new
name|Credentials
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getCredentials
argument_list|()
argument_list|)
expr_stmt|;
name|CredentialUtils
operator|.
name|addRMRenewableFSDelegationTokens
argument_list|(
name|config
argument_list|,
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|credentials
argument_list|)
expr_stmt|;
name|CredentialUtils
operator|.
name|addRMDelegationToken
argument_list|(
name|yarnClient
argument_list|,
name|credentials
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Using externally supplied credentials to launch AM"
argument_list|)
expr_stmt|;
block|}
block|}
name|AppMasterLauncher
name|amLauncher
init|=
operator|new
name|AppMasterLauncher
argument_list|(
name|clustername
argument_list|,
name|SliderKeys
operator|.
name|APP_TYPE
argument_list|,
name|config
argument_list|,
name|sliderFileSystem
argument_list|,
name|yarnClient
argument_list|,
name|clusterSecure
argument_list|,
name|sliderAMResourceComponent
argument_list|,
name|resourceGlobalOptions
argument_list|,
name|applicationTags
argument_list|,
name|credentials
argument_list|)
decl_stmt|;
name|ApplicationId
name|appId
init|=
name|amLauncher
operator|.
name|getApplicationId
argument_list|()
decl_stmt|;
comment|// set the application name;
name|amLauncher
operator|.
name|setKeepContainersOverRestarts
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// set lifetime in submission context;
name|Map
argument_list|<
name|ApplicationTimeoutType
argument_list|,
name|Long
argument_list|>
name|appTimeout
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|appTimeout
operator|.
name|put
argument_list|(
name|ApplicationTimeoutType
operator|.
name|LIFETIME
argument_list|,
name|lifetime
argument_list|)
expr_stmt|;
name|amLauncher
operator|.
name|submissionContext
operator|.
name|setApplicationTimeouts
argument_list|(
name|appTimeout
argument_list|)
expr_stmt|;
name|int
name|maxAppAttempts
init|=
name|config
operator|.
name|getInt
argument_list|(
name|KEY_AM_RESTART_LIMIT
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|amLauncher
operator|.
name|setMaxAppAttempts
argument_list|(
name|maxAppAttempts
argument_list|)
expr_stmt|;
name|sliderFileSystem
operator|.
name|purgeAppInstanceTempFiles
argument_list|(
name|clustername
argument_list|)
expr_stmt|;
name|Path
name|tempPath
init|=
name|sliderFileSystem
operator|.
name|createAppInstanceTempPath
argument_list|(
name|clustername
argument_list|,
name|appId
operator|.
name|toString
argument_list|()
operator|+
literal|"/am"
argument_list|)
decl_stmt|;
name|String
name|libdir
init|=
literal|"lib"
decl_stmt|;
name|Path
name|libPath
init|=
operator|new
name|Path
argument_list|(
name|tempPath
argument_list|,
name|libdir
argument_list|)
decl_stmt|;
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
operator|.
name|mkdirs
argument_list|(
name|libPath
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"FS={}, tempPath={}, libdir={}"
argument_list|,
name|sliderFileSystem
argument_list|,
name|tempPath
argument_list|,
name|libPath
argument_list|)
expr_stmt|;
comment|// set local resources for the application master
comment|// local files or archives as needed
comment|// In this scenario, the jar file for the application master is part of the local resources
name|Map
argument_list|<
name|String
argument_list|,
name|LocalResource
argument_list|>
name|localResources
init|=
name|amLauncher
operator|.
name|getLocalResources
argument_list|()
decl_stmt|;
comment|// look for the configuration directory named on the command line
name|boolean
name|hasServerLog4jProperties
init|=
literal|false
decl_stmt|;
name|Path
name|remoteConfPath
init|=
literal|null
decl_stmt|;
name|String
name|relativeConfDir
init|=
literal|null
decl_stmt|;
name|String
name|confdirProp
init|=
name|System
operator|.
name|getProperty
argument_list|(
name|SliderKeys
operator|.
name|PROPERTY_CONF_DIR
argument_list|)
decl_stmt|;
if|if
condition|(
name|isUnset
argument_list|(
name|confdirProp
argument_list|)
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"No local configuration directory provided as system property"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|File
name|confDir
init|=
operator|new
name|File
argument_list|(
name|confdirProp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|confDir
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|BadConfigException
argument_list|(
name|E_CONFIGURATION_DIRECTORY_NOT_FOUND
argument_list|,
name|confDir
argument_list|)
throw|;
block|}
name|Path
name|localConfDirPath
init|=
name|createLocalPath
argument_list|(
name|confDir
argument_list|)
decl_stmt|;
name|remoteConfPath
operator|=
operator|new
name|Path
argument_list|(
name|clusterDirectory
argument_list|,
name|SliderKeys
operator|.
name|SUBMITTED_CONF_DIR
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Slider configuration directory is {}; remote to be {}"
argument_list|,
name|localConfDirPath
argument_list|,
name|remoteConfPath
argument_list|)
expr_stmt|;
name|copyDirectory
argument_list|(
name|config
argument_list|,
name|localConfDirPath
argument_list|,
name|remoteConfPath
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|File
name|log4jserver
init|=
operator|new
name|File
argument_list|(
name|confDir
argument_list|,
name|SliderKeys
operator|.
name|LOG4J_SERVER_PROP_FILENAME
argument_list|)
decl_stmt|;
name|hasServerLog4jProperties
operator|=
name|log4jserver
operator|.
name|isFile
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hasServerLog4jProperties
condition|)
block|{
comment|// check for log4j properties in hadoop conf dir
name|String
name|hadoopConfDir
init|=
name|System
operator|.
name|getenv
argument_list|(
name|ApplicationConstants
operator|.
name|Environment
operator|.
name|HADOOP_CONF_DIR
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|hadoopConfDir
operator|!=
literal|null
condition|)
block|{
name|File
name|localFile
init|=
operator|new
name|File
argument_list|(
name|hadoopConfDir
argument_list|,
name|SliderKeys
operator|.
name|LOG4J_SERVER_PROP_FILENAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|localFile
operator|.
name|exists
argument_list|()
condition|)
block|{
name|Path
name|localFilePath
init|=
name|createLocalPath
argument_list|(
name|localFile
argument_list|)
decl_stmt|;
name|remoteConfPath
operator|=
operator|new
name|Path
argument_list|(
name|clusterDirectory
argument_list|,
name|SliderKeys
operator|.
name|SUBMITTED_CONF_DIR
argument_list|)
expr_stmt|;
name|Path
name|remoteFilePath
init|=
operator|new
name|Path
argument_list|(
name|remoteConfPath
argument_list|,
name|SliderKeys
operator|.
name|LOG4J_SERVER_PROP_FILENAME
argument_list|)
decl_stmt|;
name|copy
argument_list|(
name|config
argument_list|,
name|localFilePath
argument_list|,
name|remoteFilePath
argument_list|)
expr_stmt|;
name|hasServerLog4jProperties
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
comment|// the assumption here is that minimr cluster => this is a test run
comment|// and the classpath can look after itself
name|boolean
name|usingMiniMRCluster
init|=
name|getUsingMiniMRCluster
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|usingMiniMRCluster
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Destination is not a MiniYARNCluster -copying full classpath"
argument_list|)
expr_stmt|;
comment|// insert conf dir first
if|if
condition|(
name|remoteConfPath
operator|!=
literal|null
condition|)
block|{
name|relativeConfDir
operator|=
name|SliderKeys
operator|.
name|SUBMITTED_CONF_DIR
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|LocalResource
argument_list|>
name|submittedConfDir
init|=
name|sliderFileSystem
operator|.
name|submitDirectory
argument_list|(
name|remoteConfPath
argument_list|,
name|relativeConfDir
argument_list|)
decl_stmt|;
name|mergeMaps
argument_list|(
name|localResources
argument_list|,
name|submittedConfDir
argument_list|)
expr_stmt|;
block|}
block|}
comment|// build up the configuration
comment|// IMPORTANT: it is only after this call that site configurations
comment|// will be valid.
name|propagatePrincipals
argument_list|(
name|config
argument_list|,
name|instanceDefinition
argument_list|)
expr_stmt|;
comment|// validate security data
comment|/*     // turned off until tested     SecurityConfiguration securityConfiguration =         new SecurityConfiguration(config,             instanceDefinition, clustername);      */
name|Configuration
name|clientConfExtras
init|=
operator|new
name|Configuration
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|// then build up the generated path.
name|FsPermission
name|clusterPerms
init|=
name|getClusterDirectoryPermissions
argument_list|(
name|config
argument_list|)
decl_stmt|;
name|copyDirectory
argument_list|(
name|config
argument_list|,
name|snapshotConfPath
argument_list|,
name|generatedConfDirPath
argument_list|,
name|clusterPerms
argument_list|)
expr_stmt|;
comment|// standard AM resources
name|sliderAM
operator|.
name|prepareAMAndConfigForLaunch
argument_list|(
name|sliderFileSystem
argument_list|,
name|config
argument_list|,
name|amLauncher
argument_list|,
name|instanceDefinition
argument_list|,
name|snapshotConfPath
argument_list|,
name|generatedConfDirPath
argument_list|,
name|clientConfExtras
argument_list|,
name|libdir
argument_list|,
name|tempPath
argument_list|,
name|usingMiniMRCluster
argument_list|)
expr_stmt|;
comment|//add provider-specific resources
name|provider
operator|.
name|prepareAMAndConfigForLaunch
argument_list|(
name|sliderFileSystem
argument_list|,
name|config
argument_list|,
name|amLauncher
argument_list|,
name|instanceDefinition
argument_list|,
name|snapshotConfPath
argument_list|,
name|generatedConfDirPath
argument_list|,
name|clientConfExtras
argument_list|,
name|libdir
argument_list|,
name|tempPath
argument_list|,
name|usingMiniMRCluster
argument_list|)
expr_stmt|;
comment|// now that the site config is fully generated, the provider gets
comment|// to do a quick review of them.
name|log
operator|.
name|debug
argument_list|(
literal|"Preflight validation of cluster configuration"
argument_list|)
expr_stmt|;
name|sliderAM
operator|.
name|preflightValidateClusterConfiguration
argument_list|(
name|sliderFileSystem
argument_list|,
name|clustername
argument_list|,
name|config
argument_list|,
name|instanceDefinition
argument_list|,
name|clusterDirectory
argument_list|,
name|generatedConfDirPath
argument_list|,
name|clusterSecure
argument_list|)
expr_stmt|;
name|provider
operator|.
name|preflightValidateClusterConfiguration
argument_list|(
name|sliderFileSystem
argument_list|,
name|clustername
argument_list|,
name|config
argument_list|,
name|instanceDefinition
argument_list|,
name|clusterDirectory
argument_list|,
name|generatedConfDirPath
argument_list|,
name|clusterSecure
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|provider
operator|instanceof
name|DockerClientProvider
operator|)
condition|)
block|{
name|Path
name|imagePath
init|=
name|extractImagePath
argument_list|(
name|sliderFileSystem
argument_list|,
name|internalOptions
argument_list|)
decl_stmt|;
if|if
condition|(
name|sliderFileSystem
operator|.
name|maybeAddImagePath
argument_list|(
name|localResources
argument_list|,
name|imagePath
argument_list|)
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Registered image path {}"
argument_list|,
name|imagePath
argument_list|)
expr_stmt|;
block|}
block|}
comment|// build the environment
name|amLauncher
operator|.
name|putEnv
argument_list|(
name|buildEnvMap
argument_list|(
name|sliderAMResourceComponent
argument_list|)
argument_list|)
expr_stmt|;
name|ClasspathConstructor
name|classpath
init|=
name|buildClasspath
argument_list|(
name|relativeConfDir
argument_list|,
name|libdir
argument_list|,
name|getConfig
argument_list|()
argument_list|,
name|sliderFileSystem
argument_list|,
name|usingMiniMRCluster
argument_list|)
decl_stmt|;
name|amLauncher
operator|.
name|setClasspath
argument_list|(
name|classpath
argument_list|)
expr_stmt|;
comment|//add english env
name|amLauncher
operator|.
name|setEnv
argument_list|(
literal|"LANG"
argument_list|,
literal|"en_US.UTF-8"
argument_list|)
expr_stmt|;
name|amLauncher
operator|.
name|setEnv
argument_list|(
literal|"LC_ALL"
argument_list|,
literal|"en_US.UTF-8"
argument_list|)
expr_stmt|;
name|amLauncher
operator|.
name|setEnv
argument_list|(
literal|"LANGUAGE"
argument_list|,
literal|"en_US.UTF-8"
argument_list|)
expr_stmt|;
name|amLauncher
operator|.
name|maybeSetEnv
argument_list|(
name|HADOOP_JAAS_DEBUG
argument_list|,
name|System
operator|.
name|getenv
argument_list|(
name|HADOOP_JAAS_DEBUG
argument_list|)
argument_list|)
expr_stmt|;
name|amLauncher
operator|.
name|putEnv
argument_list|(
name|getAmLaunchEnv
argument_list|(
name|config
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|envs
range|:
name|getSystemEnv
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"System env {}={}"
argument_list|,
name|envs
operator|.
name|getKey
argument_list|()
argument_list|,
name|envs
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"AM classpath={}"
argument_list|,
name|classpath
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Environment Map:\n{}"
argument_list|,
name|stringifyMap
argument_list|(
name|amLauncher
operator|.
name|getEnv
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Files in lib path\n{}"
argument_list|,
name|sliderFileSystem
operator|.
name|listFSDir
argument_list|(
name|libPath
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// rm address
name|InetSocketAddress
name|rmSchedulerAddress
decl_stmt|;
try|try
block|{
name|rmSchedulerAddress
operator|=
name|getRmSchedulerAddress
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|BadConfigException
argument_list|(
literal|"%s Address invalid: %s"
argument_list|,
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_ADDRESS
argument_list|,
name|config
operator|.
name|get
argument_list|(
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_ADDRESS
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|rmAddr
init|=
name|NetUtils
operator|.
name|getHostPortString
argument_list|(
name|rmSchedulerAddress
argument_list|)
decl_stmt|;
name|JavaCommandLineBuilder
name|commandLine
init|=
operator|new
name|JavaCommandLineBuilder
argument_list|()
decl_stmt|;
comment|// insert any JVM options);
name|sliderAM
operator|.
name|addJVMOptions
argument_list|(
name|instanceDefinition
argument_list|,
name|commandLine
argument_list|)
expr_stmt|;
comment|// enable asserts
name|commandLine
operator|.
name|enableJavaAssertions
argument_list|()
expr_stmt|;
comment|// if the conf dir has a slideram-log4j.properties, switch to that
if|if
condition|(
name|hasServerLog4jProperties
condition|)
block|{
name|commandLine
operator|.
name|sysprop
argument_list|(
name|SYSPROP_LOG4J_CONFIGURATION
argument_list|,
name|LOG4J_SERVER_PROP_FILENAME
argument_list|)
expr_stmt|;
name|commandLine
operator|.
name|sysprop
argument_list|(
name|SYSPROP_LOG_DIR
argument_list|,
name|ApplicationConstants
operator|.
name|LOG_DIR_EXPANSION_VAR
argument_list|)
expr_stmt|;
block|}
comment|// add the AM sevice entry point
name|commandLine
operator|.
name|add
argument_list|(
name|SliderAppMaster
operator|.
name|SERVICE_CLASSNAME
argument_list|)
expr_stmt|;
comment|// create action and the cluster name
name|commandLine
operator|.
name|add
argument_list|(
name|ACTION_CREATE
argument_list|,
name|clustername
argument_list|)
expr_stmt|;
comment|// debug
if|if
condition|(
name|debugAM
condition|)
block|{
name|commandLine
operator|.
name|add
argument_list|(
name|Arguments
operator|.
name|ARG_DEBUG
argument_list|)
expr_stmt|;
block|}
comment|// set the cluster directory path
name|commandLine
operator|.
name|add
argument_list|(
name|Arguments
operator|.
name|ARG_CLUSTER_URI
argument_list|,
name|clusterDirectory
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isUnset
argument_list|(
name|rmAddr
argument_list|)
condition|)
block|{
name|commandLine
operator|.
name|add
argument_list|(
name|Arguments
operator|.
name|ARG_RM_ADDR
argument_list|,
name|rmAddr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|serviceArgs
operator|.
name|getFilesystemBinding
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|commandLine
operator|.
name|add
argument_list|(
name|Arguments
operator|.
name|ARG_FILESYSTEM
argument_list|,
name|serviceArgs
operator|.
name|getFilesystemBinding
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// pass the registry binding
name|commandLine
operator|.
name|addConfOptionToCLI
argument_list|(
name|config
argument_list|,
name|RegistryConstants
operator|.
name|KEY_REGISTRY_ZK_ROOT
argument_list|,
name|RegistryConstants
operator|.
name|DEFAULT_ZK_REGISTRY_ROOT
argument_list|)
expr_stmt|;
name|commandLine
operator|.
name|addMandatoryConfOption
argument_list|(
name|config
argument_list|,
name|RegistryConstants
operator|.
name|KEY_REGISTRY_ZK_QUORUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|clusterSecure
condition|)
block|{
comment|// if the cluster is secure, make sure that
comment|// the relevant security settings go over
name|commandLine
operator|.
name|addConfOption
argument_list|(
name|config
argument_list|,
name|DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY
argument_list|)
expr_stmt|;
block|}
comment|// copy over any/all YARN RM client values, in case the server-side XML conf file
comment|// has the 0.0.0.0 address
name|commandLine
operator|.
name|addConfOptions
argument_list|(
name|config
argument_list|,
name|YarnConfiguration
operator|.
name|RM_ADDRESS
argument_list|,
name|YarnConfiguration
operator|.
name|RM_CLUSTER_ID
argument_list|,
name|YarnConfiguration
operator|.
name|RM_HOSTNAME
argument_list|,
name|YarnConfiguration
operator|.
name|RM_PRINCIPAL
argument_list|)
expr_stmt|;
comment|// write out the path output
name|commandLine
operator|.
name|addOutAndErrFiles
argument_list|(
name|STDOUT_AM
argument_list|,
name|STDERR_AM
argument_list|)
expr_stmt|;
name|String
name|cmdStr
init|=
name|commandLine
operator|.
name|build
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Completed setting up app master command {}"
argument_list|,
name|cmdStr
argument_list|)
expr_stmt|;
name|amLauncher
operator|.
name|addCommandLine
argument_list|(
name|commandLine
argument_list|)
expr_stmt|;
comment|// the Slider AM gets to configure the AM requirements, not the custom provider
name|sliderAM
operator|.
name|prepareAMResourceRequirements
argument_list|(
name|sliderAMResourceComponent
argument_list|,
name|amLauncher
operator|.
name|getResource
argument_list|()
argument_list|)
expr_stmt|;
comment|// Set the priority for the application master
name|amLauncher
operator|.
name|setPriority
argument_list|(
name|config
operator|.
name|getInt
argument_list|(
name|KEY_YARN_QUEUE_PRIORITY
argument_list|,
name|DEFAULT_YARN_QUEUE_PRIORITY
argument_list|)
argument_list|)
expr_stmt|;
comment|// Set the queue to which this application is to be submitted in the RM
comment|// Queue for App master
name|String
name|amQueue
init|=
name|config
operator|.
name|get
argument_list|(
name|KEY_YARN_QUEUE
argument_list|,
name|DEFAULT_YARN_QUEUE
argument_list|)
decl_stmt|;
name|String
name|suppliedQueue
init|=
name|internalOperations
operator|.
name|getGlobalOptions
argument_list|()
operator|.
name|get
argument_list|(
name|INTERNAL_QUEUE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isUnset
argument_list|(
name|suppliedQueue
argument_list|)
condition|)
block|{
name|amQueue
operator|=
name|suppliedQueue
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Using queue {} for the application instance."
argument_list|,
name|amQueue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isSet
argument_list|(
name|amQueue
argument_list|)
condition|)
block|{
name|amLauncher
operator|.
name|setQueue
argument_list|(
name|amQueue
argument_list|)
expr_stmt|;
block|}
return|return
name|amLauncher
return|;
block|}
comment|/**    *    * @param clustername name of the cluster    * @param clusterDirectory cluster dir    * @param instanceDefinition the instance definition    * @param debugAM enable debug AM options    * @param lifetime    * @return the launched application    * @throws YarnException    * @throws IOException    */
DECL|method|launchApplication (String clustername, Path clusterDirectory, AggregateConf instanceDefinition, boolean debugAM, long lifetime)
specifier|public
name|LaunchedApplication
name|launchApplication
parameter_list|(
name|String
name|clustername
parameter_list|,
name|Path
name|clusterDirectory
parameter_list|,
name|AggregateConf
name|instanceDefinition
parameter_list|,
name|boolean
name|debugAM
parameter_list|,
name|long
name|lifetime
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|AppMasterLauncher
name|amLauncher
init|=
name|setupAppMasterLauncher
argument_list|(
name|clustername
argument_list|,
name|clusterDirectory
argument_list|,
name|instanceDefinition
argument_list|,
name|debugAM
argument_list|,
name|lifetime
argument_list|)
decl_stmt|;
name|applicationId
operator|=
name|amLauncher
operator|.
name|getApplicationId
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Submitting application {}"
argument_list|,
name|applicationId
argument_list|)
expr_stmt|;
comment|// submit the application
name|LaunchedApplication
name|launchedApplication
init|=
name|amLauncher
operator|.
name|submitApplication
argument_list|()
decl_stmt|;
return|return
name|launchedApplication
return|;
block|}
DECL|method|getAmLaunchEnv (Configuration config)
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getAmLaunchEnv
parameter_list|(
name|Configuration
name|config
parameter_list|)
block|{
name|String
name|sliderAmLaunchEnv
init|=
name|config
operator|.
name|get
argument_list|(
name|KEY_AM_LAUNCH_ENV
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"{} = {}"
argument_list|,
name|KEY_AM_LAUNCH_ENV
argument_list|,
name|sliderAmLaunchEnv
argument_list|)
expr_stmt|;
comment|// Multiple env variables can be specified with a comma (,) separator
name|String
index|[]
name|envs
init|=
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|sliderAmLaunchEnv
argument_list|)
condition|?
literal|null
else|:
name|sliderAmLaunchEnv
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
if|if
condition|(
name|ArrayUtils
operator|.
name|isEmpty
argument_list|(
name|envs
argument_list|)
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyMap
argument_list|()
return|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|amLaunchEnv
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|env
range|:
name|envs
control|)
block|{
if|if
condition|(
name|StringUtils
operator|.
name|isNotEmpty
argument_list|(
name|env
argument_list|)
condition|)
block|{
comment|// Each env name/value is separated by equals sign (=)
name|String
index|[]
name|tokens
init|=
name|env
operator|.
name|split
argument_list|(
literal|"="
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokens
operator|!=
literal|null
operator|&&
name|tokens
operator|.
name|length
operator|==
literal|2
condition|)
block|{
name|String
name|envKey
init|=
name|tokens
index|[
literal|0
index|]
decl_stmt|;
name|String
name|envValue
init|=
name|tokens
index|[
literal|1
index|]
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|placeholder
range|:
name|generatePlaceholderKeyValueMap
argument_list|(
name|env
argument_list|)
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|StringUtils
operator|.
name|isNotEmpty
argument_list|(
name|placeholder
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|envValue
operator|=
name|envValue
operator|.
name|replaceAll
argument_list|(
name|Pattern
operator|.
name|quote
argument_list|(
name|placeholder
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
name|placeholder
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Shell
operator|.
name|WINDOWS
condition|)
block|{
name|envValue
operator|=
literal|"%"
operator|+
name|envKey
operator|+
literal|"%;"
operator|+
name|envValue
expr_stmt|;
block|}
else|else
block|{
name|envValue
operator|=
literal|"$"
operator|+
name|envKey
operator|+
literal|":"
operator|+
name|envValue
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Setting AM launch env {}={}"
argument_list|,
name|envKey
argument_list|,
name|envValue
argument_list|)
expr_stmt|;
name|amLaunchEnv
operator|.
name|put
argument_list|(
name|envKey
argument_list|,
name|envValue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|amLaunchEnv
return|;
block|}
DECL|method|generatePlaceholderKeyValueMap (String env)
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|generatePlaceholderKeyValueMap
parameter_list|(
name|String
name|env
parameter_list|)
block|{
name|String
name|PLACEHOLDER_PATTERN
init|=
literal|"\\$\\{[^{]+\\}"
decl_stmt|;
name|Pattern
name|placeholderPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|PLACEHOLDER_PATTERN
argument_list|)
decl_stmt|;
name|Matcher
name|placeholderMatcher
init|=
name|placeholderPattern
operator|.
name|matcher
argument_list|(
name|env
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|placeholderKeyValueMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|placeholderMatcher
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|placeholderKey
init|=
name|placeholderMatcher
operator|.
name|group
argument_list|()
decl_stmt|;
name|String
name|systemKey
init|=
name|placeholderKey
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
name|placeholderKey
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\\."
argument_list|,
literal|"_"
argument_list|)
decl_stmt|;
name|String
name|placeholderValue
init|=
name|getSystemEnv
argument_list|(
name|systemKey
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Placeholder {}={}"
argument_list|,
name|placeholderKey
argument_list|,
name|placeholderValue
argument_list|)
expr_stmt|;
name|placeholderKeyValueMap
operator|.
name|put
argument_list|(
name|placeholderKey
argument_list|,
name|placeholderValue
argument_list|)
expr_stmt|;
block|}
return|return
name|placeholderKeyValueMap
return|;
block|}
DECL|method|propagatePythonExecutable (Configuration config, AggregateConf instanceDefinition)
specifier|private
name|void
name|propagatePythonExecutable
parameter_list|(
name|Configuration
name|config
parameter_list|,
name|AggregateConf
name|instanceDefinition
parameter_list|)
block|{
name|String
name|pythonExec
init|=
name|config
operator|.
name|get
argument_list|(
name|PYTHON_EXECUTABLE_PATH
argument_list|)
decl_stmt|;
if|if
condition|(
name|pythonExec
operator|!=
literal|null
condition|)
block|{
name|instanceDefinition
operator|.
name|getAppConfOperations
argument_list|()
operator|.
name|getGlobalOptions
argument_list|()
operator|.
name|putIfUnset
argument_list|(
name|PYTHON_EXECUTABLE_PATH
argument_list|,
name|pythonExec
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Wait for the launched app to be accepted in the time      * and, optionally running.    *<p>    * If the application    *    * @param launchedApplication application    * @param acceptWaitMillis time in millis to wait for accept    * @param runWaitMillis time in millis to wait for the app to be running.    * May be null, in which case no wait takes place    * @return exit code: success    * @throws YarnException    * @throws IOException    */
DECL|method|waitForAppRunning (LaunchedApplication launchedApplication, int acceptWaitMillis, int runWaitMillis)
specifier|public
name|int
name|waitForAppRunning
parameter_list|(
name|LaunchedApplication
name|launchedApplication
parameter_list|,
name|int
name|acceptWaitMillis
parameter_list|,
name|int
name|runWaitMillis
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
assert|assert
name|launchedApplication
operator|!=
literal|null
assert|;
name|int
name|exitCode
decl_stmt|;
comment|// wait for the submit state to be reached
name|ApplicationReport
name|report
init|=
name|launchedApplication
operator|.
name|monitorAppToState
argument_list|(
name|YarnApplicationState
operator|.
name|ACCEPTED
argument_list|,
operator|new
name|Duration
argument_list|(
name|acceptWaitMillis
argument_list|)
argument_list|)
decl_stmt|;
comment|// may have failed, so check that
if|if
condition|(
name|hasAppFinished
argument_list|(
name|report
argument_list|)
condition|)
block|{
name|exitCode
operator|=
name|buildExitCode
argument_list|(
name|report
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// exit unless there is a wait
if|if
condition|(
name|runWaitMillis
operator|!=
literal|0
condition|)
block|{
comment|// waiting for state to change
name|Duration
name|duration
init|=
operator|new
name|Duration
argument_list|(
name|runWaitMillis
operator|*
literal|1000
argument_list|)
decl_stmt|;
name|duration
operator|.
name|start
argument_list|()
expr_stmt|;
name|report
operator|=
name|launchedApplication
operator|.
name|monitorAppToState
argument_list|(
name|YarnApplicationState
operator|.
name|RUNNING
argument_list|,
name|duration
argument_list|)
expr_stmt|;
if|if
condition|(
name|report
operator|!=
literal|null
operator|&&
name|report
operator|.
name|getYarnApplicationState
argument_list|()
operator|==
name|YarnApplicationState
operator|.
name|RUNNING
condition|)
block|{
name|exitCode
operator|=
name|EXIT_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|exitCode
operator|=
name|buildExitCode
argument_list|(
name|report
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|exitCode
operator|=
name|EXIT_SUCCESS
expr_stmt|;
block|}
block|}
return|return
name|exitCode
return|;
block|}
comment|/**    * Propagate any critical principals from the current site config down to the HBase one.    * @param config config to read from    * @param clusterSpec cluster spec    */
DECL|method|propagatePrincipals (Configuration config, AggregateConf clusterSpec)
specifier|private
name|void
name|propagatePrincipals
parameter_list|(
name|Configuration
name|config
parameter_list|,
name|AggregateConf
name|clusterSpec
parameter_list|)
block|{
name|String
name|dfsPrincipal
init|=
name|config
operator|.
name|get
argument_list|(
name|DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|dfsPrincipal
operator|!=
literal|null
condition|)
block|{
name|String
name|siteDfsPrincipal
init|=
name|SITE_XML_PREFIX
operator|+
name|DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY
decl_stmt|;
name|clusterSpec
operator|.
name|getAppConfOperations
argument_list|()
operator|.
name|getGlobalOptions
argument_list|()
operator|.
name|putIfUnset
argument_list|(
name|siteDfsPrincipal
argument_list|,
name|dfsPrincipal
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Create a path that must exist in the cluster fs    * @param uri uri to create    * @return the path    * @throws FileNotFoundException if the path does not exist    */
DECL|method|createPathThatMustExist (String uri)
specifier|public
name|Path
name|createPathThatMustExist
parameter_list|(
name|String
name|uri
parameter_list|)
throws|throws
name|SliderException
throws|,
name|IOException
block|{
return|return
name|sliderFileSystem
operator|.
name|createPathThatMustExist
argument_list|(
name|uri
argument_list|)
return|;
block|}
comment|/**    * verify that a live cluster isn't there    * @param clustername cluster name    * @param action    * @throws SliderException with exit code EXIT_CLUSTER_LIVE    * if a cluster of that name is either live or starting up.    */
DECL|method|verifyNoLiveClusters (String clustername, String action)
specifier|public
name|void
name|verifyNoLiveClusters
parameter_list|(
name|String
name|clustername
parameter_list|,
name|String
name|action
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
name|List
argument_list|<
name|ApplicationReport
argument_list|>
name|existing
init|=
name|findAllLiveInstances
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|existing
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SliderException
argument_list|(
name|EXIT_APPLICATION_IN_USE
argument_list|,
name|action
operator|+
literal|" failed for "
operator|+
name|clustername
operator|+
literal|": "
operator|+
name|E_CLUSTER_RUNNING
operator|+
literal|" :"
operator|+
name|existing
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
throw|;
block|}
block|}
DECL|method|getUsername ()
specifier|public
name|String
name|getUsername
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|RegistryUtils
operator|.
name|currentUser
argument_list|()
return|;
block|}
comment|/**    * Get the name of any deployed cluster    * @return the cluster name    */
DECL|method|getDeployedClusterName ()
specifier|public
name|String
name|getDeployedClusterName
parameter_list|()
block|{
return|return
name|deployedClusterName
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setDeployedClusterName (String deployedClusterName)
specifier|public
name|void
name|setDeployedClusterName
parameter_list|(
name|String
name|deployedClusterName
parameter_list|)
block|{
name|this
operator|.
name|deployedClusterName
operator|=
name|deployedClusterName
expr_stmt|;
block|}
comment|/**    * ask if the client is using a mini MR cluster    * @return true if they are    */
DECL|method|getUsingMiniMRCluster ()
specifier|private
name|boolean
name|getUsingMiniMRCluster
parameter_list|()
block|{
return|return
name|getConfig
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|YarnConfiguration
operator|.
name|IS_MINI_YARN_CLUSTER
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Get the application name used in the zookeeper root paths    * @return an application-specific path in ZK    */
DECL|method|getAppName ()
specifier|private
name|String
name|getAppName
parameter_list|()
block|{
return|return
literal|"slider"
return|;
block|}
comment|/**    * Wait for the app to start running (or go past that state)    * @param duration time to wait    * @return the app report; null if the duration turned out    * @throws YarnException YARN or app issues    * @throws IOException IO problems    */
annotation|@
name|VisibleForTesting
DECL|method|monitorAppToRunning (Duration duration)
specifier|public
name|ApplicationReport
name|monitorAppToRunning
parameter_list|(
name|Duration
name|duration
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
return|return
name|monitorAppToState
argument_list|(
name|YarnApplicationState
operator|.
name|RUNNING
argument_list|,
name|duration
argument_list|)
return|;
block|}
comment|/**    * Build an exit code for an application from its report.    * If the report parameter is null, its interpreted as a timeout    * @param report report application report    * @return the exit code    * @throws IOException    * @throws YarnException    */
DECL|method|buildExitCode (ApplicationReport report)
specifier|private
name|int
name|buildExitCode
parameter_list|(
name|ApplicationReport
name|report
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
if|if
condition|(
literal|null
operator|==
name|report
condition|)
block|{
return|return
name|EXIT_TIMED_OUT
return|;
block|}
name|YarnApplicationState
name|state
init|=
name|report
operator|.
name|getYarnApplicationState
argument_list|()
decl_stmt|;
name|FinalApplicationStatus
name|dsStatus
init|=
name|report
operator|.
name|getFinalApplicationStatus
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|FINISHED
case|:
if|if
condition|(
name|FinalApplicationStatus
operator|.
name|SUCCEEDED
operator|==
name|dsStatus
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Application has completed successfully"
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Application finished unsuccessfully."
operator|+
literal|"YarnState = {}, DSFinalStatus = {} Breaking monitoring loop"
argument_list|,
name|state
argument_list|,
name|dsStatus
argument_list|)
expr_stmt|;
return|return
name|EXIT_YARN_SERVICE_FINISHED_WITH_ERROR
return|;
block|}
case|case
name|KILLED
case|:
name|log
operator|.
name|info
argument_list|(
literal|"Application did not finish. YarnState={}, DSFinalStatus={}"
argument_list|,
name|state
argument_list|,
name|dsStatus
argument_list|)
expr_stmt|;
return|return
name|EXIT_YARN_SERVICE_KILLED
return|;
case|case
name|FAILED
case|:
name|log
operator|.
name|info
argument_list|(
literal|"Application Failed. YarnState={}, DSFinalStatus={}"
argument_list|,
name|state
argument_list|,
name|dsStatus
argument_list|)
expr_stmt|;
return|return
name|EXIT_YARN_SERVICE_FAILED
return|;
default|default:
comment|//not in any of these states
return|return
name|EXIT_SUCCESS
return|;
block|}
block|}
comment|/**    * Monitor the submitted application for reaching the requested state.    * Will also report if the app reaches a later state (failed, killed, etc)    * Kill application if duration!= null& time expires.     * Prerequisite: the applicatin was launched.    * @param desiredState desired state.    * @param duration how long to wait -must be more than 0    * @return the application report -null on a timeout    * @throws YarnException    * @throws IOException    */
annotation|@
name|VisibleForTesting
DECL|method|monitorAppToState ( YarnApplicationState desiredState, Duration duration)
specifier|public
name|ApplicationReport
name|monitorAppToState
parameter_list|(
name|YarnApplicationState
name|desiredState
parameter_list|,
name|Duration
name|duration
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|LaunchedApplication
name|launchedApplication
init|=
operator|new
name|LaunchedApplication
argument_list|(
name|applicationId
argument_list|,
name|yarnClient
argument_list|)
decl_stmt|;
return|return
name|launchedApplication
operator|.
name|monitorAppToState
argument_list|(
name|desiredState
argument_list|,
name|duration
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getApplicationReport ()
specifier|public
name|ApplicationReport
name|getApplicationReport
parameter_list|()
throws|throws
name|IOException
throws|,
name|YarnException
block|{
return|return
name|getApplicationReport
argument_list|(
name|applicationId
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|forceKillApplication (String reason)
specifier|public
name|boolean
name|forceKillApplication
parameter_list|(
name|String
name|reason
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
if|if
condition|(
name|applicationId
operator|!=
literal|null
condition|)
block|{
operator|new
name|LaunchedApplication
argument_list|(
name|applicationId
argument_list|,
name|yarnClient
argument_list|)
operator|.
name|forceKill
argument_list|(
name|reason
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * List Slider instances belonging to a specific user. This will include    * failed and killed instances; there may be duplicates    * @param user user: "" means all users, null means "default"    * @return a possibly empty list of Slider AMs    */
DECL|method|listSliderInstances (String user)
specifier|public
name|List
argument_list|<
name|ApplicationReport
argument_list|>
name|listSliderInstances
parameter_list|(
name|String
name|user
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
return|return
name|yarnAppListClient
operator|.
name|listInstances
argument_list|(
name|user
argument_list|)
return|;
block|}
comment|/**    * A basic list action to list live instances    * @param clustername cluster name    * @return success if the listing was considered successful    * @throws IOException    * @throws YarnException    */
DECL|method|actionList (String clustername)
specifier|public
name|int
name|actionList
parameter_list|(
name|String
name|clustername
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
name|ActionListArgs
name|args
init|=
operator|new
name|ActionListArgs
argument_list|()
decl_stmt|;
name|args
operator|.
name|live
operator|=
literal|true
expr_stmt|;
return|return
name|actionList
argument_list|(
name|clustername
argument_list|,
name|args
argument_list|)
return|;
block|}
comment|/**    * Implement the list action.    * @param clustername List out specific instance name    * @param args Action list arguments    * @return 0 if one or more entries were listed    * @throws IOException    * @throws YarnException    * @throws UnknownApplicationInstanceException if a specific instance    * was named but it was not found    */
annotation|@
name|Override
DECL|method|actionList (String clustername, ActionListArgs args)
specifier|public
name|int
name|actionList
parameter_list|(
name|String
name|clustername
parameter_list|,
name|ActionListArgs
name|args
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|appInstances
init|=
name|getApplicationList
argument_list|(
name|clustername
argument_list|,
name|args
argument_list|)
decl_stmt|;
comment|// getApplicationList never returns null
return|return
operator|!
name|appInstances
operator|.
name|isEmpty
argument_list|()
condition|?
name|EXIT_SUCCESS
else|:
operator|(
operator|(
name|appInstances
operator|.
name|isEmpty
argument_list|()
operator|&&
name|isUnset
argument_list|(
name|clustername
argument_list|)
operator|)
condition|?
name|EXIT_SUCCESS
else|:
name|EXIT_FALSE
operator|)
return|;
block|}
comment|/**    * Retrieve a list of all live instances. If clustername is supplied then it    * returns this specific cluster, if and only if it exists and is live.    *     * @param clustername    *          cluster name (if looking for a specific live cluster)    * @return the list of application names which satisfies the list criteria    * @throws IOException    * @throws YarnException    */
DECL|method|getApplicationList (String clustername)
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getApplicationList
parameter_list|(
name|String
name|clustername
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
name|ActionListArgs
name|args
init|=
operator|new
name|ActionListArgs
argument_list|()
decl_stmt|;
name|args
operator|.
name|live
operator|=
literal|true
expr_stmt|;
return|return
name|getApplicationList
argument_list|(
name|clustername
argument_list|,
name|args
argument_list|)
return|;
block|}
comment|/**    * Retrieve a list of application instances satisfying the query criteria.    *     * @param clustername    *          List out specific instance name (set null for all)    * @param args    *          Action list arguments    * @return the list of application names which satisfies the list criteria    * @throws IOException    * @throws YarnException    * @throws UnknownApplicationInstanceException    *           if a specific instance was named but it was not found    */
DECL|method|getApplicationList (String clustername, ActionListArgs args)
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getApplicationList
parameter_list|(
name|String
name|clustername
parameter_list|,
name|ActionListArgs
name|args
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
if|if
condition|(
name|args
operator|.
name|help
condition|)
block|{
name|actionHelp
argument_list|(
name|ACTION_LIST
argument_list|)
expr_stmt|;
comment|// the above call throws an exception so the return is not really required
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
name|verifyBindingsDefined
argument_list|()
expr_stmt|;
name|boolean
name|live
init|=
name|args
operator|.
name|live
decl_stmt|;
name|String
name|state
init|=
name|args
operator|.
name|state
decl_stmt|;
name|boolean
name|listContainers
init|=
name|args
operator|.
name|containers
decl_stmt|;
name|boolean
name|verbose
init|=
name|args
operator|.
name|verbose
decl_stmt|;
name|String
name|version
init|=
name|args
operator|.
name|version
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|components
init|=
name|args
operator|.
name|components
decl_stmt|;
if|if
condition|(
name|live
operator|&&
operator|!
name|state
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
name|Arguments
operator|.
name|ARG_LIVE
operator|+
literal|" and "
operator|+
name|Arguments
operator|.
name|ARG_STATE
operator|+
literal|" are exclusive"
argument_list|)
throw|;
block|}
if|if
condition|(
name|listContainers
operator|&&
name|isUnset
argument_list|(
name|clustername
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"Should specify an application instance with "
operator|+
name|Arguments
operator|.
name|ARG_CONTAINERS
argument_list|)
throw|;
block|}
comment|// specifying both --version and --components with --containers is okay
if|if
condition|(
name|StringUtils
operator|.
name|isNotEmpty
argument_list|(
name|version
argument_list|)
operator|&&
operator|!
name|listContainers
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
name|Arguments
operator|.
name|ARG_VERSION
operator|+
literal|" can be specified only with "
operator|+
name|Arguments
operator|.
name|ARG_CONTAINERS
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|components
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|listContainers
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
name|Arguments
operator|.
name|ARG_COMPONENTS
operator|+
literal|" can be specified only with "
operator|+
name|Arguments
operator|.
name|ARG_CONTAINERS
argument_list|)
throw|;
block|}
comment|// flag to indicate only services in a specific state are to be listed
name|boolean
name|listOnlyInState
init|=
name|live
operator|||
operator|!
name|state
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
name|YarnApplicationState
name|min
decl_stmt|,
name|max
decl_stmt|;
if|if
condition|(
name|live
condition|)
block|{
name|min
operator|=
name|YarnApplicationState
operator|.
name|NEW
expr_stmt|;
name|max
operator|=
name|YarnApplicationState
operator|.
name|RUNNING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|state
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|YarnApplicationState
name|stateVal
init|=
name|extractYarnApplicationState
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|min
operator|=
name|max
operator|=
name|stateVal
expr_stmt|;
block|}
else|else
block|{
name|min
operator|=
name|YarnApplicationState
operator|.
name|NEW
expr_stmt|;
name|max
operator|=
name|YarnApplicationState
operator|.
name|KILLED
expr_stmt|;
block|}
comment|// get the complete list of persistent instances
name|Map
argument_list|<
name|String
argument_list|,
name|Path
argument_list|>
name|persistentInstances
init|=
name|sliderFileSystem
operator|.
name|listPersistentInstances
argument_list|()
decl_stmt|;
if|if
condition|(
name|persistentInstances
operator|.
name|isEmpty
argument_list|()
operator|&&
name|isUnset
argument_list|(
name|clustername
argument_list|)
condition|)
block|{
comment|// an empty listing is a success if no cluster was named
name|log
operator|.
name|debug
argument_list|(
literal|"No application instances found"
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
comment|// and those the RM knows about
name|List
argument_list|<
name|ApplicationReport
argument_list|>
name|instances
init|=
name|listSliderInstances
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|sortApplicationsByMostRecent
argument_list|(
name|instances
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ApplicationReport
argument_list|>
name|reportMap
init|=
name|buildApplicationReportMap
argument_list|(
name|instances
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Persisted {} deployed {} filtered[{}-{}]& de-duped to {}"
argument_list|,
name|persistentInstances
operator|.
name|size
argument_list|()
argument_list|,
name|instances
operator|.
name|size
argument_list|()
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|reportMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ContainerInformation
argument_list|>
name|containers
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isSet
argument_list|(
name|clustername
argument_list|)
condition|)
block|{
comment|// only one instance is expected
comment|// resolve the persistent value
name|Path
name|persistent
init|=
name|persistentInstances
operator|.
name|get
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
if|if
condition|(
name|persistent
operator|==
literal|null
condition|)
block|{
throw|throw
name|unknownClusterException
argument_list|(
name|clustername
argument_list|)
throw|;
block|}
comment|// create a new map with only that instance in it.
comment|// this restricts the output of results to this instance
name|persistentInstances
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|persistentInstances
operator|.
name|put
argument_list|(
name|clustername
argument_list|,
name|persistent
argument_list|)
expr_stmt|;
if|if
condition|(
name|listContainers
condition|)
block|{
name|containers
operator|=
name|getContainers
argument_list|(
name|clustername
argument_list|)
expr_stmt|;
block|}
block|}
comment|// at this point there is either the entire list or a stripped down instance
name|Set
argument_list|<
name|String
argument_list|>
name|listedInstances
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|persistentInstances
operator|.
name|keySet
argument_list|()
control|)
block|{
name|ApplicationReport
name|report
init|=
name|reportMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|listOnlyInState
operator|||
name|report
operator|!=
literal|null
condition|)
block|{
comment|// list the details if all were requested, or the filtering contained
comment|// a report
name|listedInstances
operator|.
name|add
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|// containers will be non-null when only one instance is requested
name|String
name|details
init|=
name|instanceDetailsToString
argument_list|(
name|name
argument_list|,
name|report
argument_list|,
name|containers
argument_list|,
name|version
argument_list|,
name|components
argument_list|,
name|verbose
argument_list|)
decl_stmt|;
name|print
argument_list|(
name|details
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|listedInstances
return|;
block|}
DECL|method|getContainers (String name)
specifier|public
name|List
argument_list|<
name|ContainerInformation
argument_list|>
name|getContainers
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|SliderClusterOperations
name|clusterOps
init|=
operator|new
name|SliderClusterOperations
argument_list|(
name|bondToCluster
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|clusterOps
operator|.
name|getContainers
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchNodeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|BadClusterStateException
argument_list|(
literal|"Containers not found for application instance %s"
argument_list|,
name|name
argument_list|)
throw|;
block|}
block|}
comment|/**    * Enumerate slider instances for the current user, and the    * most recent app report, where available.    * @param listOnlyInState boolean to indicate that the instances should    * only include those in a YARN state    *<code> minAppState&lt;= currentState&lt;= maxAppState</code>    *    * @param minAppState minimum application state to include in enumeration.    * @param maxAppState maximum application state to include    * @return a map of application instance name to description    * @throws IOException Any IO problem    * @throws YarnException YARN problems    */
annotation|@
name|Override
DECL|method|enumSliderInstances ( boolean listOnlyInState, YarnApplicationState minAppState, YarnApplicationState maxAppState)
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|SliderInstanceDescription
argument_list|>
name|enumSliderInstances
parameter_list|(
name|boolean
name|listOnlyInState
parameter_list|,
name|YarnApplicationState
name|minAppState
parameter_list|,
name|YarnApplicationState
name|maxAppState
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
return|return
name|yarnAppListClient
operator|.
name|enumSliderInstances
argument_list|(
name|listOnlyInState
argument_list|,
name|minAppState
argument_list|,
name|maxAppState
argument_list|)
return|;
block|}
comment|/**    * Extract the state of a Yarn application --state argument    * @param state state argument    * @return the application state    * @throws BadCommandArgumentsException if the argument did not match    * any known state    */
DECL|method|extractYarnApplicationState (String state)
specifier|private
name|YarnApplicationState
name|extractYarnApplicationState
parameter_list|(
name|String
name|state
parameter_list|)
throws|throws
name|BadCommandArgumentsException
block|{
name|YarnApplicationState
name|stateVal
decl_stmt|;
try|try
block|{
name|stateVal
operator|=
name|YarnApplicationState
operator|.
name|valueOf
argument_list|(
name|state
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"Unknown state: "
operator|+
name|state
argument_list|)
throw|;
block|}
return|return
name|stateVal
return|;
block|}
comment|/**    * Is an application active: accepted or running    * @param report the application report    * @return true if it is running or scheduled to run.    */
DECL|method|isApplicationActive (ApplicationReport report)
specifier|public
name|boolean
name|isApplicationActive
parameter_list|(
name|ApplicationReport
name|report
parameter_list|)
block|{
return|return
name|report
operator|.
name|getYarnApplicationState
argument_list|()
operator|==
name|YarnApplicationState
operator|.
name|RUNNING
operator|||
name|report
operator|.
name|getYarnApplicationState
argument_list|()
operator|==
name|YarnApplicationState
operator|.
name|ACCEPTED
return|;
block|}
comment|/**    * Implement the islive action: probe for a cluster of the given name existing    * @return exit code    */
annotation|@
name|Override
annotation|@
name|VisibleForTesting
DECL|method|actionFlex (String name, ActionFlexArgs args)
specifier|public
name|int
name|actionFlex
parameter_list|(
name|String
name|name
parameter_list|,
name|ActionFlexArgs
name|args
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|validateClusterName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|roleMap
init|=
name|args
operator|.
name|getComponentMap
argument_list|()
decl_stmt|;
comment|// throw usage exception if no changes proposed
if|if
condition|(
name|roleMap
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|actionHelp
argument_list|(
name|ACTION_FLEX
argument_list|)
expr_stmt|;
block|}
name|verifyBindingsDefined
argument_list|()
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"actionFlex({})"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|roleInstances
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|roleEntry
range|:
name|roleMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|roleEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|val
init|=
name|roleEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|roleInstances
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|flex
argument_list|(
name|name
argument_list|,
name|roleInstances
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|actionExists (String name, boolean checkLive)
specifier|public
name|int
name|actionExists
parameter_list|(
name|String
name|name
parameter_list|,
name|boolean
name|checkLive
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|ActionExistsArgs
name|args
init|=
operator|new
name|ActionExistsArgs
argument_list|()
decl_stmt|;
name|args
operator|.
name|live
operator|=
name|checkLive
expr_stmt|;
return|return
name|actionExists
argument_list|(
name|name
argument_list|,
name|args
argument_list|)
return|;
block|}
DECL|method|actionExists (String name, ActionExistsArgs args)
specifier|public
name|int
name|actionExists
parameter_list|(
name|String
name|name
parameter_list|,
name|ActionExistsArgs
name|args
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|verifyBindingsDefined
argument_list|()
expr_stmt|;
name|validateClusterName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|boolean
name|checkLive
init|=
name|args
operator|.
name|live
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"actionExists({}, {}, {})"
argument_list|,
name|name
argument_list|,
name|checkLive
argument_list|,
name|args
operator|.
name|state
argument_list|)
expr_stmt|;
comment|//initial probe for a cluster in the filesystem
name|Path
name|clusterDirectory
init|=
name|sliderFileSystem
operator|.
name|buildClusterDirPath
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
operator|.
name|exists
argument_list|(
name|clusterDirectory
argument_list|)
condition|)
block|{
throw|throw
name|unknownClusterException
argument_list|(
name|name
argument_list|)
throw|;
block|}
name|String
name|state
init|=
name|args
operator|.
name|state
decl_stmt|;
if|if
condition|(
operator|!
name|checkLive
operator|&&
name|isUnset
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Application {} exists"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
comment|//test for liveness/state
name|boolean
name|inDesiredState
init|=
literal|false
decl_stmt|;
name|ApplicationReport
name|instance
decl_stmt|;
name|instance
operator|=
name|findInstance
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Application {} not running"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|EXIT_FALSE
return|;
block|}
if|if
condition|(
name|checkLive
condition|)
block|{
comment|// the app exists, check that it is not in any terminated state
name|YarnApplicationState
name|appstate
init|=
name|instance
operator|.
name|getYarnApplicationState
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|" current app state = {}"
argument_list|,
name|appstate
argument_list|)
expr_stmt|;
name|inDesiredState
operator|=
name|appstate
operator|.
name|ordinal
argument_list|()
operator|<
name|YarnApplicationState
operator|.
name|FINISHED
operator|.
name|ordinal
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// scan for instance in single --state state
name|List
argument_list|<
name|ApplicationReport
argument_list|>
name|userInstances
init|=
name|yarnClient
operator|.
name|listDeployedInstances
argument_list|(
literal|""
argument_list|)
decl_stmt|;
name|state
operator|=
name|state
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
expr_stmt|;
name|YarnApplicationState
name|desiredState
init|=
name|extractYarnApplicationState
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|ApplicationReport
name|foundInstance
init|=
name|yarnClient
operator|.
name|findAppInInstanceList
argument_list|(
name|userInstances
argument_list|,
name|name
argument_list|,
name|desiredState
argument_list|)
decl_stmt|;
if|if
condition|(
name|foundInstance
operator|!=
literal|null
condition|)
block|{
comment|// found in selected state: success
name|inDesiredState
operator|=
literal|true
expr_stmt|;
comment|// mark this as the instance to report
name|instance
operator|=
name|foundInstance
expr_stmt|;
block|}
block|}
name|OnDemandReportStringifier
name|report
init|=
operator|new
name|OnDemandReportStringifier
argument_list|(
name|instance
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|inDesiredState
condition|)
block|{
comment|//cluster in the list of apps but not running
name|log
operator|.
name|info
argument_list|(
literal|"Application {} found but is in wrong state {}"
argument_list|,
name|name
argument_list|,
name|instance
operator|.
name|getYarnApplicationState
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"State {}"
argument_list|,
name|report
argument_list|)
expr_stmt|;
return|return
name|EXIT_FALSE
return|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Application instance is in desired state"
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Application {} is {}\n{}"
argument_list|,
name|name
argument_list|,
name|instance
operator|.
name|getYarnApplicationState
argument_list|()
argument_list|,
name|report
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|actionKillContainer (String name, ActionKillContainerArgs args)
specifier|public
name|int
name|actionKillContainer
parameter_list|(
name|String
name|name
parameter_list|,
name|ActionKillContainerArgs
name|args
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|String
name|id
init|=
name|args
operator|.
name|id
decl_stmt|;
if|if
condition|(
name|isUnset
argument_list|(
name|id
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"Missing container id"
argument_list|)
throw|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"killingContainer {}:{}"
argument_list|,
name|name
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|SliderClusterOperations
name|clusterOps
init|=
operator|new
name|SliderClusterOperations
argument_list|(
name|bondToCluster
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|clusterOps
operator|.
name|killContainer
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchNodeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|BadClusterStateException
argument_list|(
literal|"Container %s not found in cluster %s"
argument_list|,
name|id
argument_list|,
name|name
argument_list|)
throw|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
annotation|@
name|Override
DECL|method|actionEcho (String name, ActionEchoArgs args)
specifier|public
name|String
name|actionEcho
parameter_list|(
name|String
name|name
parameter_list|,
name|ActionEchoArgs
name|args
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|String
name|message
init|=
name|args
operator|.
name|message
decl_stmt|;
if|if
condition|(
name|message
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"missing message"
argument_list|)
throw|;
block|}
name|SliderClusterOperations
name|clusterOps
init|=
operator|new
name|SliderClusterOperations
argument_list|(
name|bondToCluster
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|clusterOps
operator|.
name|echo
argument_list|(
name|message
argument_list|)
return|;
block|}
comment|/**    * Get at the service registry operations    * @return registry client -valid after the service is inited.    */
DECL|method|getYarnAppListClient ()
specifier|public
name|YarnAppListClient
name|getYarnAppListClient
parameter_list|()
block|{
return|return
name|yarnAppListClient
return|;
block|}
comment|/**    * Find an instance of an application belonging to the current user    * @param appname application name    * @return the app report or null if none is found    * @throws YarnException YARN issues    * @throws IOException IO problems    */
DECL|method|findInstance (String appname)
specifier|private
name|ApplicationReport
name|findInstance
parameter_list|(
name|String
name|appname
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
return|return
name|yarnAppListClient
operator|.
name|findInstance
argument_list|(
name|appname
argument_list|)
return|;
block|}
DECL|method|findApplication (String appname)
specifier|private
name|RunningApplication
name|findApplication
parameter_list|(
name|String
name|appname
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|ApplicationReport
name|applicationReport
init|=
name|findInstance
argument_list|(
name|appname
argument_list|)
decl_stmt|;
return|return
name|applicationReport
operator|!=
literal|null
condition|?
operator|new
name|RunningApplication
argument_list|(
name|yarnClient
argument_list|,
name|applicationReport
argument_list|)
else|:
literal|null
return|;
block|}
comment|/**    * find all live instances of a specific app -if there is>1 in the cluster,    * this returns them all. State should be running or less    * @param appname application name    * @return the list of all matching application instances    */
DECL|method|findAllLiveInstances (String appname)
specifier|private
name|List
argument_list|<
name|ApplicationReport
argument_list|>
name|findAllLiveInstances
parameter_list|(
name|String
name|appname
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
return|return
name|yarnAppListClient
operator|.
name|findAllLiveInstances
argument_list|(
name|appname
argument_list|)
return|;
block|}
comment|/**    * Connect to a Slider AM    * @param app application report providing the details on the application    * @return an instance    * @throws YarnException    * @throws IOException    */
DECL|method|connect (ApplicationReport app)
specifier|private
name|SliderClusterProtocol
name|connect
parameter_list|(
name|ApplicationReport
name|app
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
try|try
block|{
return|return
name|RpcBinder
operator|.
name|getProxy
argument_list|(
name|getConfig
argument_list|()
argument_list|,
name|yarnClient
operator|.
name|getRmClient
argument_list|()
argument_list|,
name|app
argument_list|,
name|Constants
operator|.
name|CONNECT_TIMEOUT
argument_list|,
name|Constants
operator|.
name|RPC_TIMEOUT
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SliderException
argument_list|(
name|SliderExitCodes
operator|.
name|EXIT_TIMED_OUT
argument_list|,
name|e
argument_list|,
literal|"Interrupted waiting for communications with the Slider AM"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|VisibleForTesting
DECL|method|actionStatus (String clustername, ActionStatusArgs statusArgs)
specifier|public
name|int
name|actionStatus
parameter_list|(
name|String
name|clustername
parameter_list|,
name|ActionStatusArgs
name|statusArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|ClusterDescription
name|status
init|=
name|verifyAndGetClusterDescription
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
name|String
name|outfile
init|=
name|statusArgs
operator|.
name|getOutput
argument_list|()
decl_stmt|;
if|if
condition|(
name|outfile
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
name|status
operator|.
name|toJsonString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|.
name|save
argument_list|(
operator|new
name|File
argument_list|(
name|outfile
argument_list|)
operator|.
name|getAbsoluteFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
annotation|@
name|Override
DECL|method|actionStatus (String clustername)
specifier|public
name|String
name|actionStatus
parameter_list|(
name|String
name|clustername
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
return|return
name|verifyAndGetClusterDescription
argument_list|(
name|clustername
argument_list|)
operator|.
name|toJsonString
argument_list|()
return|;
block|}
DECL|method|verifyAndGetClusterDescription (String clustername)
specifier|private
name|ClusterDescription
name|verifyAndGetClusterDescription
parameter_list|(
name|String
name|clustername
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|verifyBindingsDefined
argument_list|()
expr_stmt|;
name|validateClusterName
argument_list|(
name|clustername
argument_list|)
expr_stmt|;
return|return
name|getClusterDescription
argument_list|(
name|clustername
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|actionVersion ()
specifier|public
name|int
name|actionVersion
parameter_list|()
block|{
name|SliderVersionInfo
operator|.
name|loadAndPrintVersionInfo
argument_list|(
name|log
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
annotation|@
name|Override
DECL|method|actionFreeze (String clustername, ActionFreezeArgs freezeArgs)
specifier|public
name|int
name|actionFreeze
parameter_list|(
name|String
name|clustername
parameter_list|,
name|ActionFreezeArgs
name|freezeArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|verifyBindingsDefined
argument_list|()
expr_stmt|;
name|validateClusterName
argument_list|(
name|clustername
argument_list|)
expr_stmt|;
name|int
name|waittime
init|=
name|freezeArgs
operator|.
name|getWaittime
argument_list|()
decl_stmt|;
name|String
name|text
init|=
name|freezeArgs
operator|.
name|message
decl_stmt|;
name|boolean
name|forcekill
init|=
name|freezeArgs
operator|.
name|force
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"actionFreeze({}, reason={}, wait={}, force={})"
argument_list|,
name|clustername
argument_list|,
name|text
argument_list|,
name|waittime
argument_list|,
name|forcekill
argument_list|)
expr_stmt|;
comment|//is this actually a known cluster?
name|sliderFileSystem
operator|.
name|locateInstanceDefinition
argument_list|(
name|clustername
argument_list|)
expr_stmt|;
name|ApplicationReport
name|app
init|=
name|findInstance
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
if|if
condition|(
name|app
operator|==
literal|null
condition|)
block|{
comment|// exit early
name|log
operator|.
name|info
argument_list|(
literal|"Cluster {} not running"
argument_list|,
name|clustername
argument_list|)
expr_stmt|;
comment|// not an error to stop a stopped cluster
return|return
name|EXIT_SUCCESS
return|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"App to stop was found: {}:\n{}"
argument_list|,
name|clustername
argument_list|,
operator|new
name|OnDemandReportStringifier
argument_list|(
name|app
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|app
operator|.
name|getYarnApplicationState
argument_list|()
operator|.
name|ordinal
argument_list|()
operator|>=
name|YarnApplicationState
operator|.
name|FINISHED
operator|.
name|ordinal
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Cluster {} is in a terminated state {}"
argument_list|,
name|clustername
argument_list|,
name|app
operator|.
name|getYarnApplicationState
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
comment|// IPC request for a managed shutdown is only possible if the app is running.
comment|// so we need to force kill if the app is accepted or submitted
if|if
condition|(
operator|!
name|forcekill
operator|&&
name|app
operator|.
name|getYarnApplicationState
argument_list|()
operator|.
name|ordinal
argument_list|()
operator|<
name|YarnApplicationState
operator|.
name|RUNNING
operator|.
name|ordinal
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Cluster {} is in a pre-running state {}. Force killing it"
argument_list|,
name|clustername
argument_list|,
name|app
operator|.
name|getYarnApplicationState
argument_list|()
argument_list|)
expr_stmt|;
name|forcekill
operator|=
literal|true
expr_stmt|;
block|}
name|LaunchedApplication
name|application
init|=
operator|new
name|LaunchedApplication
argument_list|(
name|yarnClient
argument_list|,
name|app
argument_list|)
decl_stmt|;
name|applicationId
operator|=
name|application
operator|.
name|getApplicationId
argument_list|()
expr_stmt|;
if|if
condition|(
name|forcekill
condition|)
block|{
comment|// escalating to forced kill
name|application
operator|.
name|kill
argument_list|(
literal|"Forced stop of "
operator|+
name|clustername
operator|+
literal|": "
operator|+
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|SliderClusterProtocol
name|appMaster
init|=
name|connect
argument_list|(
name|app
argument_list|)
decl_stmt|;
name|Messages
operator|.
name|StopClusterRequestProto
name|r
init|=
name|Messages
operator|.
name|StopClusterRequestProto
operator|.
name|newBuilder
argument_list|()
operator|.
name|setMessage
argument_list|(
name|text
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|appMaster
operator|.
name|stopCluster
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Cluster stop command issued"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|YarnException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Exception while trying to terminate {}"
argument_list|,
name|clustername
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|EXIT_FALSE
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Exception while trying to terminate {}"
argument_list|,
name|clustername
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|EXIT_FALSE
return|;
block|}
block|}
comment|//wait for completion. We don't currently return an exception during this process
comment|//as the stop operation has been issued, this is just YARN.
try|try
block|{
if|if
condition|(
name|waittime
operator|>
literal|0
condition|)
block|{
name|ApplicationReport
name|applicationReport
init|=
name|application
operator|.
name|monitorAppToState
argument_list|(
name|YarnApplicationState
operator|.
name|FINISHED
argument_list|,
operator|new
name|Duration
argument_list|(
name|waittime
operator|*
literal|1000
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|applicationReport
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"application did not shut down in time"
argument_list|)
expr_stmt|;
return|return
name|EXIT_FALSE
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|YarnException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Exception while waiting for the application {} to shut down: {}"
argument_list|,
name|clustername
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
annotation|@
name|Override
DECL|method|actionThaw (String clustername, ActionThawArgs thaw)
specifier|public
name|int
name|actionThaw
parameter_list|(
name|String
name|clustername
parameter_list|,
name|ActionThawArgs
name|thaw
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|validateClusterName
argument_list|(
name|clustername
argument_list|)
expr_stmt|;
name|verifyBindingsDefined
argument_list|()
expr_stmt|;
comment|// see if it is actually running and bail out;
name|verifyNoLiveClusters
argument_list|(
name|clustername
argument_list|,
literal|"Start"
argument_list|)
expr_stmt|;
comment|//start the cluster
return|return
name|startCluster
argument_list|(
name|clustername
argument_list|,
name|thaw
argument_list|,
name|thaw
operator|.
name|lifetime
argument_list|)
return|;
block|}
comment|/**    * Implement flexing    * @param clustername name of the cluster    * @param roleInstances map of new role instances    * @return EXIT_SUCCESS if the #of nodes in a live cluster changed    * @throws YarnException    * @throws IOException    */
DECL|method|flex (String clustername, Map<String, String> roleInstances)
specifier|public
name|int
name|flex
parameter_list|(
name|String
name|clustername
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|roleInstances
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|verifyBindingsDefined
argument_list|()
expr_stmt|;
name|validateClusterName
argument_list|(
name|clustername
argument_list|)
expr_stmt|;
name|Path
name|clusterDirectory
init|=
name|sliderFileSystem
operator|.
name|buildClusterDirPath
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
name|AggregateConf
name|instanceDefinition
init|=
name|loadInstanceDefinitionUnresolved
argument_list|(
name|clustername
argument_list|,
name|clusterDirectory
argument_list|)
decl_stmt|;
name|ConfTreeOperations
name|resources
init|=
name|instanceDefinition
operator|.
name|getResourceOperations
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|roleInstances
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|role
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|updateCountStr
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|int
name|currentCount
init|=
literal|0
decl_stmt|;
name|MapOperations
name|component
init|=
name|resources
operator|.
name|getOrAddComponent
argument_list|(
name|role
argument_list|)
decl_stmt|;
try|try
block|{
comment|// check if a relative count is specified
if|if
condition|(
name|updateCountStr
operator|.
name|startsWith
argument_list|(
literal|"+"
argument_list|)
operator|||
name|updateCountStr
operator|.
name|startsWith
argument_list|(
literal|"-"
argument_list|)
condition|)
block|{
name|int
name|updateCount
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|updateCountStr
argument_list|)
decl_stmt|;
comment|// if component was specified before, get the current count
if|if
condition|(
name|component
operator|.
name|get
argument_list|(
name|COMPONENT_INSTANCES
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|currentCount
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|component
operator|.
name|get
argument_list|(
name|COMPONENT_INSTANCES
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentCount
operator|+
name|updateCount
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"The requested count "
operator|+
literal|"of \"%s\" for role %s makes the total number of "
operator|+
literal|"instances negative: \"%s\""
argument_list|,
name|updateCount
argument_list|,
name|role
argument_list|,
name|currentCount
operator|+
name|updateCount
argument_list|)
throw|;
block|}
else|else
block|{
name|component
operator|.
name|put
argument_list|(
name|COMPONENT_INSTANCES
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|currentCount
operator|+
name|updateCount
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|updateCount
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"Invalid to request "
operator|+
literal|"negative count of \"%s\" for role %s"
argument_list|,
name|updateCount
argument_list|,
name|role
argument_list|)
throw|;
block|}
else|else
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|resources
operator|.
name|confTree
operator|.
name|components
operator|.
name|put
argument_list|(
name|role
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|component
operator|=
operator|new
name|MapOperations
argument_list|(
name|role
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|component
operator|.
name|put
argument_list|(
name|COMPONENT_INSTANCES
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|updateCount
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|int
name|count
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|updateCountStr
argument_list|)
decl_stmt|;
name|resources
operator|.
name|getOrAddComponent
argument_list|(
name|role
argument_list|)
operator|.
name|put
argument_list|(
name|COMPONENT_INSTANCES
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|count
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"Requested count of role %s"
operator|+
literal|" is not a number: \"%s\""
argument_list|,
name|role
argument_list|,
name|updateCountStr
argument_list|)
throw|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"Flexed cluster specification ( {} -> {}) : \n{}"
argument_list|,
name|role
argument_list|,
name|updateCountStr
argument_list|,
name|resources
argument_list|)
expr_stmt|;
block|}
name|SliderAMClientProvider
name|sliderAM
init|=
operator|new
name|SliderAMClientProvider
argument_list|(
name|getConfig
argument_list|()
argument_list|)
decl_stmt|;
name|AbstractClientProvider
name|provider
init|=
name|createClientProvider
argument_list|(
name|instanceDefinition
operator|.
name|getInternalOperations
argument_list|()
operator|.
name|getGlobalOptions
argument_list|()
operator|.
name|getMandatoryOption
argument_list|(
name|INTERNAL_PROVIDER_NAME
argument_list|)
argument_list|)
decl_stmt|;
comment|// slider provider to validate what there is
name|validateInstanceDefinition
argument_list|(
name|sliderAM
argument_list|,
name|instanceDefinition
argument_list|,
name|sliderFileSystem
argument_list|)
expr_stmt|;
name|validateInstanceDefinition
argument_list|(
name|provider
argument_list|,
name|instanceDefinition
argument_list|,
name|sliderFileSystem
argument_list|)
expr_stmt|;
name|int
name|exitCode
init|=
name|EXIT_FALSE
decl_stmt|;
comment|// save the specification
try|try
block|{
name|InstanceIO
operator|.
name|saveInstanceDefinition
argument_list|(
name|sliderFileSystem
argument_list|,
name|clusterDirectory
argument_list|,
name|instanceDefinition
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockAcquireFailedException
name|e
parameter_list|)
block|{
comment|// lock failure
name|log
operator|.
name|debug
argument_list|(
literal|"Failed to lock dir {}"
argument_list|,
name|clusterDirectory
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|"Failed to save new resource definition to {} : {}"
argument_list|,
name|clusterDirectory
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// now see if it is actually running and tell it about the update if it is
name|ApplicationReport
name|instance
init|=
name|findInstance
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
if|if
condition|(
name|instance
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Flexing running cluster"
argument_list|)
expr_stmt|;
name|SliderClusterProtocol
name|appMaster
init|=
name|connect
argument_list|(
name|instance
argument_list|)
decl_stmt|;
name|SliderClusterOperations
name|clusterOps
init|=
operator|new
name|SliderClusterOperations
argument_list|(
name|appMaster
argument_list|)
decl_stmt|;
name|clusterOps
operator|.
name|flex
argument_list|(
name|instanceDefinition
operator|.
name|getResources
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"application instance size updated"
argument_list|)
expr_stmt|;
name|exitCode
operator|=
name|EXIT_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"No running instance to update"
argument_list|)
expr_stmt|;
block|}
return|return
name|exitCode
return|;
block|}
comment|/**    * Validate an instance definition against a provider.    * @param provider the provider performing the validation    * @param instanceDefinition the instance definition    * @throws SliderException if invalid.    */
DECL|method|validateInstanceDefinition (AbstractClientProvider provider, AggregateConf instanceDefinition, SliderFileSystem fs)
specifier|protected
name|void
name|validateInstanceDefinition
parameter_list|(
name|AbstractClientProvider
name|provider
parameter_list|,
name|AggregateConf
name|instanceDefinition
parameter_list|,
name|SliderFileSystem
name|fs
parameter_list|)
throws|throws
name|SliderException
block|{
try|try
block|{
name|provider
operator|.
name|validateInstanceDefinition
argument_list|(
name|instanceDefinition
argument_list|,
name|fs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SliderException
name|e
parameter_list|)
block|{
comment|//problem, reject it
name|log
operator|.
name|info
argument_list|(
literal|"Error {} validating application instance definition "
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Error validating application instance definition "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
name|instanceDefinition
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Load the persistent cluster description    * @param clustername name of the cluster    * @return the description in the filesystem    * @throws IOException any problems loading -including a missing file    */
annotation|@
name|VisibleForTesting
DECL|method|loadPersistedClusterDescription (String clustername)
specifier|public
name|AggregateConf
name|loadPersistedClusterDescription
parameter_list|(
name|String
name|clustername
parameter_list|)
throws|throws
name|IOException
throws|,
name|SliderException
throws|,
name|LockAcquireFailedException
block|{
name|Path
name|clusterDirectory
init|=
name|sliderFileSystem
operator|.
name|buildClusterDirPath
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
name|ConfPersister
name|persister
init|=
operator|new
name|ConfPersister
argument_list|(
name|sliderFileSystem
argument_list|,
name|clusterDirectory
argument_list|)
decl_stmt|;
name|AggregateConf
name|instanceDescription
init|=
operator|new
name|AggregateConf
argument_list|()
decl_stmt|;
name|persister
operator|.
name|load
argument_list|(
name|instanceDescription
argument_list|)
expr_stmt|;
return|return
name|instanceDescription
return|;
block|}
comment|/**      * Connect to a live cluster and get its current state      * @param clustername the cluster name      * @return its description      */
annotation|@
name|VisibleForTesting
DECL|method|getClusterDescription (String clustername)
specifier|public
name|ClusterDescription
name|getClusterDescription
parameter_list|(
name|String
name|clustername
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|SliderClusterOperations
name|clusterOperations
init|=
name|createClusterOperations
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
return|return
name|clusterOperations
operator|.
name|getClusterDescription
argument_list|()
return|;
block|}
comment|/**    * Connect to the cluster and get its current state    * @return its description    */
annotation|@
name|VisibleForTesting
DECL|method|getClusterDescription ()
specifier|public
name|ClusterDescription
name|getClusterDescription
parameter_list|()
throws|throws
name|YarnException
throws|,
name|IOException
block|{
return|return
name|getClusterDescription
argument_list|(
name|getDeployedClusterName
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * List all node UUIDs in a role    * @param role role name or "" for all    * @return an array of UUID strings    * @throws IOException    * @throws YarnException    */
annotation|@
name|VisibleForTesting
DECL|method|listNodeUUIDsByRole (String role)
specifier|public
name|String
index|[]
name|listNodeUUIDsByRole
parameter_list|(
name|String
name|role
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
return|return
name|createClusterOperations
argument_list|()
operator|.
name|listNodeUUIDsByRole
argument_list|(
name|role
argument_list|)
return|;
block|}
comment|/**    * List all nodes in a role. This is a double round trip: once to list    * the nodes in a role, another to get their details    * @param role component/role to look for    * @return an array of ContainerNode instances    * @throws IOException    * @throws YarnException    */
annotation|@
name|VisibleForTesting
DECL|method|listClusterNodesInRole (String role)
specifier|public
name|List
argument_list|<
name|ClusterNode
argument_list|>
name|listClusterNodesInRole
parameter_list|(
name|String
name|role
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
return|return
name|createClusterOperations
argument_list|()
operator|.
name|listClusterNodesInRole
argument_list|(
name|role
argument_list|)
return|;
block|}
comment|/**    * Get the details on a list of uuids    * @param uuids uuids to ask for     * @return a possibly empty list of node details    * @throws IOException    * @throws YarnException    */
annotation|@
name|VisibleForTesting
DECL|method|listClusterNodes (String[] uuids)
specifier|public
name|List
argument_list|<
name|ClusterNode
argument_list|>
name|listClusterNodes
parameter_list|(
name|String
index|[]
name|uuids
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
if|if
condition|(
name|uuids
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|// short cut on an empty list
return|return
operator|new
name|LinkedList
argument_list|<>
argument_list|()
return|;
block|}
return|return
name|createClusterOperations
argument_list|()
operator|.
name|listClusterNodes
argument_list|(
name|uuids
argument_list|)
return|;
block|}
comment|/**    * Get the instance definition from the far end    */
annotation|@
name|VisibleForTesting
DECL|method|getLiveInstanceDefinition ()
specifier|public
name|AggregateConf
name|getLiveInstanceDefinition
parameter_list|()
throws|throws
name|IOException
throws|,
name|YarnException
block|{
return|return
name|createClusterOperations
argument_list|()
operator|.
name|getInstanceDefinition
argument_list|()
return|;
block|}
comment|/**    * Bond to a running cluster    * @param clustername cluster name    * @return the AM RPC client    * @throws SliderException if the cluster is unkown    */
DECL|method|bondToCluster (String clustername)
specifier|private
name|SliderClusterProtocol
name|bondToCluster
parameter_list|(
name|String
name|clustername
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|verifyBindingsDefined
argument_list|()
expr_stmt|;
if|if
condition|(
name|clustername
operator|==
literal|null
condition|)
block|{
throw|throw
name|unknownClusterException
argument_list|(
literal|"(undefined)"
argument_list|)
throw|;
block|}
name|ApplicationReport
name|instance
init|=
name|findInstance
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|instance
condition|)
block|{
throw|throw
name|unknownClusterException
argument_list|(
name|clustername
argument_list|)
throw|;
block|}
return|return
name|connect
argument_list|(
name|instance
argument_list|)
return|;
block|}
comment|/**    * Create a cluster operations instance against a given cluster    * @param clustername cluster name    * @return a bonded cluster operations instance    * @throws YarnException YARN issues    * @throws IOException IO problems    */
DECL|method|createClusterOperations (String clustername)
specifier|private
name|SliderClusterOperations
name|createClusterOperations
parameter_list|(
name|String
name|clustername
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|SliderClusterProtocol
name|sliderAM
init|=
name|bondToCluster
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
return|return
operator|new
name|SliderClusterOperations
argument_list|(
name|sliderAM
argument_list|)
return|;
block|}
comment|/**    * Create a cluster operations instance against the active cluster    * -returning any previous created one if held.    * @return a bonded cluster operations instance    * @throws YarnException YARN issues    * @throws IOException IO problems    */
DECL|method|createClusterOperations ()
specifier|private
name|SliderClusterOperations
name|createClusterOperations
parameter_list|()
throws|throws
name|YarnException
throws|,
name|IOException
block|{
if|if
condition|(
name|sliderClusterOperations
operator|==
literal|null
condition|)
block|{
name|sliderClusterOperations
operator|=
name|createClusterOperations
argument_list|(
name|getDeployedClusterName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|sliderClusterOperations
return|;
block|}
comment|/**    * Wait for an instance of a named role to be live (or past it in the lifecycle)    * @param role role to look for    * @param timeout time to wait    * @return the state. If still in CREATED, the cluster didn't come up    * in the time period. If LIVE, all is well. If>LIVE, it has shut for a reason    * @throws IOException IO    * @throws SliderException Slider    * @throws WaitTimeoutException if the wait timed out    */
annotation|@
name|VisibleForTesting
DECL|method|waitForRoleInstanceLive (String role, long timeout)
specifier|public
name|int
name|waitForRoleInstanceLive
parameter_list|(
name|String
name|role
parameter_list|,
name|long
name|timeout
parameter_list|)
throws|throws
name|WaitTimeoutException
throws|,
name|IOException
throws|,
name|YarnException
block|{
return|return
name|createClusterOperations
argument_list|()
operator|.
name|waitForRoleInstanceLive
argument_list|(
name|role
argument_list|,
name|timeout
argument_list|)
return|;
block|}
comment|/**    * Generate an exception for an unknown cluster    * @param clustername cluster name    * @return an exception with text and a relevant exit code    */
DECL|method|unknownClusterException (String clustername)
specifier|public
name|UnknownApplicationInstanceException
name|unknownClusterException
parameter_list|(
name|String
name|clustername
parameter_list|)
block|{
return|return
name|UnknownApplicationInstanceException
operator|.
name|unknownInstance
argument_list|(
name|clustername
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Slider Client in state "
operator|+
name|getServiceState
argument_list|()
operator|+
literal|" and Slider Application Instance "
operator|+
name|deployedClusterName
return|;
block|}
comment|/**    * Get all YARN applications    * @return a possibly empty list    * @throws YarnException    * @throws IOException    */
annotation|@
name|VisibleForTesting
DECL|method|getApplications ()
specifier|public
name|List
argument_list|<
name|ApplicationReport
argument_list|>
name|getApplications
parameter_list|()
throws|throws
name|YarnException
throws|,
name|IOException
block|{
return|return
name|yarnClient
operator|.
name|getApplications
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getApplicationReport (ApplicationId appId)
specifier|public
name|ApplicationReport
name|getApplicationReport
parameter_list|(
name|ApplicationId
name|appId
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
return|return
operator|new
name|LaunchedApplication
argument_list|(
name|appId
argument_list|,
name|yarnClient
argument_list|)
operator|.
name|getApplicationReport
argument_list|()
return|;
block|}
comment|/**    * The configuration used for deployment (after resolution).    * Non-null only after the client has launched the application    * @return the resolved configuration or null    */
annotation|@
name|VisibleForTesting
DECL|method|getLaunchedInstanceDefinition ()
specifier|public
name|AggregateConf
name|getLaunchedInstanceDefinition
parameter_list|()
block|{
return|return
name|launchedInstanceDefinition
return|;
block|}
annotation|@
name|Override
DECL|method|actionResolve (ActionResolveArgs args)
specifier|public
name|int
name|actionResolve
parameter_list|(
name|ActionResolveArgs
name|args
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
comment|// as this is an API entry point, validate
comment|// the arguments
name|args
operator|.
name|validate
argument_list|()
expr_stmt|;
name|RegistryOperations
name|operations
init|=
name|getRegistryOperations
argument_list|()
decl_stmt|;
name|String
name|path
init|=
name|SliderRegistryUtils
operator|.
name|resolvePath
argument_list|(
name|args
operator|.
name|path
argument_list|)
decl_stmt|;
name|ServiceRecordMarshal
name|serviceRecordMarshal
init|=
operator|new
name|ServiceRecordMarshal
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|args
operator|.
name|list
condition|)
block|{
name|File
name|destDir
init|=
name|args
operator|.
name|destdir
decl_stmt|;
if|if
condition|(
name|destDir
operator|!=
literal|null
condition|)
block|{
name|destDir
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|ServiceRecord
argument_list|>
name|recordMap
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|RegistryPathStatus
argument_list|>
name|znodes
decl_stmt|;
try|try
block|{
name|znodes
operator|=
name|statChildren
argument_list|(
name|registryOperations
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|recordMap
operator|=
name|extractServiceRecords
argument_list|(
name|registryOperations
argument_list|,
name|path
argument_list|,
name|znodes
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PathNotFoundException
name|e
parameter_list|)
block|{
comment|// treat the root directory as if if is always there
if|if
condition|(
literal|"/"
operator|.
name|equals
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|znodes
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|recordMap
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
comment|// subtract all records from the znodes map to get pure directories
name|log
operator|.
name|info
argument_list|(
literal|"Entries: {}"
argument_list|,
name|znodes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|name
range|:
name|znodes
operator|.
name|keySet
argument_list|()
control|)
block|{
name|println
argument_list|(
literal|"  "
operator|+
name|name
argument_list|)
expr_stmt|;
block|}
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Service records: {}"
argument_list|,
name|recordMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|ServiceRecord
argument_list|>
name|recordEntry
range|:
name|recordMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|recordEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ServiceRecord
name|instance
init|=
name|recordEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|json
init|=
name|serviceRecordMarshal
operator|.
name|toJson
argument_list|(
name|instance
argument_list|)
decl_stmt|;
if|if
condition|(
name|destDir
operator|==
literal|null
condition|)
block|{
name|println
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|println
argument_list|(
name|json
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|filename
init|=
name|RegistryPathUtils
operator|.
name|lastPathEntry
argument_list|(
name|name
argument_list|)
operator|+
literal|".json"
decl_stmt|;
name|File
name|jsonFile
init|=
operator|new
name|File
argument_list|(
name|destDir
argument_list|,
name|filename
argument_list|)
decl_stmt|;
name|write
argument_list|(
name|jsonFile
argument_list|,
name|serviceRecordMarshal
operator|.
name|toBytes
argument_list|(
name|instance
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// resolve single entry
name|ServiceRecord
name|instance
init|=
name|resolve
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|File
name|outFile
init|=
name|args
operator|.
name|out
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|destdir
operator|!=
literal|null
condition|)
block|{
name|outFile
operator|=
operator|new
name|File
argument_list|(
name|args
operator|.
name|destdir
argument_list|,
name|RegistryPathUtils
operator|.
name|lastPathEntry
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outFile
operator|!=
literal|null
condition|)
block|{
name|write
argument_list|(
name|outFile
argument_list|,
name|serviceRecordMarshal
operator|.
name|toBytes
argument_list|(
name|instance
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|println
argument_list|(
name|serviceRecordMarshal
operator|.
name|toJson
argument_list|(
name|instance
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|PathNotFoundException
decl||
name|NoRecordException
name|e
parameter_list|)
block|{
comment|// no record at this path
throw|throw
operator|new
name|NotFoundException
argument_list|(
name|e
argument_list|,
name|path
argument_list|)
throw|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
annotation|@
name|Override
DECL|method|actionRegistry (ActionRegistryArgs registryArgs)
specifier|public
name|int
name|actionRegistry
parameter_list|(
name|ActionRegistryArgs
name|registryArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
comment|// as this is also a test entry point, validate
comment|// the arguments
name|registryArgs
operator|.
name|validate
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|registryArgs
operator|.
name|list
condition|)
block|{
name|actionRegistryList
argument_list|(
name|registryArgs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|registryArgs
operator|.
name|listConf
condition|)
block|{
comment|// list the configurations
name|actionRegistryListConfigsYarn
argument_list|(
name|registryArgs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|registryArgs
operator|.
name|listExports
condition|)
block|{
comment|// list the exports
name|actionRegistryListExports
argument_list|(
name|registryArgs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isSet
argument_list|(
name|registryArgs
operator|.
name|getConf
argument_list|)
condition|)
block|{
comment|// get a configuration
name|PublishedConfiguration
name|publishedConfiguration
init|=
name|actionRegistryGetConfig
argument_list|(
name|registryArgs
argument_list|)
decl_stmt|;
name|outputConfig
argument_list|(
name|publishedConfiguration
argument_list|,
name|registryArgs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isSet
argument_list|(
name|registryArgs
operator|.
name|getExport
argument_list|)
condition|)
block|{
comment|// get a export group
name|PublishedExports
name|publishedExports
init|=
name|actionRegistryGetExport
argument_list|(
name|registryArgs
argument_list|)
decl_stmt|;
name|outputExport
argument_list|(
name|publishedExports
argument_list|,
name|registryArgs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// it's an unknown command
name|log
operator|.
name|info
argument_list|(
name|CommonArgs
operator|.
name|usage
argument_list|(
name|serviceArgs
argument_list|,
name|ACTION_DIAGNOSTICS
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EXIT_USAGE
return|;
block|}
comment|//      JDK7
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"{}"
argument_list|,
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"{}"
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|EXIT_NOT_FOUND
return|;
block|}
catch|catch
parameter_list|(
name|PathNotFoundException
name|e
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"{}"
argument_list|,
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"{}"
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|EXIT_NOT_FOUND
return|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
comment|/**    * Registry operation    *    * @param registryArgs registry Arguments    * @return the instances (for tests)    * @throws YarnException YARN problems    * @throws IOException Network or other problems    */
annotation|@
name|VisibleForTesting
DECL|method|actionRegistryList ( ActionRegistryArgs registryArgs)
specifier|public
name|Collection
argument_list|<
name|ServiceRecord
argument_list|>
name|actionRegistryList
parameter_list|(
name|ActionRegistryArgs
name|registryArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|String
name|serviceType
init|=
name|registryArgs
operator|.
name|serviceType
decl_stmt|;
name|String
name|name
init|=
name|registryArgs
operator|.
name|name
decl_stmt|;
name|RegistryOperations
name|operations
init|=
name|getRegistryOperations
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|ServiceRecord
argument_list|>
name|serviceRecords
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|String
name|path
init|=
name|serviceclassPath
argument_list|(
name|currentUser
argument_list|()
argument_list|,
name|serviceType
argument_list|)
decl_stmt|;
try|try
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|ServiceRecord
argument_list|>
name|recordMap
init|=
name|listServiceRecords
argument_list|(
name|operations
argument_list|,
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|recordMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnknownApplicationInstanceException
argument_list|(
literal|"No applications registered under "
operator|+
name|path
argument_list|)
throw|;
block|}
name|serviceRecords
operator|=
name|recordMap
operator|.
name|values
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PathNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|NotFoundException
argument_list|(
name|path
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|ServiceRecord
name|instance
init|=
name|lookupServiceRecord
argument_list|(
name|registryArgs
argument_list|)
decl_stmt|;
name|serviceRecords
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|serviceRecords
operator|.
name|add
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ServiceRecord
name|serviceRecord
range|:
name|serviceRecords
control|)
block|{
name|logInstance
argument_list|(
name|serviceRecord
argument_list|,
name|registryArgs
operator|.
name|verbose
argument_list|)
expr_stmt|;
block|}
return|return
name|serviceRecords
return|;
block|}
annotation|@
name|Override
DECL|method|actionDiagnostic (ActionDiagnosticArgs diagnosticArgs)
specifier|public
name|int
name|actionDiagnostic
parameter_list|(
name|ActionDiagnosticArgs
name|diagnosticArgs
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|diagnosticArgs
operator|.
name|client
condition|)
block|{
name|actionDiagnosticClient
argument_list|(
name|diagnosticArgs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diagnosticArgs
operator|.
name|application
condition|)
block|{
name|actionDiagnosticApplication
argument_list|(
name|diagnosticArgs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diagnosticArgs
operator|.
name|yarn
condition|)
block|{
name|actionDiagnosticYarn
argument_list|(
name|diagnosticArgs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diagnosticArgs
operator|.
name|credentials
condition|)
block|{
name|actionDiagnosticCredentials
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diagnosticArgs
operator|.
name|all
condition|)
block|{
name|actionDiagnosticAll
argument_list|(
name|diagnosticArgs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diagnosticArgs
operator|.
name|level
condition|)
block|{
name|actionDiagnosticIntelligent
argument_list|(
name|diagnosticArgs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// it's an unknown option
name|log
operator|.
name|info
argument_list|(
name|CommonArgs
operator|.
name|usage
argument_list|(
name|serviceArgs
argument_list|,
name|ACTION_DIAGNOSTICS
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EXIT_USAGE
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|EXIT_FALSE
return|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
DECL|method|actionDiagnosticIntelligent (ActionDiagnosticArgs diagnosticArgs)
specifier|private
name|void
name|actionDiagnosticIntelligent
parameter_list|(
name|ActionDiagnosticArgs
name|diagnosticArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
throws|,
name|URISyntaxException
block|{
comment|// not using member variable clustername because we want to place
comment|// application name after --application option and member variable
comment|// cluster name has to be put behind action
name|String
name|clusterName
init|=
name|diagnosticArgs
operator|.
name|name
decl_stmt|;
name|requireArgumentSet
argument_list|(
name|Arguments
operator|.
name|ARG_NAME
argument_list|,
name|clusterName
argument_list|)
expr_stmt|;
try|try
block|{
name|validateClientConfigFile
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Slider-client.xml is accessible"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// we are catching exceptions here because those are indication of
comment|// validation result, and we need to print them here
name|log
operator|.
name|error
argument_list|(
literal|"validation of slider-client.xml fails because: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
name|SliderClusterOperations
name|clusterOperations
init|=
name|createClusterOperations
argument_list|(
name|clusterName
argument_list|)
decl_stmt|;
comment|// cluster not found exceptions will be thrown upstream
name|ClusterDescription
name|clusterDescription
init|=
name|clusterOperations
operator|.
name|getClusterDescription
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Slider AppMaster is accessible"
argument_list|)
expr_stmt|;
if|if
condition|(
name|clusterDescription
operator|.
name|state
operator|==
name|StateValues
operator|.
name|STATE_LIVE
condition|)
block|{
name|AggregateConf
name|instanceDefinition
init|=
name|clusterOperations
operator|.
name|getInstanceDefinition
argument_list|()
decl_stmt|;
name|String
name|imagePath
init|=
name|instanceDefinition
operator|.
name|getInternalOperations
argument_list|()
operator|.
name|get
argument_list|(
name|INTERNAL_APPLICATION_IMAGE_PATH
argument_list|)
decl_stmt|;
comment|// if null, that means slider uploaded the agent tarball for the user
comment|// and we need to use where slider has put
if|if
condition|(
name|imagePath
operator|==
literal|null
condition|)
block|{
name|ApplicationReport
name|appReport
init|=
name|findInstance
argument_list|(
name|clusterName
argument_list|)
decl_stmt|;
name|Path
name|path1
init|=
name|sliderFileSystem
operator|.
name|getTempPathForCluster
argument_list|(
name|clusterName
argument_list|)
decl_stmt|;
if|if
condition|(
name|appReport
operator|!=
literal|null
condition|)
block|{
name|Path
name|subPath
init|=
operator|new
name|Path
argument_list|(
name|path1
argument_list|,
name|appReport
operator|.
name|getApplicationId
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|"/agent"
argument_list|)
decl_stmt|;
name|imagePath
operator|=
name|subPath
operator|.
name|toString
argument_list|()
expr_stmt|;
name|String
name|pathStr
init|=
name|imagePath
operator|+
literal|"/"
operator|+
name|AgentKeys
operator|.
name|AGENT_TAR
decl_stmt|;
try|try
block|{
name|validateHDFSFile
argument_list|(
name|sliderFileSystem
argument_list|,
name|pathStr
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Slider agent package is properly installed at "
operator|+
name|pathStr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"can not find agent package: {}"
argument_list|,
name|pathStr
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"can not open agent package: {}"
argument_list|,
name|pathStr
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|String
name|pkgTarballPath
init|=
name|getApplicationDefinitionPath
argument_list|(
name|instanceDefinition
operator|.
name|getAppConfOperations
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|validateHDFSFile
argument_list|(
name|sliderFileSystem
argument_list|,
name|pkgTarballPath
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Application package is properly installed"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"can not find application package: {}"
argument_list|,
name|pkgTarballPath
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"can not open application package: {} "
argument_list|,
name|pkgTarballPath
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|actionDiagnosticAll (ActionDiagnosticArgs diagnosticArgs)
specifier|private
name|void
name|actionDiagnosticAll
parameter_list|(
name|ActionDiagnosticArgs
name|diagnosticArgs
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
comment|// assign application name from param to each sub diagnostic function
name|actionDiagnosticClient
argument_list|(
name|diagnosticArgs
argument_list|)
expr_stmt|;
name|actionDiagnosticApplication
argument_list|(
name|diagnosticArgs
argument_list|)
expr_stmt|;
name|actionDiagnosticSlider
argument_list|(
name|diagnosticArgs
argument_list|)
expr_stmt|;
name|actionDiagnosticYarn
argument_list|(
name|diagnosticArgs
argument_list|)
expr_stmt|;
name|actionDiagnosticCredentials
argument_list|()
expr_stmt|;
block|}
DECL|method|actionDiagnosticCredentials ()
specifier|private
name|void
name|actionDiagnosticCredentials
parameter_list|()
throws|throws
name|BadConfigException
throws|,
name|IOException
block|{
if|if
condition|(
name|isHadoopClusterSecure
argument_list|(
name|loadSliderClientXML
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|credentialCacheFileDescription
init|=
literal|null
decl_stmt|;
try|try
block|{
name|credentialCacheFileDescription
operator|=
name|checkCredentialCacheFile
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|BadConfigException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"The credential config is not valid: "
operator|+
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Unable to read the credential file: "
operator|+
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Credential cache file for the current user: "
operator|+
name|credentialCacheFileDescription
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"the cluster is not in secure mode"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|actionDiagnosticYarn (ActionDiagnosticArgs diagnosticArgs)
specifier|private
name|void
name|actionDiagnosticYarn
parameter_list|(
name|ActionDiagnosticArgs
name|diagnosticArgs
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
name|JSONObject
name|converter
init|=
literal|null
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"the node in the YARN cluster has below state: "
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|NodeReport
argument_list|>
name|yarnClusterInfo
decl_stmt|;
try|try
block|{
name|yarnClusterInfo
operator|=
name|yarnClient
operator|.
name|getNodeReports
argument_list|(
name|NodeState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|YarnException
name|e1
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Exception happened when fetching node report from the YARN cluster: "
operator|+
name|e1
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e1
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e1
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Network problem happened when fetching node report YARN cluster: "
operator|+
name|e1
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e1
throw|;
block|}
for|for
control|(
name|NodeReport
name|nodeReport
range|:
name|yarnClusterInfo
control|)
block|{
name|log
operator|.
name|info
argument_list|(
name|nodeReport
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|diagnosticArgs
operator|.
name|verbose
condition|)
block|{
name|Writer
name|configWriter
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
try|try
block|{
name|Configuration
operator|.
name|dumpConfiguration
argument_list|(
name|yarnClient
operator|.
name|getConfig
argument_list|()
argument_list|,
name|configWriter
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e1
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Network problem happened when retrieving YARN config from YARN: "
operator|+
name|e1
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e1
throw|;
block|}
try|try
block|{
name|converter
operator|=
operator|new
name|JSONObject
argument_list|(
name|configWriter
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"the configuration of the YARN cluster is: "
operator|+
name|converter
operator|.
name|toString
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|JSONException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"JSONException happened during parsing response from YARN: "
operator|+
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|actionDiagnosticSlider (ActionDiagnosticArgs diagnosticArgs)
specifier|private
name|void
name|actionDiagnosticSlider
parameter_list|(
name|ActionDiagnosticArgs
name|diagnosticArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
comment|// not using member variable clustername because we want to place
comment|// application name after --application option and member variable
comment|// cluster name has to be put behind action
name|String
name|clusterName
init|=
name|diagnosticArgs
operator|.
name|name
decl_stmt|;
if|if
condition|(
name|isUnset
argument_list|(
name|clusterName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"application name must be provided with --name option"
argument_list|)
throw|;
block|}
name|AggregateConf
name|instanceDefinition
init|=
name|fetchInstanceDefinition
argument_list|(
name|clusterName
argument_list|)
decl_stmt|;
name|String
name|imagePath
init|=
name|instanceDefinition
operator|.
name|getInternalOperations
argument_list|()
operator|.
name|get
argument_list|(
name|INTERNAL_APPLICATION_IMAGE_PATH
argument_list|)
decl_stmt|;
comment|// if null, it will be uploaded by Slider and thus at slider's path
if|if
condition|(
name|imagePath
operator|==
literal|null
condition|)
block|{
name|ApplicationReport
name|appReport
init|=
name|findInstance
argument_list|(
name|clusterName
argument_list|)
decl_stmt|;
if|if
condition|(
name|appReport
operator|!=
literal|null
condition|)
block|{
name|Path
name|path1
init|=
name|sliderFileSystem
operator|.
name|getTempPathForCluster
argument_list|(
name|clusterName
argument_list|)
decl_stmt|;
name|Path
name|subPath
init|=
operator|new
name|Path
argument_list|(
name|path1
argument_list|,
name|appReport
operator|.
name|getApplicationId
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|"/agent"
argument_list|)
decl_stmt|;
name|imagePath
operator|=
name|subPath
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
block|}
name|log
operator|.
name|info
argument_list|(
literal|"The path of slider agent tarball on HDFS is: "
operator|+
name|imagePath
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchInstanceDefinition (String clusterName)
specifier|private
name|AggregateConf
name|fetchInstanceDefinition
parameter_list|(
name|String
name|clusterName
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|SliderClusterOperations
name|clusterOperations
decl_stmt|;
name|AggregateConf
name|instanceDefinition
init|=
literal|null
decl_stmt|;
try|try
block|{
name|clusterOperations
operator|=
name|createClusterOperations
argument_list|(
name|clusterName
argument_list|)
expr_stmt|;
name|instanceDefinition
operator|=
name|clusterOperations
operator|.
name|getInstanceDefinition
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|YarnException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Failed to retrieve instance definition from YARN: "
operator|+
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
name|instanceDefinition
return|;
block|}
DECL|method|actionDiagnosticApplication (ActionDiagnosticArgs diagnosticArgs)
specifier|private
name|void
name|actionDiagnosticApplication
parameter_list|(
name|ActionDiagnosticArgs
name|diagnosticArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
comment|// not using member variable clustername because we want to place
comment|// application name after --application option and member variable
comment|// cluster name has to be put behind action
name|String
name|clusterName
init|=
name|diagnosticArgs
operator|.
name|name
decl_stmt|;
name|requireArgumentSet
argument_list|(
name|Arguments
operator|.
name|ARG_NAME
argument_list|,
name|clusterName
argument_list|)
expr_stmt|;
name|AggregateConf
name|instanceDefinition
init|=
name|fetchInstanceDefinition
argument_list|(
name|clusterName
argument_list|)
decl_stmt|;
name|String
name|clusterDir
init|=
name|instanceDefinition
operator|.
name|getAppConfOperations
argument_list|()
operator|.
name|getGlobalOptions
argument_list|()
operator|.
name|get
argument_list|(
name|AgentKeys
operator|.
name|APP_ROOT
argument_list|)
decl_stmt|;
name|String
name|pkgTarball
init|=
name|getApplicationDefinitionPath
argument_list|(
name|instanceDefinition
operator|.
name|getAppConfOperations
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|runAsUser
init|=
name|instanceDefinition
operator|.
name|getAppConfOperations
argument_list|()
operator|.
name|getGlobalOptions
argument_list|()
operator|.
name|get
argument_list|(
name|AgentKeys
operator|.
name|RUNAS_USER
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"The location of the cluster instance directory in HDFS is: {}"
argument_list|,
name|clusterDir
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"The name of the application package tarball on HDFS is: {}"
argument_list|,
name|pkgTarball
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"The runas user of the application in the cluster is: {}"
argument_list|,
name|runAsUser
argument_list|)
expr_stmt|;
if|if
condition|(
name|diagnosticArgs
operator|.
name|verbose
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"App config of the application:\n{}"
argument_list|,
name|instanceDefinition
operator|.
name|getAppConf
argument_list|()
operator|.
name|toJson
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Resource config of the application:\n{}"
argument_list|,
name|instanceDefinition
operator|.
name|getResources
argument_list|()
operator|.
name|toJson
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|actionDiagnosticClient (ActionDiagnosticArgs diagnosticArgs)
specifier|private
name|void
name|actionDiagnosticClient
parameter_list|(
name|ActionDiagnosticArgs
name|diagnosticArgs
parameter_list|)
throws|throws
name|SliderException
throws|,
name|IOException
block|{
try|try
block|{
name|String
name|currentCommandPath
init|=
name|getCurrentCommandPath
argument_list|()
decl_stmt|;
name|SliderVersionInfo
operator|.
name|loadAndPrintVersionInfo
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|String
name|clientConfigPath
init|=
name|getClientConfigPath
argument_list|()
decl_stmt|;
name|String
name|jdkInfo
init|=
name|getJDKInfo
argument_list|()
decl_stmt|;
name|println
argument_list|(
literal|"The slider command path: %s"
argument_list|,
name|currentCommandPath
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"The slider-client.xml used by current running command path: %s"
argument_list|,
name|clientConfigPath
argument_list|)
expr_stmt|;
name|println
argument_list|(
name|jdkInfo
argument_list|)
expr_stmt|;
comment|// security info
name|Configuration
name|config
init|=
name|getConfig
argument_list|()
decl_stmt|;
if|if
condition|(
name|isHadoopClusterSecure
argument_list|(
name|config
argument_list|)
condition|)
block|{
name|println
argument_list|(
literal|"Hadoop Cluster is secure"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"Login user is %s"
argument_list|,
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"Current user is %s"
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|println
argument_list|(
literal|"Hadoop Cluster is insecure"
argument_list|)
expr_stmt|;
block|}
comment|// verbose?
if|if
condition|(
name|diagnosticArgs
operator|.
name|verbose
condition|)
block|{
comment|// do the environment
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
init|=
name|getSystemEnv
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|envList
init|=
name|ConfigHelper
operator|.
name|sortedConfigKeys
argument_list|(
name|env
operator|.
name|entrySet
argument_list|()
argument_list|)
decl_stmt|;
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"Environment variables:\n"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|key
range|:
name|envList
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|key
argument_list|)
operator|.
name|append
argument_list|(
literal|"="
argument_list|)
operator|.
name|append
argument_list|(
name|env
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|println
argument_list|(
name|builder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Java properties
name|builder
operator|=
operator|new
name|StringBuilder
argument_list|(
literal|"JVM Properties\n"
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|props
init|=
name|sortedMap
argument_list|(
name|toMap
argument_list|(
name|System
operator|.
name|getProperties
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|props
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"="
argument_list|)
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|println
argument_list|(
name|builder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// then the config
name|println
argument_list|(
literal|"Slider client configuration:\n"
operator|+
name|ConfigHelper
operator|.
name|dumpConfigToString
argument_list|(
name|config
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|validateSliderClientEnvironment
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SliderException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Kerberos Diagnostics    * @param args CLI arguments    * @return exit code    * @throws SliderException    * @throws IOException    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"IOResourceOpenedButNotSafelyClosed"
argument_list|)
DECL|method|actionKDiag (ActionKDiagArgs args)
specifier|private
name|int
name|actionKDiag
parameter_list|(
name|ActionKDiagArgs
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|PrintWriter
name|out
init|=
operator|new
name|PrintWriter
argument_list|(
name|System
operator|.
name|err
argument_list|)
decl_stmt|;
name|boolean
name|closeStream
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|=
operator|new
name|PrintWriter
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|args
operator|.
name|out
argument_list|)
argument_list|)
expr_stmt|;
name|closeStream
operator|=
literal|true
expr_stmt|;
block|}
try|try
block|{
name|KerberosDiags
name|kdiags
init|=
operator|new
name|KerberosDiags
argument_list|(
name|getConfig
argument_list|()
argument_list|,
name|out
argument_list|,
name|args
operator|.
name|services
argument_list|,
name|args
operator|.
name|keytab
argument_list|,
name|args
operator|.
name|principal
argument_list|,
name|args
operator|.
name|keylen
argument_list|,
name|args
operator|.
name|secure
argument_list|)
decl_stmt|;
name|kdiags
operator|.
name|execute
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KerberosDiags
operator|.
name|KerberosDiagsFailure
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Kerberos Diagnostics"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|closeStream
condition|)
block|{
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
comment|/**    * Log a service record instance    * @param instance record    * @param verbose verbose logging of all external endpoints    */
DECL|method|logInstance (ServiceRecord instance, boolean verbose)
specifier|private
name|void
name|logInstance
parameter_list|(
name|ServiceRecord
name|instance
parameter_list|,
name|boolean
name|verbose
parameter_list|)
block|{
if|if
condition|(
operator|!
name|verbose
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"{}"
argument_list|,
name|instance
operator|.
name|get
argument_list|(
name|YarnRegistryAttributes
operator|.
name|YARN_ID
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"{}: "
argument_list|,
name|instance
operator|.
name|get
argument_list|(
name|YarnRegistryAttributes
operator|.
name|YARN_ID
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|logEndpoints
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Log the external endpoints of a service record    * @param instance service record instance    */
DECL|method|logEndpoints (ServiceRecord instance)
specifier|private
name|void
name|logEndpoints
parameter_list|(
name|ServiceRecord
name|instance
parameter_list|)
block|{
name|List
argument_list|<
name|Endpoint
argument_list|>
name|endpoints
init|=
name|instance
operator|.
name|external
decl_stmt|;
for|for
control|(
name|Endpoint
name|endpoint
range|:
name|endpoints
control|)
block|{
name|log
operator|.
name|info
argument_list|(
name|endpoint
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * list configs available for an instance    *    * @param registryArgs registry Arguments    * @throws YarnException YARN problems    * @throws IOException Network or other problems    */
DECL|method|actionRegistryListConfigsYarn (ActionRegistryArgs registryArgs)
specifier|public
name|void
name|actionRegistryListConfigsYarn
parameter_list|(
name|ActionRegistryArgs
name|registryArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|ServiceRecord
name|instance
init|=
name|lookupServiceRecord
argument_list|(
name|registryArgs
argument_list|)
decl_stmt|;
name|RegistryRetriever
name|retriever
init|=
operator|new
name|RegistryRetriever
argument_list|(
name|getConfig
argument_list|()
argument_list|,
name|instance
argument_list|)
decl_stmt|;
name|PublishedConfigSet
name|configurations
init|=
name|retriever
operator|.
name|getConfigurations
argument_list|(
operator|!
name|registryArgs
operator|.
name|internal
argument_list|)
decl_stmt|;
name|PrintStream
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|registryArgs
operator|.
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|=
operator|new
name|PrintStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|registryArgs
operator|.
name|out
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|=
name|System
operator|.
name|out
expr_stmt|;
block|}
for|for
control|(
name|String
name|configName
range|:
name|configurations
operator|.
name|keys
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|registryArgs
operator|.
name|verbose
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
name|configName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PublishedConfiguration
name|published
init|=
name|configurations
operator|.
name|get
argument_list|(
name|configName
argument_list|)
decl_stmt|;
name|out
operator|.
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|configName
argument_list|,
name|published
operator|.
name|description
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|registryArgs
operator|.
name|out
operator|!=
literal|null
operator|&&
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * list exports available for an instance    *    * @param registryArgs registry Arguments    * @throws YarnException YARN problems    * @throws IOException Network or other problems    */
DECL|method|actionRegistryListExports (ActionRegistryArgs registryArgs)
specifier|public
name|void
name|actionRegistryListExports
parameter_list|(
name|ActionRegistryArgs
name|registryArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|ServiceRecord
name|instance
init|=
name|lookupServiceRecord
argument_list|(
name|registryArgs
argument_list|)
decl_stmt|;
name|RegistryRetriever
name|retriever
init|=
operator|new
name|RegistryRetriever
argument_list|(
name|getConfig
argument_list|()
argument_list|,
name|instance
argument_list|)
decl_stmt|;
name|PublishedExportsSet
name|exports
init|=
name|retriever
operator|.
name|getExports
argument_list|(
operator|!
name|registryArgs
operator|.
name|internal
argument_list|)
decl_stmt|;
name|PrintStream
name|out
init|=
literal|null
decl_stmt|;
name|boolean
name|streaming
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|registryArgs
operator|.
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|=
operator|new
name|PrintStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|registryArgs
operator|.
name|out
argument_list|)
argument_list|)
expr_stmt|;
name|streaming
operator|=
literal|true
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Saving output to {}"
argument_list|,
name|registryArgs
operator|.
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|=
name|System
operator|.
name|out
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"Number of exports: {}"
argument_list|,
name|exports
operator|.
name|keys
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|exportName
range|:
name|exports
operator|.
name|keys
argument_list|()
control|)
block|{
if|if
condition|(
name|streaming
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
name|exportName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|registryArgs
operator|.
name|verbose
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
name|exportName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PublishedExports
name|published
init|=
name|exports
operator|.
name|get
argument_list|(
name|exportName
argument_list|)
decl_stmt|;
name|out
operator|.
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|exportName
argument_list|,
name|published
operator|.
name|description
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|streaming
condition|)
block|{
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * list configs available for an instance    *    * @param registryArgs registry Arguments    * @throws YarnException YARN problems    * @throws IOException Network or other problems    * @throws FileNotFoundException if the config is not found    */
annotation|@
name|VisibleForTesting
DECL|method|actionRegistryGetConfig (ActionRegistryArgs registryArgs)
specifier|public
name|PublishedConfiguration
name|actionRegistryGetConfig
parameter_list|(
name|ActionRegistryArgs
name|registryArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
return|return
name|ClientUtils
operator|.
name|getConfigFromRegistry
argument_list|(
name|getRegistryOperations
argument_list|()
argument_list|,
name|getConfig
argument_list|()
argument_list|,
name|registryArgs
operator|.
name|getConf
argument_list|,
name|registryArgs
operator|.
name|name
argument_list|,
name|registryArgs
operator|.
name|user
argument_list|,
operator|!
name|registryArgs
operator|.
name|internal
argument_list|)
return|;
block|}
comment|/**    * get a specific export group    *    * @param registryArgs registry Arguments    *    * @throws YarnException         YARN problems    * @throws IOException           Network or other problems    * @throws FileNotFoundException if the config is not found    */
annotation|@
name|VisibleForTesting
DECL|method|actionRegistryGetExport (ActionRegistryArgs registryArgs)
specifier|public
name|PublishedExports
name|actionRegistryGetExport
parameter_list|(
name|ActionRegistryArgs
name|registryArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|ServiceRecord
name|instance
init|=
name|lookupServiceRecord
argument_list|(
name|registryArgs
argument_list|)
decl_stmt|;
name|RegistryRetriever
name|retriever
init|=
operator|new
name|RegistryRetriever
argument_list|(
name|getConfig
argument_list|()
argument_list|,
name|instance
argument_list|)
decl_stmt|;
name|boolean
name|external
init|=
operator|!
name|registryArgs
operator|.
name|internal
decl_stmt|;
name|PublishedExportsSet
name|exports
init|=
name|retriever
operator|.
name|getExports
argument_list|(
name|external
argument_list|)
decl_stmt|;
name|PublishedExports
name|published
init|=
name|retriever
operator|.
name|retrieveExports
argument_list|(
name|exports
argument_list|,
name|registryArgs
operator|.
name|getExport
argument_list|,
name|external
argument_list|)
decl_stmt|;
return|return
name|published
return|;
block|}
comment|/**    * write out the config. If a destination is provided and that dir is a    * directory, the entry is written to it with the name provided + extension,    * else it is printed to standard out.    * @param published published config    * @param registryArgs registry Arguments    * @throws BadCommandArgumentsException    * @throws IOException    */
DECL|method|outputConfig (PublishedConfiguration published, ActionRegistryArgs registryArgs)
specifier|private
name|void
name|outputConfig
parameter_list|(
name|PublishedConfiguration
name|published
parameter_list|,
name|ActionRegistryArgs
name|registryArgs
parameter_list|)
throws|throws
name|BadCommandArgumentsException
throws|,
name|IOException
block|{
comment|// decide whether or not to print
name|String
name|entry
init|=
name|registryArgs
operator|.
name|getConf
decl_stmt|;
name|String
name|format
init|=
name|registryArgs
operator|.
name|format
decl_stmt|;
name|String
name|output
init|=
name|ClientUtils
operator|.
name|saveOrReturnConfig
argument_list|(
name|published
argument_list|,
name|registryArgs
operator|.
name|format
argument_list|,
name|registryArgs
operator|.
name|out
argument_list|,
name|entry
operator|+
literal|"."
operator|+
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|output
operator|!=
literal|null
condition|)
block|{
name|print
argument_list|(
name|output
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * write out the config    * @param published    * @param registryArgs    * @throws BadCommandArgumentsException    * @throws IOException    */
DECL|method|outputExport (PublishedExports published, ActionRegistryArgs registryArgs)
specifier|private
name|void
name|outputExport
parameter_list|(
name|PublishedExports
name|published
parameter_list|,
name|ActionRegistryArgs
name|registryArgs
parameter_list|)
throws|throws
name|BadCommandArgumentsException
throws|,
name|IOException
block|{
comment|// decide whether or not to print
name|String
name|entry
init|=
name|registryArgs
operator|.
name|getExport
decl_stmt|;
name|String
name|format
init|=
name|ConfigFormat
operator|.
name|JSON
operator|.
name|toString
argument_list|()
decl_stmt|;
name|ConfigFormat
name|configFormat
init|=
name|ConfigFormat
operator|.
name|resolve
argument_list|(
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|configFormat
operator|==
literal|null
operator|||
name|configFormat
operator|!=
name|ConfigFormat
operator|.
name|JSON
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"Unknown/Unsupported format %s . Only JSON is supported."
argument_list|,
name|format
argument_list|)
throw|;
block|}
name|PublishedExportsOutputter
name|outputter
init|=
name|PublishedExportsOutputter
operator|.
name|createOutputter
argument_list|(
name|configFormat
argument_list|,
name|published
argument_list|)
decl_stmt|;
name|boolean
name|print
init|=
name|registryArgs
operator|.
name|out
operator|==
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|print
condition|)
block|{
name|File
name|destFile
decl_stmt|;
name|destFile
operator|=
name|registryArgs
operator|.
name|out
expr_stmt|;
if|if
condition|(
name|destFile
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
comment|// creating it under a directory
name|destFile
operator|=
operator|new
name|File
argument_list|(
name|destFile
argument_list|,
name|entry
operator|+
literal|"."
operator|+
name|format
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Destination path: {}"
argument_list|,
name|destFile
argument_list|)
expr_stmt|;
name|outputter
operator|.
name|save
argument_list|(
name|destFile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print
argument_list|(
name|outputter
operator|.
name|asString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Look up an instance    * @return instance data    * @throws SliderException other failures    * @throws IOException IO problems or wrapped exceptions    */
DECL|method|lookupServiceRecord (ActionRegistryArgs registryArgs)
specifier|private
name|ServiceRecord
name|lookupServiceRecord
parameter_list|(
name|ActionRegistryArgs
name|registryArgs
parameter_list|)
throws|throws
name|SliderException
throws|,
name|IOException
block|{
return|return
name|ClientUtils
operator|.
name|lookupServiceRecord
argument_list|(
name|getRegistryOperations
argument_list|()
argument_list|,
name|registryArgs
operator|.
name|user
argument_list|,
name|registryArgs
operator|.
name|serviceType
argument_list|,
name|registryArgs
operator|.
name|name
argument_list|)
return|;
block|}
comment|/**    *     * Look up an instance    * @param path path    * @return instance data    * @throws NotFoundException no path/no service record    * at the end of the path    * @throws SliderException other failures    * @throws IOException IO problems or wrapped exceptions    */
DECL|method|resolve (String path)
specifier|public
name|ServiceRecord
name|resolve
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|IOException
throws|,
name|SliderException
block|{
return|return
name|ClientUtils
operator|.
name|resolve
argument_list|(
name|getRegistryOperations
argument_list|()
argument_list|,
name|path
argument_list|)
return|;
block|}
comment|/**    * List instances in the registry for the current user    * @return a list of slider registry instances    * @throws IOException Any IO problem ... including no path in the registry    * to slider service classes for this user    * @throws SliderException other failures    */
DECL|method|listRegistryInstances ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|ServiceRecord
argument_list|>
name|listRegistryInstances
parameter_list|()
throws|throws
name|IOException
throws|,
name|SliderException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|ServiceRecord
argument_list|>
name|recordMap
init|=
name|listServiceRecords
argument_list|(
name|getRegistryOperations
argument_list|()
argument_list|,
name|serviceclassPath
argument_list|(
name|currentUser
argument_list|()
argument_list|,
name|SliderKeys
operator|.
name|APP_TYPE
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|recordMap
return|;
block|}
comment|/**    * List instances in the registry    * @return the instance IDs    * @throws IOException    * @throws YarnException    */
DECL|method|listRegisteredSliderInstances ()
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|listRegisteredSliderInstances
parameter_list|()
throws|throws
name|IOException
throws|,
name|YarnException
block|{
try|try
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|ServiceRecord
argument_list|>
name|recordMap
init|=
name|listServiceRecords
argument_list|(
name|getRegistryOperations
argument_list|()
argument_list|,
name|serviceclassPath
argument_list|(
name|currentUser
argument_list|()
argument_list|,
name|SliderKeys
operator|.
name|APP_TYPE
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|recordMap
operator|.
name|keySet
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|PathNotFoundException
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"No registry path for slider instances for current user: {}"
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// no entries: return an empty list
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|0
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|YarnException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Start the registry if it is not there yet    * @return the registry service    * @throws SliderException    * @throws IOException    */
DECL|method|maybeStartYarnRegistry ()
specifier|private
specifier|synchronized
name|RegistryOperations
name|maybeStartYarnRegistry
parameter_list|()
throws|throws
name|SliderException
throws|,
name|IOException
block|{
if|if
condition|(
name|registryOperations
operator|==
literal|null
condition|)
block|{
name|registryOperations
operator|=
name|startRegistryOperationsService
argument_list|()
expr_stmt|;
block|}
return|return
name|registryOperations
return|;
block|}
annotation|@
name|Override
DECL|method|getRegistryOperations ()
specifier|public
name|RegistryOperations
name|getRegistryOperations
parameter_list|()
throws|throws
name|SliderException
throws|,
name|IOException
block|{
return|return
name|maybeStartYarnRegistry
argument_list|()
return|;
block|}
comment|/**    * Output to standard out/stderr (implementation specific detail)    * @param src source    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"UseOfSystemOutOrSystemErr"
argument_list|)
DECL|method|print (CharSequence src)
specifier|private
specifier|static
name|void
name|print
parameter_list|(
name|CharSequence
name|src
parameter_list|)
block|{
name|clientOutputStream
operator|.
name|append
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
comment|/**    * Output to standard out/stderr with a newline after    * @param message message    */
DECL|method|println (String message)
specifier|private
specifier|static
name|void
name|println
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|print
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|print
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Output to standard out/stderr with a newline after, formatted    * @param message message    * @param args arguments for string formatting    */
DECL|method|println (String message, Object ... args)
specifier|private
specifier|static
name|void
name|println
parameter_list|(
name|String
name|message
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
block|{
name|print
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|message
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|print
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Implement the lookup action.    * @param args Action arguments    * @return 0 if the entry was found    * @throws IOException    * @throws YarnException    * @throws UnknownApplicationInstanceException if a specific instance    * was named but it was not found    */
annotation|@
name|VisibleForTesting
DECL|method|actionLookup (ActionLookupArgs args)
specifier|public
name|int
name|actionLookup
parameter_list|(
name|ActionLookupArgs
name|args
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
name|verifyBindingsDefined
argument_list|()
expr_stmt|;
try|try
block|{
name|ApplicationId
name|id
init|=
name|ConverterUtils
operator|.
name|toApplicationId
argument_list|(
name|args
operator|.
name|id
argument_list|)
decl_stmt|;
name|ApplicationReport
name|report
init|=
name|yarnClient
operator|.
name|getApplicationReport
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|SerializedApplicationReport
name|sar
init|=
operator|new
name|SerializedApplicationReport
argument_list|(
name|report
argument_list|)
decl_stmt|;
name|ApplicationReportSerDeser
name|serDeser
init|=
operator|new
name|ApplicationReportSerDeser
argument_list|()
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|outputFile
operator|!=
literal|null
condition|)
block|{
name|serDeser
operator|.
name|save
argument_list|(
name|sar
argument_list|,
name|args
operator|.
name|outputFile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|println
argument_list|(
name|serDeser
operator|.
name|toJson
argument_list|(
name|sar
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
name|e
argument_list|,
literal|"%s : %s"
argument_list|,
name|args
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ApplicationAttemptNotFoundException
decl||
name|ApplicationNotFoundException
name|notFound
parameter_list|)
block|{
throw|throw
operator|new
name|NotFoundException
argument_list|(
name|notFound
argument_list|,
name|notFound
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
annotation|@
name|Override
DECL|method|actionDependency (ActionDependencyArgs args)
specifier|public
name|int
name|actionDependency
parameter_list|(
name|ActionDependencyArgs
name|args
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
name|String
name|currentUser
init|=
name|getUsername
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Running command as user {}"
argument_list|,
name|currentUser
argument_list|)
expr_stmt|;
name|String
name|version
init|=
name|getSliderVersion
argument_list|()
decl_stmt|;
name|Path
name|dependencyLibTarGzip
init|=
name|sliderFileSystem
operator|.
name|getDependencyTarGzip
argument_list|()
decl_stmt|;
comment|// Check if dependency has already been uploaded, in which case log
comment|// appropriately and exit success (unless overwrite has been requested)
if|if
condition|(
name|sliderFileSystem
operator|.
name|isFile
argument_list|(
name|dependencyLibTarGzip
argument_list|)
operator|&&
operator|!
name|args
operator|.
name|overwrite
condition|)
block|{
name|println
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Dependency libs are already uploaded to %s. Use %s "
operator|+
literal|"if you want to re-upload"
argument_list|,
name|dependencyLibTarGzip
operator|.
name|toUri
argument_list|()
argument_list|,
name|Arguments
operator|.
name|ARG_OVERWRITE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
name|String
index|[]
name|libDirs
init|=
name|SliderUtils
operator|.
name|getLibDirs
argument_list|()
decl_stmt|;
if|if
condition|(
name|libDirs
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|File
name|tempLibTarGzipFile
init|=
name|File
operator|.
name|createTempFile
argument_list|(
name|SliderKeys
operator|.
name|SLIDER_DEPENDENCY_TAR_GZ_FILE_NAME
operator|+
literal|"_"
argument_list|,
name|SliderKeys
operator|.
name|SLIDER_DEPENDENCY_TAR_GZ_FILE_EXT
argument_list|)
decl_stmt|;
comment|// copy all jars
name|tarGzipFolder
argument_list|(
name|libDirs
argument_list|,
name|tempLibTarGzipFile
argument_list|,
name|createJarFilter
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Uploading dependency for AM (version {}) from {} to {}"
argument_list|,
name|version
argument_list|,
name|tempLibTarGzipFile
operator|.
name|toURI
argument_list|()
argument_list|,
name|dependencyLibTarGzip
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
name|sliderFileSystem
operator|.
name|copyLocalFileToHdfs
argument_list|(
name|tempLibTarGzipFile
argument_list|,
name|dependencyLibTarGzip
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|SliderKeys
operator|.
name|SLIDER_DEPENDENCY_DIR_PERMISSIONS
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
else|else
block|{
return|return
name|EXIT_FALSE
return|;
block|}
block|}
DECL|method|actionHelp (String actionName)
specifier|private
name|int
name|actionHelp
parameter_list|(
name|String
name|actionName
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
throw|throw
operator|new
name|UsageException
argument_list|(
name|CommonArgs
operator|.
name|usage
argument_list|(
name|serviceArgs
argument_list|,
name|actionName
argument_list|)
argument_list|)
throw|;
block|}
DECL|method|actionHelp (String errMsg, String actionName)
specifier|private
name|int
name|actionHelp
parameter_list|(
name|String
name|errMsg
parameter_list|,
name|String
name|actionName
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
throw|throw
operator|new
name|UsageException
argument_list|(
literal|"%s %s"
argument_list|,
name|errMsg
argument_list|,
name|CommonArgs
operator|.
name|usage
argument_list|(
name|serviceArgs
argument_list|,
name|actionName
argument_list|)
argument_list|)
throw|;
block|}
comment|/**    * List the nodes in the cluster, possibly filtering by node state or label.    *    * @param args argument list    * @return a possibly empty list of nodes in the cluster    * @throws IOException IO problems    * @throws YarnException YARN problems    */
annotation|@
name|Override
DECL|method|listYarnClusterNodes (ActionNodesArgs args)
specifier|public
name|NodeInformationList
name|listYarnClusterNodes
parameter_list|(
name|ActionNodesArgs
name|args
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
return|return
name|yarnClient
operator|.
name|listNodes
argument_list|(
name|args
operator|.
name|label
argument_list|,
name|args
operator|.
name|healthy
argument_list|)
return|;
block|}
comment|/**    * List the nodes in the cluster, possibly filtering by node state or label.    *    * @param args argument list    * @return a possibly empty list of nodes in the cluster    * @throws IOException IO problems    * @throws YarnException YARN problems    */
DECL|method|listInstanceNodes (String instance, ActionNodesArgs args)
specifier|public
name|NodeInformationList
name|listInstanceNodes
parameter_list|(
name|String
name|instance
parameter_list|,
name|ActionNodesArgs
name|args
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
comment|// TODO
name|log
operator|.
name|info
argument_list|(
literal|"listInstanceNodes {}"
argument_list|,
name|instance
argument_list|)
expr_stmt|;
name|SliderClusterOperations
name|clusterOps
init|=
operator|new
name|SliderClusterOperations
argument_list|(
name|bondToCluster
argument_list|(
name|instance
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|clusterOps
operator|.
name|getLiveNodes
argument_list|()
return|;
block|}
comment|/**    * List the nodes in the cluster, possibly filtering by node state or label.    * Prints them to stdout unless the args names a file instead.    * @param args argument list    * @throws IOException IO problems    * @throws YarnException YARN problems    */
DECL|method|actionNodes (String instance, ActionNodesArgs args)
specifier|public
name|int
name|actionNodes
parameter_list|(
name|String
name|instance
parameter_list|,
name|ActionNodesArgs
name|args
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|args
operator|.
name|instance
operator|=
name|instance
expr_stmt|;
name|NodeInformationList
name|nodes
decl_stmt|;
if|if
condition|(
name|SliderUtils
operator|.
name|isUnset
argument_list|(
name|instance
argument_list|)
condition|)
block|{
name|nodes
operator|=
name|listYarnClusterNodes
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodes
operator|=
name|listInstanceNodes
argument_list|(
name|instance
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"Node listing for {} has {} nodes"
argument_list|,
name|args
argument_list|,
name|nodes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|JsonSerDeser
argument_list|<
name|NodeInformationList
argument_list|>
name|serDeser
init|=
name|NodeInformationList
operator|.
name|createSerializer
argument_list|()
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|outputFile
operator|!=
literal|null
condition|)
block|{
name|serDeser
operator|.
name|save
argument_list|(
name|nodes
argument_list|,
name|args
operator|.
name|outputFile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|println
argument_list|(
name|serDeser
operator|.
name|toJson
argument_list|(
name|nodes
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/**    * Create a new IPC client for talking to slider via what follows the REST API.    * Client must already be bonded to the cluster    * @return a new IPC client    */
DECL|method|createIpcClient ()
specifier|public
name|SliderApplicationApi
name|createIpcClient
parameter_list|()
throws|throws
name|IOException
throws|,
name|YarnException
block|{
return|return
operator|new
name|SliderApplicationIpcClient
argument_list|(
name|createClusterOperations
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Save/list tokens. This is for testing oozie integration    * @param args commands    * @return status    */
DECL|method|actionTokens (ActionTokensArgs args)
specifier|private
name|int
name|actionTokens
parameter_list|(
name|ActionTokensArgs
name|args
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
return|return
operator|new
name|TokensOperation
argument_list|()
operator|.
name|actionTokens
argument_list|(
name|args
argument_list|,
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|getConfig
argument_list|()
argument_list|,
name|yarnClient
argument_list|)
return|;
block|}
block|}
end_class

end_unit

