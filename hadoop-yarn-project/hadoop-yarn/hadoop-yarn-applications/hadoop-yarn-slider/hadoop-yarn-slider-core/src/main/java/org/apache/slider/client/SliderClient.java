begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License. */
end_comment

begin_package
DECL|package|org.apache.slider.client
package|package
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|client
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|ArrayUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|api
operator|.
name|RegistryConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|api
operator|.
name|RegistryOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryPathUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|exceptions
operator|.
name|NoRecordException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|Endpoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|RegistryPathStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|ServiceRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|yarn
operator|.
name|YarnRegistryAttributes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|Credentials
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|KerberosDiags
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|ApplicationConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|UpdateApplicationTimeoutsRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationSubmissionContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationTimeout
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationTimeoutType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerLaunchContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|LocalResource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|LocalResourceType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|YarnApplicationState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|api
operator|.
name|YarnClientApplication
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|ApplicationAttemptNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|ApplicationNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|ConverterUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|Records
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|Times
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|SliderClusterProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|proto
operator|.
name|Messages
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|resource
operator|.
name|Application
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|resource
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|types
operator|.
name|ContainerInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|types
operator|.
name|NodeInformationList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|client
operator|.
name|ipc
operator|.
name|SliderClusterOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|SliderExitCodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|SliderKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|SliderXmlConfKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|AbstractActionArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|AbstractClusterBuildingActionArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionAMSuicideArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionClientArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionDependencyArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionDiagnosticArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionExistsArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionFlexArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionFreezeArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionKDiagArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionKeytabArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionKillContainerArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionListArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionLookupArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionNodesArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionRegistryArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionResolveArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionResourceArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionStatusArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionThawArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionTokensArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionUpgradeArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|Arguments
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ClientArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|CommonArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|ConfigHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|Duration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|SliderFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|SliderUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|SliderVersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|BadClusterStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|BadCommandArgumentsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|BadConfigException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|ErrorStrings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|NoSuchNodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|NotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|SliderException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|UnknownApplicationInstanceException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|UsageException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|launch
operator|.
name|ClasspathConstructor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|launch
operator|.
name|CredentialUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|launch
operator|.
name|JavaCommandLineBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|launch
operator|.
name|SerializedApplicationReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|main
operator|.
name|RunService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|persist
operator|.
name|ApplicationReportSerDeser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|persist
operator|.
name|JsonSerDeser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|registry
operator|.
name|SliderRegistryUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|registry
operator|.
name|YarnAppListClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|registry
operator|.
name|docstore
operator|.
name|ConfigFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|registry
operator|.
name|docstore
operator|.
name|PublishedConfigSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|registry
operator|.
name|docstore
operator|.
name|PublishedConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|registry
operator|.
name|docstore
operator|.
name|PublishedExports
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|registry
operator|.
name|docstore
operator|.
name|PublishedExportsOutputter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|registry
operator|.
name|docstore
operator|.
name|PublishedExportsSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|registry
operator|.
name|retrieve
operator|.
name|RegistryRetriever
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|zk
operator|.
name|BlockingZKWatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|zk
operator|.
name|ZKIntegration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|providers
operator|.
name|AbstractClientProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|providers
operator|.
name|ProviderUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|SliderAppMaster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|rpc
operator|.
name|RpcBinder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|services
operator|.
name|utility
operator|.
name|AbstractSliderLaunchedService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|util
operator|.
name|ServiceApiUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|CreateMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|ZooDefs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|ACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|map
operator|.
name|PropertyNamingStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|binding
operator|.
name|RegistryUtils
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|Constants
operator|.
name|HADOOP_JAAS_DEBUG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|SliderActions
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|SliderUtils
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Client service for Slider  */
end_comment

begin_class
DECL|class|SliderClient
specifier|public
class|class
name|SliderClient
extends|extends
name|AbstractSliderLaunchedService
implements|implements
name|RunService
implements|,
name|SliderExitCodes
implements|,
name|SliderKeys
implements|,
name|ErrorStrings
implements|,
name|SliderClientAPI
block|{
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SliderClient
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|E_MUST_BE_A_VALID_JSON_FILE
specifier|public
specifier|static
specifier|final
name|String
name|E_MUST_BE_A_VALID_JSON_FILE
init|=
literal|"Invalid configuration. Must be a valid json file."
decl_stmt|;
DECL|field|E_INVALID_INSTALL_LOCATION
specifier|public
specifier|static
specifier|final
name|String
name|E_INVALID_INSTALL_LOCATION
init|=
literal|"A valid install location must be provided for the client."
decl_stmt|;
DECL|field|E_UNABLE_TO_READ_SUPPLIED_PACKAGE_FILE
specifier|public
specifier|static
specifier|final
name|String
name|E_UNABLE_TO_READ_SUPPLIED_PACKAGE_FILE
init|=
literal|"Unable to read supplied package file"
decl_stmt|;
DECL|field|E_INVALID_APPLICATION_PACKAGE_LOCATION
specifier|public
specifier|static
specifier|final
name|String
name|E_INVALID_APPLICATION_PACKAGE_LOCATION
init|=
literal|"A valid application package location required."
decl_stmt|;
DECL|field|E_INVALID_INSTALL_PATH
specifier|public
specifier|static
specifier|final
name|String
name|E_INVALID_INSTALL_PATH
init|=
literal|"Install path is not a valid directory"
decl_stmt|;
DECL|field|E_INSTALL_PATH_DOES_NOT_EXIST
specifier|public
specifier|static
specifier|final
name|String
name|E_INSTALL_PATH_DOES_NOT_EXIST
init|=
literal|"Install path does not exist"
decl_stmt|;
DECL|field|E_INVALID_APPLICATION_TYPE_NAME
specifier|public
specifier|static
specifier|final
name|String
name|E_INVALID_APPLICATION_TYPE_NAME
init|=
literal|"A valid application type name is required (e.g. HBASE)."
decl_stmt|;
DECL|field|E_USE_REPLACEPKG_TO_OVERWRITE
specifier|public
specifier|static
specifier|final
name|String
name|E_USE_REPLACEPKG_TO_OVERWRITE
init|=
literal|"Use --replacepkg to overwrite."
decl_stmt|;
DECL|field|E_PACKAGE_DOES_NOT_EXIST
specifier|public
specifier|static
specifier|final
name|String
name|E_PACKAGE_DOES_NOT_EXIST
init|=
literal|"Package does not exist"
decl_stmt|;
DECL|field|E_NO_ZOOKEEPER_QUORUM
specifier|public
specifier|static
specifier|final
name|String
name|E_NO_ZOOKEEPER_QUORUM
init|=
literal|"No Zookeeper quorum defined"
decl_stmt|;
DECL|field|E_NO_RESOURCE_MANAGER
specifier|public
specifier|static
specifier|final
name|String
name|E_NO_RESOURCE_MANAGER
init|=
literal|"No valid Resource Manager address provided"
decl_stmt|;
DECL|field|E_PACKAGE_EXISTS
specifier|public
specifier|static
specifier|final
name|String
name|E_PACKAGE_EXISTS
init|=
literal|"Package exists"
decl_stmt|;
DECL|field|clientOutputStream
specifier|private
specifier|static
name|PrintStream
name|clientOutputStream
init|=
name|System
operator|.
name|out
decl_stmt|;
DECL|field|jsonSerDeser
specifier|private
specifier|static
specifier|final
name|JsonSerDeser
argument_list|<
name|Application
argument_list|>
name|jsonSerDeser
init|=
operator|new
name|JsonSerDeser
argument_list|<
name|Application
argument_list|>
argument_list|(
name|Application
operator|.
name|class
argument_list|,
name|PropertyNamingStrategy
operator|.
name|CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES
argument_list|)
decl_stmt|;
comment|// value should not be changed without updating string find in slider.py
DECL|field|PASSWORD_PROMPT
specifier|private
specifier|static
specifier|final
name|String
name|PASSWORD_PROMPT
init|=
literal|"Enter password for"
decl_stmt|;
DECL|field|serviceArgs
specifier|private
name|ClientArgs
name|serviceArgs
decl_stmt|;
DECL|field|applicationId
specifier|public
name|ApplicationId
name|applicationId
decl_stmt|;
DECL|field|deployedClusterName
specifier|private
name|String
name|deployedClusterName
decl_stmt|;
comment|/**    * Cluster operations against the deployed cluster -will be null    * if no bonding has yet taken place    */
DECL|field|sliderClusterOperations
specifier|private
name|SliderClusterOperations
name|sliderClusterOperations
decl_stmt|;
DECL|field|sliderFileSystem
specifier|protected
name|SliderFileSystem
name|sliderFileSystem
decl_stmt|;
comment|/**    * Yarn client service    */
DECL|field|yarnClient
specifier|private
name|SliderYarnClientImpl
name|yarnClient
decl_stmt|;
DECL|field|yarnAppListClient
specifier|private
name|YarnAppListClient
name|yarnAppListClient
decl_stmt|;
comment|/**    * The YARN registry service    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"FieldAccessedSynchronizedAndUnsynchronized"
argument_list|)
DECL|field|registryOperations
specifier|private
name|RegistryOperations
name|registryOperations
decl_stmt|;
DECL|field|terminatedStates
specifier|private
specifier|static
name|EnumSet
argument_list|<
name|YarnApplicationState
argument_list|>
name|terminatedStates
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|YarnApplicationState
operator|.
name|FINISHED
argument_list|,
name|YarnApplicationState
operator|.
name|FAILED
argument_list|,
name|YarnApplicationState
operator|.
name|KILLED
argument_list|)
decl_stmt|;
comment|/**    * Constructor    */
DECL|method|SliderClient ()
specifier|public
name|SliderClient
parameter_list|()
block|{
name|super
argument_list|(
literal|"Slider Client"
argument_list|)
expr_stmt|;
operator|new
name|HdfsConfiguration
argument_list|()
expr_stmt|;
operator|new
name|YarnConfiguration
argument_list|()
expr_stmt|;
block|}
comment|/**    * This is called<i>Before serviceInit is called</i>    * @param config the initial configuration build up by the    * service launcher.    * @param args argument list list of arguments passed to the command line    * after any launcher-specific commands have been stripped.    * @return the post-binding configuration to pass to the<code>init()</code>    * operation.    * @throws Exception    */
annotation|@
name|Override
DECL|method|bindArgs (Configuration config, String... args)
specifier|public
name|Configuration
name|bindArgs
parameter_list|(
name|Configuration
name|config
parameter_list|,
name|String
modifier|...
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|config
operator|=
name|super
operator|.
name|bindArgs
argument_list|(
name|config
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|serviceArgs
operator|=
operator|new
name|ClientArgs
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|serviceArgs
operator|.
name|parse
argument_list|()
expr_stmt|;
comment|// yarn-ify
name|YarnConfiguration
name|yarnConfiguration
init|=
operator|new
name|YarnConfiguration
argument_list|(
name|config
argument_list|)
decl_stmt|;
return|return
name|patchConfiguration
argument_list|(
name|yarnConfiguration
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|serviceInit (Configuration conf)
specifier|protected
name|void
name|serviceInit
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
name|Configuration
name|clientConf
init|=
name|loadSliderClientXML
argument_list|()
decl_stmt|;
name|ConfigHelper
operator|.
name|mergeConfigurations
argument_list|(
name|conf
argument_list|,
name|clientConf
argument_list|,
name|SLIDER_CLIENT_XML
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|serviceArgs
operator|.
name|applyDefinitions
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|serviceArgs
operator|.
name|applyFileSystemBinding
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|AbstractActionArgs
name|coreAction
init|=
name|serviceArgs
operator|.
name|getCoreAction
argument_list|()
decl_stmt|;
comment|// init security with our conf
if|if
condition|(
operator|!
name|coreAction
operator|.
name|disableSecureLogin
argument_list|()
operator|&&
name|isHadoopClusterSecure
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|forceLogin
argument_list|()
expr_stmt|;
name|initProcessSecurity
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|coreAction
operator|.
name|getHadoopServicesRequired
argument_list|()
condition|)
block|{
name|initHadoopBinding
argument_list|()
expr_stmt|;
block|}
name|super
operator|.
name|serviceInit
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Launched service execution. This runs {@link #exec()}    * then catches some exceptions and converts them to exit codes    * @return an exit code    * @throws Throwable    */
annotation|@
name|Override
DECL|method|runService ()
specifier|public
name|int
name|runService
parameter_list|()
throws|throws
name|Throwable
block|{
try|try
block|{
return|return
name|exec
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
decl||
name|PathNotFoundException
name|nfe
parameter_list|)
block|{
throw|throw
operator|new
name|NotFoundException
argument_list|(
name|nfe
argument_list|,
name|nfe
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Execute the command line    * @return an exit code    * @throws Throwable on a failure    */
DECL|method|exec ()
specifier|public
name|int
name|exec
parameter_list|()
throws|throws
name|Throwable
block|{
comment|// choose the action
name|String
name|action
init|=
name|serviceArgs
operator|.
name|getAction
argument_list|()
decl_stmt|;
if|if
condition|(
name|isUnset
argument_list|(
name|action
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SliderException
argument_list|(
name|EXIT_USAGE
argument_list|,
name|serviceArgs
operator|.
name|usage
argument_list|()
argument_list|)
throw|;
block|}
name|int
name|exitCode
init|=
name|EXIT_SUCCESS
decl_stmt|;
name|String
name|clusterName
init|=
name|serviceArgs
operator|.
name|getClusterName
argument_list|()
decl_stmt|;
comment|// actions
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|ACTION_AM_SUICIDE
case|:
name|exitCode
operator|=
name|actionAmSuicide
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionAMSuicideArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_BUILD
case|:
name|exitCode
operator|=
name|actionBuild
argument_list|(
name|getApplicationFromArgs
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionBuildArgs
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_CLIENT
case|:
name|exitCode
operator|=
name|actionClient
argument_list|(
name|serviceArgs
operator|.
name|getActionClientArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_CREATE
case|:
name|actionCreate
argument_list|(
name|getApplicationFromArgs
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionCreateArgs
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_DEPENDENCY
case|:
name|exitCode
operator|=
name|actionDependency
argument_list|(
name|serviceArgs
operator|.
name|getActionDependencyArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_DESTROY
case|:
name|actionDestroy
argument_list|(
name|clusterName
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_DIAGNOSTICS
case|:
name|exitCode
operator|=
name|actionDiagnostic
argument_list|(
name|serviceArgs
operator|.
name|getActionDiagnosticArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_EXISTS
case|:
name|exitCode
operator|=
name|actionExists
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionExistsArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_FLEX
case|:
name|actionFlex
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionFlexArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_STOP
case|:
name|actionStop
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionFreezeArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_HELP
case|:
name|log
operator|.
name|info
argument_list|(
name|serviceArgs
operator|.
name|usage
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_KDIAG
case|:
name|exitCode
operator|=
name|actionKDiag
argument_list|(
name|serviceArgs
operator|.
name|getActionKDiagArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_KILL_CONTAINER
case|:
name|exitCode
operator|=
name|actionKillContainer
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionKillContainerArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_KEYTAB
case|:
name|exitCode
operator|=
name|actionKeytab
argument_list|(
name|serviceArgs
operator|.
name|getActionKeytabArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_LIST
case|:
name|exitCode
operator|=
name|actionList
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionListArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_LOOKUP
case|:
name|exitCode
operator|=
name|actionLookup
argument_list|(
name|serviceArgs
operator|.
name|getActionLookupArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_NODES
case|:
name|exitCode
operator|=
name|actionNodes
argument_list|(
literal|""
argument_list|,
name|serviceArgs
operator|.
name|getActionNodesArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_REGISTRY
case|:
name|exitCode
operator|=
name|actionRegistry
argument_list|(
name|serviceArgs
operator|.
name|getActionRegistryArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_RESOLVE
case|:
name|exitCode
operator|=
name|actionResolve
argument_list|(
name|serviceArgs
operator|.
name|getActionResolveArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_RESOURCE
case|:
name|exitCode
operator|=
name|actionResource
argument_list|(
name|serviceArgs
operator|.
name|getActionResourceArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_STATUS
case|:
name|exitCode
operator|=
name|actionStatus
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionStatusArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_START
case|:
name|exitCode
operator|=
name|actionStart
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionThawArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_TOKENS
case|:
name|exitCode
operator|=
name|actionTokens
argument_list|(
name|serviceArgs
operator|.
name|getActionTokenArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_UPDATE
case|:
name|exitCode
operator|=
name|actionUpdate
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionUpdateArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_UPGRADE
case|:
name|exitCode
operator|=
name|actionUpgrade
argument_list|(
name|clusterName
argument_list|,
name|serviceArgs
operator|.
name|getActionUpgradeArgs
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_VERSION
case|:
name|exitCode
operator|=
name|actionVersion
argument_list|()
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|SliderException
argument_list|(
name|EXIT_UNIMPLEMENTED
argument_list|,
literal|"Unimplemented: "
operator|+
name|action
argument_list|)
throw|;
block|}
return|return
name|exitCode
return|;
block|}
comment|/**    * Perform everything needed to init the hadoop binding.    * This assumes that the service is already  in inited or started state    * @throws IOException    * @throws SliderException    */
DECL|method|initHadoopBinding ()
specifier|protected
name|void
name|initHadoopBinding
parameter_list|()
throws|throws
name|IOException
throws|,
name|SliderException
block|{
comment|// validate the client
name|validateSliderClientEnvironment
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|//create the YARN client
name|yarnClient
operator|=
operator|new
name|SliderYarnClientImpl
argument_list|()
expr_stmt|;
name|yarnClient
operator|.
name|init
argument_list|(
name|getConfig
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|getServiceState
argument_list|()
operator|==
name|STATE
operator|.
name|STARTED
condition|)
block|{
name|yarnClient
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|addService
argument_list|(
name|yarnClient
argument_list|)
expr_stmt|;
name|yarnAppListClient
operator|=
operator|new
name|YarnAppListClient
argument_list|(
name|yarnClient
argument_list|,
name|getUsername
argument_list|()
argument_list|,
name|getConfig
argument_list|()
argument_list|)
expr_stmt|;
comment|// create the filesystem
name|sliderFileSystem
operator|=
operator|new
name|SliderFileSystem
argument_list|(
name|getConfig
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete the zookeeper node associated with the calling user and the cluster    * TODO: YARN registry operations    **/
annotation|@
name|VisibleForTesting
DECL|method|deleteZookeeperNode (String clusterName)
specifier|public
name|boolean
name|deleteZookeeperNode
parameter_list|(
name|String
name|clusterName
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|String
name|user
init|=
name|getUsername
argument_list|()
decl_stmt|;
name|String
name|zkPath
init|=
name|ZKIntegration
operator|.
name|mkClusterPath
argument_list|(
name|user
argument_list|,
name|clusterName
argument_list|)
decl_stmt|;
name|Exception
name|e
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ZKIntegration
name|client
init|=
name|getZkClient
argument_list|(
name|clusterName
argument_list|,
name|user
argument_list|)
decl_stmt|;
if|if
condition|(
name|client
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|client
operator|.
name|exists
argument_list|(
name|zkPath
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Deleting zookeeper path {}"
argument_list|,
name|zkPath
argument_list|)
expr_stmt|;
block|}
name|client
operator|.
name|deleteRecursive
argument_list|(
name|zkPath
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
decl||
name|BadConfigException
decl||
name|KeeperException
name|ex
parameter_list|)
block|{
name|e
operator|=
name|ex
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to recursively delete zk node {}"
argument_list|,
name|zkPath
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Create the zookeeper node associated with the calling user and the cluster    *    * @param clusterName slider application name    * @param nameOnly should the name only be created (i.e. don't create ZK node)    * @return the path, using the policy implemented in    *   {@link ZKIntegration#mkClusterPath(String, String)}    * @throws YarnException    * @throws IOException    */
annotation|@
name|VisibleForTesting
DECL|method|createZookeeperNode (String clusterName, Boolean nameOnly)
specifier|public
name|String
name|createZookeeperNode
parameter_list|(
name|String
name|clusterName
parameter_list|,
name|Boolean
name|nameOnly
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
try|try
block|{
return|return
name|createZookeeperNodeInner
argument_list|(
name|clusterName
argument_list|,
name|nameOnly
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NodeExistsException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InterruptedIOException
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Create the zookeeper node associated with the calling user and the cluster    * -throwing exceptions on any failure    * @param clusterName cluster name    * @param nameOnly create the path, not the node    * @return the path, using the policy implemented in    *   {@link ZKIntegration#mkClusterPath(String, String)}    * @throws YarnException    * @throws IOException    * @throws KeeperException    * @throws InterruptedException    */
annotation|@
name|VisibleForTesting
DECL|method|createZookeeperNodeInner (String clusterName, Boolean nameOnly)
specifier|public
name|String
name|createZookeeperNodeInner
parameter_list|(
name|String
name|clusterName
parameter_list|,
name|Boolean
name|nameOnly
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
throws|,
name|KeeperException
throws|,
name|InterruptedException
block|{
name|String
name|user
init|=
name|getUsername
argument_list|()
decl_stmt|;
name|String
name|zkPath
init|=
name|ZKIntegration
operator|.
name|mkClusterPath
argument_list|(
name|user
argument_list|,
name|clusterName
argument_list|)
decl_stmt|;
if|if
condition|(
name|nameOnly
condition|)
block|{
return|return
name|zkPath
return|;
block|}
name|ZKIntegration
name|client
init|=
name|getZkClient
argument_list|(
name|clusterName
argument_list|,
name|user
argument_list|)
decl_stmt|;
if|if
condition|(
name|client
operator|!=
literal|null
condition|)
block|{
comment|// set up the permissions. This must be done differently on a secure cluster from an insecure
comment|// one
name|List
argument_list|<
name|ACL
argument_list|>
name|zkperms
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|zkperms
operator|.
name|add
argument_list|(
operator|new
name|ACL
argument_list|(
name|ZooDefs
operator|.
name|Perms
operator|.
name|ALL
argument_list|,
name|ZooDefs
operator|.
name|Ids
operator|.
name|AUTH_IDS
argument_list|)
argument_list|)
expr_stmt|;
name|zkperms
operator|.
name|add
argument_list|(
operator|new
name|ACL
argument_list|(
name|ZooDefs
operator|.
name|Perms
operator|.
name|READ
argument_list|,
name|ZooDefs
operator|.
name|Ids
operator|.
name|ANYONE_ID_UNSAFE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zkperms
operator|.
name|add
argument_list|(
operator|new
name|ACL
argument_list|(
name|ZooDefs
operator|.
name|Perms
operator|.
name|ALL
argument_list|,
name|ZooDefs
operator|.
name|Ids
operator|.
name|ANYONE_ID_UNSAFE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|client
operator|.
name|createPath
argument_list|(
name|zkPath
argument_list|,
literal|""
argument_list|,
name|zkperms
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|)
expr_stmt|;
return|return
name|zkPath
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Gets a zookeeper client, returns null if it cannot connect to zookeeper    **/
DECL|method|getZkClient (String clusterName, String user)
specifier|protected
name|ZKIntegration
name|getZkClient
parameter_list|(
name|String
name|clusterName
parameter_list|,
name|String
name|user
parameter_list|)
throws|throws
name|YarnException
block|{
name|String
name|registryQuorum
init|=
name|lookupZKQuorum
argument_list|()
decl_stmt|;
name|ZKIntegration
name|client
init|=
literal|null
decl_stmt|;
try|try
block|{
name|BlockingZKWatcher
name|watcher
init|=
operator|new
name|BlockingZKWatcher
argument_list|()
decl_stmt|;
name|client
operator|=
name|ZKIntegration
operator|.
name|newInstance
argument_list|(
name|registryQuorum
argument_list|,
name|user
argument_list|,
name|clusterName
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
name|watcher
argument_list|,
name|ZKIntegration
operator|.
name|SESSION_TIMEOUT
argument_list|)
expr_stmt|;
name|boolean
name|fromCache
init|=
name|client
operator|.
name|init
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|fromCache
condition|)
block|{
name|watcher
operator|.
name|waitForZKConnection
argument_list|(
literal|2
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|client
operator|=
literal|null
expr_stmt|;
name|log
operator|.
name|warn
argument_list|(
literal|"Interrupted - unable to connect to zookeeper quorum {}"
argument_list|,
name|registryQuorum
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Unable to connect to zookeeper quorum {}"
argument_list|,
name|registryQuorum
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|client
return|;
block|}
comment|/**    * Keep this signature for backward compatibility with    * force=true by default.    */
annotation|@
name|Override
DECL|method|actionDestroy (String appName)
specifier|public
name|int
name|actionDestroy
parameter_list|(
name|String
name|appName
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|validateClusterName
argument_list|(
name|appName
argument_list|)
expr_stmt|;
name|verifyNoLiveApp
argument_list|(
name|appName
argument_list|,
literal|"Destroy"
argument_list|)
expr_stmt|;
name|Path
name|appDir
init|=
name|sliderFileSystem
operator|.
name|buildClusterDirPath
argument_list|(
name|appName
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|appDir
argument_list|)
condition|)
block|{
if|if
condition|(
name|fs
operator|.
name|delete
argument_list|(
name|appDir
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Successfully deleted application dir for "
operator|+
name|appName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|message
init|=
literal|"Failed to delete application + "
operator|+
name|appName
operator|+
literal|" at:  "
operator|+
name|appDir
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|YarnException
argument_list|(
name|message
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|deleteZookeeperNode
argument_list|(
name|appName
argument_list|)
condition|)
block|{
name|String
name|message
init|=
literal|"Failed to cleanup cleanup application "
operator|+
name|appName
operator|+
literal|" in zookeeper"
decl_stmt|;
name|log
operator|.
name|warn
argument_list|(
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|YarnException
argument_list|(
name|message
argument_list|)
throw|;
block|}
comment|//TODO clean registry?
name|String
name|registryPath
init|=
name|SliderRegistryUtils
operator|.
name|registryPathForInstance
argument_list|(
name|appName
argument_list|)
decl_stmt|;
try|try
block|{
name|getRegistryOperations
argument_list|()
operator|.
name|delete
argument_list|(
name|registryPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Error deleting registry entry {}: {} "
argument_list|,
name|registryPath
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SliderException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Error binding to registry {} "
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Destroyed cluster {}"
argument_list|,
name|appName
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
annotation|@
name|Override
DECL|method|actionAmSuicide (String clustername, ActionAMSuicideArgs args)
specifier|public
name|int
name|actionAmSuicide
parameter_list|(
name|String
name|clustername
parameter_list|,
name|ActionAMSuicideArgs
name|args
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|SliderClusterOperations
name|clusterOperations
init|=
name|createClusterOperations
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
name|clusterOperations
operator|.
name|amSuicide
argument_list|(
name|args
operator|.
name|message
argument_list|,
name|args
operator|.
name|exitcode
argument_list|,
name|args
operator|.
name|waittime
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
DECL|method|getApplicationFromArgs (String clusterName, AbstractClusterBuildingActionArgs args)
specifier|private
name|Application
name|getApplicationFromArgs
parameter_list|(
name|String
name|clusterName
parameter_list|,
name|AbstractClusterBuildingActionArgs
name|args
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|file
init|=
name|args
operator|.
name|getAppDef
argument_list|()
decl_stmt|;
name|Path
name|filePath
init|=
operator|new
name|Path
argument_list|(
name|file
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Loading app definition from: "
operator|+
name|filePath
argument_list|)
expr_stmt|;
name|Application
name|application
init|=
name|jsonSerDeser
operator|.
name|load
argument_list|(
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|getConfig
argument_list|()
argument_list|)
argument_list|,
name|filePath
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|lifetime
operator|>
literal|0
condition|)
block|{
name|application
operator|.
name|setLifetime
argument_list|(
name|args
operator|.
name|lifetime
argument_list|)
expr_stmt|;
block|}
name|application
operator|.
name|setName
argument_list|(
name|clusterName
argument_list|)
expr_stmt|;
return|return
name|application
return|;
block|}
DECL|method|actionBuild (Application application)
specifier|public
name|int
name|actionBuild
parameter_list|(
name|Application
name|application
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|Path
name|appDir
init|=
name|checkAppNotExistOnHdfs
argument_list|(
name|application
argument_list|)
decl_stmt|;
name|ServiceApiUtil
operator|.
name|validateAndResolveApplication
argument_list|(
name|application
argument_list|,
name|sliderFileSystem
argument_list|)
expr_stmt|;
name|persistApp
argument_list|(
name|appDir
argument_list|,
name|application
argument_list|)
expr_stmt|;
name|deployedClusterName
operator|=
name|application
operator|.
name|getName
argument_list|()
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
DECL|method|actionCreate (Application application)
specifier|public
name|ApplicationId
name|actionCreate
parameter_list|(
name|Application
name|application
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
name|String
name|appName
init|=
name|application
operator|.
name|getName
argument_list|()
decl_stmt|;
name|validateClusterName
argument_list|(
name|appName
argument_list|)
expr_stmt|;
name|ServiceApiUtil
operator|.
name|validateAndResolveApplication
argument_list|(
name|application
argument_list|,
name|sliderFileSystem
argument_list|)
expr_stmt|;
name|verifyNoLiveApp
argument_list|(
name|appName
argument_list|,
literal|"Create"
argument_list|)
expr_stmt|;
name|Path
name|appDir
init|=
name|checkAppNotExistOnHdfs
argument_list|(
name|application
argument_list|)
decl_stmt|;
name|ApplicationId
name|appId
init|=
name|submitApp
argument_list|(
name|application
argument_list|)
decl_stmt|;
name|application
operator|.
name|setId
argument_list|(
name|appId
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// write app definition on to hdfs
name|persistApp
argument_list|(
name|appDir
argument_list|,
name|application
argument_list|)
expr_stmt|;
return|return
name|appId
return|;
comment|//TODO deal with registry
block|}
DECL|method|submitApp (Application app)
specifier|private
name|ApplicationId
name|submitApp
parameter_list|(
name|Application
name|app
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
name|String
name|appName
init|=
name|app
operator|.
name|getName
argument_list|()
decl_stmt|;
name|Configuration
name|conf
init|=
name|getConfig
argument_list|()
decl_stmt|;
name|Path
name|appRootDir
init|=
name|sliderFileSystem
operator|.
name|buildClusterDirPath
argument_list|(
name|app
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|deployedClusterName
operator|=
name|appName
expr_stmt|;
name|YarnClientApplication
name|yarnApp
init|=
name|yarnClient
operator|.
name|createApplication
argument_list|()
decl_stmt|;
name|ApplicationSubmissionContext
name|submissionContext
init|=
name|yarnApp
operator|.
name|getApplicationSubmissionContext
argument_list|()
decl_stmt|;
name|applicationId
operator|=
name|submissionContext
operator|.
name|getApplicationId
argument_list|()
expr_stmt|;
name|submissionContext
operator|.
name|setKeepContainersAcrossApplicationAttempts
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|app
operator|.
name|getLifetime
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Map
argument_list|<
name|ApplicationTimeoutType
argument_list|,
name|Long
argument_list|>
name|appTimeout
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|appTimeout
operator|.
name|put
argument_list|(
name|ApplicationTimeoutType
operator|.
name|LIFETIME
argument_list|,
name|app
operator|.
name|getLifetime
argument_list|()
argument_list|)
expr_stmt|;
name|submissionContext
operator|.
name|setApplicationTimeouts
argument_list|(
name|appTimeout
argument_list|)
expr_stmt|;
block|}
name|submissionContext
operator|.
name|setMaxAppAttempts
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|KEY_AM_RESTART_LIMIT
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|LocalResource
argument_list|>
name|localResources
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// copy local slideram-log4j.properties to hdfs and add to localResources
name|boolean
name|hasSliderAMLog4j
init|=
name|addAMLog4jResource
argument_list|(
name|appName
argument_list|,
name|conf
argument_list|,
name|localResources
argument_list|)
decl_stmt|;
comment|// copy jars to hdfs and add to localResources
name|addJarResource
argument_list|(
name|appName
argument_list|,
name|localResources
argument_list|)
expr_stmt|;
comment|// add keytab if in secure env
name|addKeytabResourceIfSecure
argument_list|(
name|sliderFileSystem
argument_list|,
name|localResources
argument_list|,
name|conf
argument_list|,
name|appName
argument_list|)
expr_stmt|;
name|printLocalResources
argument_list|(
name|localResources
argument_list|)
expr_stmt|;
comment|//TODO SliderAMClientProvider#copyEnvVars
comment|//TODO localResource putEnv
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
init|=
name|addAMEnv
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// create AM CLI
name|String
name|cmdStr
init|=
name|buildCommandLine
argument_list|(
name|appName
argument_list|,
name|conf
argument_list|,
name|appRootDir
argument_list|,
name|hasSliderAMLog4j
argument_list|)
decl_stmt|;
comment|//TODO set log aggregation context
comment|//TODO set retry window
name|submissionContext
operator|.
name|setResource
argument_list|(
name|Resource
operator|.
name|newInstance
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
name|KEY_AM_RESOURCE_MEM
argument_list|,
name|DEFAULT_KEY_AM_RESOURCE_MEM
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|submissionContext
operator|.
name|setQueue
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|KEY_YARN_QUEUE
argument_list|,
name|app
operator|.
name|getQueue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|submissionContext
operator|.
name|setApplicationName
argument_list|(
name|appName
argument_list|)
expr_stmt|;
name|submissionContext
operator|.
name|setApplicationType
argument_list|(
name|SliderKeys
operator|.
name|APP_TYPE
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|appTags
init|=
name|AbstractClientProvider
operator|.
name|createApplicationTags
argument_list|(
name|appName
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|appTags
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|submissionContext
operator|.
name|setApplicationTags
argument_list|(
name|appTags
argument_list|)
expr_stmt|;
block|}
name|ContainerLaunchContext
name|amLaunchContext
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|ContainerLaunchContext
operator|.
name|class
argument_list|)
decl_stmt|;
name|amLaunchContext
operator|.
name|setCommands
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|cmdStr
argument_list|)
argument_list|)
expr_stmt|;
name|amLaunchContext
operator|.
name|setEnvironment
argument_list|(
name|env
argument_list|)
expr_stmt|;
name|amLaunchContext
operator|.
name|setLocalResources
argument_list|(
name|localResources
argument_list|)
expr_stmt|;
name|addCredentialsIfSecure
argument_list|(
name|conf
argument_list|,
name|amLaunchContext
argument_list|)
expr_stmt|;
name|submissionContext
operator|.
name|setAMContainerSpec
argument_list|(
name|amLaunchContext
argument_list|)
expr_stmt|;
name|submitApplication
argument_list|(
name|submissionContext
argument_list|)
expr_stmt|;
return|return
name|submissionContext
operator|.
name|getApplicationId
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|submitApplication (ApplicationSubmissionContext context)
specifier|public
name|ApplicationId
name|submitApplication
parameter_list|(
name|ApplicationSubmissionContext
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
return|return
name|yarnClient
operator|.
name|submitApplication
argument_list|(
name|context
argument_list|)
return|;
block|}
DECL|method|printLocalResources (Map<String, LocalResource> map)
specifier|private
name|void
name|printLocalResources
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|LocalResource
argument_list|>
name|map
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Added LocalResource for localization: "
argument_list|)
expr_stmt|;
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|LocalResource
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|" -> "
argument_list|)
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getResource
argument_list|()
operator|.
name|getFile
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
name|System
operator|.
name|lineSeparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
name|builder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|addCredentialsIfSecure (Configuration conf, ContainerLaunchContext amLaunchContext)
specifier|private
name|void
name|addCredentialsIfSecure
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|ContainerLaunchContext
name|amLaunchContext
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
comment|// pick up oozie credentials
name|Credentials
name|credentials
init|=
name|CredentialUtils
operator|.
name|loadTokensFromEnvironment
argument_list|(
name|System
operator|.
name|getenv
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|credentials
operator|==
literal|null
condition|)
block|{
comment|// nothing from oozie, so build up directly
name|credentials
operator|=
operator|new
name|Credentials
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getCredentials
argument_list|()
argument_list|)
expr_stmt|;
name|CredentialUtils
operator|.
name|addRMRenewableFSDelegationTokens
argument_list|(
name|conf
argument_list|,
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|credentials
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Using externally supplied credentials to launch AM"
argument_list|)
expr_stmt|;
block|}
name|amLaunchContext
operator|.
name|setTokens
argument_list|(
name|CredentialUtils
operator|.
name|marshallCredentials
argument_list|(
name|credentials
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|buildCommandLine (String appName, Configuration conf, Path appRootDir, boolean hasSliderAMLog4j)
specifier|private
name|String
name|buildCommandLine
parameter_list|(
name|String
name|appName
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|appRootDir
parameter_list|,
name|boolean
name|hasSliderAMLog4j
parameter_list|)
throws|throws
name|BadConfigException
block|{
name|JavaCommandLineBuilder
name|CLI
init|=
operator|new
name|JavaCommandLineBuilder
argument_list|()
decl_stmt|;
name|CLI
operator|.
name|forceIPv4
argument_list|()
operator|.
name|headless
argument_list|()
expr_stmt|;
comment|//TODO CLI.setJVMHeap
comment|//TODO CLI.addJVMOPTS
if|if
condition|(
name|hasSliderAMLog4j
condition|)
block|{
name|CLI
operator|.
name|sysprop
argument_list|(
name|SYSPROP_LOG4J_CONFIGURATION
argument_list|,
name|LOG4J_SERVER_PROP_FILENAME
argument_list|)
expr_stmt|;
name|CLI
operator|.
name|sysprop
argument_list|(
name|SYSPROP_LOG_DIR
argument_list|,
name|ApplicationConstants
operator|.
name|LOG_DIR_EXPANSION_VAR
argument_list|)
expr_stmt|;
block|}
name|CLI
operator|.
name|add
argument_list|(
name|SliderAppMaster
operator|.
name|SERVICE_CLASSNAME
argument_list|)
expr_stmt|;
name|CLI
operator|.
name|add
argument_list|(
name|ACTION_CREATE
argument_list|,
name|appName
argument_list|)
expr_stmt|;
comment|//TODO debugAM CLI.add(Arguments.ARG_DEBUG)
name|CLI
operator|.
name|add
argument_list|(
name|Arguments
operator|.
name|ARG_CLUSTER_URI
argument_list|,
name|appRootDir
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
comment|//    InetSocketAddress rmSchedulerAddress = getRmSchedulerAddress(conf);
comment|//    String rmAddr = NetUtils.getHostPortString(rmSchedulerAddress);
comment|//    CLI.add(Arguments.ARG_RM_ADDR, rmAddr);
comment|// pass the registry binding
name|CLI
operator|.
name|addConfOptionToCLI
argument_list|(
name|conf
argument_list|,
name|RegistryConstants
operator|.
name|KEY_REGISTRY_ZK_ROOT
argument_list|,
name|RegistryConstants
operator|.
name|DEFAULT_ZK_REGISTRY_ROOT
argument_list|)
expr_stmt|;
name|CLI
operator|.
name|addMandatoryConfOption
argument_list|(
name|conf
argument_list|,
name|RegistryConstants
operator|.
name|KEY_REGISTRY_ZK_QUORUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|isHadoopClusterSecure
argument_list|(
name|conf
argument_list|)
condition|)
block|{
comment|//TODO Is this required ??
comment|// if the cluster is secure, make sure that
comment|// the relevant security settings go over
name|CLI
operator|.
name|addConfOption
argument_list|(
name|conf
argument_list|,
name|DFS_NAMENODE_KERBEROS_PRINCIPAL_KEY
argument_list|)
expr_stmt|;
block|}
comment|//    // copy over any/all YARN RM client values, in case the server-side XML conf file
comment|//    // has the 0.0.0.0 address
comment|//    CLI.addConfOptions(conf, YarnConfiguration.RM_ADDRESS,
comment|//        YarnConfiguration.RM_CLUSTER_ID, YarnConfiguration.RM_HOSTNAME,
comment|//        YarnConfiguration.RM_PRINCIPAL);
comment|// write out the path output
name|CLI
operator|.
name|addOutAndErrFiles
argument_list|(
name|STDOUT_AM
argument_list|,
name|STDERR_AM
argument_list|)
expr_stmt|;
name|String
name|cmdStr
init|=
name|CLI
operator|.
name|build
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Completed setting up app master command: {}"
argument_list|,
name|cmdStr
argument_list|)
expr_stmt|;
return|return
name|cmdStr
return|;
block|}
DECL|method|addAMEnv (Configuration conf)
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|addAMEnv
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|ClasspathConstructor
name|classpath
init|=
name|buildClasspath
argument_list|(
name|SliderKeys
operator|.
name|SUBMITTED_CONF_DIR
argument_list|,
literal|"lib"
argument_list|,
name|sliderFileSystem
argument_list|,
name|getUsingMiniMRCluster
argument_list|()
argument_list|)
decl_stmt|;
name|env
operator|.
name|put
argument_list|(
literal|"CLASSPATH"
argument_list|,
name|classpath
operator|.
name|buildClasspath
argument_list|()
argument_list|)
expr_stmt|;
name|env
operator|.
name|put
argument_list|(
literal|"LANG"
argument_list|,
literal|"en_US.UTF-8"
argument_list|)
expr_stmt|;
name|env
operator|.
name|put
argument_list|(
literal|"LC_ALL"
argument_list|,
literal|"en_US.UTF-8"
argument_list|)
expr_stmt|;
name|env
operator|.
name|put
argument_list|(
literal|"LANGUAGE"
argument_list|,
literal|"en_US.UTF-8"
argument_list|)
expr_stmt|;
name|String
name|jaas
init|=
name|System
operator|.
name|getenv
argument_list|(
name|HADOOP_JAAS_DEBUG
argument_list|)
decl_stmt|;
if|if
condition|(
name|jaas
operator|!=
literal|null
condition|)
block|{
name|env
operator|.
name|put
argument_list|(
name|HADOOP_JAAS_DEBUG
argument_list|,
name|jaas
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|String
name|userName
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getUserName
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Run as user "
operator|+
name|userName
argument_list|)
expr_stmt|;
comment|// HADOOP_USER_NAME env is used by UserGroupInformation when log in
comment|// This env makes AM run as this user
name|env
operator|.
name|put
argument_list|(
literal|"HADOOP_USER_NAME"
argument_list|,
name|userName
argument_list|)
expr_stmt|;
block|}
name|env
operator|.
name|putAll
argument_list|(
name|getAmLaunchEnv
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"AM env: \n{}"
argument_list|,
name|stringifyMap
argument_list|(
name|env
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|env
return|;
block|}
DECL|method|addJarResource (String appName, Map<String, LocalResource> localResources)
specifier|private
name|Path
name|addJarResource
parameter_list|(
name|String
name|appName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|LocalResource
argument_list|>
name|localResources
parameter_list|)
throws|throws
name|IOException
throws|,
name|SliderException
block|{
name|Path
name|libPath
init|=
name|sliderFileSystem
operator|.
name|buildClusterDirPath
argument_list|(
name|appName
argument_list|)
decl_stmt|;
name|ProviderUtils
operator|.
name|addProviderJar
argument_list|(
name|localResources
argument_list|,
name|SliderAppMaster
operator|.
name|class
argument_list|,
name|SLIDER_JAR
argument_list|,
name|sliderFileSystem
argument_list|,
name|libPath
argument_list|,
literal|"lib"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Path
name|dependencyLibTarGzip
init|=
name|sliderFileSystem
operator|.
name|getDependencyTarGzip
argument_list|()
decl_stmt|;
if|if
condition|(
name|sliderFileSystem
operator|.
name|isFile
argument_list|(
name|dependencyLibTarGzip
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Loading lib tar from "
operator|+
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
operator|.
name|getScheme
argument_list|()
operator|+
literal|": "
operator|+
name|dependencyLibTarGzip
argument_list|)
expr_stmt|;
name|SliderUtils
operator|.
name|putAmTarGzipAndUpdate
argument_list|(
name|localResources
argument_list|,
name|sliderFileSystem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
index|[]
name|libs
init|=
name|SliderUtils
operator|.
name|getLibDirs
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Loading dependencies from local file system: "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|libs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|libDirProp
range|:
name|libs
control|)
block|{
name|ProviderUtils
operator|.
name|addAllDependencyJars
argument_list|(
name|localResources
argument_list|,
name|sliderFileSystem
argument_list|,
name|libPath
argument_list|,
literal|"lib"
argument_list|,
name|libDirProp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|libPath
return|;
block|}
DECL|method|addAMLog4jResource (String appName, Configuration conf, Map<String, LocalResource> localResources)
specifier|private
name|boolean
name|addAMLog4jResource
parameter_list|(
name|String
name|appName
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|LocalResource
argument_list|>
name|localResources
parameter_list|)
throws|throws
name|IOException
throws|,
name|BadClusterStateException
block|{
name|boolean
name|hasSliderAMLog4j
init|=
literal|false
decl_stmt|;
name|String
name|hadoopConfDir
init|=
name|System
operator|.
name|getenv
argument_list|(
name|ApplicationConstants
operator|.
name|Environment
operator|.
name|HADOOP_CONF_DIR
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|hadoopConfDir
operator|!=
literal|null
condition|)
block|{
name|File
name|localFile
init|=
operator|new
name|File
argument_list|(
name|hadoopConfDir
argument_list|,
name|SliderKeys
operator|.
name|LOG4J_SERVER_PROP_FILENAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|localFile
operator|.
name|exists
argument_list|()
condition|)
block|{
name|Path
name|localFilePath
init|=
name|createLocalPath
argument_list|(
name|localFile
argument_list|)
decl_stmt|;
name|Path
name|appDirPath
init|=
name|sliderFileSystem
operator|.
name|buildClusterDirPath
argument_list|(
name|appName
argument_list|)
decl_stmt|;
name|Path
name|remoteConfPath
init|=
operator|new
name|Path
argument_list|(
name|appDirPath
argument_list|,
name|SliderKeys
operator|.
name|SUBMITTED_CONF_DIR
argument_list|)
decl_stmt|;
name|Path
name|remoteFilePath
init|=
operator|new
name|Path
argument_list|(
name|remoteConfPath
argument_list|,
name|SliderKeys
operator|.
name|LOG4J_SERVER_PROP_FILENAME
argument_list|)
decl_stmt|;
name|copy
argument_list|(
name|conf
argument_list|,
name|localFilePath
argument_list|,
name|remoteFilePath
argument_list|)
expr_stmt|;
name|LocalResource
name|localResource
init|=
name|sliderFileSystem
operator|.
name|createAmResource
argument_list|(
name|remoteConfPath
argument_list|,
name|LocalResourceType
operator|.
name|FILE
argument_list|)
decl_stmt|;
name|localResources
operator|.
name|put
argument_list|(
name|localFilePath
operator|.
name|getName
argument_list|()
argument_list|,
name|localResource
argument_list|)
expr_stmt|;
name|hasSliderAMLog4j
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|hasSliderAMLog4j
return|;
block|}
DECL|method|checkAppNotExistOnHdfs (Application application)
specifier|private
name|Path
name|checkAppNotExistOnHdfs
parameter_list|(
name|Application
name|application
parameter_list|)
throws|throws
name|IOException
throws|,
name|SliderException
block|{
name|Path
name|appDir
init|=
name|sliderFileSystem
operator|.
name|buildClusterDirPath
argument_list|(
name|application
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|sliderFileSystem
operator|.
name|verifyDirectoryNonexistent
argument_list|(
operator|new
name|Path
argument_list|(
name|appDir
argument_list|,
name|application
operator|.
name|getName
argument_list|()
operator|+
literal|".json"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|appDir
return|;
block|}
DECL|method|checkAppExistOnHdfs (String appName)
specifier|private
name|Path
name|checkAppExistOnHdfs
parameter_list|(
name|String
name|appName
parameter_list|)
throws|throws
name|IOException
throws|,
name|SliderException
block|{
name|Path
name|appDir
init|=
name|sliderFileSystem
operator|.
name|buildClusterDirPath
argument_list|(
name|appName
argument_list|)
decl_stmt|;
name|sliderFileSystem
operator|.
name|verifyPathExists
argument_list|(
operator|new
name|Path
argument_list|(
name|appDir
argument_list|,
name|appName
operator|+
literal|".json"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|appDir
return|;
block|}
DECL|method|persistApp (Path appDir, Application application)
specifier|private
name|void
name|persistApp
parameter_list|(
name|Path
name|appDir
parameter_list|,
name|Application
name|application
parameter_list|)
throws|throws
name|IOException
throws|,
name|SliderException
block|{
name|FsPermission
name|appDirPermission
init|=
operator|new
name|FsPermission
argument_list|(
literal|"750"
argument_list|)
decl_stmt|;
name|sliderFileSystem
operator|.
name|createWithPermissions
argument_list|(
name|appDir
argument_list|,
name|appDirPermission
argument_list|)
expr_stmt|;
name|Path
name|appJson
init|=
operator|new
name|Path
argument_list|(
name|appDir
argument_list|,
name|application
operator|.
name|getName
argument_list|()
operator|+
literal|".json"
argument_list|)
decl_stmt|;
name|jsonSerDeser
operator|.
name|save
argument_list|(
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|appJson
argument_list|,
name|application
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Persisted application "
operator|+
name|application
operator|.
name|getName
argument_list|()
operator|+
literal|" at "
operator|+
name|appJson
argument_list|)
expr_stmt|;
block|}
DECL|method|addKeytabResourceIfSecure (SliderFileSystem fileSystem, Map<String, LocalResource> localResource, Configuration conf, String appName)
specifier|private
name|void
name|addKeytabResourceIfSecure
parameter_list|(
name|SliderFileSystem
name|fileSystem
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|LocalResource
argument_list|>
name|localResource
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|String
name|appName
parameter_list|)
throws|throws
name|IOException
throws|,
name|BadConfigException
block|{
if|if
condition|(
operator|!
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
return|return;
block|}
name|String
name|keytabPreInstalledOnHost
init|=
name|conf
operator|.
name|get
argument_list|(
name|SliderXmlConfKeys
operator|.
name|KEY_AM_KEYTAB_LOCAL_PATH
argument_list|)
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|keytabPreInstalledOnHost
argument_list|)
condition|)
block|{
name|String
name|amKeytabName
init|=
name|conf
operator|.
name|get
argument_list|(
name|SliderXmlConfKeys
operator|.
name|KEY_AM_LOGIN_KEYTAB_NAME
argument_list|)
decl_stmt|;
name|String
name|keytabDir
init|=
name|conf
operator|.
name|get
argument_list|(
name|SliderXmlConfKeys
operator|.
name|KEY_HDFS_KEYTAB_DIR
argument_list|)
decl_stmt|;
name|Path
name|keytabPath
init|=
name|fileSystem
operator|.
name|buildKeytabPath
argument_list|(
name|keytabDir
argument_list|,
name|amKeytabName
argument_list|,
name|appName
argument_list|)
decl_stmt|;
if|if
condition|(
name|fileSystem
operator|.
name|getFileSystem
argument_list|()
operator|.
name|exists
argument_list|(
name|keytabPath
argument_list|)
condition|)
block|{
name|LocalResource
name|keytabRes
init|=
name|fileSystem
operator|.
name|createAmResource
argument_list|(
name|keytabPath
argument_list|,
name|LocalResourceType
operator|.
name|FILE
argument_list|)
decl_stmt|;
name|localResource
operator|.
name|put
argument_list|(
name|SliderKeys
operator|.
name|KEYTAB_DIR
operator|+
literal|"/"
operator|+
name|amKeytabName
argument_list|,
name|keytabRes
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Adding AM keytab on hdfs: "
operator|+
name|keytabPath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"No keytab file was found at {}."
argument_list|,
name|keytabPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|KEY_AM_LOGIN_KEYTAB_REQUIRED
argument_list|,
literal|false
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BadConfigException
argument_list|(
literal|"No keytab file was found at %s."
argument_list|,
name|keytabPath
argument_list|)
throw|;
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"The AM will be "
operator|+
literal|"started without a kerberos authenticated identity. "
operator|+
literal|"The application is therefore not guaranteed to remain "
operator|+
literal|"operational beyond 24 hours."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|actionUpgrade (String clustername, ActionUpgradeArgs upgradeArgs)
specifier|public
name|int
name|actionUpgrade
parameter_list|(
name|String
name|clustername
parameter_list|,
name|ActionUpgradeArgs
name|upgradeArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
comment|//TODO
return|return
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|actionKeytab (ActionKeytabArgs keytabInfo)
specifier|public
name|int
name|actionKeytab
parameter_list|(
name|ActionKeytabArgs
name|keytabInfo
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
if|if
condition|(
name|keytabInfo
operator|.
name|install
condition|)
block|{
return|return
name|actionInstallKeytab
argument_list|(
name|keytabInfo
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|keytabInfo
operator|.
name|delete
condition|)
block|{
return|return
name|actionDeleteKeytab
argument_list|(
name|keytabInfo
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|keytabInfo
operator|.
name|list
condition|)
block|{
return|return
name|actionListKeytab
argument_list|(
name|keytabInfo
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"Keytab option specified not found.\n"
operator|+
name|CommonArgs
operator|.
name|usage
argument_list|(
name|serviceArgs
argument_list|,
name|ACTION_KEYTAB
argument_list|)
argument_list|)
throw|;
block|}
block|}
DECL|method|actionListKeytab (ActionKeytabArgs keytabInfo)
specifier|private
name|int
name|actionListKeytab
parameter_list|(
name|ActionKeytabArgs
name|keytabInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|folder
init|=
name|keytabInfo
operator|.
name|folder
operator|!=
literal|null
condition|?
name|keytabInfo
operator|.
name|folder
else|:
name|StringUtils
operator|.
name|EMPTY
decl_stmt|;
name|Path
name|keytabPath
init|=
name|sliderFileSystem
operator|.
name|buildKeytabInstallationDirPath
argument_list|(
name|folder
argument_list|)
decl_stmt|;
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|files
init|=
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
operator|.
name|listFiles
argument_list|(
name|keytabPath
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Keytabs:"
argument_list|)
expr_stmt|;
while|while
condition|(
name|files
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"\t"
operator|+
name|files
operator|.
name|next
argument_list|()
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
DECL|method|actionDeleteKeytab (ActionKeytabArgs keytabInfo)
specifier|private
name|int
name|actionDeleteKeytab
parameter_list|(
name|ActionKeytabArgs
name|keytabInfo
parameter_list|)
throws|throws
name|BadCommandArgumentsException
throws|,
name|IOException
block|{
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|keytabInfo
operator|.
name|folder
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"A valid destination keytab sub-folder name is required (e.g. 'security').\n"
operator|+
name|CommonArgs
operator|.
name|usage
argument_list|(
name|serviceArgs
argument_list|,
name|ACTION_KEYTAB
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|keytabInfo
operator|.
name|keytab
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"A keytab name is required."
argument_list|)
throw|;
block|}
name|Path
name|pkgPath
init|=
name|sliderFileSystem
operator|.
name|buildKeytabInstallationDirPath
argument_list|(
name|keytabInfo
operator|.
name|folder
argument_list|)
decl_stmt|;
name|Path
name|fileInFs
init|=
operator|new
name|Path
argument_list|(
name|pkgPath
argument_list|,
name|keytabInfo
operator|.
name|keytab
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Deleting keytab {}"
argument_list|,
name|fileInFs
argument_list|)
expr_stmt|;
name|FileSystem
name|sfs
init|=
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|require
argument_list|(
name|sfs
operator|.
name|exists
argument_list|(
name|fileInFs
argument_list|)
argument_list|,
literal|"No keytab to delete found at %s"
argument_list|,
name|fileInFs
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
name|sfs
operator|.
name|delete
argument_list|(
name|fileInFs
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
DECL|method|actionInstallKeytab (ActionKeytabArgs keytabInfo)
specifier|private
name|int
name|actionInstallKeytab
parameter_list|(
name|ActionKeytabArgs
name|keytabInfo
parameter_list|)
throws|throws
name|BadCommandArgumentsException
throws|,
name|IOException
block|{
name|Path
name|srcFile
init|=
literal|null
decl_stmt|;
name|require
argument_list|(
name|isSet
argument_list|(
name|keytabInfo
operator|.
name|folder
argument_list|)
argument_list|,
literal|"A valid destination keytab sub-folder name is required (e.g. 'security').\n"
operator|+
name|CommonArgs
operator|.
name|usage
argument_list|(
name|serviceArgs
argument_list|,
name|ACTION_KEYTAB
argument_list|)
argument_list|)
expr_stmt|;
name|requireArgumentSet
argument_list|(
name|Arguments
operator|.
name|ARG_KEYTAB
argument_list|,
name|keytabInfo
operator|.
name|keytab
argument_list|)
expr_stmt|;
name|File
name|keytabFile
init|=
operator|new
name|File
argument_list|(
name|keytabInfo
operator|.
name|keytab
argument_list|)
decl_stmt|;
name|require
argument_list|(
name|keytabFile
operator|.
name|isFile
argument_list|()
argument_list|,
literal|"Unable to access supplied keytab file at %s"
argument_list|,
name|keytabFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|srcFile
operator|=
operator|new
name|Path
argument_list|(
name|keytabFile
operator|.
name|toURI
argument_list|()
argument_list|)
expr_stmt|;
name|Path
name|pkgPath
init|=
name|sliderFileSystem
operator|.
name|buildKeytabInstallationDirPath
argument_list|(
name|keytabInfo
operator|.
name|folder
argument_list|)
decl_stmt|;
name|FileSystem
name|sfs
init|=
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|sfs
operator|.
name|mkdirs
argument_list|(
name|pkgPath
argument_list|)
expr_stmt|;
name|sfs
operator|.
name|setPermission
argument_list|(
name|pkgPath
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|FsAction
operator|.
name|ALL
argument_list|,
name|FsAction
operator|.
name|NONE
argument_list|,
name|FsAction
operator|.
name|NONE
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|fileInFs
init|=
operator|new
name|Path
argument_list|(
name|pkgPath
argument_list|,
name|srcFile
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Installing keytab {} at {} and overwrite is {}."
argument_list|,
name|srcFile
argument_list|,
name|fileInFs
argument_list|,
name|keytabInfo
operator|.
name|overwrite
argument_list|)
expr_stmt|;
name|require
argument_list|(
operator|!
operator|(
name|sfs
operator|.
name|exists
argument_list|(
name|fileInFs
argument_list|)
operator|&&
operator|!
name|keytabInfo
operator|.
name|overwrite
operator|)
argument_list|,
literal|"Keytab exists at %s. Use --overwrite to overwrite."
argument_list|,
name|fileInFs
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
name|sfs
operator|.
name|copyFromLocalFile
argument_list|(
literal|false
argument_list|,
name|keytabInfo
operator|.
name|overwrite
argument_list|,
name|srcFile
argument_list|,
name|fileInFs
argument_list|)
expr_stmt|;
name|sfs
operator|.
name|setPermission
argument_list|(
name|fileInFs
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|FsAction
operator|.
name|READ_WRITE
argument_list|,
name|FsAction
operator|.
name|NONE
argument_list|,
name|FsAction
operator|.
name|NONE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
annotation|@
name|Override
DECL|method|actionResource (ActionResourceArgs resourceInfo)
specifier|public
name|int
name|actionResource
parameter_list|(
name|ActionResourceArgs
name|resourceInfo
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
if|if
condition|(
name|resourceInfo
operator|.
name|help
condition|)
block|{
name|actionHelp
argument_list|(
name|ACTION_RESOURCE
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
elseif|else
if|if
condition|(
name|resourceInfo
operator|.
name|install
condition|)
block|{
return|return
name|actionInstallResource
argument_list|(
name|resourceInfo
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|resourceInfo
operator|.
name|delete
condition|)
block|{
return|return
name|actionDeleteResource
argument_list|(
name|resourceInfo
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|resourceInfo
operator|.
name|list
condition|)
block|{
return|return
name|actionListResource
argument_list|(
name|resourceInfo
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"Resource option specified not found.\n"
operator|+
name|CommonArgs
operator|.
name|usage
argument_list|(
name|serviceArgs
argument_list|,
name|ACTION_RESOURCE
argument_list|)
argument_list|)
throw|;
block|}
block|}
DECL|method|actionListResource (ActionResourceArgs resourceInfo)
specifier|private
name|int
name|actionListResource
parameter_list|(
name|ActionResourceArgs
name|resourceInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|folder
init|=
name|resourceInfo
operator|.
name|folder
operator|!=
literal|null
condition|?
name|resourceInfo
operator|.
name|folder
else|:
name|StringUtils
operator|.
name|EMPTY
decl_stmt|;
name|Path
name|path
init|=
name|sliderFileSystem
operator|.
name|buildResourcePath
argument_list|(
name|folder
argument_list|)
decl_stmt|;
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|files
init|=
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
operator|.
name|listFiles
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Resources:"
argument_list|)
expr_stmt|;
while|while
condition|(
name|files
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"\t"
operator|+
name|files
operator|.
name|next
argument_list|()
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
DECL|method|actionDeleteResource (ActionResourceArgs resourceInfo)
specifier|private
name|int
name|actionDeleteResource
parameter_list|(
name|ActionResourceArgs
name|resourceInfo
parameter_list|)
throws|throws
name|BadCommandArgumentsException
throws|,
name|IOException
block|{
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|resourceInfo
operator|.
name|resource
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"A file name is required."
argument_list|)
throw|;
block|}
name|Path
name|fileInFs
decl_stmt|;
if|if
condition|(
name|resourceInfo
operator|.
name|folder
operator|==
literal|null
condition|)
block|{
name|fileInFs
operator|=
name|sliderFileSystem
operator|.
name|buildResourcePath
argument_list|(
name|resourceInfo
operator|.
name|resource
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fileInFs
operator|=
name|sliderFileSystem
operator|.
name|buildResourcePath
argument_list|(
name|resourceInfo
operator|.
name|folder
argument_list|,
name|resourceInfo
operator|.
name|resource
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Deleting resource {}"
argument_list|,
name|fileInFs
argument_list|)
expr_stmt|;
name|FileSystem
name|sfs
init|=
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|require
argument_list|(
name|sfs
operator|.
name|exists
argument_list|(
name|fileInFs
argument_list|)
argument_list|,
literal|"No resource to delete found at %s"
argument_list|,
name|fileInFs
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
name|sfs
operator|.
name|delete
argument_list|(
name|fileInFs
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
DECL|method|actionInstallResource (ActionResourceArgs resourceInfo)
specifier|private
name|int
name|actionInstallResource
parameter_list|(
name|ActionResourceArgs
name|resourceInfo
parameter_list|)
throws|throws
name|BadCommandArgumentsException
throws|,
name|IOException
block|{
name|Path
name|srcFile
init|=
literal|null
decl_stmt|;
name|String
name|folder
init|=
name|resourceInfo
operator|.
name|folder
operator|!=
literal|null
condition|?
name|resourceInfo
operator|.
name|folder
else|:
name|StringUtils
operator|.
name|EMPTY
decl_stmt|;
name|requireArgumentSet
argument_list|(
name|Arguments
operator|.
name|ARG_RESOURCE
argument_list|,
name|resourceInfo
operator|.
name|resource
argument_list|)
expr_stmt|;
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|resourceInfo
operator|.
name|resource
argument_list|)
decl_stmt|;
name|require
argument_list|(
name|file
operator|.
name|isFile
argument_list|()
operator|||
name|file
operator|.
name|isDirectory
argument_list|()
argument_list|,
literal|"Unable to access supplied file at %s"
argument_list|,
name|file
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|File
index|[]
name|files
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|files
operator|=
name|file
operator|.
name|listFiles
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|files
operator|=
operator|new
name|File
index|[]
block|{
name|file
block|}
expr_stmt|;
block|}
name|Path
name|pkgPath
init|=
name|sliderFileSystem
operator|.
name|buildResourcePath
argument_list|(
name|folder
argument_list|)
decl_stmt|;
name|FileSystem
name|sfs
init|=
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|sfs
operator|.
name|exists
argument_list|(
name|pkgPath
argument_list|)
condition|)
block|{
name|sfs
operator|.
name|mkdirs
argument_list|(
name|pkgPath
argument_list|)
expr_stmt|;
name|sfs
operator|.
name|setPermission
argument_list|(
name|pkgPath
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|FsAction
operator|.
name|ALL
argument_list|,
name|FsAction
operator|.
name|NONE
argument_list|,
name|FsAction
operator|.
name|NONE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|require
argument_list|(
name|sfs
operator|.
name|isDirectory
argument_list|(
name|pkgPath
argument_list|)
argument_list|,
literal|"Specified folder %s exists and is "
operator|+
literal|"not a directory"
argument_list|,
name|folder
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|files
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|File
name|f
range|:
name|files
control|)
block|{
name|srcFile
operator|=
operator|new
name|Path
argument_list|(
name|f
operator|.
name|toURI
argument_list|()
argument_list|)
expr_stmt|;
name|Path
name|fileInFs
init|=
operator|new
name|Path
argument_list|(
name|pkgPath
argument_list|,
name|srcFile
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Installing file {} at {} and overwrite is {}."
argument_list|,
name|srcFile
argument_list|,
name|fileInFs
argument_list|,
name|resourceInfo
operator|.
name|overwrite
argument_list|)
expr_stmt|;
name|require
argument_list|(
operator|!
operator|(
name|sfs
operator|.
name|exists
argument_list|(
name|fileInFs
argument_list|)
operator|&&
operator|!
name|resourceInfo
operator|.
name|overwrite
operator|)
argument_list|,
literal|"File exists at %s. Use --overwrite to overwrite."
argument_list|,
name|fileInFs
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
name|sfs
operator|.
name|copyFromLocalFile
argument_list|(
literal|false
argument_list|,
name|resourceInfo
operator|.
name|overwrite
argument_list|,
name|srcFile
argument_list|,
name|fileInFs
argument_list|)
expr_stmt|;
name|sfs
operator|.
name|setPermission
argument_list|(
name|fileInFs
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|FsAction
operator|.
name|READ_WRITE
argument_list|,
name|FsAction
operator|.
name|NONE
argument_list|,
name|FsAction
operator|.
name|NONE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
annotation|@
name|Override
DECL|method|actionClient (ActionClientArgs clientInfo)
specifier|public
name|int
name|actionClient
parameter_list|(
name|ActionClientArgs
name|clientInfo
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
if|if
condition|(
name|clientInfo
operator|.
name|install
condition|)
block|{
comment|// TODO implement client install
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Client install not yet "
operator|+
literal|"supported"
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"Only install, keystore, and truststore commands are supported for the client.\n"
operator|+
name|CommonArgs
operator|.
name|usage
argument_list|(
name|serviceArgs
argument_list|,
name|ACTION_CLIENT
argument_list|)
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|actionUpdate (String clustername, AbstractClusterBuildingActionArgs buildInfo)
specifier|public
name|int
name|actionUpdate
parameter_list|(
name|String
name|clustername
parameter_list|,
name|AbstractClusterBuildingActionArgs
name|buildInfo
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
if|if
condition|(
name|buildInfo
operator|.
name|lifetime
operator|>
literal|0
condition|)
block|{
name|updateLifetime
argument_list|(
name|clustername
argument_list|,
name|buildInfo
operator|.
name|lifetime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//TODO upgrade
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
DECL|method|updateLifetime (String appName, long lifetime)
specifier|public
name|String
name|updateLifetime
parameter_list|(
name|String
name|appName
parameter_list|,
name|long
name|lifetime
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|EnumSet
argument_list|<
name|YarnApplicationState
argument_list|>
name|appStates
init|=
name|EnumSet
operator|.
name|range
argument_list|(
name|YarnApplicationState
operator|.
name|NEW
argument_list|,
name|YarnApplicationState
operator|.
name|RUNNING
argument_list|)
decl_stmt|;
name|ApplicationReport
name|report
init|=
name|findInstance
argument_list|(
name|appName
argument_list|,
name|appStates
argument_list|)
decl_stmt|;
if|if
condition|(
name|report
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|YarnException
argument_list|(
literal|"Application not found for "
operator|+
name|appName
argument_list|)
throw|;
block|}
name|ApplicationId
name|appId
init|=
name|report
operator|.
name|getApplicationId
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Updating lifetime of an application: appName = "
operator|+
name|appName
operator|+
literal|", appId = "
operator|+
name|appId
operator|+
literal|", lifetime = "
operator|+
name|lifetime
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|ApplicationTimeoutType
argument_list|,
name|String
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|String
name|newTimeout
init|=
name|Times
operator|.
name|formatISO8601
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|lifetime
operator|*
literal|1000
argument_list|)
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|ApplicationTimeoutType
operator|.
name|LIFETIME
argument_list|,
name|newTimeout
argument_list|)
expr_stmt|;
name|UpdateApplicationTimeoutsRequest
name|request
init|=
name|UpdateApplicationTimeoutsRequest
operator|.
name|newInstance
argument_list|(
name|appId
argument_list|,
name|map
argument_list|)
decl_stmt|;
name|yarnClient
operator|.
name|updateApplicationTimeouts
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Successfully updated lifetime for an application: appName = "
operator|+
name|appName
operator|+
literal|", appId = "
operator|+
name|appId
operator|+
literal|". New expiry time in ISO8601 format is "
operator|+
name|newTimeout
argument_list|)
expr_stmt|;
return|return
name|newTimeout
return|;
block|}
DECL|method|getAmLaunchEnv (Configuration config)
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|getAmLaunchEnv
parameter_list|(
name|Configuration
name|config
parameter_list|)
block|{
name|String
name|sliderAmLaunchEnv
init|=
name|config
operator|.
name|get
argument_list|(
name|KEY_AM_LAUNCH_ENV
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"{} = {}"
argument_list|,
name|KEY_AM_LAUNCH_ENV
argument_list|,
name|sliderAmLaunchEnv
argument_list|)
expr_stmt|;
comment|// Multiple env variables can be specified with a comma (,) separator
name|String
index|[]
name|envs
init|=
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|sliderAmLaunchEnv
argument_list|)
condition|?
literal|null
else|:
name|sliderAmLaunchEnv
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
if|if
condition|(
name|ArrayUtils
operator|.
name|isEmpty
argument_list|(
name|envs
argument_list|)
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyMap
argument_list|()
return|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|amLaunchEnv
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|env
range|:
name|envs
control|)
block|{
if|if
condition|(
name|StringUtils
operator|.
name|isNotEmpty
argument_list|(
name|env
argument_list|)
condition|)
block|{
comment|// Each env name/value is separated by equals sign (=)
name|String
index|[]
name|tokens
init|=
name|env
operator|.
name|split
argument_list|(
literal|"="
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokens
operator|!=
literal|null
operator|&&
name|tokens
operator|.
name|length
operator|==
literal|2
condition|)
block|{
name|String
name|envKey
init|=
name|tokens
index|[
literal|0
index|]
decl_stmt|;
name|String
name|envValue
init|=
name|tokens
index|[
literal|1
index|]
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|placeholder
range|:
name|generatePlaceholderKeyValueMap
argument_list|(
name|env
argument_list|)
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|StringUtils
operator|.
name|isNotEmpty
argument_list|(
name|placeholder
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|envValue
operator|=
name|envValue
operator|.
name|replaceAll
argument_list|(
name|Pattern
operator|.
name|quote
argument_list|(
name|placeholder
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
name|placeholder
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Shell
operator|.
name|WINDOWS
condition|)
block|{
name|envValue
operator|=
literal|"%"
operator|+
name|envKey
operator|+
literal|"%;"
operator|+
name|envValue
expr_stmt|;
block|}
else|else
block|{
name|envValue
operator|=
literal|"$"
operator|+
name|envKey
operator|+
literal|":"
operator|+
name|envValue
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Setting AM launch env {}={}"
argument_list|,
name|envKey
argument_list|,
name|envValue
argument_list|)
expr_stmt|;
name|amLaunchEnv
operator|.
name|put
argument_list|(
name|envKey
argument_list|,
name|envValue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|amLaunchEnv
return|;
block|}
DECL|method|generatePlaceholderKeyValueMap (String env)
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|generatePlaceholderKeyValueMap
parameter_list|(
name|String
name|env
parameter_list|)
block|{
name|String
name|PLACEHOLDER_PATTERN
init|=
literal|"\\$\\{[^{]+\\}"
decl_stmt|;
name|Pattern
name|placeholderPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|PLACEHOLDER_PATTERN
argument_list|)
decl_stmt|;
name|Matcher
name|placeholderMatcher
init|=
name|placeholderPattern
operator|.
name|matcher
argument_list|(
name|env
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|placeholderKeyValueMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|placeholderMatcher
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|placeholderKey
init|=
name|placeholderMatcher
operator|.
name|group
argument_list|()
decl_stmt|;
name|String
name|systemKey
init|=
name|placeholderKey
operator|.
name|substring
argument_list|(
literal|2
argument_list|,
name|placeholderKey
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
operator|.
name|replaceAll
argument_list|(
literal|"\\."
argument_list|,
literal|"_"
argument_list|)
decl_stmt|;
name|String
name|placeholderValue
init|=
name|getSystemEnv
argument_list|(
name|systemKey
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Placeholder {}={}"
argument_list|,
name|placeholderKey
argument_list|,
name|placeholderValue
argument_list|)
expr_stmt|;
name|placeholderKeyValueMap
operator|.
name|put
argument_list|(
name|placeholderKey
argument_list|,
name|placeholderValue
argument_list|)
expr_stmt|;
block|}
return|return
name|placeholderKeyValueMap
return|;
block|}
comment|/**    * verify that a live cluster isn't there    * @param clustername cluster name    * @param action    * @throws SliderException with exit code EXIT_CLUSTER_LIVE    * if a cluster of that name is either live or starting up.    */
DECL|method|verifyNoLiveApp (String clustername, String action)
specifier|public
name|void
name|verifyNoLiveApp
parameter_list|(
name|String
name|clustername
parameter_list|,
name|String
name|action
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
name|List
argument_list|<
name|ApplicationReport
argument_list|>
name|existing
init|=
name|findAllLiveInstances
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|existing
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|SliderException
argument_list|(
name|EXIT_APPLICATION_IN_USE
argument_list|,
name|action
operator|+
literal|" failed for "
operator|+
name|clustername
operator|+
literal|": "
operator|+
name|E_CLUSTER_RUNNING
operator|+
literal|" :"
operator|+
name|existing
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
throw|;
block|}
block|}
DECL|method|getUsername ()
specifier|public
name|String
name|getUsername
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|RegistryUtils
operator|.
name|currentUser
argument_list|()
return|;
block|}
comment|/**    * Get the name of any deployed cluster    * @return the cluster name    */
DECL|method|getDeployedClusterName ()
specifier|public
name|String
name|getDeployedClusterName
parameter_list|()
block|{
return|return
name|deployedClusterName
return|;
block|}
comment|/**    * ask if the client is using a mini MR cluster    * @return true if they are    */
DECL|method|getUsingMiniMRCluster ()
specifier|private
name|boolean
name|getUsingMiniMRCluster
parameter_list|()
block|{
return|return
name|getConfig
argument_list|()
operator|.
name|getBoolean
argument_list|(
name|YarnConfiguration
operator|.
name|IS_MINI_YARN_CLUSTER
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * List Slider instances belonging to a specific user with a specific app    * name and within a set of app states.    * @param user user: "" means all users, null means "default"    * @param appName name of the application set as a tag    * @param appStates a set of states the applications should be in    * @return a possibly empty list of Slider AMs    */
DECL|method|listSliderInstances (String user, String appName, EnumSet<YarnApplicationState> appStates)
specifier|public
name|List
argument_list|<
name|ApplicationReport
argument_list|>
name|listSliderInstances
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|appName
parameter_list|,
name|EnumSet
argument_list|<
name|YarnApplicationState
argument_list|>
name|appStates
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
return|return
name|yarnAppListClient
operator|.
name|listInstances
argument_list|(
name|user
argument_list|,
name|appName
argument_list|,
name|appStates
argument_list|)
return|;
block|}
comment|/**    * A basic list action to list live instances    * @param clustername cluster name    * @return success if the listing was considered successful    * @throws IOException    * @throws YarnException    */
DECL|method|actionList (String clustername)
specifier|public
name|int
name|actionList
parameter_list|(
name|String
name|clustername
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
name|ActionListArgs
name|args
init|=
operator|new
name|ActionListArgs
argument_list|()
decl_stmt|;
name|args
operator|.
name|live
operator|=
literal|true
expr_stmt|;
return|return
name|actionList
argument_list|(
name|clustername
argument_list|,
name|args
argument_list|)
return|;
block|}
comment|/**    * Implement the list action.    * @param clustername List out specific instance name    * @param args Action list arguments    * @return 0 if one or more entries were listed    * @throws IOException    * @throws YarnException    * @throws UnknownApplicationInstanceException if a specific instance    * was named but it was not found    */
annotation|@
name|Override
DECL|method|actionList (String clustername, ActionListArgs args)
specifier|public
name|int
name|actionList
parameter_list|(
name|String
name|clustername
parameter_list|,
name|ActionListArgs
name|args
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
name|Set
argument_list|<
name|ApplicationReport
argument_list|>
name|appInstances
init|=
name|getApplicationList
argument_list|(
name|clustername
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|appInstances
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|EXIT_SUCCESS
return|;
block|}
else|else
block|{
return|return
name|EXIT_FALSE
return|;
block|}
block|}
comment|/**    * Retrieve a list of application instances satisfying the query criteria.    *     * @param clustername    *          List out specific instance name (set null for all)    * @param args    *          Action list arguments    * @return the list of application names which satisfies the list criteria    * @throws IOException    * @throws YarnException    * @throws UnknownApplicationInstanceException    *           if a specific instance was named but it was not found    */
DECL|method|getApplicationList (String clustername, ActionListArgs args)
specifier|public
name|Set
argument_list|<
name|ApplicationReport
argument_list|>
name|getApplicationList
parameter_list|(
name|String
name|clustername
parameter_list|,
name|ActionListArgs
name|args
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
if|if
condition|(
name|args
operator|.
name|help
condition|)
block|{
name|actionHelp
argument_list|(
name|ACTION_LIST
argument_list|)
expr_stmt|;
comment|// the above call throws an exception so the return is not really required
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
name|boolean
name|live
init|=
name|args
operator|.
name|live
decl_stmt|;
name|String
name|state
init|=
name|args
operator|.
name|state
decl_stmt|;
name|boolean
name|listContainers
init|=
name|args
operator|.
name|containers
decl_stmt|;
name|boolean
name|verbose
init|=
name|args
operator|.
name|verbose
decl_stmt|;
name|String
name|version
init|=
name|args
operator|.
name|version
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|components
init|=
name|args
operator|.
name|components
decl_stmt|;
if|if
condition|(
name|live
operator|&&
operator|!
name|state
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
name|Arguments
operator|.
name|ARG_LIVE
operator|+
literal|" and "
operator|+
name|Arguments
operator|.
name|ARG_STATE
operator|+
literal|" are exclusive"
argument_list|)
throw|;
block|}
if|if
condition|(
name|listContainers
operator|&&
name|isUnset
argument_list|(
name|clustername
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"Should specify an application instance with "
operator|+
name|Arguments
operator|.
name|ARG_CONTAINERS
argument_list|)
throw|;
block|}
comment|// specifying both --version and --components with --containers is okay
if|if
condition|(
name|StringUtils
operator|.
name|isNotEmpty
argument_list|(
name|version
argument_list|)
operator|&&
operator|!
name|listContainers
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
name|Arguments
operator|.
name|ARG_VERSION
operator|+
literal|" can be specified only with "
operator|+
name|Arguments
operator|.
name|ARG_CONTAINERS
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|components
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|listContainers
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
name|Arguments
operator|.
name|ARG_COMPONENTS
operator|+
literal|" can be specified only with "
operator|+
name|Arguments
operator|.
name|ARG_CONTAINERS
argument_list|)
throw|;
block|}
comment|// flag to indicate only services in a specific state are to be listed
name|boolean
name|listOnlyInState
init|=
name|live
operator|||
operator|!
name|state
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
name|YarnApplicationState
name|min
decl_stmt|,
name|max
decl_stmt|;
if|if
condition|(
name|live
condition|)
block|{
name|min
operator|=
name|YarnApplicationState
operator|.
name|NEW
expr_stmt|;
name|max
operator|=
name|YarnApplicationState
operator|.
name|RUNNING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|state
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|YarnApplicationState
name|stateVal
init|=
name|extractYarnApplicationState
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|min
operator|=
name|max
operator|=
name|stateVal
expr_stmt|;
block|}
else|else
block|{
name|min
operator|=
name|YarnApplicationState
operator|.
name|NEW
expr_stmt|;
name|max
operator|=
name|YarnApplicationState
operator|.
name|KILLED
expr_stmt|;
block|}
comment|// get the complete list of persistent instances
name|Map
argument_list|<
name|String
argument_list|,
name|Path
argument_list|>
name|persistentInstances
init|=
name|sliderFileSystem
operator|.
name|listPersistentInstances
argument_list|()
decl_stmt|;
if|if
condition|(
name|persistentInstances
operator|.
name|isEmpty
argument_list|()
operator|&&
name|isUnset
argument_list|(
name|clustername
argument_list|)
condition|)
block|{
comment|// an empty listing is a success if no cluster was named
name|log
operator|.
name|debug
argument_list|(
literal|"No application instances found"
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
comment|// and those the RM knows about
name|EnumSet
argument_list|<
name|YarnApplicationState
argument_list|>
name|appStates
init|=
name|EnumSet
operator|.
name|range
argument_list|(
name|min
argument_list|,
name|max
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ApplicationReport
argument_list|>
name|instances
init|=
name|listSliderInstances
argument_list|(
literal|null
argument_list|,
name|clustername
argument_list|,
name|appStates
argument_list|)
decl_stmt|;
name|sortApplicationsByMostRecent
argument_list|(
name|instances
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ApplicationReport
argument_list|>
name|reportMap
init|=
name|buildApplicationReportMap
argument_list|(
name|instances
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Persisted {} deployed {} filtered[{}-{}]& de-duped to {}"
argument_list|,
name|persistentInstances
operator|.
name|size
argument_list|()
argument_list|,
name|instances
operator|.
name|size
argument_list|()
argument_list|,
name|min
argument_list|,
name|max
argument_list|,
name|reportMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ContainerInformation
argument_list|>
name|containers
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isSet
argument_list|(
name|clustername
argument_list|)
condition|)
block|{
comment|// only one instance is expected
comment|// resolve the persistent value
name|Path
name|persistent
init|=
name|persistentInstances
operator|.
name|get
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
if|if
condition|(
name|persistent
operator|==
literal|null
condition|)
block|{
throw|throw
name|unknownClusterException
argument_list|(
name|clustername
argument_list|)
throw|;
block|}
comment|// create a new map with only that instance in it.
comment|// this restricts the output of results to this instance
name|persistentInstances
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|persistentInstances
operator|.
name|put
argument_list|(
name|clustername
argument_list|,
name|persistent
argument_list|)
expr_stmt|;
if|if
condition|(
name|listContainers
condition|)
block|{
name|containers
operator|=
name|getContainers
argument_list|(
name|clustername
argument_list|)
expr_stmt|;
block|}
block|}
comment|// at this point there is either the entire list or a stripped down instance
name|Set
argument_list|<
name|ApplicationReport
argument_list|>
name|listedInstances
init|=
operator|new
name|HashSet
argument_list|<
name|ApplicationReport
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|persistentInstances
operator|.
name|keySet
argument_list|()
control|)
block|{
name|ApplicationReport
name|report
init|=
name|reportMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|listOnlyInState
operator|||
name|report
operator|!=
literal|null
condition|)
block|{
comment|// list the details if all were requested, or the filtering contained
comment|// a report
name|listedInstances
operator|.
name|add
argument_list|(
name|report
argument_list|)
expr_stmt|;
comment|// containers will be non-null when only one instance is requested
name|String
name|details
init|=
name|instanceDetailsToString
argument_list|(
name|name
argument_list|,
name|report
argument_list|,
name|containers
argument_list|,
name|version
argument_list|,
name|components
argument_list|,
name|verbose
argument_list|)
decl_stmt|;
name|print
argument_list|(
name|details
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|listedInstances
return|;
block|}
DECL|method|getContainers (String name)
specifier|public
name|List
argument_list|<
name|ContainerInformation
argument_list|>
name|getContainers
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|SliderClusterOperations
name|clusterOps
init|=
operator|new
name|SliderClusterOperations
argument_list|(
name|bondToCluster
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|clusterOps
operator|.
name|getContainers
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchNodeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|BadClusterStateException
argument_list|(
literal|"Containers not found for application instance %s"
argument_list|,
name|name
argument_list|)
throw|;
block|}
block|}
comment|/**    * Extract the state of a Yarn application --state argument    * @param state state argument    * @return the application state    * @throws BadCommandArgumentsException if the argument did not match    * any known state    */
DECL|method|extractYarnApplicationState (String state)
specifier|private
name|YarnApplicationState
name|extractYarnApplicationState
parameter_list|(
name|String
name|state
parameter_list|)
throws|throws
name|BadCommandArgumentsException
block|{
name|YarnApplicationState
name|stateVal
decl_stmt|;
try|try
block|{
name|stateVal
operator|=
name|YarnApplicationState
operator|.
name|valueOf
argument_list|(
name|state
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"Unknown state: "
operator|+
name|state
argument_list|)
throw|;
block|}
return|return
name|stateVal
return|;
block|}
comment|/**    * Is an application active: accepted or running    * @param report the application report    * @return true if it is running or scheduled to run.    */
DECL|method|isApplicationActive (ApplicationReport report)
specifier|public
name|boolean
name|isApplicationActive
parameter_list|(
name|ApplicationReport
name|report
parameter_list|)
block|{
return|return
name|report
operator|.
name|getYarnApplicationState
argument_list|()
operator|==
name|YarnApplicationState
operator|.
name|RUNNING
operator|||
name|report
operator|.
name|getYarnApplicationState
argument_list|()
operator|==
name|YarnApplicationState
operator|.
name|ACCEPTED
return|;
block|}
comment|/**    * Implement the islive action: probe for a cluster of the given name existing    * @return exit code    */
annotation|@
name|Override
annotation|@
name|VisibleForTesting
DECL|method|actionFlex (String appName, ActionFlexArgs args)
specifier|public
name|int
name|actionFlex
parameter_list|(
name|String
name|appName
parameter_list|,
name|ActionFlexArgs
name|args
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|componentCounts
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|args
operator|.
name|getComponentMap
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|args
operator|.
name|getComponentMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|long
name|numberOfContainers
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|componentCounts
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|numberOfContainers
argument_list|)
expr_stmt|;
block|}
comment|// throw usage exception if no changes proposed
if|if
condition|(
name|componentCounts
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|actionHelp
argument_list|(
name|ACTION_FLEX
argument_list|)
expr_stmt|;
block|}
name|flex
argument_list|(
name|appName
argument_list|,
name|componentCounts
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
annotation|@
name|Override
DECL|method|actionExists (String name, boolean checkLive)
specifier|public
name|int
name|actionExists
parameter_list|(
name|String
name|name
parameter_list|,
name|boolean
name|checkLive
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|ActionExistsArgs
name|args
init|=
operator|new
name|ActionExistsArgs
argument_list|()
decl_stmt|;
name|args
operator|.
name|live
operator|=
name|checkLive
expr_stmt|;
return|return
name|actionExists
argument_list|(
name|name
argument_list|,
name|args
argument_list|)
return|;
block|}
DECL|method|actionExists (String name, ActionExistsArgs args)
specifier|public
name|int
name|actionExists
parameter_list|(
name|String
name|name
parameter_list|,
name|ActionExistsArgs
name|args
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|validateClusterName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|boolean
name|checkLive
init|=
name|args
operator|.
name|live
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"actionExists({}, {}, {})"
argument_list|,
name|name
argument_list|,
name|checkLive
argument_list|,
name|args
operator|.
name|state
argument_list|)
expr_stmt|;
comment|//initial probe for a cluster in the filesystem
name|Path
name|clusterDirectory
init|=
name|sliderFileSystem
operator|.
name|buildClusterDirPath
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
operator|.
name|exists
argument_list|(
name|clusterDirectory
argument_list|)
condition|)
block|{
throw|throw
name|unknownClusterException
argument_list|(
name|name
argument_list|)
throw|;
block|}
name|String
name|state
init|=
name|args
operator|.
name|state
decl_stmt|;
if|if
condition|(
operator|!
name|checkLive
operator|&&
name|isUnset
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Application {} exists"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
comment|//test for liveness/state
name|boolean
name|inDesiredState
init|=
literal|false
decl_stmt|;
name|ApplicationReport
name|instance
decl_stmt|;
name|instance
operator|=
name|findInstance
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Application {} not running"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|EXIT_FALSE
return|;
block|}
if|if
condition|(
name|checkLive
condition|)
block|{
comment|// the app exists, check that it is not in any terminated state
name|YarnApplicationState
name|appstate
init|=
name|instance
operator|.
name|getYarnApplicationState
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|" current app state = {}"
argument_list|,
name|appstate
argument_list|)
expr_stmt|;
name|inDesiredState
operator|=
name|appstate
operator|.
name|ordinal
argument_list|()
operator|<
name|YarnApplicationState
operator|.
name|FINISHED
operator|.
name|ordinal
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// scan for instance in single --state state
name|state
operator|=
name|state
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
expr_stmt|;
name|YarnApplicationState
name|desiredState
init|=
name|extractYarnApplicationState
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ApplicationReport
argument_list|>
name|userInstances
init|=
name|yarnClient
operator|.
name|listDeployedInstances
argument_list|(
literal|""
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|desiredState
argument_list|)
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|ApplicationReport
name|foundInstance
init|=
name|yarnClient
operator|.
name|findAppInInstanceList
argument_list|(
name|userInstances
argument_list|,
name|name
argument_list|,
name|desiredState
argument_list|)
decl_stmt|;
if|if
condition|(
name|foundInstance
operator|!=
literal|null
condition|)
block|{
comment|// found in selected state: success
name|inDesiredState
operator|=
literal|true
expr_stmt|;
comment|// mark this as the instance to report
name|instance
operator|=
name|foundInstance
expr_stmt|;
block|}
block|}
name|OnDemandReportStringifier
name|report
init|=
operator|new
name|OnDemandReportStringifier
argument_list|(
name|instance
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|inDesiredState
condition|)
block|{
comment|//cluster in the list of apps but not running
name|log
operator|.
name|info
argument_list|(
literal|"Application {} found but is in wrong state {}"
argument_list|,
name|name
argument_list|,
name|instance
operator|.
name|getYarnApplicationState
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"State {}"
argument_list|,
name|report
argument_list|)
expr_stmt|;
return|return
name|EXIT_FALSE
return|;
block|}
else|else
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Application instance is in desired state"
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Application {} is {}\n{}"
argument_list|,
name|name
argument_list|,
name|instance
operator|.
name|getYarnApplicationState
argument_list|()
argument_list|,
name|report
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|actionKillContainer (String name, ActionKillContainerArgs args)
specifier|public
name|int
name|actionKillContainer
parameter_list|(
name|String
name|name
parameter_list|,
name|ActionKillContainerArgs
name|args
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|String
name|id
init|=
name|args
operator|.
name|id
decl_stmt|;
if|if
condition|(
name|isUnset
argument_list|(
name|id
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"Missing container id"
argument_list|)
throw|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"killingContainer {}:{}"
argument_list|,
name|name
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|SliderClusterOperations
name|clusterOps
init|=
operator|new
name|SliderClusterOperations
argument_list|(
name|bondToCluster
argument_list|(
name|name
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|clusterOps
operator|.
name|killContainer
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchNodeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|BadClusterStateException
argument_list|(
literal|"Container %s not found in cluster %s"
argument_list|,
name|id
argument_list|,
name|name
argument_list|)
throw|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
comment|/**    * Find an instance of an application belonging to the current user.    * @param appname application name    * @return the app report or null if none is found    * @throws YarnException YARN issues    * @throws IOException IO problems    */
DECL|method|findInstance (String appname)
specifier|public
name|ApplicationReport
name|findInstance
parameter_list|(
name|String
name|appname
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
return|return
name|findInstance
argument_list|(
name|appname
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Find an instance of an application belonging to the current user and in    * specific app states.    * @param appname application name    * @param appStates app states in which the application should be in    * @return the app report or null if none is found    * @throws YarnException YARN issues    * @throws IOException IO problems    */
DECL|method|findInstance (String appname, EnumSet<YarnApplicationState> appStates)
specifier|public
name|ApplicationReport
name|findInstance
parameter_list|(
name|String
name|appname
parameter_list|,
name|EnumSet
argument_list|<
name|YarnApplicationState
argument_list|>
name|appStates
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
return|return
name|yarnAppListClient
operator|.
name|findInstance
argument_list|(
name|appname
argument_list|,
name|appStates
argument_list|)
return|;
block|}
comment|/**    * find all live instances of a specific app -if there is>1 in the cluster,    * this returns them all. State should be running or less    * @param appname application name    * @return the list of all matching application instances    */
DECL|method|findAllLiveInstances (String appname)
specifier|private
name|List
argument_list|<
name|ApplicationReport
argument_list|>
name|findAllLiveInstances
parameter_list|(
name|String
name|appname
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
return|return
name|yarnAppListClient
operator|.
name|findAllLiveInstances
argument_list|(
name|appname
argument_list|)
return|;
block|}
comment|/**    * Connect to a Slider AM    * @param app application report providing the details on the application    * @return an instance    * @throws YarnException    * @throws IOException    */
DECL|method|connect (ApplicationReport app)
specifier|private
name|SliderClusterProtocol
name|connect
parameter_list|(
name|ApplicationReport
name|app
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
try|try
block|{
return|return
name|RpcBinder
operator|.
name|getProxy
argument_list|(
name|getConfig
argument_list|()
argument_list|,
name|yarnClient
operator|.
name|getRmClient
argument_list|()
argument_list|,
name|app
argument_list|,
name|Constants
operator|.
name|CONNECT_TIMEOUT
argument_list|,
name|Constants
operator|.
name|RPC_TIMEOUT
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|SliderException
argument_list|(
name|SliderExitCodes
operator|.
name|EXIT_TIMED_OUT
argument_list|,
name|e
argument_list|,
literal|"Interrupted waiting for communications with the Slider AM"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
annotation|@
name|VisibleForTesting
DECL|method|actionStatus (String clustername, ActionStatusArgs statusArgs)
specifier|public
name|int
name|actionStatus
parameter_list|(
name|String
name|clustername
parameter_list|,
name|ActionStatusArgs
name|statusArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
if|if
condition|(
name|statusArgs
operator|.
name|lifetime
condition|)
block|{
name|queryAndPrintLifetime
argument_list|(
name|clustername
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
name|Application
name|application
init|=
name|getApplication
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
name|String
name|outfile
init|=
name|statusArgs
operator|.
name|getOutput
argument_list|()
decl_stmt|;
if|if
condition|(
name|outfile
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
name|application
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|jsonSerDeser
operator|.
name|save
argument_list|(
name|application
argument_list|,
operator|new
name|File
argument_list|(
name|statusArgs
operator|.
name|getOutput
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
annotation|@
name|Override
DECL|method|actionStatus (String clustername)
specifier|public
name|Application
name|actionStatus
parameter_list|(
name|String
name|clustername
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
return|return
name|getApplication
argument_list|(
name|clustername
argument_list|)
return|;
block|}
DECL|method|queryAndPrintLifetime (String appName)
specifier|private
name|void
name|queryAndPrintLifetime
parameter_list|(
name|String
name|appName
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|ApplicationReport
name|appReport
init|=
name|findInstance
argument_list|(
name|appName
argument_list|)
decl_stmt|;
if|if
condition|(
name|appReport
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|YarnException
argument_list|(
literal|"No application found for "
operator|+
name|appName
argument_list|)
throw|;
block|}
name|ByteArrayOutputStream
name|baos
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|PrintWriter
name|timeoutStr
init|=
operator|new
name|PrintWriter
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
name|baos
argument_list|,
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|ApplicationTimeout
name|lifetime
init|=
name|appReport
operator|.
name|getApplicationTimeouts
argument_list|()
operator|.
name|get
argument_list|(
name|ApplicationTimeoutType
operator|.
name|LIFETIME
argument_list|)
decl_stmt|;
if|if
condition|(
name|lifetime
operator|.
name|getRemainingTime
argument_list|()
operator|==
operator|-
literal|1L
condition|)
block|{
name|timeoutStr
operator|.
name|append
argument_list|(
name|appName
operator|+
literal|" has no lifetime configured."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|timeoutStr
operator|.
name|append
argument_list|(
literal|"\t"
operator|+
name|ApplicationTimeoutType
operator|.
name|LIFETIME
argument_list|)
expr_stmt|;
name|timeoutStr
operator|.
name|print
argument_list|(
literal|" expires at : "
operator|+
name|lifetime
operator|.
name|getExpiryTime
argument_list|()
argument_list|)
expr_stmt|;
name|timeoutStr
operator|.
name|println
argument_list|(
literal|".\tRemaining Time : "
operator|+
name|lifetime
operator|.
name|getRemainingTime
argument_list|()
operator|+
literal|" seconds"
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|baos
operator|.
name|toString
argument_list|(
literal|"UTF-8"
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|timeoutStr
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|actionVersion ()
specifier|public
name|int
name|actionVersion
parameter_list|()
block|{
name|SliderVersionInfo
operator|.
name|loadAndPrintVersionInfo
argument_list|(
name|log
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
annotation|@
name|Override
DECL|method|actionStop (String appName, ActionFreezeArgs freezeArgs)
specifier|public
name|int
name|actionStop
parameter_list|(
name|String
name|appName
parameter_list|,
name|ActionFreezeArgs
name|freezeArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|validateClusterName
argument_list|(
name|appName
argument_list|)
expr_stmt|;
name|ApplicationReport
name|app
init|=
name|findInstance
argument_list|(
name|appName
argument_list|)
decl_stmt|;
if|if
condition|(
name|app
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ApplicationNotFoundException
argument_list|(
literal|"Application "
operator|+
name|appName
operator|+
literal|" doesn't exist in RM."
argument_list|)
throw|;
block|}
if|if
condition|(
name|terminatedStates
operator|.
name|contains
argument_list|(
name|app
operator|.
name|getYarnApplicationState
argument_list|()
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Application {} is already in a terminated state {}"
argument_list|,
name|appName
argument_list|,
name|app
operator|.
name|getYarnApplicationState
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
try|try
block|{
name|SliderClusterProtocol
name|appMaster
init|=
name|connect
argument_list|(
name|app
argument_list|)
decl_stmt|;
name|Messages
operator|.
name|StopClusterRequestProto
name|r
init|=
name|Messages
operator|.
name|StopClusterRequestProto
operator|.
name|newBuilder
argument_list|()
operator|.
name|setMessage
argument_list|(
name|freezeArgs
operator|.
name|message
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|appMaster
operator|.
name|stopCluster
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Application "
operator|+
name|appName
operator|+
literal|" is being gracefully stopped..."
argument_list|)
expr_stmt|;
name|long
name|startTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|int
name|pollCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|ApplicationReport
name|report
init|=
name|yarnClient
operator|.
name|getApplicationReport
argument_list|(
name|app
operator|.
name|getApplicationId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|terminatedStates
operator|.
name|contains
argument_list|(
name|report
operator|.
name|getYarnApplicationState
argument_list|()
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Application "
operator|+
name|appName
operator|+
literal|" is stopped."
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// kill after 10 seconds.
if|if
condition|(
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
operator|)
operator|>
literal|10000
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Stop operation timeout stopping, forcefully kill the app "
operator|+
name|appName
argument_list|)
expr_stmt|;
name|yarnClient
operator|.
name|killApplication
argument_list|(
name|app
operator|.
name|getApplicationId
argument_list|()
argument_list|,
name|freezeArgs
operator|.
name|message
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|++
name|pollCount
operator|%
literal|10
operator|==
literal|0
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Waiting for application "
operator|+
name|appName
operator|+
literal|" to be stopped."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|YarnException
decl||
name|InterruptedException
name|e
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Failed to stop "
operator|+
name|appName
operator|+
literal|" gracefully, forcefully kill the app."
argument_list|)
expr_stmt|;
name|yarnClient
operator|.
name|killApplication
argument_list|(
name|app
operator|.
name|getApplicationId
argument_list|()
argument_list|,
name|freezeArgs
operator|.
name|message
argument_list|)
expr_stmt|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
annotation|@
name|Override
DECL|method|actionStart (String appName, ActionThawArgs thaw)
specifier|public
name|int
name|actionStart
parameter_list|(
name|String
name|appName
parameter_list|,
name|ActionThawArgs
name|thaw
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|validateClusterName
argument_list|(
name|appName
argument_list|)
expr_stmt|;
name|Path
name|appDir
init|=
name|checkAppExistOnHdfs
argument_list|(
name|appName
argument_list|)
decl_stmt|;
name|Application
name|application
init|=
name|ServiceApiUtil
operator|.
name|loadApplication
argument_list|(
name|sliderFileSystem
argument_list|,
name|appName
argument_list|)
decl_stmt|;
name|ServiceApiUtil
operator|.
name|validateAndResolveApplication
argument_list|(
name|application
argument_list|,
name|sliderFileSystem
argument_list|)
expr_stmt|;
comment|// see if it is actually running and bail out;
name|verifyNoLiveApp
argument_list|(
name|appName
argument_list|,
literal|"Thaw"
argument_list|)
expr_stmt|;
name|ApplicationId
name|appId
init|=
name|submitApp
argument_list|(
name|application
argument_list|)
decl_stmt|;
name|application
operator|.
name|setId
argument_list|(
name|appId
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// write app definition on to hdfs
name|persistApp
argument_list|(
name|appDir
argument_list|,
name|application
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
DECL|method|flex (String appName, Map<String, Long> componentCounts)
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|flex
parameter_list|(
name|String
name|appName
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|componentCounts
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|validateClusterName
argument_list|(
name|appName
argument_list|)
expr_stmt|;
name|Application
name|persistedApp
init|=
name|ServiceApiUtil
operator|.
name|loadApplication
argument_list|(
name|sliderFileSystem
argument_list|,
name|appName
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|original
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|componentCounts
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Component
name|persistedComp
range|:
name|persistedApp
operator|.
name|getComponents
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|persistedComp
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|componentCounts
operator|.
name|containsKey
argument_list|(
name|persistedComp
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|original
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|persistedComp
operator|.
name|getNumberOfContainers
argument_list|()
argument_list|)
expr_stmt|;
name|persistedComp
operator|.
name|setNumberOfContainers
argument_list|(
name|componentCounts
operator|.
name|get
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|original
operator|.
name|size
argument_list|()
operator|<
name|componentCounts
operator|.
name|size
argument_list|()
condition|)
block|{
name|componentCounts
operator|.
name|keySet
argument_list|()
operator|.
name|removeAll
argument_list|(
name|original
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|YarnException
argument_list|(
literal|"Components "
operator|+
name|componentCounts
operator|.
name|keySet
argument_list|()
operator|+
literal|" do not exist in app definition."
argument_list|)
throw|;
block|}
name|jsonSerDeser
operator|.
name|save
argument_list|(
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|ServiceApiUtil
operator|.
name|getAppJsonPath
argument_list|(
name|sliderFileSystem
argument_list|,
name|appName
argument_list|)
argument_list|,
name|persistedApp
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Updated app definition file for components "
operator|+
name|componentCounts
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
name|ApplicationReport
name|instance
init|=
name|findInstance
argument_list|(
name|appName
argument_list|)
decl_stmt|;
if|if
condition|(
name|instance
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Flexing running app "
operator|+
name|appName
argument_list|)
expr_stmt|;
name|SliderClusterProtocol
name|appMaster
init|=
name|connect
argument_list|(
name|instance
argument_list|)
decl_stmt|;
name|SliderClusterOperations
name|clusterOps
init|=
operator|new
name|SliderClusterOperations
argument_list|(
name|appMaster
argument_list|)
decl_stmt|;
name|clusterOps
operator|.
name|flex
argument_list|(
name|componentCounts
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|componentCount
range|:
name|componentCounts
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Application name = "
operator|+
name|appName
operator|+
literal|", Component name = "
operator|+
name|componentCount
operator|.
name|getKey
argument_list|()
operator|+
literal|", number of containers updated "
operator|+
literal|"from "
operator|+
name|original
operator|.
name|get
argument_list|(
name|componentCount
operator|.
name|getKey
argument_list|()
argument_list|)
operator|+
literal|" to "
operator|+
name|componentCount
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|String
name|message
init|=
literal|"Application "
operator|+
name|appName
operator|+
literal|"does not exist in RM. "
decl_stmt|;
throw|throw
operator|new
name|YarnException
argument_list|(
name|message
argument_list|)
throw|;
block|}
return|return
name|original
return|;
block|}
comment|/**    * Connect to a live cluster and get its current state    *    * @param appName the cluster name    * @return its description    */
annotation|@
name|VisibleForTesting
DECL|method|getApplication (String appName)
specifier|public
name|Application
name|getApplication
parameter_list|(
name|String
name|appName
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|validateClusterName
argument_list|(
name|appName
argument_list|)
expr_stmt|;
name|SliderClusterOperations
name|clusterOperations
init|=
name|createClusterOperations
argument_list|(
name|appName
argument_list|)
decl_stmt|;
return|return
name|clusterOperations
operator|.
name|getApplication
argument_list|()
return|;
block|}
comment|/**    * Bond to a running cluster    * @param clustername cluster name    * @return the AM RPC client    * @throws SliderException if the cluster is unkown    */
DECL|method|bondToCluster (String clustername)
specifier|private
name|SliderClusterProtocol
name|bondToCluster
parameter_list|(
name|String
name|clustername
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
if|if
condition|(
name|clustername
operator|==
literal|null
condition|)
block|{
throw|throw
name|unknownClusterException
argument_list|(
literal|"(undefined)"
argument_list|)
throw|;
block|}
name|ApplicationReport
name|instance
init|=
name|findInstance
argument_list|(
name|clustername
argument_list|,
name|SliderUtils
operator|.
name|getAllLiveAppStates
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|instance
condition|)
block|{
throw|throw
name|unknownClusterException
argument_list|(
name|clustername
argument_list|)
throw|;
block|}
return|return
name|connect
argument_list|(
name|instance
argument_list|)
return|;
block|}
comment|/**    * Create a cluster operations instance against a given cluster    * @param clustername cluster name    * @return a bonded cluster operations instance    * @throws YarnException YARN issues    * @throws IOException IO problems    */
DECL|method|createClusterOperations (String clustername)
specifier|private
name|SliderClusterOperations
name|createClusterOperations
parameter_list|(
name|String
name|clustername
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|SliderClusterProtocol
name|sliderAM
init|=
name|bondToCluster
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
return|return
operator|new
name|SliderClusterOperations
argument_list|(
name|sliderAM
argument_list|)
return|;
block|}
comment|/**    * Generate an exception for an unknown cluster    * @param clustername cluster name    * @return an exception with text and a relevant exit code    */
DECL|method|unknownClusterException (String clustername)
specifier|public
name|UnknownApplicationInstanceException
name|unknownClusterException
parameter_list|(
name|String
name|clustername
parameter_list|)
block|{
return|return
name|UnknownApplicationInstanceException
operator|.
name|unknownInstance
argument_list|(
name|clustername
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Slider Client in state "
operator|+
name|getServiceState
argument_list|()
operator|+
literal|" and Slider Application Instance "
operator|+
name|deployedClusterName
return|;
block|}
comment|/**    * Get all YARN applications    * @return a possibly empty list    * @throws YarnException    * @throws IOException    */
annotation|@
name|VisibleForTesting
DECL|method|getApplications ()
specifier|public
name|List
argument_list|<
name|ApplicationReport
argument_list|>
name|getApplications
parameter_list|()
throws|throws
name|YarnException
throws|,
name|IOException
block|{
return|return
name|yarnClient
operator|.
name|getApplications
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|actionResolve (ActionResolveArgs args)
specifier|public
name|int
name|actionResolve
parameter_list|(
name|ActionResolveArgs
name|args
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
comment|// as this is an API entry point, validate
comment|// the arguments
name|args
operator|.
name|validate
argument_list|()
expr_stmt|;
name|String
name|path
init|=
name|SliderRegistryUtils
operator|.
name|resolvePath
argument_list|(
name|args
operator|.
name|path
argument_list|)
decl_stmt|;
name|ServiceRecordMarshal
name|serviceRecordMarshal
init|=
operator|new
name|ServiceRecordMarshal
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|args
operator|.
name|list
condition|)
block|{
name|File
name|destDir
init|=
name|args
operator|.
name|destdir
decl_stmt|;
if|if
condition|(
name|destDir
operator|!=
literal|null
operator|&&
operator|!
name|destDir
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|destDir
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to create directory: "
operator|+
name|destDir
argument_list|)
throw|;
block|}
name|Map
argument_list|<
name|String
argument_list|,
name|ServiceRecord
argument_list|>
name|recordMap
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|RegistryPathStatus
argument_list|>
name|znodes
decl_stmt|;
try|try
block|{
name|znodes
operator|=
name|statChildren
argument_list|(
name|registryOperations
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|recordMap
operator|=
name|extractServiceRecords
argument_list|(
name|registryOperations
argument_list|,
name|path
argument_list|,
name|znodes
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PathNotFoundException
name|e
parameter_list|)
block|{
comment|// treat the root directory as if if is always there
if|if
condition|(
literal|"/"
operator|.
name|equals
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|znodes
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|recordMap
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
comment|// subtract all records from the znodes map to get pure directories
name|log
operator|.
name|info
argument_list|(
literal|"Entries: {}"
argument_list|,
name|znodes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|name
range|:
name|znodes
operator|.
name|keySet
argument_list|()
control|)
block|{
name|println
argument_list|(
literal|"  "
operator|+
name|name
argument_list|)
expr_stmt|;
block|}
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Service records: {}"
argument_list|,
name|recordMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|ServiceRecord
argument_list|>
name|recordEntry
range|:
name|recordMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|recordEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|ServiceRecord
name|instance
init|=
name|recordEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|json
init|=
name|serviceRecordMarshal
operator|.
name|toJson
argument_list|(
name|instance
argument_list|)
decl_stmt|;
if|if
condition|(
name|destDir
operator|==
literal|null
condition|)
block|{
name|println
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|println
argument_list|(
name|json
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|filename
init|=
name|RegistryPathUtils
operator|.
name|lastPathEntry
argument_list|(
name|name
argument_list|)
operator|+
literal|".json"
decl_stmt|;
name|File
name|jsonFile
init|=
operator|new
name|File
argument_list|(
name|destDir
argument_list|,
name|filename
argument_list|)
decl_stmt|;
name|write
argument_list|(
name|jsonFile
argument_list|,
name|serviceRecordMarshal
operator|.
name|toBytes
argument_list|(
name|instance
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// resolve single entry
name|ServiceRecord
name|instance
init|=
name|resolve
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|File
name|outFile
init|=
name|args
operator|.
name|out
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|destdir
operator|!=
literal|null
condition|)
block|{
name|outFile
operator|=
operator|new
name|File
argument_list|(
name|args
operator|.
name|destdir
argument_list|,
name|RegistryPathUtils
operator|.
name|lastPathEntry
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outFile
operator|!=
literal|null
condition|)
block|{
name|write
argument_list|(
name|outFile
argument_list|,
name|serviceRecordMarshal
operator|.
name|toBytes
argument_list|(
name|instance
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|println
argument_list|(
name|serviceRecordMarshal
operator|.
name|toJson
argument_list|(
name|instance
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|PathNotFoundException
decl||
name|NoRecordException
name|e
parameter_list|)
block|{
comment|// no record at this path
throw|throw
operator|new
name|NotFoundException
argument_list|(
name|e
argument_list|,
name|path
argument_list|)
throw|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
annotation|@
name|Override
DECL|method|actionRegistry (ActionRegistryArgs registryArgs)
specifier|public
name|int
name|actionRegistry
parameter_list|(
name|ActionRegistryArgs
name|registryArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
comment|// as this is also a test entry point, validate
comment|// the arguments
name|registryArgs
operator|.
name|validate
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|registryArgs
operator|.
name|list
condition|)
block|{
name|actionRegistryList
argument_list|(
name|registryArgs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|registryArgs
operator|.
name|listConf
condition|)
block|{
comment|// list the configurations
name|actionRegistryListConfigsYarn
argument_list|(
name|registryArgs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|registryArgs
operator|.
name|listExports
condition|)
block|{
comment|// list the exports
name|actionRegistryListExports
argument_list|(
name|registryArgs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isSet
argument_list|(
name|registryArgs
operator|.
name|getConf
argument_list|)
condition|)
block|{
comment|// get a configuration
name|PublishedConfiguration
name|publishedConfiguration
init|=
name|actionRegistryGetConfig
argument_list|(
name|registryArgs
argument_list|)
decl_stmt|;
name|outputConfig
argument_list|(
name|publishedConfiguration
argument_list|,
name|registryArgs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isSet
argument_list|(
name|registryArgs
operator|.
name|getExport
argument_list|)
condition|)
block|{
comment|// get a export group
name|PublishedExports
name|publishedExports
init|=
name|actionRegistryGetExport
argument_list|(
name|registryArgs
argument_list|)
decl_stmt|;
name|outputExport
argument_list|(
name|publishedExports
argument_list|,
name|registryArgs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// it's an unknown command
name|log
operator|.
name|info
argument_list|(
name|CommonArgs
operator|.
name|usage
argument_list|(
name|serviceArgs
argument_list|,
name|ACTION_DIAGNOSTICS
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EXIT_USAGE
return|;
block|}
comment|//      JDK7
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"{}"
argument_list|,
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"{}"
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|EXIT_NOT_FOUND
return|;
block|}
catch|catch
parameter_list|(
name|PathNotFoundException
name|e
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"{}"
argument_list|,
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"{}"
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|EXIT_NOT_FOUND
return|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
comment|/**    * Registry operation    *    * @param registryArgs registry Arguments    * @return the instances (for tests)    * @throws YarnException YARN problems    * @throws IOException Network or other problems    */
annotation|@
name|VisibleForTesting
DECL|method|actionRegistryList ( ActionRegistryArgs registryArgs)
specifier|public
name|Collection
argument_list|<
name|ServiceRecord
argument_list|>
name|actionRegistryList
parameter_list|(
name|ActionRegistryArgs
name|registryArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|String
name|serviceType
init|=
name|registryArgs
operator|.
name|serviceType
decl_stmt|;
name|String
name|name
init|=
name|registryArgs
operator|.
name|name
decl_stmt|;
name|RegistryOperations
name|operations
init|=
name|getRegistryOperations
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|ServiceRecord
argument_list|>
name|serviceRecords
decl_stmt|;
if|if
condition|(
name|StringUtils
operator|.
name|isEmpty
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|String
name|path
init|=
name|serviceclassPath
argument_list|(
name|currentUser
argument_list|()
argument_list|,
name|serviceType
argument_list|)
decl_stmt|;
try|try
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|ServiceRecord
argument_list|>
name|recordMap
init|=
name|listServiceRecords
argument_list|(
name|operations
argument_list|,
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|recordMap
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnknownApplicationInstanceException
argument_list|(
literal|"No applications registered under "
operator|+
name|path
argument_list|)
throw|;
block|}
name|serviceRecords
operator|=
name|recordMap
operator|.
name|values
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|PathNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|NotFoundException
argument_list|(
name|path
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|ServiceRecord
name|instance
init|=
name|lookupServiceRecord
argument_list|(
name|registryArgs
argument_list|)
decl_stmt|;
name|serviceRecords
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|serviceRecords
operator|.
name|add
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ServiceRecord
name|serviceRecord
range|:
name|serviceRecords
control|)
block|{
name|logInstance
argument_list|(
name|serviceRecord
argument_list|,
name|registryArgs
operator|.
name|verbose
argument_list|)
expr_stmt|;
block|}
return|return
name|serviceRecords
return|;
block|}
annotation|@
name|Override
DECL|method|actionDiagnostic (ActionDiagnosticArgs diagnosticArgs)
specifier|public
name|int
name|actionDiagnostic
parameter_list|(
name|ActionDiagnosticArgs
name|diagnosticArgs
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|diagnosticArgs
operator|.
name|client
condition|)
block|{
name|actionDiagnosticClient
argument_list|(
name|diagnosticArgs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diagnosticArgs
operator|.
name|application
condition|)
block|{
comment|// TODO print configs of application - get from AM
block|}
elseif|else
if|if
condition|(
name|diagnosticArgs
operator|.
name|yarn
condition|)
block|{
comment|// This method prints yarn nodes info and yarn configs.
comment|// We can just use yarn node CLI instead which is much more richful
comment|// for yarn configs, this method reads local config which is only client
comment|// config not cluster configs.
comment|//        actionDiagnosticYarn(diagnosticArgs);
block|}
elseif|else
if|if
condition|(
name|diagnosticArgs
operator|.
name|credentials
condition|)
block|{
comment|// actionDiagnosticCredentials internall only runs a bare 'klist' command...
comment|// IMHO, the user can just run klist on their own with extra options supported, don't
comment|// actually see the point of this method.
comment|//        actionDiagnosticCredentials();
block|}
elseif|else
if|if
condition|(
name|diagnosticArgs
operator|.
name|all
condition|)
block|{
name|actionDiagnosticAll
argument_list|(
name|diagnosticArgs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diagnosticArgs
operator|.
name|level
condition|)
block|{
comment|// agent is removed
block|}
else|else
block|{
comment|// it's an unknown option
name|log
operator|.
name|info
argument_list|(
name|CommonArgs
operator|.
name|usage
argument_list|(
name|serviceArgs
argument_list|,
name|ACTION_DIAGNOSTICS
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EXIT_USAGE
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|EXIT_FALSE
return|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
DECL|method|actionDiagnosticAll (ActionDiagnosticArgs diagnosticArgs)
specifier|private
name|void
name|actionDiagnosticAll
parameter_list|(
name|ActionDiagnosticArgs
name|diagnosticArgs
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
comment|// assign application name from param to each sub diagnostic function
name|actionDiagnosticClient
argument_list|(
name|diagnosticArgs
argument_list|)
expr_stmt|;
comment|// actionDiagnosticSlider only prints the agent location on hdfs,
comment|// which is invalid now.
comment|// actionDiagnosticCredentials only runs 'klist' command, IMHO, the user
comment|// can just run klist on its own with extra options supported, don't
comment|// actually see the point of this method.
block|}
DECL|method|actionDiagnosticClient (ActionDiagnosticArgs diagnosticArgs)
specifier|private
name|void
name|actionDiagnosticClient
parameter_list|(
name|ActionDiagnosticArgs
name|diagnosticArgs
parameter_list|)
throws|throws
name|SliderException
throws|,
name|IOException
block|{
try|try
block|{
name|String
name|currentCommandPath
init|=
name|getCurrentCommandPath
argument_list|()
decl_stmt|;
name|SliderVersionInfo
operator|.
name|loadAndPrintVersionInfo
argument_list|(
name|log
argument_list|)
expr_stmt|;
name|String
name|clientConfigPath
init|=
name|getClientConfigPath
argument_list|()
decl_stmt|;
name|String
name|jdkInfo
init|=
name|getJDKInfo
argument_list|()
decl_stmt|;
name|println
argument_list|(
literal|"The slider command path: %s"
argument_list|,
name|currentCommandPath
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"The slider-client.xml used by current running command path: %s"
argument_list|,
name|clientConfigPath
argument_list|)
expr_stmt|;
name|println
argument_list|(
name|jdkInfo
argument_list|)
expr_stmt|;
comment|// security info
name|Configuration
name|config
init|=
name|getConfig
argument_list|()
decl_stmt|;
if|if
condition|(
name|isHadoopClusterSecure
argument_list|(
name|config
argument_list|)
condition|)
block|{
name|println
argument_list|(
literal|"Hadoop Cluster is secure"
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"Login user is %s"
argument_list|,
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"Current user is %s"
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|println
argument_list|(
literal|"Hadoop Cluster is insecure"
argument_list|)
expr_stmt|;
block|}
comment|// verbose?
if|if
condition|(
name|diagnosticArgs
operator|.
name|verbose
condition|)
block|{
comment|// do the environment
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
init|=
name|getSystemEnv
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|envList
init|=
name|ConfigHelper
operator|.
name|sortedConfigKeys
argument_list|(
name|env
operator|.
name|entrySet
argument_list|()
argument_list|)
decl_stmt|;
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"Environment variables:\n"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|key
range|:
name|envList
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|key
argument_list|)
operator|.
name|append
argument_list|(
literal|"="
argument_list|)
operator|.
name|append
argument_list|(
name|env
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|println
argument_list|(
name|builder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Java properties
name|builder
operator|=
operator|new
name|StringBuilder
argument_list|(
literal|"JVM Properties\n"
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|props
init|=
name|sortedMap
argument_list|(
name|toMap
argument_list|(
name|System
operator|.
name|getProperties
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|props
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"="
argument_list|)
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|println
argument_list|(
name|builder
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// then the config
name|println
argument_list|(
literal|"Slider client configuration:\n"
operator|+
name|ConfigHelper
operator|.
name|dumpConfigToString
argument_list|(
name|config
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|validateSliderClientEnvironment
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SliderException
decl||
name|IOException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Kerberos Diagnostics    * @param args CLI arguments    * @return exit code    * @throws SliderException    * @throws IOException    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"IOResourceOpenedButNotSafelyClosed"
argument_list|)
DECL|method|actionKDiag (ActionKDiagArgs args)
specifier|private
name|int
name|actionKDiag
parameter_list|(
name|ActionKDiagArgs
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|PrintStream
name|out
decl_stmt|;
name|boolean
name|closeStream
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|=
operator|new
name|PrintStream
argument_list|(
name|args
operator|.
name|out
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
name|closeStream
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|out
operator|=
name|System
operator|.
name|err
expr_stmt|;
block|}
try|try
block|{
name|KerberosDiags
name|kdiags
init|=
operator|new
name|KerberosDiags
argument_list|(
name|getConfig
argument_list|()
argument_list|,
name|out
argument_list|,
name|args
operator|.
name|services
argument_list|,
name|args
operator|.
name|keytab
argument_list|,
name|args
operator|.
name|principal
argument_list|,
name|args
operator|.
name|keylen
argument_list|,
name|args
operator|.
name|secure
argument_list|)
decl_stmt|;
name|kdiags
operator|.
name|execute
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KerberosDiags
operator|.
name|KerberosDiagsFailure
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Kerberos Diagnostics"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|closeStream
condition|)
block|{
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
comment|/**    * Log a service record instance    * @param instance record    * @param verbose verbose logging of all external endpoints    */
DECL|method|logInstance (ServiceRecord instance, boolean verbose)
specifier|private
name|void
name|logInstance
parameter_list|(
name|ServiceRecord
name|instance
parameter_list|,
name|boolean
name|verbose
parameter_list|)
block|{
if|if
condition|(
operator|!
name|verbose
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"{}"
argument_list|,
name|instance
operator|.
name|get
argument_list|(
name|YarnRegistryAttributes
operator|.
name|YARN_ID
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"{}: "
argument_list|,
name|instance
operator|.
name|get
argument_list|(
name|YarnRegistryAttributes
operator|.
name|YARN_ID
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|logEndpoints
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Log the external endpoints of a service record    * @param instance service record instance    */
DECL|method|logEndpoints (ServiceRecord instance)
specifier|private
name|void
name|logEndpoints
parameter_list|(
name|ServiceRecord
name|instance
parameter_list|)
block|{
name|List
argument_list|<
name|Endpoint
argument_list|>
name|endpoints
init|=
name|instance
operator|.
name|external
decl_stmt|;
for|for
control|(
name|Endpoint
name|endpoint
range|:
name|endpoints
control|)
block|{
name|log
operator|.
name|info
argument_list|(
name|endpoint
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * list configs available for an instance    *    * @param registryArgs registry Arguments    * @throws YarnException YARN problems    * @throws IOException Network or other problems    */
DECL|method|actionRegistryListConfigsYarn (ActionRegistryArgs registryArgs)
specifier|public
name|void
name|actionRegistryListConfigsYarn
parameter_list|(
name|ActionRegistryArgs
name|registryArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|ServiceRecord
name|instance
init|=
name|lookupServiceRecord
argument_list|(
name|registryArgs
argument_list|)
decl_stmt|;
name|RegistryRetriever
name|retriever
init|=
operator|new
name|RegistryRetriever
argument_list|(
name|getConfig
argument_list|()
argument_list|,
name|instance
argument_list|)
decl_stmt|;
name|PublishedConfigSet
name|configurations
init|=
name|retriever
operator|.
name|getConfigurations
argument_list|(
operator|!
name|registryArgs
operator|.
name|internal
argument_list|)
decl_stmt|;
name|PrintStream
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|registryArgs
operator|.
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|=
operator|new
name|PrintStream
argument_list|(
name|registryArgs
operator|.
name|out
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|=
name|System
operator|.
name|out
expr_stmt|;
block|}
for|for
control|(
name|String
name|configName
range|:
name|configurations
operator|.
name|keys
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|registryArgs
operator|.
name|verbose
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
name|configName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PublishedConfiguration
name|published
init|=
name|configurations
operator|.
name|get
argument_list|(
name|configName
argument_list|)
decl_stmt|;
name|out
operator|.
name|printf
argument_list|(
literal|"%s: %s%n"
argument_list|,
name|configName
argument_list|,
name|published
operator|.
name|description
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|registryArgs
operator|.
name|out
operator|!=
literal|null
operator|&&
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * list exports available for an instance    *    * @param registryArgs registry Arguments    * @throws YarnException YARN problems    * @throws IOException Network or other problems    */
DECL|method|actionRegistryListExports (ActionRegistryArgs registryArgs)
specifier|public
name|void
name|actionRegistryListExports
parameter_list|(
name|ActionRegistryArgs
name|registryArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|ServiceRecord
name|instance
init|=
name|lookupServiceRecord
argument_list|(
name|registryArgs
argument_list|)
decl_stmt|;
name|RegistryRetriever
name|retriever
init|=
operator|new
name|RegistryRetriever
argument_list|(
name|getConfig
argument_list|()
argument_list|,
name|instance
argument_list|)
decl_stmt|;
name|PublishedExportsSet
name|exports
init|=
name|retriever
operator|.
name|getExports
argument_list|(
operator|!
name|registryArgs
operator|.
name|internal
argument_list|)
decl_stmt|;
name|PrintStream
name|out
init|=
literal|null
decl_stmt|;
name|boolean
name|streaming
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|registryArgs
operator|.
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|=
operator|new
name|PrintStream
argument_list|(
name|registryArgs
operator|.
name|out
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
name|streaming
operator|=
literal|true
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Saving output to {}"
argument_list|,
name|registryArgs
operator|.
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|=
name|System
operator|.
name|out
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"Number of exports: {}"
argument_list|,
name|exports
operator|.
name|keys
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|exportName
range|:
name|exports
operator|.
name|keys
argument_list|()
control|)
block|{
if|if
condition|(
name|streaming
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
name|exportName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|registryArgs
operator|.
name|verbose
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
name|exportName
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PublishedExports
name|published
init|=
name|exports
operator|.
name|get
argument_list|(
name|exportName
argument_list|)
decl_stmt|;
name|out
operator|.
name|printf
argument_list|(
literal|"%s: %s%n"
argument_list|,
name|exportName
argument_list|,
name|published
operator|.
name|description
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|streaming
condition|)
block|{
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * list configs available for an instance    *    * @param registryArgs registry Arguments    * @throws YarnException YARN problems    * @throws IOException Network or other problems    * @throws FileNotFoundException if the config is not found    */
annotation|@
name|VisibleForTesting
DECL|method|actionRegistryGetConfig (ActionRegistryArgs registryArgs)
specifier|public
name|PublishedConfiguration
name|actionRegistryGetConfig
parameter_list|(
name|ActionRegistryArgs
name|registryArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
return|return
name|ClientUtils
operator|.
name|getConfigFromRegistry
argument_list|(
name|getRegistryOperations
argument_list|()
argument_list|,
name|getConfig
argument_list|()
argument_list|,
name|registryArgs
operator|.
name|getConf
argument_list|,
name|registryArgs
operator|.
name|name
argument_list|,
name|registryArgs
operator|.
name|user
argument_list|,
operator|!
name|registryArgs
operator|.
name|internal
argument_list|)
return|;
block|}
comment|/**    * get a specific export group    *    * @param registryArgs registry Arguments    *    * @throws YarnException         YARN problems    * @throws IOException           Network or other problems    * @throws FileNotFoundException if the config is not found    */
annotation|@
name|VisibleForTesting
DECL|method|actionRegistryGetExport (ActionRegistryArgs registryArgs)
specifier|public
name|PublishedExports
name|actionRegistryGetExport
parameter_list|(
name|ActionRegistryArgs
name|registryArgs
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|ServiceRecord
name|instance
init|=
name|lookupServiceRecord
argument_list|(
name|registryArgs
argument_list|)
decl_stmt|;
name|RegistryRetriever
name|retriever
init|=
operator|new
name|RegistryRetriever
argument_list|(
name|getConfig
argument_list|()
argument_list|,
name|instance
argument_list|)
decl_stmt|;
name|boolean
name|external
init|=
operator|!
name|registryArgs
operator|.
name|internal
decl_stmt|;
name|PublishedExportsSet
name|exports
init|=
name|retriever
operator|.
name|getExports
argument_list|(
name|external
argument_list|)
decl_stmt|;
name|PublishedExports
name|published
init|=
name|retriever
operator|.
name|retrieveExports
argument_list|(
name|exports
argument_list|,
name|registryArgs
operator|.
name|getExport
argument_list|,
name|external
argument_list|)
decl_stmt|;
return|return
name|published
return|;
block|}
comment|/**    * write out the config. If a destination is provided and that dir is a    * directory, the entry is written to it with the name provided + extension,    * else it is printed to standard out.    * @param published published config    * @param registryArgs registry Arguments    * @throws BadCommandArgumentsException    * @throws IOException    */
DECL|method|outputConfig (PublishedConfiguration published, ActionRegistryArgs registryArgs)
specifier|private
name|void
name|outputConfig
parameter_list|(
name|PublishedConfiguration
name|published
parameter_list|,
name|ActionRegistryArgs
name|registryArgs
parameter_list|)
throws|throws
name|BadCommandArgumentsException
throws|,
name|IOException
block|{
comment|// decide whether or not to print
name|String
name|entry
init|=
name|registryArgs
operator|.
name|getConf
decl_stmt|;
name|String
name|format
init|=
name|registryArgs
operator|.
name|format
decl_stmt|;
name|String
name|output
init|=
name|ClientUtils
operator|.
name|saveOrReturnConfig
argument_list|(
name|published
argument_list|,
name|registryArgs
operator|.
name|format
argument_list|,
name|registryArgs
operator|.
name|out
argument_list|,
name|entry
operator|+
literal|"."
operator|+
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|output
operator|!=
literal|null
condition|)
block|{
name|print
argument_list|(
name|output
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * write out the config    * @param published    * @param registryArgs    * @throws BadCommandArgumentsException    * @throws IOException    */
DECL|method|outputExport (PublishedExports published, ActionRegistryArgs registryArgs)
specifier|private
name|void
name|outputExport
parameter_list|(
name|PublishedExports
name|published
parameter_list|,
name|ActionRegistryArgs
name|registryArgs
parameter_list|)
throws|throws
name|BadCommandArgumentsException
throws|,
name|IOException
block|{
comment|// decide whether or not to print
name|String
name|entry
init|=
name|registryArgs
operator|.
name|getExport
decl_stmt|;
name|String
name|format
init|=
name|ConfigFormat
operator|.
name|JSON
operator|.
name|toString
argument_list|()
decl_stmt|;
name|ConfigFormat
name|configFormat
init|=
name|ConfigFormat
operator|.
name|resolve
argument_list|(
name|format
argument_list|)
decl_stmt|;
if|if
condition|(
name|configFormat
operator|==
literal|null
operator|||
name|configFormat
operator|!=
name|ConfigFormat
operator|.
name|JSON
condition|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
literal|"Unknown/Unsupported format %s . Only JSON is supported."
argument_list|,
name|format
argument_list|)
throw|;
block|}
name|PublishedExportsOutputter
name|outputter
init|=
name|PublishedExportsOutputter
operator|.
name|createOutputter
argument_list|(
name|configFormat
argument_list|,
name|published
argument_list|)
decl_stmt|;
name|boolean
name|print
init|=
name|registryArgs
operator|.
name|out
operator|==
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|print
condition|)
block|{
name|File
name|destFile
decl_stmt|;
name|destFile
operator|=
name|registryArgs
operator|.
name|out
expr_stmt|;
if|if
condition|(
name|destFile
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
comment|// creating it under a directory
name|destFile
operator|=
operator|new
name|File
argument_list|(
name|destFile
argument_list|,
name|entry
operator|+
literal|"."
operator|+
name|format
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Destination path: {}"
argument_list|,
name|destFile
argument_list|)
expr_stmt|;
name|outputter
operator|.
name|save
argument_list|(
name|destFile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print
argument_list|(
name|outputter
operator|.
name|asString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Look up an instance    * @return instance data    * @throws SliderException other failures    * @throws IOException IO problems or wrapped exceptions    */
DECL|method|lookupServiceRecord (ActionRegistryArgs registryArgs)
specifier|private
name|ServiceRecord
name|lookupServiceRecord
parameter_list|(
name|ActionRegistryArgs
name|registryArgs
parameter_list|)
throws|throws
name|SliderException
throws|,
name|IOException
block|{
return|return
name|ClientUtils
operator|.
name|lookupServiceRecord
argument_list|(
name|getRegistryOperations
argument_list|()
argument_list|,
name|registryArgs
operator|.
name|user
argument_list|,
name|registryArgs
operator|.
name|serviceType
argument_list|,
name|registryArgs
operator|.
name|name
argument_list|)
return|;
block|}
comment|/**    *     * Look up an instance    * @param path path    * @return instance data    * @throws NotFoundException no path/no service record    * at the end of the path    * @throws SliderException other failures    * @throws IOException IO problems or wrapped exceptions    */
DECL|method|resolve (String path)
specifier|public
name|ServiceRecord
name|resolve
parameter_list|(
name|String
name|path
parameter_list|)
throws|throws
name|IOException
throws|,
name|SliderException
block|{
return|return
name|ClientUtils
operator|.
name|resolve
argument_list|(
name|getRegistryOperations
argument_list|()
argument_list|,
name|path
argument_list|)
return|;
block|}
comment|/**    * List instances in the registry for the current user    * @return a list of slider registry instances    * @throws IOException Any IO problem ... including no path in the registry    * to slider service classes for this user    * @throws SliderException other failures    */
DECL|method|listRegistryInstances ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|ServiceRecord
argument_list|>
name|listRegistryInstances
parameter_list|()
throws|throws
name|IOException
throws|,
name|SliderException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|ServiceRecord
argument_list|>
name|recordMap
init|=
name|listServiceRecords
argument_list|(
name|getRegistryOperations
argument_list|()
argument_list|,
name|serviceclassPath
argument_list|(
name|currentUser
argument_list|()
argument_list|,
name|SliderKeys
operator|.
name|APP_TYPE
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|recordMap
return|;
block|}
comment|/**    * List instances in the registry    * @return the instance IDs    * @throws IOException    * @throws YarnException    */
DECL|method|listRegisteredSliderInstances ()
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|listRegisteredSliderInstances
parameter_list|()
throws|throws
name|IOException
throws|,
name|YarnException
block|{
try|try
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|ServiceRecord
argument_list|>
name|recordMap
init|=
name|listServiceRecords
argument_list|(
name|getRegistryOperations
argument_list|()
argument_list|,
name|serviceclassPath
argument_list|(
name|currentUser
argument_list|()
argument_list|,
name|SliderKeys
operator|.
name|APP_TYPE
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|recordMap
operator|.
name|keySet
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|PathNotFoundException
name|e
parameter_list|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"No registry path for slider instances for current user: {}"
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// no entries: return an empty list
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|0
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|YarnException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Start the registry if it is not there yet    * @return the registry service    * @throws SliderException    * @throws IOException    */
DECL|method|maybeStartYarnRegistry ()
specifier|private
specifier|synchronized
name|RegistryOperations
name|maybeStartYarnRegistry
parameter_list|()
throws|throws
name|SliderException
throws|,
name|IOException
block|{
if|if
condition|(
name|registryOperations
operator|==
literal|null
condition|)
block|{
name|registryOperations
operator|=
name|startRegistryOperationsService
argument_list|()
expr_stmt|;
block|}
return|return
name|registryOperations
return|;
block|}
annotation|@
name|Override
DECL|method|getRegistryOperations ()
specifier|public
name|RegistryOperations
name|getRegistryOperations
parameter_list|()
throws|throws
name|SliderException
throws|,
name|IOException
block|{
return|return
name|maybeStartYarnRegistry
argument_list|()
return|;
block|}
comment|/**    * Output to standard out/stderr (implementation specific detail)    * @param src source    */
DECL|method|print (CharSequence src)
specifier|private
specifier|static
name|void
name|print
parameter_list|(
name|CharSequence
name|src
parameter_list|)
block|{
name|clientOutputStream
operator|.
name|print
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
comment|/**    * Output to standard out/stderr with a newline after    * @param message message    */
DECL|method|println (String message)
specifier|private
specifier|static
name|void
name|println
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|clientOutputStream
operator|.
name|println
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
comment|/**    * Output to standard out/stderr with a newline after, formatted    * @param message message    * @param args arguments for string formatting    */
DECL|method|println (String message, Object ... args)
specifier|private
specifier|static
name|void
name|println
parameter_list|(
name|String
name|message
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
block|{
name|clientOutputStream
operator|.
name|println
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|message
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Implement the lookup action.    * @param args Action arguments    * @return 0 if the entry was found    * @throws IOException    * @throws YarnException    * @throws UnknownApplicationInstanceException if a specific instance    * was named but it was not found    */
annotation|@
name|VisibleForTesting
DECL|method|actionLookup (ActionLookupArgs args)
specifier|public
name|int
name|actionLookup
parameter_list|(
name|ActionLookupArgs
name|args
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
try|try
block|{
name|ApplicationId
name|id
init|=
name|ConverterUtils
operator|.
name|toApplicationId
argument_list|(
name|args
operator|.
name|id
argument_list|)
decl_stmt|;
name|ApplicationReport
name|report
init|=
name|yarnClient
operator|.
name|getApplicationReport
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|SerializedApplicationReport
name|sar
init|=
operator|new
name|SerializedApplicationReport
argument_list|(
name|report
argument_list|)
decl_stmt|;
name|ApplicationReportSerDeser
name|serDeser
init|=
operator|new
name|ApplicationReportSerDeser
argument_list|()
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|outputFile
operator|!=
literal|null
condition|)
block|{
name|serDeser
operator|.
name|save
argument_list|(
name|sar
argument_list|,
name|args
operator|.
name|outputFile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|println
argument_list|(
name|serDeser
operator|.
name|toJson
argument_list|(
name|sar
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|BadCommandArgumentsException
argument_list|(
name|e
argument_list|,
literal|"%s : %s"
argument_list|,
name|args
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|ApplicationAttemptNotFoundException
decl||
name|ApplicationNotFoundException
name|notFound
parameter_list|)
block|{
throw|throw
operator|new
name|NotFoundException
argument_list|(
name|notFound
argument_list|,
name|notFound
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
annotation|@
name|Override
DECL|method|actionDependency (ActionDependencyArgs args)
specifier|public
name|int
name|actionDependency
parameter_list|(
name|ActionDependencyArgs
name|args
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
name|String
name|currentUser
init|=
name|getUsername
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Running command as user {}"
argument_list|,
name|currentUser
argument_list|)
expr_stmt|;
name|String
name|version
init|=
name|getSliderVersion
argument_list|()
decl_stmt|;
name|Path
name|dependencyLibTarGzip
init|=
name|sliderFileSystem
operator|.
name|getDependencyTarGzip
argument_list|()
decl_stmt|;
comment|// Check if dependency has already been uploaded, in which case log
comment|// appropriately and exit success (unless overwrite has been requested)
if|if
condition|(
name|sliderFileSystem
operator|.
name|isFile
argument_list|(
name|dependencyLibTarGzip
argument_list|)
operator|&&
operator|!
name|args
operator|.
name|overwrite
condition|)
block|{
name|println
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Dependency libs are already uploaded to %s. Use %s "
operator|+
literal|"if you want to re-upload"
argument_list|,
name|dependencyLibTarGzip
operator|.
name|toUri
argument_list|()
argument_list|,
name|Arguments
operator|.
name|ARG_OVERWRITE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
name|String
index|[]
name|libDirs
init|=
name|SliderUtils
operator|.
name|getLibDirs
argument_list|()
decl_stmt|;
if|if
condition|(
name|libDirs
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|File
name|tempLibTarGzipFile
init|=
name|File
operator|.
name|createTempFile
argument_list|(
name|SliderKeys
operator|.
name|SLIDER_DEPENDENCY_TAR_GZ_FILE_NAME
operator|+
literal|"_"
argument_list|,
name|SliderKeys
operator|.
name|SLIDER_DEPENDENCY_TAR_GZ_FILE_EXT
argument_list|)
decl_stmt|;
comment|// copy all jars
name|tarGzipFolder
argument_list|(
name|libDirs
argument_list|,
name|tempLibTarGzipFile
argument_list|,
name|createJarFilter
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Uploading dependency for AM (version {}) from {} to {}"
argument_list|,
name|version
argument_list|,
name|tempLibTarGzipFile
operator|.
name|toURI
argument_list|()
argument_list|,
name|dependencyLibTarGzip
operator|.
name|toUri
argument_list|()
argument_list|)
expr_stmt|;
name|sliderFileSystem
operator|.
name|copyLocalFileToHdfs
argument_list|(
name|tempLibTarGzipFile
argument_list|,
name|dependencyLibTarGzip
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|SliderKeys
operator|.
name|SLIDER_DEPENDENCY_DIR_PERMISSIONS
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
else|else
block|{
return|return
name|EXIT_FALSE
return|;
block|}
block|}
DECL|method|actionHelp (String actionName)
specifier|private
name|int
name|actionHelp
parameter_list|(
name|String
name|actionName
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
throw|throw
operator|new
name|UsageException
argument_list|(
name|CommonArgs
operator|.
name|usage
argument_list|(
name|serviceArgs
argument_list|,
name|actionName
argument_list|)
argument_list|)
throw|;
block|}
comment|/**    * List the nodes in the cluster, possibly filtering by node state or label.    *    * @param args argument list    * @return a possibly empty list of nodes in the cluster    * @throws IOException IO problems    * @throws YarnException YARN problems    */
annotation|@
name|Override
DECL|method|listYarnClusterNodes (ActionNodesArgs args)
specifier|public
name|NodeInformationList
name|listYarnClusterNodes
parameter_list|(
name|ActionNodesArgs
name|args
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
return|return
name|yarnClient
operator|.
name|listNodes
argument_list|(
name|args
operator|.
name|label
argument_list|,
name|args
operator|.
name|healthy
argument_list|)
return|;
block|}
comment|/**    * List the nodes in the cluster, possibly filtering by node state or label.    *    * @param args argument list    * @return a possibly empty list of nodes in the cluster    * @throws IOException IO problems    * @throws YarnException YARN problems    */
DECL|method|listInstanceNodes (String instance, ActionNodesArgs args)
specifier|public
name|NodeInformationList
name|listInstanceNodes
parameter_list|(
name|String
name|instance
parameter_list|,
name|ActionNodesArgs
name|args
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
comment|// TODO
name|log
operator|.
name|info
argument_list|(
literal|"listInstanceNodes {}"
argument_list|,
name|instance
argument_list|)
expr_stmt|;
name|SliderClusterOperations
name|clusterOps
init|=
operator|new
name|SliderClusterOperations
argument_list|(
name|bondToCluster
argument_list|(
name|instance
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|clusterOps
operator|.
name|getLiveNodes
argument_list|()
return|;
block|}
comment|/**    * List the nodes in the cluster, possibly filtering by node state or label.    * Prints them to stdout unless the args names a file instead.    * @param args argument list    * @throws IOException IO problems    * @throws YarnException YARN problems    */
DECL|method|actionNodes (String instance, ActionNodesArgs args)
specifier|public
name|int
name|actionNodes
parameter_list|(
name|String
name|instance
parameter_list|,
name|ActionNodesArgs
name|args
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
name|args
operator|.
name|instance
operator|=
name|instance
expr_stmt|;
name|NodeInformationList
name|nodes
decl_stmt|;
if|if
condition|(
name|SliderUtils
operator|.
name|isUnset
argument_list|(
name|instance
argument_list|)
condition|)
block|{
name|nodes
operator|=
name|listYarnClusterNodes
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodes
operator|=
name|listInstanceNodes
argument_list|(
name|instance
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"Node listing for {} has {} nodes"
argument_list|,
name|args
argument_list|,
name|nodes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|JsonSerDeser
argument_list|<
name|NodeInformationList
argument_list|>
name|serDeser
init|=
name|NodeInformationList
operator|.
name|createSerializer
argument_list|()
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|outputFile
operator|!=
literal|null
condition|)
block|{
name|serDeser
operator|.
name|save
argument_list|(
name|nodes
argument_list|,
name|args
operator|.
name|outputFile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|println
argument_list|(
name|serDeser
operator|.
name|toJson
argument_list|(
name|nodes
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/**    * Save/list tokens. This is for testing oozie integration    * @param args commands    * @return status    */
DECL|method|actionTokens (ActionTokensArgs args)
specifier|private
name|int
name|actionTokens
parameter_list|(
name|ActionTokensArgs
name|args
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
return|return
operator|new
name|TokensOperation
argument_list|()
operator|.
name|actionTokens
argument_list|(
name|args
argument_list|,
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|getConfig
argument_list|()
argument_list|,
name|yarnClient
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|monitorAppToRunning (Duration duration)
specifier|public
name|ApplicationReport
name|monitorAppToRunning
parameter_list|(
name|Duration
name|duration
parameter_list|)
throws|throws
name|YarnException
throws|,
name|IOException
block|{
return|return
name|yarnClient
operator|.
name|monitorAppToState
argument_list|(
name|applicationId
argument_list|,
name|YarnApplicationState
operator|.
name|RUNNING
argument_list|,
name|duration
argument_list|)
return|;
block|}
block|}
end_class

end_unit

