begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.slider.core.conf
package|package
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|conf
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|SliderUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|BadConfigException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * Standard map operations.  *  * This delegates the standard map interface to the map passed in,  * so it can be used to add more actions to the map.  */
end_comment

begin_class
DECL|class|MapOperations
specifier|public
class|class
name|MapOperations
implements|implements
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
block|{
DECL|field|log
specifier|private
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|MapOperations
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DAYS
specifier|public
specifier|static
specifier|final
name|String
name|DAYS
init|=
literal|".days"
decl_stmt|;
DECL|field|HOURS
specifier|public
specifier|static
specifier|final
name|String
name|HOURS
init|=
literal|".hours"
decl_stmt|;
DECL|field|MINUTES
specifier|public
specifier|static
specifier|final
name|String
name|MINUTES
init|=
literal|".minutes"
decl_stmt|;
DECL|field|SECONDS
specifier|public
specifier|static
specifier|final
name|String
name|SECONDS
init|=
literal|".seconds"
decl_stmt|;
comment|/**    * Global options    */
DECL|field|options
specifier|public
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|options
decl_stmt|;
DECL|field|name
specifier|public
specifier|final
name|String
name|name
decl_stmt|;
DECL|method|MapOperations ()
specifier|public
name|MapOperations
parameter_list|()
block|{
name|options
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|name
operator|=
literal|""
expr_stmt|;
block|}
comment|/**    * Create an instance    * @param name name    * @param options source of options    */
DECL|method|MapOperations (String name, Map<String, String> options)
specifier|public
name|MapOperations
parameter_list|(
name|String
name|name
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|options
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|options
operator|!=
literal|null
argument_list|,
literal|"null map"
argument_list|)
expr_stmt|;
name|this
operator|.
name|options
operator|=
name|options
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
comment|/**    * Create an instance from an iterative map entry    * @param entry entry to work with    */
DECL|method|MapOperations (Map.Entry<String, Map<String, String>> entry)
specifier|public
name|MapOperations
parameter_list|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|entry
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|entry
operator|!=
literal|null
argument_list|,
literal|"null entry"
argument_list|)
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|entry
operator|.
name|getKey
argument_list|()
expr_stmt|;
name|this
operator|.
name|options
operator|=
name|entry
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
comment|/**    * Get an option value    *    * @param key key    * @param defVal default value    * @return option in map or the default    */
DECL|method|getOption (String key, String defVal)
specifier|public
name|String
name|getOption
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|defVal
parameter_list|)
block|{
name|String
name|val
init|=
name|options
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|val
operator|!=
literal|null
condition|?
name|val
else|:
name|defVal
return|;
block|}
comment|/**    * Get a boolean option    *    * @param key option key    * @param defVal default value    * @return option true if the option equals "true", or the default value    * if the option was not defined at all.    */
DECL|method|getOptionBool (String key, boolean defVal)
specifier|public
name|Boolean
name|getOptionBool
parameter_list|(
name|String
name|key
parameter_list|,
name|boolean
name|defVal
parameter_list|)
block|{
name|String
name|val
init|=
name|getOption
argument_list|(
name|key
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|defVal
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|/**    * Get a cluster option or value    *    * @param key option key    * @return the value    * @throws BadConfigException if the option is missing    */
DECL|method|getMandatoryOption (String key)
specifier|public
name|String
name|getMandatoryOption
parameter_list|(
name|String
name|key
parameter_list|)
throws|throws
name|BadConfigException
block|{
name|String
name|val
init|=
name|options
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Missing key {} from config containing {}"
argument_list|,
name|key
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|String
name|text
init|=
literal|"Missing option "
operator|+
name|key
decl_stmt|;
if|if
condition|(
name|SliderUtils
operator|.
name|isSet
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|text
operator|+=
literal|" from set "
operator|+
name|name
expr_stmt|;
block|}
throw|throw
operator|new
name|BadConfigException
argument_list|(
name|text
argument_list|)
throw|;
block|}
return|return
name|val
return|;
block|}
comment|/**    * Get an integer option; use {@link Integer#decode(String)} so as to take hex    * oct and bin values too.    *    * @param option option name    * @param defVal default value    * @return parsed value    * @throws NumberFormatException if the role could not be parsed.    */
DECL|method|getOptionInt (String option, int defVal)
specifier|public
name|int
name|getOptionInt
parameter_list|(
name|String
name|option
parameter_list|,
name|int
name|defVal
parameter_list|)
block|{
name|String
name|val
init|=
name|getOption
argument_list|(
name|option
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|defVal
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|Integer
operator|.
name|decode
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|/**    * Get a long option; use {@link Long#decode(String)} so as to take hex    * oct and bin values too.    *    * @param option option name    * @param defVal default value    * @return parsed value    * @throws NumberFormatException    */
DECL|method|getOptionLong (String option, long defVal)
specifier|public
name|long
name|getOptionLong
parameter_list|(
name|String
name|option
parameter_list|,
name|long
name|defVal
parameter_list|)
block|{
name|String
name|val
init|=
name|getOption
argument_list|(
name|option
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|defVal
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|Long
operator|.
name|decode
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|/**    * Get a mandatory integer option; use {@link Integer#decode(String)} so as to take hex    * oct and bin values too.    *    * @param option option name    * @return parsed value    * @throws NumberFormatException if the option could not be parsed.    * @throws BadConfigException if the option could not be found    */
DECL|method|getMandatoryOptionInt (String option)
specifier|public
name|int
name|getMandatoryOptionInt
parameter_list|(
name|String
name|option
parameter_list|)
throws|throws
name|BadConfigException
block|{
name|getMandatoryOption
argument_list|(
name|option
argument_list|)
expr_stmt|;
return|return
name|getOptionInt
argument_list|(
name|option
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Verify that an option is set: that is defined AND non-empty    * @param key    * @throws BadConfigException    */
DECL|method|verifyOptionSet (String key)
specifier|public
name|void
name|verifyOptionSet
parameter_list|(
name|String
name|key
parameter_list|)
throws|throws
name|BadConfigException
block|{
if|if
condition|(
name|SliderUtils
operator|.
name|isUnset
argument_list|(
name|getOption
argument_list|(
name|key
argument_list|,
literal|null
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BadConfigException
argument_list|(
literal|"Unset option %s"
argument_list|,
name|key
argument_list|)
throw|;
block|}
block|}
DECL|method|mergeWithoutOverwrite (Map<String, String> that)
specifier|public
name|void
name|mergeWithoutOverwrite
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|that
parameter_list|)
block|{
name|SliderUtils
operator|.
name|mergeMapsIgnoreDuplicateKeys
argument_list|(
name|options
argument_list|,
name|that
argument_list|)
expr_stmt|;
block|}
comment|/**    * Merge a map by prefixed keys    * @param that the map to merge in    * @param prefix prefix to match on    * @param overwrite flag to enable overwrite    */
DECL|method|mergeMapPrefixedKeys (Map<String, String> that, String prefix, boolean overwrite)
specifier|public
name|void
name|mergeMapPrefixedKeys
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|that
parameter_list|,
name|String
name|prefix
parameter_list|,
name|boolean
name|overwrite
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|that
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
if|if
condition|(
name|overwrite
operator|||
name|get
argument_list|(
name|key
argument_list|)
operator|==
literal|null
condition|)
block|{
name|put
argument_list|(
name|key
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Set a property if it is not already set    * @param key key    * @param value value    */
DECL|method|putIfUnset (String key, String value)
specifier|public
name|void
name|putIfUnset
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|value
parameter_list|)
block|{
if|if
condition|(
name|get
argument_list|(
name|key
argument_list|)
operator|==
literal|null
condition|)
block|{
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|set (String key, Object value)
specifier|public
name|void
name|set
parameter_list|(
name|String
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
assert|assert
name|value
operator|!=
literal|null
assert|;
name|put
argument_list|(
name|key
argument_list|,
name|value
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|options
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|isEmpty ()
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|options
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|containsValue (Object value)
specifier|public
name|boolean
name|containsValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
return|return
name|options
operator|.
name|containsValue
argument_list|(
name|value
argument_list|)
return|;
block|}
DECL|method|containsKey (Object key)
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|options
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|get (Object key)
specifier|public
name|String
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|options
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|put (String key, String value)
specifier|public
name|String
name|put
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|value
parameter_list|)
block|{
return|return
name|options
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|remove (Object key)
specifier|public
name|String
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|options
operator|.
name|remove
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|putAll (Map<? extends String, ? extends String> m)
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|String
argument_list|,
name|?
extends|extends
name|String
argument_list|>
name|m
parameter_list|)
block|{
name|options
operator|.
name|putAll
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|options
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|keySet ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
name|options
operator|.
name|keySet
argument_list|()
return|;
block|}
DECL|method|values ()
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|values
parameter_list|()
block|{
return|return
name|options
operator|.
name|values
argument_list|()
return|;
block|}
DECL|method|entrySet ()
specifier|public
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
return|return
name|options
operator|.
name|entrySet
argument_list|()
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"EqualsWhichDoesntCheckParameterClass"
argument_list|)
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|options
operator|.
name|equals
argument_list|(
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|options
operator|.
name|hashCode
argument_list|()
return|;
block|}
DECL|method|isSet (String key)
specifier|public
name|boolean
name|isSet
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
name|SliderUtils
operator|.
name|isSet
argument_list|(
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|name
argument_list|)
operator|.
name|append
argument_list|(
literal|"=\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|options
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"  "
argument_list|)
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'='
argument_list|)
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Get the time range of a set of keys    * @param basekey base key to which suffix gets applied    * @param defDays    * @param defHours    * @param defMins    * @param defSecs    * @return the aggregate time range in seconds    */
DECL|method|getTimeRange (String basekey, int defDays, int defHours, int defMins, int defSecs)
specifier|public
name|long
name|getTimeRange
parameter_list|(
name|String
name|basekey
parameter_list|,
name|int
name|defDays
parameter_list|,
name|int
name|defHours
parameter_list|,
name|int
name|defMins
parameter_list|,
name|int
name|defSecs
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|basekey
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|int
name|days
init|=
name|getOptionInt
argument_list|(
name|basekey
operator|+
name|DAYS
argument_list|,
name|defDays
argument_list|)
decl_stmt|;
name|int
name|hours
init|=
name|getOptionInt
argument_list|(
name|basekey
operator|+
name|HOURS
argument_list|,
name|defHours
argument_list|)
decl_stmt|;
name|int
name|minutes
init|=
name|getOptionInt
argument_list|(
name|basekey
operator|+
name|MINUTES
argument_list|,
name|defMins
argument_list|)
decl_stmt|;
name|int
name|seconds
init|=
name|getOptionInt
argument_list|(
name|basekey
operator|+
name|SECONDS
argument_list|,
name|defSecs
argument_list|)
decl_stmt|;
comment|// range check
name|Preconditions
operator|.
name|checkState
argument_list|(
name|days
operator|>=
literal|0
operator|&&
name|hours
operator|>=
literal|0
operator|&&
name|minutes
operator|>=
literal|0
operator|&&
name|seconds
operator|>=
literal|0
argument_list|,
literal|"Time range for %s has negative time component %s:%s:%s:%s"
argument_list|,
name|basekey
argument_list|,
name|days
argument_list|,
name|hours
argument_list|,
name|minutes
argument_list|,
name|seconds
argument_list|)
expr_stmt|;
comment|// calculate total time, schedule the reset if expected
name|long
name|totalMinutes
init|=
operator|(
name|long
operator|)
name|days
operator|*
literal|24
operator|*
literal|60
operator|+
operator|(
name|long
operator|)
name|hours
operator|*
literal|24
operator|+
name|minutes
decl_stmt|;
return|return
name|totalMinutes
operator|*
literal|60
operator|+
name|seconds
return|;
block|}
comment|/**    * Get all entries with a specific prefix    * @param prefix prefix    * @return a prefixed map, possibly empty    */
DECL|method|prefixedWith (String prefix)
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|prefixedWith
parameter_list|(
name|String
name|prefix
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|prefixed
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
name|prefixed
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|prefixed
return|;
block|}
block|}
end_class

end_unit

