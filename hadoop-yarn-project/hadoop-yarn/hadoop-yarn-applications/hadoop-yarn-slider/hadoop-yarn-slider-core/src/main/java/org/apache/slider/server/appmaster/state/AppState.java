begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.slider.server.appmaster.state
package|package
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|state
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheLoader
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|LoadingCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|MutableGaugeInt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Container
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|FinalApplicationStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|NodeId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|NodeReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|client
operator|.
name|api
operator|.
name|AMRMClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnRuntimeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|resource
operator|.
name|Resources
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|ClusterNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|InternalKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|ServiceApiConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|StatusKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|proto
operator|.
name|Messages
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|proto
operator|.
name|Messages
operator|.
name|ComponentCountProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|resource
operator|.
name|Application
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|resource
operator|.
name|ApplicationState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|resource
operator|.
name|Component
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|resource
operator|.
name|ConfigFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|types
operator|.
name|ApplicationLivenessInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|types
operator|.
name|ComponentInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|types
operator|.
name|RoleStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|service
operator|.
name|conf
operator|.
name|SliderExitCodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|service
operator|.
name|conf
operator|.
name|SliderKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|SliderUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|BadClusterStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|BadConfigException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|ErrorStrings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|NoSuchNodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|SliderInternalStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|TriggerClusterTeardownException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|zk
operator|.
name|ZKIntegration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|providers
operator|.
name|PlacementPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|providers
operator|.
name|ProviderRole
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|management
operator|.
name|MetricsAndMonitoring
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|management
operator|.
name|MetricsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|service
operator|.
name|metrics
operator|.
name|ServiceMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|operations
operator|.
name|AbstractRMOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|operations
operator|.
name|ContainerReleaseOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|operations
operator|.
name|ContainerRequestOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|operations
operator|.
name|UpdateBlacklistOperation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|service
operator|.
name|timelineservice
operator|.
name|ServiceTimelinePublisher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|service
operator|.
name|utils
operator|.
name|ServiceApiUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
operator|.
name|FS_DEFAULT_NAME_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|api
operator|.
name|RegistryConstants
operator|.
name|DEFAULT_REGISTRY_ZK_QUORUM
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|api
operator|.
name|RegistryConstants
operator|.
name|KEY_DNS_DOMAIN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|api
operator|.
name|RegistryConstants
operator|.
name|KEY_REGISTRY_ZK_QUORUM
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|ResourceKeys
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|ServiceApiConstants
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|StateValues
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|resource
operator|.
name|ApplicationState
operator|.
name|STARTED
import|;
end_import

begin_comment
comment|/**  * The model of all the ongoing state of a Slider AM.  *  * concurrency rules: any method which begins with<i>build</i>  * is not synchronized and intended to be used during  * initialization.  */
end_comment

begin_class
DECL|class|AppState
specifier|public
class|class
name|AppState
block|{
DECL|field|log
specifier|protected
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|AppState
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|recordFactory
specifier|private
specifier|final
name|AbstractClusterServices
name|recordFactory
decl_stmt|;
DECL|field|metricsAndMonitoring
specifier|private
specifier|final
name|MetricsAndMonitoring
name|metricsAndMonitoring
decl_stmt|;
comment|/**    * Flag set to indicate the application is live -this only happens    * after the buildInstance operation    */
DECL|field|applicationLive
specifier|private
name|boolean
name|applicationLive
init|=
literal|false
decl_stmt|;
DECL|field|app
specifier|private
name|Application
name|app
decl_stmt|;
comment|// priority_id -> RoleStatus
DECL|field|roleStatusMap
specifier|private
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|RoleStatus
argument_list|>
name|roleStatusMap
init|=
operator|new
name|ConcurrentSkipListMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// component_name -> ProviderRole
DECL|field|roles
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|ProviderRole
argument_list|>
name|roles
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|rolePriorityMap
specifier|private
specifier|final
name|ConcurrentSkipListMap
argument_list|<
name|Integer
argument_list|,
name|ProviderRole
argument_list|>
name|rolePriorityMap
init|=
operator|new
name|ConcurrentSkipListMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Hash map of the containers we have. This includes things that have    * been allocated but are not live; it is a superset of the live list    */
DECL|field|ownedContainers
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|ContainerId
argument_list|,
name|RoleInstance
argument_list|>
name|ownedContainers
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Hash map of the containers we have released, but we    * are still awaiting acknowledgements on. Any failure of these    * containers is treated as a successful outcome    */
DECL|field|containersBeingReleased
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|ContainerId
argument_list|,
name|Container
argument_list|>
name|containersBeingReleased
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Map of requested nodes. This records the command used to start it,    * resources, etc. When container started callback is received,    * the node is promoted from here to the containerMap    */
DECL|field|startingContainers
specifier|private
specifier|final
name|Map
argument_list|<
name|ContainerId
argument_list|,
name|RoleInstance
argument_list|>
name|startingContainers
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * List of completed nodes. This isn't kept in the CD as it gets too    * big for the RPC responses. Indeed, we should think about how deep to get this    */
DECL|field|completedContainers
specifier|private
specifier|final
name|Map
argument_list|<
name|ContainerId
argument_list|,
name|RoleInstance
argument_list|>
name|completedContainers
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Nodes that failed to start.    * Again, kept out of the CD    */
DECL|field|failedContainers
specifier|private
specifier|final
name|Map
argument_list|<
name|ContainerId
argument_list|,
name|RoleInstance
argument_list|>
name|failedContainers
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Nodes that came assigned to a role above that    * which were asked for -this appears to happen    */
DECL|field|surplusContainers
specifier|private
specifier|final
name|Set
argument_list|<
name|ContainerId
argument_list|>
name|surplusContainers
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Map of containerID to cluster nodes, for status reports.    * Access to this should be synchronized on the clusterDescription    */
DECL|field|liveNodes
specifier|private
specifier|final
name|Map
argument_list|<
name|ContainerId
argument_list|,
name|RoleInstance
argument_list|>
name|liveNodes
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|completionOfNodeNotInLiveListEvent
specifier|private
specifier|final
name|AtomicInteger
name|completionOfNodeNotInLiveListEvent
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|field|completionOfUnknownContainerEvent
specifier|private
specifier|final
name|AtomicInteger
name|completionOfUnknownContainerEvent
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|/**    * limits of container core numbers in this queue    */
DECL|field|containerMaxCores
specifier|private
name|int
name|containerMaxCores
decl_stmt|;
DECL|field|containerMinCores
specifier|private
name|int
name|containerMinCores
decl_stmt|;
comment|/**    * limits of container memory in this queue    */
DECL|field|containerMaxMemory
specifier|private
name|int
name|containerMaxMemory
decl_stmt|;
DECL|field|containerMinMemory
specifier|private
name|int
name|containerMinMemory
decl_stmt|;
DECL|field|roleHistory
specifier|private
name|RoleHistory
name|roleHistory
decl_stmt|;
DECL|field|startTimeThreshold
specifier|private
name|long
name|startTimeThreshold
decl_stmt|;
DECL|field|failureThreshold
specifier|private
name|int
name|failureThreshold
init|=
literal|10
decl_stmt|;
DECL|field|nodeFailureThreshold
specifier|private
name|int
name|nodeFailureThreshold
init|=
literal|3
decl_stmt|;
DECL|field|logServerURL
specifier|private
name|String
name|logServerURL
init|=
literal|""
decl_stmt|;
DECL|field|globalTokens
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|globalTokens
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Selector of containers to release; application wide.    */
DECL|field|containerReleaseSelector
specifier|private
name|ContainerReleaseSelector
name|containerReleaseSelector
decl_stmt|;
DECL|field|minResource
specifier|private
name|Resource
name|minResource
decl_stmt|;
DECL|field|maxResource
specifier|private
name|Resource
name|maxResource
decl_stmt|;
DECL|field|appMetrics
specifier|private
name|ServiceMetrics
name|appMetrics
decl_stmt|;
DECL|field|serviceTimelinePublisher
specifier|private
name|ServiceTimelinePublisher
name|serviceTimelinePublisher
decl_stmt|;
comment|// A cache for loading config files from remote such as hdfs
DECL|field|configFileCache
specifier|public
name|LoadingCache
argument_list|<
name|ConfigFile
argument_list|,
name|Object
argument_list|>
name|configFileCache
init|=
literal|null
decl_stmt|;
comment|/**    * Create an instance    * @param recordFactory factory for YARN records    * @param metricsAndMonitoring metrics and monitoring services    */
DECL|method|AppState (AbstractClusterServices recordFactory, MetricsAndMonitoring metricsAndMonitoring)
specifier|public
name|AppState
parameter_list|(
name|AbstractClusterServices
name|recordFactory
parameter_list|,
name|MetricsAndMonitoring
name|metricsAndMonitoring
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|recordFactory
operator|!=
literal|null
argument_list|,
literal|"null recordFactory"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|metricsAndMonitoring
operator|!=
literal|null
argument_list|,
literal|"null metricsAndMonitoring"
argument_list|)
expr_stmt|;
name|this
operator|.
name|recordFactory
operator|=
name|recordFactory
expr_stmt|;
name|this
operator|.
name|metricsAndMonitoring
operator|=
name|metricsAndMonitoring
expr_stmt|;
block|}
DECL|method|getRoleStatusMap ()
specifier|public
name|Map
argument_list|<
name|Integer
argument_list|,
name|RoleStatus
argument_list|>
name|getRoleStatusMap
parameter_list|()
block|{
return|return
name|roleStatusMap
return|;
block|}
DECL|method|getRoleMap ()
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|ProviderRole
argument_list|>
name|getRoleMap
parameter_list|()
block|{
return|return
name|roles
return|;
block|}
DECL|method|getRolePriorityMap ()
specifier|public
name|Map
argument_list|<
name|Integer
argument_list|,
name|ProviderRole
argument_list|>
name|getRolePriorityMap
parameter_list|()
block|{
return|return
name|rolePriorityMap
return|;
block|}
DECL|method|getStartingContainers ()
specifier|private
name|Map
argument_list|<
name|ContainerId
argument_list|,
name|RoleInstance
argument_list|>
name|getStartingContainers
parameter_list|()
block|{
return|return
name|startingContainers
return|;
block|}
DECL|method|getCompletedContainers ()
specifier|private
name|Map
argument_list|<
name|ContainerId
argument_list|,
name|RoleInstance
argument_list|>
name|getCompletedContainers
parameter_list|()
block|{
return|return
name|completedContainers
return|;
block|}
DECL|method|getFailedContainers ()
specifier|public
name|Map
argument_list|<
name|ContainerId
argument_list|,
name|RoleInstance
argument_list|>
name|getFailedContainers
parameter_list|()
block|{
return|return
name|failedContainers
return|;
block|}
DECL|method|getLiveContainers ()
specifier|public
name|Map
argument_list|<
name|ContainerId
argument_list|,
name|RoleInstance
argument_list|>
name|getLiveContainers
parameter_list|()
block|{
return|return
name|liveNodes
return|;
block|}
comment|/**    * Get the current view of the cluster status.    * This is read-only    * to the extent that changes here do not trigger updates in the    * application state.     * @return the cluster status    */
DECL|method|getClusterStatus ()
specifier|public
specifier|synchronized
name|Application
name|getClusterStatus
parameter_list|()
block|{
return|return
name|app
return|;
block|}
comment|/**    * Get the role history of the application    * @return the role history    */
annotation|@
name|VisibleForTesting
DECL|method|getRoleHistory ()
specifier|public
name|RoleHistory
name|getRoleHistory
parameter_list|()
block|{
return|return
name|roleHistory
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setRoleHistory (RoleHistory roleHistory)
specifier|public
name|void
name|setRoleHistory
parameter_list|(
name|RoleHistory
name|roleHistory
parameter_list|)
block|{
name|this
operator|.
name|roleHistory
operator|=
name|roleHistory
expr_stmt|;
block|}
comment|/**    * Get the path used for history files    * @return the directory used for history files    */
annotation|@
name|VisibleForTesting
DECL|method|getHistoryPath ()
specifier|public
name|Path
name|getHistoryPath
parameter_list|()
block|{
return|return
name|roleHistory
operator|.
name|getHistoryPath
argument_list|()
return|;
block|}
comment|/**    * Set the container limits -the min and max values for    * resource requests. All requests must be multiples of the min    * values.    * @param minMemory min memory MB    * @param maxMemory maximum memory    * @param minCores min v core count    * @param maxCores maximum cores    */
DECL|method|setContainerLimits (int minMemory,int maxMemory, int minCores, int maxCores)
specifier|public
name|void
name|setContainerLimits
parameter_list|(
name|int
name|minMemory
parameter_list|,
name|int
name|maxMemory
parameter_list|,
name|int
name|minCores
parameter_list|,
name|int
name|maxCores
parameter_list|)
block|{
name|containerMinCores
operator|=
name|minCores
expr_stmt|;
name|containerMaxCores
operator|=
name|maxCores
expr_stmt|;
name|containerMinMemory
operator|=
name|minMemory
expr_stmt|;
name|containerMaxMemory
operator|=
name|maxMemory
expr_stmt|;
name|minResource
operator|=
name|recordFactory
operator|.
name|newResource
argument_list|(
name|containerMinMemory
argument_list|,
name|containerMinCores
argument_list|)
expr_stmt|;
name|maxResource
operator|=
name|recordFactory
operator|.
name|newResource
argument_list|(
name|containerMaxMemory
argument_list|,
name|containerMaxCores
argument_list|)
expr_stmt|;
block|}
DECL|method|isApplicationLive ()
specifier|public
name|boolean
name|isApplicationLive
parameter_list|()
block|{
return|return
name|applicationLive
return|;
block|}
DECL|method|buildInstance (AppStateBindingInfo binding)
specifier|public
specifier|synchronized
name|void
name|buildInstance
parameter_list|(
name|AppStateBindingInfo
name|binding
parameter_list|)
throws|throws
name|BadClusterStateException
throws|,
name|BadConfigException
throws|,
name|IOException
block|{
name|binding
operator|.
name|validate
argument_list|()
expr_stmt|;
name|containerReleaseSelector
operator|=
name|binding
operator|.
name|releaseSelector
expr_stmt|;
comment|// set the cluster specification (once its dependency the client properties
comment|// is out the way
name|this
operator|.
name|app
operator|=
name|binding
operator|.
name|application
expr_stmt|;
name|appMetrics
operator|=
name|ServiceMetrics
operator|.
name|register
argument_list|(
name|app
operator|.
name|getName
argument_list|()
argument_list|,
literal|"Metrics for service"
argument_list|)
expr_stmt|;
name|appMetrics
operator|.
name|tag
argument_list|(
literal|"type"
argument_list|,
literal|"Metrics type [component or service]"
argument_list|,
literal|"service"
argument_list|)
expr_stmt|;
name|appMetrics
operator|.
name|tag
argument_list|(
literal|"appId"
argument_list|,
literal|"Application id for service"
argument_list|,
name|app
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|resource
operator|.
name|Configuration
name|conf
init|=
name|app
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|startTimeThreshold
operator|=
name|conf
operator|.
name|getPropertyLong
argument_list|(
name|InternalKeys
operator|.
name|INTERNAL_CONTAINER_FAILURE_SHORTLIFE
argument_list|,
name|InternalKeys
operator|.
name|DEFAULT_INTERNAL_CONTAINER_FAILURE_SHORTLIFE
argument_list|)
expr_stmt|;
name|failureThreshold
operator|=
name|conf
operator|.
name|getPropertyInt
argument_list|(
name|CONTAINER_FAILURE_THRESHOLD
argument_list|,
name|DEFAULT_CONTAINER_FAILURE_THRESHOLD
argument_list|)
expr_stmt|;
name|nodeFailureThreshold
operator|=
name|conf
operator|.
name|getPropertyInt
argument_list|(
name|NODE_FAILURE_THRESHOLD
argument_list|,
name|DEFAULT_NODE_FAILURE_THRESHOLD
argument_list|)
expr_stmt|;
name|initGlobalTokensForSubstitute
argument_list|(
name|binding
argument_list|)
expr_stmt|;
comment|// build the initial component list
name|Collection
argument_list|<
name|Component
argument_list|>
name|sortedComponents
init|=
name|ServiceApiUtil
operator|.
name|sortByDependencies
argument_list|(
name|app
operator|.
name|getComponents
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|priority
init|=
literal|1
decl_stmt|;
for|for
control|(
name|Component
name|component
range|:
name|sortedComponents
control|)
block|{
name|priority
operator|=
name|getNewPriority
argument_list|(
name|priority
argument_list|)
expr_stmt|;
name|String
name|name
init|=
name|component
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|roles
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Adding component: "
operator|+
name|name
argument_list|)
expr_stmt|;
name|createComponent
argument_list|(
name|name
argument_list|,
name|component
argument_list|,
name|priority
operator|++
argument_list|)
expr_stmt|;
block|}
comment|//then pick up the requirements
comment|//    buildRoleRequirementsFromResources();
comment|// set up the role history
name|roleHistory
operator|=
operator|new
name|RoleHistory
argument_list|(
name|roleStatusMap
operator|.
name|values
argument_list|()
argument_list|,
name|recordFactory
argument_list|)
expr_stmt|;
name|roleHistory
operator|.
name|onStart
argument_list|(
name|binding
operator|.
name|fs
argument_list|,
name|binding
operator|.
name|historyPath
argument_list|)
expr_stmt|;
comment|// trigger first node update
name|roleHistory
operator|.
name|onNodesUpdated
argument_list|(
name|binding
operator|.
name|nodeReports
argument_list|)
expr_stmt|;
comment|//rebuild any live containers
name|rebuildModelFromRestart
argument_list|(
name|binding
operator|.
name|liveContainers
argument_list|)
expr_stmt|;
comment|// any am config options to pick up
name|logServerURL
operator|=
name|binding
operator|.
name|serviceConfig
operator|.
name|get
argument_list|(
name|YarnConfiguration
operator|.
name|YARN_LOG_SERVER_URL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|//mark as live
name|applicationLive
operator|=
literal|true
expr_stmt|;
name|app
operator|.
name|setState
argument_list|(
name|STARTED
argument_list|)
expr_stmt|;
name|createConfigFileCache
argument_list|(
name|binding
operator|.
name|fs
argument_list|)
expr_stmt|;
block|}
DECL|method|initGlobalTokensForSubstitute (AppStateBindingInfo binding)
specifier|private
name|void
name|initGlobalTokensForSubstitute
parameter_list|(
name|AppStateBindingInfo
name|binding
parameter_list|)
throws|throws
name|IOException
block|{
comment|// ZK
name|globalTokens
operator|.
name|put
argument_list|(
name|ServiceApiConstants
operator|.
name|CLUSTER_ZK_QUORUM
argument_list|,
name|binding
operator|.
name|serviceConfig
operator|.
name|getTrimmed
argument_list|(
name|KEY_REGISTRY_ZK_QUORUM
argument_list|,
name|DEFAULT_REGISTRY_ZK_QUORUM
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|user
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
decl_stmt|;
name|globalTokens
operator|.
name|put
argument_list|(
name|SERVICE_ZK_PATH
argument_list|,
name|ZKIntegration
operator|.
name|mkClusterPath
argument_list|(
name|user
argument_list|,
name|app
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|globalTokens
operator|.
name|put
argument_list|(
name|ServiceApiConstants
operator|.
name|USER
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|String
name|dnsDomain
init|=
name|binding
operator|.
name|serviceConfig
operator|.
name|getTrimmed
argument_list|(
name|KEY_DNS_DOMAIN
argument_list|)
decl_stmt|;
if|if
condition|(
name|dnsDomain
operator|!=
literal|null
operator|&&
operator|!
name|dnsDomain
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|globalTokens
operator|.
name|put
argument_list|(
name|ServiceApiConstants
operator|.
name|DOMAIN
argument_list|,
name|dnsDomain
argument_list|)
expr_stmt|;
block|}
comment|// HDFS
name|String
name|clusterFs
init|=
name|binding
operator|.
name|serviceConfig
operator|.
name|getTrimmed
argument_list|(
name|FS_DEFAULT_NAME_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|clusterFs
operator|!=
literal|null
operator|&&
operator|!
name|clusterFs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|globalTokens
operator|.
name|put
argument_list|(
name|ServiceApiConstants
operator|.
name|CLUSTER_FS_URI
argument_list|,
name|clusterFs
argument_list|)
expr_stmt|;
name|globalTokens
operator|.
name|put
argument_list|(
name|ServiceApiConstants
operator|.
name|CLUSTER_FS_HOST
argument_list|,
name|URI
operator|.
name|create
argument_list|(
name|clusterFs
argument_list|)
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|globalTokens
operator|.
name|put
argument_list|(
name|SERVICE_HDFS_DIR
argument_list|,
name|binding
operator|.
name|serviceHdfsDir
argument_list|)
expr_stmt|;
comment|// service name
name|globalTokens
operator|.
name|put
argument_list|(
name|SERVICE_NAME_LC
argument_list|,
name|app
operator|.
name|getName
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
expr_stmt|;
name|globalTokens
operator|.
name|put
argument_list|(
name|SERVICE_NAME
argument_list|,
name|app
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|createConfigFileCache (final FileSystem fileSystem)
specifier|private
name|void
name|createConfigFileCache
parameter_list|(
specifier|final
name|FileSystem
name|fileSystem
parameter_list|)
block|{
name|this
operator|.
name|configFileCache
operator|=
name|CacheBuilder
operator|.
name|newBuilder
argument_list|()
operator|.
name|expireAfterAccess
argument_list|(
literal|10
argument_list|,
name|TimeUnit
operator|.
name|MINUTES
argument_list|)
operator|.
name|build
argument_list|(
operator|new
name|CacheLoader
argument_list|<
name|ConfigFile
argument_list|,
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|load
parameter_list|(
name|ConfigFile
name|key
parameter_list|)
throws|throws
name|Exception
block|{
switch|switch
condition|(
name|key
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|HADOOP_XML
case|:
try|try
init|(
name|FSDataInputStream
name|input
init|=
name|fileSystem
operator|.
name|open
argument_list|(
operator|new
name|Path
argument_list|(
name|key
operator|.
name|getSrcFile
argument_list|()
argument_list|)
argument_list|)
init|)
block|{
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
name|confRead
init|=
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|confRead
operator|.
name|addResource
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|confRead
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|confRead
control|)
block|{
name|map
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
case|case
name|TEMPLATE
case|:
try|try
init|(
name|FSDataInputStream
name|fileInput
init|=
name|fileSystem
operator|.
name|open
argument_list|(
operator|new
name|Path
argument_list|(
name|key
operator|.
name|getSrcFile
argument_list|()
argument_list|)
argument_list|)
init|)
block|{
return|return
name|IOUtils
operator|.
name|toString
argument_list|(
name|fileInput
argument_list|)
return|;
block|}
default|default:
return|return
literal|null
return|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|createComponent (String name, Component component, int priority)
specifier|public
name|ProviderRole
name|createComponent
parameter_list|(
name|String
name|name
parameter_list|,
name|Component
name|component
parameter_list|,
name|int
name|priority
parameter_list|)
throws|throws
name|BadConfigException
block|{
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|resource
operator|.
name|Configuration
name|conf
init|=
name|component
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|long
name|placementTimeout
init|=
name|conf
operator|.
name|getPropertyLong
argument_list|(
name|PLACEMENT_ESCALATE_DELAY
argument_list|,
name|DEFAULT_PLACEMENT_ESCALATE_DELAY_SECONDS
argument_list|)
decl_stmt|;
name|long
name|placementPolicy
init|=
name|conf
operator|.
name|getPropertyLong
argument_list|(
name|COMPONENT_PLACEMENT_POLICY
argument_list|,
name|PlacementPolicy
operator|.
name|DEFAULT
argument_list|)
decl_stmt|;
name|int
name|threshold
init|=
name|conf
operator|.
name|getPropertyInt
argument_list|(
name|NODE_FAILURE_THRESHOLD
argument_list|,
name|nodeFailureThreshold
argument_list|)
decl_stmt|;
name|String
name|label
init|=
name|conf
operator|.
name|getProperty
argument_list|(
name|YARN_LABEL_EXPRESSION
argument_list|,
name|DEF_YARN_LABEL_EXPRESSION
argument_list|)
decl_stmt|;
name|ProviderRole
name|newRole
init|=
operator|new
name|ProviderRole
argument_list|(
name|name
argument_list|,
name|priority
argument_list|,
operator|(
name|int
operator|)
name|placementPolicy
argument_list|,
name|threshold
argument_list|,
name|placementTimeout
argument_list|,
name|label
argument_list|,
name|component
argument_list|)
decl_stmt|;
name|buildRole
argument_list|(
name|newRole
argument_list|,
name|component
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Created a new role "
operator|+
name|newRole
argument_list|)
expr_stmt|;
return|return
name|newRole
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|updateComponents (Map<String, Long> componentCounts)
specifier|public
specifier|synchronized
name|void
name|updateComponents
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|componentCounts
parameter_list|)
throws|throws
name|BadConfigException
block|{
for|for
control|(
name|Component
name|component
range|:
name|app
operator|.
name|getComponents
argument_list|()
control|)
block|{
if|if
condition|(
name|componentCounts
operator|.
name|containsKey
argument_list|(
name|component
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|long
name|count
init|=
name|componentCounts
operator|.
name|get
argument_list|(
name|component
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|component
operator|.
name|setNumberOfContainers
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|ProviderRole
name|role
init|=
name|roles
operator|.
name|get
argument_list|(
name|component
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|role
operator|!=
literal|null
operator|&&
name|roleStatusMap
operator|.
name|get
argument_list|(
name|role
operator|.
name|id
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|setDesiredContainers
argument_list|(
name|roleStatusMap
operator|.
name|get
argument_list|(
name|role
operator|.
name|id
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|count
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|updateComponents ( Messages.FlexComponentsRequestProto requestProto)
specifier|public
specifier|synchronized
name|void
name|updateComponents
parameter_list|(
name|Messages
operator|.
name|FlexComponentsRequestProto
name|requestProto
parameter_list|)
throws|throws
name|BadConfigException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Long
argument_list|>
name|componentCounts
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ComponentCountProto
name|componentCount
range|:
name|requestProto
operator|.
name|getComponentsList
argument_list|()
control|)
block|{
name|componentCounts
operator|.
name|put
argument_list|(
name|componentCount
operator|.
name|getName
argument_list|()
argument_list|,
name|componentCount
operator|.
name|getNumberOfContainers
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|updateComponents
argument_list|(
name|componentCounts
argument_list|)
expr_stmt|;
block|}
comment|/**    * build the role requirements from the cluster specification    * @return a list of any dynamically added provider roles    */
comment|//  private List<ProviderRole> buildRoleRequirementsFromResources()
comment|//      throws BadConfigException {
comment|//
comment|//    List<ProviderRole> newRoles = new ArrayList<>(0);
comment|//
comment|//    // now update every role's desired count.
comment|//    // if there are no instance values, that role count goes to zero
comment|//    // Add all the existing roles
comment|//    // component name -> number of containers
comment|//    Map<String, Integer> groupCounts = new HashMap<>();
comment|//
comment|//    for (RoleStatus roleStatus : getRoleStatusMap().values()) {
comment|//      if (roleStatus.isExcludeFromFlexing()) {
comment|//        // skip inflexible roles, e.g AM itself
comment|//        continue;
comment|//      }
comment|//      long currentDesired = roleStatus.getDesired();
comment|//      String role = roleStatus.getName();
comment|//      String roleGroup = roleStatus.getGroup();
comment|//      Component component = roleStatus.getProviderRole().component;
comment|//      int desiredInstanceCount = component.getNumberOfContainers().intValue();
comment|//
comment|//      int newDesired = desiredInstanceCount;
comment|//      if (component.getUniqueComponentSupport()) {
comment|//        Integer groupCount = 0;
comment|//        if (groupCounts.containsKey(roleGroup)) {
comment|//          groupCount = groupCounts.get(roleGroup);
comment|//        }
comment|//
comment|//        newDesired = desiredInstanceCount - groupCount;
comment|//
comment|//        if (newDesired> 0) {
comment|//          newDesired = 1;
comment|//          groupCounts.put(roleGroup, groupCount + newDesired);
comment|//        } else {
comment|//          newDesired = 0;
comment|//        }
comment|//      }
comment|//
comment|//      if (newDesired == 0) {
comment|//        log.info("Role {} has 0 instances specified", role);
comment|//      }
comment|//      if (currentDesired != newDesired) {
comment|//        log.info("Role {} flexed from {} to {}", role, currentDesired,
comment|//            newDesired);
comment|//        setDesiredContainers(roleStatus, newDesired);
comment|//      }
comment|//    }
comment|//
comment|//    log.info("Counts per component: " + groupCounts);
comment|//    // now the dynamic ones. Iterate through the the cluster spec and
comment|//    // add any role status entries not in the role status
comment|//
comment|//    List<RoleStatus> list = new ArrayList<>(getRoleStatusMap().values());
comment|//    for (RoleStatus roleStatus : list) {
comment|//      String name = roleStatus.getName();
comment|//      Component component = roleStatus.getProviderRole().component;
comment|//      if (roles.containsKey(name)) {
comment|//        continue;
comment|//      }
comment|//      if (component.getUniqueComponentSupport()) {
comment|//        // THIS NAME IS A GROUP
comment|//        int desiredInstanceCount = component.getNumberOfContainers().intValue();
comment|//        Integer groupCount = 0;
comment|//        if (groupCounts.containsKey(name)) {
comment|//          groupCount = groupCounts.get(name);
comment|//        }
comment|//        log.info("Component " + component.getName() + ", current count = "
comment|//            + groupCount + ", desired count = " + desiredInstanceCount);
comment|//        for (int i = groupCount + 1; i<= desiredInstanceCount; i++) {
comment|//          int priority = roleStatus.getPriority();
comment|//          // this is a new instance of an existing group
comment|//          String newName = String.format("%s%d", name, i);
comment|//          int newPriority = getNewPriority(priority + i - 1);
comment|//          log.info("Adding new role {}", newName);
comment|//          ProviderRole dynamicRole =
comment|//              createComponent(newName, name, component, newPriority);
comment|//          RoleStatus newRole = buildRole(dynamicRole);
comment|//          incDesiredContainers(newRole);
comment|//          log.info("New role {}", newRole);
comment|//          if (roleHistory != null) {
comment|//            roleHistory.addNewRole(newRole);
comment|//          }
comment|//          newRoles.add(dynamicRole);
comment|//        }
comment|//      } else {
comment|//        // this is a new value
comment|//        log.info("Adding new role {}", name);
comment|//        ProviderRole dynamicRole =
comment|//            createComponent(name, name, component, roleStatus.getPriority());
comment|//        RoleStatus newRole = buildRole(dynamicRole);
comment|//        incDesiredContainers(roleStatus,
comment|//            component.getNumberOfContainers().intValue());
comment|//        log.info("New role {}", newRole);
comment|//        if (roleHistory != null) {
comment|//          roleHistory.addNewRole(newRole);
comment|//        }
comment|//        newRoles.add(dynamicRole);
comment|//      }
comment|//    }
comment|//    // and fill in all those roles with their requirements
comment|//    buildRoleResourceRequirements();
comment|//
comment|//    return newRoles;
comment|//  }
DECL|method|getNewPriority (int start)
specifier|private
name|int
name|getNewPriority
parameter_list|(
name|int
name|start
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rolePriorityMap
operator|.
name|containsKey
argument_list|(
name|start
argument_list|)
condition|)
block|{
return|return
name|start
return|;
block|}
return|return
name|rolePriorityMap
operator|.
name|lastKey
argument_list|()
operator|+
literal|1
return|;
block|}
comment|/**    * Add knowledge of a role.    * This is a build-time operation that is not synchronized, and    * should be used while setting up the system state -before servicing    * requests.    * @param providerRole role to add    * @return the role status built up    * @throws BadConfigException if a role of that priority already exists    */
DECL|method|buildRole (ProviderRole providerRole, Component component)
specifier|public
name|RoleStatus
name|buildRole
parameter_list|(
name|ProviderRole
name|providerRole
parameter_list|,
name|Component
name|component
parameter_list|)
throws|throws
name|BadConfigException
block|{
comment|// build role status map
name|int
name|priority
init|=
name|providerRole
operator|.
name|id
decl_stmt|;
if|if
condition|(
name|roleStatusMap
operator|.
name|containsKey
argument_list|(
name|priority
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|BadConfigException
argument_list|(
literal|"Duplicate component priority Key: %s and %s"
argument_list|,
name|providerRole
argument_list|,
name|roleStatusMap
operator|.
name|get
argument_list|(
name|priority
argument_list|)
argument_list|)
throw|;
block|}
name|RoleStatus
name|roleStatus
init|=
operator|new
name|RoleStatus
argument_list|(
name|providerRole
argument_list|)
decl_stmt|;
name|roleStatus
operator|.
name|setResourceRequirements
argument_list|(
name|buildResourceRequirements
argument_list|(
name|roleStatus
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|prev
init|=
name|roleStatus
operator|.
name|getDesired
argument_list|()
decl_stmt|;
name|setDesiredContainers
argument_list|(
name|roleStatus
argument_list|,
name|component
operator|.
name|getNumberOfContainers
argument_list|()
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Set desired containers for component "
operator|+
name|component
operator|.
name|getName
argument_list|()
operator|+
literal|" from "
operator|+
name|prev
operator|+
literal|" to "
operator|+
name|roleStatus
operator|.
name|getDesired
argument_list|()
argument_list|)
expr_stmt|;
name|roleStatusMap
operator|.
name|put
argument_list|(
name|priority
argument_list|,
name|roleStatus
argument_list|)
expr_stmt|;
name|String
name|name
init|=
name|providerRole
operator|.
name|name
decl_stmt|;
name|roles
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|providerRole
argument_list|)
expr_stmt|;
name|rolePriorityMap
operator|.
name|put
argument_list|(
name|priority
argument_list|,
name|providerRole
argument_list|)
expr_stmt|;
comment|// register its entries
name|metricsAndMonitoring
operator|.
name|addMetricSet
argument_list|(
name|MetricsConstants
operator|.
name|PREFIX_SLIDER_ROLES
operator|+
name|name
argument_list|,
name|roleStatus
argument_list|)
expr_stmt|;
return|return
name|roleStatus
return|;
block|}
comment|/**    * Look up the status entry of a role or raise an exception    * @param key role ID    * @return the status entry    * @throws RuntimeException if the role cannot be found    */
DECL|method|lookupRoleStatus (int key)
specifier|public
name|RoleStatus
name|lookupRoleStatus
parameter_list|(
name|int
name|key
parameter_list|)
block|{
name|RoleStatus
name|rs
init|=
name|getRoleStatusMap
argument_list|()
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|rs
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Cannot find role for role ID "
operator|+
name|key
argument_list|)
throw|;
block|}
return|return
name|rs
return|;
block|}
comment|/**    * Look up the status entry of a container or raise an exception    *    * @param c container    * @return the status entry    * @throws RuntimeException if the role cannot be found    */
DECL|method|lookupRoleStatus (Container c)
specifier|public
name|RoleStatus
name|lookupRoleStatus
parameter_list|(
name|Container
name|c
parameter_list|)
block|{
return|return
name|lookupRoleStatus
argument_list|(
name|ContainerPriority
operator|.
name|extractRole
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Look up a role in the map    * @param name role name    * @return the instance    * @throws YarnRuntimeException if not found    */
DECL|method|lookupRoleStatus (String name)
specifier|public
name|RoleStatus
name|lookupRoleStatus
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|YarnRuntimeException
block|{
name|ProviderRole
name|providerRole
init|=
name|roles
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|providerRole
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|YarnRuntimeException
argument_list|(
literal|"Unknown role "
operator|+
name|name
argument_list|)
throw|;
block|}
return|return
name|lookupRoleStatus
argument_list|(
name|providerRole
operator|.
name|id
argument_list|)
return|;
block|}
comment|/**    * Clone the list of active (==owned) containers    * @return the list of role instances representing all owned containers    */
DECL|method|cloneOwnedContainerList ()
specifier|public
specifier|synchronized
name|List
argument_list|<
name|RoleInstance
argument_list|>
name|cloneOwnedContainerList
parameter_list|()
block|{
name|Collection
argument_list|<
name|RoleInstance
argument_list|>
name|values
init|=
name|ownedContainers
operator|.
name|values
argument_list|()
decl_stmt|;
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|values
argument_list|)
return|;
block|}
comment|/**    * Get the number of active (==owned) containers    * @return    */
DECL|method|getNumOwnedContainers ()
specifier|public
name|int
name|getNumOwnedContainers
parameter_list|()
block|{
return|return
name|ownedContainers
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Look up an active container: any container that the AM has, even    * if it is not currently running/live    */
DECL|method|getOwnedContainer (ContainerId id)
specifier|public
name|RoleInstance
name|getOwnedContainer
parameter_list|(
name|ContainerId
name|id
parameter_list|)
block|{
return|return
name|ownedContainers
operator|.
name|get
argument_list|(
name|id
argument_list|)
return|;
block|}
comment|/**    * Remove an owned container    * @param id container ID    * @return the instance removed    */
DECL|method|removeOwnedContainer (ContainerId id)
specifier|private
name|RoleInstance
name|removeOwnedContainer
parameter_list|(
name|ContainerId
name|id
parameter_list|)
block|{
return|return
name|ownedContainers
operator|.
name|remove
argument_list|(
name|id
argument_list|)
return|;
block|}
comment|/**    * set/update an owned container    * @param id container ID    * @param instance    * @return    */
DECL|method|putOwnedContainer (ContainerId id, RoleInstance instance)
specifier|private
name|RoleInstance
name|putOwnedContainer
parameter_list|(
name|ContainerId
name|id
parameter_list|,
name|RoleInstance
name|instance
parameter_list|)
block|{
return|return
name|ownedContainers
operator|.
name|put
argument_list|(
name|id
argument_list|,
name|instance
argument_list|)
return|;
block|}
comment|/**    * Clone the live container list. This is synchronized.    * @return a snapshot of the live node list    */
DECL|method|cloneLiveContainerInfoList ()
specifier|public
specifier|synchronized
name|List
argument_list|<
name|RoleInstance
argument_list|>
name|cloneLiveContainerInfoList
parameter_list|()
block|{
name|List
argument_list|<
name|RoleInstance
argument_list|>
name|allRoleInstances
decl_stmt|;
name|Collection
argument_list|<
name|RoleInstance
argument_list|>
name|values
init|=
name|getLiveContainers
argument_list|()
operator|.
name|values
argument_list|()
decl_stmt|;
name|allRoleInstances
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|values
argument_list|)
expr_stmt|;
return|return
name|allRoleInstances
return|;
block|}
comment|/**    * Lookup live instance by string value of container ID    * @param containerId container ID as a string    * @return the role instance for that container    * @throws NoSuchNodeException if it does not exist    */
DECL|method|getLiveInstanceByContainerID (String containerId)
specifier|public
specifier|synchronized
name|RoleInstance
name|getLiveInstanceByContainerID
parameter_list|(
name|String
name|containerId
parameter_list|)
throws|throws
name|NoSuchNodeException
block|{
name|Collection
argument_list|<
name|RoleInstance
argument_list|>
name|nodes
init|=
name|getLiveContainers
argument_list|()
operator|.
name|values
argument_list|()
decl_stmt|;
return|return
name|findNodeInCollection
argument_list|(
name|containerId
argument_list|,
name|nodes
argument_list|)
return|;
block|}
comment|/**    * Lookup owned instance by string value of container ID    * @param containerId container ID as a string    * @return the role instance for that container    * @throws NoSuchNodeException if it does not exist    */
DECL|method|getOwnedInstanceByContainerID (String containerId)
specifier|public
specifier|synchronized
name|RoleInstance
name|getOwnedInstanceByContainerID
parameter_list|(
name|String
name|containerId
parameter_list|)
throws|throws
name|NoSuchNodeException
block|{
name|Collection
argument_list|<
name|RoleInstance
argument_list|>
name|nodes
init|=
name|ownedContainers
operator|.
name|values
argument_list|()
decl_stmt|;
return|return
name|findNodeInCollection
argument_list|(
name|containerId
argument_list|,
name|nodes
argument_list|)
return|;
block|}
comment|/**    * Iterate through a collection of role instances to find one with a    * specific (string) container ID    * @param containerId container ID as a string    * @param nodes collection    * @return the found node     * @throws NoSuchNodeException if there was no match    */
DECL|method|findNodeInCollection (String containerId, Collection<RoleInstance> nodes)
specifier|private
name|RoleInstance
name|findNodeInCollection
parameter_list|(
name|String
name|containerId
parameter_list|,
name|Collection
argument_list|<
name|RoleInstance
argument_list|>
name|nodes
parameter_list|)
throws|throws
name|NoSuchNodeException
block|{
name|RoleInstance
name|found
init|=
literal|null
decl_stmt|;
for|for
control|(
name|RoleInstance
name|node
range|:
name|nodes
control|)
block|{
if|if
condition|(
name|containerId
operator|.
name|equals
argument_list|(
name|node
operator|.
name|id
argument_list|)
condition|)
block|{
name|found
operator|=
name|node
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
operator|!=
literal|null
condition|)
block|{
return|return
name|found
return|;
block|}
else|else
block|{
comment|//at this point: no node
throw|throw
operator|new
name|NoSuchNodeException
argument_list|(
literal|"Unknown node: "
operator|+
name|containerId
argument_list|)
throw|;
block|}
block|}
DECL|method|getLiveInstancesByContainerIDs ( Collection<String> containerIDs)
specifier|public
specifier|synchronized
name|List
argument_list|<
name|RoleInstance
argument_list|>
name|getLiveInstancesByContainerIDs
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|containerIDs
parameter_list|)
block|{
comment|//first, a hashmap of those containerIDs is built up
name|Set
argument_list|<
name|String
argument_list|>
name|uuidSet
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|containerIDs
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|RoleInstance
argument_list|>
name|nodes
init|=
operator|new
name|ArrayList
argument_list|<
name|RoleInstance
argument_list|>
argument_list|(
name|uuidSet
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|RoleInstance
argument_list|>
name|clusterNodes
init|=
name|getLiveContainers
argument_list|()
operator|.
name|values
argument_list|()
decl_stmt|;
for|for
control|(
name|RoleInstance
name|node
range|:
name|clusterNodes
control|)
block|{
if|if
condition|(
name|uuidSet
operator|.
name|contains
argument_list|(
name|node
operator|.
name|id
argument_list|)
condition|)
block|{
name|nodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|//at this point: a possibly empty list of nodes
return|return
name|nodes
return|;
block|}
comment|/**    * Enum all nodes by role.    * @param role role, or "" for all roles    * @return a list of nodes, may be empty    */
DECL|method|enumLiveNodesInRole (String role)
specifier|public
specifier|synchronized
name|List
argument_list|<
name|RoleInstance
argument_list|>
name|enumLiveNodesInRole
parameter_list|(
name|String
name|role
parameter_list|)
block|{
name|List
argument_list|<
name|RoleInstance
argument_list|>
name|nodes
init|=
operator|new
name|ArrayList
argument_list|<
name|RoleInstance
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|RoleInstance
argument_list|>
name|allRoleInstances
init|=
name|getLiveContainers
argument_list|()
operator|.
name|values
argument_list|()
decl_stmt|;
for|for
control|(
name|RoleInstance
name|node
range|:
name|allRoleInstances
control|)
block|{
if|if
condition|(
name|role
operator|.
name|isEmpty
argument_list|()
operator|||
name|role
operator|.
name|equals
argument_list|(
name|node
operator|.
name|role
argument_list|)
condition|)
block|{
name|nodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|nodes
return|;
block|}
comment|/**    * enum nodes by role ID, from either the owned or live node list    * @param roleId role the container must be in    * @param owned flag to indicate "use owned list" rather than the smaller    * "live" list    * @return a list of nodes, may be empty    */
DECL|method|enumNodesWithRoleId (int roleId, boolean owned)
specifier|public
specifier|synchronized
name|List
argument_list|<
name|RoleInstance
argument_list|>
name|enumNodesWithRoleId
parameter_list|(
name|int
name|roleId
parameter_list|,
name|boolean
name|owned
parameter_list|)
block|{
name|List
argument_list|<
name|RoleInstance
argument_list|>
name|nodes
init|=
operator|new
name|ArrayList
argument_list|<
name|RoleInstance
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|RoleInstance
argument_list|>
name|allRoleInstances
decl_stmt|;
name|allRoleInstances
operator|=
name|owned
condition|?
name|ownedContainers
operator|.
name|values
argument_list|()
else|:
name|liveNodes
operator|.
name|values
argument_list|()
expr_stmt|;
for|for
control|(
name|RoleInstance
name|node
range|:
name|allRoleInstances
control|)
block|{
if|if
condition|(
name|node
operator|.
name|roleId
operator|==
name|roleId
condition|)
block|{
name|nodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|nodes
return|;
block|}
comment|/**    * Build an instance map.    * @return the map of Role name to list of role instances    */
DECL|method|createRoleToInstanceMap ()
specifier|private
specifier|synchronized
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|createRoleToInstanceMap
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|RoleInstance
name|node
range|:
name|getLiveContainers
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|containers
init|=
name|map
operator|.
name|get
argument_list|(
name|node
operator|.
name|role
argument_list|)
decl_stmt|;
if|if
condition|(
name|containers
operator|==
literal|null
condition|)
block|{
name|containers
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|node
operator|.
name|role
argument_list|,
name|containers
argument_list|)
expr_stmt|;
block|}
name|containers
operator|.
name|add
argument_list|(
name|node
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
comment|/**    * Build a map of Component_name -> ContainerId -> ClusterNode    *     * @return the map of Role name to list of Cluster Nodes    */
DECL|method|createRoleToClusterNodeMap ()
specifier|public
specifier|synchronized
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ClusterNode
argument_list|>
argument_list|>
name|createRoleToClusterNodeMap
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|ClusterNode
argument_list|>
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RoleInstance
name|node
range|:
name|getLiveContainers
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|ClusterNode
argument_list|>
name|containers
init|=
name|map
operator|.
name|get
argument_list|(
name|node
operator|.
name|role
argument_list|)
decl_stmt|;
if|if
condition|(
name|containers
operator|==
literal|null
condition|)
block|{
name|containers
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ClusterNode
argument_list|>
argument_list|()
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|node
operator|.
name|role
argument_list|,
name|containers
argument_list|)
expr_stmt|;
block|}
name|ClusterNode
name|clusterNode
init|=
name|node
operator|.
name|toClusterNode
argument_list|()
decl_stmt|;
name|containers
operator|.
name|put
argument_list|(
name|clusterNode
operator|.
name|name
argument_list|,
name|clusterNode
argument_list|)
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
comment|/**    * Notification called just before the NM is asked to     * start a container    * @param container container to start    * @param instance clusterNode structure    */
DECL|method|containerStartSubmitted (Container container, RoleInstance instance)
specifier|public
name|void
name|containerStartSubmitted
parameter_list|(
name|Container
name|container
parameter_list|,
name|RoleInstance
name|instance
parameter_list|)
block|{
name|instance
operator|.
name|state
operator|=
name|STATE_SUBMITTED
expr_stmt|;
name|instance
operator|.
name|container
operator|=
name|container
expr_stmt|;
name|instance
operator|.
name|createTime
operator|=
name|now
argument_list|()
expr_stmt|;
name|getStartingContainers
argument_list|()
operator|.
name|put
argument_list|(
name|container
operator|.
name|getId
argument_list|()
argument_list|,
name|instance
argument_list|)
expr_stmt|;
name|putOwnedContainer
argument_list|(
name|container
operator|.
name|getId
argument_list|()
argument_list|,
name|instance
argument_list|)
expr_stmt|;
name|roleHistory
operator|.
name|onContainerStartSubmitted
argument_list|(
name|container
argument_list|,
name|instance
argument_list|)
expr_stmt|;
block|}
comment|/**    * Note that a container has been submitted for release; update internal state    * and mark the associated ContainerInfo released field to indicate that    * while it is still in the active list, it has been queued for release.    *    * @param container container    * @throws SliderInternalStateException if there is no container of that ID    * on the active list    */
DECL|method|containerReleaseSubmitted (Container container)
specifier|public
specifier|synchronized
name|void
name|containerReleaseSubmitted
parameter_list|(
name|Container
name|container
parameter_list|)
throws|throws
name|SliderInternalStateException
block|{
name|ContainerId
name|id
init|=
name|container
operator|.
name|getId
argument_list|()
decl_stmt|;
comment|//look up the container
name|RoleInstance
name|instance
init|=
name|getOwnedContainer
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|instance
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|SliderInternalStateException
argument_list|(
literal|"No active container with ID "
operator|+
name|id
argument_list|)
throw|;
block|}
comment|//verify that it isn't already released
if|if
condition|(
name|containersBeingReleased
operator|.
name|containsKey
argument_list|(
name|id
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SliderInternalStateException
argument_list|(
literal|"Container %s already queued for release"
argument_list|,
name|id
argument_list|)
throw|;
block|}
name|instance
operator|.
name|released
operator|=
literal|true
expr_stmt|;
name|containersBeingReleased
operator|.
name|put
argument_list|(
name|id
argument_list|,
name|instance
operator|.
name|container
argument_list|)
expr_stmt|;
name|roleHistory
operator|.
name|onContainerReleaseSubmitted
argument_list|(
name|container
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a container request.    * Update internal state, such as the role request count.    * Anti-Affine: the {@link RoleStatus#outstandingAArequest} is set here.    * This is where role history information will be used for placement decisions.    * @param role role    * @return the container request to submit or null if there is none    */
DECL|method|createContainerRequest (RoleStatus role)
specifier|private
name|AMRMClient
operator|.
name|ContainerRequest
name|createContainerRequest
parameter_list|(
name|RoleStatus
name|role
parameter_list|)
block|{
if|if
condition|(
name|role
operator|.
name|isAntiAffinePlacement
argument_list|()
condition|)
block|{
return|return
name|createAAContainerRequest
argument_list|(
name|role
argument_list|)
return|;
block|}
else|else
block|{
name|OutstandingRequest
name|request
init|=
name|roleHistory
operator|.
name|requestContainerForRole
argument_list|(
name|role
argument_list|)
decl_stmt|;
if|if
condition|(
name|request
operator|!=
literal|null
condition|)
block|{
return|return
name|request
operator|.
name|getIssuedRequest
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
block|}
comment|/**    * Create a container request.    * Update internal state, such as the role request count.    * Anti-Affine: the {@link RoleStatus#outstandingAArequest} is set here.    * This is where role history information will be used for placement decisions.    * @param role role    * @return the container request to submit or null if there is none    */
DECL|method|createAAContainerRequest (RoleStatus role)
specifier|private
name|AMRMClient
operator|.
name|ContainerRequest
name|createAAContainerRequest
parameter_list|(
name|RoleStatus
name|role
parameter_list|)
block|{
name|OutstandingRequest
name|request
init|=
name|roleHistory
operator|.
name|requestContainerForAARole
argument_list|(
name|role
argument_list|)
decl_stmt|;
if|if
condition|(
name|request
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|role
operator|.
name|setOutstandingAArequest
argument_list|(
name|request
argument_list|)
expr_stmt|;
return|return
name|request
operator|.
name|getIssuedRequest
argument_list|()
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|incRequestedContainers (RoleStatus role)
specifier|public
name|void
name|incRequestedContainers
parameter_list|(
name|RoleStatus
name|role
parameter_list|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Incrementing requested containers for {}"
argument_list|,
name|role
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|role
operator|.
name|getComponentMetrics
argument_list|()
operator|.
name|containersRequested
operator|.
name|incr
argument_list|()
expr_stmt|;
name|appMetrics
operator|.
name|containersRequested
operator|.
name|incr
argument_list|()
expr_stmt|;
block|}
DECL|method|decRequestedContainers (RoleStatus role)
specifier|private
name|void
name|decRequestedContainers
parameter_list|(
name|RoleStatus
name|role
parameter_list|)
block|{
name|role
operator|.
name|getComponentMetrics
argument_list|()
operator|.
name|containersRequested
operator|.
name|decr
argument_list|()
expr_stmt|;
name|appMetrics
operator|.
name|containersRequested
operator|.
name|decr
argument_list|()
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Decrementing requested containers for {} by {} to {}"
argument_list|,
name|role
operator|.
name|getName
argument_list|()
argument_list|,
literal|1
argument_list|,
name|role
operator|.
name|getComponentMetrics
argument_list|()
operator|.
name|containersRequested
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|decRequestedContainersToFloor (RoleStatus role, int delta)
specifier|private
name|int
name|decRequestedContainersToFloor
parameter_list|(
name|RoleStatus
name|role
parameter_list|,
name|int
name|delta
parameter_list|)
block|{
name|int
name|actual
init|=
name|decMetricToFloor
argument_list|(
name|role
operator|.
name|getComponentMetrics
argument_list|()
operator|.
name|containersRequested
argument_list|,
name|delta
argument_list|)
decl_stmt|;
name|appMetrics
operator|.
name|containersRequested
operator|.
name|decr
argument_list|(
name|actual
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Decrementing requested containers for {} by {} to {}"
argument_list|,
name|role
operator|.
name|getName
argument_list|()
argument_list|,
name|actual
argument_list|,
name|role
operator|.
name|getComponentMetrics
argument_list|()
operator|.
name|containersRequested
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|actual
return|;
block|}
DECL|method|decAAPendingToFloor (RoleStatus role, int delta)
specifier|private
name|int
name|decAAPendingToFloor
parameter_list|(
name|RoleStatus
name|role
parameter_list|,
name|int
name|delta
parameter_list|)
block|{
name|int
name|actual
init|=
name|decMetricToFloor
argument_list|(
name|role
operator|.
name|getComponentMetrics
argument_list|()
operator|.
name|pendingAAContainers
argument_list|,
name|delta
argument_list|)
decl_stmt|;
name|appMetrics
operator|.
name|pendingAAContainers
operator|.
name|decr
argument_list|(
name|actual
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Decrementing AA pending containers for {} by {} to {}"
argument_list|,
name|role
operator|.
name|getName
argument_list|()
argument_list|,
name|actual
argument_list|,
name|role
operator|.
name|getComponentMetrics
argument_list|()
operator|.
name|pendingAAContainers
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|actual
return|;
block|}
DECL|method|decMetricToFloor (MutableGaugeInt metric, int delta)
specifier|private
name|int
name|decMetricToFloor
parameter_list|(
name|MutableGaugeInt
name|metric
parameter_list|,
name|int
name|delta
parameter_list|)
block|{
name|int
name|currentValue
init|=
name|metric
operator|.
name|value
argument_list|()
decl_stmt|;
name|int
name|decrAmount
init|=
name|delta
decl_stmt|;
if|if
condition|(
name|currentValue
operator|-
name|delta
operator|<
literal|0
condition|)
block|{
name|decrAmount
operator|=
name|currentValue
expr_stmt|;
block|}
name|metric
operator|.
name|decr
argument_list|(
name|decrAmount
argument_list|)
expr_stmt|;
return|return
name|decrAmount
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|incRunningContainers (RoleStatus role)
specifier|public
name|void
name|incRunningContainers
parameter_list|(
name|RoleStatus
name|role
parameter_list|)
block|{
name|role
operator|.
name|getComponentMetrics
argument_list|()
operator|.
name|containersRunning
operator|.
name|incr
argument_list|()
expr_stmt|;
name|appMetrics
operator|.
name|containersRunning
operator|.
name|incr
argument_list|()
expr_stmt|;
block|}
DECL|method|decRunningContainers (RoleStatus role)
specifier|private
name|void
name|decRunningContainers
parameter_list|(
name|RoleStatus
name|role
parameter_list|)
block|{
name|role
operator|.
name|getComponentMetrics
argument_list|()
operator|.
name|containersRunning
operator|.
name|decr
argument_list|()
expr_stmt|;
name|appMetrics
operator|.
name|containersRunning
operator|.
name|decr
argument_list|()
expr_stmt|;
block|}
DECL|method|setDesiredContainers (RoleStatus role, int n)
specifier|private
name|void
name|setDesiredContainers
parameter_list|(
name|RoleStatus
name|role
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|delta
init|=
name|n
operator|-
name|role
operator|.
name|getComponentMetrics
argument_list|()
operator|.
name|containersDesired
operator|.
name|value
argument_list|()
decl_stmt|;
name|role
operator|.
name|getComponentMetrics
argument_list|()
operator|.
name|containersDesired
operator|.
name|set
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|appMetrics
operator|.
name|containersDesired
operator|.
name|incr
argument_list|(
name|delta
argument_list|)
expr_stmt|;
block|}
DECL|method|incCompletedContainers (RoleStatus role)
specifier|private
name|void
name|incCompletedContainers
parameter_list|(
name|RoleStatus
name|role
parameter_list|)
block|{
name|role
operator|.
name|getComponentMetrics
argument_list|()
operator|.
name|containersSucceeded
operator|.
name|incr
argument_list|()
expr_stmt|;
name|appMetrics
operator|.
name|containersSucceeded
operator|.
name|incr
argument_list|()
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|incFailedContainers (RoleStatus role, ContainerOutcome outcome)
specifier|public
name|void
name|incFailedContainers
parameter_list|(
name|RoleStatus
name|role
parameter_list|,
name|ContainerOutcome
name|outcome
parameter_list|)
block|{
switch|switch
condition|(
name|outcome
condition|)
block|{
case|case
name|Preempted
case|:
name|appMetrics
operator|.
name|containersPreempted
operator|.
name|incr
argument_list|()
expr_stmt|;
name|role
operator|.
name|getComponentMetrics
argument_list|()
operator|.
name|containersPreempted
operator|.
name|incr
argument_list|()
expr_stmt|;
break|break;
case|case
name|Disk_failure
case|:
name|appMetrics
operator|.
name|containersDiskFailure
operator|.
name|incr
argument_list|()
expr_stmt|;
name|appMetrics
operator|.
name|containersFailed
operator|.
name|incr
argument_list|()
expr_stmt|;
name|role
operator|.
name|getComponentMetrics
argument_list|()
operator|.
name|containersDiskFailure
operator|.
name|incr
argument_list|()
expr_stmt|;
name|role
operator|.
name|getComponentMetrics
argument_list|()
operator|.
name|containersFailed
operator|.
name|incr
argument_list|()
expr_stmt|;
break|break;
comment|//    case Failed:
comment|//      appMetrics.failedSinceLastThreshold.incr();
comment|//      appMetrics.containersFailed.incr();
comment|//      role.getComponentMetrics().failedSinceLastThreshold.incr();
comment|//      role.getComponentMetrics().containersFailed.incr();
comment|//      break;
comment|//    case Failed_limits_exceeded:
comment|//      appMetrics.containersLimitsExceeded.incr();
comment|//      appMetrics.failedSinceLastThreshold.incr();
comment|//      appMetrics.containersFailed.incr();
comment|//      role.getComponentMetrics().containersLimitsExceeded.incr();
comment|//      role.getComponentMetrics().failedSinceLastThreshold.incr();
comment|//      role.getComponentMetrics().containersFailed.incr();
comment|//      break;
comment|//    default:
comment|//      appMetrics.failedSinceLastThreshold.incr();
comment|//      appMetrics.containersFailed.incr();
comment|//      role.getComponentMetrics().failedSinceLastThreshold.incr();
comment|//      role.getComponentMetrics().containersFailed.incr();
comment|//      break;
block|}
block|}
comment|/**    * Build up the resource requirements for this role from the cluster    * specification, including substituting max allowed values if the    * specification asked for it (except when    * {@link org.apache.slider.api.ResourceKeys#YARN_RESOURCE_NORMALIZATION_ENABLED}    * is set to false).    * @param role role    * during normalization    */
DECL|method|buildResourceRequirements (RoleStatus role)
specifier|public
name|Resource
name|buildResourceRequirements
parameter_list|(
name|RoleStatus
name|role
parameter_list|)
block|{
comment|// Set up resource requirements from role values
name|String
name|name
init|=
name|role
operator|.
name|getName
argument_list|()
decl_stmt|;
name|Component
name|component
init|=
name|role
operator|.
name|getProviderRole
argument_list|()
operator|.
name|component
decl_stmt|;
name|int
name|cores
init|=
name|DEF_YARN_CORES
decl_stmt|;
if|if
condition|(
name|component
operator|.
name|getResource
argument_list|()
operator|!=
literal|null
operator|&&
name|component
operator|.
name|getResource
argument_list|()
operator|.
name|getCpus
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|cores
operator|=
name|Math
operator|.
name|min
argument_list|(
name|containerMaxCores
argument_list|,
name|component
operator|.
name|getResource
argument_list|()
operator|.
name|getCpus
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cores
operator|<=
literal|0
condition|)
block|{
name|cores
operator|=
name|DEF_YARN_CORES
expr_stmt|;
block|}
name|long
name|rawMem
init|=
name|DEF_YARN_MEMORY
decl_stmt|;
if|if
condition|(
name|component
operator|.
name|getResource
argument_list|()
operator|!=
literal|null
operator|&&
name|component
operator|.
name|getResource
argument_list|()
operator|.
name|getMemory
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|YARN_RESOURCE_MAX
operator|.
name|equals
argument_list|(
name|component
operator|.
name|getResource
argument_list|()
operator|.
name|getMemory
argument_list|()
argument_list|)
condition|)
block|{
name|rawMem
operator|=
name|containerMaxMemory
expr_stmt|;
block|}
else|else
block|{
name|rawMem
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|component
operator|.
name|getResource
argument_list|()
operator|.
name|getMemory
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|boolean
name|normalize
init|=
name|component
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getPropertyBool
argument_list|(
name|YARN_RESOURCE_NORMALIZATION_ENABLED
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|normalize
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Resource normalization: disabled"
argument_list|)
expr_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Component {} has RAM={}, vCores={}"
argument_list|,
name|name
argument_list|,
name|rawMem
argument_list|,
name|cores
argument_list|)
expr_stmt|;
return|return
name|Resources
operator|.
name|createResource
argument_list|(
name|rawMem
argument_list|,
name|cores
argument_list|)
return|;
block|}
name|long
name|mem
init|=
name|Math
operator|.
name|min
argument_list|(
name|containerMaxMemory
argument_list|,
name|rawMem
argument_list|)
decl_stmt|;
if|if
condition|(
name|mem
operator|<=
literal|0
condition|)
block|{
name|mem
operator|=
name|DEF_YARN_MEMORY
expr_stmt|;
block|}
name|Resource
name|capability
init|=
name|Resource
operator|.
name|newInstance
argument_list|(
name|mem
argument_list|,
name|cores
argument_list|)
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Component {} has RAM={}, vCores={}"
argument_list|,
name|name
argument_list|,
name|mem
argument_list|,
name|cores
argument_list|)
expr_stmt|;
name|Resource
name|normalized
init|=
name|recordFactory
operator|.
name|normalize
argument_list|(
name|capability
argument_list|,
name|minResource
argument_list|,
name|maxResource
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Resources
operator|.
name|equals
argument_list|(
name|normalized
argument_list|,
name|capability
argument_list|)
condition|)
block|{
comment|// resource requirements normalized to something other than asked for.
comment|// LOG @ WARN so users can see why this is happening.
name|log
operator|.
name|warn
argument_list|(
literal|"Resource requirements of {} normalized"
operator|+
literal|" from {} to {}"
argument_list|,
name|name
argument_list|,
name|capability
argument_list|,
name|normalized
argument_list|)
expr_stmt|;
block|}
return|return
name|normalized
return|;
block|}
comment|/**    * add a launched container to the node map for status responses    * @param container id    * @param node node details    */
DECL|method|addLaunchedContainer (Container container, RoleInstance node)
specifier|private
name|void
name|addLaunchedContainer
parameter_list|(
name|Container
name|container
parameter_list|,
name|RoleInstance
name|node
parameter_list|)
block|{
name|node
operator|.
name|container
operator|=
name|container
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|role
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unknown role for node "
operator|+
name|node
argument_list|)
throw|;
block|}
name|getLiveContainers
argument_list|()
operator|.
name|put
argument_list|(
name|node
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|//tell role history
name|roleHistory
operator|.
name|onContainerStarted
argument_list|(
name|container
argument_list|)
expr_stmt|;
block|}
comment|/**    * container start event    * @param containerId container that is to be started    * @return the role instance, or null if there was a problem    */
DECL|method|onNodeManagerContainerStarted (ContainerId containerId)
specifier|public
specifier|synchronized
name|RoleInstance
name|onNodeManagerContainerStarted
parameter_list|(
name|ContainerId
name|containerId
parameter_list|)
block|{
try|try
block|{
return|return
name|innerOnNodeManagerContainerStarted
argument_list|(
name|containerId
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|YarnRuntimeException
name|e
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"NodeManager callback on started container {} failed"
argument_list|,
name|containerId
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * container start event handler -throwing an exception on problems    * @param containerId container that is to be started    * @return the role instance    * @throws RuntimeException on problems    */
annotation|@
name|VisibleForTesting
DECL|method|innerOnNodeManagerContainerStarted (ContainerId containerId)
specifier|public
name|RoleInstance
name|innerOnNodeManagerContainerStarted
parameter_list|(
name|ContainerId
name|containerId
parameter_list|)
block|{
name|RoleInstance
name|instance
init|=
name|getOwnedContainer
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
if|if
condition|(
name|instance
operator|==
literal|null
condition|)
block|{
comment|//serious problem
throw|throw
operator|new
name|YarnRuntimeException
argument_list|(
literal|"Container not in active containers start "
operator|+
name|containerId
argument_list|)
throw|;
block|}
if|if
condition|(
name|instance
operator|.
name|role
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|YarnRuntimeException
argument_list|(
literal|"Component instance has no instance name "
operator|+
name|instance
argument_list|)
throw|;
block|}
name|instance
operator|.
name|startTime
operator|=
name|now
argument_list|()
expr_stmt|;
name|RoleInstance
name|starting
init|=
name|getStartingContainers
argument_list|()
operator|.
name|remove
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|starting
condition|)
block|{
throw|throw
operator|new
name|YarnRuntimeException
argument_list|(
literal|"Container "
operator|+
name|containerId
operator|+
literal|" is already started"
argument_list|)
throw|;
block|}
name|instance
operator|.
name|state
operator|=
name|STATE_LIVE
expr_stmt|;
name|Container
name|container
init|=
name|instance
operator|.
name|container
decl_stmt|;
name|addLaunchedContainer
argument_list|(
name|container
argument_list|,
name|instance
argument_list|)
expr_stmt|;
return|return
name|instance
return|;
block|}
comment|/**    * update the application state after a failure to start a container.    * This is perhaps where blacklisting could be most useful: failure    * to start a container is a sign of a more serious problem    * than a later exit.    *    * -relayed from NMClientAsync.CallbackHandler     * @param containerId failing container    * @param thrown what was thrown    */
DECL|method|onNodeManagerContainerStartFailed (ContainerId containerId, Throwable thrown)
specifier|public
specifier|synchronized
name|void
name|onNodeManagerContainerStartFailed
parameter_list|(
name|ContainerId
name|containerId
parameter_list|,
name|Throwable
name|thrown
parameter_list|)
block|{
name|removeOwnedContainer
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
name|RoleInstance
name|instance
init|=
name|getStartingContainers
argument_list|()
operator|.
name|remove
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|instance
condition|)
block|{
name|RoleStatus
name|roleStatus
init|=
name|lookupRoleStatus
argument_list|(
name|instance
operator|.
name|roleId
argument_list|)
decl_stmt|;
name|String
name|text
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|thrown
condition|)
block|{
name|text
operator|=
name|SliderUtils
operator|.
name|stringify
argument_list|(
name|thrown
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|text
operator|=
literal|"container start failure"
expr_stmt|;
block|}
name|instance
operator|.
name|diagnostics
operator|=
name|text
expr_stmt|;
name|roleStatus
operator|.
name|noteFailed
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|getFailedContainers
argument_list|()
operator|.
name|put
argument_list|(
name|containerId
argument_list|,
name|instance
argument_list|)
expr_stmt|;
name|roleHistory
operator|.
name|onNodeManagerContainerStartFailed
argument_list|(
name|instance
operator|.
name|container
argument_list|)
expr_stmt|;
name|incFailedContainers
argument_list|(
name|roleStatus
argument_list|,
name|ContainerOutcome
operator|.
name|Failed
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Handle node update from the RM. This syncs up the node map with the RM's view    * @param updatedNodes updated nodes    */
DECL|method|onNodesUpdated (List<NodeReport> updatedNodes)
specifier|public
specifier|synchronized
name|NodeUpdatedOutcome
name|onNodesUpdated
parameter_list|(
name|List
argument_list|<
name|NodeReport
argument_list|>
name|updatedNodes
parameter_list|)
block|{
name|boolean
name|changed
init|=
name|roleHistory
operator|.
name|onNodesUpdated
argument_list|(
name|updatedNodes
argument_list|)
decl_stmt|;
if|if
condition|(
name|changed
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"YARN cluster changed âcancelling current AA requests"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|operations
init|=
name|cancelOutstandingAARequests
argument_list|()
decl_stmt|;
name|log
operator|.
name|debug
argument_list|(
literal|"Created {} cancel requests"
argument_list|,
name|operations
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|NodeUpdatedOutcome
argument_list|(
literal|true
argument_list|,
name|operations
argument_list|)
return|;
block|}
return|return
operator|new
name|NodeUpdatedOutcome
argument_list|(
literal|false
argument_list|,
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Return value of the {@link #onNodesUpdated(List)} call.    */
DECL|class|NodeUpdatedOutcome
specifier|public
specifier|static
class|class
name|NodeUpdatedOutcome
block|{
DECL|field|clusterChanged
specifier|public
specifier|final
name|boolean
name|clusterChanged
decl_stmt|;
DECL|field|operations
specifier|public
specifier|final
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|operations
decl_stmt|;
DECL|method|NodeUpdatedOutcome (boolean clusterChanged, List<AbstractRMOperation> operations)
specifier|public
name|NodeUpdatedOutcome
parameter_list|(
name|boolean
name|clusterChanged
parameter_list|,
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|operations
parameter_list|)
block|{
name|this
operator|.
name|clusterChanged
operator|=
name|clusterChanged
expr_stmt|;
name|this
operator|.
name|operations
operator|=
name|operations
expr_stmt|;
block|}
block|}
comment|/**    * Is a role short lived by the threshold set for this application    * @param instance instance    * @return true if the instance is considered short lived    */
annotation|@
name|VisibleForTesting
DECL|method|isShortLived (RoleInstance instance)
specifier|public
name|boolean
name|isShortLived
parameter_list|(
name|RoleInstance
name|instance
parameter_list|)
block|{
name|long
name|time
init|=
name|now
argument_list|()
decl_stmt|;
name|long
name|started
init|=
name|instance
operator|.
name|startTime
decl_stmt|;
name|boolean
name|shortlived
decl_stmt|;
if|if
condition|(
name|started
operator|>
literal|0
condition|)
block|{
name|long
name|duration
init|=
name|time
operator|-
name|started
decl_stmt|;
name|shortlived
operator|=
name|duration
operator|<
operator|(
name|startTimeThreshold
operator|*
literal|1000
operator|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Duration {} and startTimeThreshold {}"
argument_list|,
name|duration
argument_list|,
name|startTimeThreshold
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// never even saw a start event
name|shortlived
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|shortlived
return|;
block|}
comment|/**    * Current time in milliseconds. Made protected for    * the option to override it in tests.    * @return the current time.    */
DECL|method|now ()
specifier|protected
name|long
name|now
parameter_list|()
block|{
return|return
name|System
operator|.
name|currentTimeMillis
argument_list|()
return|;
block|}
comment|/**    * This is a very small class to send a multiple result back from     * the completion operation    */
DECL|class|NodeCompletionResult
specifier|public
specifier|static
class|class
name|NodeCompletionResult
block|{
DECL|field|surplusNode
specifier|public
name|boolean
name|surplusNode
init|=
literal|false
decl_stmt|;
DECL|field|roleInstance
specifier|public
name|RoleInstance
name|roleInstance
decl_stmt|;
comment|// did the container fail for *any* reason?
DECL|field|containerFailed
specifier|public
name|boolean
name|containerFailed
init|=
literal|false
decl_stmt|;
comment|// detailed outcome on the container failure
DECL|field|outcome
specifier|public
name|ContainerOutcome
name|outcome
init|=
name|ContainerOutcome
operator|.
name|Completed
decl_stmt|;
DECL|field|exitStatus
specifier|public
name|int
name|exitStatus
init|=
literal|0
decl_stmt|;
DECL|field|unknownNode
specifier|public
name|boolean
name|unknownNode
init|=
literal|false
decl_stmt|;
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"NodeCompletionResult{"
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"surplusNode="
argument_list|)
operator|.
name|append
argument_list|(
name|surplusNode
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", roleInstance="
argument_list|)
operator|.
name|append
argument_list|(
name|roleInstance
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", exitStatus="
argument_list|)
operator|.
name|append
argument_list|(
name|exitStatus
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", containerFailed="
argument_list|)
operator|.
name|append
argument_list|(
name|containerFailed
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", outcome="
argument_list|)
operator|.
name|append
argument_list|(
name|outcome
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", unknownNode="
argument_list|)
operator|.
name|append
argument_list|(
name|unknownNode
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * handle completed node in the CD -move something from the live    * server list to the completed server list.    * @param status the node that has just completed    * @return NodeCompletionResult    */
DECL|method|onCompletedContainer ( ContainerStatus status)
specifier|public
specifier|synchronized
name|NodeCompletionResult
name|onCompletedContainer
parameter_list|(
name|ContainerStatus
name|status
parameter_list|)
block|{
name|ContainerId
name|containerId
init|=
name|status
operator|.
name|getContainerId
argument_list|()
decl_stmt|;
name|NodeCompletionResult
name|result
init|=
operator|new
name|NodeCompletionResult
argument_list|()
decl_stmt|;
name|RoleInstance
name|roleInstance
decl_stmt|;
name|int
name|exitStatus
init|=
name|status
operator|.
name|getExitStatus
argument_list|()
decl_stmt|;
name|result
operator|.
name|exitStatus
operator|=
name|exitStatus
expr_stmt|;
if|if
condition|(
name|containersBeingReleased
operator|.
name|containsKey
argument_list|(
name|containerId
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Container was queued for release : {}"
argument_list|,
name|containerId
argument_list|)
expr_stmt|;
name|Container
name|container
init|=
name|containersBeingReleased
operator|.
name|remove
argument_list|(
name|containerId
argument_list|)
decl_stmt|;
name|RoleStatus
name|roleStatus
init|=
name|lookupRoleStatus
argument_list|(
name|container
argument_list|)
decl_stmt|;
name|decRunningContainers
argument_list|(
name|roleStatus
argument_list|)
expr_stmt|;
name|incCompletedContainers
argument_list|(
name|roleStatus
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"decrementing role count for role {} to {}; completed={}"
argument_list|,
name|roleStatus
operator|.
name|getName
argument_list|()
argument_list|,
name|roleStatus
operator|.
name|getComponentMetrics
argument_list|()
operator|.
name|containersRunning
operator|.
name|value
argument_list|()
argument_list|,
name|roleStatus
operator|.
name|getComponentMetrics
argument_list|()
operator|.
name|containersSucceeded
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|.
name|outcome
operator|=
name|ContainerOutcome
operator|.
name|Completed
expr_stmt|;
name|roleHistory
operator|.
name|onReleaseCompleted
argument_list|(
name|container
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|surplusContainers
operator|.
name|remove
argument_list|(
name|containerId
argument_list|)
condition|)
block|{
comment|//its a surplus one being purged
name|result
operator|.
name|surplusNode
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// a container has failed or been killed
comment|// use the exit code to determine the outcome
name|result
operator|.
name|containerFailed
operator|=
literal|true
expr_stmt|;
name|result
operator|.
name|outcome
operator|=
name|ContainerOutcome
operator|.
name|fromExitStatus
argument_list|(
name|exitStatus
argument_list|)
expr_stmt|;
name|roleInstance
operator|=
name|removeOwnedContainer
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
if|if
condition|(
name|roleInstance
operator|!=
literal|null
condition|)
block|{
name|RoleStatus
name|roleStatus
init|=
name|lookupRoleStatus
argument_list|(
name|roleInstance
operator|.
name|roleId
argument_list|)
decl_stmt|;
name|incFailedContainers
argument_list|(
name|roleStatus
argument_list|,
name|result
operator|.
name|outcome
argument_list|)
expr_stmt|;
name|failedContainers
operator|.
name|put
argument_list|(
name|containerId
argument_list|,
name|roleInstance
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// the container may have been noted as failed already, so look
comment|// it up
name|roleInstance
operator|=
name|failedContainers
operator|.
name|get
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|roleInstance
operator|!=
literal|null
condition|)
block|{
name|int
name|roleId
init|=
name|roleInstance
operator|.
name|roleId
decl_stmt|;
name|String
name|rolename
init|=
name|roleInstance
operator|.
name|role
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Failed container in role[{}] : {}"
argument_list|,
name|roleId
argument_list|,
name|roleInstance
operator|.
name|getCompInstanceName
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|RoleStatus
name|roleStatus
init|=
name|lookupRoleStatus
argument_list|(
name|roleInstance
operator|.
name|roleId
argument_list|)
decl_stmt|;
name|decRunningContainers
argument_list|(
name|roleStatus
argument_list|)
expr_stmt|;
name|roleStatus
operator|.
name|getProviderRole
argument_list|()
operator|.
name|failedInstances
operator|.
name|offer
argument_list|(
name|roleInstance
argument_list|)
expr_stmt|;
name|boolean
name|shortLived
init|=
name|isShortLived
argument_list|(
name|roleInstance
argument_list|)
decl_stmt|;
name|String
name|message
decl_stmt|;
name|Container
name|failedContainer
init|=
name|roleInstance
operator|.
name|container
decl_stmt|;
comment|//build the failure message
if|if
condition|(
name|failedContainer
operator|!=
literal|null
condition|)
block|{
name|String
name|completedLogsUrl
init|=
name|getLogsURLForContainer
argument_list|(
name|failedContainer
argument_list|)
decl_stmt|;
name|message
operator|=
name|String
operator|.
name|format
argument_list|(
literal|"Failure %s on host %s (%d): %s"
argument_list|,
name|roleInstance
operator|.
name|getContainerId
argument_list|()
argument_list|,
name|failedContainer
operator|.
name|getNodeId
argument_list|()
operator|.
name|getHost
argument_list|()
argument_list|,
name|exitStatus
argument_list|,
name|completedLogsUrl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|message
operator|=
name|String
operator|.
name|format
argument_list|(
literal|"Failure %s (%d)"
argument_list|,
name|containerId
argument_list|,
name|exitStatus
argument_list|)
expr_stmt|;
block|}
name|roleStatus
operator|.
name|noteFailed
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|long
name|failed
init|=
name|roleStatus
operator|.
name|getComponentMetrics
argument_list|()
operator|.
name|containersFailed
operator|.
name|value
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Current count of failed role[{}] {} =  {}"
argument_list|,
name|roleId
argument_list|,
name|rolename
argument_list|,
name|failed
argument_list|)
expr_stmt|;
if|if
condition|(
name|failedContainer
operator|!=
literal|null
condition|)
block|{
name|roleHistory
operator|.
name|onFailedContainer
argument_list|(
name|failedContainer
argument_list|,
name|shortLived
argument_list|,
name|result
operator|.
name|outcome
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|YarnRuntimeException
name|e1
parameter_list|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Failed container of unknown role {}"
argument_list|,
name|roleId
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//this isn't a known container.
name|log
operator|.
name|error
argument_list|(
literal|"Notified of completed container {} that is not in the list"
operator|+
literal|" of active or failed containers"
argument_list|,
name|containerId
argument_list|)
expr_stmt|;
name|completionOfUnknownContainerEvent
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|result
operator|.
name|unknownNode
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|.
name|surplusNode
condition|)
block|{
comment|//a surplus node
return|return
name|result
return|;
block|}
comment|//record the complete node's details; this pulls it from the livenode set
comment|//remove the node
name|ContainerId
name|id
init|=
name|status
operator|.
name|getContainerId
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Removing node ID {}"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|RoleInstance
name|node
init|=
name|getLiveContainers
argument_list|()
operator|.
name|remove
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|node
operator|.
name|state
operator|=
name|STATE_DESTROYED
expr_stmt|;
name|node
operator|.
name|exitCode
operator|=
name|exitStatus
expr_stmt|;
name|node
operator|.
name|diagnostics
operator|=
name|status
operator|.
name|getDiagnostics
argument_list|()
expr_stmt|;
name|getCompletedContainers
argument_list|()
operator|.
name|put
argument_list|(
name|id
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|result
operator|.
name|roleInstance
operator|=
name|node
expr_stmt|;
block|}
else|else
block|{
comment|// not in the list
name|log
operator|.
name|warn
argument_list|(
literal|"Received notification of completion of unknown node {}"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|completionOfNodeNotInLiveListEvent
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|// and the active node list if present
name|removeOwnedContainer
argument_list|(
name|containerId
argument_list|)
expr_stmt|;
comment|// finally, verify the node doesn't exist any more
assert|assert
operator|!
name|containersBeingReleased
operator|.
name|containsKey
argument_list|(
name|containerId
argument_list|)
operator|:
literal|"container still in release queue"
assert|;
assert|assert
operator|!
name|getLiveContainers
argument_list|()
operator|.
name|containsKey
argument_list|(
name|containerId
argument_list|)
operator|:
literal|" container still in live nodes"
assert|;
assert|assert
name|getOwnedContainer
argument_list|(
name|containerId
argument_list|)
operator|==
literal|null
operator|:
literal|"Container still in active container list"
assert|;
return|return
name|result
return|;
block|}
comment|/**    * Get the URL log for a container    * @param c container    * @return the URL or "" if it cannot be determined    */
DECL|method|getLogsURLForContainer (Container c)
specifier|protected
name|String
name|getLogsURLForContainer
parameter_list|(
name|Container
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|user
init|=
literal|null
decl_stmt|;
try|try
block|{
name|user
operator|=
name|SliderUtils
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ignored
parameter_list|)
block|{     }
name|String
name|completedLogsUrl
init|=
literal|""
decl_stmt|;
name|String
name|url
init|=
name|logServerURL
decl_stmt|;
if|if
condition|(
name|user
operator|!=
literal|null
operator|&&
name|SliderUtils
operator|.
name|isSet
argument_list|(
name|url
argument_list|)
condition|)
block|{
name|completedLogsUrl
operator|=
name|url
operator|+
literal|"/"
operator|+
name|c
operator|.
name|getNodeId
argument_list|()
operator|+
literal|"/"
operator|+
name|c
operator|.
name|getId
argument_list|()
operator|+
literal|"/ctx/"
operator|+
name|user
expr_stmt|;
block|}
return|return
name|completedLogsUrl
return|;
block|}
comment|/**    * Return the percentage done that Slider is to have YARN display in its    * Web UI    * @return an number from 0 to 100    */
DECL|method|getApplicationProgressPercentage ()
specifier|public
specifier|synchronized
name|float
name|getApplicationProgressPercentage
parameter_list|()
block|{
name|float
name|percentage
decl_stmt|;
name|long
name|desired
init|=
literal|0
decl_stmt|;
name|float
name|actual
init|=
literal|0
decl_stmt|;
for|for
control|(
name|RoleStatus
name|role
range|:
name|getRoleStatusMap
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|desired
operator|+=
name|role
operator|.
name|getDesired
argument_list|()
expr_stmt|;
name|actual
operator|+=
name|role
operator|.
name|getRunning
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|desired
operator|==
literal|0
condition|)
block|{
name|percentage
operator|=
literal|100
expr_stmt|;
block|}
else|else
block|{
name|percentage
operator|=
name|actual
operator|/
name|desired
expr_stmt|;
block|}
return|return
name|percentage
return|;
block|}
comment|/**    * Update the cluster description with the current application state    */
DECL|method|refreshClusterStatus ()
specifier|public
specifier|synchronized
name|Application
name|refreshClusterStatus
parameter_list|()
block|{
comment|//TODO replace ClusterDescription with Application + related statistics
comment|//TODO build container stats
name|app
operator|.
name|setState
argument_list|(
name|ApplicationState
operator|.
name|STARTED
argument_list|)
expr_stmt|;
return|return
name|app
return|;
block|}
comment|/**    * get application liveness information    * @return a snapshot of the current liveness information    */
DECL|method|getApplicationLivenessInformation ()
specifier|public
name|ApplicationLivenessInformation
name|getApplicationLivenessInformation
parameter_list|()
block|{
name|ApplicationLivenessInformation
name|li
init|=
operator|new
name|ApplicationLivenessInformation
argument_list|()
decl_stmt|;
name|RoleStatistics
name|stats
init|=
name|getRoleStatistics
argument_list|()
decl_stmt|;
name|int
name|outstanding
init|=
call|(
name|int
call|)
argument_list|(
name|stats
operator|.
name|desired
operator|-
name|stats
operator|.
name|actual
argument_list|)
decl_stmt|;
name|li
operator|.
name|requestsOutstanding
operator|=
name|outstanding
expr_stmt|;
name|li
operator|.
name|allRequestsSatisfied
operator|=
name|outstanding
operator|<=
literal|0
expr_stmt|;
return|return
name|li
return|;
block|}
comment|/**    * Get the aggregate statistics across all roles    * @return role statistics    */
DECL|method|getRoleStatistics ()
specifier|public
name|RoleStatistics
name|getRoleStatistics
parameter_list|()
block|{
name|RoleStatistics
name|stats
init|=
operator|new
name|RoleStatistics
argument_list|()
decl_stmt|;
for|for
control|(
name|RoleStatus
name|role
range|:
name|getRoleStatusMap
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|stats
operator|.
name|add
argument_list|(
name|role
operator|.
name|getStatistics
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|stats
return|;
block|}
comment|/**    * Get a snapshot of component information.    *<p>    *   This does<i>not</i> include any container list, which     *   is more expensive to create.    * @return a map of current role status values.    */
DECL|method|getComponentInfoSnapshot ()
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|ComponentInformation
argument_list|>
name|getComponentInfoSnapshot
parameter_list|()
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|RoleStatus
argument_list|>
name|statusMap
init|=
name|getRoleStatusMap
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|ComponentInformation
argument_list|>
name|results
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|statusMap
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RoleStatus
name|status
range|:
name|statusMap
operator|.
name|values
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|status
operator|.
name|getName
argument_list|()
decl_stmt|;
name|ComponentInformation
name|info
init|=
name|status
operator|.
name|serialize
argument_list|()
decl_stmt|;
name|results
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
DECL|method|updateBlacklist ()
specifier|public
specifier|synchronized
name|AbstractRMOperation
name|updateBlacklist
parameter_list|()
block|{
name|UpdateBlacklistOperation
name|blacklistOperation
init|=
name|roleHistory
operator|.
name|updateBlacklist
argument_list|(
name|getRoleStatusMap
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|blacklistOperation
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Updating {}"
argument_list|,
name|blacklistOperation
argument_list|)
expr_stmt|;
block|}
return|return
name|blacklistOperation
return|;
block|}
comment|/**    * Look at where the current node state is -and whether it should be changed    */
DECL|method|reviewRequestAndReleaseNodes ()
specifier|public
specifier|synchronized
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|reviewRequestAndReleaseNodes
parameter_list|()
throws|throws
name|SliderInternalStateException
throws|,
name|TriggerClusterTeardownException
block|{
name|log
operator|.
name|info
argument_list|(
literal|"in reviewRequestAndReleaseNodes()"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|allOperations
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|AbstractRMOperation
name|blacklistOperation
init|=
name|updateBlacklist
argument_list|()
decl_stmt|;
if|if
condition|(
name|blacklistOperation
operator|!=
literal|null
condition|)
block|{
name|allOperations
operator|.
name|add
argument_list|(
name|blacklistOperation
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|RoleStatus
name|roleStatus
range|:
name|getRoleStatusMap
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|roleStatus
operator|.
name|isExcludeFromFlexing
argument_list|()
operator|&&
name|areDependenciesReady
argument_list|(
name|roleStatus
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|operations
init|=
name|reviewOneRole
argument_list|(
name|roleStatus
argument_list|)
decl_stmt|;
name|allOperations
operator|.
name|addAll
argument_list|(
name|operations
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|allOperations
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|areDependenciesReady (RoleStatus roleStatus)
specifier|public
name|boolean
name|areDependenciesReady
parameter_list|(
name|RoleStatus
name|roleStatus
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|dependencies
init|=
name|roleStatus
operator|.
name|getProviderRole
argument_list|()
operator|.
name|component
operator|.
name|getDependencies
argument_list|()
decl_stmt|;
if|if
condition|(
name|SliderUtils
operator|.
name|isEmpty
argument_list|(
name|dependencies
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
for|for
control|(
name|String
name|dependency
range|:
name|dependencies
control|)
block|{
name|ProviderRole
name|providerRole
init|=
name|roles
operator|.
name|get
argument_list|(
name|dependency
argument_list|)
decl_stmt|;
if|if
condition|(
name|providerRole
operator|==
literal|null
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Couldn't find dependency {} for {} (should never happen)"
argument_list|,
name|dependency
argument_list|,
name|roleStatus
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|RoleStatus
name|other
init|=
name|getRoleStatusMap
argument_list|()
operator|.
name|get
argument_list|(
name|providerRole
operator|.
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|other
operator|.
name|getRunning
argument_list|()
operator|<
name|other
operator|.
name|getDesired
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Dependency {} not satisfied for {}, only {} of {} instances"
operator|+
literal|" running"
argument_list|,
name|dependency
argument_list|,
name|roleStatus
operator|.
name|getName
argument_list|()
argument_list|,
name|other
operator|.
name|getRunning
argument_list|()
argument_list|,
name|other
operator|.
name|getDesired
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|providerRole
operator|.
name|probe
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|List
argument_list|<
name|RoleInstance
argument_list|>
name|dependencyInstances
init|=
name|enumLiveNodesInRole
argument_list|(
name|providerRole
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|dependencyInstances
operator|.
name|size
argument_list|()
operator|<
name|other
operator|.
name|getDesired
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Dependency {} not satisfied for {}, only {} of {} instances"
operator|+
literal|" live"
argument_list|,
name|dependency
argument_list|,
name|roleStatus
operator|.
name|getName
argument_list|()
argument_list|,
name|dependencyInstances
operator|.
name|size
argument_list|()
argument_list|,
name|other
operator|.
name|getDesired
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
for|for
control|(
name|RoleInstance
name|instance
range|:
name|dependencyInstances
control|)
block|{
if|if
condition|(
name|instance
operator|.
name|state
operator|!=
name|STATE_READY
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Check the "recent" failure threshold for a role    * @param role role to examine    * @throws TriggerClusterTeardownException if the role    * has failed too many times    */
DECL|method|checkFailureThreshold (RoleStatus role)
specifier|private
name|void
name|checkFailureThreshold
parameter_list|(
name|RoleStatus
name|role
parameter_list|)
throws|throws
name|TriggerClusterTeardownException
block|{
name|long
name|failures
init|=
name|role
operator|.
name|getFailedRecently
argument_list|()
decl_stmt|;
name|int
name|threshold
init|=
name|getFailureThresholdForRole
argument_list|(
name|role
argument_list|)
decl_stmt|;
if|if
condition|(
name|log
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
name|failures
operator|>
literal|0
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Failure count of component: {}: {}, threshold={}"
argument_list|,
name|role
operator|.
name|getName
argument_list|()
argument_list|,
name|failures
argument_list|,
name|threshold
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|threshold
operator|>
literal|0
operator|&&
name|failures
operator|>
name|threshold
condition|)
block|{
throw|throw
operator|new
name|TriggerClusterTeardownException
argument_list|(
name|SliderExitCodes
operator|.
name|EXIT_DEPLOYMENT_FAILED
argument_list|,
name|FinalApplicationStatus
operator|.
name|FAILED
argument_list|,
name|ErrorStrings
operator|.
name|E_UNSTABLE_CLUSTER
operator|+
literal|" - failed with component %s failed 'recently' %d times;"
operator|+
literal|" threshold is %d - last failure: %s"
argument_list|,
name|role
operator|.
name|getName
argument_list|()
argument_list|,
name|role
operator|.
name|getFailedRecently
argument_list|()
argument_list|,
name|threshold
argument_list|,
name|role
operator|.
name|getFailureMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get the failure threshold for a specific role, falling back to    * the global one if not    * @param roleStatus role    * @return the threshold for failures    */
DECL|method|getFailureThresholdForRole (RoleStatus roleStatus)
specifier|private
name|int
name|getFailureThresholdForRole
parameter_list|(
name|RoleStatus
name|roleStatus
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|roleStatus
operator|.
name|getProviderRole
argument_list|()
operator|.
name|component
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getPropertyLong
argument_list|(
name|CONTAINER_FAILURE_THRESHOLD
argument_list|,
name|failureThreshold
argument_list|)
return|;
block|}
comment|/**    * Reset the "recent" failure counts of all roles    */
DECL|method|resetFailureCounts ()
specifier|public
name|void
name|resetFailureCounts
parameter_list|()
block|{
for|for
control|(
name|RoleStatus
name|roleStatus
range|:
name|getRoleStatusMap
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|long
name|failed
init|=
name|roleStatus
operator|.
name|resetFailedRecently
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Resetting failure count of {}; was {}"
argument_list|,
name|roleStatus
operator|.
name|getName
argument_list|()
argument_list|,
name|failed
argument_list|)
expr_stmt|;
block|}
name|roleHistory
operator|.
name|resetFailedRecently
argument_list|()
expr_stmt|;
block|}
comment|/**    * Escalate operation as triggered by external timer.    * @return a (usually empty) list of cancel/request operations.    */
DECL|method|escalateOutstandingRequests ()
specifier|public
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|escalateOutstandingRequests
parameter_list|()
block|{
return|return
name|roleHistory
operator|.
name|escalateOutstandingRequests
argument_list|()
return|;
block|}
comment|/**    * Cancel any outstanding AA Requests, building up the list of ops to    * cancel, removing them from RoleHistory structures and the RoleStatus    * entries.    * @return a (usually empty) list of cancel/request operations.    */
DECL|method|cancelOutstandingAARequests ()
specifier|public
specifier|synchronized
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|cancelOutstandingAARequests
parameter_list|()
block|{
comment|// get the list of cancel operations
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|operations
init|=
name|roleHistory
operator|.
name|cancelOutstandingAARequests
argument_list|()
decl_stmt|;
for|for
control|(
name|RoleStatus
name|roleStatus
range|:
name|roleStatusMap
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|roleStatus
operator|.
name|isAARequestOutstanding
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Cancelling outstanding AA request for {}"
argument_list|,
name|roleStatus
argument_list|)
expr_stmt|;
name|roleStatus
operator|.
name|cancelOutstandingAARequest
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|operations
return|;
block|}
DECL|method|monitorComponentInstances ()
specifier|public
specifier|synchronized
name|boolean
name|monitorComponentInstances
parameter_list|()
block|{
name|boolean
name|hasChanged
init|=
literal|false
decl_stmt|;
for|for
control|(
name|RoleInstance
name|instance
range|:
name|getLiveContainers
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|instance
operator|.
name|providerRole
operator|.
name|probe
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|boolean
name|ready
init|=
name|instance
operator|.
name|providerRole
operator|.
name|probe
operator|.
name|ping
argument_list|(
literal|null
argument_list|)
operator|.
name|isSuccess
argument_list|()
decl_stmt|;
if|if
condition|(
name|ready
condition|)
block|{
if|if
condition|(
name|instance
operator|.
name|state
operator|!=
name|STATE_READY
condition|)
block|{
name|instance
operator|.
name|state
operator|=
name|STATE_READY
expr_stmt|;
name|hasChanged
operator|=
literal|true
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"State of {} changed to ready"
argument_list|,
name|instance
operator|.
name|role
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|instance
operator|.
name|state
operator|==
name|STATE_READY
condition|)
block|{
name|instance
operator|.
name|state
operator|=
name|STATE_NOT_READY
expr_stmt|;
name|hasChanged
operator|=
literal|true
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"State of {} changed from ready to not ready"
argument_list|,
name|instance
operator|.
name|role
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|hasChanged
return|;
block|}
comment|/**    * Look at the allocation status of one role, and trigger add/release    * actions if the number of desired role instances doesn't equal    * (actual + pending).    *<p>    * MUST be executed from within a synchronized method    *<p>    * @param role role    * @return a list of operations    * @throws SliderInternalStateException if the operation reveals that    * the internal state of the application is inconsistent.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"SynchronizationOnLocalVariableOrMethodParameter"
argument_list|)
DECL|method|reviewOneRole (RoleStatus role)
specifier|private
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|reviewOneRole
parameter_list|(
name|RoleStatus
name|role
parameter_list|)
throws|throws
name|SliderInternalStateException
throws|,
name|TriggerClusterTeardownException
block|{
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|operations
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|long
name|delta
decl_stmt|;
name|long
name|expected
decl_stmt|;
name|String
name|name
init|=
name|role
operator|.
name|getName
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|role
init|)
block|{
name|delta
operator|=
name|role
operator|.
name|getDelta
argument_list|()
expr_stmt|;
name|expected
operator|=
name|role
operator|.
name|getDesired
argument_list|()
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Reviewing "
operator|+
name|role
operator|.
name|getName
argument_list|()
operator|+
literal|": "
operator|+
name|role
operator|.
name|getComponentMetrics
argument_list|()
argument_list|)
expr_stmt|;
name|checkFailureThreshold
argument_list|(
name|role
argument_list|)
expr_stmt|;
if|if
condition|(
name|expected
operator|<
literal|0
condition|)
block|{
comment|// negative value: fail
throw|throw
operator|new
name|TriggerClusterTeardownException
argument_list|(
name|SliderExitCodes
operator|.
name|EXIT_DEPLOYMENT_FAILED
argument_list|,
name|FinalApplicationStatus
operator|.
name|FAILED
argument_list|,
literal|"Negative component count of %d desired for component %s"
argument_list|,
name|expected
argument_list|,
name|role
argument_list|)
throw|;
block|}
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
block|{
comment|// more workers needed than we have -ask for more
name|log
operator|.
name|info
argument_list|(
literal|"{}: Asking for {} more nodes(s) for a total of {} "
argument_list|,
name|name
argument_list|,
name|delta
argument_list|,
name|expected
argument_list|)
expr_stmt|;
if|if
condition|(
name|role
operator|.
name|isAntiAffinePlacement
argument_list|()
condition|)
block|{
name|long
name|pending
init|=
name|delta
decl_stmt|;
if|if
condition|(
name|roleHistory
operator|.
name|canPlaceAANodes
argument_list|()
condition|)
block|{
comment|// build one only if there is none outstanding, the role history knows
comment|// enough about the cluster to ask, and there is somewhere to place
comment|// the node
if|if
condition|(
operator|!
name|role
operator|.
name|isAARequestOutstanding
argument_list|()
condition|)
block|{
comment|// no outstanding AA; try to place things
name|AMRMClient
operator|.
name|ContainerRequest
name|request
init|=
name|createAAContainerRequest
argument_list|(
name|role
argument_list|)
decl_stmt|;
if|if
condition|(
name|request
operator|!=
literal|null
condition|)
block|{
name|pending
operator|--
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Starting an anti-affine request sequence for {} nodes; pending={}"
argument_list|,
name|delta
argument_list|,
name|pending
argument_list|)
expr_stmt|;
name|addContainerRequest
argument_list|(
name|operations
argument_list|,
name|request
argument_list|,
name|role
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"No location for anti-affine request"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Awaiting node map before generating anti-affinity requests"
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|info
argument_list|(
literal|"Setting pending to {}"
argument_list|,
name|pending
argument_list|)
expr_stmt|;
comment|//TODO
name|role
operator|.
name|setAAPending
argument_list|(
name|pending
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|delta
condition|;
name|i
operator|++
control|)
block|{
comment|//get the role history to select a suitable node, if available
name|addContainerRequest
argument_list|(
name|operations
argument_list|,
name|createContainerRequest
argument_list|(
name|role
argument_list|)
argument_list|,
name|role
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"{}: Asking for {} fewer node(s) for a total of {}"
argument_list|,
name|name
argument_list|,
operator|-
name|delta
argument_list|,
name|expected
argument_list|)
expr_stmt|;
comment|// reduce the number expected (i.e. subtract the delta)
name|long
name|excess
init|=
operator|-
name|delta
decl_stmt|;
comment|// how many requests are outstanding? for AA roles, this includes pending
name|long
name|outstandingRequests
init|=
name|role
operator|.
name|getRequested
argument_list|()
operator|+
name|role
operator|.
name|getAAPending
argument_list|()
decl_stmt|;
if|if
condition|(
name|outstandingRequests
operator|>
literal|0
condition|)
block|{
comment|// outstanding requests.
name|int
name|toCancel
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|outstandingRequests
argument_list|,
name|excess
argument_list|)
decl_stmt|;
name|int
name|pendingCancelled
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|role
operator|.
name|getAAPending
argument_list|()
operator|>
literal|0
condition|)
block|{
name|pendingCancelled
operator|=
name|decAAPendingToFloor
argument_list|(
name|role
argument_list|,
name|toCancel
argument_list|)
expr_stmt|;
block|}
name|int
name|remainingToCancel
init|=
name|toCancel
operator|-
name|pendingCancelled
decl_stmt|;
comment|// Delegate to Role History
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|cancellations
init|=
name|roleHistory
operator|.
name|cancelRequestsForRole
argument_list|(
name|role
argument_list|,
name|remainingToCancel
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Found {} outstanding requests to cancel"
argument_list|,
name|cancellations
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|operations
operator|.
name|addAll
argument_list|(
name|cancellations
argument_list|)
expr_stmt|;
if|if
condition|(
name|remainingToCancel
operator|!=
name|cancellations
operator|.
name|size
argument_list|()
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Tracking of outstanding requests is not in sync with the summary statistics:"
operator|+
literal|" expected to be able to cancel {} requests, but got {}"
argument_list|,
name|remainingToCancel
argument_list|,
name|cancellations
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|int
name|requestCancelled
init|=
name|decRequestedContainersToFloor
argument_list|(
name|role
argument_list|,
name|remainingToCancel
argument_list|)
decl_stmt|;
name|excess
operator|-=
name|pendingCancelled
expr_stmt|;
name|excess
operator|-=
name|requestCancelled
expr_stmt|;
assert|assert
name|excess
operator|>=
literal|0
operator|:
literal|"Attempted to cancel too many requests"
assert|;
name|log
operator|.
name|info
argument_list|(
literal|"Submitted {} cancellations, leaving {} to release"
argument_list|,
name|pendingCancelled
operator|+
name|requestCancelled
argument_list|,
name|excess
argument_list|)
expr_stmt|;
if|if
condition|(
name|excess
operator|==
literal|0
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"After cancelling requests, application is now at desired size"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// after the cancellation there may be no excess
if|if
condition|(
name|excess
operator|>
literal|0
condition|)
block|{
comment|// there's an excess, so more to cancel
comment|// get the nodes to release
name|int
name|roleId
init|=
name|role
operator|.
name|getKey
argument_list|()
decl_stmt|;
comment|// enum all active nodes that aren't being released
name|List
argument_list|<
name|RoleInstance
argument_list|>
name|containersToRelease
init|=
name|enumNodesWithRoleId
argument_list|(
name|roleId
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|containersToRelease
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"No containers for component {}"
argument_list|,
name|roleId
argument_list|)
expr_stmt|;
block|}
comment|// filter out all release-in-progress nodes
name|ListIterator
argument_list|<
name|RoleInstance
argument_list|>
name|li
init|=
name|containersToRelease
operator|.
name|listIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|li
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|RoleInstance
name|next
init|=
name|li
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|next
operator|.
name|released
condition|)
block|{
name|li
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
comment|// warn if the desired state can't be reached
name|int
name|numberAvailableForRelease
init|=
name|containersToRelease
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|numberAvailableForRelease
operator|<
name|excess
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Not enough containers to release, have {} and need {} more"
argument_list|,
name|numberAvailableForRelease
argument_list|,
name|excess
operator|-
name|numberAvailableForRelease
argument_list|)
expr_stmt|;
block|}
comment|// ask the release selector to sort the targets
name|containersToRelease
operator|=
name|containerReleaseSelector
operator|.
name|sortCandidates
argument_list|(
name|roleId
argument_list|,
name|containersToRelease
argument_list|)
expr_stmt|;
comment|// crop to the excess
name|List
argument_list|<
name|RoleInstance
argument_list|>
name|finalCandidates
init|=
operator|(
name|excess
operator|<
name|numberAvailableForRelease
operator|)
condition|?
name|containersToRelease
operator|.
name|subList
argument_list|(
literal|0
argument_list|,
operator|(
name|int
operator|)
name|excess
argument_list|)
else|:
name|containersToRelease
decl_stmt|;
comment|// then build up a release operation, logging each container as released
for|for
control|(
name|RoleInstance
name|possible
range|:
name|finalCandidates
control|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Targeting for release: {}"
argument_list|,
name|possible
argument_list|)
expr_stmt|;
name|containerReleaseSubmitted
argument_list|(
name|possible
operator|.
name|container
argument_list|)
expr_stmt|;
name|role
operator|.
name|getProviderRole
argument_list|()
operator|.
name|failedInstances
operator|.
name|offer
argument_list|(
name|possible
argument_list|)
expr_stmt|;
name|operations
operator|.
name|add
argument_list|(
operator|new
name|ContainerReleaseOperation
argument_list|(
name|possible
operator|.
name|getContainerId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// actual + requested == desired
comment|// there's a special case here: clear all pending AA requests
if|if
condition|(
name|role
operator|.
name|getAAPending
argument_list|()
operator|>
literal|0
condition|)
block|{
name|log
operator|.
name|debug
argument_list|(
literal|"Clearing outstanding pending AA requests"
argument_list|)
expr_stmt|;
name|role
operator|.
name|setAAPending
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|// there's now a list of operations to execute
name|log
operator|.
name|debug
argument_list|(
literal|"operations scheduled: {}; updated role: {}"
argument_list|,
name|operations
operator|.
name|size
argument_list|()
argument_list|,
name|role
argument_list|)
expr_stmt|;
return|return
name|operations
return|;
block|}
comment|/**    * Add a container request if the request is non-null    * @param operations operations to add the entry to    * @param containerAsk what to ask for    * @return true if a request was added    */
DECL|method|addContainerRequest (List<AbstractRMOperation> operations, AMRMClient.ContainerRequest containerAsk, RoleStatus role)
specifier|private
name|boolean
name|addContainerRequest
parameter_list|(
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|operations
parameter_list|,
name|AMRMClient
operator|.
name|ContainerRequest
name|containerAsk
parameter_list|,
name|RoleStatus
name|role
parameter_list|)
block|{
if|if
condition|(
name|containerAsk
operator|!=
literal|null
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Container ask is {} and label = {}"
argument_list|,
name|containerAsk
argument_list|,
name|containerAsk
operator|.
name|getNodeLabelExpression
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|askMemory
init|=
name|containerAsk
operator|.
name|getCapability
argument_list|()
operator|.
name|getMemory
argument_list|()
decl_stmt|;
if|if
condition|(
name|askMemory
operator|>
name|this
operator|.
name|containerMaxMemory
condition|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"Memory requested: {}> max of {}"
argument_list|,
name|askMemory
argument_list|,
name|containerMaxMemory
argument_list|)
expr_stmt|;
block|}
name|operations
operator|.
name|add
argument_list|(
operator|new
name|ContainerRequestOperation
argument_list|(
name|containerAsk
argument_list|)
argument_list|)
expr_stmt|;
name|incRequestedContainers
argument_list|(
name|role
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Releases a container based on container id    * @param containerId    * @return    * @throws SliderInternalStateException    */
DECL|method|releaseContainer (ContainerId containerId)
specifier|public
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|releaseContainer
parameter_list|(
name|ContainerId
name|containerId
parameter_list|)
throws|throws
name|SliderInternalStateException
block|{
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|operations
init|=
operator|new
name|ArrayList
argument_list|<
name|AbstractRMOperation
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RoleInstance
argument_list|>
name|activeRoleInstances
init|=
name|cloneOwnedContainerList
argument_list|()
decl_stmt|;
for|for
control|(
name|RoleInstance
name|role
range|:
name|activeRoleInstances
control|)
block|{
if|if
condition|(
name|role
operator|.
name|container
operator|.
name|getId
argument_list|()
operator|.
name|equals
argument_list|(
name|containerId
argument_list|)
condition|)
block|{
name|containerReleaseSubmitted
argument_list|(
name|role
operator|.
name|container
argument_list|)
expr_stmt|;
name|operations
operator|.
name|add
argument_list|(
operator|new
name|ContainerReleaseOperation
argument_list|(
name|role
operator|.
name|getContainerId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|operations
return|;
block|}
comment|/**    * Release all containers.    * @return a list of operations to execute    */
DECL|method|releaseAllContainers ()
specifier|public
specifier|synchronized
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|releaseAllContainers
parameter_list|()
block|{
name|Collection
argument_list|<
name|RoleInstance
argument_list|>
name|targets
init|=
name|cloneOwnedContainerList
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Releasing {} containers"
argument_list|,
name|targets
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|operations
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|targets
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|RoleInstance
name|instance
range|:
name|targets
control|)
block|{
if|if
condition|(
name|instance
operator|.
name|roleId
operator|==
name|SliderKeys
operator|.
name|ROLE_AM_PRIORITY_INDEX
condition|)
block|{
comment|// don't worry about the AM
continue|continue;
block|}
name|Container
name|possible
init|=
name|instance
operator|.
name|container
decl_stmt|;
name|ContainerId
name|id
init|=
name|possible
operator|.
name|getId
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|instance
operator|.
name|released
condition|)
block|{
name|String
name|url
init|=
name|getLogsURLForContainer
argument_list|(
name|possible
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Releasing container. Log: "
operator|+
name|url
argument_list|)
expr_stmt|;
try|try
block|{
name|containerReleaseSubmitted
argument_list|(
name|possible
argument_list|)
expr_stmt|;
comment|// update during finish call
if|if
condition|(
name|serviceTimelinePublisher
operator|!=
literal|null
condition|)
block|{
name|serviceTimelinePublisher
operator|.
name|componentInstanceFinished
argument_list|(
name|instance
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SliderInternalStateException
name|e
parameter_list|)
block|{
name|log
operator|.
name|warn
argument_list|(
literal|"when releasing container {} :"
argument_list|,
name|possible
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|operations
operator|.
name|add
argument_list|(
operator|new
name|ContainerReleaseOperation
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|operations
return|;
block|}
comment|/**    * Event handler for allocated containers: builds up the lists    * of assignment actions (what to run where), and possibly    * a list of operations to perform    * @param allocatedContainers the containers allocated    * @param assignments the assignments of roles to containers    * @param operations any allocation or release operations    */
DECL|method|onContainersAllocated ( List<Container> allocatedContainers, List<ContainerAssignment> assignments, List<AbstractRMOperation> operations)
specifier|public
specifier|synchronized
name|void
name|onContainersAllocated
parameter_list|(
name|List
argument_list|<
name|Container
argument_list|>
name|allocatedContainers
parameter_list|,
name|List
argument_list|<
name|ContainerAssignment
argument_list|>
name|assignments
parameter_list|,
name|List
argument_list|<
name|AbstractRMOperation
argument_list|>
name|operations
parameter_list|)
block|{
name|assignments
operator|.
name|clear
argument_list|()
expr_stmt|;
name|operations
operator|.
name|clear
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|Container
argument_list|>
name|ordered
init|=
name|roleHistory
operator|.
name|prepareAllocationList
argument_list|(
name|allocatedContainers
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"onContainersAllocated(): Total containers allocated = {}"
argument_list|,
name|ordered
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Container
name|container
range|:
name|ordered
control|)
block|{
specifier|final
name|NodeId
name|nodeId
init|=
name|container
operator|.
name|getNodeId
argument_list|()
decl_stmt|;
name|String
name|containerHostInfo
init|=
name|nodeId
operator|.
name|getHost
argument_list|()
operator|+
literal|":"
operator|+
name|nodeId
operator|.
name|getPort
argument_list|()
decl_stmt|;
comment|//get the role
specifier|final
name|ContainerId
name|cid
init|=
name|container
operator|.
name|getId
argument_list|()
decl_stmt|;
specifier|final
name|RoleStatus
name|role
init|=
name|lookupRoleStatus
argument_list|(
name|container
argument_list|)
decl_stmt|;
comment|//inc allocated count -this may need to be dropped in a moment,
comment|// but us needed to update the logic below
name|MutableGaugeInt
name|containersRunning
init|=
name|role
operator|.
name|getComponentMetrics
argument_list|()
operator|.
name|containersRunning
decl_stmt|;
name|incRunningContainers
argument_list|(
name|role
argument_list|)
expr_stmt|;
specifier|final
name|long
name|allocated
init|=
name|containersRunning
operator|.
name|value
argument_list|()
decl_stmt|;
specifier|final
name|long
name|desired
init|=
name|role
operator|.
name|getDesired
argument_list|()
decl_stmt|;
specifier|final
name|String
name|roleName
init|=
name|role
operator|.
name|getName
argument_list|()
decl_stmt|;
specifier|final
name|ContainerAllocationResults
name|allocation
init|=
name|roleHistory
operator|.
name|onContainerAllocated
argument_list|(
name|container
argument_list|,
name|desired
argument_list|,
name|allocated
argument_list|)
decl_stmt|;
specifier|final
name|ContainerAllocationOutcome
name|outcome
init|=
name|allocation
operator|.
name|outcome
decl_stmt|;
comment|// add all requests to the operations list
name|operations
operator|.
name|addAll
argument_list|(
name|allocation
operator|.
name|operations
argument_list|)
expr_stmt|;
comment|//look for condition where we get more back than we asked
if|if
condition|(
name|allocated
operator|>
name|desired
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Discarding surplus {} container {} on {}"
argument_list|,
name|roleName
argument_list|,
name|cid
argument_list|,
name|containerHostInfo
argument_list|)
expr_stmt|;
name|operations
operator|.
name|add
argument_list|(
operator|new
name|ContainerReleaseOperation
argument_list|(
name|cid
argument_list|)
argument_list|)
expr_stmt|;
comment|//register as a surplus node
name|surplusContainers
operator|.
name|add
argument_list|(
name|cid
argument_list|)
expr_stmt|;
name|role
operator|.
name|getComponentMetrics
argument_list|()
operator|.
name|surplusContainers
operator|.
name|incr
argument_list|()
expr_stmt|;
name|containersRunning
operator|.
name|decr
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|decRequestedContainers
argument_list|(
name|role
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Assigning role {} to container"
operator|+
literal|" {},"
operator|+
literal|" on {}:{},"
argument_list|,
name|roleName
argument_list|,
name|cid
argument_list|,
name|nodeId
operator|.
name|getHost
argument_list|()
argument_list|,
name|nodeId
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
name|assignments
operator|.
name|add
argument_list|(
operator|new
name|ContainerAssignment
argument_list|(
name|container
argument_list|,
name|role
argument_list|,
name|outcome
argument_list|)
argument_list|)
expr_stmt|;
comment|//add to the history
name|roleHistory
operator|.
name|onContainerAssigned
argument_list|(
name|container
argument_list|)
expr_stmt|;
comment|// now for AA requests, add some more
if|if
condition|(
name|role
operator|.
name|isAntiAffinePlacement
argument_list|()
condition|)
block|{
name|role
operator|.
name|completeOutstandingAARequest
argument_list|()
expr_stmt|;
comment|// check invariants. The new node must become unavailable.
name|NodeInstance
name|node
init|=
name|roleHistory
operator|.
name|getOrCreateNodeInstance
argument_list|(
name|container
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|canHost
argument_list|(
name|role
operator|.
name|getKey
argument_list|()
argument_list|,
name|role
operator|.
name|getLabelExpression
argument_list|()
argument_list|)
condition|)
block|{
name|log
operator|.
name|error
argument_list|(
literal|"Assigned node still declares as available {}"
argument_list|,
name|node
operator|.
name|toFullString
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|role
operator|.
name|getAAPending
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// still an outstanding AA request: need to issue a new one.
name|log
operator|.
name|info
argument_list|(
literal|"Asking for next container for AA role {}"
argument_list|,
name|roleName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|addContainerRequest
argument_list|(
name|operations
argument_list|,
name|createAAContainerRequest
argument_list|(
name|role
argument_list|)
argument_list|,
name|role
argument_list|)
condition|)
block|{
name|log
operator|.
name|info
argument_list|(
literal|"No capacity in cluster for new requests"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|role
operator|.
name|decAAPending
argument_list|()
expr_stmt|;
block|}
name|log
operator|.
name|debug
argument_list|(
literal|"Current AA role status {}"
argument_list|,
name|role
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"AA request sequence completed for role {}"
argument_list|,
name|role
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * Event handler for the list of active containers on restart.    * Sets the info key {@link StatusKeys#INFO_CONTAINERS_AM_RESTART}    * to the size of the list passed down (and does not set it if none were)    * @param liveContainers the containers allocated    * @return true if a rebuild took place (even if size 0)    * @throws RuntimeException on problems    */
DECL|method|rebuildModelFromRestart (List<Container> liveContainers)
specifier|private
name|boolean
name|rebuildModelFromRestart
parameter_list|(
name|List
argument_list|<
name|Container
argument_list|>
name|liveContainers
parameter_list|)
throws|throws
name|BadClusterStateException
block|{
if|if
condition|(
name|liveContainers
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|Container
name|container
range|:
name|liveContainers
control|)
block|{
name|addRestartedContainer
argument_list|(
name|container
argument_list|)
expr_stmt|;
block|}
name|app
operator|.
name|setNumberOfRunningContainers
argument_list|(
operator|(
name|long
operator|)
name|liveContainers
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Add a restarted container by walking it through the create/submit/start    * lifecycle, so building up the internal structures    * @param container container that was running before the AM restarted    * @throws RuntimeException on problems    */
DECL|method|addRestartedContainer (Container container)
specifier|private
name|void
name|addRestartedContainer
parameter_list|(
name|Container
name|container
parameter_list|)
throws|throws
name|BadClusterStateException
block|{
name|String
name|containerHostInfo
init|=
name|container
operator|.
name|getNodeId
argument_list|()
operator|.
name|getHost
argument_list|()
operator|+
literal|":"
operator|+
name|container
operator|.
name|getNodeId
argument_list|()
operator|.
name|getPort
argument_list|()
decl_stmt|;
comment|// get the container ID
name|ContainerId
name|cid
init|=
name|container
operator|.
name|getId
argument_list|()
decl_stmt|;
comment|// get the role
name|int
name|roleId
init|=
name|ContainerPriority
operator|.
name|extractRole
argument_list|(
name|container
argument_list|)
decl_stmt|;
name|RoleStatus
name|role
init|=
name|lookupRoleStatus
argument_list|(
name|roleId
argument_list|)
decl_stmt|;
comment|// increment its count
name|incRunningContainers
argument_list|(
name|role
argument_list|)
expr_stmt|;
name|String
name|roleName
init|=
name|role
operator|.
name|getName
argument_list|()
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Rebuilding container {} in role {} on {},"
argument_list|,
name|cid
argument_list|,
name|roleName
argument_list|,
name|containerHostInfo
argument_list|)
expr_stmt|;
comment|//update app state internal structures and maps
comment|//TODO recover the component instance name from zk registry ?
name|RoleInstance
name|instance
init|=
operator|new
name|RoleInstance
argument_list|(
name|container
argument_list|)
decl_stmt|;
name|instance
operator|.
name|command
operator|=
name|roleName
expr_stmt|;
name|instance
operator|.
name|role
operator|=
name|roleName
expr_stmt|;
name|instance
operator|.
name|roleId
operator|=
name|roleId
expr_stmt|;
name|instance
operator|.
name|environment
operator|=
operator|new
name|String
index|[
literal|0
index|]
expr_stmt|;
name|instance
operator|.
name|container
operator|=
name|container
expr_stmt|;
name|instance
operator|.
name|createTime
operator|=
name|now
argument_list|()
expr_stmt|;
name|instance
operator|.
name|state
operator|=
name|STATE_LIVE
expr_stmt|;
name|instance
operator|.
name|appVersion
operator|=
name|SliderKeys
operator|.
name|APP_VERSION_UNKNOWN
expr_stmt|;
name|putOwnedContainer
argument_list|(
name|cid
argument_list|,
name|instance
argument_list|)
expr_stmt|;
comment|//role history gets told
name|roleHistory
operator|.
name|onContainerAssigned
argument_list|(
name|container
argument_list|)
expr_stmt|;
comment|// pretend the container has just had its start actions submitted
name|containerStartSubmitted
argument_list|(
name|container
argument_list|,
name|instance
argument_list|)
expr_stmt|;
comment|// now pretend it has just started
name|innerOnNodeManagerContainerStarted
argument_list|(
name|cid
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"AppState{"
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"applicationLive="
argument_list|)
operator|.
name|append
argument_list|(
name|applicationLive
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", live nodes="
argument_list|)
operator|.
name|append
argument_list|(
name|liveNodes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Build map of role ID-> name    * @return    */
DECL|method|buildNamingMap ()
specifier|public
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|buildNamingMap
parameter_list|()
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|RoleStatus
argument_list|>
name|statusMap
init|=
name|getRoleStatusMap
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|Integer
argument_list|,
name|String
argument_list|>
name|naming
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|statusMap
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Integer
argument_list|,
name|RoleStatus
argument_list|>
name|entry
range|:
name|statusMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|naming
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|naming
return|;
block|}
DECL|method|setServiceTimelinePublisher (ServiceTimelinePublisher serviceTimelinePublisher)
specifier|public
name|void
name|setServiceTimelinePublisher
parameter_list|(
name|ServiceTimelinePublisher
name|serviceTimelinePublisher
parameter_list|)
block|{
name|this
operator|.
name|serviceTimelinePublisher
operator|=
name|serviceTimelinePublisher
expr_stmt|;
block|}
block|}
end_class

end_unit

