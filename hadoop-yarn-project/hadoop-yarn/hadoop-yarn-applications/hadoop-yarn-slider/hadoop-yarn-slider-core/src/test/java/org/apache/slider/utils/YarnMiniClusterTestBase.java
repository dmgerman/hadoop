begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *       http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.slider.utils
package|package
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|utils
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|MiniDFSCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|ServiceOperations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|server
operator|.
name|MiniYARNCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|client
operator|.
name|SliderClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|service
operator|.
name|conf
operator|.
name|SliderExitCodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|service
operator|.
name|conf
operator|.
name|SliderXmlConfKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|params
operator|.
name|ActionFreezeArgs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|service
operator|.
name|client
operator|.
name|params
operator|.
name|Arguments
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|service
operator|.
name|client
operator|.
name|params
operator|.
name|SliderActions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|Duration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|SliderFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|SliderUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|ErrorStrings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|exceptions
operator|.
name|SliderException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|main
operator|.
name|ServiceLauncher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|appmaster
operator|.
name|SliderAppMaster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|BeforeClass
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Rule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|Timeout
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|utils
operator|.
name|KeysForTests
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Base class for mini cluster tests -creates a field for the  * mini yarn cluster.  */
end_comment

begin_class
DECL|class|YarnMiniClusterTestBase
specifier|public
specifier|abstract
class|class
name|YarnMiniClusterTestBase
extends|extends
name|SliderTestBase
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|YarnMiniClusterTestBase
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Mini YARN cluster only.    */
DECL|field|CLUSTER_GO_LIVE_TIME
specifier|public
specifier|static
specifier|final
name|int
name|CLUSTER_GO_LIVE_TIME
init|=
literal|3
operator|*
literal|60
operator|*
literal|1000
decl_stmt|;
DECL|field|CLUSTER_STOP_TIME
specifier|public
specifier|static
specifier|final
name|int
name|CLUSTER_STOP_TIME
init|=
literal|1
operator|*
literal|60
operator|*
literal|1000
decl_stmt|;
DECL|field|SIGTERM
specifier|public
specifier|static
specifier|final
name|int
name|SIGTERM
init|=
operator|-
literal|15
decl_stmt|;
DECL|field|SIGKILL
specifier|public
specifier|static
specifier|final
name|int
name|SIGKILL
init|=
operator|-
literal|9
decl_stmt|;
DECL|field|SIGSTOP
specifier|public
specifier|static
specifier|final
name|int
name|SIGSTOP
init|=
operator|-
literal|17
decl_stmt|;
DECL|field|NO_ARCHIVE_DEFINED
specifier|public
specifier|static
specifier|final
name|String
name|NO_ARCHIVE_DEFINED
init|=
literal|"Archive configuration "
operator|+
literal|"option not set: "
decl_stmt|;
comment|/**    * RAM for the YARN containers: {@value}.    */
DECL|field|YRAM
specifier|public
specifier|static
specifier|final
name|String
name|YRAM
init|=
literal|"256"
decl_stmt|;
DECL|field|FIFO_SCHEDULER
specifier|public
specifier|static
specifier|final
name|String
name|FIFO_SCHEDULER
init|=
literal|"org.apache.hadoop.yarn.server"
operator|+
literal|".resourcemanager.scheduler.fifo.FifoScheduler"
decl_stmt|;
DECL|field|SLIDER_CONFIG
specifier|public
specifier|static
specifier|final
name|YarnConfiguration
name|SLIDER_CONFIG
init|=
name|SliderUtils
operator|.
name|createConfiguration
argument_list|()
decl_stmt|;
DECL|field|killSupported
specifier|private
specifier|static
name|boolean
name|killSupported
decl_stmt|;
static|static
block|{
name|SLIDER_CONFIG
operator|.
name|setInt
argument_list|(
name|SliderXmlConfKeys
operator|.
name|KEY_AM_RESTART_LIMIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SLIDER_CONFIG
operator|.
name|setInt
argument_list|(
name|YarnConfiguration
operator|.
name|RM_AM_MAX_ATTEMPTS
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|SLIDER_CONFIG
operator|.
name|setBoolean
argument_list|(
name|YarnConfiguration
operator|.
name|NM_PMEM_CHECK_ENABLED
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|SLIDER_CONFIG
operator|.
name|setBoolean
argument_list|(
name|YarnConfiguration
operator|.
name|NM_VMEM_CHECK_ENABLED
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|SLIDER_CONFIG
operator|.
name|setBoolean
argument_list|(
name|SliderXmlConfKeys
operator|.
name|KEY_SLIDER_AM_DEPENDENCY_CHECKS_DISABLED
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|SLIDER_CONFIG
operator|.
name|setInt
argument_list|(
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_MINIMUM_ALLOCATION_MB
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|field|thawWaitTime
specifier|private
name|int
name|thawWaitTime
init|=
name|DEFAULT_THAW_WAIT_TIME_SECONDS
operator|*
literal|1000
decl_stmt|;
DECL|field|freezeWaitTime
specifier|private
name|int
name|freezeWaitTime
init|=
name|DEFAULT_TEST_FREEZE_WAIT_TIME_SECONDS
operator|*
literal|1000
decl_stmt|;
DECL|field|sliderTestTimeout
specifier|private
name|int
name|sliderTestTimeout
init|=
name|DEFAULT_TEST_TIMEOUT_SECONDS
operator|*
literal|1000
decl_stmt|;
DECL|field|teardownKillall
specifier|private
name|boolean
name|teardownKillall
init|=
name|DEFAULT_TEARDOWN_KILLALL
decl_stmt|;
comment|/**    * This is set in a system property.    */
annotation|@
name|Rule
DECL|field|testTimeout
specifier|public
name|Timeout
name|testTimeout
init|=
operator|new
name|Timeout
argument_list|(
name|getTimeOptionMillis
argument_list|(
name|getTestConfiguration
argument_list|()
argument_list|,
name|KEY_TEST_TIMEOUT
argument_list|,
name|DEFAULT_TEST_TIMEOUT_SECONDS
operator|*
literal|1000
argument_list|)
argument_list|)
decl_stmt|;
DECL|field|hdfsCluster
specifier|private
name|MiniDFSCluster
name|hdfsCluster
decl_stmt|;
DECL|field|miniCluster
specifier|private
name|MiniYARNCluster
name|miniCluster
decl_stmt|;
DECL|field|switchToImageDeploy
specifier|private
name|boolean
name|switchToImageDeploy
init|=
literal|false
decl_stmt|;
DECL|field|imageIsRemote
specifier|private
name|boolean
name|imageIsRemote
init|=
literal|false
decl_stmt|;
DECL|field|remoteImageURI
specifier|private
name|URI
name|remoteImageURI
decl_stmt|;
DECL|field|clustersToTeardown
specifier|private
name|List
argument_list|<
name|SliderClient
argument_list|>
name|clustersToTeardown
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|clusterCount
specifier|private
name|int
name|clusterCount
init|=
literal|1
decl_stmt|;
comment|/**    * Clent side test: validate system env before launch.    */
annotation|@
name|BeforeClass
DECL|method|checkClientEnv ()
specifier|public
specifier|static
name|void
name|checkClientEnv
parameter_list|()
throws|throws
name|IOException
throws|,
name|SliderException
block|{
name|SliderUtils
operator|.
name|validateSliderClientEnvironment
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Work out if kill is supported.    */
annotation|@
name|BeforeClass
DECL|method|checkKillSupport ()
specifier|public
specifier|static
name|void
name|checkKillSupport
parameter_list|()
block|{
name|killSupported
operator|=
operator|!
name|Shell
operator|.
name|WINDOWS
expr_stmt|;
block|}
DECL|method|getKillSupported ()
specifier|protected
specifier|static
name|boolean
name|getKillSupported
parameter_list|()
block|{
return|return
name|killSupported
return|;
block|}
DECL|method|getMiniCluster ()
specifier|protected
name|MiniYARNCluster
name|getMiniCluster
parameter_list|()
block|{
return|return
name|miniCluster
return|;
block|}
comment|/**    * Probe for the disks being healthy in a mini cluster. Only the first    * NM is checked.    *    * @param miniCluster    */
DECL|method|assertMiniClusterDisksHealthy ( MiniYARNCluster miniCluster)
specifier|public
specifier|static
name|void
name|assertMiniClusterDisksHealthy
parameter_list|(
name|MiniYARNCluster
name|miniCluster
parameter_list|)
block|{
name|boolean
name|healthy
init|=
name|miniCluster
operator|.
name|getNodeManager
argument_list|(
literal|0
argument_list|)
operator|.
name|getNodeHealthChecker
argument_list|()
operator|.
name|getDiskHandler
argument_list|()
operator|.
name|areDisksHealthy
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Disks on test cluster unhealthy âmay be full"
argument_list|,
name|healthy
argument_list|)
expr_stmt|;
block|}
comment|/**    * Inner work building the mini dfs cluster.    *    * @param name    * @param conf    * @return    */
DECL|method|buildMiniHDFSCluster ( String name, YarnConfiguration conf)
specifier|public
specifier|static
name|MiniDFSCluster
name|buildMiniHDFSCluster
parameter_list|(
name|String
name|name
parameter_list|,
name|YarnConfiguration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|assertNativeLibrariesPresent
argument_list|()
expr_stmt|;
name|File
name|baseDir
init|=
operator|new
name|File
argument_list|(
literal|"./target/hdfs"
argument_list|,
name|name
argument_list|)
operator|.
name|getAbsoluteFile
argument_list|()
decl_stmt|;
comment|//use file: to rm it recursively
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|baseDir
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|MiniDFSCluster
operator|.
name|HDFS_MINIDFS_BASEDIR
argument_list|,
name|baseDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|MiniDFSCluster
operator|.
name|Builder
name|builder
init|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
name|builder
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
name|cluster
return|;
block|}
DECL|method|buildFsDefaultName (MiniDFSCluster miniDFSCluster)
specifier|public
specifier|static
name|String
name|buildFsDefaultName
parameter_list|(
name|MiniDFSCluster
name|miniDFSCluster
parameter_list|)
block|{
if|if
condition|(
name|miniDFSCluster
operator|!=
literal|null
condition|)
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"hdfs://localhost:%d/"
argument_list|,
name|miniDFSCluster
operator|.
name|getNameNodePort
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|"file:///"
return|;
block|}
block|}
comment|/**    * Assert that an operation failed because a cluster is in use.    *    * @param e exception    */
DECL|method|assertFailureClusterInUse (SliderException e)
specifier|public
specifier|static
name|void
name|assertFailureClusterInUse
parameter_list|(
name|SliderException
name|e
parameter_list|)
block|{
name|assertExceptionDetails
argument_list|(
name|e
argument_list|,
name|SliderExitCodes
operator|.
name|EXIT_APPLICATION_IN_USE
argument_list|,
name|ErrorStrings
operator|.
name|E_CLUSTER_RUNNING
argument_list|)
expr_stmt|;
block|}
DECL|method|buildClustername (String clustername)
specifier|protected
name|String
name|buildClustername
parameter_list|(
name|String
name|clustername
parameter_list|)
block|{
if|if
condition|(
name|SliderUtils
operator|.
name|isSet
argument_list|(
name|clustername
argument_list|)
condition|)
block|{
return|return
name|clustername
return|;
block|}
else|else
block|{
return|return
name|createClusterName
argument_list|()
return|;
block|}
block|}
comment|/**    * Create the cluster name from the method name and an auto-incrementing    * counter.    *    * @return a cluster name    */
DECL|method|createClusterName ()
specifier|protected
name|String
name|createClusterName
parameter_list|()
block|{
name|String
name|base
init|=
name|methodName
operator|.
name|getMethodName
argument_list|()
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
decl_stmt|;
if|if
condition|(
name|clusterCount
operator|++
operator|>
literal|1
condition|)
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%s-%d"
argument_list|,
name|base
argument_list|,
name|clusterCount
argument_list|)
return|;
block|}
return|return
name|base
return|;
block|}
annotation|@
name|Override
DECL|method|setup ()
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|setup
argument_list|()
expr_stmt|;
name|Configuration
name|testConf
init|=
name|getTestConfiguration
argument_list|()
decl_stmt|;
name|thawWaitTime
operator|=
name|getTimeOptionMillis
argument_list|(
name|testConf
argument_list|,
name|KEY_TEST_THAW_WAIT_TIME
argument_list|,
name|thawWaitTime
argument_list|)
expr_stmt|;
name|freezeWaitTime
operator|=
name|getTimeOptionMillis
argument_list|(
name|testConf
argument_list|,
name|KEY_TEST_FREEZE_WAIT_TIME
argument_list|,
name|freezeWaitTime
argument_list|)
expr_stmt|;
name|sliderTestTimeout
operator|=
name|getTimeOptionMillis
argument_list|(
name|testConf
argument_list|,
name|KEY_TEST_TIMEOUT
argument_list|,
name|sliderTestTimeout
argument_list|)
expr_stmt|;
name|teardownKillall
operator|=
name|testConf
operator|.
name|getBoolean
argument_list|(
name|KEY_TEST_TEARDOWN_KILLALL
argument_list|,
name|teardownKillall
argument_list|)
expr_stmt|;
block|}
annotation|@
name|After
DECL|method|teardown ()
specifier|public
name|void
name|teardown
parameter_list|()
block|{
name|describe
argument_list|(
literal|"teardown"
argument_list|)
expr_stmt|;
name|stopRunningClusters
argument_list|()
expr_stmt|;
name|stopMiniCluster
argument_list|()
expr_stmt|;
block|}
DECL|method|addToTeardown (SliderClient client)
specifier|protected
name|void
name|addToTeardown
parameter_list|(
name|SliderClient
name|client
parameter_list|)
block|{
name|clustersToTeardown
operator|.
name|add
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
DECL|method|addToTeardown (ServiceLauncher<SliderClient> launcher)
specifier|protected
name|void
name|addToTeardown
parameter_list|(
name|ServiceLauncher
argument_list|<
name|SliderClient
argument_list|>
name|launcher
parameter_list|)
block|{
if|if
condition|(
name|launcher
operator|!=
literal|null
condition|)
block|{
name|SliderClient
name|sliderClient
init|=
name|launcher
operator|.
name|getService
argument_list|()
decl_stmt|;
if|if
condition|(
name|sliderClient
operator|!=
literal|null
condition|)
block|{
name|addToTeardown
argument_list|(
name|sliderClient
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Kill any java process with the given grep pattern.    *    * @param grepString string to grep for    */
DECL|method|killJavaProcesses (String grepString, int signal)
specifier|public
name|int
name|killJavaProcesses
parameter_list|(
name|String
name|grepString
parameter_list|,
name|int
name|signal
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|String
index|[]
name|commandString
decl_stmt|;
if|if
condition|(
operator|!
name|Shell
operator|.
name|WINDOWS
condition|)
block|{
name|String
name|killCommand
init|=
name|String
operator|.
name|format
argument_list|(
literal|"jps -l| grep %s | awk '{print $1}' | xargs kill %d"
argument_list|,
name|grepString
argument_list|,
name|signal
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Command command = {}"
argument_list|,
name|killCommand
argument_list|)
expr_stmt|;
name|commandString
operator|=
operator|new
name|String
index|[]
block|{
literal|"bash"
block|,
literal|"-c"
block|,
name|killCommand
block|}
expr_stmt|;
block|}
else|else
block|{
comment|// windows
if|if
condition|(
operator|!
name|killSupported
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|// "jps -l | grep "String" | awk "{print $1}" | xargs -n 1 taskkill /PID"
name|String
name|killCommand
init|=
name|String
operator|.
name|format
argument_list|(
literal|"jps -l | grep %s | gawk '{print $1}' | xargs -n 1 taskkill /f "
operator|+
literal|"/PID"
argument_list|,
name|grepString
argument_list|)
decl_stmt|;
name|commandString
operator|=
operator|new
name|String
index|[]
block|{
literal|"CMD"
block|,
literal|"/C"
block|,
name|killCommand
block|}
expr_stmt|;
block|}
name|Process
name|command
init|=
operator|new
name|ProcessBuilder
argument_list|(
name|commandString
argument_list|)
operator|.
name|start
argument_list|()
decl_stmt|;
name|int
name|exitCode
init|=
name|command
operator|.
name|waitFor
argument_list|()
decl_stmt|;
name|logStdOutStdErr
argument_list|(
name|command
argument_list|)
expr_stmt|;
return|return
name|exitCode
return|;
block|}
comment|/**    * Kill all processes which match one of the list of grepstrings.    *    * @param greps    * @param signal    */
DECL|method|killJavaProcesses (List<String> greps, int signal)
specifier|public
name|void
name|killJavaProcesses
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|greps
parameter_list|,
name|int
name|signal
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
for|for
control|(
name|String
name|grep
range|:
name|greps
control|)
block|{
name|killJavaProcesses
argument_list|(
name|grep
argument_list|,
name|signal
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getConfiguration ()
specifier|protected
name|YarnConfiguration
name|getConfiguration
parameter_list|()
block|{
return|return
name|SLIDER_CONFIG
return|;
block|}
comment|/**    * Stop any running cluster that has been added.    */
DECL|method|stopRunningClusters ()
specifier|public
name|void
name|stopRunningClusters
parameter_list|()
block|{
for|for
control|(
name|SliderClient
name|client
range|:
name|clustersToTeardown
control|)
block|{
name|maybeStopCluster
argument_list|(
name|client
argument_list|,
name|client
operator|.
name|getDeployedClusterName
argument_list|()
argument_list|,
literal|"Teardown at end of test case"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|stopMiniCluster ()
specifier|public
name|void
name|stopMiniCluster
parameter_list|()
block|{
name|Log
name|commonslog
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|YarnMiniClusterTestBase
operator|.
name|class
argument_list|)
decl_stmt|;
name|ServiceOperations
operator|.
name|stopQuietly
argument_list|(
name|commonslog
argument_list|,
name|miniCluster
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdfsCluster
operator|!=
literal|null
condition|)
block|{
name|hdfsCluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Create and start a minicluster.    *    * @param name             cluster/test name; if empty one is created from    *                         the junit method    * @param conf             configuration to use    * @param noOfNodeManagers #of NMs    * @param numLocalDirs     #of local dirs    * @param numLogDirs       #of log dirs    * @param startHDFS        create an HDFS mini cluster    * @return the name of the cluster    */
DECL|method|createMiniCluster (String name, YarnConfiguration conf, int noOfNodeManagers, int numLocalDirs, int numLogDirs, boolean startHDFS)
specifier|protected
name|String
name|createMiniCluster
parameter_list|(
name|String
name|name
parameter_list|,
name|YarnConfiguration
name|conf
parameter_list|,
name|int
name|noOfNodeManagers
parameter_list|,
name|int
name|numLocalDirs
parameter_list|,
name|int
name|numLogDirs
parameter_list|,
name|boolean
name|startHDFS
parameter_list|)
throws|throws
name|IOException
block|{
name|assertNativeLibrariesPresent
argument_list|()
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|YarnConfiguration
operator|.
name|RM_SCHEDULER_MINIMUM_ALLOCATION_MB
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|YarnConfiguration
operator|.
name|RM_SCHEDULER
argument_list|,
name|FIFO_SCHEDULER
argument_list|)
expr_stmt|;
name|patchDiskCapacityLimits
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|SliderUtils
operator|.
name|patchConfiguration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|name
operator|=
name|buildClustername
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|miniCluster
operator|=
operator|new
name|MiniYARNCluster
argument_list|(
name|name
argument_list|,
name|noOfNodeManagers
argument_list|,
name|numLocalDirs
argument_list|,
name|numLogDirs
argument_list|)
expr_stmt|;
name|miniCluster
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|miniCluster
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// health check
name|assertMiniClusterDisksHealthy
argument_list|(
name|miniCluster
argument_list|)
expr_stmt|;
if|if
condition|(
name|startHDFS
condition|)
block|{
name|createMiniHDFSCluster
argument_list|(
name|name
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
DECL|method|patchDiskCapacityLimits (YarnConfiguration conf)
specifier|public
name|void
name|patchDiskCapacityLimits
parameter_list|(
name|YarnConfiguration
name|conf
parameter_list|)
block|{
name|conf
operator|.
name|setFloat
argument_list|(
name|YarnConfiguration
operator|.
name|NM_MAX_PER_DISK_UTILIZATION_PERCENTAGE
argument_list|,
literal|99.0f
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|SliderXmlConfKeys
operator|.
name|DFS_NAMENODE_DU_RESERVED_KEY
argument_list|,
literal|2
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
literal|"yarn.nodemanager.disk-health-checker.enable"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a mini HDFS cluster and save it to the hdfsClusterField.    *    * @param name    * @param conf    */
DECL|method|createMiniHDFSCluster (String name, YarnConfiguration conf)
specifier|public
name|void
name|createMiniHDFSCluster
parameter_list|(
name|String
name|name
parameter_list|,
name|YarnConfiguration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|hdfsCluster
operator|=
name|buildMiniHDFSCluster
argument_list|(
name|name
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Launch the client with the specific args against the MiniMR cluster    * launcher i.e. expected to have successfully completed.    *    * @param conf configuration    * @param args arg list    * @return the return code    */
DECL|method|launchClientAgainstMiniMR ( Configuration conf, List args)
specifier|protected
name|ServiceLauncher
argument_list|<
name|SliderClient
argument_list|>
name|launchClientAgainstMiniMR
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|List
name|args
parameter_list|)
throws|throws
name|Throwable
block|{
name|ServiceLauncher
argument_list|<
name|SliderClient
argument_list|>
name|launcher
init|=
name|launchClientNoExitCodeCheck
argument_list|(
name|conf
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|int
name|exited
init|=
name|launcher
operator|.
name|getServiceExitCode
argument_list|()
decl_stmt|;
if|if
condition|(
name|exited
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|SliderException
argument_list|(
name|exited
argument_list|,
literal|"Launch failed with exit code "
operator|+
name|exited
argument_list|)
throw|;
block|}
return|return
name|launcher
return|;
block|}
comment|/**    * Launch the client with the specific args against the MiniMR cluster    * without any checks for exit codes.    *    * @param conf configuration    * @param args arg list    * @return the return code    */
DECL|method|launchClientNoExitCodeCheck ( Configuration conf, List args)
specifier|public
name|ServiceLauncher
argument_list|<
name|SliderClient
argument_list|>
name|launchClientNoExitCodeCheck
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|List
name|args
parameter_list|)
throws|throws
name|Throwable
block|{
name|assertNotNull
argument_list|(
name|miniCluster
argument_list|)
expr_stmt|;
return|return
name|launchClientAgainstRM
argument_list|(
name|getRMAddr
argument_list|()
argument_list|,
name|args
argument_list|,
name|conf
argument_list|)
return|;
block|}
comment|/**    * Kill all Slider Services.    *    * @param signal    */
DECL|method|killAM (int signal)
specifier|public
name|int
name|killAM
parameter_list|(
name|int
name|signal
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|killJavaProcesses
argument_list|(
name|SliderAppMaster
operator|.
name|SERVICE_CLASSNAME_SHORT
argument_list|,
name|signal
argument_list|)
return|;
block|}
DECL|method|logStdOutStdErr (Process p)
specifier|public
name|void
name|logStdOutStdErr
parameter_list|(
name|Process
name|p
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|BufferedReader
name|br
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|p
operator|.
name|getInputStream
argument_list|()
argument_list|)
argument_list|)
init|)
block|{
name|String
name|line
init|=
name|br
operator|.
name|readLine
argument_list|()
decl_stmt|;
while|while
condition|(
name|line
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|line
operator|=
name|br
operator|.
name|readLine
argument_list|()
expr_stmt|;
block|}
block|}
try|try
init|(
name|BufferedReader
name|br
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|p
operator|.
name|getErrorStream
argument_list|()
argument_list|)
argument_list|)
init|)
block|{
name|String
name|line
init|=
name|br
operator|.
name|readLine
argument_list|()
decl_stmt|;
while|while
condition|(
name|line
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|line
operator|=
name|br
operator|.
name|readLine
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * List any java process.    */
DECL|method|lsJavaProcesses ()
specifier|public
name|void
name|lsJavaProcesses
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|IOException
block|{
name|Process
name|bash
init|=
operator|new
name|ProcessBuilder
argument_list|(
literal|"jps"
argument_list|,
literal|"-v"
argument_list|)
operator|.
name|start
argument_list|()
decl_stmt|;
name|bash
operator|.
name|waitFor
argument_list|()
expr_stmt|;
name|logStdOutStdErr
argument_list|(
name|bash
argument_list|)
expr_stmt|;
block|}
DECL|method|getTestConfiguration ()
specifier|public
name|YarnConfiguration
name|getTestConfiguration
parameter_list|()
block|{
name|YarnConfiguration
name|conf
init|=
name|getConfiguration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|addResource
argument_list|(
name|SLIDER_TEST_XML
argument_list|)
expr_stmt|;
return|return
name|conf
return|;
block|}
DECL|method|getRMAddr ()
specifier|protected
name|String
name|getRMAddr
parameter_list|()
block|{
name|assertNotNull
argument_list|(
name|miniCluster
argument_list|)
expr_stmt|;
name|String
name|addr
init|=
name|miniCluster
operator|.
name|getConfig
argument_list|()
operator|.
name|get
argument_list|(
name|YarnConfiguration
operator|.
name|RM_ADDRESS
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|addr
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|assertNotEquals
argument_list|(
literal|""
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
comment|/**    * Return the default filesystem, which is HDFS if the miniDFS cluster is    * up, file:// if not.    *    * @return a filesystem string to pass down    */
DECL|method|getFsDefaultName ()
specifier|protected
name|String
name|getFsDefaultName
parameter_list|()
block|{
return|return
name|buildFsDefaultName
argument_list|(
name|hdfsCluster
argument_list|)
return|;
block|}
comment|/**    * Create or build a cluster (the action is set by the first verb).    * @param action operation to invoke: SliderActions.ACTION_CREATE or    *               SliderActions.ACTION_BUILD    * @param clustername cluster name    * @param extraArgs list of extra args to add to the creation command    * @param deleteExistingData should the data of any existing cluster    * of this name be deleted    * @param blockUntilRunning block until the AM is running    * @return launcher which will have executed the command.    */
DECL|method|createOrBuildCluster (String action, String clustername, List<String> extraArgs, boolean deleteExistingData, boolean blockUntilRunning)
specifier|public
name|ServiceLauncher
argument_list|<
name|SliderClient
argument_list|>
name|createOrBuildCluster
parameter_list|(
name|String
name|action
parameter_list|,
name|String
name|clustername
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|extraArgs
parameter_list|,
name|boolean
name|deleteExistingData
parameter_list|,
name|boolean
name|blockUntilRunning
parameter_list|)
throws|throws
name|Throwable
block|{
name|assertNotNull
argument_list|(
name|clustername
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|miniCluster
argument_list|)
expr_stmt|;
comment|// update action should keep existing data
name|Configuration
name|config
init|=
name|miniCluster
operator|.
name|getConfig
argument_list|()
decl_stmt|;
if|if
condition|(
name|deleteExistingData
operator|&&
operator|!
name|SliderActions
operator|.
name|ACTION_UPDATE
operator|.
name|equals
argument_list|(
name|action
argument_list|)
condition|)
block|{
name|FileSystem
name|dfs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
operator|new
name|URI
argument_list|(
name|getFsDefaultName
argument_list|()
argument_list|)
argument_list|,
name|config
argument_list|)
decl_stmt|;
name|SliderFileSystem
name|sliderFileSystem
init|=
operator|new
name|SliderFileSystem
argument_list|(
name|dfs
argument_list|,
name|config
argument_list|)
decl_stmt|;
name|Path
name|clusterDir
init|=
name|sliderFileSystem
operator|.
name|buildClusterDirPath
argument_list|(
name|clustername
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"deleting instance data at {}"
argument_list|,
name|clusterDir
argument_list|)
expr_stmt|;
comment|//this is a safety check to stop us doing something stupid like deleting /
name|assertTrue
argument_list|(
name|clusterDir
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
literal|"/.slider/"
argument_list|)
argument_list|)
expr_stmt|;
name|rigorousDelete
argument_list|(
name|sliderFileSystem
argument_list|,
name|clusterDir
argument_list|,
literal|60000
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|argsList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|argsList
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|action
argument_list|,
name|clustername
argument_list|,
name|Arguments
operator|.
name|ARG_MANAGER
argument_list|,
name|getRMAddr
argument_list|()
argument_list|,
name|Arguments
operator|.
name|ARG_FILESYSTEM
argument_list|,
name|getFsDefaultName
argument_list|()
argument_list|,
name|Arguments
operator|.
name|ARG_DEBUG
argument_list|)
argument_list|)
expr_stmt|;
name|argsList
operator|.
name|addAll
argument_list|(
name|getExtraCLIArgs
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|extraArgs
operator|!=
literal|null
condition|)
block|{
name|argsList
operator|.
name|addAll
argument_list|(
name|extraArgs
argument_list|)
expr_stmt|;
block|}
name|ServiceLauncher
argument_list|<
name|SliderClient
argument_list|>
name|launcher
init|=
name|launchClientAgainstMiniMR
argument_list|(
comment|//config includes RM binding info
operator|new
name|YarnConfiguration
argument_list|(
name|config
argument_list|)
argument_list|,
comment|//varargs list of command line params
name|argsList
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|launcher
operator|.
name|getServiceExitCode
argument_list|()
argument_list|)
expr_stmt|;
name|SliderClient
name|client
init|=
name|launcher
operator|.
name|getService
argument_list|()
decl_stmt|;
if|if
condition|(
name|blockUntilRunning
condition|)
block|{
name|client
operator|.
name|monitorAppToRunning
argument_list|(
operator|new
name|Duration
argument_list|(
name|CLUSTER_GO_LIVE_TIME
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|launcher
return|;
block|}
comment|/**    * Delete with some pauses and backoff; designed to handle slow delete    * operation in windows.    */
DECL|method|rigorousDelete ( SliderFileSystem sliderFileSystem, Path path, long timeout)
specifier|public
name|void
name|rigorousDelete
parameter_list|(
name|SliderFileSystem
name|sliderFileSystem
parameter_list|,
name|Path
name|path
parameter_list|,
name|long
name|timeout
parameter_list|)
throws|throws
name|IOException
throws|,
name|SliderException
block|{
if|if
condition|(
name|path
operator|.
name|toUri
argument_list|()
operator|.
name|getScheme
argument_list|()
operator|==
literal|"file"
condition|)
block|{
name|File
name|dir
init|=
operator|new
name|File
argument_list|(
name|path
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|rigorousDelete
argument_list|(
name|dir
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Duration
name|duration
init|=
operator|new
name|Duration
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
name|duration
operator|.
name|start
argument_list|()
expr_stmt|;
name|FileSystem
name|dfs
init|=
name|sliderFileSystem
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
name|boolean
name|deleted
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|deleted
operator|&&
operator|!
name|duration
operator|.
name|getLimitExceeded
argument_list|()
condition|)
block|{
name|dfs
operator|.
name|delete
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|deleted
operator|=
operator|!
name|dfs
operator|.
name|exists
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|deleted
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"ignoring interrupted sleep"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|sliderFileSystem
operator|.
name|verifyDirectoryNonexistent
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete with some pauses and backoff; designed to handle slow delete    * operation in windows.    *    * @param dir     dir to delete    * @param timeout timeout in millis    */
DECL|method|rigorousDelete (File dir, long timeout)
specifier|public
name|void
name|rigorousDelete
parameter_list|(
name|File
name|dir
parameter_list|,
name|long
name|timeout
parameter_list|)
throws|throws
name|IOException
block|{
name|Duration
name|duration
init|=
operator|new
name|Duration
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
name|duration
operator|.
name|start
argument_list|()
expr_stmt|;
name|boolean
name|deleted
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|deleted
operator|&&
operator|!
name|duration
operator|.
name|getLimitExceeded
argument_list|()
condition|)
block|{
name|FileUtils
operator|.
name|deleteQuietly
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|deleted
operator|=
operator|!
name|dir
operator|.
name|exists
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|deleted
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"ignoring interrupted sleep"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|deleted
condition|)
block|{
comment|// noisy delete raises an IOE
name|FileUtils
operator|.
name|deleteDirectory
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Add arguments to launch Slider with.    *<p>    * Extra arguments are added after standard arguments and before roles.    *    * @return additional arguments to launch Slider with    */
DECL|method|getExtraCLIArgs ()
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getExtraCLIArgs
parameter_list|()
block|{
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|()
return|;
block|}
DECL|method|getConfDir ()
specifier|public
name|String
name|getConfDir
parameter_list|()
throws|throws
name|FileNotFoundException
block|{
return|return
name|getResourceConfDirURI
argument_list|()
return|;
block|}
comment|/**    * Get the key for the application.    *    * @return    */
DECL|method|getApplicationHomeKey ()
specifier|public
name|String
name|getApplicationHomeKey
parameter_list|()
block|{
name|failNotImplemented
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/**    * Get the archive path -which defaults to the local one.    *    * @return    */
DECL|method|getArchivePath ()
specifier|public
name|String
name|getArchivePath
parameter_list|()
block|{
return|return
name|getLocalArchive
argument_list|()
return|;
block|}
comment|/**    * Get the local archive -the one defined in the test configuration.    *    * @return a possibly null/empty string    */
DECL|method|getLocalArchive ()
specifier|public
specifier|final
name|String
name|getLocalArchive
parameter_list|()
block|{
return|return
name|getTestConfiguration
argument_list|()
operator|.
name|getTrimmed
argument_list|(
name|getArchiveKey
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get the key for archives in tests.    *    * @return    */
DECL|method|getArchiveKey ()
specifier|public
name|String
name|getArchiveKey
parameter_list|()
block|{
name|failNotImplemented
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/**    * Merge a k-v pair into a simple k=v string; simple utility.    *    * @param key key    * @param val value    * @return the string to use after a -D option    */
DECL|method|define (String key, String val)
specifier|public
name|String
name|define
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|val
parameter_list|)
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%s=%s"
argument_list|,
name|key
argument_list|,
name|val
argument_list|)
return|;
block|}
DECL|method|assumeTestEnabled (boolean flag)
specifier|public
name|void
name|assumeTestEnabled
parameter_list|(
name|boolean
name|flag
parameter_list|)
block|{
name|assume
argument_list|(
name|flag
argument_list|,
literal|"test disabled"
argument_list|)
expr_stmt|;
block|}
DECL|method|assumeArchiveDefined ()
specifier|public
name|void
name|assumeArchiveDefined
parameter_list|()
block|{
name|String
name|archive
init|=
name|getArchivePath
argument_list|()
decl_stmt|;
name|boolean
name|defined
init|=
name|archive
operator|!=
literal|null
operator|&&
name|archive
operator|!=
literal|""
decl_stmt|;
if|if
condition|(
operator|!
name|defined
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|NO_ARCHIVE_DEFINED
operator|+
name|getArchiveKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assume
argument_list|(
name|defined
argument_list|,
name|NO_ARCHIVE_DEFINED
operator|+
name|getArchiveKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assume that application home is defined. This does not check that the    * path is valid -that is expected to be a failure on tests that require    * application home to be set.    */
DECL|method|assumeApplicationHome ()
specifier|public
name|void
name|assumeApplicationHome
parameter_list|()
block|{
name|String
name|applicationHome
init|=
name|getApplicationHome
argument_list|()
decl_stmt|;
name|assume
argument_list|(
name|applicationHome
operator|!=
literal|null
operator|&&
name|applicationHome
operator|!=
literal|""
argument_list|,
literal|"Application home dir option not set "
operator|+
name|getApplicationHomeKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|getApplicationHome ()
specifier|public
name|String
name|getApplicationHome
parameter_list|()
block|{
return|return
name|getTestConfiguration
argument_list|()
operator|.
name|getTrimmed
argument_list|(
name|getApplicationHomeKey
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get the resource configuration dir in the source tree.    *    * @return    */
DECL|method|getResourceConfDir ()
specifier|public
name|File
name|getResourceConfDir
parameter_list|()
throws|throws
name|FileNotFoundException
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|getTestConfigurationPath
argument_list|()
argument_list|)
operator|.
name|getAbsoluteFile
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Resource configuration directory "
operator|+
name|f
operator|+
literal|" not found"
argument_list|)
throw|;
block|}
return|return
name|f
return|;
block|}
DECL|method|getTestConfigurationPath ()
specifier|public
name|String
name|getTestConfigurationPath
parameter_list|()
block|{
name|failNotImplemented
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/**    * Get a URI string to the resource conf dir that is suitable for passing down    * to the AM -and works even when the default FS is hdfs.    */
DECL|method|getResourceConfDirURI ()
specifier|public
name|String
name|getResourceConfDirURI
parameter_list|()
throws|throws
name|FileNotFoundException
block|{
return|return
name|getResourceConfDir
argument_list|()
operator|.
name|getAbsoluteFile
argument_list|()
operator|.
name|toURI
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Log an application report.    *    * @param report    */
DECL|method|logReport (ApplicationReport report)
specifier|public
name|void
name|logReport
parameter_list|(
name|ApplicationReport
name|report
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|SliderUtils
operator|.
name|reportToString
argument_list|(
name|report
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Stop the cluster via the stop action -and wait for    * {@link #CLUSTER_STOP_TIME} for the cluster to stop. If it doesn't    *    * @param sliderClient client    * @param clustername  cluster    * @return the exit code    */
DECL|method|clusterActionFreeze (SliderClient sliderClient, String clustername, String message, boolean force)
specifier|public
name|int
name|clusterActionFreeze
parameter_list|(
name|SliderClient
name|sliderClient
parameter_list|,
name|String
name|clustername
parameter_list|,
name|String
name|message
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopping cluster {}: {}"
argument_list|,
name|clustername
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|ActionFreezeArgs
name|freezeArgs
init|=
operator|new
name|ActionFreezeArgs
argument_list|()
decl_stmt|;
name|freezeArgs
operator|.
name|setWaittime
argument_list|(
name|CLUSTER_STOP_TIME
argument_list|)
expr_stmt|;
name|freezeArgs
operator|.
name|message
operator|=
name|message
expr_stmt|;
name|freezeArgs
operator|.
name|force
operator|=
name|force
expr_stmt|;
name|int
name|exitCode
init|=
name|sliderClient
operator|.
name|actionStop
argument_list|(
name|clustername
argument_list|,
name|freezeArgs
argument_list|)
decl_stmt|;
if|if
condition|(
name|exitCode
operator|!=
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cluster stop failed with error code {}"
argument_list|,
name|exitCode
argument_list|)
expr_stmt|;
block|}
return|return
name|exitCode
return|;
block|}
comment|/**    * Teardown-time cluster termination; will stop the cluster iff the client    * is not null.    *    * @param sliderClient client    * @param clustername  name of cluster to teardown    * @return    */
DECL|method|maybeStopCluster ( SliderClient sliderClient, String clustername, String message, boolean force)
specifier|public
name|int
name|maybeStopCluster
parameter_list|(
name|SliderClient
name|sliderClient
parameter_list|,
name|String
name|clustername
parameter_list|,
name|String
name|message
parameter_list|,
name|boolean
name|force
parameter_list|)
block|{
if|if
condition|(
name|sliderClient
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|SliderUtils
operator|.
name|isUnset
argument_list|(
name|clustername
argument_list|)
condition|)
block|{
name|clustername
operator|=
name|sliderClient
operator|.
name|getDeployedClusterName
argument_list|()
expr_stmt|;
block|}
comment|//only stop a cluster that exists
if|if
condition|(
name|SliderUtils
operator|.
name|isSet
argument_list|(
name|clustername
argument_list|)
condition|)
block|{
try|try
block|{
name|clusterActionFreeze
argument_list|(
name|sliderClient
argument_list|,
name|clustername
argument_list|,
name|message
argument_list|,
name|force
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"While stopping cluster "
operator|+
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|sliderClient
operator|.
name|actionDestroy
argument_list|(
name|clustername
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"While destroying cluster "
operator|+
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
DECL|method|roleMapToString (Map<String, Integer> roles)
specifier|public
name|String
name|roleMapToString
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|roles
parameter_list|)
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|entry
range|:
name|roles
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"->"
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Turn on test runs against a copy of the archive that is    * uploaded to HDFS -this method copies up the    * archive then switches the tests into archive mode.    */
DECL|method|enableTestRunAgainstUploadedArchive ()
specifier|public
name|void
name|enableTestRunAgainstUploadedArchive
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|remotePath
init|=
name|copyLocalArchiveToHDFS
argument_list|(
name|getLocalArchive
argument_list|()
argument_list|)
decl_stmt|;
comment|// image mode
name|switchToRemoteImageDeploy
argument_list|(
name|remotePath
argument_list|)
expr_stmt|;
block|}
comment|/**    * Switch to deploying a remote image.    *    * @param remotePath the remote path to use    */
DECL|method|switchToRemoteImageDeploy (Path remotePath)
specifier|public
name|void
name|switchToRemoteImageDeploy
parameter_list|(
name|Path
name|remotePath
parameter_list|)
block|{
name|switchToImageDeploy
operator|=
literal|true
expr_stmt|;
name|imageIsRemote
operator|=
literal|true
expr_stmt|;
name|remoteImageURI
operator|=
name|remotePath
operator|.
name|toUri
argument_list|()
expr_stmt|;
block|}
comment|/**    * Copy a local archive to HDFS.    *    * @param localArchive local archive    * @return the path of the uploaded image    */
DECL|method|copyLocalArchiveToHDFS (String localArchive)
specifier|public
name|Path
name|copyLocalArchiveToHDFS
parameter_list|(
name|String
name|localArchive
parameter_list|)
throws|throws
name|IOException
block|{
name|assertNotNull
argument_list|(
name|localArchive
argument_list|)
expr_stmt|;
name|File
name|localArchiveFile
init|=
operator|new
name|File
argument_list|(
name|localArchive
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|localArchiveFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|hdfsCluster
argument_list|)
expr_stmt|;
name|Path
name|remoteUnresolvedArchive
init|=
operator|new
name|Path
argument_list|(
name|localArchiveFile
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|FileUtil
operator|.
name|copy
argument_list|(
name|localArchiveFile
argument_list|,
name|hdfsCluster
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|remoteUnresolvedArchive
argument_list|,
literal|false
argument_list|,
name|getTestConfiguration
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|remotePath
init|=
name|hdfsCluster
operator|.
name|getFileSystem
argument_list|()
operator|.
name|resolvePath
argument_list|(
name|remoteUnresolvedArchive
argument_list|)
decl_stmt|;
return|return
name|remotePath
return|;
block|}
comment|/**    * Create a SliderFileSystem instance bonded to the running FS.    * The YARN cluster must be up and running already    *    * @return    */
DECL|method|createSliderFileSystem ()
specifier|public
name|SliderFileSystem
name|createSliderFileSystem
parameter_list|()
throws|throws
name|URISyntaxException
throws|,
name|IOException
block|{
name|FileSystem
name|dfs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
operator|new
name|URI
argument_list|(
name|getFsDefaultName
argument_list|()
argument_list|)
argument_list|,
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
name|SliderFileSystem
name|hfs
init|=
operator|new
name|SliderFileSystem
argument_list|(
name|dfs
argument_list|,
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|hfs
return|;
block|}
block|}
end_class

end_unit

