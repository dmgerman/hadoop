begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.slider.tools
package|package
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|tools
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|zip
operator|.
name|ZipArchiveEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|zip
operator|.
name|ZipArchiveOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|utils
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|rules
operator|.
name|TemporaryFolder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_comment
comment|/**  *  Various utility methods  *  Byte comparison methods are from  *<code>org.apache.hadoop.fs.contract.ContractTestUtils</code>  */
end_comment

begin_class
DECL|class|TestUtility
specifier|public
class|class
name|TestUtility
block|{
DECL|field|log
specifier|protected
specifier|static
specifier|final
name|Logger
name|log
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TestUtility
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|method|addDir (File dirObj, ZipArchiveOutputStream zipFile, String prefix)
specifier|public
specifier|static
name|void
name|addDir
parameter_list|(
name|File
name|dirObj
parameter_list|,
name|ZipArchiveOutputStream
name|zipFile
parameter_list|,
name|String
name|prefix
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|File
name|file
range|:
name|dirObj
operator|.
name|listFiles
argument_list|()
control|)
block|{
if|if
condition|(
name|file
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|addDir
argument_list|(
name|file
argument_list|,
name|zipFile
argument_list|,
name|prefix
operator|+
name|file
operator|.
name|getName
argument_list|()
operator|+
name|File
operator|.
name|separator
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
operator|.
name|info
argument_list|(
literal|"Adding to zip - "
operator|+
name|prefix
operator|+
name|file
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|zipFile
operator|.
name|putArchiveEntry
argument_list|(
operator|new
name|ZipArchiveEntry
argument_list|(
name|prefix
operator|+
name|file
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|copy
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
argument_list|,
name|zipFile
argument_list|)
expr_stmt|;
name|zipFile
operator|.
name|closeArchiveEntry
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|zipDir (String zipFile, String dir)
specifier|public
specifier|static
name|void
name|zipDir
parameter_list|(
name|String
name|zipFile
parameter_list|,
name|String
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|dirObj
init|=
operator|new
name|File
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|ZipArchiveOutputStream
name|out
init|=
operator|new
name|ZipArchiveOutputStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
name|zipFile
argument_list|)
argument_list|)
decl_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Creating : {}"
argument_list|,
name|zipFile
argument_list|)
expr_stmt|;
try|try
block|{
name|addDir
argument_list|(
name|dirObj
argument_list|,
name|out
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|createAppPackage ( TemporaryFolder folder, String subDir, String pkgName, String srcPath)
specifier|public
specifier|static
name|String
name|createAppPackage
parameter_list|(
name|TemporaryFolder
name|folder
parameter_list|,
name|String
name|subDir
parameter_list|,
name|String
name|pkgName
parameter_list|,
name|String
name|srcPath
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|zipFileName
decl_stmt|;
name|File
name|pkgPath
init|=
name|folder
operator|.
name|newFolder
argument_list|(
name|subDir
argument_list|)
decl_stmt|;
name|File
name|zipFile
init|=
operator|new
name|File
argument_list|(
name|pkgPath
argument_list|,
name|pkgName
argument_list|)
operator|.
name|getAbsoluteFile
argument_list|()
decl_stmt|;
name|zipFileName
operator|=
name|zipFile
operator|.
name|getAbsolutePath
argument_list|()
expr_stmt|;
name|TestUtility
operator|.
name|zipDir
argument_list|(
name|zipFileName
argument_list|,
name|srcPath
argument_list|)
expr_stmt|;
name|log
operator|.
name|info
argument_list|(
literal|"Created temporary zip file at {}"
argument_list|,
name|zipFileName
argument_list|)
expr_stmt|;
return|return
name|zipFileName
return|;
block|}
comment|/**    * Assert that tthe array original[0..len] and received[] are equal.    * A failure triggers the logging of the bytes near where the first    * difference surfaces.    * @param original source data    * @param received actual    * @param len length of bytes to compare    */
DECL|method|compareByteArrays (byte[] original, byte[] received, int len)
specifier|public
specifier|static
name|void
name|compareByteArrays
parameter_list|(
name|byte
index|[]
name|original
parameter_list|,
name|byte
index|[]
name|received
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Number of bytes read != number written"
argument_list|,
name|len
argument_list|,
name|received
operator|.
name|length
argument_list|)
expr_stmt|;
name|int
name|errors
init|=
literal|0
decl_stmt|;
name|int
name|first_error_byte
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|original
index|[
name|i
index|]
operator|!=
name|received
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|errors
operator|==
literal|0
condition|)
block|{
name|first_error_byte
operator|=
name|i
expr_stmt|;
block|}
name|errors
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errors
operator|>
literal|0
condition|)
block|{
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
literal|" %d errors in file of length %d"
argument_list|,
name|errors
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|log
operator|.
name|warn
argument_list|(
name|message
argument_list|)
expr_stmt|;
comment|// the range either side of the first error to print
comment|// this is a purely arbitrary number, to aid user debugging
specifier|final
name|int
name|overlap
init|=
literal|10
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|first_error_byte
operator|-
name|overlap
argument_list|)
init|;
name|i
operator|<
name|Math
operator|.
name|min
argument_list|(
name|first_error_byte
operator|+
name|overlap
argument_list|,
name|len
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|byte
name|actual
init|=
name|received
index|[
name|i
index|]
decl_stmt|;
name|byte
name|expected
init|=
name|original
index|[
name|i
index|]
decl_stmt|;
name|String
name|letter
init|=
name|toChar
argument_list|(
name|actual
argument_list|)
decl_stmt|;
name|String
name|line
init|=
name|String
operator|.
name|format
argument_list|(
literal|"[%04d] %2x %s\n"
argument_list|,
name|i
argument_list|,
name|actual
argument_list|,
name|letter
argument_list|)
decl_stmt|;
if|if
condition|(
name|expected
operator|!=
name|actual
condition|)
block|{
name|line
operator|=
name|String
operator|.
name|format
argument_list|(
literal|"[%04d] %2x %s -expected %2x %s\n"
argument_list|,
name|i
argument_list|,
name|actual
argument_list|,
name|letter
argument_list|,
name|expected
argument_list|,
name|toChar
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|log
operator|.
name|warn
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|Assert
operator|.
name|fail
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Convert a byte to a character for printing. If the    * byte value is< 32 -and hence unprintable- the byte is    * returned as a two digit hex value    * @param b byte    * @return the printable character string    */
DECL|method|toChar (byte b)
specifier|public
specifier|static
name|String
name|toChar
parameter_list|(
name|byte
name|b
parameter_list|)
block|{
if|if
condition|(
name|b
operator|>=
literal|0x20
condition|)
block|{
return|return
name|Character
operator|.
name|toString
argument_list|(
operator|(
name|char
operator|)
name|b
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%02x"
argument_list|,
name|b
argument_list|)
return|;
block|}
block|}
comment|/**    * Convert a buffer to a string, character by character    * @param buffer input bytes    * @return a string conversion    */
DECL|method|toChar (byte[] buffer)
specifier|public
specifier|static
name|String
name|toChar
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|)
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
name|buffer
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|byte
name|b
range|:
name|buffer
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|toChar
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|toAsciiByteArray (String s)
specifier|public
specifier|static
name|byte
index|[]
name|toAsciiByteArray
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|char
index|[]
name|chars
init|=
name|s
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|chars
operator|.
name|length
decl_stmt|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
name|len
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|chars
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
return|;
block|}
comment|/**    * Create a dataset for use in the tests; all data is in the range    * base to (base+modulo-1) inclusive    * @param len length of data    * @param base base of the data    * @param modulo the modulo    * @return the newly generated dataset    */
DECL|method|dataset (int len, int base, int modulo)
specifier|public
specifier|static
name|byte
index|[]
name|dataset
parameter_list|(
name|int
name|len
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|modulo
parameter_list|)
block|{
name|byte
index|[]
name|dataset
init|=
operator|new
name|byte
index|[
name|len
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|dataset
index|[
name|i
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|base
operator|+
operator|(
name|i
operator|%
name|modulo
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|dataset
return|;
block|}
block|}
end_class

end_unit

