begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *       http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.slider.utils
package|package
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|utils
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|internal
operator|.
name|AssumptionViolatedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_comment
comment|/**  * Utilities used across test cases to make assertions about filesystems  * -assertions which fail with useful information.  * This is lifted from Hadoop common Test; that JAR isn't published, so  * we have to make do.  */
end_comment

begin_class
DECL|class|ContractTestUtils
specifier|public
class|class
name|ContractTestUtils
extends|extends
name|Assert
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ContractTestUtils
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|IO_FILE_BUFFER_SIZE
specifier|public
specifier|static
specifier|final
name|String
name|IO_FILE_BUFFER_SIZE
init|=
literal|"io.file.buffer.size"
decl_stmt|;
comment|// For scale testing, we can repeatedly write small chunk data to generate
comment|// a large file.
DECL|field|IO_CHUNK_BUFFER_SIZE
specifier|public
specifier|static
specifier|final
name|String
name|IO_CHUNK_BUFFER_SIZE
init|=
literal|"io.chunk.buffer.size"
decl_stmt|;
DECL|field|DEFAULT_IO_CHUNK_BUFFER_SIZE
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_IO_CHUNK_BUFFER_SIZE
init|=
literal|128
decl_stmt|;
DECL|field|IO_CHUNK_MODULUS_SIZE
specifier|public
specifier|static
specifier|final
name|String
name|IO_CHUNK_MODULUS_SIZE
init|=
literal|"io.chunk.modulus.size"
decl_stmt|;
DECL|field|DEFAULT_IO_CHUNK_MODULUS_SIZE
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_IO_CHUNK_MODULUS_SIZE
init|=
literal|128
decl_stmt|;
comment|/**    * Assert that a property in the property set matches the expected value    * @param props property set    * @param key property name    * @param expected expected value. If null, the property must not be in the set    */
DECL|method|assertPropertyEquals (Properties props, String key, String expected)
specifier|public
specifier|static
name|void
name|assertPropertyEquals
parameter_list|(
name|Properties
name|props
parameter_list|,
name|String
name|key
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
name|String
name|val
init|=
name|props
operator|.
name|getProperty
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|expected
operator|==
literal|null
condition|)
block|{
name|assertNull
argument_list|(
literal|"Non null property "
operator|+
name|key
operator|+
literal|" = "
operator|+
name|val
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertEquals
argument_list|(
literal|"property "
operator|+
name|key
operator|+
literal|" = "
operator|+
name|val
argument_list|,
name|expected
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    *    * Write a file and read it in, validating the result. Optional flags control    * whether file overwrite operations should be enabled, and whether the    * file should be deleted afterwards.    *    * If there is a mismatch between what was written and what was expected,    * a small range of bytes either side of the first error are logged to aid    * diagnosing what problem occurred -whether it was a previous file    * or a corrupting of the current file. This assumes that two    * sequential runs to the same path use datasets with different character    * moduli.    *    * @param fs filesystem    * @param path path to write to    * @param len length of data    * @param overwrite should the create option allow overwrites?    * @param delete should the file be deleted afterwards? -with a verification    * that it worked. Deletion is not attempted if an assertion has failed    * earlier -it is not in a<code>finally{}</code> block.    * @throws IOException IO problems    */
DECL|method|writeAndRead (FileSystem fs, Path path, byte[] src, int len, int blocksize, boolean overwrite, boolean delete)
specifier|public
specifier|static
name|void
name|writeAndRead
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|byte
index|[]
name|src
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|blocksize
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|boolean
name|delete
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|mkdirs
argument_list|(
name|path
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
name|writeDataset
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|src
argument_list|,
name|len
argument_list|,
name|blocksize
argument_list|,
name|overwrite
argument_list|)
expr_stmt|;
name|byte
index|[]
name|dest
init|=
name|readDataset
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|compareByteArrays
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete
condition|)
block|{
name|rejectRootOperation
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|boolean
name|deleted
init|=
name|fs
operator|.
name|delete
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Deleted"
argument_list|,
name|deleted
argument_list|)
expr_stmt|;
name|assertPathDoesNotExist
argument_list|(
name|fs
argument_list|,
literal|"Cleanup failed"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Write a file.    * Optional flags control    * whether file overwrite operations should be enabled    * @param fs filesystem    * @param path path to write to    * @param len length of data    * @param overwrite should the create option allow overwrites?    * @throws IOException IO problems    */
DECL|method|writeDataset (FileSystem fs, Path path, byte[] src, int len, int buffersize, boolean overwrite)
specifier|public
specifier|static
name|void
name|writeDataset
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|byte
index|[]
name|src
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|buffersize
parameter_list|,
name|boolean
name|overwrite
parameter_list|)
throws|throws
name|IOException
block|{
name|assertTrue
argument_list|(
literal|"Not enough data in source array to write "
operator|+
name|len
operator|+
literal|" bytes"
argument_list|,
name|src
operator|.
name|length
operator|>=
name|len
argument_list|)
expr_stmt|;
name|FSDataOutputStream
name|out
init|=
name|fs
operator|.
name|create
argument_list|(
name|path
argument_list|,
name|overwrite
argument_list|,
name|fs
operator|.
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|IO_FILE_BUFFER_SIZE
argument_list|,
literal|4096
argument_list|)
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|,
name|buffersize
argument_list|)
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertFileHasLength
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/**    * Read the file and convert to a byte dataset.    * This implements readfully internally, so that it will read    * in the file without ever having to seek()    * @param fs filesystem    * @param path path to read from    * @param len length of data to read    * @return the bytes    * @throws IOException IO problems    */
DECL|method|readDataset (FileSystem fs, Path path, int len)
specifier|public
specifier|static
name|byte
index|[]
name|readDataset
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|FSDataInputStream
name|in
init|=
name|fs
operator|.
name|open
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|byte
index|[]
name|dest
init|=
operator|new
name|byte
index|[
name|len
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|nread
init|=
literal|0
decl_stmt|;
try|try
block|{
while|while
condition|(
name|nread
operator|<
name|len
condition|)
block|{
name|int
name|nbytes
init|=
name|in
operator|.
name|read
argument_list|(
name|dest
argument_list|,
name|offset
operator|+
name|nread
argument_list|,
name|len
operator|-
name|nread
argument_list|)
decl_stmt|;
if|if
condition|(
name|nbytes
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"End of file reached before reading fully."
argument_list|)
throw|;
block|}
name|nread
operator|+=
name|nbytes
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|dest
return|;
block|}
comment|/**    * Read a file, verify its length and contents match the expected array    * @param fs filesystem    * @param path path to file    * @param original original dataset    * @throws IOException IO Problems    */
DECL|method|verifyFileContents (FileSystem fs, Path path, byte[] original)
specifier|public
specifier|static
name|void
name|verifyFileContents
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|byte
index|[]
name|original
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
name|stat
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|String
name|statText
init|=
name|stat
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"not a file "
operator|+
name|statText
argument_list|,
name|stat
operator|.
name|isFile
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"wrong length "
operator|+
name|statText
argument_list|,
name|original
operator|.
name|length
argument_list|,
name|stat
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
name|byte
index|[]
name|bytes
init|=
name|readDataset
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|original
operator|.
name|length
argument_list|)
decl_stmt|;
name|compareByteArrays
argument_list|(
name|original
argument_list|,
name|bytes
argument_list|,
name|original
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**    * Verify that the read at a specific offset in a stream    * matches that expected    * @param stm stream    * @param fileContents original file contents    * @param seekOff seek offset    * @param toRead number of bytes to read    * @throws IOException IO problems    */
DECL|method|verifyRead (FSDataInputStream stm, byte[] fileContents, int seekOff, int toRead)
specifier|public
specifier|static
name|void
name|verifyRead
parameter_list|(
name|FSDataInputStream
name|stm
parameter_list|,
name|byte
index|[]
name|fileContents
parameter_list|,
name|int
name|seekOff
parameter_list|,
name|int
name|toRead
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|out
init|=
operator|new
name|byte
index|[
name|toRead
index|]
decl_stmt|;
name|stm
operator|.
name|seek
argument_list|(
name|seekOff
argument_list|)
expr_stmt|;
name|stm
operator|.
name|readFully
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|byte
index|[]
name|expected
init|=
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|fileContents
argument_list|,
name|seekOff
argument_list|,
name|seekOff
operator|+
name|toRead
argument_list|)
decl_stmt|;
name|compareByteArrays
argument_list|(
name|expected
argument_list|,
name|out
argument_list|,
name|toRead
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that tthe array original[0..len] and received[] are equal.    * A failure triggers the logging of the bytes near where the first    * difference surfaces.    * @param original source data    * @param received actual    * @param len length of bytes to compare    */
DECL|method|compareByteArrays (byte[] original, byte[] received, int len)
specifier|public
specifier|static
name|void
name|compareByteArrays
parameter_list|(
name|byte
index|[]
name|original
parameter_list|,
name|byte
index|[]
name|received
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|assertEquals
argument_list|(
literal|"Number of bytes read != number written"
argument_list|,
name|len
argument_list|,
name|received
operator|.
name|length
argument_list|)
expr_stmt|;
name|int
name|errors
init|=
literal|0
decl_stmt|;
name|int
name|first_error_byte
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|original
index|[
name|i
index|]
operator|!=
name|received
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|errors
operator|==
literal|0
condition|)
block|{
name|first_error_byte
operator|=
name|i
expr_stmt|;
block|}
name|errors
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errors
operator|>
literal|0
condition|)
block|{
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
literal|" %d errors in file of length %d"
argument_list|,
name|errors
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|message
argument_list|)
expr_stmt|;
comment|// the range either side of the first error to print
comment|// this is a purely arbitrary number, to aid user debugging
specifier|final
name|int
name|overlap
init|=
literal|10
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|first_error_byte
operator|-
name|overlap
argument_list|)
init|;
name|i
operator|<
name|Math
operator|.
name|min
argument_list|(
name|first_error_byte
operator|+
name|overlap
argument_list|,
name|len
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|byte
name|actual
init|=
name|received
index|[
name|i
index|]
decl_stmt|;
name|byte
name|expected
init|=
name|original
index|[
name|i
index|]
decl_stmt|;
name|String
name|letter
init|=
name|toChar
argument_list|(
name|actual
argument_list|)
decl_stmt|;
name|String
name|line
init|=
name|String
operator|.
name|format
argument_list|(
literal|"[%04d] %2x %s\n"
argument_list|,
name|i
argument_list|,
name|actual
argument_list|,
name|letter
argument_list|)
decl_stmt|;
if|if
condition|(
name|expected
operator|!=
name|actual
condition|)
block|{
name|line
operator|=
name|String
operator|.
name|format
argument_list|(
literal|"[%04d] %2x %s -expected %2x %s\n"
argument_list|,
name|i
argument_list|,
name|actual
argument_list|,
name|letter
argument_list|,
name|expected
argument_list|,
name|toChar
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|fail
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Convert a byte to a character for printing. If the    * byte value is< 32 -and hence unprintable- the byte is    * returned as a two digit hex value    * @param b byte    * @return the printable character string    */
DECL|method|toChar (byte b)
specifier|public
specifier|static
name|String
name|toChar
parameter_list|(
name|byte
name|b
parameter_list|)
block|{
if|if
condition|(
name|b
operator|>=
literal|0x20
condition|)
block|{
return|return
name|Character
operator|.
name|toString
argument_list|(
operator|(
name|char
operator|)
name|b
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%02x"
argument_list|,
name|b
argument_list|)
return|;
block|}
block|}
comment|/**    * Convert a buffer to a string, character by character    * @param buffer input bytes    * @return a string conversion    */
DECL|method|toChar (byte[] buffer)
specifier|public
specifier|static
name|String
name|toChar
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|)
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
name|buffer
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|byte
name|b
range|:
name|buffer
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|toChar
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|toAsciiByteArray (String s)
specifier|public
specifier|static
name|byte
index|[]
name|toAsciiByteArray
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|char
index|[]
name|chars
init|=
name|s
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|chars
operator|.
name|length
decl_stmt|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
name|len
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|chars
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
return|;
block|}
comment|/**    * Cleanup at the end of a test run    * @param action action triggering the operation (for use in logging)    * @param fileSystem filesystem to work with. May be null    * @param cleanupPath path to delete as a string    */
DECL|method|cleanup (String action, FileSystem fileSystem, String cleanupPath)
specifier|public
specifier|static
name|void
name|cleanup
parameter_list|(
name|String
name|action
parameter_list|,
name|FileSystem
name|fileSystem
parameter_list|,
name|String
name|cleanupPath
parameter_list|)
block|{
if|if
condition|(
name|fileSystem
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|cleanupPath
argument_list|)
operator|.
name|makeQualified
argument_list|(
name|fileSystem
operator|.
name|getUri
argument_list|()
argument_list|,
name|fileSystem
operator|.
name|getWorkingDirectory
argument_list|()
argument_list|)
decl_stmt|;
name|cleanup
argument_list|(
name|action
argument_list|,
name|fileSystem
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
comment|/**    * Cleanup at the end of a test run    * @param action action triggering the operation (for use in logging)    * @param fileSystem filesystem to work with. May be null    * @param path path to delete    */
DECL|method|cleanup (String action, FileSystem fileSystem, Path path)
specifier|public
specifier|static
name|void
name|cleanup
parameter_list|(
name|String
name|action
parameter_list|,
name|FileSystem
name|fileSystem
parameter_list|,
name|Path
name|path
parameter_list|)
block|{
name|noteAction
argument_list|(
name|action
argument_list|)
expr_stmt|;
try|try
block|{
name|rm
argument_list|(
name|fileSystem
argument_list|,
name|path
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error deleting in "
operator|+
name|action
operator|+
literal|" - "
operator|+
name|path
operator|+
literal|": "
operator|+
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Delete a directory. There's a safety check for operations against the    * root directory -these are intercepted and rejected with an IOException    * unless the allowRootDelete flag is true    * @param fileSystem filesystem to work with. May be null    * @param path path to delete    * @param recursive flag to enable recursive delete    * @param allowRootDelete can the root directory be deleted?    * @throws IOException on any problem.    */
DECL|method|rm (FileSystem fileSystem, Path path, boolean recursive, boolean allowRootDelete)
specifier|public
specifier|static
name|boolean
name|rm
parameter_list|(
name|FileSystem
name|fileSystem
parameter_list|,
name|Path
name|path
parameter_list|,
name|boolean
name|recursive
parameter_list|,
name|boolean
name|allowRootDelete
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fileSystem
operator|!=
literal|null
condition|)
block|{
name|rejectRootOperation
argument_list|(
name|path
argument_list|,
name|allowRootDelete
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileSystem
operator|.
name|exists
argument_list|(
name|path
argument_list|)
condition|)
block|{
return|return
name|fileSystem
operator|.
name|delete
argument_list|(
name|path
argument_list|,
name|recursive
argument_list|)
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Block any operation on the root path. This is a safety check    * @param path path in the filesystem    * @param allowRootOperation can the root directory be manipulated?    * @throws IOException if the operation was rejected    */
DECL|method|rejectRootOperation (Path path, boolean allowRootOperation)
specifier|public
specifier|static
name|void
name|rejectRootOperation
parameter_list|(
name|Path
name|path
parameter_list|,
name|boolean
name|allowRootOperation
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|path
operator|.
name|isRoot
argument_list|()
operator|&&
operator|!
name|allowRootOperation
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Root directory operation rejected: "
operator|+
name|path
argument_list|)
throw|;
block|}
block|}
comment|/**    * Block any operation on the root path. This is a safety check    * @param path path in the filesystem    * @throws IOException if the operation was rejected    */
DECL|method|rejectRootOperation (Path path)
specifier|public
specifier|static
name|void
name|rejectRootOperation
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|rejectRootOperation
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|noteAction (String action)
specifier|public
specifier|static
name|void
name|noteAction
parameter_list|(
name|String
name|action
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"==============  "
operator|+
name|action
operator|+
literal|" ============="
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * downgrade a failure to a message and a warning, then an    * exception for the Junit test runner to mark as failed    * @param message text message    * @param failure what failed    * @throws AssumptionViolatedException always    */
DECL|method|downgrade (String message, Throwable failure)
specifier|public
specifier|static
name|void
name|downgrade
parameter_list|(
name|String
name|message
parameter_list|,
name|Throwable
name|failure
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Downgrading test "
operator|+
name|message
argument_list|,
name|failure
argument_list|)
expr_stmt|;
name|AssumptionViolatedException
name|ave
init|=
operator|new
name|AssumptionViolatedException
argument_list|(
name|failure
argument_list|,
literal|null
argument_list|)
decl_stmt|;
throw|throw
name|ave
throw|;
block|}
comment|/**    * report an overridden test as unsupported    * @param message message to use in the text    * @throws AssumptionViolatedException always    */
DECL|method|unsupported (String message)
specifier|public
specifier|static
name|void
name|unsupported
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|skip
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
comment|/**    * report a test has been skipped for some reason    * @param message message to use in the text    * @throws AssumptionViolatedException always    */
DECL|method|skip (String message)
specifier|public
specifier|static
name|void
name|skip
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skipping: {}"
argument_list|,
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AssumptionViolatedException
argument_list|(
name|message
argument_list|)
throw|;
block|}
comment|/**    * Fail with an exception that was received    * @param text text to use in the exception    * @param thrown a (possibly null) throwable to init the cause with    * @throws AssertionError with the text and throwable -always    */
DECL|method|fail (String text, Throwable thrown)
specifier|public
specifier|static
name|void
name|fail
parameter_list|(
name|String
name|text
parameter_list|,
name|Throwable
name|thrown
parameter_list|)
block|{
name|AssertionError
name|e
init|=
operator|new
name|AssertionError
argument_list|(
name|text
argument_list|)
decl_stmt|;
name|e
operator|.
name|initCause
argument_list|(
name|thrown
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
comment|/**    * Make an assertion about the length of a file    * @param fs filesystem    * @param path path of the file    * @param expected expected length    * @throws IOException on File IO problems    */
DECL|method|assertFileHasLength (FileSystem fs, Path path, int expected)
specifier|public
specifier|static
name|void
name|assertFileHasLength
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|int
name|expected
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
name|status
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong file length of file "
operator|+
name|path
operator|+
literal|" status: "
operator|+
name|status
argument_list|,
name|expected
argument_list|,
name|status
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that a path refers to a directory    * @param fs filesystem    * @param path path of the directory    * @throws IOException on File IO problems    */
DECL|method|assertIsDirectory (FileSystem fs, Path path)
specifier|public
specifier|static
name|void
name|assertIsDirectory
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
name|fileStatus
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|assertIsDirectory
argument_list|(
name|fileStatus
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that a path refers to a directory    * @param fileStatus stats to check    */
DECL|method|assertIsDirectory (FileStatus fileStatus)
specifier|public
specifier|static
name|void
name|assertIsDirectory
parameter_list|(
name|FileStatus
name|fileStatus
parameter_list|)
block|{
name|assertTrue
argument_list|(
literal|"Should be a directory -but isn't: "
operator|+
name|fileStatus
argument_list|,
name|fileStatus
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Write the text to a file, returning the converted byte array    * for use in validating the round trip    * @param fs filesystem    * @param path path of file    * @param text text to write    * @param overwrite should the operation overwrite any existing file?    * @return the read bytes    * @throws IOException on IO problems    */
DECL|method|writeTextFile (FileSystem fs, Path path, String text, boolean overwrite)
specifier|public
specifier|static
name|byte
index|[]
name|writeTextFile
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|String
name|text
parameter_list|,
name|boolean
name|overwrite
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|text
operator|!=
literal|null
condition|)
block|{
name|bytes
operator|=
name|toAsciiByteArray
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
name|createFile
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|overwrite
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
return|return
name|bytes
return|;
block|}
comment|/**    * Create a file    * @param fs filesystem    * @param path       path to write    * @param overwrite overwrite flag    * @param data source dataset. Can be null    * @throws IOException on any problem    */
DECL|method|createFile (FileSystem fs, Path path, boolean overwrite, byte[] data)
specifier|public
specifier|static
name|void
name|createFile
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|FSDataOutputStream
name|stream
init|=
name|fs
operator|.
name|create
argument_list|(
name|path
argument_list|,
name|overwrite
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|!=
literal|null
operator|&&
name|data
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|stream
operator|.
name|write
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Touch a file    * @param fs filesystem    * @param path path    * @throws IOException IO problems    */
DECL|method|touch (FileSystem fs, Path path)
specifier|public
specifier|static
name|void
name|touch
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|createFile
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete a file/dir and assert that delete() returned true    *<i>and</i> that the path no longer exists. This variant rejects    * all operations on root directories    * @param fs filesystem    * @param file path to delete    * @param recursive flag to enable recursive delete    * @throws IOException IO problems    */
DECL|method|assertDeleted (FileSystem fs, Path file, boolean recursive)
specifier|public
specifier|static
name|void
name|assertDeleted
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|file
parameter_list|,
name|boolean
name|recursive
parameter_list|)
throws|throws
name|IOException
block|{
name|assertDeleted
argument_list|(
name|fs
argument_list|,
name|file
argument_list|,
name|recursive
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete a file/dir and assert that delete() returned true    *<i>and</i> that the path no longer exists. This variant rejects    * all operations on root directories    * @param fs filesystem    * @param file path to delete    * @param recursive flag to enable recursive delete    * @param allowRootOperations can the root dir be deleted?    * @throws IOException IO problems    */
DECL|method|assertDeleted (FileSystem fs, Path file, boolean recursive, boolean allowRootOperations)
specifier|public
specifier|static
name|void
name|assertDeleted
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|file
parameter_list|,
name|boolean
name|recursive
parameter_list|,
name|boolean
name|allowRootOperations
parameter_list|)
throws|throws
name|IOException
block|{
name|rejectRootOperation
argument_list|(
name|file
argument_list|,
name|allowRootOperations
argument_list|)
expr_stmt|;
name|assertPathExists
argument_list|(
name|fs
argument_list|,
literal|"about to be deleted file"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|boolean
name|deleted
init|=
name|fs
operator|.
name|delete
argument_list|(
name|file
argument_list|,
name|recursive
argument_list|)
decl_stmt|;
name|String
name|dir
init|=
name|ls
argument_list|(
name|fs
argument_list|,
name|file
operator|.
name|getParent
argument_list|()
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Delete failed on "
operator|+
name|file
operator|+
literal|": "
operator|+
name|dir
argument_list|,
name|deleted
argument_list|)
expr_stmt|;
name|assertPathDoesNotExist
argument_list|(
name|fs
argument_list|,
literal|"Deleted file"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
comment|/**    * Read in "length" bytes, convert to an ascii string    * @param fs filesystem    * @param path path to read    * @param length #of bytes to read.    * @return the bytes read and converted to a string    * @throws IOException IO problems    */
DECL|method|readBytesToString (FileSystem fs, Path path, int length)
specifier|public
specifier|static
name|String
name|readBytesToString
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|FSDataInputStream
name|in
init|=
name|fs
operator|.
name|open
argument_list|(
name|path
argument_list|)
decl_stmt|;
try|try
block|{
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|length
index|]
decl_stmt|;
name|in
operator|.
name|readFully
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|toChar
argument_list|(
name|buf
argument_list|)
return|;
block|}
finally|finally
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Take an array of filestats and convert to a string (prefixed w/ a [01] counter    * @param stats array of stats    * @param separator separator after every entry    * @return a stringified set    */
DECL|method|fileStatsToString (FileStatus[] stats, String separator)
specifier|public
specifier|static
name|String
name|fileStatsToString
parameter_list|(
name|FileStatus
index|[]
name|stats
parameter_list|,
name|String
name|separator
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
name|stats
operator|.
name|length
operator|*
literal|128
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stats
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"[%02d] %s"
argument_list|,
name|i
argument_list|,
name|stats
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|separator
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * List a directory    * @param fileSystem FS    * @param path path    * @return a directory listing or failure message    * @throws IOException    */
DECL|method|ls (FileSystem fileSystem, Path path)
specifier|public
specifier|static
name|String
name|ls
parameter_list|(
name|FileSystem
name|fileSystem
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|path
operator|==
literal|null
condition|)
block|{
comment|//surfaces when someone calls getParent() on something at the top of the path
return|return
literal|"/"
return|;
block|}
name|FileStatus
index|[]
name|stats
decl_stmt|;
name|String
name|pathtext
init|=
literal|"ls "
operator|+
name|path
decl_stmt|;
try|try
block|{
name|stats
operator|=
name|fileSystem
operator|.
name|listStatus
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return
name|pathtext
operator|+
literal|" -file not found"
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
name|pathtext
operator|+
literal|" -failed: "
operator|+
name|e
return|;
block|}
return|return
name|dumpStats
argument_list|(
name|pathtext
argument_list|,
name|stats
argument_list|)
return|;
block|}
DECL|method|dumpStats (String pathname, FileStatus[] stats)
specifier|public
specifier|static
name|String
name|dumpStats
parameter_list|(
name|String
name|pathname
parameter_list|,
name|FileStatus
index|[]
name|stats
parameter_list|)
block|{
return|return
name|pathname
operator|+
name|fileStatsToString
argument_list|(
name|stats
argument_list|,
literal|"\n"
argument_list|)
return|;
block|}
comment|/**    * Assert that a file exists and whose {@link FileStatus} entry    * declares that this is a file and not a symlink or directory.    * @param fileSystem filesystem to resolve path against    * @param filename name of the file    * @throws IOException IO problems during file operations    */
DECL|method|assertIsFile (FileSystem fileSystem, Path filename)
specifier|public
specifier|static
name|void
name|assertIsFile
parameter_list|(
name|FileSystem
name|fileSystem
parameter_list|,
name|Path
name|filename
parameter_list|)
throws|throws
name|IOException
block|{
name|assertPathExists
argument_list|(
name|fileSystem
argument_list|,
literal|"Expected file"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|FileStatus
name|status
init|=
name|fileSystem
operator|.
name|getFileStatus
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|assertIsFile
argument_list|(
name|filename
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that a file exists and whose {@link FileStatus} entry    * declares that this is a file and not a symlink or directory.    * @param filename name of the file    * @param status file status    */
DECL|method|assertIsFile (Path filename, FileStatus status)
specifier|public
specifier|static
name|void
name|assertIsFile
parameter_list|(
name|Path
name|filename
parameter_list|,
name|FileStatus
name|status
parameter_list|)
block|{
name|String
name|fileInfo
init|=
name|filename
operator|+
literal|"  "
operator|+
name|status
decl_stmt|;
name|assertFalse
argument_list|(
literal|"File claims to be a directory "
operator|+
name|fileInfo
argument_list|,
name|status
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"File claims to be a symlink "
operator|+
name|fileInfo
argument_list|,
name|status
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a dataset for use in the tests; all data is in the range    * base to (base+modulo-1) inclusive    * @param len length of data    * @param base base of the data    * @param modulo the modulo    * @return the newly generated dataset    */
DECL|method|dataset (int len, int base, int modulo)
specifier|public
specifier|static
name|byte
index|[]
name|dataset
parameter_list|(
name|int
name|len
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|modulo
parameter_list|)
block|{
name|byte
index|[]
name|dataset
init|=
operator|new
name|byte
index|[
name|len
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|dataset
index|[
name|i
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|base
operator|+
operator|(
name|i
operator|%
name|modulo
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|dataset
return|;
block|}
comment|/**    * Assert that a path exists -but make no assertions as to the    * type of that entry    *    * @param fileSystem filesystem to examine    * @param message message to include in the assertion failure message    * @param path path in the filesystem    * @throws FileNotFoundException raised if the path is missing    * @throws IOException IO problems    */
DECL|method|assertPathExists (FileSystem fileSystem, String message, Path path)
specifier|public
specifier|static
name|void
name|assertPathExists
parameter_list|(
name|FileSystem
name|fileSystem
parameter_list|,
name|String
name|message
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|fileSystem
operator|.
name|exists
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|//failure, report it
name|String
name|listing
init|=
name|ls
argument_list|(
name|fileSystem
argument_list|,
name|path
operator|.
name|getParent
argument_list|()
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|message
operator|+
literal|": not found "
operator|+
name|path
operator|+
literal|" in \""
operator|+
name|path
operator|.
name|getParent
argument_list|()
operator|+
literal|"\" :\n"
operator|+
name|listing
argument_list|)
throw|;
block|}
block|}
comment|/**    * Assert that a path does not exist    *    * @param fileSystem filesystem to examine    * @param message message to include in the assertion failure message    * @param path path in the filesystem    * @throws IOException IO problems    */
DECL|method|assertPathDoesNotExist (FileSystem fileSystem, String message, Path path)
specifier|public
specifier|static
name|void
name|assertPathDoesNotExist
parameter_list|(
name|FileSystem
name|fileSystem
parameter_list|,
name|String
name|message
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|FileStatus
name|status
init|=
name|fileSystem
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|fail
argument_list|(
name|message
operator|+
literal|": unexpectedly found "
operator|+
name|path
operator|+
literal|" as  "
operator|+
name|status
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|expected
parameter_list|)
block|{
comment|//this is expected
block|}
block|}
comment|/**    * Assert that a FileSystem.listStatus on a dir finds the subdir/child entry    * @param fs filesystem    * @param dir directory to scan    * @param subdir full path to look for    * @throws IOException IO probles    */
DECL|method|assertListStatusFinds (FileSystem fs, Path dir, Path subdir)
specifier|public
specifier|static
name|void
name|assertListStatusFinds
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|dir
parameter_list|,
name|Path
name|subdir
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
index|[]
name|stats
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|FileStatus
name|stat
range|:
name|stats
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|stat
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|.
name|getPath
argument_list|()
operator|.
name|equals
argument_list|(
name|subdir
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
literal|"Path "
operator|+
name|subdir
operator|+
literal|" not found in directory "
operator|+
name|dir
operator|+
literal|":"
operator|+
name|builder
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test for the host being an OSX machine    * @return true if the JVM thinks that is running on OSX    */
DECL|method|isOSX ()
specifier|public
specifier|static
name|boolean
name|isOSX
parameter_list|()
block|{
return|return
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.name"
argument_list|)
operator|.
name|contains
argument_list|(
literal|"OS X"
argument_list|)
return|;
block|}
comment|/**    * compare content of file operations using a double byte array    * @param concat concatenated files    * @param bytes bytes    */
DECL|method|validateFileContent (byte[] concat, byte[][] bytes)
specifier|public
specifier|static
name|void
name|validateFileContent
parameter_list|(
name|byte
index|[]
name|concat
parameter_list|,
name|byte
index|[]
index|[]
name|bytes
parameter_list|)
block|{
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|boolean
name|mismatch
init|=
literal|false
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|bb
range|:
name|bytes
control|)
block|{
for|for
control|(
name|byte
name|b
range|:
name|bb
control|)
block|{
if|if
condition|(
name|b
operator|!=
name|concat
index|[
name|idx
operator|++
index|]
condition|)
block|{
name|mismatch
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|mismatch
condition|)
break|break;
block|}
name|assertFalse
argument_list|(
literal|"File content of file is not as expected at offset "
operator|+
name|idx
argument_list|,
name|mismatch
argument_list|)
expr_stmt|;
block|}
comment|/**    * Receives test data from the given input file and checks the size of the    * data as well as the pattern inside the received data.    *    * @param fs FileSystem    * @param path Input file to be checked    * @param expectedSize the expected size of the data to be read from the    *        input file in bytes    * @param bufferLen Pattern length    * @param modulus   Pattern modulus    * @throws IOException    *         thrown if an error occurs while reading the data    */
DECL|method|verifyReceivedData (FileSystem fs, Path path, final long expectedSize, final int bufferLen, final int modulus)
specifier|public
specifier|static
name|void
name|verifyReceivedData
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
specifier|final
name|long
name|expectedSize
parameter_list|,
specifier|final
name|int
name|bufferLen
parameter_list|,
specifier|final
name|int
name|modulus
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|byte
index|[]
name|testBuffer
init|=
operator|new
name|byte
index|[
name|bufferLen
index|]
decl_stmt|;
name|long
name|totalBytesRead
init|=
literal|0
decl_stmt|;
name|int
name|nextExpectedNumber
init|=
literal|0
decl_stmt|;
specifier|final
name|InputStream
name|inputStream
init|=
name|fs
operator|.
name|open
argument_list|(
name|path
argument_list|)
decl_stmt|;
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|bytesRead
init|=
name|inputStream
operator|.
name|read
argument_list|(
name|testBuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytesRead
operator|<
literal|0
condition|)
block|{
break|break;
block|}
name|totalBytesRead
operator|+=
name|bytesRead
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bytesRead
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|testBuffer
index|[
name|i
index|]
operator|!=
name|nextExpectedNumber
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Read number "
operator|+
name|testBuffer
index|[
name|i
index|]
operator|+
literal|" but expected "
operator|+
name|nextExpectedNumber
argument_list|)
throw|;
block|}
operator|++
name|nextExpectedNumber
expr_stmt|;
if|if
condition|(
name|nextExpectedNumber
operator|==
name|modulus
condition|)
block|{
name|nextExpectedNumber
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|totalBytesRead
operator|!=
name|expectedSize
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected to read "
operator|+
name|expectedSize
operator|+
literal|" bytes but only received "
operator|+
name|totalBytesRead
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|inputStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Generates test data of the given size according to some specific pattern    * and writes it to the provided output file.    *    * @param fs FileSystem    * @param path Test file to be generated    * @param size The size of the test data to be generated in bytes    * @param bufferLen Pattern length    * @param modulus   Pattern modulus    * @throws IOException    *         thrown if an error occurs while writing the data    */
DECL|method|generateTestFile (FileSystem fs, Path path, final long size, final int bufferLen, final int modulus)
specifier|public
specifier|static
name|long
name|generateTestFile
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
specifier|final
name|long
name|size
parameter_list|,
specifier|final
name|int
name|bufferLen
parameter_list|,
specifier|final
name|int
name|modulus
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|byte
index|[]
name|testBuffer
init|=
operator|new
name|byte
index|[
name|bufferLen
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|testBuffer
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|testBuffer
index|[
name|i
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|i
operator|%
name|modulus
argument_list|)
expr_stmt|;
block|}
specifier|final
name|OutputStream
name|outputStream
init|=
name|fs
operator|.
name|create
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|long
name|bytesWritten
init|=
literal|0
decl_stmt|;
try|try
block|{
while|while
condition|(
name|bytesWritten
operator|<
name|size
condition|)
block|{
specifier|final
name|long
name|diff
init|=
name|size
operator|-
name|bytesWritten
decl_stmt|;
if|if
condition|(
name|diff
operator|<
name|testBuffer
operator|.
name|length
condition|)
block|{
name|outputStream
operator|.
name|write
argument_list|(
name|testBuffer
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|diff
argument_list|)
expr_stmt|;
name|bytesWritten
operator|+=
name|diff
expr_stmt|;
block|}
else|else
block|{
name|outputStream
operator|.
name|write
argument_list|(
name|testBuffer
argument_list|)
expr_stmt|;
name|bytesWritten
operator|+=
name|testBuffer
operator|.
name|length
expr_stmt|;
block|}
block|}
return|return
name|bytesWritten
return|;
block|}
finally|finally
block|{
name|outputStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Creates and reads a file with the given size. The test file is generated    * according to a specific pattern so it can be easily verified even if it's    * a multi-GB one.    * During the read phase the incoming data stream is also checked against    * this pattern.    *    * @param fs FileSystem    * @param parent Test file parent dir path    * @throws IOException    *    thrown if an I/O error occurs while writing or reading the test file    */
DECL|method|createAndVerifyFile (FileSystem fs, Path parent, final long fileSize)
specifier|public
specifier|static
name|void
name|createAndVerifyFile
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|parent
parameter_list|,
specifier|final
name|long
name|fileSize
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|testBufferSize
init|=
name|fs
operator|.
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|IO_CHUNK_BUFFER_SIZE
argument_list|,
name|DEFAULT_IO_CHUNK_BUFFER_SIZE
argument_list|)
decl_stmt|;
name|int
name|modulus
init|=
name|fs
operator|.
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|IO_CHUNK_MODULUS_SIZE
argument_list|,
name|DEFAULT_IO_CHUNK_MODULUS_SIZE
argument_list|)
decl_stmt|;
specifier|final
name|String
name|objectName
init|=
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|objectPath
init|=
operator|new
name|Path
argument_list|(
name|parent
argument_list|,
name|objectName
argument_list|)
decl_stmt|;
comment|// Write test file in a specific pattern
name|assertEquals
argument_list|(
name|fileSize
argument_list|,
name|generateTestFile
argument_list|(
name|fs
argument_list|,
name|objectPath
argument_list|,
name|fileSize
argument_list|,
name|testBufferSize
argument_list|,
name|modulus
argument_list|)
argument_list|)
expr_stmt|;
name|assertPathExists
argument_list|(
name|fs
argument_list|,
literal|"not created successful"
argument_list|,
name|objectPath
argument_list|)
expr_stmt|;
comment|// Now read the same file back and verify its content
try|try
block|{
name|verifyReceivedData
argument_list|(
name|fs
argument_list|,
name|objectPath
argument_list|,
name|fileSize
argument_list|,
name|testBufferSize
argument_list|,
name|modulus
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// Delete test file
name|fs
operator|.
name|delete
argument_list|(
name|objectPath
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

