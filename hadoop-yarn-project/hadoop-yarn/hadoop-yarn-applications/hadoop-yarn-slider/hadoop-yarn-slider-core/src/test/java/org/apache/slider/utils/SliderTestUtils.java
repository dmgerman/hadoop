begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.slider.utils
package|package
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|utils
package|;
end_package

begin_import
import|import
name|com
operator|.
name|fasterxml
operator|.
name|jackson
operator|.
name|core
operator|.
name|JsonProcessingException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|fasterxml
operator|.
name|jackson
operator|.
name|databind
operator|.
name|ObjectMapper
import|;
end_import

begin_import
import|import
name|com
operator|.
name|fasterxml
operator|.
name|jackson
operator|.
name|databind
operator|.
name|ObjectReader
import|;
end_import

begin_import
import|import
name|com
operator|.
name|fasterxml
operator|.
name|jackson
operator|.
name|databind
operator|.
name|ObjectWriter
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gson
operator|.
name|Gson
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gson
operator|.
name|GsonBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|gson
operator|.
name|JsonParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|registry
operator|.
name|client
operator|.
name|types
operator|.
name|ServiceRecord
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|ServiceStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|resource
operator|.
name|Application
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|api
operator|.
name|resource
operator|.
name|Container
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|client
operator|.
name|SliderClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|service
operator|.
name|client
operator|.
name|params
operator|.
name|Arguments
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|Duration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|common
operator|.
name|tools
operator|.
name|SliderUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|main
operator|.
name|LauncherExitCodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|main
operator|.
name|ServiceLaunchException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|main
operator|.
name|ServiceLauncher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|persist
operator|.
name|JsonSerDeser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|registry
operator|.
name|docstore
operator|.
name|PublishedConfigSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|core
operator|.
name|registry
operator|.
name|docstore
operator|.
name|PublishedConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|slider
operator|.
name|server
operator|.
name|services
operator|.
name|workflow
operator|.
name|ForkedProcessService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|map
operator|.
name|PropertyNamingStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assume
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|service
operator|.
name|client
operator|.
name|params
operator|.
name|Arguments
operator|.
name|ARG_OPTION
import|;
end_import

begin_comment
comment|/**  * Static utils for tests in this package and in other test projects.  *  * It is designed to work with mini clusters as well as remote ones  *  * This class is not final and may be extended for test cases.  *  * Some of these methods are derived from the SwiftUtils and SwiftTestUtils  * classes -replicated here so that they are available in Hadoop-2.0 code  */
end_comment

begin_class
DECL|class|SliderTestUtils
specifier|public
class|class
name|SliderTestUtils
extends|extends
name|Assert
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|SliderTestUtils
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEFAULT_SLIDER_CLIENT
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_SLIDER_CLIENT
init|=
name|SliderClient
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
DECL|field|sliderClientClassName
specifier|private
specifier|static
name|String
name|sliderClientClassName
init|=
name|DEFAULT_SLIDER_CLIENT
decl_stmt|;
DECL|field|EMPTY_MAP
specifier|public
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|EMPTY_MAP
init|=
name|Collections
operator|.
name|emptyMap
argument_list|()
decl_stmt|;
DECL|field|EMPTY_INT_MAP
specifier|public
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|EMPTY_INT_MAP
init|=
name|Collections
operator|.
name|emptyMap
argument_list|()
decl_stmt|;
DECL|field|EMPTY_LIST
specifier|public
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|EMPTY_LIST
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
DECL|field|OBJECT_READER
specifier|public
specifier|static
specifier|final
name|ObjectReader
name|OBJECT_READER
decl_stmt|;
DECL|field|OBJECT_WRITER
specifier|public
specifier|static
specifier|final
name|ObjectWriter
name|OBJECT_WRITER
decl_stmt|;
DECL|field|JSON_SER_DESER
specifier|public
specifier|static
specifier|final
name|JsonSerDeser
argument_list|<
name|Application
argument_list|>
name|JSON_SER_DESER
init|=
operator|new
name|JsonSerDeser
argument_list|<>
argument_list|(
name|Application
operator|.
name|class
argument_list|,
name|PropertyNamingStrategy
operator|.
name|CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES
argument_list|)
decl_stmt|;
static|static
block|{
name|ObjectMapper
name|mapper
init|=
operator|new
name|ObjectMapper
argument_list|()
decl_stmt|;
name|OBJECT_READER
operator|=
name|mapper
operator|.
name|readerFor
argument_list|(
name|Object
operator|.
name|class
argument_list|)
expr_stmt|;
name|OBJECT_WRITER
operator|=
name|mapper
operator|.
name|writer
argument_list|()
expr_stmt|;
block|}
comment|/**    * Action that returns an object.    */
DECL|interface|Action
specifier|public
interface|interface
name|Action
block|{
DECL|method|invoke ()
name|Object
name|invoke
parameter_list|()
throws|throws
name|Exception
function_decl|;
block|}
comment|/**    * Probe that returns an Outcome.    */
DECL|interface|Probe
specifier|public
interface|interface
name|Probe
block|{
DECL|method|invoke (Map args)
name|Outcome
name|invoke
parameter_list|(
name|Map
name|args
parameter_list|)
throws|throws
name|Exception
function_decl|;
block|}
DECL|method|setSliderClientClassName (String sliderClientClassName)
specifier|public
specifier|static
name|void
name|setSliderClientClassName
parameter_list|(
name|String
name|sliderClientClassName
parameter_list|)
block|{
name|sliderClientClassName
operator|=
name|sliderClientClassName
expr_stmt|;
block|}
DECL|method|describe (String s)
specifier|public
specifier|static
name|void
name|describe
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"==============================="
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"==============================="
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/**    * Convert a JSON string to something readable.    * @param json    * @return a string for printing    */
DECL|method|prettyPrintJson (String json)
specifier|public
specifier|static
name|String
name|prettyPrintJson
parameter_list|(
name|String
name|json
parameter_list|)
block|{
name|Gson
name|gson
init|=
operator|new
name|GsonBuilder
argument_list|()
operator|.
name|setPrettyPrinting
argument_list|()
operator|.
name|create
argument_list|()
decl_stmt|;
return|return
name|gson
operator|.
name|toJson
argument_list|(
operator|new
name|JsonParser
argument_list|()
operator|.
name|parse
argument_list|(
name|json
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Convert an object to something readable.    * @param src    * @return a string for printing    */
DECL|method|prettyPrintAsJson (Object src)
specifier|public
specifier|static
name|String
name|prettyPrintAsJson
parameter_list|(
name|Object
name|src
parameter_list|)
throws|throws
name|JsonProcessingException
throws|,
name|UnsupportedEncodingException
block|{
return|return
operator|new
name|String
argument_list|(
name|OBJECT_WRITER
operator|.
name|writeValueAsBytes
argument_list|(
name|src
argument_list|)
argument_list|,
literal|"UTF8"
argument_list|)
return|;
block|}
comment|/**    * Skip the test with a message.    * @param message message logged and thrown    */
DECL|method|skip (String message)
specifier|public
specifier|static
name|void
name|skip
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Skipping test: {}"
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|Assume
operator|.
name|assumeTrue
argument_list|(
name|message
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Skip the test with a message if condition holds.    * @param condition predicate    * @param message message logged and thrown    */
DECL|method|assume (boolean condition, String message)
specifier|public
specifier|static
name|void
name|assume
parameter_list|(
name|boolean
name|condition
parameter_list|,
name|String
name|message
parameter_list|)
block|{
if|if
condition|(
operator|!
name|condition
condition|)
block|{
name|skip
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Skip a test if not running on Windows.    */
DECL|method|assumeWindows ()
specifier|public
specifier|static
name|void
name|assumeWindows
parameter_list|()
block|{
name|assume
argument_list|(
name|Shell
operator|.
name|WINDOWS
argument_list|,
literal|"not windows"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Skip a test if running on Windows.    */
DECL|method|assumeNotWindows ()
specifier|public
specifier|static
name|void
name|assumeNotWindows
parameter_list|()
block|{
name|assume
argument_list|(
operator|!
name|Shell
operator|.
name|WINDOWS
argument_list|,
literal|"windows"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Skip a test on windows.    */
DECL|method|skipOnWindows ()
specifier|public
specifier|static
name|void
name|skipOnWindows
parameter_list|()
block|{
name|assumeNotWindows
argument_list|()
expr_stmt|;
block|}
comment|/**    * Equality size for a list.    * @param left    * @param right    */
DECL|method|assertListEquals (List left, List right)
specifier|public
specifier|static
name|void
name|assertListEquals
parameter_list|(
name|List
name|left
parameter_list|,
name|List
name|right
parameter_list|)
block|{
name|String
name|lval
init|=
name|collectionToString
argument_list|(
name|left
argument_list|)
decl_stmt|;
name|String
name|rval
init|=
name|collectionToString
argument_list|(
name|right
argument_list|)
decl_stmt|;
name|String
name|text
init|=
literal|"comparing "
operator|+
name|lval
operator|+
literal|" to "
operator|+
name|rval
decl_stmt|;
name|assertEquals
argument_list|(
name|text
argument_list|,
name|left
operator|.
name|size
argument_list|()
argument_list|,
name|right
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|left
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|assertEquals
argument_list|(
name|text
argument_list|,
name|left
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|right
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Assert a list has a given length.    * @param list list    * @param size size to have    */
DECL|method|assertListLength (List list, int size)
specifier|public
specifier|static
name|void
name|assertListLength
parameter_list|(
name|List
name|list
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|String
name|lval
init|=
name|collectionToString
argument_list|(
name|list
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|lval
argument_list|,
name|size
argument_list|,
name|list
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Stringify a collection with [ ] at either end.    * @param collection collection    * @return string value    */
DECL|method|collectionToString (List collection)
specifier|public
specifier|static
name|String
name|collectionToString
parameter_list|(
name|List
name|collection
parameter_list|)
block|{
return|return
literal|"["
operator|+
name|SliderUtils
operator|.
name|join
argument_list|(
name|collection
argument_list|,
literal|", "
argument_list|,
literal|false
argument_list|)
operator|+
literal|"]"
return|;
block|}
comment|/**    * Assume that a string option is set and not equal to "".    * @param conf configuration file    * @param key key to look for    */
DECL|method|assumeStringOptionSet (Configuration conf, String key)
specifier|public
specifier|static
name|void
name|assumeStringOptionSet
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|key
parameter_list|)
block|{
if|if
condition|(
name|SliderUtils
operator|.
name|isUnset
argument_list|(
name|conf
operator|.
name|getTrimmed
argument_list|(
name|key
argument_list|)
argument_list|)
condition|)
block|{
name|skip
argument_list|(
literal|"Configuration key "
operator|+
name|key
operator|+
literal|" not set"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * assert that a string option is set and not equal to "".    * @param conf configuration file    * @param key key to look for    */
DECL|method|assertStringOptionSet (Configuration conf, String key)
specifier|public
specifier|static
name|void
name|assertStringOptionSet
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|key
parameter_list|)
block|{
name|getRequiredConfOption
argument_list|(
name|conf
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assume that a boolean option is set and true.    * Unset or false triggers a test skip    * @param conf configuration file    * @param key key to look for    */
DECL|method|assumeBoolOptionTrue (Configuration conf, String key)
specifier|public
specifier|static
name|void
name|assumeBoolOptionTrue
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|key
parameter_list|)
block|{
name|assumeBoolOption
argument_list|(
name|conf
argument_list|,
name|key
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assume that a boolean option is true.    * False triggers a test skip    * @param conf configuration file    * @param key key to look for    * @param defval default value if the property is not defined    */
DECL|method|assumeBoolOption ( Configuration conf, String key, boolean defval)
specifier|public
specifier|static
name|void
name|assumeBoolOption
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|key
parameter_list|,
name|boolean
name|defval
parameter_list|)
block|{
name|assume
argument_list|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|key
argument_list|,
name|defval
argument_list|)
argument_list|,
literal|"Configuration key "
operator|+
name|key
operator|+
literal|" is false"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get a required config option (trimmed, incidentally).    * Test will fail if not set    * @param conf configuration    * @param key key    * @return the string    */
DECL|method|getRequiredConfOption (Configuration conf, String key)
specifier|public
specifier|static
name|String
name|getRequiredConfOption
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|key
parameter_list|)
block|{
name|String
name|val
init|=
name|conf
operator|.
name|getTrimmed
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|SliderUtils
operator|.
name|isUnset
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|fail
argument_list|(
literal|"Missing configuration option "
operator|+
name|key
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
comment|/**    * Fails a test because required behavior has not been implemented.    */
DECL|method|failNotImplemented ()
specifier|public
specifier|static
name|void
name|failNotImplemented
parameter_list|()
block|{
name|fail
argument_list|(
literal|"Not implemented"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that any needed libraries being present. On Unix none are needed;    * on windows they must be present    */
DECL|method|assertNativeLibrariesPresent ()
specifier|public
specifier|static
name|void
name|assertNativeLibrariesPresent
parameter_list|()
block|{
name|String
name|errorText
init|=
name|SliderUtils
operator|.
name|checkForRequiredNativeLibraries
argument_list|()
decl_stmt|;
if|if
condition|(
name|SliderUtils
operator|.
name|isSet
argument_list|(
name|errorText
argument_list|)
condition|)
block|{
name|fail
argument_list|(
name|errorText
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|toArray (List<Object> args)
specifier|protected
specifier|static
name|String
index|[]
name|toArray
parameter_list|(
name|List
argument_list|<
name|Object
argument_list|>
name|args
parameter_list|)
block|{
name|String
index|[]
name|converted
init|=
operator|new
name|String
index|[
name|args
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Object
name|elt
init|=
name|args
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
name|args
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|converted
index|[
name|i
index|]
operator|=
name|elt
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
return|return
name|converted
return|;
block|}
DECL|method|waitWhileClusterLive (SliderClient client, int timeout)
specifier|public
specifier|static
name|void
name|waitWhileClusterLive
parameter_list|(
name|SliderClient
name|client
parameter_list|,
name|int
name|timeout
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
name|Duration
name|duration
init|=
operator|new
name|Duration
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
name|duration
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
name|client
operator|.
name|actionExists
argument_list|(
name|client
operator|.
name|getDeployedClusterName
argument_list|()
argument_list|,
literal|true
argument_list|)
operator|==
name|LauncherExitCodes
operator|.
name|EXIT_SUCCESS
operator|&&
operator|!
name|duration
operator|.
name|getLimitExceeded
argument_list|()
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{       }
block|}
if|if
condition|(
name|duration
operator|.
name|getLimitExceeded
argument_list|()
condition|)
block|{
name|fail
argument_list|(
literal|"Cluster "
operator|+
name|client
operator|.
name|getDeployedClusterName
argument_list|()
operator|+
literal|" still live after "
operator|+
name|timeout
operator|+
literal|" ms"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|waitUntilClusterLive (SliderClient client, int timeout)
specifier|public
specifier|static
name|void
name|waitUntilClusterLive
parameter_list|(
name|SliderClient
name|client
parameter_list|,
name|int
name|timeout
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
name|Duration
name|duration
init|=
operator|new
name|Duration
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
name|duration
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
name|LauncherExitCodes
operator|.
name|EXIT_SUCCESS
operator|!=
name|client
operator|.
name|actionExists
argument_list|(
name|client
operator|.
name|getDeployedClusterName
argument_list|()
argument_list|,
literal|true
argument_list|)
operator|&&
operator|!
name|duration
operator|.
name|getLimitExceeded
argument_list|()
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{       }
block|}
if|if
condition|(
name|duration
operator|.
name|getLimitExceeded
argument_list|()
condition|)
block|{
name|fail
argument_list|(
literal|"Cluster "
operator|+
name|client
operator|.
name|getDeployedClusterName
argument_list|()
operator|+
literal|" not live after "
operator|+
name|timeout
operator|+
literal|" ms"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|dumpClusterDescription ( String text, Application status)
specifier|public
specifier|static
name|void
name|dumpClusterDescription
parameter_list|(
name|String
name|text
parameter_list|,
name|Application
name|status
parameter_list|)
throws|throws
name|IOException
block|{
name|describe
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|JSON_SER_DESER
operator|.
name|toJson
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that a service operation succeeded.    * @param service service    */
DECL|method|assertSucceeded (ServiceLauncher service)
specifier|public
specifier|static
name|void
name|assertSucceeded
parameter_list|(
name|ServiceLauncher
name|service
parameter_list|)
block|{
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|service
operator|.
name|getServiceExitCode
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|assertContainersLive (Application application, String component, int expected)
specifier|public
specifier|static
name|void
name|assertContainersLive
parameter_list|(
name|Application
name|application
parameter_list|,
name|String
name|component
parameter_list|,
name|int
name|expected
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Asserting component {} expected count {}"
argument_list|,
name|component
argument_list|,
name|expected
argument_list|)
expr_stmt|;
name|int
name|actual
init|=
name|extractLiveContainerCount
argument_list|(
name|application
argument_list|,
name|component
argument_list|)
decl_stmt|;
if|if
condition|(
name|expected
operator|!=
name|actual
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"{} actual={}, expected {} in \n{}\n"
argument_list|,
name|component
argument_list|,
name|actual
argument_list|,
name|expected
argument_list|,
name|application
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|actual
argument_list|)
expr_stmt|;
block|}
comment|/**    * Robust extraction of live container count.    * @param application status    * @param component component to resolve    * @return the number of containers live.    */
DECL|method|extractLiveContainerCount ( Application application, String component)
specifier|public
specifier|static
name|int
name|extractLiveContainerCount
parameter_list|(
name|Application
name|application
parameter_list|,
name|String
name|component
parameter_list|)
block|{
name|int
name|actual
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|application
operator|.
name|getContainers
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Container
name|container
range|:
name|application
operator|.
name|getContainers
argument_list|()
control|)
block|{
if|if
condition|(
name|container
operator|.
name|getComponentName
argument_list|()
operator|.
name|equals
argument_list|(
name|component
argument_list|)
condition|)
block|{
name|actual
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|actual
return|;
block|}
comment|/**    * Exec a set of commands, wait a few seconds for it to finish.    * @param status code    * @param commands    * @return the process    */
DECL|method|exec (int status, List<String> commands)
specifier|public
specifier|static
name|ForkedProcessService
name|exec
parameter_list|(
name|int
name|status
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|commands
parameter_list|)
throws|throws
name|IOException
throws|,
name|TimeoutException
block|{
name|ForkedProcessService
name|process
init|=
name|exec
argument_list|(
name|commands
argument_list|)
decl_stmt|;
name|Integer
name|exitCode
init|=
name|process
operator|.
name|getExitCode
argument_list|()
decl_stmt|;
name|assertNotNull
argument_list|(
name|exitCode
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|status
argument_list|,
name|exitCode
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|process
return|;
block|}
comment|/**    * Exec a set of commands, wait a few seconds for it to finish.    * @param commands    * @return    */
DECL|method|exec (List<String> commands)
specifier|public
specifier|static
name|ForkedProcessService
name|exec
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|commands
parameter_list|)
throws|throws
name|IOException
throws|,
name|TimeoutException
block|{
name|ForkedProcessService
name|process
decl_stmt|;
name|process
operator|=
operator|new
name|ForkedProcessService
argument_list|(
name|commands
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|EMPTY_MAP
argument_list|,
name|commands
argument_list|)
expr_stmt|;
name|process
operator|.
name|init
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|)
expr_stmt|;
name|process
operator|.
name|start
argument_list|()
expr_stmt|;
name|int
name|timeoutMillis
init|=
literal|5000
decl_stmt|;
if|if
condition|(
operator|!
name|process
operator|.
name|waitForServiceToStop
argument_list|(
name|timeoutMillis
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|TimeoutException
argument_list|(
literal|"Process did not stop in "
operator|+
name|timeoutMillis
operator|+
literal|"mS"
argument_list|)
throw|;
block|}
return|return
name|process
return|;
block|}
comment|/**    * Determine whether an application exists. Run the commands and if the    * operation fails with a FileNotFoundException, then    * this method returns false.    *<p>    *   Run something harmless like a -version command, something    *   which must return 0    *    * @param commands    * @return true if the command sequence succeeded    * false if they failed with no file    * @throws Exception on any other failure cause    */
DECL|method|doesAppExist (List<String> commands)
specifier|public
specifier|static
name|boolean
name|doesAppExist
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|commands
parameter_list|)
throws|throws
name|IOException
throws|,
name|TimeoutException
block|{
try|try
block|{
name|exec
argument_list|(
literal|0
argument_list|,
name|commands
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|ServiceStateException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|FileNotFoundException
operator|)
condition|)
block|{
throw|throw
name|e
throw|;
block|}
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Locate an executable on the path.    * @param exe executable name. If it is an absolute path which    * exists then it will returned direct    * @return the path to an exe or null for no match    */
DECL|method|locateExecutable (String exe)
specifier|public
specifier|static
name|File
name|locateExecutable
parameter_list|(
name|String
name|exe
parameter_list|)
block|{
name|File
name|exeNameAsPath
init|=
operator|new
name|File
argument_list|(
name|exe
argument_list|)
operator|.
name|getAbsoluteFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|exeNameAsPath
operator|.
name|exists
argument_list|()
condition|)
block|{
return|return
name|exeNameAsPath
return|;
block|}
name|File
name|exepath
init|=
literal|null
decl_stmt|;
name|String
name|path
init|=
name|extractPath
argument_list|()
decl_stmt|;
name|String
index|[]
name|dirs
init|=
name|path
operator|.
name|split
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"path.separator"
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|dirname
range|:
name|dirs
control|)
block|{
name|File
name|dir
init|=
operator|new
name|File
argument_list|(
name|dirname
argument_list|)
decl_stmt|;
name|File
name|possible
init|=
operator|new
name|File
argument_list|(
name|dir
argument_list|,
name|exe
argument_list|)
decl_stmt|;
if|if
condition|(
name|possible
operator|.
name|exists
argument_list|()
condition|)
block|{
name|exepath
operator|=
name|possible
expr_stmt|;
block|}
block|}
return|return
name|exepath
return|;
block|}
comment|/**    * Lookup the PATH env var.    * @return the path or null    */
DECL|method|extractPath ()
specifier|public
specifier|static
name|String
name|extractPath
parameter_list|()
block|{
return|return
name|extractEnvVar
argument_list|(
literal|"PATH"
argument_list|)
return|;
block|}
comment|/**    * Find an environment variable. Uses case independent checking for    * the benefit of windows.    * Will fail if the var is not found.    * @param var path variable<i>in upper case</i>    * @return the env var    */
DECL|method|extractEnvVar (String var)
specifier|public
specifier|static
name|String
name|extractEnvVar
parameter_list|(
name|String
name|var
parameter_list|)
block|{
name|String
name|realkey
init|=
literal|""
decl_stmt|;
for|for
control|(
name|String
name|it
range|:
name|System
operator|.
name|getenv
argument_list|()
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|it
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|)
operator|.
name|equals
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|realkey
operator|=
name|it
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SliderUtils
operator|.
name|isUnset
argument_list|(
name|realkey
argument_list|)
condition|)
block|{
name|fail
argument_list|(
literal|"No environment variable "
operator|+
name|var
operator|+
literal|" found"
argument_list|)
expr_stmt|;
block|}
name|String
name|val
init|=
name|System
operator|.
name|getenv
argument_list|(
name|realkey
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{} = {}"
argument_list|,
name|realkey
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
comment|/**    * Create a temp JSON file. After coming up with the name, the file    * is deleted    * @return the filename    */
DECL|method|createTempJsonFile ()
specifier|public
specifier|static
name|File
name|createTempJsonFile
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|tmpFile
argument_list|(
literal|".json"
argument_list|)
return|;
block|}
comment|/**    * Create a temp file with the specific name. It's deleted after creation,    * to avoid  "file exists exceptions"    * @param suffix suffix, e.g. ".txt"    * @return a path to a file which may be created    */
DECL|method|tmpFile (String suffix)
specifier|public
specifier|static
name|File
name|tmpFile
parameter_list|(
name|String
name|suffix
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|reportFile
init|=
name|File
operator|.
name|createTempFile
argument_list|(
literal|"temp"
argument_list|,
name|suffix
argument_list|,
operator|new
name|File
argument_list|(
literal|"target"
argument_list|)
argument_list|)
decl_stmt|;
name|reportFile
operator|.
name|delete
argument_list|()
expr_stmt|;
return|return
name|reportFile
return|;
block|}
comment|/**    * Execute a closure, assert it fails with a given exit code and text.    * @param exitCode exit code    * @param text text (can be "")    * @param action action    * @return    */
DECL|method|assertFailsWithException (int exitCode, String text, Action action)
specifier|public
name|void
name|assertFailsWithException
parameter_list|(
name|int
name|exitCode
parameter_list|,
name|String
name|text
parameter_list|,
name|Action
name|action
parameter_list|)
throws|throws
name|Exception
block|{
try|try
block|{
name|action
operator|.
name|invoke
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Operation was expected to fail âbut it succeeded"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ServiceLaunchException
name|e
parameter_list|)
block|{
name|assertExceptionDetails
argument_list|(
name|e
argument_list|,
name|exitCode
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Execute a closure, assert it fails with a given exit code and text.    * @param text text (can be "")    * @param action action    * @return    */
DECL|method|assertFailsWithExceptionClass (Class clazz, String text, Action action)
specifier|public
name|void
name|assertFailsWithExceptionClass
parameter_list|(
name|Class
name|clazz
parameter_list|,
name|String
name|text
parameter_list|,
name|Action
name|action
parameter_list|)
throws|throws
name|Exception
block|{
try|try
block|{
name|action
operator|.
name|invoke
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Operation was expected to fail âbut it succeeded"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|assertExceptionDetails
argument_list|(
name|e
argument_list|,
name|clazz
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|assertExceptionDetails ( ServiceLaunchException ex, int exitCode)
specifier|public
specifier|static
name|void
name|assertExceptionDetails
parameter_list|(
name|ServiceLaunchException
name|ex
parameter_list|,
name|int
name|exitCode
parameter_list|)
block|{
name|assertExceptionDetails
argument_list|(
name|ex
argument_list|,
name|exitCode
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Make an assertion about the exit code of an exception.    * @param ex exception    * @param exitCode exit code    * @param text error text to look for in the exception    */
DECL|method|assertExceptionDetails ( ServiceLaunchException ex, int exitCode, String text)
specifier|public
specifier|static
name|void
name|assertExceptionDetails
parameter_list|(
name|ServiceLaunchException
name|ex
parameter_list|,
name|int
name|exitCode
parameter_list|,
name|String
name|text
parameter_list|)
block|{
if|if
condition|(
name|exitCode
operator|!=
name|ex
operator|.
name|getExitCode
argument_list|()
condition|)
block|{
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Wrong exit code, expected %d but"
operator|+
literal|" got %d in %s"
argument_list|,
name|exitCode
argument_list|,
name|ex
operator|.
name|getExitCode
argument_list|()
argument_list|,
name|ex
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|message
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
name|message
argument_list|,
name|ex
argument_list|)
throw|;
block|}
if|if
condition|(
name|SliderUtils
operator|.
name|isSet
argument_list|(
name|text
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ex
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
name|text
argument_list|)
operator|)
condition|)
block|{
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
literal|"String match for \"%s\"failed in %s"
argument_list|,
name|text
argument_list|,
name|ex
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|message
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
name|message
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Make an assertion about the class of an exception.    * @param ex exception    * @param clazz exit code    * @param text error text to look for in the exception    */
DECL|method|assertExceptionDetails ( Exception ex, Class clazz, String text)
specifier|static
name|void
name|assertExceptionDetails
parameter_list|(
name|Exception
name|ex
parameter_list|,
name|Class
name|clazz
parameter_list|,
name|String
name|text
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|ex
operator|.
name|getClass
argument_list|()
operator|!=
name|clazz
condition|)
block|{
throw|throw
name|ex
throw|;
block|}
if|if
condition|(
name|SliderUtils
operator|.
name|isSet
argument_list|(
name|text
argument_list|)
operator|&&
operator|!
operator|(
name|ex
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
name|text
argument_list|)
operator|)
condition|)
block|{
throw|throw
name|ex
throw|;
block|}
block|}
comment|/**    * Launch the slider client with the specific args; no validation    * of return code takes place.    * @param conf configuration    * @param args arg list    * @return the launcher    */
DECL|method|execSliderCommand ( Configuration conf, List args)
specifier|protected
specifier|static
name|ServiceLauncher
argument_list|<
name|SliderClient
argument_list|>
name|execSliderCommand
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|List
name|args
parameter_list|)
throws|throws
name|Throwable
block|{
name|ServiceLauncher
argument_list|<
name|SliderClient
argument_list|>
name|serviceLauncher
init|=
operator|new
name|ServiceLauncher
argument_list|<>
argument_list|(
name|sliderClientClassName
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"slider {}"
argument_list|,
name|SliderUtils
operator|.
name|join
argument_list|(
name|args
argument_list|,
literal|" "
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|serviceLauncher
operator|.
name|launchService
argument_list|(
name|conf
argument_list|,
name|toArray
argument_list|(
name|args
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|serviceLauncher
return|;
block|}
comment|/**    * Launch a slider command to a given exit code.    * Most failures will trigger exceptions; this is for the exit code of the    * runService() call.    * @param exitCode desired exit code    * @param conf configuration    * @param args arg list    * @return the launcher    */
DECL|method|execSliderCommand ( int exitCode, Configuration conf, List args)
specifier|protected
specifier|static
name|ServiceLauncher
argument_list|<
name|SliderClient
argument_list|>
name|execSliderCommand
parameter_list|(
name|int
name|exitCode
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|List
name|args
parameter_list|)
throws|throws
name|Throwable
block|{
name|ServiceLauncher
argument_list|<
name|SliderClient
argument_list|>
name|serviceLauncher
init|=
name|execSliderCommand
argument_list|(
name|conf
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|exitCode
argument_list|,
name|serviceLauncher
operator|.
name|getServiceExitCode
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|serviceLauncher
return|;
block|}
DECL|method|launch (Class serviceClass, Configuration conf, List<Object> args)
specifier|public
specifier|static
name|ServiceLauncher
name|launch
parameter_list|(
name|Class
name|serviceClass
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|List
argument_list|<
name|Object
argument_list|>
name|args
parameter_list|)
throws|throws
name|Throwable
block|{
name|ServiceLauncher
name|serviceLauncher
init|=
operator|new
name|ServiceLauncher
argument_list|(
name|serviceClass
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|joinedArgs
init|=
name|SliderUtils
operator|.
name|join
argument_list|(
name|args
argument_list|,
literal|" "
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"slider {}"
argument_list|,
name|joinedArgs
argument_list|)
expr_stmt|;
name|serviceLauncher
operator|.
name|launchService
argument_list|(
name|conf
argument_list|,
name|toArray
argument_list|(
name|args
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|serviceLauncher
return|;
block|}
DECL|method|launchExpectingException (Class serviceClass, Configuration conf, String expectedText, List args)
specifier|public
specifier|static
name|Throwable
name|launchExpectingException
parameter_list|(
name|Class
name|serviceClass
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|String
name|expectedText
parameter_list|,
name|List
name|args
parameter_list|)
throws|throws
name|Throwable
block|{
try|try
block|{
name|ServiceLauncher
name|launch
init|=
name|launch
argument_list|(
name|serviceClass
argument_list|,
name|conf
argument_list|,
name|args
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Expected an exception with text containing "
operator|+
name|expectedText
operator|+
literal|" -but the service completed with exit code "
operator|+
name|launch
operator|.
name|getServiceExitCode
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|AssertionError
name|error
parameter_list|)
block|{
throw|throw
name|error
throw|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|thrown
parameter_list|)
block|{
if|if
condition|(
name|SliderUtils
operator|.
name|isSet
argument_list|(
name|expectedText
argument_list|)
operator|&&
operator|!
name|thrown
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
name|expectedText
argument_list|)
condition|)
block|{
comment|//not the right exception -rethrow
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught Exception did not contain expected text"
operator|+
literal|"\""
operator|+
name|expectedText
operator|+
literal|"\""
argument_list|)
expr_stmt|;
throw|throw
name|thrown
throw|;
block|}
return|return
name|thrown
return|;
block|}
block|}
DECL|method|launchClientAgainstRM ( String address, List<String> args, Configuration conf)
specifier|public
specifier|static
name|ServiceLauncher
argument_list|<
name|SliderClient
argument_list|>
name|launchClientAgainstRM
parameter_list|(
name|String
name|address
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|args
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|Throwable
block|{
name|assertNotNull
argument_list|(
name|address
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Connecting to rm at {}"
argument_list|,
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
operator|.
name|contains
argument_list|(
name|Arguments
operator|.
name|ARG_MANAGER
argument_list|)
condition|)
block|{
name|args
operator|.
name|add
argument_list|(
name|Arguments
operator|.
name|ARG_MANAGER
argument_list|)
expr_stmt|;
name|args
operator|.
name|add
argument_list|(
name|address
argument_list|)
expr_stmt|;
block|}
name|ServiceLauncher
argument_list|<
name|SliderClient
argument_list|>
name|launcher
init|=
name|execSliderCommand
argument_list|(
name|conf
argument_list|,
name|args
argument_list|)
decl_stmt|;
return|return
name|launcher
return|;
block|}
comment|/**    * Add a configuration parameter as a cluster configuration option.    * @param extraArgs extra arguments    * @param conf config    * @param option option    */
DECL|method|addClusterConfigOption ( List<String> extraArgs, YarnConfiguration conf, String option)
specifier|public
specifier|static
name|void
name|addClusterConfigOption
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|extraArgs
parameter_list|,
name|YarnConfiguration
name|conf
parameter_list|,
name|String
name|option
parameter_list|)
block|{
name|conf
operator|.
name|getTrimmed
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|extraArgs
operator|.
name|add
argument_list|(
name|ARG_OPTION
argument_list|)
expr_stmt|;
name|extraArgs
operator|.
name|add
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|extraArgs
operator|.
name|add
argument_list|(
name|getRequiredConfOption
argument_list|(
name|conf
argument_list|,
name|option
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that a path refers to a directory.    * @param fs filesystem    * @param path path of the directory    * @throws IOException on File IO problems    */
DECL|method|assertIsDirectory (FileSystem fs, Path path)
specifier|public
specifier|static
name|void
name|assertIsDirectory
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
name|fileStatus
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|assertIsDirectory
argument_list|(
name|fileStatus
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that a path refers to a directory.    * @param fileStatus stats to check    */
DECL|method|assertIsDirectory (FileStatus fileStatus)
specifier|public
specifier|static
name|void
name|assertIsDirectory
parameter_list|(
name|FileStatus
name|fileStatus
parameter_list|)
block|{
name|assertTrue
argument_list|(
literal|"Should be a dir -but isn't: "
operator|+
name|fileStatus
argument_list|,
name|fileStatus
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that a path exists -but make no assertions as to the    * type of that entry.    *    * @param fileSystem filesystem to examine    * @param message message to include in the assertion failure message    * @param path path in the filesystem    * @throws IOException IO problems    */
DECL|method|assertPathExists ( FileSystem fileSystem, String message, Path path)
specifier|public
specifier|static
name|void
name|assertPathExists
parameter_list|(
name|FileSystem
name|fileSystem
parameter_list|,
name|String
name|message
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|fileSystem
operator|.
name|exists
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|//failure, report it
name|fail
argument_list|(
name|message
operator|+
literal|": not found \""
operator|+
name|path
operator|+
literal|"\" in "
operator|+
name|path
operator|.
name|getParent
argument_list|()
operator|+
literal|"-"
operator|+
name|ls
argument_list|(
name|fileSystem
argument_list|,
name|path
operator|.
name|getParent
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Assert that a path does not exist.    *    * @param fileSystem filesystem to examine    * @param message message to include in the assertion failure message    * @param path path in the filesystem    * @throws IOException IO problems    */
DECL|method|assertPathDoesNotExist ( FileSystem fileSystem, String message, Path path)
specifier|public
specifier|static
name|void
name|assertPathDoesNotExist
parameter_list|(
name|FileSystem
name|fileSystem
parameter_list|,
name|String
name|message
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|FileStatus
name|status
init|=
name|fileSystem
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
comment|// a status back implies there is a file here
name|fail
argument_list|(
name|message
operator|+
literal|": unexpectedly found "
operator|+
name|path
operator|+
literal|" as  "
operator|+
name|status
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|expected
parameter_list|)
block|{
comment|//this is expected
block|}
block|}
comment|/**    * Assert that a FileSystem.listStatus on a dir finds the subdir/child entry.    * @param fs filesystem    * @param dir directory to scan    * @param subdir full path to look for    * @throws IOException IO probles    */
DECL|method|assertListStatusFinds (FileSystem fs, Path dir, Path subdir)
specifier|public
specifier|static
name|void
name|assertListStatusFinds
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|dir
parameter_list|,
name|Path
name|subdir
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
index|[]
name|stats
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|FileStatus
name|stat
range|:
name|stats
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|stat
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|.
name|getPath
argument_list|()
operator|.
name|equals
argument_list|(
name|subdir
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
literal|"Path "
operator|+
name|subdir
operator|+
literal|" not found in directory "
operator|+
name|dir
operator|+
literal|":"
operator|+
name|builder
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
comment|/**    * List a a path to string.    * @param fileSystem filesystem    * @param path directory    * @return a listing of the filestatuses of elements in the directory, one    * to a line, precedeed by the full path of the directory    * @throws IOException connectivity problems    */
DECL|method|ls (FileSystem fileSystem, Path path)
specifier|public
specifier|static
name|String
name|ls
parameter_list|(
name|FileSystem
name|fileSystem
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|path
operator|==
literal|null
condition|)
block|{
comment|//surfaces when someone calls getParent() on something at the top of
comment|// the path
return|return
literal|"/"
return|;
block|}
name|FileStatus
index|[]
name|stats
decl_stmt|;
name|String
name|pathtext
init|=
literal|"ls "
operator|+
name|path
decl_stmt|;
try|try
block|{
name|stats
operator|=
name|fileSystem
operator|.
name|listStatus
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return
name|pathtext
operator|+
literal|" -file not found"
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
name|pathtext
operator|+
literal|" -failed: "
operator|+
name|e
return|;
block|}
return|return
name|pathtext
operator|+
name|fileStatsToString
argument_list|(
name|stats
argument_list|,
literal|"\n"
argument_list|)
return|;
block|}
comment|/**    * Take an array of filestats and convert to a string (prefixed w/ a [01]    * counter).    * @param stats array of stats    * @param separator separator after every entry    * @return a stringified set    */
DECL|method|fileStatsToString (FileStatus[] stats, String separator)
specifier|public
specifier|static
name|String
name|fileStatsToString
parameter_list|(
name|FileStatus
index|[]
name|stats
parameter_list|,
name|String
name|separator
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
name|stats
operator|.
name|length
operator|*
literal|128
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stats
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"[%02d] %s"
argument_list|,
name|i
argument_list|,
name|stats
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|separator
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|waitWhileClusterLive (SliderClient sliderClient)
specifier|public
specifier|static
name|void
name|waitWhileClusterLive
parameter_list|(
name|SliderClient
name|sliderClient
parameter_list|)
throws|throws
name|IOException
throws|,
name|YarnException
block|{
name|waitWhileClusterLive
argument_list|(
name|sliderClient
argument_list|,
literal|30000
argument_list|)
expr_stmt|;
block|}
DECL|method|dumpRegistryInstances ( Map<String, ServiceRecord> instances)
specifier|public
specifier|static
name|void
name|dumpRegistryInstances
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|ServiceRecord
argument_list|>
name|instances
parameter_list|)
block|{
name|describe
argument_list|(
literal|"service registry slider instances"
argument_list|)
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|String
argument_list|,
name|ServiceRecord
argument_list|>
name|it
range|:
name|instances
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|" {} : {}"
argument_list|,
name|it
operator|.
name|getKey
argument_list|()
argument_list|,
name|it
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|describe
argument_list|(
literal|"end list service registry slider instances"
argument_list|)
expr_stmt|;
block|}
DECL|method|dumpRegistryInstanceIDs (List<String> instanceIds)
specifier|public
specifier|static
name|void
name|dumpRegistryInstanceIDs
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|instanceIds
parameter_list|)
block|{
name|describe
argument_list|(
literal|"service registry instance IDs"
argument_list|)
expr_stmt|;
name|dumpCollection
argument_list|(
name|instanceIds
argument_list|)
expr_stmt|;
block|}
DECL|method|dumpRegistryServiceTypes (Collection<String> entries)
specifier|public
specifier|static
name|void
name|dumpRegistryServiceTypes
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|entries
parameter_list|)
block|{
name|describe
argument_list|(
literal|"service registry types"
argument_list|)
expr_stmt|;
name|dumpCollection
argument_list|(
name|entries
argument_list|)
expr_stmt|;
block|}
DECL|method|dumpCollection (Collection<V> entries)
specifier|public
specifier|static
parameter_list|<
name|V
parameter_list|>
name|void
name|dumpCollection
parameter_list|(
name|Collection
argument_list|<
name|V
argument_list|>
name|entries
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"number of entries: {}"
argument_list|,
name|entries
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|V
name|it
range|:
name|entries
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|it
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|dumpArray (Object[] entries)
specifier|public
specifier|static
name|void
name|dumpArray
parameter_list|(
name|Object
index|[]
name|entries
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"number of entries: {}"
argument_list|,
name|entries
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|Object
name|it
range|:
name|entries
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|it
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|dumpMap (Map<K, V> map)
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|void
name|dumpMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|it
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"\"{}\": \"{}\""
argument_list|,
name|it
operator|.
name|getKey
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|it
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get a time option in seconds if set, otherwise the default value (also    * in seconds).    * This operation picks up the time value as a system property if set -that    * value overrides anything in the test file    * @param conf    * @param key    * @param defValMillis    * @return    */
DECL|method|getTimeOptionMillis ( Configuration conf, String key, int defValMillis)
specifier|public
specifier|static
name|int
name|getTimeOptionMillis
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|key
parameter_list|,
name|int
name|defValMillis
parameter_list|)
block|{
name|int
name|val
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|key
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|val
operator|=
name|Integer
operator|.
name|getInteger
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|int
name|time
init|=
literal|1000
operator|*
name|val
decl_stmt|;
if|if
condition|(
name|time
operator|==
literal|0
condition|)
block|{
name|time
operator|=
name|defValMillis
expr_stmt|;
block|}
return|return
name|time
return|;
block|}
DECL|method|dumpConfigurationSet (PublishedConfigSet confSet)
specifier|public
name|void
name|dumpConfigurationSet
parameter_list|(
name|PublishedConfigSet
name|confSet
parameter_list|)
block|{
for|for
control|(
name|String
name|key
range|:
name|confSet
operator|.
name|keys
argument_list|()
control|)
block|{
name|PublishedConfiguration
name|config
init|=
name|confSet
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"{} -- {}"
argument_list|,
name|key
argument_list|,
name|config
operator|.
name|description
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Convert a file to a URI suitable for use in an argument.    * @param file file    * @return a URI string valid on all platforms    */
DECL|method|toURIArg (File file)
specifier|public
name|String
name|toURIArg
parameter_list|(
name|File
name|file
parameter_list|)
block|{
return|return
name|file
operator|.
name|getAbsoluteFile
argument_list|()
operator|.
name|toURI
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Assert a file exists; fails with a listing of the parent dir.    * @param text text for front of message    * @param file file to look for    * @throws FileNotFoundException    */
DECL|method|assertFileExists (String text, File file)
specifier|public
name|void
name|assertFileExists
parameter_list|(
name|String
name|text
parameter_list|,
name|File
name|file
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
if|if
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
name|File
name|parent
init|=
name|file
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
name|String
index|[]
name|files
init|=
name|parent
operator|.
name|list
argument_list|()
decl_stmt|;
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|parent
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|":\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|name
range|:
name|files
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|text
operator|+
literal|": "
operator|+
name|file
operator|+
literal|" not found in "
operator|+
name|builder
argument_list|)
throw|;
block|}
block|}
comment|/**    * Repeat a probe until it succeeds, if it does not execute a failure    * closure then raise an exception with the supplied message.    * @param probe probe    * @param timeout time in millis before giving up    * @param sleepDur sleep between failing attempts    * @param args map of arguments to the probe    * @param failIfUnsuccessful if the probe fails after all the attempts    * âshould it raise an exception    * @param failureMessage message to include in exception raised    * @param failureHandler closure to invoke prior to the failure being raised    */
DECL|method|repeatUntilSuccess ( String action, Probe probe, int timeout, int sleepDur, Map args, boolean failIfUnsuccessful, String failureMessage, Action failureHandler)
specifier|protected
name|void
name|repeatUntilSuccess
parameter_list|(
name|String
name|action
parameter_list|,
name|Probe
name|probe
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|sleepDur
parameter_list|,
name|Map
name|args
parameter_list|,
name|boolean
name|failIfUnsuccessful
parameter_list|,
name|String
name|failureMessage
parameter_list|,
name|Action
name|failureHandler
parameter_list|)
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Probe {} timelimit {}"
argument_list|,
name|action
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|<
literal|1000
condition|)
block|{
name|fail
argument_list|(
literal|"Timeout "
operator|+
name|timeout
operator|+
literal|" too low: milliseconds are expected, not "
operator|+
literal|"seconds"
argument_list|)
expr_stmt|;
block|}
name|int
name|attemptCount
init|=
literal|1
decl_stmt|;
name|boolean
name|succeeded
init|=
literal|false
decl_stmt|;
name|boolean
name|completed
init|=
literal|false
decl_stmt|;
name|Duration
name|duration
init|=
operator|new
name|Duration
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
name|duration
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|completed
condition|)
block|{
name|Outcome
name|outcome
init|=
name|probe
operator|.
name|invoke
argument_list|(
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|outcome
operator|.
name|equals
argument_list|(
name|Outcome
operator|.
name|SUCCESS
argument_list|)
condition|)
block|{
comment|// success
name|LOG
operator|.
name|debug
argument_list|(
literal|"Success after {} attempt(s)"
argument_list|,
name|attemptCount
argument_list|)
expr_stmt|;
name|succeeded
operator|=
literal|true
expr_stmt|;
name|completed
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|outcome
operator|.
name|equals
argument_list|(
name|Outcome
operator|.
name|RETRY
argument_list|)
condition|)
block|{
comment|// failed but retry possible
name|attemptCount
operator|++
expr_stmt|;
name|completed
operator|=
name|duration
operator|.
name|getLimitExceeded
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|completed
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempt {} failed"
argument_list|,
name|attemptCount
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepDur
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{           }
block|}
block|}
elseif|else
if|if
condition|(
name|outcome
operator|.
name|equals
argument_list|(
name|Outcome
operator|.
name|FAIL
argument_list|)
condition|)
block|{
comment|// fast fail
name|LOG
operator|.
name|debug
argument_list|(
literal|"Fast fail of probe"
argument_list|)
expr_stmt|;
name|completed
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|succeeded
condition|)
block|{
if|if
condition|(
name|duration
operator|.
name|getLimitExceeded
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"probe timed out after {} and {} attempts"
argument_list|,
name|timeout
argument_list|,
name|attemptCount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|failureHandler
operator|!=
literal|null
condition|)
block|{
name|failureHandler
operator|.
name|invoke
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|failIfUnsuccessful
condition|)
block|{
name|fail
argument_list|(
name|failureMessage
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Get a value from a map; raise an assertion if it is not there.    * @param map map to look up    * @param key key    * @return the string value    */
DECL|method|requiredMapValue (Map<K, V> map, String key)
specifier|public
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|String
name|requiredMapValue
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|String
name|key
parameter_list|)
block|{
name|assertNotNull
argument_list|(
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|assertStringContains (String expected, String text)
specifier|public
specifier|static
name|void
name|assertStringContains
parameter_list|(
name|String
name|expected
parameter_list|,
name|String
name|text
parameter_list|)
block|{
name|assertNotNull
argument_list|(
literal|"null text"
argument_list|,
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|text
operator|.
name|contains
argument_list|(
name|expected
argument_list|)
condition|)
block|{
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
literal|"did not find %s in \"%s\""
argument_list|,
name|expected
argument_list|,
name|text
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|fail
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

