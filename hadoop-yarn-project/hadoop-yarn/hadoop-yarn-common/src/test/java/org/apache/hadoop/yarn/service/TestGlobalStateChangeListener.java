begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *       http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.service
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|service
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_comment
comment|/**  * Test global state changes. It is critical for all tests to clean up the  * global listener afterwards to avoid interfering with follow-on tests.  *  * One listener, {@link #listener} is defined which is automatically  * unregistered on cleanup. All other listeners must be unregistered in the  * finally clauses of the tests.  */
end_comment

begin_class
DECL|class|TestGlobalStateChangeListener
specifier|public
class|class
name|TestGlobalStateChangeListener
extends|extends
name|ServiceAssert
block|{
DECL|field|listener
name|BreakableStateChangeListener
name|listener
init|=
operator|new
name|BreakableStateChangeListener
argument_list|(
literal|"listener"
argument_list|)
decl_stmt|;
DECL|method|register ()
specifier|private
name|void
name|register
parameter_list|()
block|{
name|register
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
DECL|method|unregister ()
specifier|private
name|boolean
name|unregister
parameter_list|()
block|{
return|return
name|unregister
argument_list|(
name|listener
argument_list|)
return|;
block|}
DECL|method|register (ServiceStateChangeListener l)
specifier|private
name|void
name|register
parameter_list|(
name|ServiceStateChangeListener
name|l
parameter_list|)
block|{
name|AbstractService
operator|.
name|registerGlobalListener
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
DECL|method|unregister (ServiceStateChangeListener l)
specifier|private
name|boolean
name|unregister
parameter_list|(
name|ServiceStateChangeListener
name|l
parameter_list|)
block|{
return|return
name|AbstractService
operator|.
name|unregisterGlobalListener
argument_list|(
name|l
argument_list|)
return|;
block|}
comment|/**    * After every test case reset the list of global listeners.    */
annotation|@
name|After
DECL|method|cleanup ()
specifier|public
name|void
name|cleanup
parameter_list|()
block|{
name|AbstractService
operator|.
name|resetGlobalListeners
argument_list|()
expr_stmt|;
block|}
comment|/**    * Assert that the last state of the listener is that the test expected.    * @param breakable a breakable listener    * @param state the expected state    */
DECL|method|assertListenerState (BreakableStateChangeListener breakable, Service.STATE state)
specifier|public
name|void
name|assertListenerState
parameter_list|(
name|BreakableStateChangeListener
name|breakable
parameter_list|,
name|Service
operator|.
name|STATE
name|state
parameter_list|)
block|{
name|assertEquals
argument_list|(
literal|"Wrong state in "
operator|+
name|breakable
argument_list|,
name|state
argument_list|,
name|breakable
operator|.
name|getLastState
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that the number of state change notifications matches expectations.    * @param breakable the listener    * @param count the expected count.    */
DECL|method|assertListenerEventCount (BreakableStateChangeListener breakable, int count)
specifier|public
name|void
name|assertListenerEventCount
parameter_list|(
name|BreakableStateChangeListener
name|breakable
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|assertEquals
argument_list|(
literal|"Wrong event count in "
operator|+
name|breakable
argument_list|,
name|count
argument_list|,
name|breakable
operator|.
name|getEventCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that register/unregister works    */
annotation|@
name|Test
DECL|method|testRegisterListener ()
specifier|public
name|void
name|testRegisterListener
parameter_list|()
block|{
name|register
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"listener not registered"
argument_list|,
name|unregister
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that double registration results in one registration only.    */
annotation|@
name|Test
DECL|method|testRegisterListenerTwice ()
specifier|public
name|void
name|testRegisterListenerTwice
parameter_list|()
block|{
name|register
argument_list|()
expr_stmt|;
name|register
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
literal|"listener not registered"
argument_list|,
name|unregister
argument_list|()
argument_list|)
expr_stmt|;
comment|//there should be no listener to unregister the second time
name|assertFalse
argument_list|(
literal|"listener double registered"
argument_list|,
name|unregister
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that the {@link BreakableStateChangeListener} is picking up    * the state changes and that its last event field is as expected.    */
annotation|@
name|Test
DECL|method|testEventHistory ()
specifier|public
name|void
name|testEventHistory
parameter_list|()
block|{
name|register
argument_list|()
expr_stmt|;
name|BreakableService
name|service
init|=
operator|new
name|BreakableService
argument_list|()
decl_stmt|;
name|assertListenerState
argument_list|(
name|listener
argument_list|,
name|Service
operator|.
name|STATE
operator|.
name|NOTINITED
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|listener
operator|.
name|getEventCount
argument_list|()
argument_list|)
expr_stmt|;
name|service
operator|.
name|init
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|)
expr_stmt|;
name|assertListenerState
argument_list|(
name|listener
argument_list|,
name|Service
operator|.
name|STATE
operator|.
name|INITED
argument_list|)
expr_stmt|;
name|assertSame
argument_list|(
name|service
argument_list|,
name|listener
operator|.
name|getLastService
argument_list|()
argument_list|)
expr_stmt|;
name|assertListenerEventCount
argument_list|(
name|listener
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|service
operator|.
name|start
argument_list|()
expr_stmt|;
name|assertListenerState
argument_list|(
name|listener
argument_list|,
name|Service
operator|.
name|STATE
operator|.
name|STARTED
argument_list|)
expr_stmt|;
name|assertListenerEventCount
argument_list|(
name|listener
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|service
operator|.
name|stop
argument_list|()
expr_stmt|;
name|assertListenerState
argument_list|(
name|listener
argument_list|,
name|Service
operator|.
name|STATE
operator|.
name|STOPPED
argument_list|)
expr_stmt|;
name|assertListenerEventCount
argument_list|(
name|listener
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/**    * This test triggers a failure in the listener - the expectation is that the    * service has already reached it's desired state, purely because the    * notifications take place afterwards.    *    */
annotation|@
name|Test
DECL|method|testListenerFailure ()
specifier|public
name|void
name|testListenerFailure
parameter_list|()
block|{
name|listener
operator|.
name|setFailingState
argument_list|(
name|Service
operator|.
name|STATE
operator|.
name|INITED
argument_list|)
expr_stmt|;
name|register
argument_list|()
expr_stmt|;
name|BreakableStateChangeListener
name|l2
init|=
operator|new
name|BreakableStateChangeListener
argument_list|()
decl_stmt|;
name|register
argument_list|(
name|l2
argument_list|)
expr_stmt|;
name|BreakableService
name|service
init|=
operator|new
name|BreakableService
argument_list|()
decl_stmt|;
name|service
operator|.
name|init
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|)
expr_stmt|;
comment|//expected notifications to fail
comment|//still should record its invocation
name|assertListenerState
argument_list|(
name|listener
argument_list|,
name|Service
operator|.
name|STATE
operator|.
name|INITED
argument_list|)
expr_stmt|;
name|assertListenerEventCount
argument_list|(
name|listener
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|//and second listener didn't get notified of anything
name|assertListenerEventCount
argument_list|(
name|l2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|//service should still consider itself started
name|assertServiceStateInited
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|service
operator|.
name|start
argument_list|()
expr_stmt|;
name|service
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
comment|/**    * Create a chain of listeners and set one in the middle to fail; verify that    * those in front got called, and those after did not.    */
annotation|@
name|Test
DECL|method|testListenerChain ()
specifier|public
name|void
name|testListenerChain
parameter_list|()
block|{
comment|//create and register the listeners
name|LoggingStateChangeListener
name|logListener
init|=
operator|new
name|LoggingStateChangeListener
argument_list|()
decl_stmt|;
name|register
argument_list|(
name|logListener
argument_list|)
expr_stmt|;
name|BreakableStateChangeListener
name|l0
init|=
operator|new
name|BreakableStateChangeListener
argument_list|(
literal|"l0"
argument_list|)
decl_stmt|;
name|register
argument_list|(
name|l0
argument_list|)
expr_stmt|;
name|listener
operator|.
name|setFailingState
argument_list|(
name|Service
operator|.
name|STATE
operator|.
name|STARTED
argument_list|)
expr_stmt|;
name|register
argument_list|()
expr_stmt|;
name|BreakableStateChangeListener
name|l3
init|=
operator|new
name|BreakableStateChangeListener
argument_list|(
literal|"l3"
argument_list|)
decl_stmt|;
name|register
argument_list|(
name|l3
argument_list|)
expr_stmt|;
comment|//create and init a service.
name|BreakableService
name|service
init|=
operator|new
name|BreakableService
argument_list|()
decl_stmt|;
name|service
operator|.
name|init
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|)
expr_stmt|;
name|assertServiceStateInited
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|assertListenerState
argument_list|(
name|l0
argument_list|,
name|Service
operator|.
name|STATE
operator|.
name|INITED
argument_list|)
expr_stmt|;
name|assertListenerState
argument_list|(
name|listener
argument_list|,
name|Service
operator|.
name|STATE
operator|.
name|INITED
argument_list|)
expr_stmt|;
name|assertListenerState
argument_list|(
name|l3
argument_list|,
name|Service
operator|.
name|STATE
operator|.
name|INITED
argument_list|)
expr_stmt|;
name|service
operator|.
name|start
argument_list|()
expr_stmt|;
comment|//expect that listener l1 and the failing listener are in start, but
comment|//not the final one
name|assertServiceStateStarted
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|assertListenerState
argument_list|(
name|l0
argument_list|,
name|Service
operator|.
name|STATE
operator|.
name|STARTED
argument_list|)
expr_stmt|;
name|assertListenerEventCount
argument_list|(
name|l0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assertListenerState
argument_list|(
name|listener
argument_list|,
name|Service
operator|.
name|STATE
operator|.
name|STARTED
argument_list|)
expr_stmt|;
name|assertListenerEventCount
argument_list|(
name|listener
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|//this is the listener that is not expected to have been invoked
name|assertListenerState
argument_list|(
name|l3
argument_list|,
name|Service
operator|.
name|STATE
operator|.
name|INITED
argument_list|)
expr_stmt|;
name|assertListenerEventCount
argument_list|(
name|l3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|//stop the service
name|service
operator|.
name|stop
argument_list|()
expr_stmt|;
comment|//listeners are all updated
name|assertListenerEventCount
argument_list|(
name|l0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|assertListenerEventCount
argument_list|(
name|listener
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|assertListenerEventCount
argument_list|(
name|l3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|//can all be unregistered in any order
name|unregister
argument_list|(
name|logListener
argument_list|)
expr_stmt|;
name|unregister
argument_list|(
name|l0
argument_list|)
expr_stmt|;
name|unregister
argument_list|(
name|l3
argument_list|)
expr_stmt|;
comment|//check that the listeners are all unregistered, even
comment|//though they were registered in a different order.
comment|//rather than do this by doing unregister checks, a new service is created
name|service
operator|=
operator|new
name|BreakableService
argument_list|()
expr_stmt|;
comment|//this service is initialized
name|service
operator|.
name|init
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|)
expr_stmt|;
comment|//it is asserted that the event count has not changed for the unregistered
comment|//listeners
name|assertListenerEventCount
argument_list|(
name|l0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|assertListenerEventCount
argument_list|(
name|l3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|//except for the one listener that was not unregistered, which
comment|//has incremented by one
name|assertListenerEventCount
argument_list|(
name|listener
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

