begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.api.resource
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|resource
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|Private
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|Public
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
operator|.
name|Unstable
import|;
end_import

begin_comment
comment|/**  * {@code PlacementConstraint} represents a placement constraint for a resource  * allocation.  */
end_comment

begin_class
annotation|@
name|Public
annotation|@
name|Unstable
DECL|class|PlacementConstraint
specifier|public
class|class
name|PlacementConstraint
block|{
comment|/**    * The constraint expression tree.    */
DECL|field|constraintExpr
specifier|private
name|AbstractConstraint
name|constraintExpr
decl_stmt|;
DECL|method|PlacementConstraint (AbstractConstraint constraintExpr)
specifier|public
name|PlacementConstraint
parameter_list|(
name|AbstractConstraint
name|constraintExpr
parameter_list|)
block|{
name|this
operator|.
name|constraintExpr
operator|=
name|constraintExpr
expr_stmt|;
block|}
comment|/**    * Get the constraint expression of the placement constraint.    *    * @return the constraint expression    */
DECL|method|getConstraintExpr ()
specifier|public
name|AbstractConstraint
name|getConstraintExpr
parameter_list|()
block|{
return|return
name|constraintExpr
return|;
block|}
comment|/**    * Interface used to enable the elements of the constraint tree to be visited.    */
annotation|@
name|Private
DECL|interface|Visitable
specifier|public
interface|interface
name|Visitable
block|{
comment|/**      * Visitor pattern.      *      * @param visitor visitor to be used      * @param<T> defines the type that the visitor will use and the return type      *          of the accept.      * @return the result of visiting a given object.      */
DECL|method|accept (Visitor<T> visitor)
parameter_list|<
name|T
parameter_list|>
name|T
name|accept
parameter_list|(
name|Visitor
argument_list|<
name|T
argument_list|>
name|visitor
parameter_list|)
function_decl|;
block|}
comment|/**    * Visitor API for a constraint tree.    *    * @param<T> determines the return type of the visit methods.    */
annotation|@
name|Private
DECL|interface|Visitor
specifier|public
interface|interface
name|Visitor
parameter_list|<
name|T
parameter_list|>
block|{
DECL|method|visit (SingleConstraint constraint)
name|T
name|visit
parameter_list|(
name|SingleConstraint
name|constraint
parameter_list|)
function_decl|;
DECL|method|visit (TargetExpression target)
name|T
name|visit
parameter_list|(
name|TargetExpression
name|target
parameter_list|)
function_decl|;
DECL|method|visit (TargetConstraint constraint)
name|T
name|visit
parameter_list|(
name|TargetConstraint
name|constraint
parameter_list|)
function_decl|;
DECL|method|visit (CardinalityConstraint constraint)
name|T
name|visit
parameter_list|(
name|CardinalityConstraint
name|constraint
parameter_list|)
function_decl|;
DECL|method|visit (And constraint)
name|T
name|visit
parameter_list|(
name|And
name|constraint
parameter_list|)
function_decl|;
DECL|method|visit (Or constraint)
name|T
name|visit
parameter_list|(
name|Or
name|constraint
parameter_list|)
function_decl|;
DECL|method|visit (DelayedOr constraint)
name|T
name|visit
parameter_list|(
name|DelayedOr
name|constraint
parameter_list|)
function_decl|;
DECL|method|visit (TimedPlacementConstraint constraint)
name|T
name|visit
parameter_list|(
name|TimedPlacementConstraint
name|constraint
parameter_list|)
function_decl|;
block|}
comment|/**    * Abstract class that acts as the superclass of all placement constraint    * classes.    */
DECL|class|AbstractConstraint
specifier|public
specifier|abstract
specifier|static
class|class
name|AbstractConstraint
implements|implements
name|Visitable
block|{
DECL|method|build ()
specifier|public
name|PlacementConstraint
name|build
parameter_list|()
block|{
return|return
operator|new
name|PlacementConstraint
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
DECL|field|NODE_SCOPE
specifier|static
specifier|final
name|String
name|NODE_SCOPE
init|=
literal|"node"
decl_stmt|;
DECL|field|RACK_SCOPE
specifier|static
specifier|final
name|String
name|RACK_SCOPE
init|=
literal|"rack"
decl_stmt|;
comment|/**    * Consider a set of nodes N that belongs to the scope specified in the    * constraint. If the target expressions are satisfied at least minCardinality    * times and at most max-cardinality times in the node set N, then the    * constraint is satisfied.    *    * For example, a constraint of the form {@code {RACK, 2, 10,    * allocationTag("zk")}}, requires an allocation to be placed within a rack    * that has at least 2 and at most 10 other allocations with tag "zk".    */
DECL|class|SingleConstraint
specifier|public
specifier|static
class|class
name|SingleConstraint
extends|extends
name|AbstractConstraint
block|{
DECL|field|scope
specifier|private
name|String
name|scope
decl_stmt|;
DECL|field|minCardinality
specifier|private
name|int
name|minCardinality
decl_stmt|;
DECL|field|maxCardinality
specifier|private
name|int
name|maxCardinality
decl_stmt|;
DECL|field|targetExpressions
specifier|private
name|Set
argument_list|<
name|TargetExpression
argument_list|>
name|targetExpressions
decl_stmt|;
DECL|method|SingleConstraint (String scope, int minCardinality, int maxCardinality, Set<TargetExpression> targetExpressions)
specifier|public
name|SingleConstraint
parameter_list|(
name|String
name|scope
parameter_list|,
name|int
name|minCardinality
parameter_list|,
name|int
name|maxCardinality
parameter_list|,
name|Set
argument_list|<
name|TargetExpression
argument_list|>
name|targetExpressions
parameter_list|)
block|{
name|this
operator|.
name|scope
operator|=
name|scope
expr_stmt|;
name|this
operator|.
name|minCardinality
operator|=
name|minCardinality
expr_stmt|;
name|this
operator|.
name|maxCardinality
operator|=
name|maxCardinality
expr_stmt|;
name|this
operator|.
name|targetExpressions
operator|=
name|targetExpressions
expr_stmt|;
block|}
DECL|method|SingleConstraint (String scope, int minC, int maxC, TargetExpression... targetExpressions)
specifier|public
name|SingleConstraint
parameter_list|(
name|String
name|scope
parameter_list|,
name|int
name|minC
parameter_list|,
name|int
name|maxC
parameter_list|,
name|TargetExpression
modifier|...
name|targetExpressions
parameter_list|)
block|{
name|this
argument_list|(
name|scope
argument_list|,
name|minC
argument_list|,
name|maxC
argument_list|,
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|targetExpressions
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get the scope of the constraint.      *      * @return the scope of the constraint      */
DECL|method|getScope ()
specifier|public
name|String
name|getScope
parameter_list|()
block|{
return|return
name|scope
return|;
block|}
comment|/**      * Get the minimum cardinality of the constraint.      *      * @return the minimum cardinality of the constraint      */
DECL|method|getMinCardinality ()
specifier|public
name|int
name|getMinCardinality
parameter_list|()
block|{
return|return
name|minCardinality
return|;
block|}
comment|/**      * Get the maximum cardinality of the constraint.      *      * @return the maximum cardinality of the constraint      */
DECL|method|getMaxCardinality ()
specifier|public
name|int
name|getMaxCardinality
parameter_list|()
block|{
return|return
name|maxCardinality
return|;
block|}
comment|/**      * Get the target expressions of the constraint.      *      * @return the set of target expressions      */
DECL|method|getTargetExpressions ()
specifier|public
name|Set
argument_list|<
name|TargetExpression
argument_list|>
name|getTargetExpressions
parameter_list|()
block|{
return|return
name|targetExpressions
return|;
block|}
annotation|@
name|Override
DECL|method|accept (Visitor<T> visitor)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|accept
parameter_list|(
name|Visitor
argument_list|<
name|T
argument_list|>
name|visitor
parameter_list|)
block|{
return|return
name|visitor
operator|.
name|visit
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/**    * Class representing the target expressions that are used in placement    * constraints. They might refer to expressions on node attributes, allocation    * tags, or be self-targets (referring to the allocation to which the    * constraint is attached).    */
DECL|class|TargetExpression
specifier|public
specifier|static
class|class
name|TargetExpression
implements|implements
name|Visitable
block|{
comment|/**      * Enum specifying the type of the target expression.      */
DECL|enum|TargetType
specifier|public
enum|enum
name|TargetType
block|{
DECL|enumConstant|NODE_ATTRIBUTE
DECL|enumConstant|ALLOCATION_TAG
DECL|enumConstant|SELF
name|NODE_ATTRIBUTE
block|,
name|ALLOCATION_TAG
block|,
name|SELF
block|}
DECL|field|targetType
specifier|private
name|TargetType
name|targetType
decl_stmt|;
DECL|field|targetKey
specifier|private
name|String
name|targetKey
decl_stmt|;
DECL|field|targetValues
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|targetValues
decl_stmt|;
DECL|method|TargetExpression (TargetType targetType, String targetKey, Set<String> targetValues)
specifier|public
name|TargetExpression
parameter_list|(
name|TargetType
name|targetType
parameter_list|,
name|String
name|targetKey
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|targetValues
parameter_list|)
block|{
name|this
operator|.
name|targetType
operator|=
name|targetType
expr_stmt|;
name|this
operator|.
name|targetKey
operator|=
name|targetKey
expr_stmt|;
name|this
operator|.
name|targetValues
operator|=
name|targetValues
expr_stmt|;
block|}
DECL|method|TargetExpression (TargetType targetType)
specifier|public
name|TargetExpression
parameter_list|(
name|TargetType
name|targetType
parameter_list|)
block|{
name|this
argument_list|(
name|targetType
argument_list|,
literal|null
argument_list|,
operator|new
name|HashSet
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|TargetExpression (TargetType targetType, String targetKey, String... targetValues)
specifier|public
name|TargetExpression
parameter_list|(
name|TargetType
name|targetType
parameter_list|,
name|String
name|targetKey
parameter_list|,
name|String
modifier|...
name|targetValues
parameter_list|)
block|{
name|this
argument_list|(
name|targetType
argument_list|,
name|targetKey
argument_list|,
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|targetValues
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get the type of the target expression.      *      * @return the type of the target expression      */
DECL|method|getTargetType ()
specifier|public
name|TargetType
name|getTargetType
parameter_list|()
block|{
return|return
name|targetType
return|;
block|}
comment|/**      * Get the key of the target expression.      *      * @return the key of the target expression      */
DECL|method|getTargetKey ()
specifier|public
name|String
name|getTargetKey
parameter_list|()
block|{
return|return
name|targetKey
return|;
block|}
comment|/**      * Get the set of values of the target expression.      *      * @return the set of values of the target expression      */
DECL|method|getTargetValues ()
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getTargetValues
parameter_list|()
block|{
return|return
name|targetValues
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|result
init|=
name|targetType
operator|!=
literal|null
condition|?
name|targetType
operator|.
name|hashCode
argument_list|()
else|:
literal|0
decl_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
operator|(
name|targetKey
operator|!=
literal|null
condition|?
name|targetKey
operator|.
name|hashCode
argument_list|()
else|:
literal|0
operator|)
expr_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
operator|(
name|targetValues
operator|!=
literal|null
condition|?
name|targetValues
operator|.
name|hashCode
argument_list|()
else|:
literal|0
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|TargetExpression
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|TargetExpression
name|that
init|=
operator|(
name|TargetExpression
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|targetType
operator|!=
name|that
operator|.
name|targetType
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|targetKey
operator|!=
literal|null
condition|?
operator|!
name|targetKey
operator|.
name|equals
argument_list|(
name|that
operator|.
name|targetKey
argument_list|)
else|:
name|that
operator|.
name|targetKey
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|targetValues
operator|!=
literal|null
condition|?
name|targetValues
operator|.
name|equals
argument_list|(
name|that
operator|.
name|targetValues
argument_list|)
else|:
name|that
operator|.
name|targetValues
operator|==
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|accept (Visitor<T> visitor)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|accept
parameter_list|(
name|Visitor
argument_list|<
name|T
argument_list|>
name|visitor
parameter_list|)
block|{
return|return
name|visitor
operator|.
name|visit
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/**    * Class that represents a target constraint. Such a constraint requires an    * allocation to be placed within a scope that satisfies some specified    * expressions on node attributes and allocation tags.    *    * It is a specialized version of the {@link SingleConstraint}, where the    * minimum and the maximum cardinalities take specific values based on the    * {@link TargetOperator} used.    */
DECL|class|TargetConstraint
specifier|public
specifier|static
class|class
name|TargetConstraint
extends|extends
name|AbstractConstraint
block|{
DECL|enum|TargetOperator
enum|enum
name|TargetOperator
block|{
DECL|enumConstant|IN
DECL|enumConstant|NOT_IN
name|IN
block|,
name|NOT_IN
block|}
DECL|field|op
specifier|private
name|TargetOperator
name|op
decl_stmt|;
DECL|field|scope
specifier|private
name|String
name|scope
decl_stmt|;
DECL|field|targetExpressions
specifier|private
name|Set
argument_list|<
name|TargetExpression
argument_list|>
name|targetExpressions
decl_stmt|;
DECL|method|TargetConstraint (TargetOperator op, String scope, Set<TargetExpression> targetExpressions)
specifier|public
name|TargetConstraint
parameter_list|(
name|TargetOperator
name|op
parameter_list|,
name|String
name|scope
parameter_list|,
name|Set
argument_list|<
name|TargetExpression
argument_list|>
name|targetExpressions
parameter_list|)
block|{
name|this
operator|.
name|op
operator|=
name|op
expr_stmt|;
name|this
operator|.
name|scope
operator|=
name|scope
expr_stmt|;
name|this
operator|.
name|targetExpressions
operator|=
name|targetExpressions
expr_stmt|;
block|}
comment|/**      * Get the target operator of the constraint.      *      * @return the target operator      */
DECL|method|getOp ()
specifier|public
name|TargetOperator
name|getOp
parameter_list|()
block|{
return|return
name|op
return|;
block|}
comment|/**      * Get the scope of the constraint.      *      * @return the scope of the constraint      */
DECL|method|getScope ()
specifier|public
name|String
name|getScope
parameter_list|()
block|{
return|return
name|scope
return|;
block|}
comment|/**      * Get the set of target expressions.      *      * @return the set of target expressions      */
DECL|method|getTargetExpressions ()
specifier|public
name|Set
argument_list|<
name|TargetExpression
argument_list|>
name|getTargetExpressions
parameter_list|()
block|{
return|return
name|targetExpressions
return|;
block|}
annotation|@
name|Override
DECL|method|accept (Visitor<T> visitor)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|accept
parameter_list|(
name|Visitor
argument_list|<
name|T
argument_list|>
name|visitor
parameter_list|)
block|{
return|return
name|visitor
operator|.
name|visit
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/**    * Class that represents a cardinality constraint. Such a constraint the    * number of allocations within a given scope to some minimum and maximum    * values.    *    * It is a specialized version of the {@link SingleConstraint}, where the    * target is self (i.e., the allocation to which the constraint is attached).    */
DECL|class|CardinalityConstraint
specifier|public
specifier|static
class|class
name|CardinalityConstraint
extends|extends
name|AbstractConstraint
block|{
DECL|field|scope
specifier|private
name|String
name|scope
decl_stmt|;
DECL|field|minCardinality
specifier|private
name|int
name|minCardinality
decl_stmt|;
DECL|field|maxCardinality
specifier|private
name|int
name|maxCardinality
decl_stmt|;
DECL|method|CardinalityConstraint (String scope, int minCardinality, int maxCardinality)
specifier|public
name|CardinalityConstraint
parameter_list|(
name|String
name|scope
parameter_list|,
name|int
name|minCardinality
parameter_list|,
name|int
name|maxCardinality
parameter_list|)
block|{
name|this
operator|.
name|scope
operator|=
name|scope
expr_stmt|;
name|this
operator|.
name|minCardinality
operator|=
name|minCardinality
expr_stmt|;
name|this
operator|.
name|maxCardinality
operator|=
name|maxCardinality
expr_stmt|;
block|}
comment|/**      * Get the scope of the constraint.      *      * @return the scope of the constraint      */
DECL|method|getScope ()
specifier|public
name|String
name|getScope
parameter_list|()
block|{
return|return
name|scope
return|;
block|}
comment|/**      * Get the minimum cardinality of the constraint.      *      * @return the minimum cardinality of the constraint      */
DECL|method|getMinCardinality ()
specifier|public
name|int
name|getMinCardinality
parameter_list|()
block|{
return|return
name|minCardinality
return|;
block|}
comment|/**      * Get the maximum cardinality of the constraint.      *      * @return the maximum cardinality of the constraint      */
DECL|method|getMaxCardinality ()
specifier|public
name|int
name|getMaxCardinality
parameter_list|()
block|{
return|return
name|maxCardinality
return|;
block|}
annotation|@
name|Override
DECL|method|accept (Visitor<T> visitor)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|accept
parameter_list|(
name|Visitor
argument_list|<
name|T
argument_list|>
name|visitor
parameter_list|)
block|{
return|return
name|visitor
operator|.
name|visit
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/**    * Class that represents composite constraints, which comprise other    * constraints, forming a constraint tree.    *    * @param<R> the type of constraints that are used as children of the    *          specific composite constraint    */
DECL|class|CompositeConstraint
specifier|public
specifier|abstract
specifier|static
class|class
name|CompositeConstraint
parameter_list|<
name|R
extends|extends
name|Visitable
parameter_list|>
extends|extends
name|AbstractConstraint
block|{
comment|/**      * Get the children of this composite constraint.      *      * @return the children of the composite constraint      */
DECL|method|getChildren ()
specifier|public
specifier|abstract
name|List
argument_list|<
name|R
argument_list|>
name|getChildren
parameter_list|()
function_decl|;
block|}
comment|/**    * Class that represents a composite constraint that is a conjunction of other    * constraints.    */
DECL|class|And
specifier|public
specifier|static
class|class
name|And
extends|extends
name|CompositeConstraint
argument_list|<
name|AbstractConstraint
argument_list|>
block|{
DECL|field|children
specifier|private
name|List
argument_list|<
name|AbstractConstraint
argument_list|>
name|children
decl_stmt|;
DECL|method|And (List<AbstractConstraint> children)
specifier|public
name|And
parameter_list|(
name|List
argument_list|<
name|AbstractConstraint
argument_list|>
name|children
parameter_list|)
block|{
name|this
operator|.
name|children
operator|=
name|children
expr_stmt|;
block|}
DECL|method|And (AbstractConstraint... children)
specifier|public
name|And
parameter_list|(
name|AbstractConstraint
modifier|...
name|children
parameter_list|)
block|{
name|this
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|children
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getChildren ()
specifier|public
name|List
argument_list|<
name|AbstractConstraint
argument_list|>
name|getChildren
parameter_list|()
block|{
return|return
name|children
return|;
block|}
annotation|@
name|Override
DECL|method|accept (Visitor<T> visitor)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|accept
parameter_list|(
name|Visitor
argument_list|<
name|T
argument_list|>
name|visitor
parameter_list|)
block|{
return|return
name|visitor
operator|.
name|visit
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/**    * Class that represents a composite constraint that is a disjunction of other    * constraints.    */
DECL|class|Or
specifier|public
specifier|static
class|class
name|Or
extends|extends
name|CompositeConstraint
argument_list|<
name|AbstractConstraint
argument_list|>
block|{
DECL|field|children
specifier|private
name|List
argument_list|<
name|AbstractConstraint
argument_list|>
name|children
decl_stmt|;
DECL|method|Or (List<AbstractConstraint> children)
specifier|public
name|Or
parameter_list|(
name|List
argument_list|<
name|AbstractConstraint
argument_list|>
name|children
parameter_list|)
block|{
name|this
operator|.
name|children
operator|=
name|children
expr_stmt|;
block|}
DECL|method|Or (AbstractConstraint... children)
specifier|public
name|Or
parameter_list|(
name|AbstractConstraint
modifier|...
name|children
parameter_list|)
block|{
name|this
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|children
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getChildren ()
specifier|public
name|List
argument_list|<
name|AbstractConstraint
argument_list|>
name|getChildren
parameter_list|()
block|{
return|return
name|children
return|;
block|}
annotation|@
name|Override
DECL|method|accept (Visitor<T> visitor)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|accept
parameter_list|(
name|Visitor
argument_list|<
name|T
argument_list|>
name|visitor
parameter_list|)
block|{
return|return
name|visitor
operator|.
name|visit
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/**    * Class that represents a composite constraint that comprises a list of timed    * placement constraints (see {@link TimedPlacementConstraint}). The scheduler    * should try to satisfy first the first timed child constraint within the    * specified time window. If this is not possible, it should attempt to    * satisfy the second, and so on.    */
DECL|class|DelayedOr
specifier|public
specifier|static
class|class
name|DelayedOr
extends|extends
name|CompositeConstraint
argument_list|<
name|TimedPlacementConstraint
argument_list|>
block|{
DECL|field|children
specifier|private
name|List
argument_list|<
name|TimedPlacementConstraint
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|DelayedOr (List<TimedPlacementConstraint> children)
specifier|public
name|DelayedOr
parameter_list|(
name|List
argument_list|<
name|TimedPlacementConstraint
argument_list|>
name|children
parameter_list|)
block|{
name|this
operator|.
name|children
operator|=
name|children
expr_stmt|;
block|}
DECL|method|DelayedOr (TimedPlacementConstraint... children)
specifier|public
name|DelayedOr
parameter_list|(
name|TimedPlacementConstraint
modifier|...
name|children
parameter_list|)
block|{
name|this
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|children
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getChildren ()
specifier|public
name|List
argument_list|<
name|TimedPlacementConstraint
argument_list|>
name|getChildren
parameter_list|()
block|{
return|return
name|children
return|;
block|}
annotation|@
name|Override
DECL|method|accept (Visitor<T> visitor)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|accept
parameter_list|(
name|Visitor
argument_list|<
name|T
argument_list|>
name|visitor
parameter_list|)
block|{
return|return
name|visitor
operator|.
name|visit
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
comment|/**    * Represents a timed placement constraint that has to be satisfied within a    * time window.    */
DECL|class|TimedPlacementConstraint
specifier|public
specifier|static
class|class
name|TimedPlacementConstraint
implements|implements
name|Visitable
block|{
comment|/**      * The unit of scheduling delay.      */
DECL|enum|DelayUnit
specifier|public
enum|enum
name|DelayUnit
block|{
DECL|enumConstant|MILLISECONDS
DECL|enumConstant|OPPORTUNITIES
name|MILLISECONDS
block|,
name|OPPORTUNITIES
block|}
DECL|field|constraint
specifier|private
name|AbstractConstraint
name|constraint
decl_stmt|;
DECL|field|schedulingDelay
specifier|private
name|long
name|schedulingDelay
decl_stmt|;
DECL|field|delayUnit
specifier|private
name|DelayUnit
name|delayUnit
decl_stmt|;
DECL|method|TimedPlacementConstraint (AbstractConstraint constraint, long schedulingDelay, DelayUnit delayUnit)
specifier|public
name|TimedPlacementConstraint
parameter_list|(
name|AbstractConstraint
name|constraint
parameter_list|,
name|long
name|schedulingDelay
parameter_list|,
name|DelayUnit
name|delayUnit
parameter_list|)
block|{
name|this
operator|.
name|constraint
operator|=
name|constraint
expr_stmt|;
name|this
operator|.
name|schedulingDelay
operator|=
name|schedulingDelay
expr_stmt|;
name|this
operator|.
name|delayUnit
operator|=
name|delayUnit
expr_stmt|;
block|}
DECL|method|TimedPlacementConstraint (AbstractConstraint constraint, long schedulingDelay)
specifier|public
name|TimedPlacementConstraint
parameter_list|(
name|AbstractConstraint
name|constraint
parameter_list|,
name|long
name|schedulingDelay
parameter_list|)
block|{
name|this
argument_list|(
name|constraint
argument_list|,
name|schedulingDelay
argument_list|,
name|DelayUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
DECL|method|TimedPlacementConstraint (AbstractConstraint constraint)
specifier|public
name|TimedPlacementConstraint
parameter_list|(
name|AbstractConstraint
name|constraint
parameter_list|)
block|{
name|this
argument_list|(
name|constraint
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|,
name|DelayUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get the constraint that has to be satisfied within the time window.      *      * @return the constraint to be satisfied      */
DECL|method|getConstraint ()
specifier|public
name|AbstractConstraint
name|getConstraint
parameter_list|()
block|{
return|return
name|constraint
return|;
block|}
comment|/**      * Sets the constraint that has to be satisfied within the time window.      *      * @param constraint the constraint to be satisfied      */
DECL|method|setConstraint (AbstractConstraint constraint)
specifier|public
name|void
name|setConstraint
parameter_list|(
name|AbstractConstraint
name|constraint
parameter_list|)
block|{
name|this
operator|.
name|constraint
operator|=
name|constraint
expr_stmt|;
block|}
comment|/**      * Get the scheduling delay value that determines the time window within      * which the constraint has to be satisfied.      *      * @return the value of the scheduling delay      */
DECL|method|getSchedulingDelay ()
specifier|public
name|long
name|getSchedulingDelay
parameter_list|()
block|{
return|return
name|schedulingDelay
return|;
block|}
comment|/**      * The unit of the scheduling delay.      *      * @return the unit of the delay      */
DECL|method|getDelayUnit ()
specifier|public
name|DelayUnit
name|getDelayUnit
parameter_list|()
block|{
return|return
name|delayUnit
return|;
block|}
annotation|@
name|Override
DECL|method|accept (Visitor<T> visitor)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|accept
parameter_list|(
name|Visitor
argument_list|<
name|T
argument_list|>
name|visitor
parameter_list|)
block|{
return|return
name|visitor
operator|.
name|visit
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

