begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.examples
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|examples
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|RoundingMode
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configured
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|BooleanWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableComparable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
operator|.
name|CompressionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|FileInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|SequenceFileInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|FileOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|SequenceFileOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Tool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_comment
comment|/**  * A map/reduce program that estimates the value of Pi  * using a quasi-Monte Carlo (qMC) method.  * Arbitrary integrals can be approximated numerically by qMC methods.  * In this example,  * we use a qMC method to approximate the integral $I = \int_S f(x) dx$,  * where $S=[0,1)^2$ is a unit square,  * $x=(x_1,x_2)$ is a 2-dimensional point,  * and $f$ is a function describing the inscribed circle of the square $S$,  * $f(x)=1$ if $(2x_1-1)^2+(2x_2-1)^2&lt;= 1$ and $f(x)=0$, otherwise.  * It is easy to see that Pi is equal to $4I$.  * So an approximation of Pi is obtained once $I$ is evaluated numerically.  *   * There are better methods for computing Pi.  * We emphasize numerical approximation of arbitrary integrals in this example.  * For computing many digits of Pi, consider using bbp.  *  * The implementation is discussed below.  *  * Mapper:  *   Generate points in a unit square  *   and then count points inside/outside of the inscribed circle of the square.  *  * Reducer:  *   Accumulate points inside/outside results from the mappers.  *  * Let numTotal = numInside + numOutside.  * The fraction numInside/numTotal is a rational approximation of  * the value (Area of the circle)/(Area of the square) = $I$,  * where the area of the inscribed circle is Pi/4  * and the area of unit square is 1.  * Finally, the estimated value of Pi is 4(numInside/numTotal).    */
end_comment

begin_class
DECL|class|QuasiMonteCarlo
specifier|public
class|class
name|QuasiMonteCarlo
extends|extends
name|Configured
implements|implements
name|Tool
block|{
DECL|field|DESCRIPTION
specifier|static
specifier|final
name|String
name|DESCRIPTION
init|=
literal|"A map/reduce program that estimates Pi using a quasi-Monte Carlo method."
decl_stmt|;
comment|/** tmp directory for input/output */
DECL|field|TMP_DIR_PREFIX
specifier|static
specifier|private
specifier|final
name|String
name|TMP_DIR_PREFIX
init|=
name|QuasiMonteCarlo
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
decl_stmt|;
comment|/** 2-dimensional Halton sequence {H(i)},    * where H(i) is a 2-dimensional point and i>= 1 is the index.    * Halton sequence is used to generate sample points for Pi estimation.     */
DECL|class|HaltonSequence
specifier|private
specifier|static
class|class
name|HaltonSequence
block|{
comment|/** Bases */
DECL|field|P
specifier|static
specifier|final
name|int
index|[]
name|P
init|=
block|{
literal|2
block|,
literal|3
block|}
decl_stmt|;
comment|/** Maximum number of digits allowed */
DECL|field|K
specifier|static
specifier|final
name|int
index|[]
name|K
init|=
block|{
literal|63
block|,
literal|40
block|}
decl_stmt|;
DECL|field|index
specifier|private
name|long
name|index
decl_stmt|;
DECL|field|x
specifier|private
name|double
index|[]
name|x
decl_stmt|;
DECL|field|q
specifier|private
name|double
index|[]
index|[]
name|q
decl_stmt|;
DECL|field|d
specifier|private
name|int
index|[]
index|[]
name|d
decl_stmt|;
comment|/** Initialize to H(startindex),      * so the sequence begins with H(startindex+1).      */
DECL|method|HaltonSequence (long startindex)
name|HaltonSequence
parameter_list|(
name|long
name|startindex
parameter_list|)
block|{
name|index
operator|=
name|startindex
expr_stmt|;
name|x
operator|=
operator|new
name|double
index|[
name|K
operator|.
name|length
index|]
expr_stmt|;
name|q
operator|=
operator|new
name|double
index|[
name|K
operator|.
name|length
index|]
index|[]
expr_stmt|;
name|d
operator|=
operator|new
name|int
index|[
name|K
operator|.
name|length
index|]
index|[]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|K
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|q
index|[
name|i
index|]
operator|=
operator|new
name|double
index|[
name|K
index|[
name|i
index|]
index|]
expr_stmt|;
name|d
index|[
name|i
index|]
operator|=
operator|new
name|int
index|[
name|K
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|K
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|long
name|k
init|=
name|index
decl_stmt|;
name|x
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|K
index|[
name|i
index|]
condition|;
name|j
operator|++
control|)
block|{
name|q
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
name|j
operator|==
literal|0
condition|?
literal|1.0
else|:
name|q
index|[
name|i
index|]
index|[
name|j
operator|-
literal|1
index|]
operator|)
operator|/
name|P
index|[
name|i
index|]
expr_stmt|;
name|d
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|k
operator|%
name|P
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|k
operator|=
operator|(
name|k
operator|-
name|d
index|[
name|i
index|]
index|[
name|j
index|]
operator|)
operator|/
name|P
index|[
name|i
index|]
expr_stmt|;
name|x
index|[
name|i
index|]
operator|+=
name|d
index|[
name|i
index|]
index|[
name|j
index|]
operator|*
name|q
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/** Compute next point.      * Assume the current point is H(index).      * Compute H(index+1).      *       * @return a 2-dimensional point with coordinates in [0,1)^2      */
DECL|method|nextPoint ()
name|double
index|[]
name|nextPoint
parameter_list|()
block|{
name|index
operator|++
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|K
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|K
index|[
name|i
index|]
condition|;
name|j
operator|++
control|)
block|{
name|d
index|[
name|i
index|]
index|[
name|j
index|]
operator|++
expr_stmt|;
name|x
index|[
name|i
index|]
operator|+=
name|q
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|d
index|[
name|i
index|]
index|[
name|j
index|]
operator|<
name|P
index|[
name|i
index|]
condition|)
block|{
break|break;
block|}
name|d
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|x
index|[
name|i
index|]
operator|-=
operator|(
name|j
operator|==
literal|0
condition|?
literal|1.0
else|:
name|q
index|[
name|i
index|]
index|[
name|j
operator|-
literal|1
index|]
operator|)
expr_stmt|;
block|}
block|}
return|return
name|x
return|;
block|}
block|}
comment|/**    * Mapper class for Pi estimation.    * Generate points in a unit square    * and then count points inside/outside of the inscribed circle of the square.    */
DECL|class|QmcMapper
specifier|public
specifier|static
class|class
name|QmcMapper
extends|extends
name|Mapper
argument_list|<
name|LongWritable
argument_list|,
name|LongWritable
argument_list|,
name|BooleanWritable
argument_list|,
name|LongWritable
argument_list|>
block|{
comment|/** Map method.      * @param offset samples starting from the (offset+1)th sample.      * @param size the number of samples for this map      * @param context output {true-&gt;numInside, false-&gt;numOutside}      */
DECL|method|map (LongWritable offset, LongWritable size, Context context)
specifier|public
name|void
name|map
parameter_list|(
name|LongWritable
name|offset
parameter_list|,
name|LongWritable
name|size
parameter_list|,
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
specifier|final
name|HaltonSequence
name|haltonsequence
init|=
operator|new
name|HaltonSequence
argument_list|(
name|offset
operator|.
name|get
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|numInside
init|=
literal|0L
decl_stmt|;
name|long
name|numOutside
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|long
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
operator|.
name|get
argument_list|()
condition|;
control|)
block|{
comment|//generate points in a unit square
specifier|final
name|double
index|[]
name|point
init|=
name|haltonsequence
operator|.
name|nextPoint
argument_list|()
decl_stmt|;
comment|//count points inside/outside of the inscribed circle of the square
specifier|final
name|double
name|x
init|=
name|point
index|[
literal|0
index|]
operator|-
literal|0.5
decl_stmt|;
specifier|final
name|double
name|y
init|=
name|point
index|[
literal|1
index|]
operator|-
literal|0.5
decl_stmt|;
if|if
condition|(
name|x
operator|*
name|x
operator|+
name|y
operator|*
name|y
operator|>
literal|0.25
condition|)
block|{
name|numOutside
operator|++
expr_stmt|;
block|}
else|else
block|{
name|numInside
operator|++
expr_stmt|;
block|}
comment|//report status
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|1000
operator|==
literal|0
condition|)
block|{
name|context
operator|.
name|setStatus
argument_list|(
literal|"Generated "
operator|+
name|i
operator|+
literal|" samples."
argument_list|)
expr_stmt|;
block|}
block|}
comment|//output map results
name|context
operator|.
name|write
argument_list|(
operator|new
name|BooleanWritable
argument_list|(
literal|true
argument_list|)
argument_list|,
operator|new
name|LongWritable
argument_list|(
name|numInside
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|write
argument_list|(
operator|new
name|BooleanWritable
argument_list|(
literal|false
argument_list|)
argument_list|,
operator|new
name|LongWritable
argument_list|(
name|numOutside
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Reducer class for Pi estimation.    * Accumulate points inside/outside results from the mappers.    */
DECL|class|QmcReducer
specifier|public
specifier|static
class|class
name|QmcReducer
extends|extends
name|Reducer
argument_list|<
name|BooleanWritable
argument_list|,
name|LongWritable
argument_list|,
name|WritableComparable
argument_list|<
name|?
argument_list|>
argument_list|,
name|Writable
argument_list|>
block|{
DECL|field|numInside
specifier|private
name|long
name|numInside
init|=
literal|0
decl_stmt|;
DECL|field|numOutside
specifier|private
name|long
name|numOutside
init|=
literal|0
decl_stmt|;
comment|/**      * Accumulate number of points inside/outside results from the mappers.      * @param isInside Is the points inside?       * @param values An iterator to a list of point counts      * @param context dummy, not used here.      */
DECL|method|reduce (BooleanWritable isInside, Iterable<LongWritable> values, Context context)
specifier|public
name|void
name|reduce
parameter_list|(
name|BooleanWritable
name|isInside
parameter_list|,
name|Iterable
argument_list|<
name|LongWritable
argument_list|>
name|values
parameter_list|,
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|isInside
operator|.
name|get
argument_list|()
condition|)
block|{
for|for
control|(
name|LongWritable
name|val
range|:
name|values
control|)
block|{
name|numInside
operator|+=
name|val
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|LongWritable
name|val
range|:
name|values
control|)
block|{
name|numOutside
operator|+=
name|val
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Reduce task done, write output to a file.      */
annotation|@
name|Override
DECL|method|cleanup (Context context)
specifier|public
name|void
name|cleanup
parameter_list|(
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
block|{
comment|//write output to a file
name|Configuration
name|conf
init|=
name|context
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|Path
name|outDir
init|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|FileOutputFormat
operator|.
name|OUTDIR
argument_list|)
argument_list|)
decl_stmt|;
name|Path
name|outFile
init|=
operator|new
name|Path
argument_list|(
name|outDir
argument_list|,
literal|"reduce-out"
argument_list|)
decl_stmt|;
name|FileSystem
name|fileSys
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|SequenceFile
operator|.
name|Writer
name|writer
init|=
name|SequenceFile
operator|.
name|createWriter
argument_list|(
name|fileSys
argument_list|,
name|conf
argument_list|,
name|outFile
argument_list|,
name|LongWritable
operator|.
name|class
argument_list|,
name|LongWritable
operator|.
name|class
argument_list|,
name|CompressionType
operator|.
name|NONE
argument_list|)
decl_stmt|;
name|writer
operator|.
name|append
argument_list|(
operator|new
name|LongWritable
argument_list|(
name|numInside
argument_list|)
argument_list|,
operator|new
name|LongWritable
argument_list|(
name|numOutside
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Run a map/reduce job for estimating Pi.    *    * @return the estimated value of Pi    */
DECL|method|estimatePi (int numMaps, long numPoints, Path tmpDir, Configuration conf )
specifier|public
specifier|static
name|BigDecimal
name|estimatePi
parameter_list|(
name|int
name|numMaps
parameter_list|,
name|long
name|numPoints
parameter_list|,
name|Path
name|tmpDir
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
throws|,
name|InterruptedException
block|{
name|Job
name|job
init|=
name|Job
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|//setup job conf
name|job
operator|.
name|setJobName
argument_list|(
name|QuasiMonteCarlo
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|setJarByClass
argument_list|(
name|QuasiMonteCarlo
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setInputFormatClass
argument_list|(
name|SequenceFileInputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputKeyClass
argument_list|(
name|BooleanWritable
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputValueClass
argument_list|(
name|LongWritable
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputFormatClass
argument_list|(
name|SequenceFileOutputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setMapperClass
argument_list|(
name|QmcMapper
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setReducerClass
argument_list|(
name|QmcReducer
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setNumReduceTasks
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// turn off speculative execution, because DFS doesn't handle
comment|// multiple writers to the same file.
name|job
operator|.
name|setSpeculativeExecution
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|//setup input/output directories
specifier|final
name|Path
name|inDir
init|=
operator|new
name|Path
argument_list|(
name|tmpDir
argument_list|,
literal|"in"
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|outDir
init|=
operator|new
name|Path
argument_list|(
name|tmpDir
argument_list|,
literal|"out"
argument_list|)
decl_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|inDir
argument_list|)
expr_stmt|;
name|FileOutputFormat
operator|.
name|setOutputPath
argument_list|(
name|job
argument_list|,
name|outDir
argument_list|)
expr_stmt|;
specifier|final
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|tmpDir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Tmp directory "
operator|+
name|fs
operator|.
name|makeQualified
argument_list|(
name|tmpDir
argument_list|)
operator|+
literal|" already exists.  Please remove it first."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|fs
operator|.
name|mkdirs
argument_list|(
name|inDir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot create input directory "
operator|+
name|inDir
argument_list|)
throw|;
block|}
try|try
block|{
comment|//generate an input file for each map task
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numMaps
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|inDir
argument_list|,
literal|"part"
operator|+
name|i
argument_list|)
decl_stmt|;
specifier|final
name|LongWritable
name|offset
init|=
operator|new
name|LongWritable
argument_list|(
name|i
operator|*
name|numPoints
argument_list|)
decl_stmt|;
specifier|final
name|LongWritable
name|size
init|=
operator|new
name|LongWritable
argument_list|(
name|numPoints
argument_list|)
decl_stmt|;
specifier|final
name|SequenceFile
operator|.
name|Writer
name|writer
init|=
name|SequenceFile
operator|.
name|createWriter
argument_list|(
name|fs
argument_list|,
name|conf
argument_list|,
name|file
argument_list|,
name|LongWritable
operator|.
name|class
argument_list|,
name|LongWritable
operator|.
name|class
argument_list|,
name|CompressionType
operator|.
name|NONE
argument_list|)
decl_stmt|;
try|try
block|{
name|writer
operator|.
name|append
argument_list|(
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Wrote input for Map #"
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
comment|//start a map/reduce job
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Starting Job"
argument_list|)
expr_stmt|;
specifier|final
name|long
name|startTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|job
operator|.
name|waitForCompletion
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|job
operator|.
name|isSuccessful
argument_list|()
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Job "
operator|+
name|job
operator|.
name|getJobID
argument_list|()
operator|+
literal|" failed!"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|final
name|double
name|duration
init|=
operator|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|startTime
operator|)
operator|/
literal|1000.0
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Job Finished in "
operator|+
name|duration
operator|+
literal|" seconds"
argument_list|)
expr_stmt|;
comment|//read outputs
name|Path
name|inFile
init|=
operator|new
name|Path
argument_list|(
name|outDir
argument_list|,
literal|"reduce-out"
argument_list|)
decl_stmt|;
name|LongWritable
name|numInside
init|=
operator|new
name|LongWritable
argument_list|()
decl_stmt|;
name|LongWritable
name|numOutside
init|=
operator|new
name|LongWritable
argument_list|()
decl_stmt|;
name|SequenceFile
operator|.
name|Reader
name|reader
init|=
operator|new
name|SequenceFile
operator|.
name|Reader
argument_list|(
name|fs
argument_list|,
name|inFile
argument_list|,
name|conf
argument_list|)
decl_stmt|;
try|try
block|{
name|reader
operator|.
name|next
argument_list|(
name|numInside
argument_list|,
name|numOutside
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|//compute estimated value
specifier|final
name|BigDecimal
name|numTotal
init|=
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|numMaps
argument_list|)
operator|.
name|multiply
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|numPoints
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|BigDecimal
operator|.
name|valueOf
argument_list|(
literal|4
argument_list|)
operator|.
name|setScale
argument_list|(
literal|20
argument_list|)
operator|.
name|multiply
argument_list|(
name|BigDecimal
operator|.
name|valueOf
argument_list|(
name|numInside
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
operator|.
name|divide
argument_list|(
name|numTotal
argument_list|,
name|RoundingMode
operator|.
name|HALF_UP
argument_list|)
return|;
block|}
finally|finally
block|{
name|fs
operator|.
name|delete
argument_list|(
name|tmpDir
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Parse arguments and then runs a map/reduce job.    * Print output in standard out.    *     * @return a non-zero if there is an error.  Otherwise, return 0.      */
DECL|method|run (String[] args)
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: "
operator|+
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"<nMaps><nSamples>"
argument_list|)
expr_stmt|;
name|ToolRunner
operator|.
name|printGenericCommandUsage
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
specifier|final
name|int
name|nMaps
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|final
name|long
name|nSamples
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|int
name|rand
init|=
operator|new
name|Random
argument_list|()
operator|.
name|nextInt
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|tmpDir
init|=
operator|new
name|Path
argument_list|(
name|TMP_DIR_PREFIX
operator|+
literal|"_"
operator|+
name|now
operator|+
literal|"_"
operator|+
name|rand
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Number of Maps  = "
operator|+
name|nMaps
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Samples per Map = "
operator|+
name|nSamples
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Estimated value of Pi is "
operator|+
name|estimatePi
argument_list|(
name|nMaps
argument_list|,
name|nSamples
argument_list|,
name|tmpDir
argument_list|,
name|getConf
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/**    * main method for running it as a stand alone command.     */
DECL|method|main (String[] argv)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|argv
parameter_list|)
throws|throws
name|Exception
block|{
name|System
operator|.
name|exit
argument_list|(
name|ToolRunner
operator|.
name|run
argument_list|(
literal|null
argument_list|,
operator|new
name|QuasiMonteCarlo
argument_list|()
argument_list|,
name|argv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

