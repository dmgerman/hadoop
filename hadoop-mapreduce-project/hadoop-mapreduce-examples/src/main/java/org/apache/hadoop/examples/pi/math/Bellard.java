begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.examples.pi.math
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|examples
operator|.
name|pi
operator|.
name|math
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|examples
operator|.
name|pi
operator|.
name|Container
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|examples
operator|.
name|pi
operator|.
name|Util
import|;
end_import

begin_comment
comment|/**  * Bellard's BBP-type Pi formula  * 1/2^6 \sum_{n=0}^\infty (-1)^n/2^{10n}  * (-2^5/(4n+1) -1/(4n+3) +2^8/(10n+1) -2^6/(10n+3) -2^2/(10n+5)  *  -2^2/(10n+7) +1/(10n+9))  *    * References:  *  * [1] David H. Bailey, Peter B. Borwein and Simon Plouffe.  On the Rapid  *     Computation of Various Polylogarithmic Constants.  *     Math. Comp., 66:903-913, 1996.  *       * [2] Fabrice Bellard.  A new formula to compute the n'th binary digit of pi,  *     1997.  Available at http://fabrice.bellard.free.fr/pi .  */
end_comment

begin_class
DECL|class|Bellard
specifier|public
specifier|final
class|class
name|Bellard
block|{
comment|/** Parameters for the sums */
DECL|enum|Parameter
specifier|public
enum|enum
name|Parameter
block|{
comment|// \sum_{k=0}^\infty (-1)^{k+1}( 2^{d-10k-1}/(4k+1) + 2^{d-10k-6}/(4k+3) )
DECL|enumConstant|P8_1
name|P8_1
argument_list|(
literal|false
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
operator|-
literal|1
argument_list|)
block|,
DECL|enumConstant|P8_3
name|P8_3
argument_list|(
literal|false
argument_list|,
literal|3
argument_list|,
literal|8
argument_list|,
operator|-
literal|6
argument_list|)
block|,
DECL|enumConstant|P8_5
name|P8_5
parameter_list|(
name|P8_1
parameter_list|)
operator|,
DECL|enumConstant|P8_7
constructor|P8_7(P8_3
block|)
enum|,
comment|/*      *   2^d\sum_{k=0}^\infty (-1)^k( 2^{ 2-10k} / (10k + 1)      *                               -2^{  -10k} / (10k + 3)      *                               -2^{-4-10k} / (10k + 5)      *                               -2^{-4-10k} / (10k + 7)      *                               +2^{-6-10k} / (10k + 9) )      */
DECL|enumConstant|P20_21
name|P20_21
argument_list|(
literal|true
argument_list|,
literal|1
argument_list|,
literal|20
argument_list|,
literal|2
argument_list|)
operator|,
DECL|enumConstant|P20_3
name|P20_3
argument_list|(
literal|false
argument_list|,
literal|3
argument_list|,
literal|20
argument_list|,
literal|0
argument_list|)
operator|,
DECL|enumConstant|P20_5
name|P20_5
argument_list|(
literal|false
argument_list|,
literal|5
argument_list|,
literal|20
argument_list|,
operator|-
literal|4
argument_list|)
operator|,
DECL|enumConstant|P20_7
name|P20_7
argument_list|(
literal|false
argument_list|,
literal|7
argument_list|,
literal|20
argument_list|,
operator|-
literal|4
argument_list|)
operator|,
DECL|enumConstant|P20_9
name|P20_9
argument_list|(
literal|true
argument_list|,
literal|9
argument_list|,
literal|20
argument_list|,
operator|-
literal|6
argument_list|)
operator|,
DECL|enumConstant|P20_11
name|P20_11
argument_list|(
name|P20_21
argument_list|)
operator|,
DECL|enumConstant|P20_13
name|P20_13
argument_list|(
name|P20_3
argument_list|)
operator|,
DECL|enumConstant|P20_15
name|P20_15
argument_list|(
name|P20_5
argument_list|)
operator|,
DECL|enumConstant|P20_17
name|P20_17
argument_list|(
name|P20_7
argument_list|)
operator|,
DECL|enumConstant|P20_19
name|P20_19
argument_list|(
name|P20_9
argument_list|)
enum|;
DECL|field|isplus
specifier|final
name|boolean
name|isplus
decl_stmt|;
DECL|field|j
specifier|final
name|long
name|j
decl_stmt|;
DECL|field|deltaN
specifier|final
name|int
name|deltaN
decl_stmt|;
DECL|field|deltaE
specifier|final
name|int
name|deltaE
decl_stmt|;
DECL|field|offsetE
specifier|final
name|int
name|offsetE
decl_stmt|;
DECL|method|Parameter (boolean isplus, long j, int deltaN, int offsetE)
specifier|private
name|Parameter
parameter_list|(
name|boolean
name|isplus
parameter_list|,
name|long
name|j
parameter_list|,
name|int
name|deltaN
parameter_list|,
name|int
name|offsetE
parameter_list|)
block|{
name|this
operator|.
name|isplus
operator|=
name|isplus
expr_stmt|;
name|this
operator|.
name|j
operator|=
name|j
expr_stmt|;
name|this
operator|.
name|deltaN
operator|=
name|deltaN
expr_stmt|;
name|this
operator|.
name|deltaE
operator|=
operator|-
literal|20
expr_stmt|;
name|this
operator|.
name|offsetE
operator|=
name|offsetE
expr_stmt|;
block|}
DECL|method|Parameter (Parameter p)
specifier|private
name|Parameter
parameter_list|(
name|Parameter
name|p
parameter_list|)
block|{
name|this
operator|.
name|isplus
operator|=
operator|!
name|p
operator|.
name|isplus
expr_stmt|;
name|this
operator|.
name|j
operator|=
name|p
operator|.
name|j
operator|+
operator|(
name|p
operator|.
name|deltaN
operator|>>
literal|1
operator|)
expr_stmt|;
name|this
operator|.
name|deltaN
operator|=
name|p
operator|.
name|deltaN
expr_stmt|;
name|this
operator|.
name|deltaE
operator|=
name|p
operator|.
name|deltaE
expr_stmt|;
name|this
operator|.
name|offsetE
operator|=
name|p
operator|.
name|offsetE
operator|+
operator|(
name|p
operator|.
name|deltaE
operator|>>
literal|1
operator|)
expr_stmt|;
block|}
comment|/** Get the Parameter represented by the String */
DECL|method|get (String s)
specifier|public
specifier|static
name|Parameter
name|get
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|s
operator|=
name|s
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'P'
condition|)
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
specifier|final
name|String
index|[]
name|parts
init|=
name|s
operator|.
name|split
argument_list|(
literal|"\\D+"
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|length
operator|>=
literal|2
condition|)
block|{
specifier|final
name|String
name|name
init|=
literal|"P"
operator|+
name|parts
index|[
literal|0
index|]
operator|+
literal|"_"
operator|+
name|parts
index|[
literal|1
index|]
decl_stmt|;
for|for
control|(
name|Parameter
name|p
range|:
name|values
argument_list|()
control|)
if|if
condition|(
name|p
operator|.
name|name
argument_list|()
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|p
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"s="
operator|+
name|s
operator|+
literal|", parts="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|parts
argument_list|)
argument_list|)
throw|;
block|}
block|}
end_class

begin_comment
comment|/** The sums in the Bellard's formula */
end_comment

begin_class
DECL|class|Sum
specifier|public
specifier|static
class|class
name|Sum
implements|implements
name|Container
argument_list|<
name|Summation
argument_list|>
implements|,
name|Iterable
argument_list|<
name|Summation
argument_list|>
block|{
DECL|field|ACCURACY_BIT
specifier|private
specifier|static
specifier|final
name|long
name|ACCURACY_BIT
init|=
literal|50
decl_stmt|;
DECL|field|parameter
specifier|private
specifier|final
name|Parameter
name|parameter
decl_stmt|;
DECL|field|sigma
specifier|private
specifier|final
name|Summation
name|sigma
decl_stmt|;
DECL|field|parts
specifier|private
specifier|final
name|Summation
index|[]
name|parts
decl_stmt|;
DECL|field|tail
specifier|private
specifier|final
name|Tail
name|tail
decl_stmt|;
comment|/** Constructor */
DECL|method|Sum (long b, Parameter p, int nParts, List<T> existing)
specifier|private
parameter_list|<
name|T
extends|extends
name|Container
argument_list|<
name|Summation
argument_list|>
parameter_list|>
name|Sum
parameter_list|(
name|long
name|b
parameter_list|,
name|Parameter
name|p
parameter_list|,
name|int
name|nParts
parameter_list|,
name|List
argument_list|<
name|T
argument_list|>
name|existing
parameter_list|)
block|{
if|if
condition|(
name|b
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"b = "
operator|+
name|b
operator|+
literal|"< 0"
argument_list|)
throw|;
if|if
condition|(
name|nParts
operator|<
literal|1
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"nParts = "
operator|+
name|nParts
operator|+
literal|"< 1"
argument_list|)
throw|;
specifier|final
name|long
name|i
init|=
name|p
operator|.
name|j
operator|==
literal|1
operator|&&
name|p
operator|.
name|offsetE
operator|>=
literal|0
condition|?
literal|1
else|:
literal|0
decl_stmt|;
specifier|final
name|long
name|e
init|=
name|b
operator|+
name|i
operator|*
name|p
operator|.
name|deltaE
operator|+
name|p
operator|.
name|offsetE
decl_stmt|;
specifier|final
name|long
name|n
init|=
name|i
operator|*
name|p
operator|.
name|deltaN
operator|+
name|p
operator|.
name|j
decl_stmt|;
name|this
operator|.
name|parameter
operator|=
name|p
expr_stmt|;
name|this
operator|.
name|sigma
operator|=
operator|new
name|Summation
argument_list|(
name|n
argument_list|,
name|p
operator|.
name|deltaN
argument_list|,
name|e
argument_list|,
name|p
operator|.
name|deltaE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|parts
operator|=
name|partition
argument_list|(
name|sigma
argument_list|,
name|nParts
argument_list|,
name|existing
argument_list|)
expr_stmt|;
name|this
operator|.
name|tail
operator|=
operator|new
name|Tail
argument_list|(
name|n
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
DECL|method|partition ( Summation sigma, int nParts, List<T> existing)
specifier|private
specifier|static
parameter_list|<
name|T
extends|extends
name|Container
argument_list|<
name|Summation
argument_list|>
parameter_list|>
name|Summation
index|[]
name|partition
parameter_list|(
name|Summation
name|sigma
parameter_list|,
name|int
name|nParts
parameter_list|,
name|List
argument_list|<
name|T
argument_list|>
name|existing
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|Summation
argument_list|>
name|parts
init|=
operator|new
name|ArrayList
argument_list|<
name|Summation
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|existing
operator|==
literal|null
operator|||
name|existing
operator|.
name|isEmpty
argument_list|()
condition|)
name|parts
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|sigma
operator|.
name|partition
argument_list|(
name|nParts
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
specifier|final
name|long
name|stepsPerPart
init|=
name|sigma
operator|.
name|getSteps
argument_list|()
operator|/
name|nParts
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Summation
argument_list|>
name|remaining
init|=
name|sigma
operator|.
name|remainingTerms
argument_list|(
name|existing
argument_list|)
decl_stmt|;
for|for
control|(
name|Summation
name|s
range|:
name|remaining
control|)
block|{
specifier|final
name|int
name|n
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|s
operator|.
name|getSteps
argument_list|()
operator|-
literal|1
operator|)
operator|/
name|stepsPerPart
argument_list|)
operator|+
literal|1
decl_stmt|;
name|parts
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|s
operator|.
name|partition
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Container
argument_list|<
name|Summation
argument_list|>
name|c
range|:
name|existing
control|)
name|parts
operator|.
name|add
argument_list|(
name|c
operator|.
name|getElement
argument_list|()
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|parts
argument_list|)
expr_stmt|;
block|}
return|return
name|parts
operator|.
name|toArray
argument_list|(
operator|new
name|Summation
index|[
name|parts
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Summation
name|s
range|:
name|parts
control|)
if|if
condition|(
name|s
operator|.
name|getValue
argument_list|()
operator|==
literal|null
condition|)
name|n
operator|++
expr_stmt|;
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"{"
operator|+
name|parameter
operator|+
literal|": "
operator|+
name|sigma
operator|+
literal|", remaining="
operator|+
name|n
operator|+
literal|"}"
return|;
block|}
comment|/** Set the value of sigma */
DECL|method|setValue (Summation s)
specifier|public
name|void
name|setValue
parameter_list|(
name|Summation
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|getValue
argument_list|()
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"s.getValue()"
operator|+
literal|"\n  sigma="
operator|+
name|sigma
operator|+
literal|"\n  s    ="
operator|+
name|s
argument_list|)
throw|;
if|if
condition|(
operator|!
name|s
operator|.
name|contains
argument_list|(
name|sigma
argument_list|)
operator|||
operator|!
name|sigma
operator|.
name|contains
argument_list|(
name|s
argument_list|)
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"!s.contains(sigma) || !sigma.contains(s)"
operator|+
literal|"\n  sigma="
operator|+
name|sigma
operator|+
literal|"\n  s    ="
operator|+
name|s
argument_list|)
throw|;
name|sigma
operator|.
name|setValue
argument_list|(
name|s
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** get the value of sigma */
DECL|method|getValue ()
specifier|public
name|double
name|getValue
parameter_list|()
block|{
if|if
condition|(
name|sigma
operator|.
name|getValue
argument_list|()
operator|==
literal|null
condition|)
block|{
name|double
name|d
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parts
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|d
operator|=
name|Modular
operator|.
name|addMod
argument_list|(
name|d
argument_list|,
name|parts
index|[
name|i
index|]
operator|.
name|compute
argument_list|()
argument_list|)
expr_stmt|;
name|sigma
operator|.
name|setValue
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
specifier|final
name|double
name|s
init|=
name|Modular
operator|.
name|addMod
argument_list|(
name|sigma
operator|.
name|getValue
argument_list|()
argument_list|,
name|tail
operator|.
name|compute
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|parameter
operator|.
name|isplus
condition|?
name|s
else|:
operator|-
name|s
return|;
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
DECL|method|getElement ()
specifier|public
name|Summation
name|getElement
parameter_list|()
block|{
if|if
condition|(
name|sigma
operator|.
name|getValue
argument_list|()
operator|==
literal|null
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|double
name|d
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|parts
operator|.
name|length
operator|&&
name|parts
index|[
name|i
index|]
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
condition|;
name|i
operator|++
control|)
name|d
operator|=
name|Modular
operator|.
name|addMod
argument_list|(
name|d
argument_list|,
name|parts
index|[
name|i
index|]
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|parts
operator|.
name|length
condition|)
name|sigma
operator|.
name|setValue
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
return|return
name|sigma
return|;
block|}
comment|/** The sum tail */
DECL|class|Tail
specifier|private
class|class
name|Tail
block|{
DECL|field|n
specifier|private
name|long
name|n
decl_stmt|;
DECL|field|e
specifier|private
name|long
name|e
decl_stmt|;
DECL|method|Tail (long n, long e)
specifier|private
name|Tail
parameter_list|(
name|long
name|n
parameter_list|,
name|long
name|e
parameter_list|)
block|{
name|this
operator|.
name|n
operator|=
name|n
expr_stmt|;
name|this
operator|.
name|e
operator|=
name|e
expr_stmt|;
block|}
DECL|method|compute ()
specifier|private
name|double
name|compute
parameter_list|()
block|{
if|if
condition|(
name|e
operator|>
literal|0
condition|)
block|{
specifier|final
name|long
name|edelta
init|=
operator|-
name|sigma
operator|.
name|E
operator|.
name|delta
decl_stmt|;
name|long
name|q
init|=
name|e
operator|/
name|edelta
decl_stmt|;
name|long
name|r
init|=
name|e
operator|%
name|edelta
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|e
operator|=
literal|0
expr_stmt|;
name|n
operator|+=
name|q
operator|*
name|sigma
operator|.
name|N
operator|.
name|delta
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
name|edelta
operator|-
name|r
expr_stmt|;
name|n
operator|+=
operator|(
name|q
operator|+
literal|1
operator|)
operator|*
name|sigma
operator|.
name|N
operator|.
name|delta
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|e
operator|<
literal|0
condition|)
name|e
operator|=
operator|-
name|e
expr_stmt|;
name|double
name|s
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
name|e
operator|-=
name|sigma
operator|.
name|E
operator|.
name|delta
control|)
block|{
if|if
condition|(
name|e
operator|>
name|ACCURACY_BIT
operator|||
operator|(
literal|1L
operator|<<
operator|(
name|ACCURACY_BIT
operator|-
name|e
operator|)
operator|)
operator|<
name|n
condition|)
return|return
name|s
return|;
name|s
operator|+=
literal|1.0
operator|/
operator|(
name|n
operator|<<
name|e
operator|)
expr_stmt|;
if|if
condition|(
name|s
operator|>=
literal|1
condition|)
name|s
operator|--
expr_stmt|;
name|n
operator|+=
name|sigma
operator|.
name|N
operator|.
name|delta
expr_stmt|;
block|}
block|}
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
DECL|method|iterator ()
specifier|public
name|Iterator
argument_list|<
name|Summation
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Summation
argument_list|>
argument_list|()
block|{
specifier|private
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/** {@inheritDoc} */
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|i
operator|<
name|parts
operator|.
name|length
return|;
block|}
comment|/** {@inheritDoc} */
annotation|@
name|Override
specifier|public
name|Summation
name|next
parameter_list|()
throws|throws
name|NoSuchElementException
block|{
if|if
condition|(
name|hasNext
argument_list|()
condition|)
block|{
return|return
name|parts
index|[
name|i
operator|++
index|]
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|(
literal|"Sum's iterator does not have next!"
argument_list|)
throw|;
block|}
block|}
comment|/** Unsupported */
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
block|}
end_class

begin_comment
comment|/** Get the sums for the Bellard formula. */
end_comment

begin_function
DECL|method|getSums ( long b, int partsPerSum, Map<Parameter, List<T>> existing)
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|Container
argument_list|<
name|Summation
argument_list|>
parameter_list|>
name|Map
argument_list|<
name|Parameter
argument_list|,
name|Sum
argument_list|>
name|getSums
parameter_list|(
name|long
name|b
parameter_list|,
name|int
name|partsPerSum
parameter_list|,
name|Map
argument_list|<
name|Parameter
argument_list|,
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|existing
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|Parameter
argument_list|,
name|Sum
argument_list|>
name|sums
init|=
operator|new
name|TreeMap
argument_list|<
name|Parameter
argument_list|,
name|Sum
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Parameter
name|p
range|:
name|Parameter
operator|.
name|values
argument_list|()
control|)
block|{
specifier|final
name|Sum
name|s
init|=
operator|new
name|Sum
argument_list|(
name|b
argument_list|,
name|p
argument_list|,
name|partsPerSum
argument_list|,
name|existing
operator|.
name|get
argument_list|(
name|p
argument_list|)
argument_list|)
decl_stmt|;
name|Util
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"put "
operator|+
name|s
argument_list|)
expr_stmt|;
name|sums
operator|.
name|put
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|sums
return|;
block|}
end_function

begin_comment
comment|/** Compute bits of Pi from the results. */
end_comment

begin_function
DECL|method|computePi ( final long b, Map<Parameter, T> results)
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|Container
argument_list|<
name|Summation
argument_list|>
parameter_list|>
name|double
name|computePi
parameter_list|(
specifier|final
name|long
name|b
parameter_list|,
name|Map
argument_list|<
name|Parameter
argument_list|,
name|T
argument_list|>
name|results
parameter_list|)
block|{
if|if
condition|(
name|results
operator|.
name|size
argument_list|()
operator|!=
name|Parameter
operator|.
name|values
argument_list|()
operator|.
name|length
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"m.size() != Parameter.values().length"
operator|+
literal|", m.size()="
operator|+
name|results
operator|.
name|size
argument_list|()
operator|+
literal|"\n  m="
operator|+
name|results
argument_list|)
throw|;
name|double
name|pi
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Parameter
name|p
range|:
name|Parameter
operator|.
name|values
argument_list|()
control|)
block|{
specifier|final
name|Summation
name|sigma
init|=
name|results
operator|.
name|get
argument_list|(
name|p
argument_list|)
operator|.
name|getElement
argument_list|()
decl_stmt|;
specifier|final
name|Sum
name|s
init|=
operator|new
name|Sum
argument_list|(
name|b
argument_list|,
name|p
argument_list|,
literal|1
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|s
operator|.
name|setValue
argument_list|(
name|sigma
argument_list|)
expr_stmt|;
name|pi
operator|=
name|Modular
operator|.
name|addMod
argument_list|(
name|pi
argument_list|,
name|s
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|pi
return|;
block|}
end_function

begin_comment
comment|/** Compute bits of Pi in the local machine. */
end_comment

begin_function
DECL|method|computePi (final long b)
specifier|public
specifier|static
name|double
name|computePi
parameter_list|(
specifier|final
name|long
name|b
parameter_list|)
block|{
name|double
name|pi
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Parameter
name|p
range|:
name|Parameter
operator|.
name|values
argument_list|()
control|)
name|pi
operator|=
name|Modular
operator|.
name|addMod
argument_list|(
name|pi
argument_list|,
operator|new
name|Sum
argument_list|(
name|b
argument_list|,
name|p
argument_list|,
literal|1
argument_list|,
literal|null
argument_list|)
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|pi
return|;
block|}
end_function

begin_comment
comment|/** Estimate the number of terms. */
end_comment

begin_function
DECL|method|bit2terms (long b)
specifier|public
specifier|static
name|long
name|bit2terms
parameter_list|(
name|long
name|b
parameter_list|)
block|{
return|return
literal|7
operator|*
operator|(
name|b
operator|/
literal|10
operator|)
return|;
block|}
end_function

begin_function
DECL|method|computePi (Util.Timer t, long b)
specifier|private
specifier|static
name|void
name|computePi
parameter_list|(
name|Util
operator|.
name|Timer
name|t
parameter_list|,
name|long
name|b
parameter_list|)
block|{
name|t
operator|.
name|tick
argument_list|(
name|Util
operator|.
name|pi2string
argument_list|(
name|computePi
argument_list|(
name|b
argument_list|)
argument_list|,
name|bit2terms
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** main */
end_comment

begin_function
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Util
operator|.
name|Timer
name|t
init|=
operator|new
name|Util
operator|.
name|Timer
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|computePi
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|computePi
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|computePi
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|computePi
argument_list|(
name|t
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|computePi
argument_list|(
name|t
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|Util
operator|.
name|printBitSkipped
argument_list|(
literal|1008
argument_list|)
expr_stmt|;
name|computePi
argument_list|(
name|t
argument_list|,
literal|1008
argument_list|)
expr_stmt|;
name|computePi
argument_list|(
name|t
argument_list|,
literal|1012
argument_list|)
expr_stmt|;
name|long
name|b
init|=
literal|10
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|Util
operator|.
name|printBitSkipped
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|computePi
argument_list|(
name|t
argument_list|,
name|b
operator|-
literal|4
argument_list|)
expr_stmt|;
name|computePi
argument_list|(
name|t
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|computePi
argument_list|(
name|t
argument_list|,
name|b
operator|+
literal|4
argument_list|)
expr_stmt|;
name|b
operator|*=
literal|10
expr_stmt|;
block|}
block|}
end_function

unit|}
end_unit

