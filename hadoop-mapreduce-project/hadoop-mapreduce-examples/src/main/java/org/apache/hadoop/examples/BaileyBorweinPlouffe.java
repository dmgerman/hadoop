begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.examples
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|examples
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configured
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|BytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IntWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|InputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|InputSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Job
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRJobConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Mapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|RecordReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Reducer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|FileOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Tool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Charsets
import|;
end_import

begin_comment
comment|/**  * A map/reduce program that uses Bailey-Borwein-Plouffe to compute exact   * digits of Pi.  * This program is able to calculate digit positions  * lower than a certain limit, which is roughly 10^8.  * If the limit is exceeded,  * the corresponding results may be incorrect due to overflow errors.  * For computing higher bits of Pi, consider using distbbp.   *   * Reference:  *  * [1] David H. Bailey, Peter B. Borwein and Simon Plouffe.  On the Rapid  *     Computation of Various Polylogarithmic Constants.  *     Math. Comp., 66:903-913, 1996.  */
end_comment

begin_class
DECL|class|BaileyBorweinPlouffe
specifier|public
class|class
name|BaileyBorweinPlouffe
extends|extends
name|Configured
implements|implements
name|Tool
block|{
DECL|field|DESCRIPTION
specifier|public
specifier|static
specifier|final
name|String
name|DESCRIPTION
init|=
literal|"A map/reduce program that uses Bailey-Borwein-Plouffe to compute exact digits of Pi."
decl_stmt|;
DECL|field|NAME
specifier|private
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"mapreduce."
operator|+
name|BaileyBorweinPlouffe
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
decl_stmt|;
comment|//custom job properties
DECL|field|WORKING_DIR_PROPERTY
specifier|private
specifier|static
specifier|final
name|String
name|WORKING_DIR_PROPERTY
init|=
name|NAME
operator|+
literal|".dir"
decl_stmt|;
DECL|field|HEX_FILE_PROPERTY
specifier|private
specifier|static
specifier|final
name|String
name|HEX_FILE_PROPERTY
init|=
name|NAME
operator|+
literal|".hex.file"
decl_stmt|;
DECL|field|DIGIT_START_PROPERTY
specifier|private
specifier|static
specifier|final
name|String
name|DIGIT_START_PROPERTY
init|=
name|NAME
operator|+
literal|".digit.start"
decl_stmt|;
DECL|field|DIGIT_SIZE_PROPERTY
specifier|private
specifier|static
specifier|final
name|String
name|DIGIT_SIZE_PROPERTY
init|=
name|NAME
operator|+
literal|".digit.size"
decl_stmt|;
DECL|field|DIGIT_PARTS_PROPERTY
specifier|private
specifier|static
specifier|final
name|String
name|DIGIT_PARTS_PROPERTY
init|=
name|NAME
operator|+
literal|".digit.parts"
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|BaileyBorweinPlouffe
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Mapper class computing digits of Pi. */
DECL|class|BbpMapper
specifier|public
specifier|static
class|class
name|BbpMapper
extends|extends
name|Mapper
argument_list|<
name|LongWritable
argument_list|,
name|IntWritable
argument_list|,
name|LongWritable
argument_list|,
name|BytesWritable
argument_list|>
block|{
comment|/** Compute the (offset+1)th to (offset+length)th digits. */
DECL|method|map (LongWritable offset, IntWritable length, final Context context)
specifier|protected
name|void
name|map
parameter_list|(
name|LongWritable
name|offset
parameter_list|,
name|IntWritable
name|length
parameter_list|,
specifier|final
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"offset="
operator|+
name|offset
operator|+
literal|", length="
operator|+
name|length
argument_list|)
expr_stmt|;
comment|// compute digits
specifier|final
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|length
operator|.
name|get
argument_list|()
operator|>>
literal|1
index|]
decl_stmt|;
name|long
name|d
init|=
name|offset
operator|.
name|get
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bytes
operator|.
name|length
condition|;
name|d
operator|+=
literal|4
control|)
block|{
specifier|final
name|long
name|digits
init|=
name|hexDigits
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|bytes
index|[
name|i
operator|++
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|digits
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|bytes
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|digits
expr_stmt|;
block|}
comment|// output map results
name|context
operator|.
name|write
argument_list|(
name|offset
argument_list|,
operator|new
name|BytesWritable
argument_list|(
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Reducer for concatenating map outputs. */
DECL|class|BbpReducer
specifier|public
specifier|static
class|class
name|BbpReducer
extends|extends
name|Reducer
argument_list|<
name|LongWritable
argument_list|,
name|BytesWritable
argument_list|,
name|LongWritable
argument_list|,
name|BytesWritable
argument_list|>
block|{
comment|/** Storing hex digits */
DECL|field|hex
specifier|private
specifier|final
name|List
argument_list|<
name|Byte
argument_list|>
name|hex
init|=
operator|new
name|ArrayList
argument_list|<
name|Byte
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Concatenate map outputs. */
annotation|@
name|Override
DECL|method|reduce (LongWritable offset, Iterable<BytesWritable> values, Context context)
specifier|protected
name|void
name|reduce
parameter_list|(
name|LongWritable
name|offset
parameter_list|,
name|Iterable
argument_list|<
name|BytesWritable
argument_list|>
name|values
parameter_list|,
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// read map outputs
for|for
control|(
name|BytesWritable
name|bytes
range|:
name|values
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bytes
operator|.
name|getLength
argument_list|()
condition|;
name|i
operator|++
control|)
name|hex
operator|.
name|add
argument_list|(
name|bytes
operator|.
name|getBytes
argument_list|()
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"hex.size() = "
operator|+
name|hex
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Write output to files. */
annotation|@
name|Override
DECL|method|cleanup (Context context )
specifier|protected
name|void
name|cleanup
parameter_list|(
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
specifier|final
name|Configuration
name|conf
init|=
name|context
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|WORKING_DIR_PROPERTY
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|FileSystem
name|fs
init|=
name|dir
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// write hex output
block|{
specifier|final
name|Path
name|hexfile
init|=
operator|new
name|Path
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|HEX_FILE_PROPERTY
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|OutputStream
name|out
init|=
operator|new
name|BufferedOutputStream
argument_list|(
name|fs
operator|.
name|create
argument_list|(
name|hexfile
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
for|for
control|(
name|byte
name|b
range|:
name|hex
control|)
name|out
operator|.
name|write
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|// If the starting digit is 1,
comment|// the hex value can be converted to decimal value.
if|if
condition|(
name|conf
operator|.
name|getInt
argument_list|(
name|DIGIT_START_PROPERTY
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
specifier|final
name|Path
name|outfile
init|=
operator|new
name|Path
argument_list|(
name|dir
argument_list|,
literal|"pi.txt"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Writing text output to "
operator|+
name|outfile
argument_list|)
expr_stmt|;
specifier|final
name|OutputStream
name|outputstream
init|=
name|fs
operator|.
name|create
argument_list|(
name|outfile
argument_list|)
decl_stmt|;
try|try
block|{
specifier|final
name|PrintWriter
name|out
init|=
operator|new
name|PrintWriter
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
name|outputstream
argument_list|,
name|Charsets
operator|.
name|UTF_8
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// write hex text
name|print
argument_list|(
name|out
argument_list|,
name|hex
operator|.
name|iterator
argument_list|()
argument_list|,
literal|"Pi = 0x3."
argument_list|,
literal|"%02X"
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"Total number of hexadecimal digits is "
operator|+
literal|2
operator|*
name|hex
operator|.
name|size
argument_list|()
operator|+
literal|"."
argument_list|)
expr_stmt|;
comment|// write decimal text
specifier|final
name|Fraction
name|dec
init|=
operator|new
name|Fraction
argument_list|(
name|hex
argument_list|)
decl_stmt|;
specifier|final
name|int
name|decDigits
init|=
literal|2
operator|*
name|hex
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// TODO: this is conservative.
name|print
argument_list|(
name|out
argument_list|,
operator|new
name|Iterator
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
specifier|private
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|i
operator|<
name|decDigits
return|;
block|}
specifier|public
name|Integer
name|next
parameter_list|()
block|{
name|i
operator|++
expr_stmt|;
return|return
name|dec
operator|.
name|times10
argument_list|()
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{             }
block|}
argument_list|,
literal|"Pi = 3."
argument_list|,
literal|"%d"
argument_list|,
literal|10
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"Total number of decimal digits is "
operator|+
name|decDigits
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|outputstream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** Print out elements in a nice format. */
DECL|method|print (PrintWriter out, Iterator<T> iterator, String prefix, String format, int elementsPerGroup, int groupsPerLine)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|void
name|print
parameter_list|(
name|PrintWriter
name|out
parameter_list|,
name|Iterator
argument_list|<
name|T
argument_list|>
name|iterator
parameter_list|,
name|String
name|prefix
parameter_list|,
name|String
name|format
parameter_list|,
name|int
name|elementsPerGroup
parameter_list|,
name|int
name|groupsPerLine
parameter_list|)
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"\n"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|prefix
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
name|sb
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
specifier|final
name|String
name|spaces
init|=
name|sb
operator|.
name|toString
argument_list|()
decl_stmt|;
name|out
operator|.
name|print
argument_list|(
literal|"\n"
operator|+
name|prefix
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|i
operator|%
name|elementsPerGroup
operator|==
literal|0
condition|)
name|out
operator|.
name|print
argument_list|(
operator|(
name|i
operator|/
name|elementsPerGroup
operator|)
operator|%
name|groupsPerLine
operator|==
literal|0
condition|?
name|spaces
else|:
literal|" "
argument_list|)
expr_stmt|;
name|out
operator|.
name|print
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|format
argument_list|,
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
comment|/** Input split for the {@link BbpInputFormat}. */
DECL|class|BbpSplit
specifier|public
specifier|static
class|class
name|BbpSplit
extends|extends
name|InputSplit
implements|implements
name|Writable
block|{
DECL|field|EMPTY
specifier|private
specifier|final
specifier|static
name|String
index|[]
name|EMPTY
init|=
block|{}
decl_stmt|;
DECL|field|offset
specifier|private
name|long
name|offset
decl_stmt|;
DECL|field|size
specifier|private
name|int
name|size
decl_stmt|;
comment|/** Public default constructor for the Writable interface. */
DECL|method|BbpSplit ()
specifier|public
name|BbpSplit
parameter_list|()
block|{     }
DECL|method|BbpSplit (int i, long offset, int size)
specifier|private
name|BbpSplit
parameter_list|(
name|int
name|i
parameter_list|,
name|long
name|offset
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Map #"
operator|+
name|i
operator|+
literal|": workload="
operator|+
name|workload
argument_list|(
name|offset
argument_list|,
name|size
argument_list|)
operator|+
literal|", offset="
operator|+
name|offset
operator|+
literal|", size="
operator|+
name|size
argument_list|)
expr_stmt|;
name|this
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
block|}
DECL|method|getOffset ()
specifier|private
name|long
name|getOffset
parameter_list|()
block|{
return|return
name|offset
return|;
block|}
comment|/** {@inheritDoc} */
DECL|method|getLength ()
specifier|public
name|long
name|getLength
parameter_list|()
block|{
return|return
name|size
return|;
block|}
comment|/** No location is needed. */
DECL|method|getLocations ()
specifier|public
name|String
index|[]
name|getLocations
parameter_list|()
block|{
return|return
name|EMPTY
return|;
block|}
comment|/** {@inheritDoc} */
DECL|method|readFields (DataInput in)
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|offset
operator|=
name|in
operator|.
name|readLong
argument_list|()
expr_stmt|;
name|size
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
block|}
comment|/** {@inheritDoc} */
DECL|method|write (DataOutput out)
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeLong
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Input format for the {@link BbpMapper}.    * Keys and values represent offsets and sizes, respectively.    */
DECL|class|BbpInputFormat
specifier|public
specifier|static
class|class
name|BbpInputFormat
extends|extends
name|InputFormat
argument_list|<
name|LongWritable
argument_list|,
name|IntWritable
argument_list|>
block|{
comment|/** {@inheritDoc} */
DECL|method|getSplits (JobContext context)
specifier|public
name|List
argument_list|<
name|InputSplit
argument_list|>
name|getSplits
parameter_list|(
name|JobContext
name|context
parameter_list|)
block|{
comment|//get the property values
specifier|final
name|int
name|startDigit
init|=
name|context
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|DIGIT_START_PROPERTY
argument_list|,
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|int
name|nDigits
init|=
name|context
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|DIGIT_SIZE_PROPERTY
argument_list|,
literal|100
argument_list|)
decl_stmt|;
specifier|final
name|int
name|nMaps
init|=
name|context
operator|.
name|getConfiguration
argument_list|()
operator|.
name|getInt
argument_list|(
name|DIGIT_PARTS_PROPERTY
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|//create splits
specifier|final
name|List
argument_list|<
name|InputSplit
argument_list|>
name|splits
init|=
operator|new
name|ArrayList
argument_list|<
name|InputSplit
argument_list|>
argument_list|(
name|nMaps
argument_list|)
decl_stmt|;
specifier|final
name|int
index|[]
name|parts
init|=
name|partition
argument_list|(
name|startDigit
operator|-
literal|1
argument_list|,
name|nDigits
argument_list|,
name|nMaps
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parts
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|int
name|k
init|=
name|i
operator|<
name|parts
operator|.
name|length
operator|-
literal|1
condition|?
name|parts
index|[
name|i
operator|+
literal|1
index|]
else|:
name|nDigits
operator|+
name|startDigit
operator|-
literal|1
decl_stmt|;
name|splits
operator|.
name|add
argument_list|(
operator|new
name|BbpSplit
argument_list|(
name|i
argument_list|,
name|parts
index|[
name|i
index|]
argument_list|,
name|k
operator|-
name|parts
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|splits
return|;
block|}
comment|/** {@inheritDoc} */
DECL|method|createRecordReader ( InputSplit generic, TaskAttemptContext context)
specifier|public
name|RecordReader
argument_list|<
name|LongWritable
argument_list|,
name|IntWritable
argument_list|>
name|createRecordReader
parameter_list|(
name|InputSplit
name|generic
parameter_list|,
name|TaskAttemptContext
name|context
parameter_list|)
block|{
specifier|final
name|BbpSplit
name|split
init|=
operator|(
name|BbpSplit
operator|)
name|generic
decl_stmt|;
comment|//return a record reader
return|return
operator|new
name|RecordReader
argument_list|<
name|LongWritable
argument_list|,
name|IntWritable
argument_list|>
argument_list|()
block|{
name|boolean
name|done
init|=
literal|false
decl_stmt|;
specifier|public
name|void
name|initialize
parameter_list|(
name|InputSplit
name|split
parameter_list|,
name|TaskAttemptContext
name|context
parameter_list|)
block|{         }
specifier|public
name|boolean
name|nextKeyValue
parameter_list|()
block|{
comment|//Each record only contains one key.
return|return
operator|!
name|done
condition|?
name|done
operator|=
literal|true
else|:
literal|false
return|;
block|}
specifier|public
name|LongWritable
name|getCurrentKey
parameter_list|()
block|{
return|return
operator|new
name|LongWritable
argument_list|(
name|split
operator|.
name|getOffset
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|IntWritable
name|getCurrentValue
parameter_list|()
block|{
return|return
operator|new
name|IntWritable
argument_list|(
operator|(
name|int
operator|)
name|split
operator|.
name|getLength
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|float
name|getProgress
parameter_list|()
block|{
return|return
name|done
condition|?
literal|1f
else|:
literal|0f
return|;
block|}
specifier|public
name|void
name|close
parameter_list|()
block|{         }
block|}
return|;
block|}
block|}
comment|/** Create and setup a job */
DECL|method|createJob (String name, Configuration conf )
specifier|private
specifier|static
name|Job
name|createJob
parameter_list|(
name|String
name|name
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Job
name|job
init|=
name|Job
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|,
name|NAME
operator|+
literal|"_"
operator|+
name|name
argument_list|)
decl_stmt|;
specifier|final
name|Configuration
name|jobconf
init|=
name|job
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|job
operator|.
name|setJarByClass
argument_list|(
name|BaileyBorweinPlouffe
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// setup mapper
name|job
operator|.
name|setMapperClass
argument_list|(
name|BbpMapper
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setMapOutputKeyClass
argument_list|(
name|LongWritable
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setMapOutputValueClass
argument_list|(
name|BytesWritable
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// setup reducer
name|job
operator|.
name|setReducerClass
argument_list|(
name|BbpReducer
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputKeyClass
argument_list|(
name|LongWritable
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputValueClass
argument_list|(
name|BytesWritable
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setNumReduceTasks
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// setup input
name|job
operator|.
name|setInputFormatClass
argument_list|(
name|BbpInputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// disable task timeout
name|jobconf
operator|.
name|setLong
argument_list|(
name|MRJobConfig
operator|.
name|TASK_TIMEOUT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// do not use speculative execution
name|jobconf
operator|.
name|setBoolean
argument_list|(
name|MRJobConfig
operator|.
name|MAP_SPECULATIVE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|jobconf
operator|.
name|setBoolean
argument_list|(
name|MRJobConfig
operator|.
name|REDUCE_SPECULATIVE
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|job
return|;
block|}
comment|/** Run a map/reduce job to compute Pi. */
DECL|method|compute (int startDigit, int nDigits, int nMaps, String workingDir, Configuration conf, PrintStream out )
specifier|private
specifier|static
name|void
name|compute
parameter_list|(
name|int
name|startDigit
parameter_list|,
name|int
name|nDigits
parameter_list|,
name|int
name|nMaps
parameter_list|,
name|String
name|workingDir
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|PrintStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|name
init|=
name|startDigit
operator|+
literal|"_"
operator|+
name|nDigits
decl_stmt|;
comment|//setup wroking directory
name|out
operator|.
name|println
argument_list|(
literal|"Working Directory = "
operator|+
name|workingDir
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
specifier|final
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|dir
init|=
name|fs
operator|.
name|makeQualified
argument_list|(
operator|new
name|Path
argument_list|(
name|workingDir
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|dir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Working directory "
operator|+
name|dir
operator|+
literal|" already exists.  Please remove it first."
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
operator|!
name|fs
operator|.
name|mkdirs
argument_list|(
name|dir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot create working directory "
operator|+
name|dir
argument_list|)
throw|;
block|}
name|out
operator|.
name|println
argument_list|(
literal|"Start Digit      = "
operator|+
name|startDigit
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"Number of Digits = "
operator|+
name|nDigits
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"Number of Maps   = "
operator|+
name|nMaps
argument_list|)
expr_stmt|;
comment|// setup a job
specifier|final
name|Job
name|job
init|=
name|createJob
argument_list|(
name|name
argument_list|,
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|hexfile
init|=
operator|new
name|Path
argument_list|(
name|dir
argument_list|,
literal|"pi_"
operator|+
name|name
operator|+
literal|".hex"
argument_list|)
decl_stmt|;
name|FileOutputFormat
operator|.
name|setOutputPath
argument_list|(
name|job
argument_list|,
operator|new
name|Path
argument_list|(
name|dir
argument_list|,
literal|"out"
argument_list|)
argument_list|)
expr_stmt|;
comment|// setup custom properties
name|job
operator|.
name|getConfiguration
argument_list|()
operator|.
name|set
argument_list|(
name|WORKING_DIR_PROPERTY
argument_list|,
name|dir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|getConfiguration
argument_list|()
operator|.
name|set
argument_list|(
name|HEX_FILE_PROPERTY
argument_list|,
name|hexfile
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|getConfiguration
argument_list|()
operator|.
name|setInt
argument_list|(
name|DIGIT_START_PROPERTY
argument_list|,
name|startDigit
argument_list|)
expr_stmt|;
name|job
operator|.
name|getConfiguration
argument_list|()
operator|.
name|setInt
argument_list|(
name|DIGIT_SIZE_PROPERTY
argument_list|,
name|nDigits
argument_list|)
expr_stmt|;
name|job
operator|.
name|getConfiguration
argument_list|()
operator|.
name|setInt
argument_list|(
name|DIGIT_PARTS_PROPERTY
argument_list|,
name|nMaps
argument_list|)
expr_stmt|;
comment|// start a map/reduce job
name|out
operator|.
name|println
argument_list|(
literal|"\nStarting Job ..."
argument_list|)
expr_stmt|;
specifier|final
name|long
name|startTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|job
operator|.
name|waitForCompletion
argument_list|(
literal|true
argument_list|)
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"Job failed."
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
specifier|final
name|double
name|duration
init|=
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTime
operator|)
operator|/
literal|1000.0
decl_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"Duration is "
operator|+
name|duration
operator|+
literal|" seconds."
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|println
argument_list|(
literal|"Output file: "
operator|+
name|hexfile
argument_list|)
expr_stmt|;
block|}
comment|/**    * Parse arguments and then runs a map/reduce job.    * @return a non-zero value if there is an error. Otherwise, return 0.    */
DECL|method|run (String[] args)
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|args
operator|.
name|length
operator|!=
literal|4
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: bbp "
operator|+
literal|"<startDigit><nDigits><nMaps><workingDir>"
argument_list|)
expr_stmt|;
name|ToolRunner
operator|.
name|printGenericCommandUsage
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
specifier|final
name|int
name|startDigit
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
specifier|final
name|int
name|nDigits
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
specifier|final
name|int
name|nMaps
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
specifier|final
name|String
name|workingDir
init|=
name|args
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|startDigit
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"startDigit = "
operator|+
name|startDigit
operator|+
literal|"<= 0"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|nDigits
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"nDigits = "
operator|+
name|nDigits
operator|+
literal|"<= 0"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|nDigits
operator|%
name|BBP_HEX_DIGITS
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"nDigits = "
operator|+
name|nDigits
operator|+
literal|" is not a multiple of "
operator|+
name|BBP_HEX_DIGITS
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|nDigits
operator|-
literal|1L
operator|+
name|startDigit
operator|>
name|IMPLEMENTATION_LIMIT
operator|+
name|BBP_HEX_DIGITS
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"nDigits - 1 + startDigit = "
operator|+
operator|(
name|nDigits
operator|-
literal|1L
operator|+
name|startDigit
operator|)
operator|+
literal|"> IMPLEMENTATION_LIMIT + BBP_HEX_DIGITS,"
operator|+
literal|", where IMPLEMENTATION_LIMIT="
operator|+
name|IMPLEMENTATION_LIMIT
operator|+
literal|"and BBP_HEX_DIGITS="
operator|+
name|BBP_HEX_DIGITS
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|nMaps
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"nMaps = "
operator|+
name|nMaps
operator|+
literal|"<= 0"
argument_list|)
throw|;
block|}
name|compute
argument_list|(
name|startDigit
argument_list|,
name|nDigits
argument_list|,
name|nMaps
argument_list|,
name|workingDir
argument_list|,
name|getConf
argument_list|()
argument_list|,
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/** The main method for running it as a stand alone command. */
DECL|method|main (String[] argv)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|argv
parameter_list|)
throws|throws
name|Exception
block|{
name|System
operator|.
name|exit
argument_list|(
name|ToolRunner
operator|.
name|run
argument_list|(
literal|null
argument_list|,
operator|new
name|BaileyBorweinPlouffe
argument_list|()
argument_list|,
name|argv
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/////////////////////////////////////////////////////////////////////
comment|// static fields and methods for Bailey-Borwein-Plouffe algorithm. //
comment|/////////////////////////////////////////////////////////////////////
comment|/** Limitation of the program.    * The program may return incorrect results if the limit is exceeded.    * The default value is 10^8.    * The program probably can handle some higher values such as 2^28.    */
DECL|field|IMPLEMENTATION_LIMIT
specifier|private
specifier|static
specifier|final
name|long
name|IMPLEMENTATION_LIMIT
init|=
literal|100000000
decl_stmt|;
DECL|field|ACCURACY_BIT
specifier|private
specifier|static
specifier|final
name|long
name|ACCURACY_BIT
init|=
literal|32
decl_stmt|;
DECL|field|BBP_HEX_DIGITS
specifier|private
specifier|static
specifier|final
name|long
name|BBP_HEX_DIGITS
init|=
literal|4
decl_stmt|;
DECL|field|BBP_MULTIPLIER
specifier|private
specifier|static
specifier|final
name|long
name|BBP_MULTIPLIER
init|=
literal|1
operator|<<
operator|(
literal|4
operator|*
name|BBP_HEX_DIGITS
operator|)
decl_stmt|;
comment|/**    * Compute the exact (d+1)th to (d+{@link #BBP_HEX_DIGITS})th    * hex digits of pi.    */
DECL|method|hexDigits (final long d)
specifier|static
name|long
name|hexDigits
parameter_list|(
specifier|final
name|long
name|d
parameter_list|)
block|{
if|if
condition|(
name|d
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"d = "
operator|+
name|d
operator|+
literal|"< 0"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|d
operator|>
name|IMPLEMENTATION_LIMIT
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"d = "
operator|+
name|d
operator|+
literal|"> IMPLEMENTATION_LIMIT = "
operator|+
name|IMPLEMENTATION_LIMIT
argument_list|)
throw|;
block|}
specifier|final
name|double
name|s1
init|=
name|sum
argument_list|(
literal|1
argument_list|,
name|d
argument_list|)
decl_stmt|;
specifier|final
name|double
name|s4
init|=
name|sum
argument_list|(
literal|4
argument_list|,
name|d
argument_list|)
decl_stmt|;
specifier|final
name|double
name|s5
init|=
name|sum
argument_list|(
literal|5
argument_list|,
name|d
argument_list|)
decl_stmt|;
specifier|final
name|double
name|s6
init|=
name|sum
argument_list|(
literal|6
argument_list|,
name|d
argument_list|)
decl_stmt|;
name|double
name|pi
init|=
name|s1
operator|+
name|s1
decl_stmt|;
if|if
condition|(
name|pi
operator|>=
literal|1
condition|)
name|pi
operator|--
expr_stmt|;
name|pi
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|pi
operator|>=
literal|1
condition|)
name|pi
operator|--
expr_stmt|;
name|pi
operator|-=
name|s4
expr_stmt|;
if|if
condition|(
name|pi
operator|<
literal|0
condition|)
name|pi
operator|++
expr_stmt|;
name|pi
operator|-=
name|s4
expr_stmt|;
if|if
condition|(
name|pi
operator|<
literal|0
condition|)
name|pi
operator|++
expr_stmt|;
name|pi
operator|-=
name|s5
expr_stmt|;
if|if
condition|(
name|pi
operator|<
literal|0
condition|)
name|pi
operator|++
expr_stmt|;
name|pi
operator|-=
name|s6
expr_stmt|;
if|if
condition|(
name|pi
operator|<
literal|0
condition|)
name|pi
operator|++
expr_stmt|;
return|return
call|(
name|long
call|)
argument_list|(
name|pi
operator|*
name|BBP_MULTIPLIER
argument_list|)
return|;
block|}
comment|/**    * Approximate the fraction part of    * $16^d \sum_{k=0}^\infty \frac{16^{d-k}}{8k+j}$    * for d> 0 and j = 1, 4, 5, 6.    */
DECL|method|sum (final long j, final long d)
specifier|private
specifier|static
name|double
name|sum
parameter_list|(
specifier|final
name|long
name|j
parameter_list|,
specifier|final
name|long
name|d
parameter_list|)
block|{
name|long
name|k
init|=
name|j
operator|==
literal|1
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|double
name|s
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|k
operator|<=
name|d
condition|)
block|{
name|s
operator|=
literal|1.0
operator|/
operator|(
operator|(
name|d
operator|<<
literal|3
operator|)
operator||
name|j
operator|)
expr_stmt|;
for|for
control|(
init|;
name|k
operator|<
name|d
condition|;
name|k
operator|++
control|)
block|{
specifier|final
name|long
name|n
init|=
operator|(
name|k
operator|<<
literal|3
operator|)
operator||
name|j
decl_stmt|;
name|s
operator|+=
name|mod
argument_list|(
operator|(
name|d
operator|-
name|k
operator|)
operator|<<
literal|2
argument_list|,
name|n
argument_list|)
operator|*
literal|1.0
operator|/
name|n
expr_stmt|;
if|if
condition|(
name|s
operator|>=
literal|1
condition|)
name|s
operator|--
expr_stmt|;
block|}
name|k
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|>=
literal|1L
operator|<<
operator|(
name|ACCURACY_BIT
operator|-
literal|7
operator|)
condition|)
return|return
name|s
return|;
for|for
control|(
init|;
condition|;
name|k
operator|++
control|)
block|{
specifier|final
name|long
name|n
init|=
operator|(
name|k
operator|<<
literal|3
operator|)
operator||
name|j
decl_stmt|;
specifier|final
name|long
name|shift
init|=
operator|(
name|k
operator|-
name|d
operator|)
operator|<<
literal|2
decl_stmt|;
if|if
condition|(
name|ACCURACY_BIT
operator|<=
name|shift
operator|||
literal|1L
operator|<<
operator|(
name|ACCURACY_BIT
operator|-
name|shift
operator|)
operator|<
name|n
condition|)
block|{
return|return
name|s
return|;
block|}
name|s
operator|+=
literal|1.0
operator|/
operator|(
name|n
operator|<<
name|shift
operator|)
expr_stmt|;
if|if
condition|(
name|s
operator|>=
literal|1
condition|)
name|s
operator|--
expr_stmt|;
block|}
block|}
comment|/** Compute $2^e \mod n$ for e> 0, n> 2 */
DECL|method|mod (final long e, final long n)
specifier|static
name|long
name|mod
parameter_list|(
specifier|final
name|long
name|e
parameter_list|,
specifier|final
name|long
name|n
parameter_list|)
block|{
name|long
name|mask
init|=
operator|(
name|e
operator|&
literal|0xFFFFFFFF00000000L
operator|)
operator|==
literal|0
condition|?
literal|0x00000000FFFFFFFFL
else|:
literal|0xFFFFFFFF00000000L
decl_stmt|;
name|mask
operator|&=
operator|(
name|e
operator|&
literal|0xFFFF0000FFFF0000L
operator|&
name|mask
operator|)
operator|==
literal|0
condition|?
literal|0x0000FFFF0000FFFFL
else|:
literal|0xFFFF0000FFFF0000L
expr_stmt|;
name|mask
operator|&=
operator|(
name|e
operator|&
literal|0xFF00FF00FF00FF00L
operator|&
name|mask
operator|)
operator|==
literal|0
condition|?
literal|0x00FF00FF00FF00FFL
else|:
literal|0xFF00FF00FF00FF00L
expr_stmt|;
name|mask
operator|&=
operator|(
name|e
operator|&
literal|0xF0F0F0F0F0F0F0F0L
operator|&
name|mask
operator|)
operator|==
literal|0
condition|?
literal|0x0F0F0F0F0F0F0F0FL
else|:
literal|0xF0F0F0F0F0F0F0F0L
expr_stmt|;
name|mask
operator|&=
operator|(
name|e
operator|&
literal|0xCCCCCCCCCCCCCCCCL
operator|&
name|mask
operator|)
operator|==
literal|0
condition|?
literal|0x3333333333333333L
else|:
literal|0xCCCCCCCCCCCCCCCCL
expr_stmt|;
name|mask
operator|&=
operator|(
name|e
operator|&
literal|0xAAAAAAAAAAAAAAAAL
operator|&
name|mask
operator|)
operator|==
literal|0
condition|?
literal|0x5555555555555555L
else|:
literal|0xAAAAAAAAAAAAAAAAL
expr_stmt|;
name|long
name|r
init|=
literal|2
decl_stmt|;
for|for
control|(
name|mask
operator|>>=
literal|1
init|;
name|mask
operator|>
literal|0
condition|;
name|mask
operator|>>=
literal|1
control|)
block|{
name|r
operator|*=
name|r
expr_stmt|;
name|r
operator|%=
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|r
operator|+=
name|r
expr_stmt|;
if|if
condition|(
name|r
operator|>=
name|n
condition|)
name|r
operator|-=
name|n
expr_stmt|;
block|}
block|}
return|return
name|r
return|;
block|}
comment|/** Represent a number x in hex for 1> x>= 0 */
DECL|class|Fraction
specifier|private
specifier|static
class|class
name|Fraction
block|{
DECL|field|integers
specifier|private
specifier|final
name|int
index|[]
name|integers
decl_stmt|;
comment|// only use 24-bit
DECL|field|first
specifier|private
name|int
name|first
init|=
literal|0
decl_stmt|;
comment|// index to the first non-zero integer
comment|/** Construct a fraction represented by the bytes. */
DECL|method|Fraction (List<Byte> bytes)
name|Fraction
parameter_list|(
name|List
argument_list|<
name|Byte
argument_list|>
name|bytes
parameter_list|)
block|{
name|integers
operator|=
operator|new
name|int
index|[
operator|(
name|bytes
operator|.
name|size
argument_list|()
operator|+
literal|2
operator|)
operator|/
literal|3
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bytes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|b
init|=
literal|0xFF
operator|&
name|bytes
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|integers
index|[
name|integers
operator|.
name|length
operator|-
literal|1
operator|-
name|i
operator|/
literal|3
index|]
operator||=
name|b
operator|<<
operator|(
operator|(
literal|2
operator|-
name|i
operator|%
literal|3
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
name|skipZeros
argument_list|()
expr_stmt|;
block|}
comment|/**      * Compute y = 10*x and then set x to the fraction part of y, where x is the      * fraction represented by this object.      * @return integer part of y      */
DECL|method|times10 ()
name|int
name|times10
parameter_list|()
block|{
name|int
name|carry
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|first
init|;
name|i
operator|<
name|integers
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|integers
index|[
name|i
index|]
operator|<<=
literal|1
expr_stmt|;
name|integers
index|[
name|i
index|]
operator|+=
name|carry
operator|+
operator|(
name|integers
index|[
name|i
index|]
operator|<<
literal|2
operator|)
expr_stmt|;
name|carry
operator|=
name|integers
index|[
name|i
index|]
operator|>>
literal|24
expr_stmt|;
name|integers
index|[
name|i
index|]
operator|&=
literal|0xFFFFFF
expr_stmt|;
block|}
name|skipZeros
argument_list|()
expr_stmt|;
return|return
name|carry
return|;
block|}
DECL|method|skipZeros ()
specifier|private
name|void
name|skipZeros
parameter_list|()
block|{
for|for
control|(
init|;
name|first
operator|<
name|integers
operator|.
name|length
operator|&&
name|integers
index|[
name|first
index|]
operator|==
literal|0
condition|;
name|first
operator|++
control|)
empty_stmt|;
block|}
block|}
comment|/**    * Partition input so that the workload of each part is    * approximately the same.    */
DECL|method|partition (final int offset, final int size, final int nParts)
specifier|static
name|int
index|[]
name|partition
parameter_list|(
specifier|final
name|int
name|offset
parameter_list|,
specifier|final
name|int
name|size
parameter_list|,
specifier|final
name|int
name|nParts
parameter_list|)
block|{
specifier|final
name|int
index|[]
name|parts
init|=
operator|new
name|int
index|[
name|nParts
index|]
decl_stmt|;
specifier|final
name|long
name|total
init|=
name|workload
argument_list|(
name|offset
argument_list|,
name|size
argument_list|)
decl_stmt|;
specifier|final
name|int
name|remainder
init|=
name|offset
operator|%
literal|4
decl_stmt|;
name|parts
index|[
literal|0
index|]
operator|=
name|offset
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|nParts
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|long
name|target
init|=
name|offset
operator|+
name|i
operator|*
operator|(
name|total
operator|/
name|nParts
operator|)
operator|+
name|i
operator|*
operator|(
name|total
operator|%
name|nParts
operator|)
operator|/
name|nParts
decl_stmt|;
comment|//search the closest value
name|int
name|low
init|=
name|parts
index|[
name|i
operator|-
literal|1
index|]
decl_stmt|;
name|int
name|high
init|=
name|offset
operator|+
name|size
decl_stmt|;
for|for
control|(
init|;
name|high
operator|>
name|low
operator|+
literal|4
condition|;
control|)
block|{
specifier|final
name|int
name|mid
init|=
operator|(
name|high
operator|+
name|low
operator|-
literal|2
operator|*
name|remainder
operator|)
operator|/
literal|8
operator|*
literal|4
operator|+
name|remainder
decl_stmt|;
specifier|final
name|long
name|midvalue
init|=
name|workload
argument_list|(
name|mid
argument_list|)
decl_stmt|;
if|if
condition|(
name|midvalue
operator|==
name|target
condition|)
name|high
operator|=
name|low
operator|=
name|mid
expr_stmt|;
elseif|else
if|if
condition|(
name|midvalue
operator|>
name|target
condition|)
name|high
operator|=
name|mid
expr_stmt|;
else|else
name|low
operator|=
name|mid
expr_stmt|;
block|}
name|parts
index|[
name|i
index|]
operator|=
name|high
operator|==
name|low
condition|?
name|high
else|:
name|workload
argument_list|(
name|high
argument_list|)
operator|-
name|target
operator|>
name|target
operator|-
name|workload
argument_list|(
name|low
argument_list|)
condition|?
name|low
else|:
name|high
expr_stmt|;
block|}
return|return
name|parts
return|;
block|}
DECL|field|MAX_N
specifier|private
specifier|static
specifier|final
name|long
name|MAX_N
init|=
literal|4294967295L
decl_stmt|;
comment|// prevent overflow
comment|/** Estimate the workload for input size n (in some unit). */
DECL|method|workload (final long n)
specifier|private
specifier|static
name|long
name|workload
parameter_list|(
specifier|final
name|long
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"n = "
operator|+
name|n
operator|+
literal|"< 0"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>
name|MAX_N
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"n = "
operator|+
name|n
operator|+
literal|"> MAX_N = "
operator|+
name|MAX_N
argument_list|)
throw|;
block|}
return|return
operator|(
name|n
operator|&
literal|1L
operator|)
operator|==
literal|0L
condition|?
operator|(
name|n
operator|>>
literal|1
operator|)
operator|*
operator|(
name|n
operator|+
literal|1
operator|)
else|:
name|n
operator|*
operator|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|>>
literal|1
operator|)
return|;
block|}
DECL|method|workload (long offset, long size)
specifier|private
specifier|static
name|long
name|workload
parameter_list|(
name|long
name|offset
parameter_list|,
name|long
name|size
parameter_list|)
block|{
return|return
name|workload
argument_list|(
name|offset
operator|+
name|size
argument_list|)
operator|-
name|workload
argument_list|(
name|offset
argument_list|)
return|;
block|}
block|}
end_class

end_unit

