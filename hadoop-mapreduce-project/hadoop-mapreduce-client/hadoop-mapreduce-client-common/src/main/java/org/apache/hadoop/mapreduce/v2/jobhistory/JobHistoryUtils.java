begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/** * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file * distributed with this work for additional information * regarding copyright ownership.  The ASF licenses this file * to you under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance * with the License.  You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapreduce.v2.jobhistory
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|v2
operator|.
name|jobhistory
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Calendar
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|UnsupportedFileSystemException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRJobConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TypeConverter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|v2
operator|.
name|api
operator|.
name|records
operator|.
name|JobId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|v2
operator|.
name|util
operator|.
name|MRApps
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationAttemptId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|JobHistoryUtils
specifier|public
class|class
name|JobHistoryUtils
block|{
comment|/**    * Permissions for the history staging dir while JobInProgress.    */
DECL|field|HISTORY_STAGING_DIR_PERMISSIONS
specifier|public
specifier|static
specifier|final
name|FsPermission
name|HISTORY_STAGING_DIR_PERMISSIONS
init|=
name|FsPermission
operator|.
name|createImmutable
argument_list|(
operator|(
name|short
operator|)
literal|0700
argument_list|)
decl_stmt|;
comment|/**    * Permissions for the user directory under the staging directory.    */
DECL|field|HISTORY_STAGING_USER_DIR_PERMISSIONS
specifier|public
specifier|static
specifier|final
name|FsPermission
name|HISTORY_STAGING_USER_DIR_PERMISSIONS
init|=
name|FsPermission
operator|.
name|createImmutable
argument_list|(
operator|(
name|short
operator|)
literal|0700
argument_list|)
decl_stmt|;
comment|/**    * Permissions for the history done dir and derivatives.    */
DECL|field|HISTORY_DONE_DIR_PERMISSION
specifier|public
specifier|static
specifier|final
name|FsPermission
name|HISTORY_DONE_DIR_PERMISSION
init|=
name|FsPermission
operator|.
name|createImmutable
argument_list|(
operator|(
name|short
operator|)
literal|0770
argument_list|)
decl_stmt|;
DECL|field|HISTORY_DONE_FILE_PERMISSION
specifier|public
specifier|static
specifier|final
name|FsPermission
name|HISTORY_DONE_FILE_PERMISSION
init|=
name|FsPermission
operator|.
name|createImmutable
argument_list|(
operator|(
name|short
operator|)
literal|0770
argument_list|)
decl_stmt|;
comment|// rwx------
comment|/**    * Umask for the done dir and derivatives.    */
DECL|field|HISTORY_DONE_DIR_UMASK
specifier|public
specifier|static
specifier|final
name|FsPermission
name|HISTORY_DONE_DIR_UMASK
init|=
name|FsPermission
operator|.
name|createImmutable
argument_list|(
call|(
name|short
call|)
argument_list|(
literal|0770
operator|^
literal|0777
argument_list|)
argument_list|)
decl_stmt|;
comment|/**    * Permissions for the intermediate done directory.    */
DECL|field|HISTORY_INTERMEDIATE_DONE_DIR_PERMISSIONS
specifier|public
specifier|static
specifier|final
name|FsPermission
name|HISTORY_INTERMEDIATE_DONE_DIR_PERMISSIONS
init|=
name|FsPermission
operator|.
name|createImmutable
argument_list|(
operator|(
name|short
operator|)
literal|01777
argument_list|)
decl_stmt|;
DECL|field|HISTORY_INTERMEDIATE_FILE_PERMISSIONS
specifier|public
specifier|static
specifier|final
name|FsPermission
name|HISTORY_INTERMEDIATE_FILE_PERMISSIONS
init|=
name|FsPermission
operator|.
name|createImmutable
argument_list|(
operator|(
name|short
operator|)
literal|0770
argument_list|)
decl_stmt|;
comment|// rwx------
comment|/**    * Suffix for configuration files.    */
DECL|field|CONF_FILE_NAME_SUFFIX
specifier|public
specifier|static
specifier|final
name|String
name|CONF_FILE_NAME_SUFFIX
init|=
literal|"_conf.xml"
decl_stmt|;
comment|/**    * Suffix for summary files.    */
DECL|field|SUMMARY_FILE_NAME_SUFFIX
specifier|public
specifier|static
specifier|final
name|String
name|SUMMARY_FILE_NAME_SUFFIX
init|=
literal|".summary"
decl_stmt|;
comment|/**    * Job History File extension.    */
DECL|field|JOB_HISTORY_FILE_EXTENSION
specifier|public
specifier|static
specifier|final
name|String
name|JOB_HISTORY_FILE_EXTENSION
init|=
literal|".jhist"
decl_stmt|;
DECL|field|VERSION
specifier|public
specifier|static
specifier|final
name|int
name|VERSION
init|=
literal|4
decl_stmt|;
DECL|field|SERIAL_NUMBER_DIRECTORY_DIGITS
specifier|public
specifier|static
specifier|final
name|int
name|SERIAL_NUMBER_DIRECTORY_DIGITS
init|=
literal|6
decl_stmt|;
DECL|field|TIMESTAMP_DIR_REGEX
specifier|public
specifier|static
specifier|final
name|String
name|TIMESTAMP_DIR_REGEX
init|=
literal|"\\d{4}"
operator|+
literal|"\\"
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
literal|"\\d{2}"
operator|+
literal|"\\"
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
literal|"\\d{2}"
decl_stmt|;
DECL|field|TIMESTAMP_DIR_PATTERN
specifier|public
specifier|static
specifier|final
name|Pattern
name|TIMESTAMP_DIR_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|TIMESTAMP_DIR_REGEX
argument_list|)
decl_stmt|;
DECL|field|TIMESTAMP_DIR_FORMAT
specifier|private
specifier|static
specifier|final
name|String
name|TIMESTAMP_DIR_FORMAT
init|=
literal|"%04d"
operator|+
name|File
operator|.
name|separator
operator|+
literal|"%02d"
operator|+
name|File
operator|.
name|separator
operator|+
literal|"%02d"
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|JobHistoryUtils
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|CONF_FILTER
specifier|private
specifier|static
specifier|final
name|PathFilter
name|CONF_FILTER
init|=
operator|new
name|PathFilter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
return|return
name|path
operator|.
name|getName
argument_list|()
operator|.
name|endsWith
argument_list|(
name|CONF_FILE_NAME_SUFFIX
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|field|JOB_HISTORY_FILE_FILTER
specifier|private
specifier|static
specifier|final
name|PathFilter
name|JOB_HISTORY_FILE_FILTER
init|=
operator|new
name|PathFilter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
return|return
name|path
operator|.
name|getName
argument_list|()
operator|.
name|endsWith
argument_list|(
name|JOB_HISTORY_FILE_EXTENSION
argument_list|)
return|;
block|}
block|}
decl_stmt|;
comment|/**    * Checks whether the provided path string is a valid job history file.    * @param pathString the path to be checked.    * @return true is the path is a valid job history filename else return false    */
DECL|method|isValidJobHistoryFileName (String pathString)
specifier|public
specifier|static
name|boolean
name|isValidJobHistoryFileName
parameter_list|(
name|String
name|pathString
parameter_list|)
block|{
return|return
name|pathString
operator|.
name|endsWith
argument_list|(
name|JOB_HISTORY_FILE_EXTENSION
argument_list|)
return|;
block|}
comment|/**    * Returns the jobId from a job history file name.    * @param pathString the path string.    * @return the JobId    * @throws IOException if the filename format is invalid.    */
DECL|method|getJobIDFromHistoryFilePath (String pathString)
specifier|public
specifier|static
name|JobID
name|getJobIDFromHistoryFilePath
parameter_list|(
name|String
name|pathString
parameter_list|)
throws|throws
name|IOException
block|{
name|String
index|[]
name|parts
init|=
name|pathString
operator|.
name|split
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
decl_stmt|;
name|String
name|fileNamePart
init|=
name|parts
index|[
name|parts
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
name|JobIndexInfo
name|jobIndexInfo
init|=
name|FileNameIndexUtils
operator|.
name|getIndexInfo
argument_list|(
name|fileNamePart
argument_list|)
decl_stmt|;
return|return
name|TypeConverter
operator|.
name|fromYarn
argument_list|(
name|jobIndexInfo
operator|.
name|getJobId
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Gets a PathFilter which would match configuration files.    * @return the patch filter {@link PathFilter} for matching conf files.    */
DECL|method|getConfFileFilter ()
specifier|public
specifier|static
name|PathFilter
name|getConfFileFilter
parameter_list|()
block|{
return|return
name|CONF_FILTER
return|;
block|}
comment|/**    * Gets a PathFilter which would match job history file names.    * @return the path filter {@link PathFilter} matching job history files.    */
DECL|method|getHistoryFileFilter ()
specifier|public
specifier|static
name|PathFilter
name|getHistoryFileFilter
parameter_list|()
block|{
return|return
name|JOB_HISTORY_FILE_FILTER
return|;
block|}
comment|/**    * Gets the configured directory prefix for In Progress history files.    * @param conf the configuration for hte job    * @param jobId the id of the job the history file is for.    * @return A string representation of the prefix.    */
specifier|public
specifier|static
name|String
DECL|method|getConfiguredHistoryStagingDirPrefix (Configuration conf, String jobId)
name|getConfiguredHistoryStagingDirPrefix
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|jobId
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|user
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
decl_stmt|;
name|Path
name|stagingPath
init|=
name|MRApps
operator|.
name|getStagingAreaDir
argument_list|(
name|conf
argument_list|,
name|user
argument_list|)
decl_stmt|;
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|stagingPath
argument_list|,
name|jobId
argument_list|)
decl_stmt|;
name|String
name|logDir
init|=
name|path
operator|.
name|toString
argument_list|()
decl_stmt|;
return|return
name|ensurePathInDefaultFileSystem
argument_list|(
name|logDir
argument_list|,
name|conf
argument_list|)
return|;
block|}
comment|/**    * Gets the configured directory prefix for intermediate done history files.    * @param conf    * @return A string representation of the prefix.    */
DECL|method|getConfiguredHistoryIntermediateDoneDirPrefix ( Configuration conf)
specifier|public
specifier|static
name|String
name|getConfiguredHistoryIntermediateDoneDirPrefix
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|doneDirPrefix
init|=
name|conf
operator|.
name|get
argument_list|(
name|JHAdminConfig
operator|.
name|MR_HISTORY_INTERMEDIATE_DONE_DIR
argument_list|)
decl_stmt|;
if|if
condition|(
name|doneDirPrefix
operator|==
literal|null
condition|)
block|{
name|doneDirPrefix
operator|=
name|conf
operator|.
name|get
argument_list|(
name|MRJobConfig
operator|.
name|MR_AM_STAGING_DIR
argument_list|,
name|MRJobConfig
operator|.
name|DEFAULT_MR_AM_STAGING_DIR
argument_list|)
operator|+
literal|"/history/done_intermediate"
expr_stmt|;
block|}
return|return
name|ensurePathInDefaultFileSystem
argument_list|(
name|doneDirPrefix
argument_list|,
name|conf
argument_list|)
return|;
block|}
comment|/**    * Gets the configured directory permissions for the user directories in the    * directory of the intermediate done history files. The user and the group    * both need full permissions, this is enforced by this method.    * @param conf The configuration object    * @return FsPermission of the user directories    */
specifier|public
specifier|static
name|FsPermission
DECL|method|getConfiguredHistoryIntermediateUserDoneDirPermissions ( Configuration conf)
name|getConfiguredHistoryIntermediateUserDoneDirPermissions
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|userDoneDirPermissions
init|=
name|conf
operator|.
name|get
argument_list|(
name|JHAdminConfig
operator|.
name|MR_HISTORY_INTERMEDIATE_USER_DONE_DIR_PERMISSIONS
argument_list|)
decl_stmt|;
if|if
condition|(
name|userDoneDirPermissions
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|FsPermission
argument_list|(
name|JHAdminConfig
operator|.
name|DEFAULT_MR_HISTORY_INTERMEDIATE_USER_DONE_DIR_PERMISSIONS
argument_list|)
return|;
block|}
name|FsPermission
name|permission
init|=
operator|new
name|FsPermission
argument_list|(
name|userDoneDirPermissions
argument_list|)
decl_stmt|;
if|if
condition|(
name|permission
operator|.
name|getUserAction
argument_list|()
operator|!=
name|FsAction
operator|.
name|ALL
operator|||
name|permission
operator|.
name|getGroupAction
argument_list|()
operator|!=
name|FsAction
operator|.
name|ALL
condition|)
block|{
name|permission
operator|=
operator|new
name|FsPermission
argument_list|(
name|FsAction
operator|.
name|ALL
argument_list|,
name|FsAction
operator|.
name|ALL
argument_list|,
name|permission
operator|.
name|getOtherAction
argument_list|()
argument_list|,
name|permission
operator|.
name|getStickyBit
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unsupported permission configured in "
operator|+
name|JHAdminConfig
operator|.
name|MR_HISTORY_INTERMEDIATE_USER_DONE_DIR_PERMISSIONS
operator|+
literal|", the user and the group permission must be 7 (rwx). "
operator|+
literal|"The permission was set to "
operator|+
name|permission
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|permission
return|;
block|}
comment|/**    * Gets the configured directory prefix for Done history files.    * @param conf the configuration object    * @return the done history directory    */
DECL|method|getConfiguredHistoryServerDoneDirPrefix ( Configuration conf)
specifier|public
specifier|static
name|String
name|getConfiguredHistoryServerDoneDirPrefix
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|doneDirPrefix
init|=
name|conf
operator|.
name|get
argument_list|(
name|JHAdminConfig
operator|.
name|MR_HISTORY_DONE_DIR
argument_list|)
decl_stmt|;
if|if
condition|(
name|doneDirPrefix
operator|==
literal|null
condition|)
block|{
name|doneDirPrefix
operator|=
name|conf
operator|.
name|get
argument_list|(
name|MRJobConfig
operator|.
name|MR_AM_STAGING_DIR
argument_list|,
name|MRJobConfig
operator|.
name|DEFAULT_MR_AM_STAGING_DIR
argument_list|)
operator|+
literal|"/history/done"
expr_stmt|;
block|}
return|return
name|ensurePathInDefaultFileSystem
argument_list|(
name|doneDirPrefix
argument_list|,
name|conf
argument_list|)
return|;
block|}
comment|/**    * Get default file system URI for the cluster (used to ensure consistency    * of history done/staging locations) over different context    *    * @return Default file context    */
DECL|method|getDefaultFileContext ()
specifier|private
specifier|static
name|FileContext
name|getDefaultFileContext
parameter_list|()
block|{
comment|// If FS_DEFAULT_NAME_KEY was set solely by core-default.xml then we ignore
comment|// ignore it. This prevents defaulting history paths to file system specified
comment|// by core-default.xml which would not make sense in any case. For a test
comment|// case to exploit this functionality it should create core-site.xml
name|FileContext
name|fc
init|=
literal|null
decl_stmt|;
name|Configuration
name|defaultConf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|String
index|[]
name|sources
decl_stmt|;
name|sources
operator|=
name|defaultConf
operator|.
name|getPropertySources
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|FS_DEFAULT_NAME_KEY
argument_list|)
expr_stmt|;
if|if
condition|(
name|sources
operator|!=
literal|null
operator|&&
operator|(
operator|!
name|Arrays
operator|.
name|asList
argument_list|(
name|sources
argument_list|)
operator|.
name|contains
argument_list|(
literal|"core-default.xml"
argument_list|)
operator|||
name|sources
operator|.
name|length
operator|>
literal|1
operator|)
condition|)
block|{
try|try
block|{
name|fc
operator|=
name|FileContext
operator|.
name|getFileContext
argument_list|(
name|defaultConf
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Default file system ["
operator|+
name|fc
operator|.
name|getDefaultFileSystem
argument_list|()
operator|.
name|getUri
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedFileSystemException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to create default file context ["
operator|+
name|defaultConf
operator|.
name|get
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|FS_DEFAULT_NAME_KEY
argument_list|)
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Default file system is set solely "
operator|+
literal|"by core-default.xml therefore -  ignoring"
argument_list|)
expr_stmt|;
block|}
return|return
name|fc
return|;
block|}
comment|/**    * Ensure that path belongs to cluster's default file system unless    * 1. it is already fully qualified.    * 2. current job configuration uses default file system    * 3. running from a test case without core-site.xml    *    * @param sourcePath source path    * @param conf the job configuration    * @return full qualified path (if necessary) in default file system    */
DECL|method|ensurePathInDefaultFileSystem (String sourcePath, Configuration conf)
specifier|private
specifier|static
name|String
name|ensurePathInDefaultFileSystem
parameter_list|(
name|String
name|sourcePath
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|sourcePath
argument_list|)
decl_stmt|;
name|FileContext
name|fc
init|=
name|getDefaultFileContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|fc
operator|==
literal|null
operator|||
name|fc
operator|.
name|getDefaultFileSystem
argument_list|()
operator|.
name|getUri
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|FS_DEFAULT_NAME_KEY
argument_list|,
literal|""
argument_list|)
argument_list|)
operator|||
name|path
operator|.
name|toUri
argument_list|()
operator|.
name|getAuthority
argument_list|()
operator|!=
literal|null
operator|||
name|path
operator|.
name|toUri
argument_list|()
operator|.
name|getScheme
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|sourcePath
return|;
block|}
return|return
name|fc
operator|.
name|makeQualified
argument_list|(
name|path
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Gets the user directory for intermediate done history files.    * @param conf the configuration object    * @return the intermediate done directory for jobhistory files.    */
DECL|method|getHistoryIntermediateDoneDirForUser (Configuration conf)
specifier|public
specifier|static
name|String
name|getHistoryIntermediateDoneDirForUser
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|Path
argument_list|(
name|getConfiguredHistoryIntermediateDoneDirPrefix
argument_list|(
name|conf
argument_list|)
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getShortUserName
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|shouldCreateNonUserDirectory (Configuration conf)
specifier|public
specifier|static
name|boolean
name|shouldCreateNonUserDirectory
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
comment|// Returning true by default to allow non secure single node clusters to work
comment|// without any configuration change.
return|return
name|conf
operator|.
name|getBoolean
argument_list|(
name|MRJobConfig
operator|.
name|MR_AM_CREATE_JH_INTERMEDIATE_BASE_DIR
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Get the job history file path for non Done history files.    */
DECL|method|getStagingJobHistoryFile (Path dir, JobId jobId, int attempt)
specifier|public
specifier|static
name|Path
name|getStagingJobHistoryFile
parameter_list|(
name|Path
name|dir
parameter_list|,
name|JobId
name|jobId
parameter_list|,
name|int
name|attempt
parameter_list|)
block|{
return|return
name|getStagingJobHistoryFile
argument_list|(
name|dir
argument_list|,
name|TypeConverter
operator|.
name|fromYarn
argument_list|(
name|jobId
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|attempt
argument_list|)
return|;
block|}
comment|/**    * Get the job history file path for non Done history files.    */
DECL|method|getStagingJobHistoryFile (Path dir, String jobId, int attempt)
specifier|public
specifier|static
name|Path
name|getStagingJobHistoryFile
parameter_list|(
name|Path
name|dir
parameter_list|,
name|String
name|jobId
parameter_list|,
name|int
name|attempt
parameter_list|)
block|{
return|return
operator|new
name|Path
argument_list|(
name|dir
argument_list|,
name|jobId
operator|+
literal|"_"
operator|+
name|attempt
operator|+
name|JOB_HISTORY_FILE_EXTENSION
argument_list|)
return|;
block|}
comment|/**    * Get the done configuration file name for a job.    * @param jobId the jobId.    * @return the conf file name.    */
DECL|method|getIntermediateConfFileName (JobId jobId)
specifier|public
specifier|static
name|String
name|getIntermediateConfFileName
parameter_list|(
name|JobId
name|jobId
parameter_list|)
block|{
return|return
name|TypeConverter
operator|.
name|fromYarn
argument_list|(
name|jobId
argument_list|)
operator|.
name|toString
argument_list|()
operator|+
name|CONF_FILE_NAME_SUFFIX
return|;
block|}
comment|/**    * Get the done summary file name for a job.    * @param jobId the jobId.    * @return the conf file name.    */
DECL|method|getIntermediateSummaryFileName (JobId jobId)
specifier|public
specifier|static
name|String
name|getIntermediateSummaryFileName
parameter_list|(
name|JobId
name|jobId
parameter_list|)
block|{
return|return
name|TypeConverter
operator|.
name|fromYarn
argument_list|(
name|jobId
argument_list|)
operator|.
name|toString
argument_list|()
operator|+
name|SUMMARY_FILE_NAME_SUFFIX
return|;
block|}
comment|/**    * Gets the conf file path for jobs in progress.    *     * @param logDir the log directory prefix.    * @param jobId the jobId.    * @param attempt attempt number for this job.    * @return the conf file path for jobs in progress.    */
DECL|method|getStagingConfFile (Path logDir, JobId jobId, int attempt)
specifier|public
specifier|static
name|Path
name|getStagingConfFile
parameter_list|(
name|Path
name|logDir
parameter_list|,
name|JobId
name|jobId
parameter_list|,
name|int
name|attempt
parameter_list|)
block|{
name|Path
name|jobFilePath
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|logDir
operator|!=
literal|null
condition|)
block|{
name|jobFilePath
operator|=
operator|new
name|Path
argument_list|(
name|logDir
argument_list|,
name|TypeConverter
operator|.
name|fromYarn
argument_list|(
name|jobId
argument_list|)
operator|.
name|toString
argument_list|()
operator|+
literal|"_"
operator|+
name|attempt
operator|+
name|CONF_FILE_NAME_SUFFIX
argument_list|)
expr_stmt|;
block|}
return|return
name|jobFilePath
return|;
block|}
comment|/**    * Gets the serial number part of the path based on the jobId and serialNumber format.    * @param id    * @param serialNumberFormat    * @return the serial number part of the patch based on the jobId and serial number format.    */
DECL|method|serialNumberDirectoryComponent (JobId id, String serialNumberFormat)
specifier|public
specifier|static
name|String
name|serialNumberDirectoryComponent
parameter_list|(
name|JobId
name|id
parameter_list|,
name|String
name|serialNumberFormat
parameter_list|)
block|{
return|return
name|String
operator|.
name|format
argument_list|(
name|serialNumberFormat
argument_list|,
name|Integer
operator|.
name|valueOf
argument_list|(
name|jobSerialNumber
argument_list|(
name|id
argument_list|)
argument_list|)
argument_list|)
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|SERIAL_NUMBER_DIRECTORY_DIGITS
argument_list|)
return|;
block|}
comment|/**Extracts the timstamp component from the path.    * @param path    * @return the timestamp component from the path    */
DECL|method|getTimestampPartFromPath (String path)
specifier|public
specifier|static
name|String
name|getTimestampPartFromPath
parameter_list|(
name|String
name|path
parameter_list|)
block|{
name|Matcher
name|matcher
init|=
name|TIMESTAMP_DIR_PATTERN
operator|.
name|matcher
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
name|matched
init|=
name|matcher
operator|.
name|group
argument_list|()
decl_stmt|;
name|String
name|ret
init|=
name|matched
operator|.
name|intern
argument_list|()
decl_stmt|;
return|return
name|ret
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Gets the history subdirectory based on the jobId, timestamp and serial number format.    * @param id    * @param timestampComponent    * @param serialNumberFormat    * @return the history sub directory based on the jobid, timestamp and serial number format    */
DECL|method|historyLogSubdirectory (JobId id, String timestampComponent, String serialNumberFormat)
specifier|public
specifier|static
name|String
name|historyLogSubdirectory
parameter_list|(
name|JobId
name|id
parameter_list|,
name|String
name|timestampComponent
parameter_list|,
name|String
name|serialNumberFormat
parameter_list|)
block|{
comment|//    String result = LOG_VERSION_STRING;
name|String
name|result
init|=
literal|""
decl_stmt|;
name|String
name|serialNumberDirectory
init|=
name|serialNumberDirectoryComponent
argument_list|(
name|id
argument_list|,
name|serialNumberFormat
argument_list|)
decl_stmt|;
name|result
operator|=
name|result
operator|+
name|timestampComponent
operator|+
name|File
operator|.
name|separator
operator|+
name|serialNumberDirectory
operator|+
name|File
operator|.
name|separator
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Gets the timestamp component based on millisecond time.    * @param millisecondTime    * @return the timestamp component based on millisecond time    */
DECL|method|timestampDirectoryComponent (long millisecondTime)
specifier|public
specifier|static
name|String
name|timestampDirectoryComponent
parameter_list|(
name|long
name|millisecondTime
parameter_list|)
block|{
name|Calendar
name|timestamp
init|=
name|Calendar
operator|.
name|getInstance
argument_list|()
decl_stmt|;
name|timestamp
operator|.
name|setTimeInMillis
argument_list|(
name|millisecondTime
argument_list|)
expr_stmt|;
name|String
name|dateString
init|=
literal|null
decl_stmt|;
name|dateString
operator|=
name|String
operator|.
name|format
argument_list|(
name|TIMESTAMP_DIR_FORMAT
argument_list|,
name|timestamp
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
argument_list|,
comment|// months are 0-based in Calendar, but people will expect January to
comment|// be month #1.
name|timestamp
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|MONTH
argument_list|)
operator|+
literal|1
argument_list|,
name|timestamp
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|DAY_OF_MONTH
argument_list|)
argument_list|)
expr_stmt|;
name|dateString
operator|=
name|dateString
operator|.
name|intern
argument_list|()
expr_stmt|;
return|return
name|dateString
return|;
block|}
DECL|method|doneSubdirsBeforeSerialTail ()
specifier|public
specifier|static
name|String
name|doneSubdirsBeforeSerialTail
parameter_list|()
block|{
comment|// date
name|String
name|result
init|=
literal|"/*/*/*"
decl_stmt|;
comment|// YYYY/MM/DD ;
return|return
name|result
return|;
block|}
comment|/**    * Computes a serial number used as part of directory naming for the given jobId.    * @param id the jobId.    * @return the serial number used as part of directory naming for the given jobid    */
DECL|method|jobSerialNumber (JobId id)
specifier|public
specifier|static
name|int
name|jobSerialNumber
parameter_list|(
name|JobId
name|id
parameter_list|)
block|{
return|return
name|id
operator|.
name|getId
argument_list|()
return|;
block|}
DECL|method|localGlobber (FileContext fc, Path root, String tail)
specifier|public
specifier|static
name|List
argument_list|<
name|FileStatus
argument_list|>
name|localGlobber
parameter_list|(
name|FileContext
name|fc
parameter_list|,
name|Path
name|root
parameter_list|,
name|String
name|tail
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|localGlobber
argument_list|(
name|fc
argument_list|,
name|root
argument_list|,
name|tail
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|localGlobber (FileContext fc, Path root, String tail, PathFilter filter)
specifier|public
specifier|static
name|List
argument_list|<
name|FileStatus
argument_list|>
name|localGlobber
parameter_list|(
name|FileContext
name|fc
parameter_list|,
name|Path
name|root
parameter_list|,
name|String
name|tail
parameter_list|,
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|localGlobber
argument_list|(
name|fc
argument_list|,
name|root
argument_list|,
name|tail
argument_list|,
name|filter
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|// hasMismatches is just used to return a second value if you want
comment|// one. I would have used MutableBoxedBoolean if such had been provided.
DECL|method|localGlobber (FileContext fc, Path root, String tail, PathFilter filter, AtomicBoolean hasFlatFiles)
specifier|public
specifier|static
name|List
argument_list|<
name|FileStatus
argument_list|>
name|localGlobber
parameter_list|(
name|FileContext
name|fc
parameter_list|,
name|Path
name|root
parameter_list|,
name|String
name|tail
parameter_list|,
name|PathFilter
name|filter
parameter_list|,
name|AtomicBoolean
name|hasFlatFiles
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|tail
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
return|return
operator|(
name|listFilteredStatus
argument_list|(
name|fc
argument_list|,
name|root
argument_list|,
name|filter
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|tail
operator|.
name|startsWith
argument_list|(
literal|"/*"
argument_list|)
condition|)
block|{
name|Path
index|[]
name|subdirs
init|=
name|filteredStat2Paths
argument_list|(
name|remoteIterToList
argument_list|(
name|fc
operator|.
name|listStatus
argument_list|(
name|root
argument_list|)
argument_list|)
argument_list|,
literal|true
argument_list|,
name|hasFlatFiles
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|FileStatus
argument_list|>
argument_list|>
name|subsubdirs
init|=
operator|new
name|LinkedList
argument_list|<
name|List
argument_list|<
name|FileStatus
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|subsubdirCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|subdirs
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|LinkedList
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
return|;
block|}
name|String
name|newTail
init|=
name|tail
operator|.
name|substring
argument_list|(
literal|2
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subdirs
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|subsubdirs
operator|.
name|add
argument_list|(
name|localGlobber
argument_list|(
name|fc
argument_list|,
name|subdirs
index|[
name|i
index|]
argument_list|,
name|newTail
argument_list|,
name|filter
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
comment|// subsubdirs.set(i, localGlobber(fc, subdirs[i], newTail, filter,
comment|// null));
name|subsubdirCount
operator|+=
name|subsubdirs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|List
argument_list|<
name|FileStatus
argument_list|>
name|result
init|=
operator|new
name|LinkedList
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|subsubdirs
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|result
operator|.
name|addAll
argument_list|(
name|subsubdirs
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
if|if
condition|(
name|tail
operator|.
name|startsWith
argument_list|(
literal|"/"
argument_list|)
condition|)
block|{
name|int
name|split
init|=
name|tail
operator|.
name|indexOf
argument_list|(
literal|'/'
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|split
operator|<
literal|0
condition|)
block|{
return|return
name|listFilteredStatus
argument_list|(
name|fc
argument_list|,
operator|new
name|Path
argument_list|(
name|root
argument_list|,
name|tail
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|filter
argument_list|)
return|;
block|}
else|else
block|{
name|String
name|thisSegment
init|=
name|tail
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|split
argument_list|)
decl_stmt|;
name|String
name|newTail
init|=
name|tail
operator|.
name|substring
argument_list|(
name|split
argument_list|)
decl_stmt|;
return|return
name|localGlobber
argument_list|(
name|fc
argument_list|,
operator|new
name|Path
argument_list|(
name|root
argument_list|,
name|thisSegment
argument_list|)
argument_list|,
name|newTail
argument_list|,
name|filter
argument_list|,
name|hasFlatFiles
argument_list|)
return|;
block|}
block|}
name|IOException
name|e
init|=
operator|new
name|IOException
argument_list|(
literal|"localGlobber: bad tail"
argument_list|)
decl_stmt|;
throw|throw
name|e
throw|;
block|}
DECL|method|listFilteredStatus (FileContext fc, Path root, PathFilter filter)
specifier|private
specifier|static
name|List
argument_list|<
name|FileStatus
argument_list|>
name|listFilteredStatus
parameter_list|(
name|FileContext
name|fc
parameter_list|,
name|Path
name|root
parameter_list|,
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|FileStatus
argument_list|>
name|fsList
init|=
name|remoteIterToList
argument_list|(
name|fc
operator|.
name|listStatus
argument_list|(
name|root
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|filter
operator|==
literal|null
condition|)
block|{
return|return
name|fsList
return|;
block|}
else|else
block|{
name|List
argument_list|<
name|FileStatus
argument_list|>
name|filteredList
init|=
operator|new
name|LinkedList
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|FileStatus
name|fs
range|:
name|fsList
control|)
block|{
if|if
condition|(
name|filter
operator|.
name|accept
argument_list|(
name|fs
operator|.
name|getPath
argument_list|()
argument_list|)
condition|)
block|{
name|filteredList
operator|.
name|add
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|filteredList
return|;
block|}
block|}
DECL|method|remoteIterToList ( RemoteIterator<FileStatus> rIter)
specifier|private
specifier|static
name|List
argument_list|<
name|FileStatus
argument_list|>
name|remoteIterToList
parameter_list|(
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|rIter
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|FileStatus
argument_list|>
name|fsList
init|=
operator|new
name|LinkedList
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|rIter
operator|==
literal|null
condition|)
return|return
name|fsList
return|;
while|while
condition|(
name|rIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|fsList
operator|.
name|add
argument_list|(
name|rIter
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|fsList
return|;
block|}
comment|// hasMismatches is just used to return a second value if you want
comment|// one. I would have used MutableBoxedBoolean if such had been provided.
DECL|method|filteredStat2Paths (List<FileStatus> stats, boolean dirs, AtomicBoolean hasMismatches)
specifier|private
specifier|static
name|Path
index|[]
name|filteredStat2Paths
parameter_list|(
name|List
argument_list|<
name|FileStatus
argument_list|>
name|stats
parameter_list|,
name|boolean
name|dirs
parameter_list|,
name|AtomicBoolean
name|hasMismatches
parameter_list|)
block|{
name|int
name|resultCount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hasMismatches
operator|==
literal|null
condition|)
block|{
name|hasMismatches
operator|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stats
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|stats
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|isDirectory
argument_list|()
operator|==
name|dirs
condition|)
block|{
name|stats
operator|.
name|set
argument_list|(
name|resultCount
operator|++
argument_list|,
name|stats
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hasMismatches
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
name|Path
index|[]
name|result
init|=
operator|new
name|Path
index|[
name|resultCount
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|resultCount
condition|;
name|i
operator|++
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
name|stats
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getPath
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|getPreviousJobHistoryPath ( Configuration conf, ApplicationAttemptId applicationAttemptId)
specifier|public
specifier|static
name|Path
name|getPreviousJobHistoryPath
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|ApplicationAttemptId
name|applicationAttemptId
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|jobId
init|=
name|TypeConverter
operator|.
name|fromYarn
argument_list|(
name|applicationAttemptId
operator|.
name|getApplicationId
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|String
name|jobhistoryDir
init|=
name|JobHistoryUtils
operator|.
name|getConfiguredHistoryStagingDirPrefix
argument_list|(
name|conf
argument_list|,
name|jobId
argument_list|)
decl_stmt|;
name|Path
name|histDirPath
init|=
name|FileContext
operator|.
name|getFileContext
argument_list|(
name|conf
argument_list|)
operator|.
name|makeQualified
argument_list|(
operator|new
name|Path
argument_list|(
name|jobhistoryDir
argument_list|)
argument_list|)
decl_stmt|;
name|FileContext
name|fc
init|=
name|FileContext
operator|.
name|getFileContext
argument_list|(
name|histDirPath
operator|.
name|toUri
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
return|return
name|fc
operator|.
name|makeQualified
argument_list|(
name|JobHistoryUtils
operator|.
name|getStagingJobHistoryFile
argument_list|(
name|histDirPath
argument_list|,
name|jobId
argument_list|,
operator|(
name|applicationAttemptId
operator|.
name|getAttemptId
argument_list|()
operator|-
literal|1
operator|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Looks for the dirs to clean.  The folder structure is YYYY/MM/DD/Serial so    * we can use that to more efficiently find the directories to clean by    * comparing the cutoff timestamp with the timestamp from the folder    * structure.    *    * @param fc done dir FileContext    * @param root folder for completed jobs    * @param cutoff The cutoff for the max history age    * @return The list of directories for cleaning    * @throws IOException    */
DECL|method|getHistoryDirsForCleaning (FileContext fc, Path root, long cutoff)
specifier|public
specifier|static
name|List
argument_list|<
name|FileStatus
argument_list|>
name|getHistoryDirsForCleaning
parameter_list|(
name|FileContext
name|fc
parameter_list|,
name|Path
name|root
parameter_list|,
name|long
name|cutoff
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|FileStatus
argument_list|>
name|fsList
init|=
operator|new
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
decl_stmt|;
name|Calendar
name|cCal
init|=
name|Calendar
operator|.
name|getInstance
argument_list|()
decl_stmt|;
name|cCal
operator|.
name|setTimeInMillis
argument_list|(
name|cutoff
argument_list|)
expr_stmt|;
name|int
name|cYear
init|=
name|cCal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|YEAR
argument_list|)
decl_stmt|;
name|int
name|cMonth
init|=
name|cCal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|MONTH
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|cDate
init|=
name|cCal
operator|.
name|get
argument_list|(
name|Calendar
operator|.
name|DATE
argument_list|)
decl_stmt|;
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|yearDirIt
init|=
name|fc
operator|.
name|listStatus
argument_list|(
name|root
argument_list|)
decl_stmt|;
while|while
condition|(
name|yearDirIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|FileStatus
name|yearDir
init|=
name|yearDirIt
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|year
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|yearDir
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|year
operator|<=
name|cYear
condition|)
block|{
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|monthDirIt
init|=
name|fc
operator|.
name|listStatus
argument_list|(
name|yearDir
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|monthDirIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|FileStatus
name|monthDir
init|=
name|monthDirIt
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|month
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|monthDir
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|// If we only checked the month here, then something like 07/2013
comment|// would incorrectly not pass when the cutoff is 06/2014
if|if
condition|(
name|year
operator|<
name|cYear
operator|||
name|month
operator|<=
name|cMonth
condition|)
block|{
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|dateDirIt
init|=
name|fc
operator|.
name|listStatus
argument_list|(
name|monthDir
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|dateDirIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|FileStatus
name|dateDir
init|=
name|dateDirIt
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|date
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|dateDir
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|// If we only checked the date here, then something like
comment|// 07/21/2013 would incorrectly not pass when the cutoff is
comment|// 08/20/2013 or 07/20/2012
if|if
condition|(
name|year
operator|<
name|cYear
operator|||
name|month
operator|<
name|cMonth
operator|||
name|date
operator|<=
name|cDate
condition|)
block|{
name|fsList
operator|.
name|addAll
argument_list|(
name|remoteIterToList
argument_list|(
name|fc
operator|.
name|listStatus
argument_list|(
name|dateDir
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
comment|// the directory didn't fit the format we're looking for so
comment|// skip the dir
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
comment|// the directory didn't fit the format we're looking for so skip
comment|// the dir
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
comment|// the directory didn't fit the format we're looking for so skip the dir
block|}
block|}
return|return
name|fsList
return|;
block|}
block|}
end_class

end_unit

