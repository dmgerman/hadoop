begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapreduce.v2.hs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|v2
operator|.
name|hs
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|ConnectException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentSkipListMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|LinkedBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|UnsupportedFileSystemException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsServerConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RetriableException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobACLsManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|jobhistory
operator|.
name|JobSummary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|v2
operator|.
name|api
operator|.
name|records
operator|.
name|JobId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|v2
operator|.
name|app
operator|.
name|job
operator|.
name|Job
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|v2
operator|.
name|jobhistory
operator|.
name|FileNameIndexUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|v2
operator|.
name|jobhistory
operator|.
name|JHAdminConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|v2
operator|.
name|jobhistory
operator|.
name|JobHistoryUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|v2
operator|.
name|jobhistory
operator|.
name|JobIndexInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|AbstractService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ShutdownThreadsHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|concurrent
operator|.
name|HadoopThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnRuntimeException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|Clock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|SystemClock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * This class provides a way to interact with history files in a thread safe  * manor.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|HistoryFileManager
specifier|public
class|class
name|HistoryFileManager
extends|extends
name|AbstractService
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|HistoryFileManager
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|SUMMARY_LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|SUMMARY_LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|JobSummary
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|enum|HistoryInfoState
specifier|private
enum|enum
name|HistoryInfoState
block|{
DECL|enumConstant|IN_INTERMEDIATE
DECL|enumConstant|IN_DONE
DECL|enumConstant|DELETED
DECL|enumConstant|MOVE_FAILED
name|IN_INTERMEDIATE
block|,
name|IN_DONE
block|,
name|DELETED
block|,
name|MOVE_FAILED
block|}
empty_stmt|;
DECL|field|DONE_BEFORE_SERIAL_TAIL
specifier|private
specifier|static
name|String
name|DONE_BEFORE_SERIAL_TAIL
init|=
name|JobHistoryUtils
operator|.
name|doneSubdirsBeforeSerialTail
argument_list|()
decl_stmt|;
comment|/**    * Maps between a serial number (generated based on jobId) and the timestamp    * component(s) to which it belongs. Facilitates jobId based searches. If a    * jobId is not found in this list - it will not be found.    */
DECL|class|SerialNumberIndex
specifier|private
specifier|static
class|class
name|SerialNumberIndex
block|{
DECL|field|cache
specifier|private
name|SortedMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|cache
decl_stmt|;
DECL|field|maxSize
specifier|private
name|int
name|maxSize
decl_stmt|;
DECL|method|SerialNumberIndex (int maxSize)
specifier|public
name|SerialNumberIndex
parameter_list|(
name|int
name|maxSize
parameter_list|)
block|{
name|this
operator|.
name|cache
operator|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxSize
operator|=
name|maxSize
expr_stmt|;
block|}
DECL|method|add (String serialPart, String timestampPart)
specifier|public
specifier|synchronized
name|void
name|add
parameter_list|(
name|String
name|serialPart
parameter_list|,
name|String
name|timestampPart
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cache
operator|.
name|containsKey
argument_list|(
name|serialPart
argument_list|)
condition|)
block|{
name|cache
operator|.
name|put
argument_list|(
name|serialPart
argument_list|,
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|.
name|size
argument_list|()
operator|>
name|maxSize
condition|)
block|{
name|String
name|key
init|=
name|cache
operator|.
name|firstKey
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Dropping "
operator|+
name|key
operator|+
literal|" from the SerialNumberIndex. We will no "
operator|+
literal|"longer be able to see jobs that are in that serial index for "
operator|+
name|cache
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|cache
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|datePartSet
init|=
name|cache
operator|.
name|get
argument_list|(
name|serialPart
argument_list|)
decl_stmt|;
name|datePartSet
operator|.
name|add
argument_list|(
name|timestampPart
argument_list|)
expr_stmt|;
block|}
DECL|method|remove (String serialPart, String timeStampPart)
specifier|public
specifier|synchronized
name|void
name|remove
parameter_list|(
name|String
name|serialPart
parameter_list|,
name|String
name|timeStampPart
parameter_list|)
block|{
if|if
condition|(
name|cache
operator|.
name|containsKey
argument_list|(
name|serialPart
argument_list|)
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|set
init|=
name|cache
operator|.
name|get
argument_list|(
name|serialPart
argument_list|)
decl_stmt|;
name|set
operator|.
name|remove
argument_list|(
name|timeStampPart
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|cache
operator|.
name|remove
argument_list|(
name|serialPart
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|get (String serialPart)
specifier|public
specifier|synchronized
name|Set
argument_list|<
name|String
argument_list|>
name|get
parameter_list|(
name|String
name|serialPart
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|found
init|=
name|cache
operator|.
name|get
argument_list|(
name|serialPart
argument_list|)
decl_stmt|;
if|if
condition|(
name|found
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|found
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/**    * Wrapper around {@link ConcurrentSkipListMap} that maintains size along    * side for O(1) size() implementation for use in JobListCache.    *    * Note: The size is not updated atomically with changes additions/removals.    * This race can lead to size() returning an incorrect size at times.    */
DECL|class|JobIdHistoryFileInfoMap
specifier|static
class|class
name|JobIdHistoryFileInfoMap
block|{
DECL|field|cache
specifier|private
name|ConcurrentSkipListMap
argument_list|<
name|JobId
argument_list|,
name|HistoryFileInfo
argument_list|>
name|cache
decl_stmt|;
DECL|field|mapSize
specifier|private
name|AtomicInteger
name|mapSize
decl_stmt|;
DECL|method|JobIdHistoryFileInfoMap ()
name|JobIdHistoryFileInfoMap
parameter_list|()
block|{
name|cache
operator|=
operator|new
name|ConcurrentSkipListMap
argument_list|<
name|JobId
argument_list|,
name|HistoryFileInfo
argument_list|>
argument_list|()
expr_stmt|;
name|mapSize
operator|=
operator|new
name|AtomicInteger
argument_list|()
expr_stmt|;
block|}
DECL|method|putIfAbsent (JobId key, HistoryFileInfo value)
specifier|public
name|HistoryFileInfo
name|putIfAbsent
parameter_list|(
name|JobId
name|key
parameter_list|,
name|HistoryFileInfo
name|value
parameter_list|)
block|{
name|HistoryFileInfo
name|ret
init|=
name|cache
operator|.
name|putIfAbsent
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|null
condition|)
block|{
name|mapSize
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
DECL|method|remove (JobId key)
specifier|public
name|HistoryFileInfo
name|remove
parameter_list|(
name|JobId
name|key
parameter_list|)
block|{
name|HistoryFileInfo
name|ret
init|=
name|cache
operator|.
name|remove
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|null
condition|)
block|{
name|mapSize
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**      * Returns the recorded size of the internal map. Note that this could be out      * of sync with the actual size of the map      * @return "recorded" size      */
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|mapSize
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|get (JobId key)
specifier|public
name|HistoryFileInfo
name|get
parameter_list|(
name|JobId
name|key
parameter_list|)
block|{
return|return
name|cache
operator|.
name|get
argument_list|(
name|key
argument_list|)
return|;
block|}
DECL|method|navigableKeySet ()
specifier|public
name|NavigableSet
argument_list|<
name|JobId
argument_list|>
name|navigableKeySet
parameter_list|()
block|{
return|return
name|cache
operator|.
name|navigableKeySet
argument_list|()
return|;
block|}
DECL|method|values ()
specifier|public
name|Collection
argument_list|<
name|HistoryFileInfo
argument_list|>
name|values
parameter_list|()
block|{
return|return
name|cache
operator|.
name|values
argument_list|()
return|;
block|}
block|}
DECL|class|JobListCache
specifier|static
class|class
name|JobListCache
block|{
DECL|field|cache
specifier|private
name|JobIdHistoryFileInfoMap
name|cache
decl_stmt|;
DECL|field|maxSize
specifier|private
name|int
name|maxSize
decl_stmt|;
DECL|field|maxAge
specifier|private
name|long
name|maxAge
decl_stmt|;
DECL|method|JobListCache (int maxSize, long maxAge)
specifier|public
name|JobListCache
parameter_list|(
name|int
name|maxSize
parameter_list|,
name|long
name|maxAge
parameter_list|)
block|{
name|this
operator|.
name|maxSize
operator|=
name|maxSize
expr_stmt|;
name|this
operator|.
name|maxAge
operator|=
name|maxAge
expr_stmt|;
name|this
operator|.
name|cache
operator|=
operator|new
name|JobIdHistoryFileInfoMap
argument_list|()
expr_stmt|;
block|}
DECL|method|addIfAbsent (HistoryFileInfo fileInfo)
specifier|public
name|HistoryFileInfo
name|addIfAbsent
parameter_list|(
name|HistoryFileInfo
name|fileInfo
parameter_list|)
block|{
name|JobId
name|jobId
init|=
name|fileInfo
operator|.
name|getJobId
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding "
operator|+
name|jobId
operator|+
literal|" to job list cache with "
operator|+
name|fileInfo
operator|.
name|getJobIndexInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|HistoryFileInfo
name|old
init|=
name|cache
operator|.
name|putIfAbsent
argument_list|(
name|jobId
argument_list|,
name|fileInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|cache
operator|.
name|size
argument_list|()
operator|>
name|maxSize
condition|)
block|{
comment|//There is a race here, where more then one thread could be trying to
comment|// remove entries.  This could result in too many entries being removed
comment|// from the cache.  This is considered OK as the size of the cache
comment|// should be rather large, and we would rather have performance over
comment|// keeping the cache size exactly at the maximum.
name|Iterator
argument_list|<
name|JobId
argument_list|>
name|keys
init|=
name|cache
operator|.
name|navigableKeySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|long
name|cutoff
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|maxAge
decl_stmt|;
comment|// MAPREDUCE-6436: In order to reduce the number of logs written
comment|// in case of a lot of move pending histories.
name|JobId
name|firstInIntermediateKey
init|=
literal|null
decl_stmt|;
name|int
name|inIntermediateCount
init|=
literal|0
decl_stmt|;
name|JobId
name|firstMoveFailedKey
init|=
literal|null
decl_stmt|;
name|int
name|moveFailedCount
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|cache
operator|.
name|size
argument_list|()
operator|>
name|maxSize
operator|&&
name|keys
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|JobId
name|key
init|=
name|keys
operator|.
name|next
argument_list|()
decl_stmt|;
name|HistoryFileInfo
name|firstValue
init|=
name|cache
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|firstValue
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|firstValue
operator|.
name|isMovePending
argument_list|()
condition|)
block|{
if|if
condition|(
name|firstValue
operator|.
name|didMoveFail
argument_list|()
operator|&&
name|firstValue
operator|.
name|jobIndexInfo
operator|.
name|getFinishTime
argument_list|()
operator|<=
name|cutoff
condition|)
block|{
name|cache
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
comment|// Now lets try to delete it
try|try
block|{
name|firstValue
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error while trying to delete history files"
operator|+
literal|" that could not be moved to done."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|firstValue
operator|.
name|didMoveFail
argument_list|()
condition|)
block|{
if|if
condition|(
name|moveFailedCount
operator|==
literal|0
condition|)
block|{
name|firstMoveFailedKey
operator|=
name|key
expr_stmt|;
block|}
name|moveFailedCount
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inIntermediateCount
operator|==
literal|0
condition|)
block|{
name|firstInIntermediateKey
operator|=
name|key
expr_stmt|;
block|}
name|inIntermediateCount
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|cache
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Log output only for first jobhisotry in pendings to restrict
comment|// the total number of logs.
if|if
condition|(
name|inIntermediateCount
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Waiting to remove IN_INTERMEDIATE state histories "
operator|+
literal|"(e.g. "
operator|+
name|firstInIntermediateKey
operator|+
literal|") from JobListCache "
operator|+
literal|"because it is not in done yet. Total count is "
operator|+
name|inIntermediateCount
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|moveFailedCount
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Waiting to remove MOVE_FAILED state histories "
operator|+
literal|"(e.g. "
operator|+
name|firstMoveFailedKey
operator|+
literal|") from JobListCache "
operator|+
literal|"because it is not in done yet. Total count is "
operator|+
name|moveFailedCount
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|old
return|;
block|}
DECL|method|delete (HistoryFileInfo fileInfo)
specifier|public
name|void
name|delete
parameter_list|(
name|HistoryFileInfo
name|fileInfo
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing from cache "
operator|+
name|fileInfo
argument_list|)
expr_stmt|;
block|}
name|cache
operator|.
name|remove
argument_list|(
name|fileInfo
operator|.
name|getJobId
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|values ()
specifier|public
name|Collection
argument_list|<
name|HistoryFileInfo
argument_list|>
name|values
parameter_list|()
block|{
return|return
operator|new
name|ArrayList
argument_list|<
name|HistoryFileInfo
argument_list|>
argument_list|(
name|cache
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
DECL|method|get (JobId jobId)
specifier|public
name|HistoryFileInfo
name|get
parameter_list|(
name|JobId
name|jobId
parameter_list|)
block|{
return|return
name|cache
operator|.
name|get
argument_list|(
name|jobId
argument_list|)
return|;
block|}
DECL|method|isFull ()
specifier|public
name|boolean
name|isFull
parameter_list|()
block|{
return|return
name|cache
operator|.
name|size
argument_list|()
operator|>=
name|maxSize
return|;
block|}
DECL|method|size ()
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|cache
operator|.
name|size
argument_list|()
return|;
block|}
block|}
comment|/**    * This class represents a user dir in the intermediate done directory.  This    * is mostly for locking purposes.     */
DECL|class|UserLogDir
specifier|private
class|class
name|UserLogDir
block|{
DECL|field|modTime
name|long
name|modTime
init|=
literal|0
decl_stmt|;
DECL|field|scanTime
specifier|private
name|long
name|scanTime
init|=
literal|0
decl_stmt|;
DECL|method|scanIfNeeded (FileStatus fs)
specifier|public
specifier|synchronized
name|void
name|scanIfNeeded
parameter_list|(
name|FileStatus
name|fs
parameter_list|)
block|{
name|long
name|newModTime
init|=
name|fs
operator|.
name|getModificationTime
argument_list|()
decl_stmt|;
comment|// MAPREDUCE-6680: In some Cloud FileSystem, like Azure FS or S3, file's
comment|// modification time is truncated into seconds. In that case,
comment|// modTime == newModTime doesn't means no file update in the directory,
comment|// so we need to have additional check.
comment|// Note: modTime (X second Y millisecond) could be casted to X second or
comment|// X+1 second.
if|if
condition|(
name|modTime
operator|!=
name|newModTime
operator|||
operator|(
name|scanTime
operator|/
literal|1000
operator|)
operator|==
operator|(
name|modTime
operator|/
literal|1000
operator|)
operator|||
operator|(
name|scanTime
operator|/
literal|1000
operator|+
literal|1
operator|)
operator|==
operator|(
name|modTime
operator|/
literal|1000
operator|)
condition|)
block|{
comment|// reset scanTime before scanning happens
name|scanTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|Path
name|p
init|=
name|fs
operator|.
name|getPath
argument_list|()
decl_stmt|;
try|try
block|{
name|scanIntermediateDirectory
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|//If scanning fails, we will scan again.  We assume the failure is
comment|// temporary.
name|modTime
operator|=
name|newModTime
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error while trying to scan the directory "
operator|+
name|p
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Scan not needed of "
operator|+
name|fs
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// reset scanTime
name|scanTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|class|HistoryFileInfo
specifier|public
class|class
name|HistoryFileInfo
block|{
DECL|field|historyFile
specifier|private
name|Path
name|historyFile
decl_stmt|;
DECL|field|confFile
specifier|private
name|Path
name|confFile
decl_stmt|;
DECL|field|summaryFile
specifier|private
name|Path
name|summaryFile
decl_stmt|;
DECL|field|jobIndexInfo
specifier|private
name|JobIndexInfo
name|jobIndexInfo
decl_stmt|;
DECL|field|state
specifier|private
specifier|volatile
name|HistoryInfoState
name|state
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|method|HistoryFileInfo (Path historyFile, Path confFile, Path summaryFile, JobIndexInfo jobIndexInfo, boolean isInDone)
specifier|protected
name|HistoryFileInfo
parameter_list|(
name|Path
name|historyFile
parameter_list|,
name|Path
name|confFile
parameter_list|,
name|Path
name|summaryFile
parameter_list|,
name|JobIndexInfo
name|jobIndexInfo
parameter_list|,
name|boolean
name|isInDone
parameter_list|)
block|{
name|this
operator|.
name|historyFile
operator|=
name|historyFile
expr_stmt|;
name|this
operator|.
name|confFile
operator|=
name|confFile
expr_stmt|;
name|this
operator|.
name|summaryFile
operator|=
name|summaryFile
expr_stmt|;
name|this
operator|.
name|jobIndexInfo
operator|=
name|jobIndexInfo
expr_stmt|;
name|state
operator|=
name|isInDone
condition|?
name|HistoryInfoState
operator|.
name|IN_DONE
else|:
name|HistoryInfoState
operator|.
name|IN_INTERMEDIATE
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|isMovePending ()
name|boolean
name|isMovePending
parameter_list|()
block|{
return|return
name|state
operator|==
name|HistoryInfoState
operator|.
name|IN_INTERMEDIATE
operator|||
name|state
operator|==
name|HistoryInfoState
operator|.
name|MOVE_FAILED
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|didMoveFail ()
name|boolean
name|didMoveFail
parameter_list|()
block|{
return|return
name|state
operator|==
name|HistoryInfoState
operator|.
name|MOVE_FAILED
return|;
block|}
comment|/**      * @return true if the files backed by this were deleted.      */
DECL|method|isDeleted ()
specifier|public
name|boolean
name|isDeleted
parameter_list|()
block|{
return|return
name|state
operator|==
name|HistoryInfoState
operator|.
name|DELETED
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"HistoryFileInfo jobID "
operator|+
name|getJobId
argument_list|()
operator|+
literal|" historyFile = "
operator|+
name|historyFile
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|moveToDone ()
specifier|synchronized
name|void
name|moveToDone
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"moveToDone: "
operator|+
name|historyFile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isMovePending
argument_list|()
condition|)
block|{
comment|// It was either deleted or is already in done. Either way do nothing
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Move no longer pending"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
try|try
block|{
name|long
name|completeTime
init|=
name|jobIndexInfo
operator|.
name|getFinishTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|completeTime
operator|==
literal|0
condition|)
block|{
name|completeTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
name|JobId
name|jobId
init|=
name|jobIndexInfo
operator|.
name|getJobId
argument_list|()
decl_stmt|;
if|if
condition|(
name|historyFile
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No file for job-history with "
operator|+
name|jobId
operator|+
literal|" found in cache!"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|confFile
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No file for jobConf with "
operator|+
name|jobId
operator|+
literal|" found in cache!"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|summaryFile
operator|==
literal|null
operator|||
operator|!
name|intermediateDoneDirFc
operator|.
name|util
argument_list|()
operator|.
name|exists
argument_list|(
name|summaryFile
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No summary file for job: "
operator|+
name|jobId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|jobSummaryString
init|=
name|getJobSummary
argument_list|(
name|intermediateDoneDirFc
argument_list|,
name|summaryFile
argument_list|)
decl_stmt|;
name|SUMMARY_LOG
operator|.
name|info
argument_list|(
name|jobSummaryString
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleting JobSummary file: ["
operator|+
name|summaryFile
operator|+
literal|"]"
argument_list|)
expr_stmt|;
name|intermediateDoneDirFc
operator|.
name|delete
argument_list|(
name|summaryFile
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|summaryFile
operator|=
literal|null
expr_stmt|;
block|}
name|Path
name|targetDir
init|=
name|canonicalHistoryLogPath
argument_list|(
name|jobId
argument_list|,
name|completeTime
argument_list|)
decl_stmt|;
name|addDirectoryToSerialNumberIndex
argument_list|(
name|targetDir
argument_list|)
expr_stmt|;
name|makeDoneSubdir
argument_list|(
name|targetDir
argument_list|)
expr_stmt|;
if|if
condition|(
name|historyFile
operator|!=
literal|null
condition|)
block|{
name|Path
name|toPath
init|=
name|doneDirFc
operator|.
name|makeQualified
argument_list|(
operator|new
name|Path
argument_list|(
name|targetDir
argument_list|,
name|historyFile
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|toPath
operator|.
name|equals
argument_list|(
name|historyFile
argument_list|)
condition|)
block|{
name|moveToDoneNow
argument_list|(
name|historyFile
argument_list|,
name|toPath
argument_list|)
expr_stmt|;
name|historyFile
operator|=
name|toPath
expr_stmt|;
block|}
block|}
if|if
condition|(
name|confFile
operator|!=
literal|null
condition|)
block|{
name|Path
name|toPath
init|=
name|doneDirFc
operator|.
name|makeQualified
argument_list|(
operator|new
name|Path
argument_list|(
name|targetDir
argument_list|,
name|confFile
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|toPath
operator|.
name|equals
argument_list|(
name|confFile
argument_list|)
condition|)
block|{
name|moveToDoneNow
argument_list|(
name|confFile
argument_list|,
name|toPath
argument_list|)
expr_stmt|;
name|confFile
operator|=
name|toPath
expr_stmt|;
block|}
block|}
name|state
operator|=
name|HistoryInfoState
operator|.
name|IN_DONE
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error while trying to move a job to done"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|HistoryInfoState
operator|.
name|MOVE_FAILED
expr_stmt|;
block|}
finally|finally
block|{
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Parse a job from the JobHistoryFile, if the underlying file is not going      * to be deleted and the number of tasks associated with the job is not      * greater than maxTasksForLoadedJob.      *       * @return null if the underlying job history file was deleted, or      *         an {@link UnparsedJob} object representing a partially parsed job      *           if the job tasks exceeds the configured maximum, or      *         a {@link CompletedJob} representing a fully parsed job.      * @throws IOException      *           if there is an error trying to read the file if parsed.      */
DECL|method|loadJob ()
specifier|public
specifier|synchronized
name|Job
name|loadJob
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|isOversized
argument_list|()
condition|)
block|{
return|return
operator|new
name|UnparsedJob
argument_list|(
name|maxTasksForLoadedJob
argument_list|,
name|jobIndexInfo
argument_list|,
name|this
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|CompletedJob
argument_list|(
name|conf
argument_list|,
name|jobIndexInfo
operator|.
name|getJobId
argument_list|()
argument_list|,
name|historyFile
argument_list|,
literal|false
argument_list|,
name|jobIndexInfo
operator|.
name|getUser
argument_list|()
argument_list|,
name|this
argument_list|,
name|aclsMgr
argument_list|)
return|;
block|}
block|}
comment|/**      * Return the history file.      * @return the history file.      */
DECL|method|getHistoryFile ()
specifier|public
specifier|synchronized
name|Path
name|getHistoryFile
parameter_list|()
block|{
return|return
name|historyFile
return|;
block|}
DECL|method|delete ()
specifier|protected
specifier|synchronized
name|void
name|delete
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"deleting "
operator|+
name|historyFile
operator|+
literal|" and "
operator|+
name|confFile
argument_list|)
expr_stmt|;
block|}
name|state
operator|=
name|HistoryInfoState
operator|.
name|DELETED
expr_stmt|;
name|doneDirFc
operator|.
name|delete
argument_list|(
name|doneDirFc
operator|.
name|makeQualified
argument_list|(
name|historyFile
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|doneDirFc
operator|.
name|delete
argument_list|(
name|doneDirFc
operator|.
name|makeQualified
argument_list|(
name|confFile
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getJobIndexInfo ()
specifier|public
name|JobIndexInfo
name|getJobIndexInfo
parameter_list|()
block|{
return|return
name|jobIndexInfo
return|;
block|}
DECL|method|getJobId ()
specifier|public
name|JobId
name|getJobId
parameter_list|()
block|{
return|return
name|jobIndexInfo
operator|.
name|getJobId
argument_list|()
return|;
block|}
DECL|method|getConfFile ()
specifier|public
specifier|synchronized
name|Path
name|getConfFile
parameter_list|()
block|{
return|return
name|confFile
return|;
block|}
DECL|method|loadConfFile ()
specifier|public
specifier|synchronized
name|Configuration
name|loadConfFile
parameter_list|()
throws|throws
name|IOException
block|{
name|FileContext
name|fc
init|=
name|FileContext
operator|.
name|getFileContext
argument_list|(
name|confFile
operator|.
name|toUri
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|Configuration
name|jobConf
init|=
operator|new
name|Configuration
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|jobConf
operator|.
name|addResource
argument_list|(
name|fc
operator|.
name|open
argument_list|(
name|confFile
argument_list|)
argument_list|,
name|confFile
operator|.
name|toString
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|jobConf
return|;
block|}
DECL|method|isOversized ()
specifier|private
name|boolean
name|isOversized
parameter_list|()
block|{
specifier|final
name|int
name|totalTasks
init|=
name|jobIndexInfo
operator|.
name|getNumReduces
argument_list|()
operator|+
name|jobIndexInfo
operator|.
name|getNumMaps
argument_list|()
decl_stmt|;
return|return
operator|(
name|maxTasksForLoadedJob
operator|>
literal|0
operator|)
operator|&&
operator|(
name|totalTasks
operator|>
name|maxTasksForLoadedJob
operator|)
return|;
block|}
DECL|method|waitUntilMoved ()
specifier|public
specifier|synchronized
name|void
name|waitUntilMoved
parameter_list|()
block|{
while|while
condition|(
name|isMovePending
argument_list|()
operator|&&
operator|!
name|didMoveFail
argument_list|()
condition|)
block|{
try|try
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Waiting has been interrupted"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
DECL|field|serialNumberIndex
specifier|private
name|SerialNumberIndex
name|serialNumberIndex
init|=
literal|null
decl_stmt|;
DECL|field|jobListCache
specifier|protected
name|JobListCache
name|jobListCache
init|=
literal|null
decl_stmt|;
comment|// Maintains a list of known done subdirectories.
DECL|field|existingDoneSubdirs
specifier|private
specifier|final
name|Set
argument_list|<
name|Path
argument_list|>
name|existingDoneSubdirs
init|=
name|Collections
operator|.
name|synchronizedSet
argument_list|(
operator|new
name|HashSet
argument_list|<
name|Path
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|/**    * Maintains a mapping between intermediate user directories and the last    * known modification time.    */
DECL|field|userDirModificationTimeMap
specifier|private
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|UserLogDir
argument_list|>
name|userDirModificationTimeMap
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|String
argument_list|,
name|UserLogDir
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|aclsMgr
specifier|private
name|JobACLsManager
name|aclsMgr
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|conf
name|Configuration
name|conf
decl_stmt|;
DECL|field|serialNumberFormat
specifier|private
name|String
name|serialNumberFormat
decl_stmt|;
DECL|field|doneDirPrefixPath
specifier|private
name|Path
name|doneDirPrefixPath
init|=
literal|null
decl_stmt|;
comment|// folder for completed jobs
DECL|field|doneDirFc
specifier|private
name|FileContext
name|doneDirFc
decl_stmt|;
comment|// done Dir FileContext
DECL|field|intermediateDoneDirPath
specifier|private
name|Path
name|intermediateDoneDirPath
init|=
literal|null
decl_stmt|;
comment|// Intermediate Done Dir Path
DECL|field|intermediateDoneDirFc
specifier|private
name|FileContext
name|intermediateDoneDirFc
decl_stmt|;
comment|// Intermediate Done Dir
comment|// FileContext
annotation|@
name|VisibleForTesting
DECL|field|moveToDoneExecutor
specifier|protected
name|ThreadPoolExecutor
name|moveToDoneExecutor
init|=
literal|null
decl_stmt|;
DECL|field|maxHistoryAge
specifier|private
name|long
name|maxHistoryAge
init|=
literal|0
decl_stmt|;
comment|/**    * The maximum number of tasks allowed for a job to be loaded.    */
DECL|field|maxTasksForLoadedJob
specifier|private
name|int
name|maxTasksForLoadedJob
init|=
operator|-
literal|1
decl_stmt|;
DECL|method|HistoryFileManager ()
specifier|public
name|HistoryFileManager
parameter_list|()
block|{
name|super
argument_list|(
name|HistoryFileManager
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|serviceInit (Configuration conf)
specifier|protected
name|void
name|serviceInit
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|int
name|serialNumberLowDigits
init|=
literal|3
decl_stmt|;
name|serialNumberFormat
operator|=
operator|(
literal|"%0"
operator|+
operator|(
name|JobHistoryUtils
operator|.
name|SERIAL_NUMBER_DIRECTORY_DIGITS
operator|+
name|serialNumberLowDigits
operator|)
operator|+
literal|"d"
operator|)
expr_stmt|;
name|long
name|maxFSWaitTime
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|JHAdminConfig
operator|.
name|MR_HISTORY_MAX_START_WAIT_TIME
argument_list|,
name|JHAdminConfig
operator|.
name|DEFAULT_MR_HISTORY_MAX_START_WAIT_TIME
argument_list|)
decl_stmt|;
name|createHistoryDirs
argument_list|(
name|SystemClock
operator|.
name|getInstance
argument_list|()
argument_list|,
literal|10
operator|*
literal|1000
argument_list|,
name|maxFSWaitTime
argument_list|)
expr_stmt|;
name|maxTasksForLoadedJob
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|JHAdminConfig
operator|.
name|MR_HS_LOADED_JOBS_TASKS_MAX
argument_list|,
name|JHAdminConfig
operator|.
name|DEFAULT_MR_HS_LOADED_JOBS_TASKS_MAX
argument_list|)
expr_stmt|;
name|this
operator|.
name|aclsMgr
operator|=
operator|new
name|JobACLsManager
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|maxHistoryAge
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|JHAdminConfig
operator|.
name|MR_HISTORY_MAX_AGE_MS
argument_list|,
name|JHAdminConfig
operator|.
name|DEFAULT_MR_HISTORY_MAX_AGE
argument_list|)
expr_stmt|;
name|jobListCache
operator|=
name|createJobListCache
argument_list|()
expr_stmt|;
name|serialNumberIndex
operator|=
operator|new
name|SerialNumberIndex
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|JHAdminConfig
operator|.
name|MR_HISTORY_DATESTRING_CACHE_SIZE
argument_list|,
name|JHAdminConfig
operator|.
name|DEFAULT_MR_HISTORY_DATESTRING_CACHE_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|numMoveThreads
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|JHAdminConfig
operator|.
name|MR_HISTORY_MOVE_THREAD_COUNT
argument_list|,
name|JHAdminConfig
operator|.
name|DEFAULT_MR_HISTORY_MOVE_THREAD_COUNT
argument_list|)
decl_stmt|;
name|moveToDoneExecutor
operator|=
name|createMoveToDoneThreadPool
argument_list|(
name|numMoveThreads
argument_list|)
expr_stmt|;
name|super
operator|.
name|serviceInit
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
DECL|method|createMoveToDoneThreadPool (int numMoveThreads)
specifier|protected
name|ThreadPoolExecutor
name|createMoveToDoneThreadPool
parameter_list|(
name|int
name|numMoveThreads
parameter_list|)
block|{
name|ThreadFactory
name|tf
init|=
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setNameFormat
argument_list|(
literal|"MoveIntermediateToDone Thread #%d"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
return|return
operator|new
name|HadoopThreadPoolExecutor
argument_list|(
name|numMoveThreads
argument_list|,
name|numMoveThreads
argument_list|,
literal|1
argument_list|,
name|TimeUnit
operator|.
name|HOURS
argument_list|,
operator|new
name|LinkedBlockingQueue
argument_list|<
name|Runnable
argument_list|>
argument_list|()
argument_list|,
name|tf
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|createHistoryDirs (Clock clock, long intervalCheckMillis, long timeOutMillis)
name|void
name|createHistoryDirs
parameter_list|(
name|Clock
name|clock
parameter_list|,
name|long
name|intervalCheckMillis
parameter_list|,
name|long
name|timeOutMillis
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|start
init|=
name|clock
operator|.
name|getTime
argument_list|()
decl_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
name|int
name|counter
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
operator|(
operator|(
name|timeOutMillis
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|clock
operator|.
name|getTime
argument_list|()
operator|-
name|start
operator|<
name|timeOutMillis
operator|)
operator|)
condition|)
block|{
name|done
operator|=
name|tryCreatingHistoryDirs
argument_list|(
name|counter
operator|++
operator|%
literal|3
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|// log every 3 attempts, 30sec
if|if
condition|(
name|done
condition|)
block|{
break|break;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|intervalCheckMillis
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|YarnRuntimeException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
throw|throw
operator|new
name|YarnRuntimeException
argument_list|(
literal|"Timed out '"
operator|+
name|timeOutMillis
operator|+
literal|"ms' waiting for FileSystem to become available"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Check if the NameNode is still not started yet as indicated by the    * exception type and message.    * DistributedFileSystem returns a RemoteException with a message stating    * SafeModeException in it. So this is only way to check it is because of    * being in safe mode. In addition, Name Node may have not started yet, in    * which case, the message contains "NameNode still not started".    */
DECL|method|isNameNodeStillNotStarted (Exception ex)
specifier|private
name|boolean
name|isNameNodeStillNotStarted
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|String
name|nameNodeNotStartedMsg
init|=
name|NameNode
operator|.
name|composeNotStartedMessage
argument_list|(
name|HdfsServerConstants
operator|.
name|NamenodeRole
operator|.
name|NAMENODE
argument_list|)
decl_stmt|;
return|return
name|ex
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
literal|"SafeModeException"
argument_list|)
operator|||
operator|(
name|ex
operator|instanceof
name|RetriableException
operator|&&
name|ex
operator|.
name|getMessage
argument_list|()
operator|.
name|contains
argument_list|(
name|nameNodeNotStartedMsg
argument_list|)
operator|)
return|;
block|}
comment|/**    * Returns TRUE if the history dirs were created, FALSE if they could not    * be created because the FileSystem is not reachable or in safe mode and    * throws and exception otherwise.    */
annotation|@
name|VisibleForTesting
DECL|method|tryCreatingHistoryDirs (boolean logWait)
name|boolean
name|tryCreatingHistoryDirs
parameter_list|(
name|boolean
name|logWait
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|succeeded
init|=
literal|true
decl_stmt|;
name|String
name|doneDirPrefix
init|=
name|JobHistoryUtils
operator|.
name|getConfiguredHistoryServerDoneDirPrefix
argument_list|(
name|conf
argument_list|)
decl_stmt|;
try|try
block|{
name|doneDirPrefixPath
operator|=
name|FileContext
operator|.
name|getFileContext
argument_list|(
name|conf
argument_list|)
operator|.
name|makeQualified
argument_list|(
operator|new
name|Path
argument_list|(
name|doneDirPrefix
argument_list|)
argument_list|)
expr_stmt|;
name|doneDirFc
operator|=
name|FileContext
operator|.
name|getFileContext
argument_list|(
name|doneDirPrefixPath
operator|.
name|toUri
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|doneDirFc
operator|.
name|setUMask
argument_list|(
name|JobHistoryUtils
operator|.
name|HISTORY_DONE_DIR_UMASK
argument_list|)
expr_stmt|;
name|mkdir
argument_list|(
name|doneDirFc
argument_list|,
name|doneDirPrefixPath
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|JobHistoryUtils
operator|.
name|HISTORY_DONE_DIR_PERMISSION
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ConnectException
name|ex
parameter_list|)
block|{
if|if
condition|(
name|logWait
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting for FileSystem at "
operator|+
name|doneDirPrefixPath
operator|.
name|toUri
argument_list|()
operator|.
name|getAuthority
argument_list|()
operator|+
literal|"to be available"
argument_list|)
expr_stmt|;
block|}
name|succeeded
operator|=
literal|false
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isNameNodeStillNotStarted
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|succeeded
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|logWait
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting for FileSystem at "
operator|+
name|doneDirPrefixPath
operator|.
name|toUri
argument_list|()
operator|.
name|getAuthority
argument_list|()
operator|+
literal|"to be out of safe mode"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|YarnRuntimeException
argument_list|(
literal|"Error creating done directory: ["
operator|+
name|doneDirPrefixPath
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|succeeded
condition|)
block|{
name|String
name|intermediateDoneDirPrefix
init|=
name|JobHistoryUtils
operator|.
name|getConfiguredHistoryIntermediateDoneDirPrefix
argument_list|(
name|conf
argument_list|)
decl_stmt|;
try|try
block|{
name|intermediateDoneDirPath
operator|=
name|FileContext
operator|.
name|getFileContext
argument_list|(
name|conf
argument_list|)
operator|.
name|makeQualified
argument_list|(
operator|new
name|Path
argument_list|(
name|intermediateDoneDirPrefix
argument_list|)
argument_list|)
expr_stmt|;
name|intermediateDoneDirFc
operator|=
name|FileContext
operator|.
name|getFileContext
argument_list|(
name|intermediateDoneDirPath
operator|.
name|toUri
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|mkdir
argument_list|(
name|intermediateDoneDirFc
argument_list|,
name|intermediateDoneDirPath
argument_list|,
operator|new
name|FsPermission
argument_list|(
name|JobHistoryUtils
operator|.
name|HISTORY_INTERMEDIATE_DONE_DIR_PERMISSIONS
operator|.
name|toShort
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ConnectException
name|ex
parameter_list|)
block|{
name|succeeded
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|logWait
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting for FileSystem at "
operator|+
name|intermediateDoneDirPath
operator|.
name|toUri
argument_list|()
operator|.
name|getAuthority
argument_list|()
operator|+
literal|"to be available"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isNameNodeStillNotStarted
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|succeeded
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|logWait
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting for FileSystem at "
operator|+
name|intermediateDoneDirPath
operator|.
name|toUri
argument_list|()
operator|.
name|getAuthority
argument_list|()
operator|+
literal|"to be out of safe mode"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|YarnRuntimeException
argument_list|(
literal|"Error creating intermediate done directory: ["
operator|+
name|intermediateDoneDirPath
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|succeeded
return|;
block|}
annotation|@
name|Override
DECL|method|serviceStop ()
specifier|public
name|void
name|serviceStop
parameter_list|()
throws|throws
name|Exception
block|{
name|ShutdownThreadsHelper
operator|.
name|shutdownExecutorService
argument_list|(
name|moveToDoneExecutor
argument_list|)
expr_stmt|;
name|super
operator|.
name|serviceStop
argument_list|()
expr_stmt|;
block|}
DECL|method|createJobListCache ()
specifier|protected
name|JobListCache
name|createJobListCache
parameter_list|()
block|{
return|return
operator|new
name|JobListCache
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|JHAdminConfig
operator|.
name|MR_HISTORY_JOBLIST_CACHE_SIZE
argument_list|,
name|JHAdminConfig
operator|.
name|DEFAULT_MR_HISTORY_JOBLIST_CACHE_SIZE
argument_list|)
argument_list|,
name|maxHistoryAge
argument_list|)
return|;
block|}
DECL|method|mkdir (FileContext fc, Path path, FsPermission fsp)
specifier|private
name|void
name|mkdir
parameter_list|(
name|FileContext
name|fc
parameter_list|,
name|Path
name|path
parameter_list|,
name|FsPermission
name|fsp
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|fc
operator|.
name|util
argument_list|()
operator|.
name|exists
argument_list|(
name|path
argument_list|)
condition|)
block|{
try|try
block|{
name|fc
operator|.
name|mkdir
argument_list|(
name|path
argument_list|,
name|fsp
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|FileStatus
name|fsStatus
init|=
name|fc
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Perms after creating "
operator|+
name|fsStatus
operator|.
name|getPermission
argument_list|()
operator|.
name|toShort
argument_list|()
operator|+
literal|", Expected: "
operator|+
name|fsp
operator|.
name|toShort
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsStatus
operator|.
name|getPermission
argument_list|()
operator|.
name|toShort
argument_list|()
operator|!=
name|fsp
operator|.
name|toShort
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Explicitly setting permissions to : "
operator|+
name|fsp
operator|.
name|toShort
argument_list|()
operator|+
literal|", "
operator|+
name|fsp
argument_list|)
expr_stmt|;
name|fc
operator|.
name|setPermission
argument_list|(
name|path
argument_list|,
name|fsp
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|FileAlreadyExistsException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Directory: ["
operator|+
name|path
operator|+
literal|"] already exists."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|createHistoryFileInfo (Path historyFile, Path confFile, Path summaryFile, JobIndexInfo jobIndexInfo, boolean isInDone)
specifier|protected
name|HistoryFileInfo
name|createHistoryFileInfo
parameter_list|(
name|Path
name|historyFile
parameter_list|,
name|Path
name|confFile
parameter_list|,
name|Path
name|summaryFile
parameter_list|,
name|JobIndexInfo
name|jobIndexInfo
parameter_list|,
name|boolean
name|isInDone
parameter_list|)
block|{
return|return
operator|new
name|HistoryFileInfo
argument_list|(
name|historyFile
argument_list|,
name|confFile
argument_list|,
name|summaryFile
argument_list|,
name|jobIndexInfo
argument_list|,
name|isInDone
argument_list|)
return|;
block|}
comment|/**    * Populates index data structures. Should only be called at initialization    * times.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|initExisting ()
name|void
name|initExisting
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Initializing Existing Jobs..."
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|FileStatus
argument_list|>
name|timestampedDirList
init|=
name|findTimestampedDirectories
argument_list|()
decl_stmt|;
comment|// Sort first just so insertion is in a consistent order
name|Collections
operator|.
name|sort
argument_list|(
name|timestampedDirList
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Found "
operator|+
name|timestampedDirList
operator|.
name|size
argument_list|()
operator|+
literal|" directories to load"
argument_list|)
expr_stmt|;
for|for
control|(
name|FileStatus
name|fs
range|:
name|timestampedDirList
control|)
block|{
comment|// TODO Could verify the correct format for these directories.
name|addDirectoryToSerialNumberIndex
argument_list|(
name|fs
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|double
name|maxCacheSize
init|=
operator|(
name|double
operator|)
name|jobListCache
operator|.
name|maxSize
decl_stmt|;
name|int
name|prevCacheSize
init|=
name|jobListCache
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|timestampedDirList
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
operator|&&
operator|!
name|jobListCache
operator|.
name|isFull
argument_list|()
condition|;
name|i
operator|--
control|)
block|{
name|FileStatus
name|fs
init|=
name|timestampedDirList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|addDirectoryToJobListCache
argument_list|(
name|fs
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|currCacheSize
init|=
name|jobListCache
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|currCacheSize
operator|-
name|prevCacheSize
operator|)
operator|/
name|maxCacheSize
operator|>=
literal|0.05
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|currCacheSize
operator|*
literal|100.0
operator|/
name|maxCacheSize
operator|+
literal|"% of cache is loaded."
argument_list|)
expr_stmt|;
block|}
name|prevCacheSize
operator|=
name|currCacheSize
expr_stmt|;
block|}
specifier|final
name|double
name|loadedPercent
init|=
name|maxCacheSize
operator|==
literal|0.0
condition|?
literal|100
else|:
name|prevCacheSize
operator|*
literal|100.0
operator|/
name|maxCacheSize
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Existing job initialization finished. "
operator|+
name|loadedPercent
operator|+
literal|"% of cache is occupied."
argument_list|)
expr_stmt|;
block|}
DECL|method|removeDirectoryFromSerialNumberIndex (Path serialDirPath)
specifier|private
name|void
name|removeDirectoryFromSerialNumberIndex
parameter_list|(
name|Path
name|serialDirPath
parameter_list|)
block|{
name|String
name|serialPart
init|=
name|serialDirPath
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|timeStampPart
init|=
name|JobHistoryUtils
operator|.
name|getTimestampPartFromPath
argument_list|(
name|serialDirPath
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|timeStampPart
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not find timestamp portion from path: "
operator|+
name|serialDirPath
operator|.
name|toString
argument_list|()
operator|+
literal|". Continuing with next"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|serialPart
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not find serial portion from path: "
operator|+
name|serialDirPath
operator|.
name|toString
argument_list|()
operator|+
literal|". Continuing with next"
argument_list|)
expr_stmt|;
return|return;
block|}
name|serialNumberIndex
operator|.
name|remove
argument_list|(
name|serialPart
argument_list|,
name|timeStampPart
argument_list|)
expr_stmt|;
block|}
DECL|method|addDirectoryToSerialNumberIndex (Path serialDirPath)
specifier|private
name|void
name|addDirectoryToSerialNumberIndex
parameter_list|(
name|Path
name|serialDirPath
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding "
operator|+
name|serialDirPath
operator|+
literal|" to serial index"
argument_list|)
expr_stmt|;
block|}
name|String
name|serialPart
init|=
name|serialDirPath
operator|.
name|getName
argument_list|()
decl_stmt|;
name|String
name|timestampPart
init|=
name|JobHistoryUtils
operator|.
name|getTimestampPartFromPath
argument_list|(
name|serialDirPath
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|timestampPart
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not find timestamp portion from path: "
operator|+
name|serialDirPath
operator|+
literal|". Continuing with next"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|serialPart
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not find serial portion from path: "
operator|+
name|serialDirPath
operator|.
name|toString
argument_list|()
operator|+
literal|". Continuing with next"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|serialNumberIndex
operator|.
name|add
argument_list|(
name|serialPart
argument_list|,
name|timestampPart
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addDirectoryToJobListCache (Path path)
specifier|private
name|void
name|addDirectoryToJobListCache
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding "
operator|+
name|path
operator|+
literal|" to job list cache."
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|FileStatus
argument_list|>
name|historyFileList
init|=
name|scanDirectoryForHistoryFiles
argument_list|(
name|path
argument_list|,
name|doneDirFc
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|fs
range|:
name|historyFileList
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Adding in history for "
operator|+
name|fs
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|JobIndexInfo
name|jobIndexInfo
init|=
name|FileNameIndexUtils
operator|.
name|getIndexInfo
argument_list|(
name|fs
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|confFileName
init|=
name|JobHistoryUtils
operator|.
name|getIntermediateConfFileName
argument_list|(
name|jobIndexInfo
operator|.
name|getJobId
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|summaryFileName
init|=
name|JobHistoryUtils
operator|.
name|getIntermediateSummaryFileName
argument_list|(
name|jobIndexInfo
operator|.
name|getJobId
argument_list|()
argument_list|)
decl_stmt|;
name|HistoryFileInfo
name|fileInfo
init|=
name|createHistoryFileInfo
argument_list|(
name|fs
operator|.
name|getPath
argument_list|()
argument_list|,
operator|new
name|Path
argument_list|(
name|fs
operator|.
name|getPath
argument_list|()
operator|.
name|getParent
argument_list|()
argument_list|,
name|confFileName
argument_list|)
argument_list|,
operator|new
name|Path
argument_list|(
name|fs
operator|.
name|getPath
argument_list|()
operator|.
name|getParent
argument_list|()
argument_list|,
name|summaryFileName
argument_list|)
argument_list|,
name|jobIndexInfo
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|jobListCache
operator|.
name|addIfAbsent
argument_list|(
name|fileInfo
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|scanDirectory (Path path, FileContext fc, PathFilter pathFilter)
specifier|protected
specifier|static
name|List
argument_list|<
name|FileStatus
argument_list|>
name|scanDirectory
parameter_list|(
name|Path
name|path
parameter_list|,
name|FileContext
name|fc
parameter_list|,
name|PathFilter
name|pathFilter
parameter_list|)
throws|throws
name|IOException
block|{
name|path
operator|=
name|fc
operator|.
name|makeQualified
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|FileStatus
argument_list|>
name|jhStatusList
init|=
operator|new
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
decl_stmt|;
try|try
block|{
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|fileStatusIter
init|=
name|fc
operator|.
name|listStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
while|while
condition|(
name|fileStatusIter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|FileStatus
name|fileStatus
init|=
name|fileStatusIter
operator|.
name|next
argument_list|()
decl_stmt|;
name|Path
name|filePath
init|=
name|fileStatus
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|fileStatus
operator|.
name|isFile
argument_list|()
operator|&&
name|pathFilter
operator|.
name|accept
argument_list|(
name|filePath
argument_list|)
condition|)
block|{
name|jhStatusList
operator|.
name|add
argument_list|(
name|fileStatus
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error while scanning directory "
operator|+
name|path
argument_list|,
name|fe
argument_list|)
expr_stmt|;
block|}
return|return
name|jhStatusList
return|;
block|}
DECL|method|scanDirectoryForHistoryFiles (Path path, FileContext fc)
specifier|protected
name|List
argument_list|<
name|FileStatus
argument_list|>
name|scanDirectoryForHistoryFiles
parameter_list|(
name|Path
name|path
parameter_list|,
name|FileContext
name|fc
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|scanDirectory
argument_list|(
name|path
argument_list|,
name|fc
argument_list|,
name|JobHistoryUtils
operator|.
name|getHistoryFileFilter
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Finds all history directories with a timestamp component by scanning the    * filesystem. Used when the JobHistory server is started.    *     * @return list of history directories    */
DECL|method|findTimestampedDirectories ()
specifier|protected
name|List
argument_list|<
name|FileStatus
argument_list|>
name|findTimestampedDirectories
parameter_list|()
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|FileStatus
argument_list|>
name|fsList
init|=
name|JobHistoryUtils
operator|.
name|localGlobber
argument_list|(
name|doneDirFc
argument_list|,
name|doneDirPrefixPath
argument_list|,
name|DONE_BEFORE_SERIAL_TAIL
argument_list|)
decl_stmt|;
return|return
name|fsList
return|;
block|}
comment|/**    * Scans the intermediate directory to find user directories. Scans these for    * history files if the modification time for the directory has changed. Once    * it finds history files it starts the process of moving them to the done     * directory.    *     * @throws IOException    *           if there was a error while scanning    */
DECL|method|scanIntermediateDirectory ()
name|void
name|scanIntermediateDirectory
parameter_list|()
throws|throws
name|IOException
block|{
comment|// TODO it would be great to limit how often this happens, except in the
comment|// case where we are looking for a particular job.
name|List
argument_list|<
name|FileStatus
argument_list|>
name|userDirList
init|=
name|JobHistoryUtils
operator|.
name|localGlobber
argument_list|(
name|intermediateDoneDirFc
argument_list|,
name|intermediateDoneDirPath
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Scanning intermediate dirs"
argument_list|)
expr_stmt|;
for|for
control|(
name|FileStatus
name|userDir
range|:
name|userDirList
control|)
block|{
name|String
name|name
init|=
name|userDir
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|UserLogDir
name|dir
init|=
name|userDirModificationTimeMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|dir
operator|==
literal|null
condition|)
block|{
name|dir
operator|=
operator|new
name|UserLogDir
argument_list|()
expr_stmt|;
name|UserLogDir
name|old
init|=
name|userDirModificationTimeMap
operator|.
name|putIfAbsent
argument_list|(
name|name
argument_list|,
name|dir
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
name|dir
operator|=
name|old
expr_stmt|;
block|}
block|}
name|dir
operator|.
name|scanIfNeeded
argument_list|(
name|userDir
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Scans the specified path and populates the intermediate cache.    *     * @param absPath    * @throws IOException    */
DECL|method|scanIntermediateDirectory (final Path absPath)
specifier|private
name|void
name|scanIntermediateDirectory
parameter_list|(
specifier|final
name|Path
name|absPath
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Scanning intermediate dir "
operator|+
name|absPath
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|FileStatus
argument_list|>
name|fileStatusList
init|=
name|scanDirectoryForHistoryFiles
argument_list|(
name|absPath
argument_list|,
name|intermediateDoneDirFc
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Found "
operator|+
name|fileStatusList
operator|.
name|size
argument_list|()
operator|+
literal|" files"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|FileStatus
name|fs
range|:
name|fileStatusList
control|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"scanning file: "
operator|+
name|fs
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|JobIndexInfo
name|jobIndexInfo
init|=
name|FileNameIndexUtils
operator|.
name|getIndexInfo
argument_list|(
name|fs
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|confFileName
init|=
name|JobHistoryUtils
operator|.
name|getIntermediateConfFileName
argument_list|(
name|jobIndexInfo
operator|.
name|getJobId
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|summaryFileName
init|=
name|JobHistoryUtils
operator|.
name|getIntermediateSummaryFileName
argument_list|(
name|jobIndexInfo
operator|.
name|getJobId
argument_list|()
argument_list|)
decl_stmt|;
name|HistoryFileInfo
name|fileInfo
init|=
name|createHistoryFileInfo
argument_list|(
name|fs
operator|.
name|getPath
argument_list|()
argument_list|,
operator|new
name|Path
argument_list|(
name|fs
operator|.
name|getPath
argument_list|()
operator|.
name|getParent
argument_list|()
argument_list|,
name|confFileName
argument_list|)
argument_list|,
operator|new
name|Path
argument_list|(
name|fs
operator|.
name|getPath
argument_list|()
operator|.
name|getParent
argument_list|()
argument_list|,
name|summaryFileName
argument_list|)
argument_list|,
name|jobIndexInfo
argument_list|,
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|HistoryFileInfo
name|old
init|=
name|jobListCache
operator|.
name|addIfAbsent
argument_list|(
name|fileInfo
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|==
literal|null
operator|||
name|old
operator|.
name|didMoveFail
argument_list|()
condition|)
block|{
specifier|final
name|HistoryFileInfo
name|found
init|=
operator|(
name|old
operator|==
literal|null
operator|)
condition|?
name|fileInfo
else|:
name|old
decl_stmt|;
name|long
name|cutoff
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|maxHistoryAge
decl_stmt|;
if|if
condition|(
name|found
operator|.
name|getJobIndexInfo
argument_list|()
operator|.
name|getFinishTime
argument_list|()
operator|<=
name|cutoff
condition|)
block|{
try|try
block|{
name|found
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error cleaning up a HistoryFile that is out of date."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Scheduling move to done of "
operator|+
name|found
argument_list|)
expr_stmt|;
block|}
name|moveToDoneExecutor
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|found
operator|.
name|moveToDone
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to process fileInfo for job: "
operator|+
name|found
operator|.
name|getJobId
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|old
operator|.
name|isMovePending
argument_list|()
condition|)
block|{
comment|//This is a duplicate so just delete it
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Duplicate: deleting"
argument_list|)
expr_stmt|;
block|}
name|fileInfo
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Searches the job history file FileStatus list for the specified JobId.    *     * @param fileStatusList    *          fileStatus list of Job History Files.    * @param jobId    *          The JobId to find.    * @return A FileInfo object for the jobId, null if not found.    * @throws IOException    */
DECL|method|getJobFileInfo (List<FileStatus> fileStatusList, JobId jobId)
specifier|private
name|HistoryFileInfo
name|getJobFileInfo
parameter_list|(
name|List
argument_list|<
name|FileStatus
argument_list|>
name|fileStatusList
parameter_list|,
name|JobId
name|jobId
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|FileStatus
name|fs
range|:
name|fileStatusList
control|)
block|{
name|JobIndexInfo
name|jobIndexInfo
init|=
name|FileNameIndexUtils
operator|.
name|getIndexInfo
argument_list|(
name|fs
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|jobIndexInfo
operator|.
name|getJobId
argument_list|()
operator|.
name|equals
argument_list|(
name|jobId
argument_list|)
condition|)
block|{
name|String
name|confFileName
init|=
name|JobHistoryUtils
operator|.
name|getIntermediateConfFileName
argument_list|(
name|jobIndexInfo
operator|.
name|getJobId
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|summaryFileName
init|=
name|JobHistoryUtils
operator|.
name|getIntermediateSummaryFileName
argument_list|(
name|jobIndexInfo
operator|.
name|getJobId
argument_list|()
argument_list|)
decl_stmt|;
name|HistoryFileInfo
name|fileInfo
init|=
name|createHistoryFileInfo
argument_list|(
name|fs
operator|.
name|getPath
argument_list|()
argument_list|,
operator|new
name|Path
argument_list|(
name|fs
operator|.
name|getPath
argument_list|()
operator|.
name|getParent
argument_list|()
argument_list|,
name|confFileName
argument_list|)
argument_list|,
operator|new
name|Path
argument_list|(
name|fs
operator|.
name|getPath
argument_list|()
operator|.
name|getParent
argument_list|()
argument_list|,
name|summaryFileName
argument_list|)
argument_list|,
name|jobIndexInfo
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
name|fileInfo
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Scans old directories known by the idToDateString map for the specified    * jobId. If the number of directories is higher than the supported size of    * the idToDateString cache, the jobId will not be found.    *     * @param jobId    *          the jobId.    * @return    * @throws IOException    */
DECL|method|scanOldDirsForJob (JobId jobId)
specifier|private
name|HistoryFileInfo
name|scanOldDirsForJob
parameter_list|(
name|JobId
name|jobId
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|boxedSerialNumber
init|=
name|JobHistoryUtils
operator|.
name|serialNumberDirectoryComponent
argument_list|(
name|jobId
argument_list|,
name|serialNumberFormat
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|dateStringSet
init|=
name|serialNumberIndex
operator|.
name|get
argument_list|(
name|boxedSerialNumber
argument_list|)
decl_stmt|;
if|if
condition|(
name|dateStringSet
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
for|for
control|(
name|String
name|timestampPart
range|:
name|dateStringSet
control|)
block|{
name|Path
name|logDir
init|=
name|canonicalHistoryLogPath
argument_list|(
name|jobId
argument_list|,
name|timestampPart
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|FileStatus
argument_list|>
name|fileStatusList
init|=
name|scanDirectoryForHistoryFiles
argument_list|(
name|logDir
argument_list|,
name|doneDirFc
argument_list|)
decl_stmt|;
name|HistoryFileInfo
name|fileInfo
init|=
name|getJobFileInfo
argument_list|(
name|fileStatusList
argument_list|,
name|jobId
argument_list|)
decl_stmt|;
if|if
condition|(
name|fileInfo
operator|!=
literal|null
condition|)
block|{
return|return
name|fileInfo
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|getAllFileInfo ()
specifier|public
name|Collection
argument_list|<
name|HistoryFileInfo
argument_list|>
name|getAllFileInfo
parameter_list|()
throws|throws
name|IOException
block|{
name|scanIntermediateDirectory
argument_list|()
expr_stmt|;
return|return
name|jobListCache
operator|.
name|values
argument_list|()
return|;
block|}
DECL|method|getFileInfo (JobId jobId)
specifier|public
name|HistoryFileInfo
name|getFileInfo
parameter_list|(
name|JobId
name|jobId
parameter_list|)
throws|throws
name|IOException
block|{
comment|// FileInfo available in cache.
name|HistoryFileInfo
name|fileInfo
init|=
name|jobListCache
operator|.
name|get
argument_list|(
name|jobId
argument_list|)
decl_stmt|;
if|if
condition|(
name|fileInfo
operator|!=
literal|null
condition|)
block|{
return|return
name|fileInfo
return|;
block|}
comment|// OK so scan the intermediate to be sure we did not lose it that way
name|scanIntermediateDirectory
argument_list|()
expr_stmt|;
name|fileInfo
operator|=
name|jobListCache
operator|.
name|get
argument_list|(
name|jobId
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileInfo
operator|!=
literal|null
condition|)
block|{
return|return
name|fileInfo
return|;
block|}
comment|// Intermediate directory does not contain job. Search through older ones.
name|fileInfo
operator|=
name|scanOldDirsForJob
argument_list|(
name|jobId
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileInfo
operator|!=
literal|null
condition|)
block|{
return|return
name|fileInfo
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|moveToDoneNow (final Path src, final Path target)
specifier|private
name|void
name|moveToDoneNow
parameter_list|(
specifier|final
name|Path
name|src
parameter_list|,
specifier|final
name|Path
name|target
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Moving "
operator|+
name|src
operator|.
name|toString
argument_list|()
operator|+
literal|" to "
operator|+
name|target
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|intermediateDoneDirFc
operator|.
name|rename
argument_list|(
name|src
argument_list|,
name|target
argument_list|,
name|Options
operator|.
name|Rename
operator|.
name|NONE
argument_list|)
expr_stmt|;
block|}
DECL|method|getJobSummary (FileContext fc, Path path)
specifier|private
name|String
name|getJobSummary
parameter_list|(
name|FileContext
name|fc
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|qPath
init|=
name|fc
operator|.
name|makeQualified
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|FSDataInputStream
name|in
init|=
literal|null
decl_stmt|;
name|String
name|jobSummaryString
init|=
literal|null
decl_stmt|;
try|try
block|{
name|in
operator|=
name|fc
operator|.
name|open
argument_list|(
name|qPath
argument_list|)
expr_stmt|;
name|jobSummaryString
operator|=
name|in
operator|.
name|readUTF
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|jobSummaryString
return|;
block|}
DECL|method|makeDoneSubdir (Path path)
specifier|private
name|void
name|makeDoneSubdir
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|doneDirFc
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|existingDoneSubdirs
operator|.
name|add
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfE
parameter_list|)
block|{
try|try
block|{
name|FsPermission
name|fsp
init|=
operator|new
name|FsPermission
argument_list|(
name|JobHistoryUtils
operator|.
name|HISTORY_DONE_DIR_PERMISSION
argument_list|)
decl_stmt|;
name|doneDirFc
operator|.
name|mkdir
argument_list|(
name|path
argument_list|,
name|fsp
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|FileStatus
name|fsStatus
init|=
name|doneDirFc
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Perms after creating "
operator|+
name|fsStatus
operator|.
name|getPermission
argument_list|()
operator|.
name|toShort
argument_list|()
operator|+
literal|", Expected: "
operator|+
name|fsp
operator|.
name|toShort
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsStatus
operator|.
name|getPermission
argument_list|()
operator|.
name|toShort
argument_list|()
operator|!=
name|fsp
operator|.
name|toShort
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Explicitly setting permissions to : "
operator|+
name|fsp
operator|.
name|toShort
argument_list|()
operator|+
literal|", "
operator|+
name|fsp
argument_list|)
expr_stmt|;
name|doneDirFc
operator|.
name|setPermission
argument_list|(
name|path
argument_list|,
name|fsp
argument_list|)
expr_stmt|;
block|}
name|existingDoneSubdirs
operator|.
name|add
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileAlreadyExistsException
name|faeE
parameter_list|)
block|{
comment|// Nothing to do.
block|}
block|}
block|}
DECL|method|canonicalHistoryLogPath (JobId id, String timestampComponent)
specifier|private
name|Path
name|canonicalHistoryLogPath
parameter_list|(
name|JobId
name|id
parameter_list|,
name|String
name|timestampComponent
parameter_list|)
block|{
return|return
operator|new
name|Path
argument_list|(
name|doneDirPrefixPath
argument_list|,
name|JobHistoryUtils
operator|.
name|historyLogSubdirectory
argument_list|(
name|id
argument_list|,
name|timestampComponent
argument_list|,
name|serialNumberFormat
argument_list|)
argument_list|)
return|;
block|}
DECL|method|canonicalHistoryLogPath (JobId id, long millisecondTime)
specifier|private
name|Path
name|canonicalHistoryLogPath
parameter_list|(
name|JobId
name|id
parameter_list|,
name|long
name|millisecondTime
parameter_list|)
block|{
name|String
name|timestampComponent
init|=
name|JobHistoryUtils
operator|.
name|timestampDirectoryComponent
argument_list|(
name|millisecondTime
argument_list|)
decl_stmt|;
return|return
operator|new
name|Path
argument_list|(
name|doneDirPrefixPath
argument_list|,
name|JobHistoryUtils
operator|.
name|historyLogSubdirectory
argument_list|(
name|id
argument_list|,
name|timestampComponent
argument_list|,
name|serialNumberFormat
argument_list|)
argument_list|)
return|;
block|}
DECL|method|getEffectiveTimestamp (long finishTime, FileStatus fileStatus)
specifier|private
name|long
name|getEffectiveTimestamp
parameter_list|(
name|long
name|finishTime
parameter_list|,
name|FileStatus
name|fileStatus
parameter_list|)
block|{
if|if
condition|(
name|finishTime
operator|==
literal|0
condition|)
block|{
return|return
name|fileStatus
operator|.
name|getModificationTime
argument_list|()
return|;
block|}
return|return
name|finishTime
return|;
block|}
DECL|method|deleteJobFromDone (HistoryFileInfo fileInfo)
specifier|private
name|void
name|deleteJobFromDone
parameter_list|(
name|HistoryFileInfo
name|fileInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|jobListCache
operator|.
name|delete
argument_list|(
name|fileInfo
argument_list|)
expr_stmt|;
name|fileInfo
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
DECL|method|getHistoryDirsForCleaning (long cutoff)
name|List
argument_list|<
name|FileStatus
argument_list|>
name|getHistoryDirsForCleaning
parameter_list|(
name|long
name|cutoff
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|JobHistoryUtils
operator|.
name|getHistoryDirsForCleaning
argument_list|(
name|doneDirFc
argument_list|,
name|doneDirPrefixPath
argument_list|,
name|cutoff
argument_list|)
return|;
block|}
comment|/**    * Clean up older history files.    *     * @throws IOException    *           on any error trying to remove the entries.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|clean ()
name|void
name|clean
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|cutoff
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|maxHistoryAge
decl_stmt|;
name|boolean
name|halted
init|=
literal|false
decl_stmt|;
name|List
argument_list|<
name|FileStatus
argument_list|>
name|serialDirList
init|=
name|getHistoryDirsForCleaning
argument_list|(
name|cutoff
argument_list|)
decl_stmt|;
comment|// Sort in ascending order. Relies on YYYY/MM/DD/Serial
name|Collections
operator|.
name|sort
argument_list|(
name|serialDirList
argument_list|)
expr_stmt|;
for|for
control|(
name|FileStatus
name|serialDir
range|:
name|serialDirList
control|)
block|{
name|List
argument_list|<
name|FileStatus
argument_list|>
name|historyFileList
init|=
name|scanDirectoryForHistoryFiles
argument_list|(
name|serialDir
operator|.
name|getPath
argument_list|()
argument_list|,
name|doneDirFc
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|historyFile
range|:
name|historyFileList
control|)
block|{
name|JobIndexInfo
name|jobIndexInfo
init|=
name|FileNameIndexUtils
operator|.
name|getIndexInfo
argument_list|(
name|historyFile
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|effectiveTimestamp
init|=
name|getEffectiveTimestamp
argument_list|(
name|jobIndexInfo
operator|.
name|getFinishTime
argument_list|()
argument_list|,
name|historyFile
argument_list|)
decl_stmt|;
if|if
condition|(
name|effectiveTimestamp
operator|<=
name|cutoff
condition|)
block|{
name|HistoryFileInfo
name|fileInfo
init|=
name|this
operator|.
name|jobListCache
operator|.
name|get
argument_list|(
name|jobIndexInfo
operator|.
name|getJobId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|fileInfo
operator|==
literal|null
condition|)
block|{
name|String
name|confFileName
init|=
name|JobHistoryUtils
operator|.
name|getIntermediateConfFileName
argument_list|(
name|jobIndexInfo
operator|.
name|getJobId
argument_list|()
argument_list|)
decl_stmt|;
name|fileInfo
operator|=
name|createHistoryFileInfo
argument_list|(
name|historyFile
operator|.
name|getPath
argument_list|()
argument_list|,
operator|new
name|Path
argument_list|(
name|historyFile
operator|.
name|getPath
argument_list|()
operator|.
name|getParent
argument_list|()
argument_list|,
name|confFileName
argument_list|)
argument_list|,
literal|null
argument_list|,
name|jobIndexInfo
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|deleteJobFromDone
argument_list|(
name|fileInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|halted
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|halted
condition|)
block|{
name|deleteDir
argument_list|(
name|serialDir
argument_list|)
expr_stmt|;
name|removeDirectoryFromSerialNumberIndex
argument_list|(
name|serialDir
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|existingDoneSubdirs
operator|.
name|remove
argument_list|(
name|serialDir
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
comment|// Don't scan any more directories.
block|}
block|}
block|}
DECL|method|deleteDir (FileStatus serialDir)
specifier|protected
name|boolean
name|deleteDir
parameter_list|(
name|FileStatus
name|serialDir
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
return|return
name|doneDirFc
operator|.
name|delete
argument_list|(
name|doneDirFc
operator|.
name|makeQualified
argument_list|(
name|serialDir
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|// for test
annotation|@
name|VisibleForTesting
DECL|method|setMaxHistoryAge (long newValue)
name|void
name|setMaxHistoryAge
parameter_list|(
name|long
name|newValue
parameter_list|)
block|{
name|maxHistoryAge
operator|=
name|newValue
expr_stmt|;
block|}
block|}
end_class

end_unit

