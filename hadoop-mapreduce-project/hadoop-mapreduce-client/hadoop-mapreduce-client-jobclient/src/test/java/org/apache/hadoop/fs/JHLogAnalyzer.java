begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStreamWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
operator|.
name|CompressionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|CompressionCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|GzipCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * Job History Log Analyzer.  *   *<h3>Description.</h3>  * This a tool for parsing and analyzing history logs of map-reduce jobs.  * History logs contain information about execution of jobs, tasks, and   * attempts. This tool focuses on submission, launch, start, and finish times,  * as well as the success or failure of jobs, tasks, and attempts.  *<p>  * The analyzer calculates<em>per hour slot utilization</em> for the cluster   * as follows.  * For each task attempt it divides the time segment from the start of the   * attempt t<sub>S</sub> to the finish t<sub>F</sub> into whole hours   * [t<sub>0</sub>, ..., t<sub>n</sub>], where t<sub>0</sub><= t<sub>S</sub>   * is the maximal whole hour preceding t<sub>S</sub>, and  * t<sub>n</sub>>= t<sub>F</sub> is the minimal whole hour after t<sub>F</sub>.   * Thus, [t<sub>0</sub>, ..., t<sub>n</sub>] covers the segment   * [t<sub>S</sub>, t<sub>F</sub>], during which the attempt was executed.  * Each interval [t<sub>i</sub>, t<sub>i+1</sub>] fully contained in   * [t<sub>S</sub>, t<sub>F</sub>] corresponds to exactly one slot on  * a map-reduce cluster (usually MAP-slot or REDUCE-slot).  * If interval [t<sub>i</sub>, t<sub>i+1</sub>] only intersects with   * [t<sub>S</sub>, t<sub>F</sub>] then we say that the task   * attempt used just a fraction of the slot during this hour.  * The fraction equals the size of the intersection.  * Let slotTime(A, h) denote the number of slots calculated that way for a   * specific attempt A during hour h.  * The tool then sums all slots for all attempts for every hour.  * The result is the slot hour utilization of the cluster:  *<tt>slotTime(h) = SUM<sub>A</sub> slotTime(A,h)</tt>.  *<p>  * Log analyzer calculates slot hours for<em>MAP</em> and<em>REDUCE</em>   * attempts separately.  *<p>  * Log analyzer distinguishes between<em>successful</em> and<em>failed</em>  * attempts. Task attempt is considered successful if its own status is SUCCESS  * and the statuses of the task and the job it is a part of are also SUCCESS.  * Otherwise the task attempt is considered failed.  *<p>  * Map-reduce clusters are usually configured to have a fixed number of MAP   * and REDUCE slots per node. Thus the maximal possible number of slots on  * the cluster is<tt>total_slots = total_nodes * slots_per_node</tt>.  * Effective slot hour cannot exceed<tt>total_slots</tt> for successful  * attempts.  *<p>  *<em>Pending time</em> characterizes the wait time of attempts.  * It is calculated similarly to the slot hour except that the wait interval  * starts when the job is submitted and ends when an attempt starts execution.  * In addition to that pending time also includes intervals between attempts  * of the same task if it was re-executed.  *<p>  * History log analyzer calculates two pending time variations. First is based  * on job submission time as described above, second, starts the wait interval  * when the job is launched rather than submitted.  *   *<h3>Input.</h3>  * The following input parameters can be specified in the argument string  * to the job log analyzer:  *<ul>  *<li><tt>-historyDir inputDir</tt> specifies the location of the directory  * where analyzer will be looking for job history log files.</li>  *<li><tt>-resFile resultFile</tt> the name of the result file.</li>  *<li><tt>-usersIncluded | -usersExcluded userList</tt> slot utilization and   * pending time can be calculated for all or for all but the specified users.  *<br>  *<tt>userList</tt> is a comma or semicolon separated list of users.</li>  *<li><tt>-gzip</tt> is used if history log files are compressed.  * Only {@link GzipCodec} is currently supported.</li>  *<li><tt>-jobDelimiter pattern</tt> one can concatenate original log files into   * larger file(s) with the specified delimiter to recognize the end of the log  * for one job from the next one.<br>  *<tt>pattern</tt> is a java regular expression  * {@link java.util.regex.Pattern}, which should match only the log delimiters.  *<br>  * E.g. pattern<tt>".!!FILE=.*!!"</tt> matches delimiters, which contain  * the original history log file names in the following form:<br>  *<tt>"$!!FILE=my.job.tracker.com_myJobId_user_wordcount.log!!"</tt></li>  *<li><tt>-clean</tt> cleans up default directories used by the analyzer.</li>  *<li><tt>-test</tt> test one file locally and exit;  * does not require map-reduce.</li>  *<li><tt>-help</tt> print usage.</li>  *</ul>  *   *<h3>Output.</h3>  * The output file is formatted as a tab separated table consisting of four  * columns:<tt>SERIES, PERIOD, TYPE, SLOT_HOUR</tt>.  *<ul>  *<li><tt>SERIES</tt> one of the four statistical series;</li>  *<li><tt>PERIOD</tt> the start of the time interval in the following format:  *<tt>"yyyy-mm-dd hh:mm:ss"</tt>;</li>  *<li><tt>TYPE</tt> the slot type, e.g. MAP or REDUCE;</li>  *<li><tt>SLOT_HOUR</tt> the value of the slot usage during this   * time interval.</li>  *</ul>  */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
DECL|class|JHLogAnalyzer
specifier|public
class|class
name|JHLogAnalyzer
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|JHLogAnalyzer
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Constants
DECL|field|JHLA_ROOT_DIR
specifier|private
specifier|static
specifier|final
name|String
name|JHLA_ROOT_DIR
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"test.build.data"
argument_list|,
literal|"stats/JHLA"
argument_list|)
decl_stmt|;
DECL|field|INPUT_DIR
specifier|private
specifier|static
specifier|final
name|Path
name|INPUT_DIR
init|=
operator|new
name|Path
argument_list|(
name|JHLA_ROOT_DIR
argument_list|,
literal|"jhla_input"
argument_list|)
decl_stmt|;
DECL|field|BASE_INPUT_FILE_NAME
specifier|private
specifier|static
specifier|final
name|String
name|BASE_INPUT_FILE_NAME
init|=
literal|"jhla_in_"
decl_stmt|;
DECL|field|OUTPUT_DIR
specifier|private
specifier|static
specifier|final
name|Path
name|OUTPUT_DIR
init|=
operator|new
name|Path
argument_list|(
name|JHLA_ROOT_DIR
argument_list|,
literal|"jhla_output"
argument_list|)
decl_stmt|;
DECL|field|RESULT_FILE
specifier|private
specifier|static
specifier|final
name|Path
name|RESULT_FILE
init|=
operator|new
name|Path
argument_list|(
name|JHLA_ROOT_DIR
argument_list|,
literal|"jhla_result.txt"
argument_list|)
decl_stmt|;
DECL|field|DEFAULT_HISTORY_DIR
specifier|private
specifier|static
specifier|final
name|Path
name|DEFAULT_HISTORY_DIR
init|=
operator|new
name|Path
argument_list|(
literal|"history"
argument_list|)
decl_stmt|;
DECL|field|DEFAULT_TIME_INTERVAL_MSEC
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_TIME_INTERVAL_MSEC
init|=
literal|1000
operator|*
literal|60
operator|*
literal|60
decl_stmt|;
comment|// 1 hour
static|static
block|{
name|Configuration
operator|.
name|addDefaultResource
argument_list|(
literal|"hdfs-default.xml"
argument_list|)
expr_stmt|;
name|Configuration
operator|.
name|addDefaultResource
argument_list|(
literal|"hdfs-site.xml"
argument_list|)
expr_stmt|;
block|}
DECL|enum|StatSeries
enum|enum
name|StatSeries
block|{
DECL|enumConstant|STAT_ALL_SLOT_TIME
name|STAT_ALL_SLOT_TIME
argument_list|(
name|AccumulatingReducer
operator|.
name|VALUE_TYPE_LONG
operator|+
literal|"allSlotTime"
argument_list|)
block|,
DECL|enumConstant|STAT_FAILED_SLOT_TIME
name|STAT_FAILED_SLOT_TIME
argument_list|(
name|AccumulatingReducer
operator|.
name|VALUE_TYPE_LONG
operator|+
literal|"failedSlotTime"
argument_list|)
block|,
DECL|enumConstant|STAT_SUBMIT_PENDING_SLOT_TIME
name|STAT_SUBMIT_PENDING_SLOT_TIME
argument_list|(
name|AccumulatingReducer
operator|.
name|VALUE_TYPE_LONG
operator|+
literal|"submitPendingSlotTime"
argument_list|)
block|,
DECL|enumConstant|STAT_LAUNCHED_PENDING_SLOT_TIME
name|STAT_LAUNCHED_PENDING_SLOT_TIME
argument_list|(
name|AccumulatingReducer
operator|.
name|VALUE_TYPE_LONG
operator|+
literal|"launchedPendingSlotTime"
argument_list|)
block|;
DECL|field|statName
specifier|private
name|String
name|statName
init|=
literal|null
decl_stmt|;
DECL|method|StatSeries (String name)
specifier|private
name|StatSeries
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|statName
operator|=
name|name
expr_stmt|;
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|statName
return|;
block|}
block|}
DECL|class|FileCreateDaemon
specifier|private
specifier|static
class|class
name|FileCreateDaemon
extends|extends
name|Thread
block|{
DECL|field|NUM_CREATE_THREADS
specifier|private
specifier|static
specifier|final
name|int
name|NUM_CREATE_THREADS
init|=
literal|10
decl_stmt|;
DECL|field|numFinishedThreads
specifier|private
specifier|static
specifier|volatile
name|int
name|numFinishedThreads
decl_stmt|;
DECL|field|numRunningThreads
specifier|private
specifier|static
specifier|volatile
name|int
name|numRunningThreads
decl_stmt|;
DECL|field|jhLogFiles
specifier|private
specifier|static
name|FileStatus
index|[]
name|jhLogFiles
decl_stmt|;
DECL|field|fs
name|FileSystem
name|fs
decl_stmt|;
DECL|field|start
name|int
name|start
decl_stmt|;
DECL|field|end
name|int
name|end
decl_stmt|;
DECL|method|FileCreateDaemon (FileSystem fs, int start, int end)
name|FileCreateDaemon
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|this
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|this
operator|.
name|start
operator|=
name|start
expr_stmt|;
name|this
operator|.
name|end
operator|=
name|end
expr_stmt|;
block|}
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|getFileName
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|Path
name|controlFile
init|=
operator|new
name|Path
argument_list|(
name|INPUT_DIR
argument_list|,
literal|"in_file_"
operator|+
name|name
argument_list|)
decl_stmt|;
name|SequenceFile
operator|.
name|Writer
name|writer
init|=
literal|null
decl_stmt|;
try|try
block|{
name|writer
operator|=
name|SequenceFile
operator|.
name|createWriter
argument_list|(
name|fs
argument_list|,
name|fs
operator|.
name|getConf
argument_list|()
argument_list|,
name|controlFile
argument_list|,
name|Text
operator|.
name|class
argument_list|,
name|LongWritable
operator|.
name|class
argument_list|,
name|CompressionType
operator|.
name|NONE
argument_list|)
expr_stmt|;
name|String
name|logFile
init|=
name|jhLogFiles
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|writer
operator|.
name|append
argument_list|(
operator|new
name|Text
argument_list|(
name|logFile
argument_list|)
argument_list|,
operator|new
name|LongWritable
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
name|writer
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"FileCreateDaemon failed."
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|numFinishedThreads
operator|++
expr_stmt|;
block|}
DECL|method|createControlFile (FileSystem fs, Path jhLogDir )
specifier|private
specifier|static
name|void
name|createControlFile
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|jhLogDir
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|delete
argument_list|(
name|INPUT_DIR
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|jhLogFiles
operator|=
name|fs
operator|.
name|listStatus
argument_list|(
name|jhLogDir
argument_list|)
expr_stmt|;
name|numFinishedThreads
operator|=
literal|0
expr_stmt|;
try|try
block|{
name|int
name|start
init|=
literal|0
decl_stmt|;
name|int
name|step
init|=
name|jhLogFiles
operator|.
name|length
operator|/
name|NUM_CREATE_THREADS
operator|+
operator|(
operator|(
name|jhLogFiles
operator|.
name|length
operator|%
name|NUM_CREATE_THREADS
operator|)
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|FileCreateDaemon
index|[]
name|daemons
init|=
operator|new
name|FileCreateDaemon
index|[
name|NUM_CREATE_THREADS
index|]
decl_stmt|;
name|numRunningThreads
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|tIdx
init|=
literal|0
init|;
name|tIdx
operator|<
name|NUM_CREATE_THREADS
operator|&&
name|start
operator|<
name|jhLogFiles
operator|.
name|length
condition|;
name|tIdx
operator|++
control|)
block|{
name|int
name|end
init|=
name|Math
operator|.
name|min
argument_list|(
name|start
operator|+
name|step
argument_list|,
name|jhLogFiles
operator|.
name|length
argument_list|)
decl_stmt|;
name|daemons
index|[
name|tIdx
index|]
operator|=
operator|new
name|FileCreateDaemon
argument_list|(
name|fs
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|start
operator|+=
name|step
expr_stmt|;
name|numRunningThreads
operator|++
expr_stmt|;
block|}
for|for
control|(
name|int
name|tIdx
init|=
literal|0
init|;
name|tIdx
operator|<
name|numRunningThreads
condition|;
name|tIdx
operator|++
control|)
block|{
name|daemons
index|[
name|tIdx
index|]
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|int
name|prevValue
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|numFinishedThreads
operator|<
name|numRunningThreads
condition|)
block|{
if|if
condition|(
name|prevValue
operator|<
name|numFinishedThreads
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Finished "
operator|+
name|numFinishedThreads
operator|+
literal|" threads out of "
operator|+
name|numRunningThreads
argument_list|)
expr_stmt|;
name|prevValue
operator|=
name|numFinishedThreads
expr_stmt|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|500
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{}
block|}
block|}
block|}
block|}
DECL|method|createControlFile (FileSystem fs, Path jhLogDir )
specifier|private
specifier|static
name|void
name|createControlFile
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|jhLogDir
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"creating control file: JH log dir = "
operator|+
name|jhLogDir
argument_list|)
expr_stmt|;
name|FileCreateDaemon
operator|.
name|createControlFile
argument_list|(
name|fs
argument_list|,
name|jhLogDir
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"created control file: JH log dir = "
operator|+
name|jhLogDir
argument_list|)
expr_stmt|;
block|}
DECL|method|getFileName (int fIdx)
specifier|private
specifier|static
name|String
name|getFileName
parameter_list|(
name|int
name|fIdx
parameter_list|)
block|{
return|return
name|BASE_INPUT_FILE_NAME
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|fIdx
argument_list|)
return|;
block|}
comment|/**    * If keyVal is of the form KEY="VALUE", then this will return [KEY, VALUE]    */
DECL|method|getKeyValue (String t)
specifier|private
specifier|static
name|String
index|[]
name|getKeyValue
parameter_list|(
name|String
name|t
parameter_list|)
throws|throws
name|IOException
block|{
name|String
index|[]
name|keyVal
init|=
name|t
operator|.
name|split
argument_list|(
literal|"=\"*|\""
argument_list|)
decl_stmt|;
return|return
name|keyVal
return|;
block|}
comment|/**    * JobHistory log record.    */
DECL|class|JobHistoryLog
specifier|private
specifier|static
class|class
name|JobHistoryLog
block|{
DECL|field|JOBID
name|String
name|JOBID
decl_stmt|;
DECL|field|JOB_STATUS
name|String
name|JOB_STATUS
decl_stmt|;
DECL|field|SUBMIT_TIME
name|long
name|SUBMIT_TIME
decl_stmt|;
DECL|field|LAUNCH_TIME
name|long
name|LAUNCH_TIME
decl_stmt|;
DECL|field|FINISH_TIME
name|long
name|FINISH_TIME
decl_stmt|;
DECL|field|TOTAL_MAPS
name|long
name|TOTAL_MAPS
decl_stmt|;
DECL|field|TOTAL_REDUCES
name|long
name|TOTAL_REDUCES
decl_stmt|;
DECL|field|FINISHED_MAPS
name|long
name|FINISHED_MAPS
decl_stmt|;
DECL|field|FINISHED_REDUCES
name|long
name|FINISHED_REDUCES
decl_stmt|;
DECL|field|USER
name|String
name|USER
decl_stmt|;
DECL|field|tasks
name|Map
argument_list|<
name|String
argument_list|,
name|TaskHistoryLog
argument_list|>
name|tasks
decl_stmt|;
DECL|method|isSuccessful ()
name|boolean
name|isSuccessful
parameter_list|()
block|{
return|return
operator|(
name|JOB_STATUS
operator|!=
literal|null
operator|)
operator|&&
name|JOB_STATUS
operator|.
name|equals
argument_list|(
literal|"SUCCESS"
argument_list|)
return|;
block|}
DECL|method|parseLine (String line)
name|void
name|parseLine
parameter_list|(
name|String
name|line
parameter_list|)
throws|throws
name|IOException
block|{
name|StringTokenizer
name|tokens
init|=
operator|new
name|StringTokenizer
argument_list|(
name|line
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tokens
operator|.
name|hasMoreTokens
argument_list|()
condition|)
return|return;
name|String
name|what
init|=
name|tokens
operator|.
name|nextToken
argument_list|()
decl_stmt|;
comment|// Line should start with one of the following:
comment|// Job, Task, MapAttempt, ReduceAttempt
if|if
condition|(
name|what
operator|.
name|equals
argument_list|(
literal|"Job"
argument_list|)
condition|)
name|updateJob
argument_list|(
name|tokens
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|what
operator|.
name|equals
argument_list|(
literal|"Task"
argument_list|)
condition|)
name|updateTask
argument_list|(
name|tokens
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|what
operator|.
name|indexOf
argument_list|(
literal|"Attempt"
argument_list|)
operator|>=
literal|0
condition|)
name|updateTaskAttempt
argument_list|(
name|tokens
argument_list|)
expr_stmt|;
block|}
DECL|method|updateJob (StringTokenizer tokens)
specifier|private
name|void
name|updateJob
parameter_list|(
name|StringTokenizer
name|tokens
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
name|tokens
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|t
init|=
name|tokens
operator|.
name|nextToken
argument_list|()
decl_stmt|;
name|String
index|[]
name|keyVal
init|=
name|getKeyValue
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyVal
operator|.
name|length
operator|<
literal|2
condition|)
continue|continue;
if|if
condition|(
name|keyVal
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"JOBID"
argument_list|)
condition|)
block|{
if|if
condition|(
name|JOBID
operator|==
literal|null
condition|)
name|JOBID
operator|=
operator|new
name|String
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|JOBID
operator|.
name|equals
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Incorrect JOBID: "
operator|+
name|keyVal
index|[
literal|1
index|]
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|keyVal
index|[
literal|1
index|]
operator|.
name|length
argument_list|()
argument_list|,
literal|100
argument_list|)
argument_list|)
operator|+
literal|" expect "
operator|+
name|JOBID
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|keyVal
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"JOB_STATUS"
argument_list|)
condition|)
name|JOB_STATUS
operator|=
operator|new
name|String
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|keyVal
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"SUBMIT_TIME"
argument_list|)
condition|)
name|SUBMIT_TIME
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|keyVal
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"LAUNCH_TIME"
argument_list|)
condition|)
name|LAUNCH_TIME
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|keyVal
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"FINISH_TIME"
argument_list|)
condition|)
name|FINISH_TIME
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|keyVal
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"TOTAL_MAPS"
argument_list|)
condition|)
name|TOTAL_MAPS
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|keyVal
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"TOTAL_REDUCES"
argument_list|)
condition|)
name|TOTAL_REDUCES
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|keyVal
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"FINISHED_MAPS"
argument_list|)
condition|)
name|FINISHED_MAPS
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|keyVal
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"FINISHED_REDUCES"
argument_list|)
condition|)
name|FINISHED_REDUCES
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|keyVal
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"USER"
argument_list|)
condition|)
name|USER
operator|=
operator|new
name|String
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|updateTask (StringTokenizer tokens)
specifier|private
name|void
name|updateTask
parameter_list|(
name|StringTokenizer
name|tokens
parameter_list|)
throws|throws
name|IOException
block|{
comment|// unpack
name|TaskHistoryLog
name|task
init|=
operator|new
name|TaskHistoryLog
argument_list|()
operator|.
name|parse
argument_list|(
name|tokens
argument_list|)
decl_stmt|;
if|if
condition|(
name|task
operator|.
name|TASKID
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"TASKID = NULL for job "
operator|+
name|JOBID
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// update or insert
if|if
condition|(
name|tasks
operator|==
literal|null
condition|)
name|tasks
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|TaskHistoryLog
argument_list|>
argument_list|(
call|(
name|int
call|)
argument_list|(
name|TOTAL_MAPS
operator|+
name|TOTAL_REDUCES
argument_list|)
argument_list|)
expr_stmt|;
name|TaskHistoryLog
name|existing
init|=
name|tasks
operator|.
name|get
argument_list|(
name|task
operator|.
name|TASKID
argument_list|)
decl_stmt|;
if|if
condition|(
name|existing
operator|==
literal|null
condition|)
name|tasks
operator|.
name|put
argument_list|(
name|task
operator|.
name|TASKID
argument_list|,
name|task
argument_list|)
expr_stmt|;
else|else
name|existing
operator|.
name|updateWith
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
DECL|method|updateTaskAttempt (StringTokenizer tokens)
specifier|private
name|void
name|updateTaskAttempt
parameter_list|(
name|StringTokenizer
name|tokens
parameter_list|)
throws|throws
name|IOException
block|{
comment|// unpack
name|TaskAttemptHistoryLog
name|attempt
init|=
operator|new
name|TaskAttemptHistoryLog
argument_list|()
decl_stmt|;
name|String
name|taskID
init|=
name|attempt
operator|.
name|parse
argument_list|(
name|tokens
argument_list|)
decl_stmt|;
if|if
condition|(
name|taskID
operator|==
literal|null
condition|)
return|return;
if|if
condition|(
name|tasks
operator|==
literal|null
condition|)
name|tasks
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|TaskHistoryLog
argument_list|>
argument_list|(
call|(
name|int
call|)
argument_list|(
name|TOTAL_MAPS
operator|+
name|TOTAL_REDUCES
argument_list|)
argument_list|)
expr_stmt|;
name|TaskHistoryLog
name|existing
init|=
name|tasks
operator|.
name|get
argument_list|(
name|taskID
argument_list|)
decl_stmt|;
if|if
condition|(
name|existing
operator|==
literal|null
condition|)
block|{
name|existing
operator|=
operator|new
name|TaskHistoryLog
argument_list|(
name|taskID
argument_list|)
expr_stmt|;
name|tasks
operator|.
name|put
argument_list|(
name|taskID
argument_list|,
name|existing
argument_list|)
expr_stmt|;
block|}
name|existing
operator|.
name|updateWith
argument_list|(
name|attempt
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * TaskHistory log record.    */
DECL|class|TaskHistoryLog
specifier|private
specifier|static
class|class
name|TaskHistoryLog
block|{
DECL|field|TASKID
name|String
name|TASKID
decl_stmt|;
DECL|field|TASK_TYPE
name|String
name|TASK_TYPE
decl_stmt|;
comment|// MAP, REDUCE, SETUP, CLEANUP
DECL|field|TASK_STATUS
name|String
name|TASK_STATUS
decl_stmt|;
DECL|field|START_TIME
name|long
name|START_TIME
decl_stmt|;
DECL|field|FINISH_TIME
name|long
name|FINISH_TIME
decl_stmt|;
DECL|field|attempts
name|Map
argument_list|<
name|String
argument_list|,
name|TaskAttemptHistoryLog
argument_list|>
name|attempts
decl_stmt|;
DECL|method|TaskHistoryLog ()
name|TaskHistoryLog
parameter_list|()
block|{}
DECL|method|TaskHistoryLog (String taskID)
name|TaskHistoryLog
parameter_list|(
name|String
name|taskID
parameter_list|)
block|{
name|TASKID
operator|=
name|taskID
expr_stmt|;
block|}
DECL|method|isSuccessful ()
name|boolean
name|isSuccessful
parameter_list|()
block|{
return|return
operator|(
name|TASK_STATUS
operator|!=
literal|null
operator|)
operator|&&
name|TASK_STATUS
operator|.
name|equals
argument_list|(
literal|"SUCCESS"
argument_list|)
return|;
block|}
DECL|method|parse (StringTokenizer tokens)
name|TaskHistoryLog
name|parse
parameter_list|(
name|StringTokenizer
name|tokens
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
name|tokens
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|t
init|=
name|tokens
operator|.
name|nextToken
argument_list|()
decl_stmt|;
name|String
index|[]
name|keyVal
init|=
name|getKeyValue
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyVal
operator|.
name|length
operator|<
literal|2
condition|)
continue|continue;
if|if
condition|(
name|keyVal
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"TASKID"
argument_list|)
condition|)
block|{
if|if
condition|(
name|TASKID
operator|==
literal|null
condition|)
name|TASKID
operator|=
operator|new
name|String
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TASKID
operator|.
name|equals
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Incorrect TASKID: "
operator|+
name|keyVal
index|[
literal|1
index|]
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|keyVal
index|[
literal|1
index|]
operator|.
name|length
argument_list|()
argument_list|,
literal|100
argument_list|)
argument_list|)
operator|+
literal|" expect "
operator|+
name|TASKID
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|keyVal
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"TASK_TYPE"
argument_list|)
condition|)
name|TASK_TYPE
operator|=
operator|new
name|String
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|keyVal
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"TASK_STATUS"
argument_list|)
condition|)
name|TASK_STATUS
operator|=
operator|new
name|String
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|keyVal
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"START_TIME"
argument_list|)
condition|)
name|START_TIME
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|keyVal
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"FINISH_TIME"
argument_list|)
condition|)
name|FINISH_TIME
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/**      * Update with non-null fields of the same task log record.      */
DECL|method|updateWith (TaskHistoryLog from)
name|void
name|updateWith
parameter_list|(
name|TaskHistoryLog
name|from
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|TASKID
operator|==
literal|null
condition|)
name|TASKID
operator|=
name|from
operator|.
name|TASKID
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TASKID
operator|.
name|equals
argument_list|(
name|from
operator|.
name|TASKID
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Incorrect TASKID: "
operator|+
name|from
operator|.
name|TASKID
operator|+
literal|" expect "
operator|+
name|TASKID
argument_list|)
throw|;
block|}
if|if
condition|(
name|TASK_TYPE
operator|==
literal|null
condition|)
name|TASK_TYPE
operator|=
name|from
operator|.
name|TASK_TYPE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TASK_TYPE
operator|.
name|equals
argument_list|(
name|from
operator|.
name|TASK_TYPE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Incorrect TASK_TYPE: "
operator|+
name|from
operator|.
name|TASK_TYPE
operator|+
literal|" expect "
operator|+
name|TASK_TYPE
operator|+
literal|" for task "
operator|+
name|TASKID
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|from
operator|.
name|TASK_STATUS
operator|!=
literal|null
condition|)
name|TASK_STATUS
operator|=
name|from
operator|.
name|TASK_STATUS
expr_stmt|;
if|if
condition|(
name|from
operator|.
name|START_TIME
operator|>
literal|0
condition|)
name|START_TIME
operator|=
name|from
operator|.
name|START_TIME
expr_stmt|;
if|if
condition|(
name|from
operator|.
name|FINISH_TIME
operator|>
literal|0
condition|)
name|FINISH_TIME
operator|=
name|from
operator|.
name|FINISH_TIME
expr_stmt|;
block|}
comment|/**      * Update with non-null fields of the task attempt log record.      */
DECL|method|updateWith (TaskAttemptHistoryLog attempt)
name|void
name|updateWith
parameter_list|(
name|TaskAttemptHistoryLog
name|attempt
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|attempt
operator|.
name|TASK_ATTEMPT_ID
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected TASK_ATTEMPT_ID = null for task "
operator|+
name|TASKID
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|attempts
operator|==
literal|null
condition|)
name|attempts
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|TaskAttemptHistoryLog
argument_list|>
argument_list|()
expr_stmt|;
name|TaskAttemptHistoryLog
name|existing
init|=
name|attempts
operator|.
name|get
argument_list|(
name|attempt
operator|.
name|TASK_ATTEMPT_ID
argument_list|)
decl_stmt|;
if|if
condition|(
name|existing
operator|==
literal|null
condition|)
name|attempts
operator|.
name|put
argument_list|(
name|attempt
operator|.
name|TASK_ATTEMPT_ID
argument_list|,
name|attempt
argument_list|)
expr_stmt|;
else|else
name|existing
operator|.
name|updateWith
argument_list|(
name|attempt
argument_list|)
expr_stmt|;
comment|// update task start time
if|if
condition|(
name|attempt
operator|.
name|START_TIME
operator|>
literal|0
operator|&&
operator|(
name|this
operator|.
name|START_TIME
operator|==
literal|0
operator|||
name|this
operator|.
name|START_TIME
operator|>
name|attempt
operator|.
name|START_TIME
operator|)
condition|)
name|START_TIME
operator|=
name|attempt
operator|.
name|START_TIME
expr_stmt|;
block|}
block|}
comment|/**    * TaskAttemptHistory log record.    */
DECL|class|TaskAttemptHistoryLog
specifier|private
specifier|static
class|class
name|TaskAttemptHistoryLog
block|{
DECL|field|TASK_ATTEMPT_ID
name|String
name|TASK_ATTEMPT_ID
decl_stmt|;
DECL|field|TASK_STATUS
name|String
name|TASK_STATUS
decl_stmt|;
comment|// this task attempt status
DECL|field|START_TIME
name|long
name|START_TIME
decl_stmt|;
DECL|field|FINISH_TIME
name|long
name|FINISH_TIME
decl_stmt|;
DECL|field|HDFS_BYTES_READ
name|long
name|HDFS_BYTES_READ
decl_stmt|;
DECL|field|HDFS_BYTES_WRITTEN
name|long
name|HDFS_BYTES_WRITTEN
decl_stmt|;
DECL|field|FILE_BYTES_READ
name|long
name|FILE_BYTES_READ
decl_stmt|;
DECL|field|FILE_BYTES_WRITTEN
name|long
name|FILE_BYTES_WRITTEN
decl_stmt|;
comment|/**      * Task attempt is considered successful iff all three statuses      * of the attempt, the task, and the job equal "SUCCESS".      */
DECL|method|isSuccessful ()
name|boolean
name|isSuccessful
parameter_list|()
block|{
return|return
operator|(
name|TASK_STATUS
operator|!=
literal|null
operator|)
operator|&&
name|TASK_STATUS
operator|.
name|equals
argument_list|(
literal|"SUCCESS"
argument_list|)
return|;
block|}
DECL|method|parse (StringTokenizer tokens)
name|String
name|parse
parameter_list|(
name|StringTokenizer
name|tokens
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|taskID
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|tokens
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|t
init|=
name|tokens
operator|.
name|nextToken
argument_list|()
decl_stmt|;
name|String
index|[]
name|keyVal
init|=
name|getKeyValue
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyVal
operator|.
name|length
operator|<
literal|2
condition|)
continue|continue;
if|if
condition|(
name|keyVal
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"TASKID"
argument_list|)
condition|)
block|{
if|if
condition|(
name|taskID
operator|==
literal|null
condition|)
name|taskID
operator|=
operator|new
name|String
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|taskID
operator|.
name|equals
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Incorrect TASKID: "
operator|+
name|keyVal
index|[
literal|1
index|]
operator|+
literal|" expect "
operator|+
name|taskID
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|keyVal
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"TASK_ATTEMPT_ID"
argument_list|)
condition|)
block|{
if|if
condition|(
name|TASK_ATTEMPT_ID
operator|==
literal|null
condition|)
name|TASK_ATTEMPT_ID
operator|=
operator|new
name|String
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TASK_ATTEMPT_ID
operator|.
name|equals
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Incorrect TASKID: "
operator|+
name|keyVal
index|[
literal|1
index|]
operator|+
literal|" expect "
operator|+
name|taskID
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|keyVal
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"TASK_STATUS"
argument_list|)
condition|)
name|TASK_STATUS
operator|=
operator|new
name|String
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|keyVal
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"START_TIME"
argument_list|)
condition|)
name|START_TIME
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|keyVal
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
literal|"FINISH_TIME"
argument_list|)
condition|)
name|FINISH_TIME
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|keyVal
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|taskID
return|;
block|}
comment|/**      * Update with non-null fields of the same task attempt log record.      */
DECL|method|updateWith (TaskAttemptHistoryLog from)
name|void
name|updateWith
parameter_list|(
name|TaskAttemptHistoryLog
name|from
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|TASK_ATTEMPT_ID
operator|==
literal|null
condition|)
name|TASK_ATTEMPT_ID
operator|=
name|from
operator|.
name|TASK_ATTEMPT_ID
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TASK_ATTEMPT_ID
operator|.
name|equals
argument_list|(
name|from
operator|.
name|TASK_ATTEMPT_ID
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Incorrect TASK_ATTEMPT_ID: "
operator|+
name|from
operator|.
name|TASK_ATTEMPT_ID
operator|+
literal|" expect "
operator|+
name|TASK_ATTEMPT_ID
argument_list|)
throw|;
block|}
if|if
condition|(
name|from
operator|.
name|TASK_STATUS
operator|!=
literal|null
condition|)
name|TASK_STATUS
operator|=
name|from
operator|.
name|TASK_STATUS
expr_stmt|;
if|if
condition|(
name|from
operator|.
name|START_TIME
operator|>
literal|0
condition|)
name|START_TIME
operator|=
name|from
operator|.
name|START_TIME
expr_stmt|;
if|if
condition|(
name|from
operator|.
name|FINISH_TIME
operator|>
literal|0
condition|)
name|FINISH_TIME
operator|=
name|from
operator|.
name|FINISH_TIME
expr_stmt|;
if|if
condition|(
name|from
operator|.
name|HDFS_BYTES_READ
operator|>
literal|0
condition|)
name|HDFS_BYTES_READ
operator|=
name|from
operator|.
name|HDFS_BYTES_READ
expr_stmt|;
if|if
condition|(
name|from
operator|.
name|HDFS_BYTES_WRITTEN
operator|>
literal|0
condition|)
name|HDFS_BYTES_WRITTEN
operator|=
name|from
operator|.
name|HDFS_BYTES_WRITTEN
expr_stmt|;
if|if
condition|(
name|from
operator|.
name|FILE_BYTES_READ
operator|>
literal|0
condition|)
name|FILE_BYTES_READ
operator|=
name|from
operator|.
name|FILE_BYTES_READ
expr_stmt|;
if|if
condition|(
name|from
operator|.
name|FILE_BYTES_WRITTEN
operator|>
literal|0
condition|)
name|FILE_BYTES_WRITTEN
operator|=
name|from
operator|.
name|FILE_BYTES_WRITTEN
expr_stmt|;
block|}
block|}
comment|/**    * Key = statName*date-time*taskType    * Value = number of msec for the our    */
DECL|class|IntervalKey
specifier|private
specifier|static
class|class
name|IntervalKey
block|{
DECL|field|KEY_FIELD_DELIMITER
specifier|static
specifier|final
name|String
name|KEY_FIELD_DELIMITER
init|=
literal|"*"
decl_stmt|;
DECL|field|statName
name|String
name|statName
decl_stmt|;
DECL|field|dateTime
name|String
name|dateTime
decl_stmt|;
DECL|field|taskType
name|String
name|taskType
decl_stmt|;
DECL|method|IntervalKey (String stat, long timeMSec, String taskType)
name|IntervalKey
parameter_list|(
name|String
name|stat
parameter_list|,
name|long
name|timeMSec
parameter_list|,
name|String
name|taskType
parameter_list|)
block|{
name|statName
operator|=
name|stat
expr_stmt|;
name|SimpleDateFormat
name|dateF
init|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"yyyy-MM-dd HH:mm:ss"
argument_list|)
decl_stmt|;
name|dateTime
operator|=
name|dateF
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|(
name|timeMSec
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|taskType
operator|=
name|taskType
expr_stmt|;
block|}
DECL|method|IntervalKey (String key)
name|IntervalKey
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|StringTokenizer
name|keyTokens
init|=
operator|new
name|StringTokenizer
argument_list|(
name|key
argument_list|,
name|KEY_FIELD_DELIMITER
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|keyTokens
operator|.
name|hasMoreTokens
argument_list|()
condition|)
return|return;
name|statName
operator|=
name|keyTokens
operator|.
name|nextToken
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|keyTokens
operator|.
name|hasMoreTokens
argument_list|()
condition|)
return|return;
name|dateTime
operator|=
name|keyTokens
operator|.
name|nextToken
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|keyTokens
operator|.
name|hasMoreTokens
argument_list|()
condition|)
return|return;
name|taskType
operator|=
name|keyTokens
operator|.
name|nextToken
argument_list|()
expr_stmt|;
block|}
DECL|method|setStatName (String stat)
name|void
name|setStatName
parameter_list|(
name|String
name|stat
parameter_list|)
block|{
name|statName
operator|=
name|stat
expr_stmt|;
block|}
DECL|method|getStringKey ()
name|String
name|getStringKey
parameter_list|()
block|{
return|return
name|statName
operator|+
name|KEY_FIELD_DELIMITER
operator|+
name|dateTime
operator|+
name|KEY_FIELD_DELIMITER
operator|+
name|taskType
return|;
block|}
DECL|method|getTextKey ()
name|Text
name|getTextKey
parameter_list|()
block|{
return|return
operator|new
name|Text
argument_list|(
name|getStringKey
argument_list|()
argument_list|)
return|;
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getStringKey
argument_list|()
return|;
block|}
block|}
comment|/**    * Mapper class.    */
DECL|class|JHLAMapper
specifier|private
specifier|static
class|class
name|JHLAMapper
extends|extends
name|IOMapperBase
argument_list|<
name|Object
argument_list|>
block|{
comment|/**      * A line pattern, which delimits history logs of different jobs,      * if multiple job logs are written in the same file.      * Null value means only one job log per file is expected.      * The pattern should be a regular expression as in      * {@link String#matches(String)}.      */
DECL|field|jobDelimiterPattern
name|String
name|jobDelimiterPattern
decl_stmt|;
DECL|field|maxJobDelimiterLineLength
name|int
name|maxJobDelimiterLineLength
decl_stmt|;
comment|/** Count only these users jobs */
DECL|field|usersIncluded
name|Collection
argument_list|<
name|String
argument_list|>
name|usersIncluded
decl_stmt|;
comment|/** Exclude jobs of the following users */
DECL|field|usersExcluded
name|Collection
argument_list|<
name|String
argument_list|>
name|usersExcluded
decl_stmt|;
comment|/** Type of compression for compressed files: gzip */
DECL|field|compressionClass
name|Class
argument_list|<
name|?
extends|extends
name|CompressionCodec
argument_list|>
name|compressionClass
decl_stmt|;
DECL|method|JHLAMapper ()
name|JHLAMapper
parameter_list|()
throws|throws
name|IOException
block|{     }
DECL|method|JHLAMapper (Configuration conf)
name|JHLAMapper
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|configure
argument_list|(
operator|new
name|JobConf
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|configure (JobConf conf)
specifier|public
name|void
name|configure
parameter_list|(
name|JobConf
name|conf
parameter_list|)
block|{
name|super
operator|.
name|configure
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|usersIncluded
operator|=
name|getUserList
argument_list|(
name|conf
operator|.
name|get
argument_list|(
literal|"jhla.users.included"
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|usersExcluded
operator|=
name|getUserList
argument_list|(
name|conf
operator|.
name|get
argument_list|(
literal|"jhla.users.excluded"
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|zipClassName
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"jhla.compression.class"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
try|try
block|{
name|compressionClass
operator|=
operator|(
name|zipClassName
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|Class
operator|.
name|forName
argument_list|(
name|zipClassName
argument_list|)
operator|.
name|asSubclass
argument_list|(
name|CompressionCodec
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Compression codec not found: "
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|jobDelimiterPattern
operator|=
name|conf
operator|.
name|get
argument_list|(
literal|"jhla.job.delimiter.pattern"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|maxJobDelimiterLineLength
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"jhla.job.delimiter.length"
argument_list|,
literal|512
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|map (Text key, LongWritable value, OutputCollector<Text, Text> output, Reporter reporter)
specifier|public
name|void
name|map
parameter_list|(
name|Text
name|key
parameter_list|,
name|LongWritable
name|value
parameter_list|,
name|OutputCollector
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|output
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|name
init|=
name|key
operator|.
name|toString
argument_list|()
decl_stmt|;
name|long
name|longValue
init|=
name|value
operator|.
name|get
argument_list|()
decl_stmt|;
name|reporter
operator|.
name|setStatus
argument_list|(
literal|"starting "
operator|+
name|name
operator|+
literal|" ::host = "
operator|+
name|hostName
argument_list|)
expr_stmt|;
name|long
name|tStart
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|parseLogFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
name|name
argument_list|)
argument_list|,
name|longValue
argument_list|,
name|output
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
name|long
name|tEnd
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|long
name|execTime
init|=
name|tEnd
operator|-
name|tStart
decl_stmt|;
name|reporter
operator|.
name|setStatus
argument_list|(
literal|"finished "
operator|+
name|name
operator|+
literal|" ::host = "
operator|+
name|hostName
operator|+
literal|" in "
operator|+
name|execTime
operator|/
literal|1000
operator|+
literal|" sec."
argument_list|)
expr_stmt|;
block|}
DECL|method|doIO (Reporter reporter, String path, long offset )
specifier|public
name|Object
name|doIO
parameter_list|(
name|Reporter
name|reporter
parameter_list|,
name|String
name|path
parameter_list|,
comment|// full path of history log file
name|long
name|offset
comment|// starting offset within the file
parameter_list|)
throws|throws
name|IOException
block|{
return|return
literal|null
return|;
block|}
DECL|method|collectStats (OutputCollector<Text, Text> output, String name, long execTime, Object jobObjects)
name|void
name|collectStats
parameter_list|(
name|OutputCollector
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|output
parameter_list|,
name|String
name|name
parameter_list|,
name|long
name|execTime
parameter_list|,
name|Object
name|jobObjects
parameter_list|)
throws|throws
name|IOException
block|{     }
DECL|method|isEndOfJobLog (String line)
specifier|private
name|boolean
name|isEndOfJobLog
parameter_list|(
name|String
name|line
parameter_list|)
block|{
if|if
condition|(
name|jobDelimiterPattern
operator|==
literal|null
condition|)
return|return
literal|false
return|;
return|return
name|line
operator|.
name|matches
argument_list|(
name|jobDelimiterPattern
argument_list|)
return|;
block|}
comment|/**      * Collect information about one job.      *       * @param fs - file system      * @param filePath - full path of a history log file      * @param offset - starting offset in the history log file      * @throws IOException      */
DECL|method|parseLogFile (FileSystem fs, Path filePath, long offset, OutputCollector<Text, Text> output, Reporter reporter )
specifier|public
name|void
name|parseLogFile
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|filePath
parameter_list|,
name|long
name|offset
parameter_list|,
name|OutputCollector
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|output
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
name|InputStream
name|in
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// open file& seek
name|FSDataInputStream
name|stm
init|=
name|fs
operator|.
name|open
argument_list|(
name|filePath
argument_list|)
decl_stmt|;
name|stm
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|in
operator|=
name|stm
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Opened "
operator|+
name|filePath
argument_list|)
expr_stmt|;
name|reporter
operator|.
name|setStatus
argument_list|(
literal|"Opened "
operator|+
name|filePath
argument_list|)
expr_stmt|;
comment|// get a compression filter if specified
if|if
condition|(
name|compressionClass
operator|!=
literal|null
condition|)
block|{
name|CompressionCodec
name|codec
init|=
operator|(
name|CompressionCodec
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|compressionClass
argument_list|,
operator|new
name|Configuration
argument_list|()
argument_list|)
decl_stmt|;
name|in
operator|=
name|codec
operator|.
name|createInputStream
argument_list|(
name|stm
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Codec created "
operator|+
name|filePath
argument_list|)
expr_stmt|;
name|reporter
operator|.
name|setStatus
argument_list|(
literal|"Codec created "
operator|+
name|filePath
argument_list|)
expr_stmt|;
block|}
name|BufferedReader
name|reader
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|in
argument_list|)
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Reader created "
operator|+
name|filePath
argument_list|)
expr_stmt|;
comment|// skip to the next job log start
name|long
name|processed
init|=
literal|0L
decl_stmt|;
if|if
condition|(
name|jobDelimiterPattern
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|line
init|=
name|reader
operator|.
name|readLine
argument_list|()
init|;
name|line
operator|!=
literal|null
condition|;
name|line
operator|=
name|reader
operator|.
name|readLine
argument_list|()
control|)
block|{
if|if
condition|(
operator|(
name|stm
operator|.
name|getPos
argument_list|()
operator|-
name|processed
operator|)
operator|>
literal|100000
condition|)
block|{
name|processed
operator|=
name|stm
operator|.
name|getPos
argument_list|()
expr_stmt|;
name|reporter
operator|.
name|setStatus
argument_list|(
literal|"Processing "
operator|+
name|filePath
operator|+
literal|" at "
operator|+
name|processed
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isEndOfJobLog
argument_list|(
name|line
argument_list|)
condition|)
break|break;
block|}
block|}
comment|// parse lines and update job history
name|JobHistoryLog
name|jh
init|=
operator|new
name|JobHistoryLog
argument_list|()
decl_stmt|;
name|int
name|jobLineCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|line
init|=
name|readLine
argument_list|(
name|reader
argument_list|)
init|;
name|line
operator|!=
literal|null
condition|;
name|line
operator|=
name|readLine
argument_list|(
name|reader
argument_list|)
control|)
block|{
name|jobLineCount
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|stm
operator|.
name|getPos
argument_list|()
operator|-
name|processed
operator|)
operator|>
literal|20000
condition|)
block|{
name|processed
operator|=
name|stm
operator|.
name|getPos
argument_list|()
expr_stmt|;
name|long
name|numTasks
init|=
operator|(
name|jh
operator|.
name|tasks
operator|==
literal|null
condition|?
literal|0
else|:
name|jh
operator|.
name|tasks
operator|.
name|size
argument_list|()
operator|)
decl_stmt|;
name|String
name|txt
init|=
literal|"Processing "
operator|+
name|filePath
operator|+
literal|" at "
operator|+
name|processed
operator|+
literal|" # tasks = "
operator|+
name|numTasks
decl_stmt|;
name|reporter
operator|.
name|setStatus
argument_list|(
name|txt
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|txt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isEndOfJobLog
argument_list|(
name|line
argument_list|)
condition|)
block|{
if|if
condition|(
name|jh
operator|.
name|JOBID
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Finished parsing job: "
operator|+
name|jh
operator|.
name|JOBID
operator|+
literal|" line count = "
operator|+
name|jobLineCount
argument_list|)
expr_stmt|;
name|collectJobStats
argument_list|(
name|jh
argument_list|,
name|output
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Collected stats for job: "
operator|+
name|jh
operator|.
name|JOBID
argument_list|)
expr_stmt|;
block|}
name|jh
operator|=
operator|new
name|JobHistoryLog
argument_list|()
expr_stmt|;
name|jobLineCount
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|jh
operator|.
name|parseLine
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|jh
operator|.
name|JOBID
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"JOBID = NULL in "
operator|+
name|filePath
operator|+
literal|" at "
operator|+
name|processed
argument_list|)
expr_stmt|;
return|return;
block|}
name|collectJobStats
argument_list|(
name|jh
argument_list|,
name|output
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ie
parameter_list|)
block|{
comment|// parsing errors can happen if the file has been truncated
name|LOG
operator|.
name|error
argument_list|(
literal|"JHLAMapper.parseLogFile"
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|reporter
operator|.
name|setStatus
argument_list|(
literal|"JHLAMapper.parseLogFile failed "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ie
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Job failed."
argument_list|,
name|ie
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Read lines until one ends with a " ." or "\" "      */
DECL|field|resBuffer
specifier|private
name|StringBuffer
name|resBuffer
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
DECL|method|readLine (BufferedReader reader)
specifier|private
name|String
name|readLine
parameter_list|(
name|BufferedReader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
name|resBuffer
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|reader
operator|.
name|mark
argument_list|(
name|maxJobDelimiterLineLength
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|line
init|=
name|reader
operator|.
name|readLine
argument_list|()
init|;
name|line
operator|!=
literal|null
condition|;
name|line
operator|=
name|reader
operator|.
name|readLine
argument_list|()
control|)
block|{
if|if
condition|(
name|isEndOfJobLog
argument_list|(
name|line
argument_list|)
condition|)
block|{
if|if
condition|(
name|resBuffer
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
name|resBuffer
operator|.
name|append
argument_list|(
name|line
argument_list|)
expr_stmt|;
else|else
name|reader
operator|.
name|reset
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|resBuffer
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
name|resBuffer
operator|.
name|append
argument_list|(
name|line
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|resBuffer
operator|.
name|length
argument_list|()
operator|<
literal|32000
condition|)
name|resBuffer
operator|.
name|append
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|endsWith
argument_list|(
literal|" ."
argument_list|)
operator|||
name|line
operator|.
name|endsWith
argument_list|(
literal|"\" "
argument_list|)
condition|)
block|{
break|break;
block|}
name|reader
operator|.
name|mark
argument_list|(
name|maxJobDelimiterLineLength
argument_list|)
expr_stmt|;
block|}
name|String
name|result
init|=
name|resBuffer
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|?
literal|null
else|:
name|resBuffer
operator|.
name|toString
argument_list|()
decl_stmt|;
name|resBuffer
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
DECL|method|collectPerIntervalStats (OutputCollector<Text, Text> output, long start, long finish, String taskType, StatSeries ... stats)
specifier|private
name|void
name|collectPerIntervalStats
parameter_list|(
name|OutputCollector
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|output
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|finish
parameter_list|,
name|String
name|taskType
parameter_list|,
name|StatSeries
modifier|...
name|stats
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|curInterval
init|=
operator|(
name|start
operator|/
name|DEFAULT_TIME_INTERVAL_MSEC
operator|)
operator|*
name|DEFAULT_TIME_INTERVAL_MSEC
decl_stmt|;
name|long
name|curTime
init|=
name|start
decl_stmt|;
name|long
name|accumTime
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|curTime
operator|<
name|finish
condition|)
block|{
comment|// how much of the task time belonged to current interval
name|long
name|nextInterval
init|=
name|curInterval
operator|+
name|DEFAULT_TIME_INTERVAL_MSEC
decl_stmt|;
name|long
name|intervalTime
init|=
operator|(
operator|(
name|finish
operator|<
name|nextInterval
operator|)
condition|?
name|finish
else|:
name|nextInterval
operator|)
operator|-
name|curTime
decl_stmt|;
name|IntervalKey
name|key
init|=
operator|new
name|IntervalKey
argument_list|(
literal|""
argument_list|,
name|curInterval
argument_list|,
name|taskType
argument_list|)
decl_stmt|;
name|Text
name|val
init|=
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|intervalTime
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|StatSeries
name|statName
range|:
name|stats
control|)
block|{
name|key
operator|.
name|setStatName
argument_list|(
name|statName
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|output
operator|.
name|collect
argument_list|(
name|key
operator|.
name|getTextKey
argument_list|()
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|curTime
operator|=
name|curInterval
operator|=
name|nextInterval
expr_stmt|;
name|accumTime
operator|+=
name|intervalTime
expr_stmt|;
block|}
comment|// For the pending stat speculative attempts may intersect.
comment|// Only one of them is considered pending.
assert|assert
name|accumTime
operator|==
name|finish
operator|-
name|start
operator|||
name|finish
operator|<
name|start
assert|;
block|}
DECL|method|collectJobStats (JobHistoryLog jh, OutputCollector<Text, Text> output, Reporter reporter )
specifier|private
name|void
name|collectJobStats
parameter_list|(
name|JobHistoryLog
name|jh
parameter_list|,
name|OutputCollector
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|output
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|jh
operator|==
literal|null
condition|)
return|return;
if|if
condition|(
name|jh
operator|.
name|tasks
operator|==
literal|null
condition|)
return|return;
if|if
condition|(
name|jh
operator|.
name|SUBMIT_TIME
operator|<=
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Job "
operator|+
name|jh
operator|.
name|JOBID
operator|+
literal|" SUBMIT_TIME = "
operator|+
name|jh
operator|.
name|SUBMIT_TIME
argument_list|)
throw|;
if|if
condition|(
name|usersIncluded
operator|!=
literal|null
operator|&&
operator|!
name|usersIncluded
operator|.
name|contains
argument_list|(
name|jh
operator|.
name|USER
argument_list|)
condition|)
return|return;
if|if
condition|(
name|usersExcluded
operator|!=
literal|null
operator|&&
name|usersExcluded
operator|.
name|contains
argument_list|(
name|jh
operator|.
name|USER
argument_list|)
condition|)
return|return;
name|int
name|numAttempts
init|=
literal|0
decl_stmt|;
name|long
name|totalTime
init|=
literal|0
decl_stmt|;
name|boolean
name|jobSuccess
init|=
name|jh
operator|.
name|isSuccessful
argument_list|()
decl_stmt|;
name|long
name|jobWaitTime
init|=
name|jh
operator|.
name|LAUNCH_TIME
operator|-
name|jh
operator|.
name|SUBMIT_TIME
decl_stmt|;
comment|// attemptSubmitTime is the job's SUBMIT_TIME,
comment|// or the previous attempt FINISH_TIME for all subsequent attempts
for|for
control|(
name|TaskHistoryLog
name|th
range|:
name|jh
operator|.
name|tasks
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|th
operator|.
name|attempts
operator|==
literal|null
condition|)
continue|continue;
comment|// Task is successful iff both the task and the job are a "SUCCESS"
name|long
name|attemptSubmitTime
init|=
name|jh
operator|.
name|LAUNCH_TIME
decl_stmt|;
name|boolean
name|taskSuccess
init|=
name|jobSuccess
operator|&&
name|th
operator|.
name|isSuccessful
argument_list|()
decl_stmt|;
for|for
control|(
name|TaskAttemptHistoryLog
name|tah
range|:
name|th
operator|.
name|attempts
operator|.
name|values
argument_list|()
control|)
block|{
comment|// Task attempt is considered successful iff all three statuses
comment|// of the attempt, the task, and the job equal "SUCCESS"
name|boolean
name|success
init|=
name|taskSuccess
operator|&&
name|tah
operator|.
name|isSuccessful
argument_list|()
decl_stmt|;
if|if
condition|(
name|tah
operator|.
name|START_TIME
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Start time 0 for task attempt "
operator|+
name|tah
operator|.
name|TASK_ATTEMPT_ID
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tah
operator|.
name|FINISH_TIME
operator|<
name|tah
operator|.
name|START_TIME
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Finish time "
operator|+
name|tah
operator|.
name|FINISH_TIME
operator|+
literal|" is less than "
operator|+
literal|"Start time "
operator|+
name|tah
operator|.
name|START_TIME
operator|+
literal|" for task attempt "
operator|+
name|tah
operator|.
name|TASK_ATTEMPT_ID
argument_list|)
expr_stmt|;
name|tah
operator|.
name|FINISH_TIME
operator|=
name|tah
operator|.
name|START_TIME
expr_stmt|;
block|}
if|if
condition|(
operator|!
literal|"MAP"
operator|.
name|equals
argument_list|(
name|th
operator|.
name|TASK_TYPE
argument_list|)
operator|&&
operator|!
literal|"REDUCE"
operator|.
name|equals
argument_list|(
name|th
operator|.
name|TASK_TYPE
argument_list|)
operator|&&
operator|!
literal|"CLEANUP"
operator|.
name|equals
argument_list|(
name|th
operator|.
name|TASK_TYPE
argument_list|)
operator|&&
operator|!
literal|"SETUP"
operator|.
name|equals
argument_list|(
name|th
operator|.
name|TASK_TYPE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unexpected TASK_TYPE = "
operator|+
name|th
operator|.
name|TASK_TYPE
operator|+
literal|" for attempt "
operator|+
name|tah
operator|.
name|TASK_ATTEMPT_ID
argument_list|)
expr_stmt|;
block|}
name|collectPerIntervalStats
argument_list|(
name|output
argument_list|,
name|attemptSubmitTime
argument_list|,
name|tah
operator|.
name|START_TIME
argument_list|,
name|th
operator|.
name|TASK_TYPE
argument_list|,
name|StatSeries
operator|.
name|STAT_LAUNCHED_PENDING_SLOT_TIME
argument_list|)
expr_stmt|;
name|collectPerIntervalStats
argument_list|(
name|output
argument_list|,
name|attemptSubmitTime
operator|-
name|jobWaitTime
argument_list|,
name|tah
operator|.
name|START_TIME
argument_list|,
name|th
operator|.
name|TASK_TYPE
argument_list|,
name|StatSeries
operator|.
name|STAT_SUBMIT_PENDING_SLOT_TIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|collectPerIntervalStats
argument_list|(
name|output
argument_list|,
name|tah
operator|.
name|START_TIME
argument_list|,
name|tah
operator|.
name|FINISH_TIME
argument_list|,
name|th
operator|.
name|TASK_TYPE
argument_list|,
name|StatSeries
operator|.
name|STAT_ALL_SLOT_TIME
argument_list|)
expr_stmt|;
else|else
name|collectPerIntervalStats
argument_list|(
name|output
argument_list|,
name|tah
operator|.
name|START_TIME
argument_list|,
name|tah
operator|.
name|FINISH_TIME
argument_list|,
name|th
operator|.
name|TASK_TYPE
argument_list|,
name|StatSeries
operator|.
name|STAT_ALL_SLOT_TIME
argument_list|,
name|StatSeries
operator|.
name|STAT_FAILED_SLOT_TIME
argument_list|)
expr_stmt|;
name|totalTime
operator|+=
operator|(
name|tah
operator|.
name|FINISH_TIME
operator|-
name|tah
operator|.
name|START_TIME
operator|)
expr_stmt|;
name|numAttempts
operator|++
expr_stmt|;
if|if
condition|(
name|numAttempts
operator|%
literal|500
operator|==
literal|0
condition|)
block|{
name|reporter
operator|.
name|setStatus
argument_list|(
literal|"Processing "
operator|+
name|jh
operator|.
name|JOBID
operator|+
literal|" at "
operator|+
name|numAttempts
argument_list|)
expr_stmt|;
block|}
name|attemptSubmitTime
operator|=
name|tah
operator|.
name|FINISH_TIME
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Total    Maps = "
operator|+
name|jh
operator|.
name|TOTAL_MAPS
operator|+
literal|"  Reduces = "
operator|+
name|jh
operator|.
name|TOTAL_REDUCES
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Finished Maps = "
operator|+
name|jh
operator|.
name|FINISHED_MAPS
operator|+
literal|"  Reduces = "
operator|+
name|jh
operator|.
name|FINISHED_REDUCES
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"numAttempts = "
operator|+
name|numAttempts
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"totalTime   = "
operator|+
name|totalTime
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"averageAttemptTime = "
operator|+
operator|(
name|numAttempts
operator|==
literal|0
condition|?
literal|0
else|:
name|totalTime
operator|/
name|numAttempts
operator|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"jobTotalTime = "
operator|+
operator|(
name|jh
operator|.
name|FINISH_TIME
operator|<=
name|jh
operator|.
name|SUBMIT_TIME
condition|?
literal|0
else|:
name|jh
operator|.
name|FINISH_TIME
operator|-
name|jh
operator|.
name|SUBMIT_TIME
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|JHLAPartitioner
specifier|public
specifier|static
class|class
name|JHLAPartitioner
implements|implements
name|Partitioner
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
block|{
DECL|field|NUM_REDUCERS
specifier|static
specifier|final
name|int
name|NUM_REDUCERS
init|=
literal|9
decl_stmt|;
DECL|method|configure (JobConf conf)
specifier|public
name|void
name|configure
parameter_list|(
name|JobConf
name|conf
parameter_list|)
block|{}
DECL|method|getPartition (Text key, Text value, int numPartitions)
specifier|public
name|int
name|getPartition
parameter_list|(
name|Text
name|key
parameter_list|,
name|Text
name|value
parameter_list|,
name|int
name|numPartitions
parameter_list|)
block|{
name|IntervalKey
name|intKey
init|=
operator|new
name|IntervalKey
argument_list|(
name|key
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|intKey
operator|.
name|statName
operator|.
name|equals
argument_list|(
name|StatSeries
operator|.
name|STAT_ALL_SLOT_TIME
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|intKey
operator|.
name|taskType
operator|.
name|equals
argument_list|(
literal|"MAP"
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|intKey
operator|.
name|taskType
operator|.
name|equals
argument_list|(
literal|"REDUCE"
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|intKey
operator|.
name|statName
operator|.
name|equals
argument_list|(
name|StatSeries
operator|.
name|STAT_SUBMIT_PENDING_SLOT_TIME
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|intKey
operator|.
name|taskType
operator|.
name|equals
argument_list|(
literal|"MAP"
argument_list|)
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|intKey
operator|.
name|taskType
operator|.
name|equals
argument_list|(
literal|"REDUCE"
argument_list|)
condition|)
return|return
literal|3
return|;
block|}
elseif|else
if|if
condition|(
name|intKey
operator|.
name|statName
operator|.
name|equals
argument_list|(
name|StatSeries
operator|.
name|STAT_LAUNCHED_PENDING_SLOT_TIME
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|intKey
operator|.
name|taskType
operator|.
name|equals
argument_list|(
literal|"MAP"
argument_list|)
condition|)
return|return
literal|4
return|;
elseif|else
if|if
condition|(
name|intKey
operator|.
name|taskType
operator|.
name|equals
argument_list|(
literal|"REDUCE"
argument_list|)
condition|)
return|return
literal|5
return|;
block|}
elseif|else
if|if
condition|(
name|intKey
operator|.
name|statName
operator|.
name|equals
argument_list|(
name|StatSeries
operator|.
name|STAT_FAILED_SLOT_TIME
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|intKey
operator|.
name|taskType
operator|.
name|equals
argument_list|(
literal|"MAP"
argument_list|)
condition|)
return|return
literal|6
return|;
elseif|else
if|if
condition|(
name|intKey
operator|.
name|taskType
operator|.
name|equals
argument_list|(
literal|"REDUCE"
argument_list|)
condition|)
return|return
literal|7
return|;
block|}
return|return
literal|8
return|;
block|}
block|}
DECL|method|runJHLA ( Class<? extends Mapper<Text, LongWritable, Text, Text>> mapperClass, Path outputDir, Configuration fsConfig)
specifier|private
specifier|static
name|void
name|runJHLA
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Mapper
argument_list|<
name|Text
argument_list|,
name|LongWritable
argument_list|,
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|>
name|mapperClass
parameter_list|,
name|Path
name|outputDir
parameter_list|,
name|Configuration
name|fsConfig
parameter_list|)
throws|throws
name|IOException
block|{
name|JobConf
name|job
init|=
operator|new
name|JobConf
argument_list|(
name|fsConfig
argument_list|,
name|JHLogAnalyzer
operator|.
name|class
argument_list|)
decl_stmt|;
name|job
operator|.
name|setPartitionerClass
argument_list|(
name|JHLAPartitioner
operator|.
name|class
argument_list|)
expr_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|INPUT_DIR
argument_list|)
expr_stmt|;
name|job
operator|.
name|setInputFormat
argument_list|(
name|SequenceFileInputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setMapperClass
argument_list|(
name|mapperClass
argument_list|)
expr_stmt|;
name|job
operator|.
name|setReducerClass
argument_list|(
name|AccumulatingReducer
operator|.
name|class
argument_list|)
expr_stmt|;
name|FileOutputFormat
operator|.
name|setOutputPath
argument_list|(
name|job
argument_list|,
name|outputDir
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputKeyClass
argument_list|(
name|Text
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputValueClass
argument_list|(
name|Text
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setNumReduceTasks
argument_list|(
name|JHLAPartitioner
operator|.
name|NUM_REDUCERS
argument_list|)
expr_stmt|;
name|JobClient
operator|.
name|runJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
DECL|class|LoggingCollector
specifier|private
specifier|static
class|class
name|LoggingCollector
implements|implements
name|OutputCollector
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
block|{
DECL|method|collect (Text key, Text value)
specifier|public
name|void
name|collect
parameter_list|(
name|Text
name|key
parameter_list|,
name|Text
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
name|key
operator|+
literal|" == "
operator|+
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Run job history log analyser.    */
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|Path
name|resFileName
init|=
name|RESULT_FILE
decl_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
try|try
block|{
name|conf
operator|.
name|setInt
argument_list|(
literal|"test.io.file.buffer.size"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Path
name|historyDir
init|=
name|DEFAULT_HISTORY_DIR
decl_stmt|;
name|String
name|testFile
init|=
literal|null
decl_stmt|;
name|boolean
name|cleanup
init|=
literal|false
decl_stmt|;
name|boolean
name|initControlFiles
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// parse command line
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"-historyDir"
argument_list|)
condition|)
block|{
name|historyDir
operator|=
operator|new
name|Path
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"-resFile"
argument_list|)
condition|)
block|{
name|resFileName
operator|=
operator|new
name|Path
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"-usersIncluded"
argument_list|)
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
literal|"jhla.users.included"
argument_list|,
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"-usersExcluded"
argument_list|)
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
literal|"jhla.users.excluded"
argument_list|,
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"-gzip"
argument_list|)
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
literal|"jhla.compression.class"
argument_list|,
name|GzipCodec
operator|.
name|class
operator|.
name|getCanonicalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"-jobDelimiter"
argument_list|)
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
literal|"jhla.job.delimiter.pattern"
argument_list|,
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"-jobDelimiterLength"
argument_list|)
condition|)
block|{
name|conf
operator|.
name|setInt
argument_list|(
literal|"jhla.job.delimiter.length"
argument_list|,
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"-noInit"
argument_list|)
condition|)
block|{
name|initControlFiles
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"-test"
argument_list|)
condition|)
block|{
name|testFile
operator|=
name|args
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"-clean"
argument_list|)
condition|)
block|{
name|cleanup
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equalsIgnoreCase
argument_list|(
literal|"-jobQueue"
argument_list|)
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
literal|"mapred.job.queue.name"
argument_list|,
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|startsWith
argument_list|(
literal|"-Xmx"
argument_list|)
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
literal|"mapred.child.java.opts"
argument_list|,
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printUsage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cleanup
condition|)
block|{
name|cleanup
argument_list|(
name|conf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|testFile
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Start JHLA test ============ "
argument_list|)
expr_stmt|;
name|LocalFileSystem
name|lfs
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
literal|"fs.defaultFS"
argument_list|,
literal|"file:///"
argument_list|)
expr_stmt|;
name|JHLAMapper
name|map
init|=
operator|new
name|JHLAMapper
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|map
operator|.
name|parseLogFile
argument_list|(
name|lfs
argument_list|,
operator|new
name|Path
argument_list|(
name|testFile
argument_list|)
argument_list|,
literal|0L
argument_list|,
operator|new
name|LoggingCollector
argument_list|()
argument_list|,
name|Reporter
operator|.
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|initControlFiles
condition|)
name|createControlFile
argument_list|(
name|fs
argument_list|,
name|historyDir
argument_list|)
expr_stmt|;
name|long
name|tStart
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|runJHLA
argument_list|(
name|JHLAMapper
operator|.
name|class
argument_list|,
name|OUTPUT_DIR
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|long
name|execTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|tStart
decl_stmt|;
name|analyzeResult
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
name|execTime
argument_list|,
name|resFileName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|print
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|printUsage ()
specifier|private
specifier|static
name|void
name|printUsage
parameter_list|()
block|{
name|String
name|className
init|=
name|JHLogAnalyzer
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
decl_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: "
operator|+
name|className
operator|+
literal|"\n\t[-historyDir inputDir] | [-resFile resultFile] |"
operator|+
literal|"\n\t[-usersIncluded | -usersExcluded userList] |"
operator|+
literal|"\n\t[-gzip] | [-jobDelimiter pattern] |"
operator|+
literal|"\n\t[-help | -clean | -test testFile]"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|getUserList (String users)
specifier|private
specifier|static
name|Collection
argument_list|<
name|String
argument_list|>
name|getUserList
parameter_list|(
name|String
name|users
parameter_list|)
block|{
if|if
condition|(
name|users
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|StringTokenizer
name|tokens
init|=
operator|new
name|StringTokenizer
argument_list|(
name|users
argument_list|,
literal|",;"
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|userList
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|tokens
operator|.
name|countTokens
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|tokens
operator|.
name|hasMoreTokens
argument_list|()
condition|)
name|userList
operator|.
name|add
argument_list|(
name|tokens
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|userList
return|;
block|}
comment|/**    * Result is combined from all reduce output files and is written to    * RESULT_FILE in the format    * column 1:     */
DECL|method|analyzeResult ( FileSystem fs, int testType, long execTime, Path resFileName )
specifier|private
specifier|static
name|void
name|analyzeResult
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|int
name|testType
parameter_list|,
name|long
name|execTime
parameter_list|,
name|Path
name|resFileName
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Analyzing results ..."
argument_list|)
expr_stmt|;
name|DataOutputStream
name|out
init|=
literal|null
decl_stmt|;
name|BufferedWriter
name|writer
init|=
literal|null
decl_stmt|;
try|try
block|{
name|out
operator|=
operator|new
name|DataOutputStream
argument_list|(
name|fs
operator|.
name|create
argument_list|(
name|resFileName
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|=
operator|new
name|BufferedWriter
argument_list|(
operator|new
name|OutputStreamWriter
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|"SERIES\tPERIOD\tTYPE\tSLOT_HOUR\n"
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|reduceFiles
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|OUTPUT_DIR
argument_list|)
decl_stmt|;
assert|assert
name|reduceFiles
operator|.
name|length
operator|==
name|JHLAPartitioner
operator|.
name|NUM_REDUCERS
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|JHLAPartitioner
operator|.
name|NUM_REDUCERS
condition|;
name|i
operator|++
control|)
block|{
name|DataInputStream
name|in
init|=
literal|null
decl_stmt|;
name|BufferedReader
name|lines
init|=
literal|null
decl_stmt|;
try|try
block|{
name|in
operator|=
name|fs
operator|.
name|open
argument_list|(
name|reduceFiles
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|lines
operator|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|line
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|lines
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|StringTokenizer
name|tokens
init|=
operator|new
name|StringTokenizer
argument_list|(
name|line
argument_list|,
literal|"\t*"
argument_list|)
decl_stmt|;
name|String
name|attr
init|=
name|tokens
operator|.
name|nextToken
argument_list|()
decl_stmt|;
name|String
name|dateTime
init|=
name|tokens
operator|.
name|nextToken
argument_list|()
decl_stmt|;
name|String
name|taskType
init|=
name|tokens
operator|.
name|nextToken
argument_list|()
decl_stmt|;
name|double
name|val
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|tokens
operator|.
name|nextToken
argument_list|()
argument_list|)
operator|/
operator|(
name|double
operator|)
name|DEFAULT_TIME_INTERVAL_MSEC
decl_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|attr
operator|.
name|substring
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|// skip the stat type "l:"
name|writer
operator|.
name|write
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|dateTime
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|taskType
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|writer
operator|.
name|write
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
operator|(
name|float
operator|)
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|writer
operator|.
name|newLine
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|lines
operator|!=
literal|null
condition|)
name|lines
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Analyzing results ... done."
argument_list|)
expr_stmt|;
block|}
DECL|method|cleanup (Configuration conf)
specifier|private
specifier|static
name|void
name|cleanup
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cleaning up test files"
argument_list|)
expr_stmt|;
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|fs
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|JHLA_ROOT_DIR
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

