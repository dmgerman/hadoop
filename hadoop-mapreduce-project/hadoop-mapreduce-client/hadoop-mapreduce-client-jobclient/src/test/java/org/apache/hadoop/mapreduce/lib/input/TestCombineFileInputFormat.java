begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapreduce.lib.input
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|GZIPOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|BlockLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|HdfsBlockLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSTestUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DistributedFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|MiniDFSCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|InputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|InputSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Job
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|RecordReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|CombineFileInputFormat
operator|.
name|OneBlockInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|CombineFileInputFormat
operator|.
name|OneFileInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|task
operator|.
name|TaskAttemptContextImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|Mock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|MockitoAnnotations
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|HashMultiset
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|assertj
operator|.
name|core
operator|.
name|api
operator|.
name|Assertions
operator|.
name|assertThat
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|atLeastOnce
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|times
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|reset
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|verify
import|;
end_import

begin_class
DECL|class|TestCombineFileInputFormat
specifier|public
class|class
name|TestCombineFileInputFormat
block|{
DECL|field|rack1
specifier|private
specifier|static
specifier|final
name|String
name|rack1
index|[]
init|=
operator|new
name|String
index|[]
block|{
literal|"/r1"
block|}
decl_stmt|;
DECL|field|hosts1
specifier|private
specifier|static
specifier|final
name|String
name|hosts1
index|[]
init|=
operator|new
name|String
index|[]
block|{
literal|"host1.rack1.com"
block|}
decl_stmt|;
DECL|field|rack2
specifier|private
specifier|static
specifier|final
name|String
name|rack2
index|[]
init|=
operator|new
name|String
index|[]
block|{
literal|"/r2"
block|}
decl_stmt|;
DECL|field|hosts2
specifier|private
specifier|static
specifier|final
name|String
name|hosts2
index|[]
init|=
operator|new
name|String
index|[]
block|{
literal|"host2.rack2.com"
block|}
decl_stmt|;
DECL|field|rack3
specifier|private
specifier|static
specifier|final
name|String
name|rack3
index|[]
init|=
operator|new
name|String
index|[]
block|{
literal|"/r3"
block|}
decl_stmt|;
DECL|field|hosts3
specifier|private
specifier|static
specifier|final
name|String
name|hosts3
index|[]
init|=
operator|new
name|String
index|[]
block|{
literal|"host3.rack3.com"
block|}
decl_stmt|;
DECL|field|inDir
specifier|final
name|Path
name|inDir
init|=
operator|new
name|Path
argument_list|(
literal|"/racktesting"
argument_list|)
decl_stmt|;
DECL|field|outputPath
specifier|final
name|Path
name|outputPath
init|=
operator|new
name|Path
argument_list|(
literal|"/output"
argument_list|)
decl_stmt|;
DECL|field|dir1
specifier|final
name|Path
name|dir1
init|=
operator|new
name|Path
argument_list|(
name|inDir
argument_list|,
literal|"/dir1"
argument_list|)
decl_stmt|;
DECL|field|dir2
specifier|final
name|Path
name|dir2
init|=
operator|new
name|Path
argument_list|(
name|inDir
argument_list|,
literal|"/dir2"
argument_list|)
decl_stmt|;
DECL|field|dir3
specifier|final
name|Path
name|dir3
init|=
operator|new
name|Path
argument_list|(
name|inDir
argument_list|,
literal|"/dir3"
argument_list|)
decl_stmt|;
DECL|field|dir4
specifier|final
name|Path
name|dir4
init|=
operator|new
name|Path
argument_list|(
name|inDir
argument_list|,
literal|"/dir4"
argument_list|)
decl_stmt|;
DECL|field|dir5
specifier|final
name|Path
name|dir5
init|=
operator|new
name|Path
argument_list|(
name|inDir
argument_list|,
literal|"/dir5"
argument_list|)
decl_stmt|;
DECL|field|BLOCKSIZE
specifier|static
specifier|final
name|int
name|BLOCKSIZE
init|=
literal|1024
decl_stmt|;
DECL|field|databuf
specifier|static
specifier|final
name|byte
index|[]
name|databuf
init|=
operator|new
name|byte
index|[
name|BLOCKSIZE
index|]
decl_stmt|;
annotation|@
name|Mock
DECL|field|mockList
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|mockList
decl_stmt|;
annotation|@
name|Before
DECL|method|initMocks ()
specifier|public
name|void
name|initMocks
parameter_list|()
block|{
name|MockitoAnnotations
operator|.
name|initMocks
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|field|DUMMY_FS_URI
specifier|private
specifier|static
specifier|final
name|String
name|DUMMY_FS_URI
init|=
literal|"dummyfs:///"
decl_stmt|;
comment|/** Dummy class to extend CombineFileInputFormat*/
DECL|class|DummyInputFormat
specifier|private
class|class
name|DummyInputFormat
extends|extends
name|CombineFileInputFormat
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
block|{
annotation|@
name|Override
DECL|method|createRecordReader (InputSplit split, TaskAttemptContext context)
specifier|public
name|RecordReader
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|createRecordReader
parameter_list|(
name|InputSplit
name|split
parameter_list|,
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/** Dummy class to extend CombineFileInputFormat. It allows     * non-existent files to be passed into the CombineFileInputFormat, allows    * for easy testing without having to create real files.    */
DECL|class|DummyInputFormat1
specifier|private
class|class
name|DummyInputFormat1
extends|extends
name|DummyInputFormat
block|{
annotation|@
name|Override
DECL|method|listStatus (JobContext job)
specifier|protected
name|List
argument_list|<
name|FileStatus
argument_list|>
name|listStatus
parameter_list|(
name|JobContext
name|job
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
index|[]
name|files
init|=
name|getInputPaths
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|FileStatus
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|files
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Path
name|p
init|=
name|files
index|[
name|i
index|]
decl_stmt|;
name|FileSystem
name|fs
init|=
name|p
operator|.
name|getFileSystem
argument_list|(
name|job
operator|.
name|getConfiguration
argument_list|()
argument_list|)
decl_stmt|;
name|results
operator|.
name|add
argument_list|(
name|fs
operator|.
name|getFileStatus
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
block|}
comment|/** Dummy class to extend CombineFileInputFormat. It allows    * testing with files having missing blocks without actually removing replicas.    */
DECL|class|MissingBlockFileSystem
specifier|public
specifier|static
class|class
name|MissingBlockFileSystem
extends|extends
name|DistributedFileSystem
block|{
DECL|field|fileWithMissingBlocks
name|String
name|fileWithMissingBlocks
decl_stmt|;
annotation|@
name|Override
DECL|method|initialize (URI name, Configuration conf)
specifier|public
name|void
name|initialize
parameter_list|(
name|URI
name|name
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|fileWithMissingBlocks
operator|=
literal|""
expr_stmt|;
name|super
operator|.
name|initialize
argument_list|(
name|name
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getFileBlockLocations ( FileStatus stat, long start, long len)
specifier|public
name|BlockLocation
index|[]
name|getFileBlockLocations
parameter_list|(
name|FileStatus
name|stat
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|stat
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"File "
operator|+
name|stat
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|name
init|=
name|stat
operator|.
name|getPath
argument_list|()
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|BlockLocation
index|[]
name|locs
init|=
name|super
operator|.
name|getFileBlockLocations
argument_list|(
name|stat
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
name|fileWithMissingBlocks
argument_list|)
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Returning missing blocks for "
operator|+
name|fileWithMissingBlocks
argument_list|)
expr_stmt|;
name|locs
index|[
literal|0
index|]
operator|=
operator|new
name|HdfsBlockLocation
argument_list|(
operator|new
name|BlockLocation
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|,
operator|new
name|String
index|[
literal|0
index|]
argument_list|,
name|locs
index|[
literal|0
index|]
operator|.
name|getOffset
argument_list|()
argument_list|,
name|locs
index|[
literal|0
index|]
operator|.
name|getLength
argument_list|()
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
return|return
name|locs
return|;
block|}
DECL|method|setFileWithMissingBlocks (String f)
specifier|public
name|void
name|setFileWithMissingBlocks
parameter_list|(
name|String
name|f
parameter_list|)
block|{
name|fileWithMissingBlocks
operator|=
name|f
expr_stmt|;
block|}
block|}
DECL|field|DUMMY_KEY
specifier|private
specifier|static
specifier|final
name|String
name|DUMMY_KEY
init|=
literal|"dummy.rr.key"
decl_stmt|;
DECL|class|DummyRecordReader
specifier|private
specifier|static
class|class
name|DummyRecordReader
extends|extends
name|RecordReader
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
block|{
DECL|field|context
specifier|private
name|TaskAttemptContext
name|context
decl_stmt|;
DECL|field|s
specifier|private
name|CombineFileSplit
name|s
decl_stmt|;
DECL|field|idx
specifier|private
name|int
name|idx
decl_stmt|;
DECL|field|used
specifier|private
name|boolean
name|used
decl_stmt|;
DECL|method|DummyRecordReader (CombineFileSplit split, TaskAttemptContext context, Integer i)
specifier|public
name|DummyRecordReader
parameter_list|(
name|CombineFileSplit
name|split
parameter_list|,
name|TaskAttemptContext
name|context
parameter_list|,
name|Integer
name|i
parameter_list|)
block|{
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|this
operator|.
name|idx
operator|=
name|i
expr_stmt|;
name|this
operator|.
name|s
operator|=
name|split
expr_stmt|;
name|this
operator|.
name|used
operator|=
literal|true
expr_stmt|;
block|}
comment|/** @return a value specified in the context to check whether the      * context is properly updated by the initialize() method.      */
DECL|method|getDummyConfVal ()
specifier|public
name|String
name|getDummyConfVal
parameter_list|()
block|{
return|return
name|this
operator|.
name|context
operator|.
name|getConfiguration
argument_list|()
operator|.
name|get
argument_list|(
name|DUMMY_KEY
argument_list|)
return|;
block|}
DECL|method|initialize (InputSplit split, TaskAttemptContext context)
specifier|public
name|void
name|initialize
parameter_list|(
name|InputSplit
name|split
parameter_list|,
name|TaskAttemptContext
name|context
parameter_list|)
block|{
name|this
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|this
operator|.
name|s
operator|=
operator|(
name|CombineFileSplit
operator|)
name|split
expr_stmt|;
comment|// By setting used to true in the c'tor, but false in initialize,
comment|// we can check that initialize() is always called before use
comment|// (e.g., in testReinit()).
name|this
operator|.
name|used
operator|=
literal|false
expr_stmt|;
block|}
DECL|method|nextKeyValue ()
specifier|public
name|boolean
name|nextKeyValue
parameter_list|()
block|{
name|boolean
name|ret
init|=
operator|!
name|used
decl_stmt|;
name|this
operator|.
name|used
operator|=
literal|true
expr_stmt|;
return|return
name|ret
return|;
block|}
DECL|method|getCurrentKey ()
specifier|public
name|Text
name|getCurrentKey
parameter_list|()
block|{
return|return
operator|new
name|Text
argument_list|(
name|this
operator|.
name|context
operator|.
name|getConfiguration
argument_list|()
operator|.
name|get
argument_list|(
name|DUMMY_KEY
argument_list|)
argument_list|)
return|;
block|}
DECL|method|getCurrentValue ()
specifier|public
name|Text
name|getCurrentValue
parameter_list|()
block|{
return|return
operator|new
name|Text
argument_list|(
name|this
operator|.
name|s
operator|.
name|getPath
argument_list|(
name|idx
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
DECL|method|getProgress ()
specifier|public
name|float
name|getProgress
parameter_list|()
block|{
return|return
name|used
condition|?
literal|1.0f
else|:
literal|0.0f
return|;
block|}
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
block|{     }
block|}
comment|/** Extend CFIF to use CFRR with DummyRecordReader */
DECL|class|ChildRRInputFormat
specifier|private
class|class
name|ChildRRInputFormat
extends|extends
name|CombineFileInputFormat
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Override
DECL|method|createRecordReader (InputSplit split, TaskAttemptContext context)
specifier|public
name|RecordReader
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|createRecordReader
parameter_list|(
name|InputSplit
name|split
parameter_list|,
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|CombineFileRecordReader
argument_list|(
operator|(
name|CombineFileSplit
operator|)
name|split
argument_list|,
name|context
argument_list|,
operator|(
name|Class
operator|)
name|DummyRecordReader
operator|.
name|class
argument_list|)
return|;
block|}
block|}
annotation|@
name|Test
DECL|method|testRecordReaderInit ()
specifier|public
name|void
name|testRecordReaderInit
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|IOException
block|{
comment|// Test that we properly initialize the child recordreader when
comment|// CombineFileInputFormat and CombineFileRecordReader are used.
name|TaskAttemptID
name|taskId
init|=
operator|new
name|TaskAttemptID
argument_list|(
literal|"jt"
argument_list|,
literal|0
argument_list|,
name|TaskType
operator|.
name|MAP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|Configuration
name|conf1
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|conf1
operator|.
name|set
argument_list|(
name|DUMMY_KEY
argument_list|,
literal|"STATE1"
argument_list|)
expr_stmt|;
name|TaskAttemptContext
name|context1
init|=
operator|new
name|TaskAttemptContextImpl
argument_list|(
name|conf1
argument_list|,
name|taskId
argument_list|)
decl_stmt|;
comment|// This will create a CombineFileRecordReader that itself contains a
comment|// DummyRecordReader.
name|InputFormat
name|inputFormat
init|=
operator|new
name|ChildRRInputFormat
argument_list|()
decl_stmt|;
name|Path
index|[]
name|files
init|=
block|{
operator|new
name|Path
argument_list|(
literal|"file1"
argument_list|)
block|}
decl_stmt|;
name|long
index|[]
name|lengths
init|=
block|{
literal|1
block|}
decl_stmt|;
name|CombineFileSplit
name|split
init|=
operator|new
name|CombineFileSplit
argument_list|(
name|files
argument_list|,
name|lengths
argument_list|)
decl_stmt|;
name|RecordReader
name|rr
init|=
name|inputFormat
operator|.
name|createRecordReader
argument_list|(
name|split
argument_list|,
name|context1
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Unexpected RR type!"
argument_list|,
name|rr
operator|instanceof
name|CombineFileRecordReader
argument_list|)
expr_stmt|;
comment|// Verify that the initial configuration is the one being used.
comment|// Right after construction the dummy key should have value "STATE1"
name|assertEquals
argument_list|(
literal|"Invalid initial dummy key value"
argument_list|,
literal|"STATE1"
argument_list|,
name|rr
operator|.
name|getCurrentKey
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Switch the active context for the RecordReader...
name|Configuration
name|conf2
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|conf2
operator|.
name|set
argument_list|(
name|DUMMY_KEY
argument_list|,
literal|"STATE2"
argument_list|)
expr_stmt|;
name|TaskAttemptContext
name|context2
init|=
operator|new
name|TaskAttemptContextImpl
argument_list|(
name|conf2
argument_list|,
name|taskId
argument_list|)
decl_stmt|;
name|rr
operator|.
name|initialize
argument_list|(
name|split
argument_list|,
name|context2
argument_list|)
expr_stmt|;
comment|// And verify that the new context is updated into the child record reader.
name|assertEquals
argument_list|(
literal|"Invalid secondary dummy key value"
argument_list|,
literal|"STATE2"
argument_list|,
name|rr
operator|.
name|getCurrentKey
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testReinit ()
specifier|public
name|void
name|testReinit
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Test that a split containing multiple files works correctly,
comment|// with the child RecordReader getting its initialize() method
comment|// called a second time.
name|TaskAttemptID
name|taskId
init|=
operator|new
name|TaskAttemptID
argument_list|(
literal|"jt"
argument_list|,
literal|0
argument_list|,
name|TaskType
operator|.
name|MAP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|TaskAttemptContext
name|context
init|=
operator|new
name|TaskAttemptContextImpl
argument_list|(
name|conf
argument_list|,
name|taskId
argument_list|)
decl_stmt|;
comment|// This will create a CombineFileRecordReader that itself contains a
comment|// DummyRecordReader.
name|InputFormat
name|inputFormat
init|=
operator|new
name|ChildRRInputFormat
argument_list|()
decl_stmt|;
name|Path
index|[]
name|files
init|=
block|{
operator|new
name|Path
argument_list|(
literal|"file1"
argument_list|)
block|,
operator|new
name|Path
argument_list|(
literal|"file2"
argument_list|)
block|}
decl_stmt|;
name|long
index|[]
name|lengths
init|=
block|{
literal|1
block|,
literal|1
block|}
decl_stmt|;
name|CombineFileSplit
name|split
init|=
operator|new
name|CombineFileSplit
argument_list|(
name|files
argument_list|,
name|lengths
argument_list|)
decl_stmt|;
name|RecordReader
name|rr
init|=
name|inputFormat
operator|.
name|createRecordReader
argument_list|(
name|split
argument_list|,
name|context
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Unexpected RR type!"
argument_list|,
name|rr
operator|instanceof
name|CombineFileRecordReader
argument_list|)
expr_stmt|;
comment|// first initialize() call comes from MapTask. We'll do it here.
name|rr
operator|.
name|initialize
argument_list|(
name|split
argument_list|,
name|context
argument_list|)
expr_stmt|;
comment|// First value is first filename.
name|assertTrue
argument_list|(
name|rr
operator|.
name|nextKeyValue
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"file1"
argument_list|,
name|rr
operator|.
name|getCurrentValue
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// The inner RR will return false, because it only emits one (k, v) pair.
comment|// But there's another sub-split to process. This returns true to us.
name|assertTrue
argument_list|(
name|rr
operator|.
name|nextKeyValue
argument_list|()
argument_list|)
expr_stmt|;
comment|// And the 2nd rr will have its initialize method called correctly.
name|assertEquals
argument_list|(
literal|"file2"
argument_list|,
name|rr
operator|.
name|getCurrentValue
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// But after both child RR's have returned their singleton (k, v), this
comment|// should also return false.
name|assertFalse
argument_list|(
name|rr
operator|.
name|nextKeyValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * For testing each split has the expected name, length, and offset.    */
DECL|class|Split
specifier|private
specifier|final
class|class
name|Split
block|{
DECL|field|name
specifier|private
name|String
name|name
decl_stmt|;
DECL|field|length
specifier|private
name|long
name|length
decl_stmt|;
DECL|field|offset
specifier|private
name|long
name|offset
decl_stmt|;
DECL|method|Split (String name, long length, long offset)
specifier|public
name|Split
parameter_list|(
name|String
name|name
parameter_list|,
name|long
name|length
parameter_list|,
name|long
name|offset
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|this
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
block|}
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
DECL|method|getLength ()
specifier|public
name|long
name|getLength
parameter_list|()
block|{
return|return
name|length
return|;
block|}
DECL|method|getOffset ()
specifier|public
name|long
name|getOffset
parameter_list|()
block|{
return|return
name|offset
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object obj)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|instanceof
name|Split
condition|)
block|{
name|Split
name|split
init|=
operator|(
operator|(
name|Split
operator|)
name|obj
operator|)
decl_stmt|;
return|return
name|split
operator|.
name|name
operator|.
name|equals
argument_list|(
name|name
argument_list|)
operator|&&
name|split
operator|.
name|length
operator|==
name|length
operator|&&
name|split
operator|.
name|offset
operator|==
name|offset
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
comment|/**    * The test suppresses unchecked warnings in    * {@link org.mockito.Mockito#reset}. Although calling the method is    * a bad manner, we call the method instead of splitting the test    * (i.e. restarting MiniDFSCluster) to save time.    */
annotation|@
name|Test
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|testSplitPlacement ()
specifier|public
name|void
name|testSplitPlacement
parameter_list|()
throws|throws
name|Exception
block|{
name|MiniDFSCluster
name|dfs
init|=
literal|null
decl_stmt|;
name|FileSystem
name|fileSys
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|/* Start 3 datanodes, one each in rack r1, r2, r3. Create five files        * 1) file1 and file5, just after starting the datanode on r1, with         *    a repl factor of 1, and,        * 2) file2, just after starting the datanode on r2, with         *    a repl factor of 2, and,        * 3) file3, file4 after starting the all three datanodes, with a repl         *    factor of 3.        * At the end, file1, file5 will be present on only datanode1, file2 will         * be present on datanode 1 and datanode2 and         * file3, file4 will be present on all datanodes.         */
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
literal|"dfs.replication.considerLoad"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|dfs
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|racks
argument_list|(
name|rack1
argument_list|)
operator|.
name|hosts
argument_list|(
name|hosts1
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|dfs
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fileSys
operator|=
name|dfs
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fileSys
operator|.
name|mkdirs
argument_list|(
name|inDir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mkdirs failed to create "
operator|+
name|inDir
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|Path
name|file1
init|=
operator|new
name|Path
argument_list|(
name|dir1
operator|+
literal|"/file1"
argument_list|)
decl_stmt|;
name|writeFile
argument_list|(
name|conf
argument_list|,
name|file1
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// create another file on the same datanode
name|Path
name|file5
init|=
operator|new
name|Path
argument_list|(
name|dir5
operator|+
literal|"/file5"
argument_list|)
decl_stmt|;
name|writeFile
argument_list|(
name|conf
argument_list|,
name|file5
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// split it using a CombinedFile input format
name|DummyInputFormat
name|inFormat
init|=
operator|new
name|DummyInputFormat
argument_list|()
decl_stmt|;
name|Job
name|job
init|=
name|Job
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|dir1
operator|+
literal|","
operator|+
name|dir5
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|InputSplit
argument_list|>
name|splits
init|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Made splits(Test0): "
operator|+
name|splits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"File split(Test0): "
operator|+
name|split
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|splits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|CombineFileSplit
name|fileSplit
init|=
operator|(
name|CombineFileSplit
operator|)
name|splits
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file1
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|BLOCKSIZE
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file5
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|1
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|BLOCKSIZE
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dfs
operator|.
name|startDataNodes
argument_list|(
name|conf
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
name|rack2
argument_list|,
name|hosts2
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|dfs
operator|.
name|waitActive
argument_list|()
expr_stmt|;
comment|// create file on two datanodes.
name|Path
name|file2
init|=
operator|new
name|Path
argument_list|(
name|dir2
operator|+
literal|"/file2"
argument_list|)
decl_stmt|;
name|writeFile
argument_list|(
name|conf
argument_list|,
name|file2
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|// split it using a CombinedFile input format
name|inFormat
operator|=
operator|new
name|DummyInputFormat
argument_list|()
expr_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|dir1
operator|+
literal|","
operator|+
name|dir2
argument_list|)
expr_stmt|;
name|inFormat
operator|.
name|setMinSplitSizeRack
argument_list|(
name|BLOCKSIZE
argument_list|)
expr_stmt|;
name|splits
operator|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Made splits(Test1): "
operator|+
name|splits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"File split(Test1): "
operator|+
name|split
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|fileSplit
operator|=
operator|(
name|CombineFileSplit
operator|)
name|split
expr_stmt|;
comment|/**          * If rack1 is processed first by          * {@link CombineFileInputFormat#createSplits},          * create only one split on rack1. Otherwise create two splits.          */
if|if
condition|(
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
comment|// first split is on rack2, contains file2
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file2
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|BLOCKSIZE
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file2
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|1
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|BLOCKSIZE
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|BLOCKSIZE
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts2
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|// second split is on rack1, contains file1
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file1
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|BLOCKSIZE
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// first split is on rack1, contains file1 and file2.
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|Split
argument_list|>
name|expected
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file1
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file2
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file2
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
name|BLOCKSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Split
argument_list|>
name|actual
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|fileSplit
operator|.
name|getPath
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|long
name|length
init|=
name|fileSplit
operator|.
name|getLength
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|offset
init|=
name|fileSplit
operator|.
name|getOffset
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|actual
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|name
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|actual
operator|.
name|containsAll
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fail
argument_list|(
literal|"Expected split size is 1 or 2, but actual size is "
operator|+
name|splits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// create another file on 3 datanodes and 3 racks.
name|dfs
operator|.
name|startDataNodes
argument_list|(
name|conf
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
name|rack3
argument_list|,
name|hosts3
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|dfs
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|Path
name|file3
init|=
operator|new
name|Path
argument_list|(
name|dir3
operator|+
literal|"/file3"
argument_list|)
decl_stmt|;
name|writeFile
argument_list|(
name|conf
argument_list|,
operator|new
name|Path
argument_list|(
name|dir3
operator|+
literal|"/file3"
argument_list|)
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|inFormat
operator|=
operator|new
name|DummyInputFormat
argument_list|()
expr_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|dir1
operator|+
literal|","
operator|+
name|dir2
operator|+
literal|","
operator|+
name|dir3
argument_list|)
expr_stmt|;
name|inFormat
operator|.
name|setMinSplitSizeRack
argument_list|(
name|BLOCKSIZE
argument_list|)
expr_stmt|;
name|splits
operator|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"File split(Test2): "
operator|+
name|split
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|Split
argument_list|>
name|expected
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file1
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file2
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file2
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
name|BLOCKSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file3
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file3
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
name|BLOCKSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file3
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
name|BLOCKSIZE
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Split
argument_list|>
name|actual
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|fileSplit
operator|=
operator|(
name|CombineFileSplit
operator|)
name|split
expr_stmt|;
comment|/**          * If rack1 is processed first by          * {@link CombineFileInputFormat#createSplits},          * create only one split on rack1.          * If rack2 or rack3 is processed first and rack1 is processed second,          * create one split on rack2 or rack3 and the other split is on rack1.          * Otherwise create 3 splits for each rack.          */
if|if
condition|(
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|3
condition|)
block|{
comment|// first split is on rack3, contains file3
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file3
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|BLOCKSIZE
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file3
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|1
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|BLOCKSIZE
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|BLOCKSIZE
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file3
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|2
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
operator|*
name|BLOCKSIZE
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|BLOCKSIZE
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts3
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|// second split is on rack2, contains file2
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file2
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|BLOCKSIZE
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file2
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|1
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|BLOCKSIZE
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|BLOCKSIZE
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts2
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|// third split is on rack1, contains file1
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file1
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|BLOCKSIZE
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
comment|// first split is on rack2 or rack3, contains one or two files.
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
name|hosts2
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
name|hosts3
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fail
argument_list|(
literal|"First split should be on rack2 or rack3."
argument_list|)
expr_stmt|;
block|}
block|}
comment|// second split is on rack1, contains the rest files.
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// first split is rack1, contains all three files.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fail
argument_list|(
literal|"Split size should be 1, 2, or 3."
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|fileSplit
operator|.
name|getPath
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|long
name|length
init|=
name|fileSplit
operator|.
name|getLength
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|offset
init|=
name|fileSplit
operator|.
name|getOffset
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|actual
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|name
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|actual
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|actual
operator|.
name|containsAll
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
comment|// create file4 on all three racks
name|Path
name|file4
init|=
operator|new
name|Path
argument_list|(
name|dir4
operator|+
literal|"/file4"
argument_list|)
decl_stmt|;
name|writeFile
argument_list|(
name|conf
argument_list|,
name|file4
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|inFormat
operator|=
operator|new
name|DummyInputFormat
argument_list|()
expr_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|dir1
operator|+
literal|","
operator|+
name|dir2
operator|+
literal|","
operator|+
name|dir3
operator|+
literal|","
operator|+
name|dir4
argument_list|)
expr_stmt|;
name|inFormat
operator|.
name|setMinSplitSizeRack
argument_list|(
name|BLOCKSIZE
argument_list|)
expr_stmt|;
name|splits
operator|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"File split(Test3): "
operator|+
name|split
argument_list|)
expr_stmt|;
block|}
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file4
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file4
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
name|BLOCKSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file4
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
name|BLOCKSIZE
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|actual
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|fileSplit
operator|=
operator|(
name|CombineFileSplit
operator|)
name|split
expr_stmt|;
comment|/**          * If rack1 is processed first by          * {@link CombineFileInputFormat#createSplits},          * create only one split on rack1.          * If rack2 or rack3 is processed first and rack1 is processed second,          * create one split on rack2 or rack3 and the other split is on rack1.          * Otherwise create 3 splits for each rack.          */
if|if
condition|(
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|3
condition|)
block|{
comment|// first split is on rack3, contains file3 and file4
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts3
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|// second split is on rack2, contains file2
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file2
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|BLOCKSIZE
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file2
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|1
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|BLOCKSIZE
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|BLOCKSIZE
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts2
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|// third split is on rack1, contains file1
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file1
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|BLOCKSIZE
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
comment|// first split is on rack2 or rack3, contains two or three files.
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
name|hosts2
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
name|hosts3
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fail
argument_list|(
literal|"First split should be on rack2 or rack3."
argument_list|)
expr_stmt|;
block|}
block|}
comment|// second split is on rack1, contains the rest files.
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// first split is rack1, contains all four files.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|9
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fail
argument_list|(
literal|"Split size should be 1, 2, or 3."
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|fileSplit
operator|.
name|getPath
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|long
name|length
init|=
name|fileSplit
operator|.
name|getLength
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|offset
init|=
name|fileSplit
operator|.
name|getOffset
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|actual
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|name
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
literal|9
argument_list|,
name|actual
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|actual
operator|.
name|containsAll
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
comment|// maximum split size is 2 blocks
name|inFormat
operator|=
operator|new
name|DummyInputFormat
argument_list|()
expr_stmt|;
name|inFormat
operator|.
name|setMinSplitSizeNode
argument_list|(
name|BLOCKSIZE
argument_list|)
expr_stmt|;
name|inFormat
operator|.
name|setMaxSplitSize
argument_list|(
literal|2
operator|*
name|BLOCKSIZE
argument_list|)
expr_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|dir1
operator|+
literal|","
operator|+
name|dir2
operator|+
literal|","
operator|+
name|dir3
operator|+
literal|","
operator|+
name|dir4
argument_list|)
expr_stmt|;
name|splits
operator|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"File split(Test4): "
operator|+
name|split
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|splits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|actual
operator|.
name|clear
argument_list|()
expr_stmt|;
name|reset
argument_list|(
name|mockList
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|fileSplit
operator|=
operator|(
name|CombineFileSplit
operator|)
name|split
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|fileSplit
operator|.
name|getPath
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|long
name|length
init|=
name|fileSplit
operator|.
name|getLength
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|offset
init|=
name|fileSplit
operator|.
name|getOffset
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|actual
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|name
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mockList
operator|.
name|add
argument_list|(
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|9
argument_list|,
name|actual
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|actual
operator|.
name|containsAll
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
comment|// verify the splits are on all the racks
name|verify
argument_list|(
name|mockList
argument_list|,
name|atLeastOnce
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|mockList
argument_list|,
name|atLeastOnce
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|hosts2
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|mockList
argument_list|,
name|atLeastOnce
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|hosts3
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// maximum split size is 3 blocks
name|inFormat
operator|=
operator|new
name|DummyInputFormat
argument_list|()
expr_stmt|;
name|inFormat
operator|.
name|setMinSplitSizeNode
argument_list|(
name|BLOCKSIZE
argument_list|)
expr_stmt|;
name|inFormat
operator|.
name|setMaxSplitSize
argument_list|(
literal|3
operator|*
name|BLOCKSIZE
argument_list|)
expr_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|dir1
operator|+
literal|","
operator|+
name|dir2
operator|+
literal|","
operator|+
name|dir3
operator|+
literal|","
operator|+
name|dir4
argument_list|)
expr_stmt|;
name|splits
operator|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"File split(Test5): "
operator|+
name|split
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|splits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|actual
operator|.
name|clear
argument_list|()
expr_stmt|;
name|reset
argument_list|(
name|mockList
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|fileSplit
operator|=
operator|(
name|CombineFileSplit
operator|)
name|split
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|fileSplit
operator|.
name|getPath
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|long
name|length
init|=
name|fileSplit
operator|.
name|getLength
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|offset
init|=
name|fileSplit
operator|.
name|getOffset
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|actual
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|name
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mockList
operator|.
name|add
argument_list|(
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|9
argument_list|,
name|actual
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|actual
operator|.
name|containsAll
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|mockList
argument_list|,
name|atLeastOnce
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|mockList
argument_list|,
name|atLeastOnce
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|hosts2
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// maximum split size is 4 blocks
name|inFormat
operator|=
operator|new
name|DummyInputFormat
argument_list|()
expr_stmt|;
name|inFormat
operator|.
name|setMaxSplitSize
argument_list|(
literal|4
operator|*
name|BLOCKSIZE
argument_list|)
expr_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|dir1
operator|+
literal|","
operator|+
name|dir2
operator|+
literal|","
operator|+
name|dir3
operator|+
literal|","
operator|+
name|dir4
argument_list|)
expr_stmt|;
name|splits
operator|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"File split(Test6): "
operator|+
name|split
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|splits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|actual
operator|.
name|clear
argument_list|()
expr_stmt|;
name|reset
argument_list|(
name|mockList
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|fileSplit
operator|=
operator|(
name|CombineFileSplit
operator|)
name|split
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|fileSplit
operator|.
name|getPath
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|long
name|length
init|=
name|fileSplit
operator|.
name|getLength
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|offset
init|=
name|fileSplit
operator|.
name|getOffset
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|actual
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|name
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mockList
operator|.
name|add
argument_list|(
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|9
argument_list|,
name|actual
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|actual
operator|.
name|containsAll
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|mockList
argument_list|,
name|atLeastOnce
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// maximum split size is 7 blocks and min is 3 blocks
name|inFormat
operator|=
operator|new
name|DummyInputFormat
argument_list|()
expr_stmt|;
name|inFormat
operator|.
name|setMaxSplitSize
argument_list|(
literal|7
operator|*
name|BLOCKSIZE
argument_list|)
expr_stmt|;
name|inFormat
operator|.
name|setMinSplitSizeNode
argument_list|(
literal|3
operator|*
name|BLOCKSIZE
argument_list|)
expr_stmt|;
name|inFormat
operator|.
name|setMinSplitSizeRack
argument_list|(
literal|3
operator|*
name|BLOCKSIZE
argument_list|)
expr_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|dir1
operator|+
literal|","
operator|+
name|dir2
operator|+
literal|","
operator|+
name|dir3
operator|+
literal|","
operator|+
name|dir4
argument_list|)
expr_stmt|;
name|splits
operator|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"File split(Test7): "
operator|+
name|split
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|splits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|actual
operator|.
name|clear
argument_list|()
expr_stmt|;
name|reset
argument_list|(
name|mockList
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|fileSplit
operator|=
operator|(
name|CombineFileSplit
operator|)
name|split
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|fileSplit
operator|.
name|getPath
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|long
name|length
init|=
name|fileSplit
operator|.
name|getLength
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|offset
init|=
name|fileSplit
operator|.
name|getOffset
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|actual
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|name
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mockList
operator|.
name|add
argument_list|(
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|9
argument_list|,
name|actual
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|actual
operator|.
name|containsAll
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|mockList
argument_list|,
name|atLeastOnce
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Rack 1 has file1, file2 and file3 and file4
comment|// Rack 2 has file2 and file3 and file4
comment|// Rack 3 has file3 and file4
comment|// setup a filter so that only (file1 and file2) or (file3 and file4)
comment|// can be combined
name|inFormat
operator|=
operator|new
name|DummyInputFormat
argument_list|()
expr_stmt|;
name|FileInputFormat
operator|.
name|addInputPath
argument_list|(
name|job
argument_list|,
name|inDir
argument_list|)
expr_stmt|;
name|inFormat
operator|.
name|setMinSplitSizeRack
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// everything is at least rack local
name|inFormat
operator|.
name|createPool
argument_list|(
operator|new
name|TestFilter
argument_list|(
name|dir1
argument_list|)
argument_list|,
operator|new
name|TestFilter
argument_list|(
name|dir2
argument_list|)
argument_list|)
expr_stmt|;
name|splits
operator|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"File split(Test1): "
operator|+
name|split
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|fileSplit
operator|=
operator|(
name|CombineFileSplit
operator|)
name|split
expr_stmt|;
if|if
condition|(
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
comment|// first split is on rack1, contains file1 and file2.
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|expected
operator|.
name|clear
argument_list|()
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file1
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file2
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file2
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
name|BLOCKSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|actual
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|fileSplit
operator|.
name|getPath
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|long
name|length
init|=
name|fileSplit
operator|.
name|getLength
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|offset
init|=
name|fileSplit
operator|.
name|getOffset
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|actual
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|name
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|actual
operator|.
name|containsAll
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
comment|// second split contains the file3 and file4, however,
comment|// the locations is undetermined.
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|expected
operator|.
name|clear
argument_list|()
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file3
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file3
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
name|BLOCKSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file3
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
name|BLOCKSIZE
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file4
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file4
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
name|BLOCKSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file4
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
name|BLOCKSIZE
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|actual
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|fileSplit
operator|.
name|getPath
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|long
name|length
init|=
name|fileSplit
operator|.
name|getLength
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|offset
init|=
name|fileSplit
operator|.
name|getOffset
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|actual
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|name
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|actual
operator|.
name|containsAll
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|// first split is on rack2, contains file2
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|expected
operator|.
name|clear
argument_list|()
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file2
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file2
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
name|BLOCKSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|actual
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|fileSplit
operator|.
name|getPath
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|long
name|length
init|=
name|fileSplit
operator|.
name|getLength
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|offset
init|=
name|fileSplit
operator|.
name|getOffset
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|actual
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|name
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|actual
operator|.
name|containsAll
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts2
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
comment|// second split is on rack1, contains file1
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file1
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|BLOCKSIZE
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
condition|)
block|{
comment|// third split contains file3 and file4, however,
comment|// the locations is undetermined.
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|expected
operator|.
name|clear
argument_list|()
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file3
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file3
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
name|BLOCKSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file3
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
name|BLOCKSIZE
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file4
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file4
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
name|BLOCKSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file4
operator|.
name|getName
argument_list|()
argument_list|,
name|BLOCKSIZE
argument_list|,
name|BLOCKSIZE
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|actual
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|fileSplit
operator|.
name|getPath
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|long
name|length
init|=
name|fileSplit
operator|.
name|getLength
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|offset
init|=
name|fileSplit
operator|.
name|getOffset
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|actual
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|name
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|actual
operator|.
name|containsAll
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fail
argument_list|(
literal|"Split size should be 2 or 3."
argument_list|)
expr_stmt|;
block|}
block|}
comment|// measure performance when there are multiple pools and
comment|// many files in each pool.
name|int
name|numPools
init|=
literal|100
decl_stmt|;
name|int
name|numFiles
init|=
literal|1000
decl_stmt|;
name|DummyInputFormat1
name|inFormat1
init|=
operator|new
name|DummyInputFormat1
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFiles
condition|;
name|i
operator|++
control|)
block|{
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|file1
argument_list|)
expr_stmt|;
block|}
name|inFormat1
operator|.
name|setMinSplitSizeRack
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// everything is at least rack local
specifier|final
name|Path
name|dirNoMatch1
init|=
operator|new
name|Path
argument_list|(
name|inDir
argument_list|,
literal|"/dirxx"
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|dirNoMatch2
init|=
operator|new
name|Path
argument_list|(
name|inDir
argument_list|,
literal|"/diryy"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numPools
condition|;
name|i
operator|++
control|)
block|{
name|inFormat1
operator|.
name|createPool
argument_list|(
operator|new
name|TestFilter
argument_list|(
name|dirNoMatch1
argument_list|)
argument_list|,
operator|new
name|TestFilter
argument_list|(
name|dirNoMatch2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|splits
operator|=
name|inFormat1
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|long
name|end
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Elapsed time for "
operator|+
name|numPools
operator|+
literal|" pools "
operator|+
literal|" and "
operator|+
name|numFiles
operator|+
literal|" files is "
operator|+
operator|(
operator|(
name|end
operator|-
name|start
operator|)
operator|/
literal|1000
operator|)
operator|+
literal|" seconds."
argument_list|)
expr_stmt|;
comment|// This file has three whole blocks. If the maxsplit size is
comment|// half the block size, then there should be six splits.
name|inFormat
operator|=
operator|new
name|DummyInputFormat
argument_list|()
expr_stmt|;
name|inFormat
operator|.
name|setMaxSplitSize
argument_list|(
name|BLOCKSIZE
operator|/
literal|2
argument_list|)
expr_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|dir3
argument_list|)
expr_stmt|;
name|splits
operator|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"File split(Test8): "
operator|+
name|split
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
name|splits
operator|.
name|size
argument_list|()
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|dfs
operator|!=
literal|null
condition|)
block|{
name|dfs
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|writeFile (Configuration conf, Path name, short replication, int numBlocks)
specifier|static
name|void
name|writeFile
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|short
name|replication
parameter_list|,
name|int
name|numBlocks
parameter_list|)
throws|throws
name|IOException
throws|,
name|TimeoutException
throws|,
name|InterruptedException
block|{
name|FileSystem
name|fileSys
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FSDataOutputStream
name|stm
init|=
name|fileSys
operator|.
name|create
argument_list|(
name|name
argument_list|,
literal|true
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"io.file.buffer.size"
argument_list|,
literal|4096
argument_list|)
argument_list|,
name|replication
argument_list|,
operator|(
name|long
operator|)
name|BLOCKSIZE
argument_list|)
decl_stmt|;
name|writeDataAndSetReplication
argument_list|(
name|fileSys
argument_list|,
name|name
argument_list|,
name|stm
argument_list|,
name|replication
argument_list|,
name|numBlocks
argument_list|)
expr_stmt|;
block|}
comment|// Creates the gzip file and return the FileStatus
DECL|method|writeGzipFile (Configuration conf, Path name, short replication, int numBlocks)
specifier|static
name|FileStatus
name|writeGzipFile
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|short
name|replication
parameter_list|,
name|int
name|numBlocks
parameter_list|)
throws|throws
name|IOException
throws|,
name|TimeoutException
throws|,
name|InterruptedException
block|{
name|FileSystem
name|fileSys
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|GZIPOutputStream
name|out
init|=
operator|new
name|GZIPOutputStream
argument_list|(
name|fileSys
operator|.
name|create
argument_list|(
name|name
argument_list|,
literal|true
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"io.file.buffer.size"
argument_list|,
literal|4096
argument_list|)
argument_list|,
name|replication
argument_list|,
operator|(
name|long
operator|)
name|BLOCKSIZE
argument_list|)
argument_list|)
decl_stmt|;
name|writeDataAndSetReplication
argument_list|(
name|fileSys
argument_list|,
name|name
argument_list|,
name|out
argument_list|,
name|replication
argument_list|,
name|numBlocks
argument_list|)
expr_stmt|;
return|return
name|fileSys
operator|.
name|getFileStatus
argument_list|(
name|name
argument_list|)
return|;
block|}
DECL|method|writeDataAndSetReplication (FileSystem fileSys, Path name, OutputStream out, short replication, int numBlocks)
specifier|private
specifier|static
name|void
name|writeDataAndSetReplication
parameter_list|(
name|FileSystem
name|fileSys
parameter_list|,
name|Path
name|name
parameter_list|,
name|OutputStream
name|out
parameter_list|,
name|short
name|replication
parameter_list|,
name|int
name|numBlocks
parameter_list|)
throws|throws
name|IOException
throws|,
name|TimeoutException
throws|,
name|InterruptedException
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numBlocks
condition|;
name|i
operator|++
control|)
block|{
name|out
operator|.
name|write
argument_list|(
name|databuf
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|DFSTestUtil
operator|.
name|waitReplication
argument_list|(
name|fileSys
argument_list|,
name|name
argument_list|,
name|replication
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testNodeDistribution ()
specifier|public
name|void
name|testNodeDistribution
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|DummyInputFormat
name|inFormat
init|=
operator|new
name|DummyInputFormat
argument_list|()
decl_stmt|;
name|int
name|numBlocks
init|=
literal|60
decl_stmt|;
name|long
name|totLength
init|=
literal|0
decl_stmt|;
name|long
name|blockSize
init|=
literal|100
decl_stmt|;
name|int
name|numNodes
init|=
literal|10
decl_stmt|;
name|long
name|minSizeNode
init|=
literal|50
decl_stmt|;
name|long
name|minSizeRack
init|=
literal|50
decl_stmt|;
name|int
name|maxSplitSize
init|=
literal|200
decl_stmt|;
comment|// 4 blocks per split.
name|String
index|[]
name|locations
init|=
operator|new
name|String
index|[
name|numNodes
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numNodes
condition|;
name|i
operator|++
control|)
block|{
name|locations
index|[
name|i
index|]
operator|=
literal|"h"
operator|+
name|i
expr_stmt|;
block|}
name|String
index|[]
name|racks
init|=
operator|new
name|String
index|[
literal|0
index|]
decl_stmt|;
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
literal|"hdfs://file"
argument_list|)
decl_stmt|;
name|OneBlockInfo
index|[]
name|blocks
init|=
operator|new
name|OneBlockInfo
index|[
name|numBlocks
index|]
decl_stmt|;
name|int
name|hostCountBase
init|=
literal|0
decl_stmt|;
comment|// Generate block list. Replication 3 per block.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numBlocks
condition|;
name|i
operator|++
control|)
block|{
name|int
name|localHostCount
init|=
name|hostCountBase
decl_stmt|;
name|String
index|[]
name|blockHosts
init|=
operator|new
name|String
index|[
literal|3
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
block|{
name|int
name|hostNum
init|=
name|localHostCount
operator|%
name|numNodes
decl_stmt|;
name|blockHosts
index|[
name|j
index|]
operator|=
literal|"h"
operator|+
name|hostNum
expr_stmt|;
name|localHostCount
operator|++
expr_stmt|;
block|}
name|hostCountBase
operator|++
expr_stmt|;
name|blocks
index|[
name|i
index|]
operator|=
operator|new
name|OneBlockInfo
argument_list|(
name|path
argument_list|,
name|i
operator|*
name|blockSize
argument_list|,
name|blockSize
argument_list|,
name|blockHosts
argument_list|,
name|racks
argument_list|)
expr_stmt|;
name|totLength
operator|+=
name|blockSize
expr_stmt|;
block|}
name|List
argument_list|<
name|InputSplit
argument_list|>
name|splits
init|=
operator|new
name|ArrayList
argument_list|<
name|InputSplit
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|rackToNodes
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|OneBlockInfo
argument_list|>
argument_list|>
name|rackToBlocks
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|OneBlockInfo
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|OneBlockInfo
argument_list|,
name|String
index|[]
argument_list|>
name|blockToNodes
init|=
operator|new
name|HashMap
argument_list|<
name|OneBlockInfo
argument_list|,
name|String
index|[]
argument_list|>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|OneBlockInfo
argument_list|>
argument_list|>
name|nodeToBlocks
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|OneBlockInfo
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|OneFileInfo
operator|.
name|populateBlockInfo
argument_list|(
name|blocks
argument_list|,
name|rackToBlocks
argument_list|,
name|blockToNodes
argument_list|,
name|nodeToBlocks
argument_list|,
name|rackToNodes
argument_list|)
expr_stmt|;
name|inFormat
operator|.
name|createSplits
argument_list|(
name|nodeToBlocks
argument_list|,
name|blockToNodes
argument_list|,
name|rackToBlocks
argument_list|,
name|totLength
argument_list|,
name|maxSplitSize
argument_list|,
name|minSizeNode
argument_list|,
name|minSizeRack
argument_list|,
name|splits
argument_list|)
expr_stmt|;
name|int
name|expectedSplitCount
init|=
call|(
name|int
call|)
argument_list|(
name|totLength
operator|/
name|maxSplitSize
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|expectedSplitCount
argument_list|,
name|splits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// Ensure 90+% of the splits have node local blocks.
comment|// 100% locality may not always be achieved.
name|int
name|numLocalSplits
init|=
literal|0
decl_stmt|;
for|for
control|(
name|InputSplit
name|inputSplit
range|:
name|splits
control|)
block|{
name|assertEquals
argument_list|(
name|maxSplitSize
argument_list|,
name|inputSplit
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|inputSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|numLocalSplits
operator|++
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
name|numLocalSplits
operator|>=
literal|0.9
operator|*
name|splits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testNodeInputSplit ()
specifier|public
name|void
name|testNodeInputSplit
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
comment|// Regression test for MAPREDUCE-4892. There are 2 nodes with all blocks on
comment|// both nodes. The grouping ensures that both nodes get splits instead of
comment|// just the first node
name|DummyInputFormat
name|inFormat
init|=
operator|new
name|DummyInputFormat
argument_list|()
decl_stmt|;
name|int
name|numBlocks
init|=
literal|12
decl_stmt|;
name|long
name|totLength
init|=
literal|0
decl_stmt|;
name|long
name|blockSize
init|=
literal|100
decl_stmt|;
name|long
name|maxSize
init|=
literal|200
decl_stmt|;
name|long
name|minSizeNode
init|=
literal|50
decl_stmt|;
name|long
name|minSizeRack
init|=
literal|50
decl_stmt|;
name|String
index|[]
name|locations
init|=
block|{
literal|"h1"
block|,
literal|"h2"
block|}
decl_stmt|;
name|String
index|[]
name|racks
init|=
operator|new
name|String
index|[
literal|0
index|]
decl_stmt|;
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
literal|"hdfs://file"
argument_list|)
decl_stmt|;
name|OneBlockInfo
index|[]
name|blocks
init|=
operator|new
name|OneBlockInfo
index|[
name|numBlocks
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numBlocks
condition|;
operator|++
name|i
control|)
block|{
name|blocks
index|[
name|i
index|]
operator|=
operator|new
name|OneBlockInfo
argument_list|(
name|path
argument_list|,
name|i
operator|*
name|blockSize
argument_list|,
name|blockSize
argument_list|,
name|locations
argument_list|,
name|racks
argument_list|)
expr_stmt|;
name|totLength
operator|+=
name|blockSize
expr_stmt|;
block|}
name|List
argument_list|<
name|InputSplit
argument_list|>
name|splits
init|=
operator|new
name|ArrayList
argument_list|<
name|InputSplit
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|rackToNodes
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|OneBlockInfo
argument_list|>
argument_list|>
name|rackToBlocks
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|OneBlockInfo
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|OneBlockInfo
argument_list|,
name|String
index|[]
argument_list|>
name|blockToNodes
init|=
operator|new
name|HashMap
argument_list|<
name|OneBlockInfo
argument_list|,
name|String
index|[]
argument_list|>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|OneBlockInfo
argument_list|>
argument_list|>
name|nodeToBlocks
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|OneBlockInfo
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|OneFileInfo
operator|.
name|populateBlockInfo
argument_list|(
name|blocks
argument_list|,
name|rackToBlocks
argument_list|,
name|blockToNodes
argument_list|,
name|nodeToBlocks
argument_list|,
name|rackToNodes
argument_list|)
expr_stmt|;
name|inFormat
operator|.
name|createSplits
argument_list|(
name|nodeToBlocks
argument_list|,
name|blockToNodes
argument_list|,
name|rackToBlocks
argument_list|,
name|totLength
argument_list|,
name|maxSize
argument_list|,
name|minSizeNode
argument_list|,
name|minSizeRack
argument_list|,
name|splits
argument_list|)
expr_stmt|;
name|int
name|expectedSplitCount
init|=
call|(
name|int
call|)
argument_list|(
name|totLength
operator|/
name|maxSize
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|expectedSplitCount
argument_list|,
name|splits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|HashMultiset
argument_list|<
name|String
argument_list|>
name|nodeSplits
init|=
name|HashMultiset
operator|.
name|create
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|expectedSplitCount
condition|;
operator|++
name|i
control|)
block|{
name|InputSplit
name|inSplit
init|=
name|splits
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|maxSize
argument_list|,
name|inSplit
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|inSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|nodeSplits
operator|.
name|add
argument_list|(
name|inSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|nodeSplits
operator|.
name|count
argument_list|(
name|locations
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|nodeSplits
operator|.
name|count
argument_list|(
name|locations
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * The test suppresses unchecked warnings in    * {@link org.mockito.Mockito#reset}. Although calling the method is    * a bad manner, we call the method instead of splitting the test    * (i.e. restarting MiniDFSCluster) to save time.    */
annotation|@
name|Test
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|testSplitPlacementForCompressedFiles ()
specifier|public
name|void
name|testSplitPlacementForCompressedFiles
parameter_list|()
throws|throws
name|Exception
block|{
name|MiniDFSCluster
name|dfs
init|=
literal|null
decl_stmt|;
name|FileSystem
name|fileSys
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|/* Start 3 datanodes, one each in rack r1, r2, r3. Create five gzipped        *  files        * 1) file1 and file5, just after starting the datanode on r1, with         *    a repl factor of 1, and,        * 2) file2, just after starting the datanode on r2, with         *    a repl factor of 2, and,        * 3) file3, file4 after starting the all three datanodes, with a repl         *    factor of 3.        * At the end, file1, file5 will be present on only datanode1, file2 will         * be present on datanode 1 and datanode2 and         * file3, file4 will be present on all datanodes.         */
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
literal|"dfs.replication.considerLoad"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|dfs
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|racks
argument_list|(
name|rack1
argument_list|)
operator|.
name|hosts
argument_list|(
name|hosts1
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|dfs
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fileSys
operator|=
name|dfs
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fileSys
operator|.
name|mkdirs
argument_list|(
name|inDir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mkdirs failed to create "
operator|+
name|inDir
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|Path
name|file1
init|=
operator|new
name|Path
argument_list|(
name|dir1
operator|+
literal|"/file1.gz"
argument_list|)
decl_stmt|;
name|FileStatus
name|f1
init|=
name|writeGzipFile
argument_list|(
name|conf
argument_list|,
name|file1
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// create another file on the same datanode
name|Path
name|file5
init|=
operator|new
name|Path
argument_list|(
name|dir5
operator|+
literal|"/file5.gz"
argument_list|)
decl_stmt|;
name|FileStatus
name|f5
init|=
name|writeGzipFile
argument_list|(
name|conf
argument_list|,
name|file5
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|// split it using a CombinedFile input format
name|DummyInputFormat
name|inFormat
init|=
operator|new
name|DummyInputFormat
argument_list|()
decl_stmt|;
name|Job
name|job
init|=
name|Job
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|dir1
operator|+
literal|","
operator|+
name|dir5
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|InputSplit
argument_list|>
name|splits
init|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Made splits(Test0): "
operator|+
name|splits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"File split(Test0): "
operator|+
name|split
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|splits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|CombineFileSplit
name|fileSplit
init|=
operator|(
name|CombineFileSplit
operator|)
name|splits
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file1
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|f1
operator|.
name|getLen
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file5
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|1
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|f5
operator|.
name|getLen
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dfs
operator|.
name|startDataNodes
argument_list|(
name|conf
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
name|rack2
argument_list|,
name|hosts2
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|dfs
operator|.
name|waitActive
argument_list|()
expr_stmt|;
comment|// create file on two datanodes.
name|Path
name|file2
init|=
operator|new
name|Path
argument_list|(
name|dir2
operator|+
literal|"/file2.gz"
argument_list|)
decl_stmt|;
name|FileStatus
name|f2
init|=
name|writeGzipFile
argument_list|(
name|conf
argument_list|,
name|file2
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|,
literal|2
argument_list|)
decl_stmt|;
comment|// split it using a CombinedFile input format
name|inFormat
operator|=
operator|new
name|DummyInputFormat
argument_list|()
expr_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|dir1
operator|+
literal|","
operator|+
name|dir2
argument_list|)
expr_stmt|;
name|inFormat
operator|.
name|setMinSplitSizeRack
argument_list|(
name|f1
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
name|splits
operator|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Made splits(Test1): "
operator|+
name|splits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// make sure that each split has different locations
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"File split(Test1): "
operator|+
name|split
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|Split
argument_list|>
name|expected
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file1
operator|.
name|getName
argument_list|()
argument_list|,
name|f1
operator|.
name|getLen
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file2
operator|.
name|getName
argument_list|()
argument_list|,
name|f2
operator|.
name|getLen
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Split
argument_list|>
name|actual
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**        * If rack1 is processed first by        * {@link CombineFileInputFormat#createSplits},        * create only one split on rack1. Otherwise create two splits.        */
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|fileSplit
operator|=
operator|(
name|CombineFileSplit
operator|)
name|split
expr_stmt|;
if|if
condition|(
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|// first split is on rack2, contains file2.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file2
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|f2
operator|.
name|getLen
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts2
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
comment|// second split is on rack1, contains file1.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file1
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|f1
operator|.
name|getLen
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// first split is on rack1, contains file1 and file2.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fail
argument_list|(
literal|"Split size should be 1 or 2."
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|fileSplit
operator|.
name|getPath
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|long
name|length
init|=
name|fileSplit
operator|.
name|getLength
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|offset
init|=
name|fileSplit
operator|.
name|getOffset
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|actual
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|name
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|actual
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|actual
operator|.
name|containsAll
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
comment|// create another file on 3 datanodes and 3 racks.
name|dfs
operator|.
name|startDataNodes
argument_list|(
name|conf
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|,
name|rack3
argument_list|,
name|hosts3
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|dfs
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|Path
name|file3
init|=
operator|new
name|Path
argument_list|(
name|dir3
operator|+
literal|"/file3.gz"
argument_list|)
decl_stmt|;
name|FileStatus
name|f3
init|=
name|writeGzipFile
argument_list|(
name|conf
argument_list|,
name|file3
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|inFormat
operator|=
operator|new
name|DummyInputFormat
argument_list|()
expr_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|dir1
operator|+
literal|","
operator|+
name|dir2
operator|+
literal|","
operator|+
name|dir3
argument_list|)
expr_stmt|;
name|inFormat
operator|.
name|setMinSplitSizeRack
argument_list|(
name|f1
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
name|splits
operator|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"File split(Test2): "
operator|+
name|split
argument_list|)
expr_stmt|;
block|}
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file3
operator|.
name|getName
argument_list|()
argument_list|,
name|f3
operator|.
name|getLen
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|actual
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|fileSplit
operator|=
operator|(
name|CombineFileSplit
operator|)
name|split
expr_stmt|;
comment|/**          * If rack1 is processed first by          * {@link CombineFileInputFormat#createSplits},          * create only one split on rack1.          * If rack2 or rack3 is processed first and rack1 is processed second,          * create one split on rack2 or rack3 and the other split is on rack1.          * Otherwise create 3 splits for each rack.          */
if|if
condition|(
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|3
condition|)
block|{
comment|// first split is on rack3, contains file3
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file3
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|f3
operator|.
name|getLen
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts3
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|// second split is on rack2, contains file2
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file2
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|f2
operator|.
name|getLen
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts2
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|// third split is on rack1, contains file1
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file1
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|f1
operator|.
name|getLen
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
comment|// first split is on rack2 or rack3, contains one or two files.
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
name|hosts2
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
name|hosts3
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fail
argument_list|(
literal|"First split should be on rack2 or rack3."
argument_list|)
expr_stmt|;
block|}
block|}
comment|// second split is on rack1, contains the rest files.
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// first split is rack1, contains all three files.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fail
argument_list|(
literal|"Split size should be 1, 2, or 3."
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|fileSplit
operator|.
name|getPath
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|long
name|length
init|=
name|fileSplit
operator|.
name|getLength
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|offset
init|=
name|fileSplit
operator|.
name|getOffset
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|actual
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|name
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|actual
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|actual
operator|.
name|containsAll
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
comment|// create file4 on all three racks
name|Path
name|file4
init|=
operator|new
name|Path
argument_list|(
name|dir4
operator|+
literal|"/file4.gz"
argument_list|)
decl_stmt|;
name|FileStatus
name|f4
init|=
name|writeGzipFile
argument_list|(
name|conf
argument_list|,
name|file4
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|inFormat
operator|=
operator|new
name|DummyInputFormat
argument_list|()
expr_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|dir1
operator|+
literal|","
operator|+
name|dir2
operator|+
literal|","
operator|+
name|dir3
operator|+
literal|","
operator|+
name|dir4
argument_list|)
expr_stmt|;
name|inFormat
operator|.
name|setMinSplitSizeRack
argument_list|(
name|f1
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
name|splits
operator|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"File split(Test3): "
operator|+
name|split
argument_list|)
expr_stmt|;
block|}
name|expected
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|file3
operator|.
name|getName
argument_list|()
argument_list|,
name|f3
operator|.
name|getLen
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|actual
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|fileSplit
operator|=
operator|(
name|CombineFileSplit
operator|)
name|split
expr_stmt|;
comment|/**          * If rack1 is processed first by          * {@link CombineFileInputFormat#createSplits},          * create only one split on rack1.          * If rack2 or rack3 is processed first and rack1 is processed second,          * create one split on rack2 or rack3 and the other split is on rack1.          * Otherwise create 3 splits for each rack.          */
if|if
condition|(
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|3
condition|)
block|{
comment|// first split is on rack3, contains file3 and file4
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts3
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|// second split is on rack2, contains file2
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file2
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|f2
operator|.
name|getLen
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts2
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|// third split is on rack1, contains file1
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file1
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|f1
operator|.
name|getLen
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
comment|// first split is on rack2 or rack3, contains two or three files.
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
name|hosts2
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
name|hosts3
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fail
argument_list|(
literal|"First split should be on rack2 or rack3."
argument_list|)
expr_stmt|;
block|}
block|}
comment|// second split is on rack1, contains the rest files.
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// first split is rack1, contains all four files.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fail
argument_list|(
literal|"Split size should be 1, 2, or 3."
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|fileSplit
operator|.
name|getPath
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|long
name|length
init|=
name|fileSplit
operator|.
name|getLength
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|offset
init|=
name|fileSplit
operator|.
name|getOffset
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|actual
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|name
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|actual
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|actual
operator|.
name|containsAll
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
comment|// maximum split size is file1's length
name|inFormat
operator|=
operator|new
name|DummyInputFormat
argument_list|()
expr_stmt|;
name|inFormat
operator|.
name|setMinSplitSizeNode
argument_list|(
name|f1
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
name|inFormat
operator|.
name|setMaxSplitSize
argument_list|(
name|f1
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|dir1
operator|+
literal|","
operator|+
name|dir2
operator|+
literal|","
operator|+
name|dir3
operator|+
literal|","
operator|+
name|dir4
argument_list|)
expr_stmt|;
name|splits
operator|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"File split(Test4): "
operator|+
name|split
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|splits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|actual
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|fileSplit
operator|=
operator|(
name|CombineFileSplit
operator|)
name|split
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|fileSplit
operator|.
name|getPath
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|long
name|length
init|=
name|fileSplit
operator|.
name|getLength
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|offset
init|=
name|fileSplit
operator|.
name|getOffset
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|actual
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|name
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mockList
operator|.
name|add
argument_list|(
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|actual
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|actual
operator|.
name|containsAll
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|mockList
argument_list|,
name|atLeastOnce
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|mockList
argument_list|,
name|atLeastOnce
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|hosts2
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|mockList
argument_list|,
name|atLeastOnce
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|hosts3
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// maximum split size is twice file1's length
name|inFormat
operator|=
operator|new
name|DummyInputFormat
argument_list|()
expr_stmt|;
name|inFormat
operator|.
name|setMinSplitSizeNode
argument_list|(
name|f1
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
name|inFormat
operator|.
name|setMaxSplitSize
argument_list|(
literal|2
operator|*
name|f1
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|dir1
operator|+
literal|","
operator|+
name|dir2
operator|+
literal|","
operator|+
name|dir3
operator|+
literal|","
operator|+
name|dir4
argument_list|)
expr_stmt|;
name|splits
operator|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"File split(Test5): "
operator|+
name|split
argument_list|)
expr_stmt|;
block|}
name|actual
operator|.
name|clear
argument_list|()
expr_stmt|;
name|reset
argument_list|(
name|mockList
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|fileSplit
operator|=
operator|(
name|CombineFileSplit
operator|)
name|split
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|fileSplit
operator|.
name|getPath
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|long
name|length
init|=
name|fileSplit
operator|.
name|getLength
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|offset
init|=
name|fileSplit
operator|.
name|getOffset
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|actual
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|name
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mockList
operator|.
name|add
argument_list|(
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|actual
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|actual
operator|.
name|containsAll
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|3
condition|)
block|{
comment|// splits are on all the racks
name|verify
argument_list|(
name|mockList
argument_list|,
name|times
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|mockList
argument_list|,
name|times
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
name|hosts2
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|mockList
argument_list|,
name|times
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
name|hosts3
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
comment|// one split is on rack1, another split is on rack2 or rack3
name|verify
argument_list|(
name|mockList
argument_list|,
name|times
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fail
argument_list|(
literal|"Split size should be 2 or 3."
argument_list|)
expr_stmt|;
block|}
comment|// maximum split size is 4 times file1's length
name|inFormat
operator|=
operator|new
name|DummyInputFormat
argument_list|()
expr_stmt|;
name|inFormat
operator|.
name|setMinSplitSizeNode
argument_list|(
literal|2
operator|*
name|f1
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
name|inFormat
operator|.
name|setMaxSplitSize
argument_list|(
literal|4
operator|*
name|f1
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|dir1
operator|+
literal|","
operator|+
name|dir2
operator|+
literal|","
operator|+
name|dir3
operator|+
literal|","
operator|+
name|dir4
argument_list|)
expr_stmt|;
name|splits
operator|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"File split(Test6): "
operator|+
name|split
argument_list|)
expr_stmt|;
block|}
comment|/**        * If rack1 is processed first by        * {@link CombineFileInputFormat#createSplits},        * create only one split on rack1. Otherwise create two splits.        */
name|assertTrue
argument_list|(
literal|"Split size should be 1 or 2."
argument_list|,
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|||
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|2
argument_list|)
expr_stmt|;
name|actual
operator|.
name|clear
argument_list|()
expr_stmt|;
name|reset
argument_list|(
name|mockList
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|fileSplit
operator|=
operator|(
name|CombineFileSplit
operator|)
name|split
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|fileSplit
operator|.
name|getPath
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|long
name|length
init|=
name|fileSplit
operator|.
name|getLength
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|offset
init|=
name|fileSplit
operator|.
name|getOffset
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|actual
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|name
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mockList
operator|.
name|add
argument_list|(
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|actual
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|actual
operator|.
name|containsAll
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|mockList
argument_list|,
name|times
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// maximum split size and min-split-size per rack is 4 times file1's length
name|inFormat
operator|=
operator|new
name|DummyInputFormat
argument_list|()
expr_stmt|;
name|inFormat
operator|.
name|setMaxSplitSize
argument_list|(
literal|4
operator|*
name|f1
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
name|inFormat
operator|.
name|setMinSplitSizeRack
argument_list|(
literal|4
operator|*
name|f1
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|dir1
operator|+
literal|","
operator|+
name|dir2
operator|+
literal|","
operator|+
name|dir3
operator|+
literal|","
operator|+
name|dir4
argument_list|)
expr_stmt|;
name|splits
operator|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"File split(Test7): "
operator|+
name|split
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|splits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|fileSplit
operator|=
operator|(
name|CombineFileSplit
operator|)
name|splits
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// minimum split size per node is 4 times file1's length
name|inFormat
operator|=
operator|new
name|DummyInputFormat
argument_list|()
expr_stmt|;
name|inFormat
operator|.
name|setMinSplitSizeNode
argument_list|(
literal|4
operator|*
name|f1
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|dir1
operator|+
literal|","
operator|+
name|dir2
operator|+
literal|","
operator|+
name|dir3
operator|+
literal|","
operator|+
name|dir4
argument_list|)
expr_stmt|;
name|splits
operator|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"File split(Test8): "
operator|+
name|split
argument_list|)
expr_stmt|;
block|}
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|splits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|fileSplit
operator|=
operator|(
name|CombineFileSplit
operator|)
name|splits
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|// Rack 1 has file1, file2 and file3 and file4
comment|// Rack 2 has file2 and file3 and file4
comment|// Rack 3 has file3 and file4
comment|// setup a filter so that only file1 and file2 can be combined
name|inFormat
operator|=
operator|new
name|DummyInputFormat
argument_list|()
expr_stmt|;
name|FileInputFormat
operator|.
name|addInputPath
argument_list|(
name|job
argument_list|,
name|inDir
argument_list|)
expr_stmt|;
name|inFormat
operator|.
name|setMinSplitSizeRack
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// everything is at least rack local
name|inFormat
operator|.
name|createPool
argument_list|(
operator|new
name|TestFilter
argument_list|(
name|dir1
argument_list|)
argument_list|,
operator|new
name|TestFilter
argument_list|(
name|dir2
argument_list|)
argument_list|)
expr_stmt|;
name|splits
operator|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"File split(Test9): "
operator|+
name|split
argument_list|)
expr_stmt|;
block|}
name|actual
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|fileSplit
operator|=
operator|(
name|CombineFileSplit
operator|)
name|split
expr_stmt|;
if|if
condition|(
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|3
condition|)
block|{
comment|// If rack2 is processed first
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts2
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|2
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts3
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|splits
operator|.
name|size
argument_list|()
operator|==
literal|2
condition|)
block|{
comment|// If rack1 is processed first
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|split
operator|.
name|equals
argument_list|(
name|splits
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts3
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fail
argument_list|(
literal|"Split size should be 2 or 3."
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|fileSplit
operator|.
name|getPath
argument_list|(
name|i
argument_list|)
operator|.
name|getName
argument_list|()
decl_stmt|;
name|long
name|length
init|=
name|fileSplit
operator|.
name|getLength
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|long
name|offset
init|=
name|fileSplit
operator|.
name|getOffset
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|actual
operator|.
name|add
argument_list|(
operator|new
name|Split
argument_list|(
name|name
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|actual
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|actual
operator|.
name|containsAll
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
comment|// measure performance when there are multiple pools and
comment|// many files in each pool.
name|int
name|numPools
init|=
literal|100
decl_stmt|;
name|int
name|numFiles
init|=
literal|1000
decl_stmt|;
name|DummyInputFormat1
name|inFormat1
init|=
operator|new
name|DummyInputFormat1
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numFiles
condition|;
name|i
operator|++
control|)
block|{
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|file1
argument_list|)
expr_stmt|;
block|}
name|inFormat1
operator|.
name|setMinSplitSizeRack
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// everything is at least rack local
specifier|final
name|Path
name|dirNoMatch1
init|=
operator|new
name|Path
argument_list|(
name|inDir
argument_list|,
literal|"/dirxx"
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|dirNoMatch2
init|=
operator|new
name|Path
argument_list|(
name|inDir
argument_list|,
literal|"/diryy"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numPools
condition|;
name|i
operator|++
control|)
block|{
name|inFormat1
operator|.
name|createPool
argument_list|(
operator|new
name|TestFilter
argument_list|(
name|dirNoMatch1
argument_list|)
argument_list|,
operator|new
name|TestFilter
argument_list|(
name|dirNoMatch2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|splits
operator|=
name|inFormat1
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|long
name|end
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Elapsed time for "
operator|+
name|numPools
operator|+
literal|" pools "
operator|+
literal|" and "
operator|+
name|numFiles
operator|+
literal|" files is "
operator|+
operator|(
operator|(
name|end
operator|-
name|start
operator|)
operator|)
operator|+
literal|" milli seconds."
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|dfs
operator|!=
literal|null
condition|)
block|{
name|dfs
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Test that CFIF can handle missing blocks.    */
annotation|@
name|Test
DECL|method|testMissingBlocks ()
specifier|public
name|void
name|testMissingBlocks
parameter_list|()
throws|throws
name|Exception
block|{
name|String
name|namenode
init|=
literal|null
decl_stmt|;
name|MiniDFSCluster
name|dfs
init|=
literal|null
decl_stmt|;
name|FileSystem
name|fileSys
init|=
literal|null
decl_stmt|;
name|String
name|testName
init|=
literal|"testMissingBlocks"
decl_stmt|;
try|try
block|{
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
literal|"fs.hdfs.impl"
argument_list|,
name|MissingBlockFileSystem
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
literal|"dfs.replication.considerLoad"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|dfs
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|racks
argument_list|(
name|rack1
argument_list|)
operator|.
name|hosts
argument_list|(
name|hosts1
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|dfs
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|namenode
operator|=
operator|(
name|dfs
operator|.
name|getFileSystem
argument_list|()
operator|)
operator|.
name|getUri
argument_list|()
operator|.
name|getHost
argument_list|()
operator|+
literal|":"
operator|+
operator|(
name|dfs
operator|.
name|getFileSystem
argument_list|()
operator|)
operator|.
name|getUri
argument_list|()
operator|.
name|getPort
argument_list|()
expr_stmt|;
name|fileSys
operator|=
name|dfs
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fileSys
operator|.
name|mkdirs
argument_list|(
name|inDir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mkdirs failed to create "
operator|+
name|inDir
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|Path
name|file1
init|=
operator|new
name|Path
argument_list|(
name|dir1
operator|+
literal|"/file1"
argument_list|)
decl_stmt|;
name|writeFile
argument_list|(
name|conf
argument_list|,
name|file1
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// create another file on the same datanode
name|Path
name|file5
init|=
operator|new
name|Path
argument_list|(
name|dir5
operator|+
literal|"/file5"
argument_list|)
decl_stmt|;
name|writeFile
argument_list|(
name|conf
argument_list|,
name|file5
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|(
name|MissingBlockFileSystem
operator|)
name|fileSys
operator|)
operator|.
name|setFileWithMissingBlocks
argument_list|(
name|file1
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
comment|// split it using a CombinedFile input format
name|DummyInputFormat
name|inFormat
init|=
operator|new
name|DummyInputFormat
argument_list|()
decl_stmt|;
name|Job
name|job
init|=
name|Job
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|dir1
operator|+
literal|","
operator|+
name|dir5
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|InputSplit
argument_list|>
name|splits
init|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Made splits(Test0): "
operator|+
name|splits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|split
range|:
name|splits
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"File split(Test0): "
operator|+
name|split
argument_list|)
expr_stmt|;
block|}
name|assertThat
argument_list|(
name|splits
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|isEqualTo
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|CombineFileSplit
name|fileSplit
init|=
operator|(
name|CombineFileSplit
operator|)
name|splits
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file1
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|BLOCKSIZE
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file5
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|1
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|BLOCKSIZE
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|hosts1
index|[
literal|0
index|]
argument_list|,
name|fileSplit
operator|.
name|getLocations
argument_list|()
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|dfs
operator|!=
literal|null
condition|)
block|{
name|dfs
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Test when the input file's length is 0.    */
annotation|@
name|Test
DECL|method|testForEmptyFile ()
specifier|public
name|void
name|testForEmptyFile
parameter_list|()
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|FileSystem
name|fileSys
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
literal|"test"
operator|+
literal|"/file"
argument_list|)
decl_stmt|;
name|FSDataOutputStream
name|out
init|=
name|fileSys
operator|.
name|create
argument_list|(
name|file
argument_list|,
literal|true
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
literal|"io.file.buffer.size"
argument_list|,
literal|4096
argument_list|)
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|,
operator|(
name|long
operator|)
name|BLOCKSIZE
argument_list|)
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
operator|new
name|byte
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// split it using a CombinedFile input format
name|DummyInputFormat
name|inFormat
init|=
operator|new
name|DummyInputFormat
argument_list|()
decl_stmt|;
name|Job
name|job
init|=
name|Job
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
literal|"test"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|InputSplit
argument_list|>
name|splits
init|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|splits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|CombineFileSplit
name|fileSplit
init|=
operator|(
name|CombineFileSplit
operator|)
name|splits
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fileSys
operator|.
name|delete
argument_list|(
name|file
operator|.
name|getParent
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that directories do not get included as part of getSplits()    */
annotation|@
name|Test
DECL|method|testGetSplitsWithDirectory ()
specifier|public
name|void
name|testGetSplitsWithDirectory
parameter_list|()
throws|throws
name|Exception
block|{
name|MiniDFSCluster
name|dfs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|dfs
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|racks
argument_list|(
name|rack1
argument_list|)
operator|.
name|hosts
argument_list|(
name|hosts1
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|dfs
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|FileSystem
name|fileSys
init|=
name|dfs
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
comment|// Set up the following directory structure:
comment|// /dir1/: directory
comment|// /dir1/file: regular file
comment|// /dir1/dir2/: directory
name|Path
name|dir1
init|=
operator|new
name|Path
argument_list|(
literal|"/dir1"
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
literal|"/dir1/file1"
argument_list|)
decl_stmt|;
name|Path
name|dir2
init|=
operator|new
name|Path
argument_list|(
literal|"/dir1/dir2"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fileSys
operator|.
name|mkdirs
argument_list|(
name|dir1
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mkdirs failed to create "
operator|+
name|dir1
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|FSDataOutputStream
name|out
init|=
name|fileSys
operator|.
name|create
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
operator|new
name|byte
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|fileSys
operator|.
name|mkdirs
argument_list|(
name|dir2
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mkdirs failed to create "
operator|+
name|dir2
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
comment|// split it using a CombinedFile input format
name|DummyInputFormat
name|inFormat
init|=
operator|new
name|DummyInputFormat
argument_list|()
decl_stmt|;
name|Job
name|job
init|=
name|Job
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
literal|"/dir1"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|InputSplit
argument_list|>
name|splits
init|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
decl_stmt|;
comment|// directories should be omitted from getSplits() - we should only see file1 and not dir2
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|splits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|CombineFileSplit
name|fileSplit
init|=
operator|(
name|CombineFileSplit
operator|)
name|splits
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|fileSplit
operator|.
name|getNumPaths
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file
operator|.
name|getName
argument_list|()
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|(
literal|0
argument_list|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getOffset
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|dfs
operator|!=
literal|null
condition|)
block|{
name|dfs
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Test when input files are from non-default file systems    */
annotation|@
name|Test
DECL|method|testForNonDefaultFileSystem ()
specifier|public
name|void
name|testForNonDefaultFileSystem
parameter_list|()
throws|throws
name|Throwable
block|{
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
comment|// use a fake file system scheme as default
name|conf
operator|.
name|set
argument_list|(
name|CommonConfigurationKeys
operator|.
name|FS_DEFAULT_NAME_KEY
argument_list|,
name|DUMMY_FS_URI
argument_list|)
expr_stmt|;
comment|// default fs path
name|assertEquals
argument_list|(
name|DUMMY_FS_URI
argument_list|,
name|FileSystem
operator|.
name|getDefaultUri
argument_list|(
name|conf
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// add a local file
name|String
name|localPathRoot
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"test.build.data"
argument_list|,
literal|"build/test/data"
argument_list|)
decl_stmt|;
name|Path
name|localPath
init|=
operator|new
name|Path
argument_list|(
name|localPathRoot
argument_list|,
literal|"testFile1"
argument_list|)
decl_stmt|;
name|FileSystem
name|lfs
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FSDataOutputStream
name|dos
init|=
name|lfs
operator|.
name|create
argument_list|(
name|localPath
argument_list|)
decl_stmt|;
name|dos
operator|.
name|writeChars
argument_list|(
literal|"Local file for CFIF"
argument_list|)
expr_stmt|;
name|dos
operator|.
name|close
argument_list|()
expr_stmt|;
name|Job
name|job
init|=
name|Job
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
name|lfs
operator|.
name|makeQualified
argument_list|(
name|localPath
argument_list|)
argument_list|)
expr_stmt|;
name|DummyInputFormat
name|inFormat
init|=
operator|new
name|DummyInputFormat
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|InputSplit
argument_list|>
name|splits
init|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|splits
operator|.
name|size
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|InputSplit
name|s
range|:
name|splits
control|)
block|{
name|CombineFileSplit
name|cfs
init|=
operator|(
name|CombineFileSplit
operator|)
name|s
decl_stmt|;
for|for
control|(
name|Path
name|p
range|:
name|cfs
operator|.
name|getPaths
argument_list|()
control|)
block|{
name|assertThat
argument_list|(
name|p
operator|.
name|toUri
argument_list|()
operator|.
name|getScheme
argument_list|()
argument_list|)
operator|.
name|isEqualTo
argument_list|(
literal|"file"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|TestFilter
specifier|static
class|class
name|TestFilter
implements|implements
name|PathFilter
block|{
DECL|field|p
specifier|private
name|Path
name|p
decl_stmt|;
comment|// store a path prefix in this TestFilter
DECL|method|TestFilter (Path p)
specifier|public
name|TestFilter
parameter_list|(
name|Path
name|p
parameter_list|)
block|{
name|this
operator|.
name|p
operator|=
name|p
expr_stmt|;
block|}
comment|// returns true if the specified path matches the prefix stored
comment|// in this TestFilter.
DECL|method|accept (Path path)
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
operator|.
name|indexOf
argument_list|(
name|p
operator|.
name|toString
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"PathFilter:"
operator|+
name|p
return|;
block|}
block|}
comment|/*    * Prints out the input splits for the specified files    */
DECL|method|splitRealFiles (String[] args)
specifier|private
name|void
name|splitRealFiles
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|Job
name|job
init|=
name|Job
operator|.
name|getInstance
argument_list|()
decl_stmt|;
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fs
operator|instanceof
name|DistributedFileSystem
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Wrong file system: "
operator|+
name|fs
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
name|long
name|blockSize
init|=
name|fs
operator|.
name|getDefaultBlockSize
argument_list|()
decl_stmt|;
name|DummyInputFormat
name|inFormat
init|=
operator|new
name|DummyInputFormat
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|FileInputFormat
operator|.
name|addInputPaths
argument_list|(
name|job
argument_list|,
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|inFormat
operator|.
name|setMinSplitSizeRack
argument_list|(
name|blockSize
argument_list|)
expr_stmt|;
name|inFormat
operator|.
name|setMaxSplitSize
argument_list|(
literal|10
operator|*
name|blockSize
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|InputSplit
argument_list|>
name|splits
init|=
name|inFormat
operator|.
name|getSplits
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Total number of splits "
operator|+
name|splits
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|splits
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|CombineFileSplit
name|fileSplit
init|=
operator|(
name|CombineFileSplit
operator|)
name|splits
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Split["
operator|+
name|i
operator|+
literal|"] "
operator|+
name|fileSplit
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
comment|// if there are some parameters specified, then use those paths
if|if
condition|(
name|args
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|TestCombineFileInputFormat
name|test
init|=
operator|new
name|TestCombineFileInputFormat
argument_list|()
decl_stmt|;
name|test
operator|.
name|splitRealFiles
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TestCombineFileInputFormat
name|test
init|=
operator|new
name|TestCombineFileInputFormat
argument_list|()
decl_stmt|;
name|test
operator|.
name|testSplitPlacement
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

