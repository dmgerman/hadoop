begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configured
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
operator|.
name|CompressionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|FileInputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|FileOutputFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|MapReduceBase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Mapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|OutputCollector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Reducer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Reporter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|SequenceFileInputFormat
import|;
end_import

begin_comment
comment|/**  * This program executes a specified operation that applies load to   * the NameNode.  *   * When run simultaneously on multiple nodes, this program functions   * as a stress-test and benchmark for namenode, especially when   * the number of bytes written to each file is small.  *   * Valid operations are:  *   create_write  *   open_read  *   rename  *   delete  *   * NOTE: The open_read, rename and delete operations assume that the files  *       they operate on are already available. The create_write operation   *       must be run before running the other operations.  */
end_comment

begin_class
DECL|class|NNBench
specifier|public
class|class
name|NNBench
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
literal|"org.apache.hadoop.hdfs.NNBench"
argument_list|)
decl_stmt|;
DECL|field|CONTROL_DIR_NAME
specifier|protected
specifier|static
name|String
name|CONTROL_DIR_NAME
init|=
literal|"control"
decl_stmt|;
DECL|field|OUTPUT_DIR_NAME
specifier|protected
specifier|static
name|String
name|OUTPUT_DIR_NAME
init|=
literal|"output"
decl_stmt|;
DECL|field|DATA_DIR_NAME
specifier|protected
specifier|static
name|String
name|DATA_DIR_NAME
init|=
literal|"data"
decl_stmt|;
DECL|field|DEFAULT_RES_FILE_NAME
specifier|protected
specifier|static
specifier|final
name|String
name|DEFAULT_RES_FILE_NAME
init|=
literal|"NNBench_results.log"
decl_stmt|;
DECL|field|NNBENCH_VERSION
specifier|protected
specifier|static
specifier|final
name|String
name|NNBENCH_VERSION
init|=
literal|"NameNode Benchmark 0.4"
decl_stmt|;
DECL|field|operation
specifier|public
specifier|static
name|String
name|operation
init|=
literal|"none"
decl_stmt|;
DECL|field|numberOfMaps
specifier|public
specifier|static
name|long
name|numberOfMaps
init|=
literal|1l
decl_stmt|;
comment|// default is 1
DECL|field|numberOfReduces
specifier|public
specifier|static
name|long
name|numberOfReduces
init|=
literal|1l
decl_stmt|;
comment|// default is 1
DECL|field|startTime
specifier|public
specifier|static
name|long
name|startTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
operator|(
literal|120
operator|*
literal|1000
operator|)
decl_stmt|;
comment|// default is 'now' + 2min
DECL|field|blockSize
specifier|public
specifier|static
name|long
name|blockSize
init|=
literal|1l
decl_stmt|;
comment|// default is 1
DECL|field|bytesToWrite
specifier|public
specifier|static
name|int
name|bytesToWrite
init|=
literal|0
decl_stmt|;
comment|// default is 0
DECL|field|bytesPerChecksum
specifier|public
specifier|static
name|long
name|bytesPerChecksum
init|=
literal|1l
decl_stmt|;
comment|// default is 1
DECL|field|numberOfFiles
specifier|public
specifier|static
name|long
name|numberOfFiles
init|=
literal|1l
decl_stmt|;
comment|// default is 1
DECL|field|replicationFactorPerFile
specifier|public
specifier|static
name|short
name|replicationFactorPerFile
init|=
literal|1
decl_stmt|;
comment|// default is 1
DECL|field|baseDir
specifier|public
specifier|static
name|String
name|baseDir
init|=
literal|"/benchmarks/NNBench"
decl_stmt|;
comment|// default
DECL|field|readFileAfterOpen
specifier|public
specifier|static
name|boolean
name|readFileAfterOpen
init|=
literal|false
decl_stmt|;
comment|// default is to not read
comment|// Supported operations
DECL|field|OP_CREATE_WRITE
specifier|private
specifier|static
specifier|final
name|String
name|OP_CREATE_WRITE
init|=
literal|"create_write"
decl_stmt|;
DECL|field|OP_OPEN_READ
specifier|private
specifier|static
specifier|final
name|String
name|OP_OPEN_READ
init|=
literal|"open_read"
decl_stmt|;
DECL|field|OP_RENAME
specifier|private
specifier|static
specifier|final
name|String
name|OP_RENAME
init|=
literal|"rename"
decl_stmt|;
DECL|field|OP_DELETE
specifier|private
specifier|static
specifier|final
name|String
name|OP_DELETE
init|=
literal|"delete"
decl_stmt|;
comment|// To display in the format that matches the NN and DN log format
comment|// Example: 2007-10-26 00:01:19,853
DECL|field|sdf
specifier|static
name|SimpleDateFormat
name|sdf
init|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"yyyy-MM-dd' 'HH:mm:ss','S"
argument_list|)
decl_stmt|;
DECL|field|config
specifier|private
specifier|static
name|Configuration
name|config
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
comment|/**    * Clean up the files before a test run    *     * @throws IOException on error    */
DECL|method|cleanupBeforeTestrun ()
specifier|private
specifier|static
name|void
name|cleanupBeforeTestrun
parameter_list|()
throws|throws
name|IOException
block|{
name|FileSystem
name|tempFS
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|config
argument_list|)
decl_stmt|;
comment|// Delete the data directory only if it is the create/write operation
if|if
condition|(
name|operation
operator|.
name|equals
argument_list|(
name|OP_CREATE_WRITE
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleting data directory"
argument_list|)
expr_stmt|;
name|tempFS
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|baseDir
argument_list|,
name|DATA_DIR_NAME
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|tempFS
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|baseDir
argument_list|,
name|CONTROL_DIR_NAME
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|tempFS
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|baseDir
argument_list|,
name|OUTPUT_DIR_NAME
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create control files before a test run.    * Number of files created is equal to the number of maps specified    *     * @throws IOException on error    */
DECL|method|createControlFiles ()
specifier|private
specifier|static
name|void
name|createControlFiles
parameter_list|()
throws|throws
name|IOException
block|{
name|FileSystem
name|tempFS
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|config
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Creating "
operator|+
name|numberOfMaps
operator|+
literal|" control files"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numberOfMaps
condition|;
name|i
operator|++
control|)
block|{
name|String
name|strFileName
init|=
literal|"NNBench_Controlfile_"
operator|+
name|i
decl_stmt|;
name|Path
name|filePath
init|=
operator|new
name|Path
argument_list|(
operator|new
name|Path
argument_list|(
name|baseDir
argument_list|,
name|CONTROL_DIR_NAME
argument_list|)
argument_list|,
name|strFileName
argument_list|)
decl_stmt|;
name|SequenceFile
operator|.
name|Writer
name|writer
init|=
literal|null
decl_stmt|;
try|try
block|{
name|writer
operator|=
name|SequenceFile
operator|.
name|createWriter
argument_list|(
name|tempFS
argument_list|,
name|config
argument_list|,
name|filePath
argument_list|,
name|Text
operator|.
name|class
argument_list|,
name|LongWritable
operator|.
name|class
argument_list|,
name|CompressionType
operator|.
name|NONE
argument_list|)
expr_stmt|;
name|writer
operator|.
name|append
argument_list|(
operator|new
name|Text
argument_list|(
name|strFileName
argument_list|)
argument_list|,
operator|new
name|LongWritable
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|writer
operator|!=
literal|null
condition|)
block|{
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Display version    */
DECL|method|displayVersion ()
specifier|private
specifier|static
name|void
name|displayVersion
parameter_list|()
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|NNBENCH_VERSION
argument_list|)
expr_stmt|;
block|}
comment|/**    * Display usage    */
DECL|method|displayUsage ()
specifier|private
specifier|static
name|void
name|displayUsage
parameter_list|()
block|{
name|String
name|usage
init|=
literal|"Usage: nnbench<options>\n"
operator|+
literal|"Options:\n"
operator|+
literal|"\t-operation<Available operations are "
operator|+
name|OP_CREATE_WRITE
operator|+
literal|" "
operator|+
name|OP_OPEN_READ
operator|+
literal|" "
operator|+
name|OP_RENAME
operator|+
literal|" "
operator|+
name|OP_DELETE
operator|+
literal|". "
operator|+
literal|"This option is mandatory>\n"
operator|+
literal|"\t * NOTE: The open_read, rename and delete operations assume "
operator|+
literal|"that the files they operate on, are already available. "
operator|+
literal|"The create_write operation must be run before running the "
operator|+
literal|"other operations.\n"
operator|+
literal|"\t-maps<number of maps. default is 1. This is not mandatory>\n"
operator|+
literal|"\t-reduces<number of reduces. default is 1. This is not mandatory>\n"
operator|+
literal|"\t-startTime<time to start, given in seconds from the epoch. "
operator|+
literal|"Make sure this is far enough into the future, so all maps "
operator|+
literal|"(operations) will start at the same time. "
operator|+
literal|"default is launch time + 2 mins. This is not mandatory>\n"
operator|+
literal|"\t-blockSize<Block size in bytes. default is 1. "
operator|+
literal|"This is not mandatory>\n"
operator|+
literal|"\t-bytesToWrite<Bytes to write. default is 0. "
operator|+
literal|"This is not mandatory>\n"
operator|+
literal|"\t-bytesPerChecksum<Bytes per checksum for the files. default is 1. "
operator|+
literal|"This is not mandatory>\n"
operator|+
literal|"\t-numberOfFiles<number of files to create. default is 1. "
operator|+
literal|"This is not mandatory>\n"
operator|+
literal|"\t-replicationFactorPerFile<Replication factor for the files."
operator|+
literal|" default is 1. This is not mandatory>\n"
operator|+
literal|"\t-baseDir<base DFS path. default is /benchmarks/NNBench. "
operator|+
literal|"This is not mandatory>\n"
operator|+
literal|"\t-readFileAfterOpen<true or false. if true, it reads the file and "
operator|+
literal|"reports the average time to read. This is valid with the open_read "
operator|+
literal|"operation. default is false. This is not mandatory>\n"
operator|+
literal|"\t-help: Display the help statement\n"
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|usage
argument_list|)
expr_stmt|;
block|}
comment|/**    * check for arguments and fail if the values are not specified    * @param index  positional number of an argument in the list of command    *   line's arguments    * @param length total number of arguments    */
DECL|method|checkArgs (final int index, final int length)
specifier|public
specifier|static
name|void
name|checkArgs
parameter_list|(
specifier|final
name|int
name|index
parameter_list|,
specifier|final
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|index
operator|==
name|length
condition|)
block|{
name|displayUsage
argument_list|()
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Parse input arguments    *    * @param args array of command line's parameters to be parsed    */
DECL|method|parseInputs (final String[] args)
specifier|public
specifier|static
name|void
name|parseInputs
parameter_list|(
specifier|final
name|String
index|[]
name|args
parameter_list|)
block|{
comment|// If there are no command line arguments, exit
if|if
condition|(
name|args
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|displayUsage
argument_list|()
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// Parse command line args
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-operation"
argument_list|)
condition|)
block|{
name|operation
operator|=
name|args
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-maps"
argument_list|)
condition|)
block|{
name|checkArgs
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|args
operator|.
name|length
argument_list|)
expr_stmt|;
name|numberOfMaps
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-reduces"
argument_list|)
condition|)
block|{
name|checkArgs
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|args
operator|.
name|length
argument_list|)
expr_stmt|;
name|numberOfReduces
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-startTime"
argument_list|)
condition|)
block|{
name|checkArgs
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|args
operator|.
name|length
argument_list|)
expr_stmt|;
name|startTime
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
operator|*
literal|1000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-blockSize"
argument_list|)
condition|)
block|{
name|checkArgs
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|args
operator|.
name|length
argument_list|)
expr_stmt|;
name|blockSize
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-bytesToWrite"
argument_list|)
condition|)
block|{
name|checkArgs
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|args
operator|.
name|length
argument_list|)
expr_stmt|;
name|bytesToWrite
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-bytesPerChecksum"
argument_list|)
condition|)
block|{
name|checkArgs
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|args
operator|.
name|length
argument_list|)
expr_stmt|;
name|bytesPerChecksum
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-numberOfFiles"
argument_list|)
condition|)
block|{
name|checkArgs
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|args
operator|.
name|length
argument_list|)
expr_stmt|;
name|numberOfFiles
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-replicationFactorPerFile"
argument_list|)
condition|)
block|{
name|checkArgs
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|args
operator|.
name|length
argument_list|)
expr_stmt|;
name|replicationFactorPerFile
operator|=
name|Short
operator|.
name|parseShort
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-baseDir"
argument_list|)
condition|)
block|{
name|checkArgs
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|args
operator|.
name|length
argument_list|)
expr_stmt|;
name|baseDir
operator|=
name|args
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-readFileAfterOpen"
argument_list|)
condition|)
block|{
name|checkArgs
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|args
operator|.
name|length
argument_list|)
expr_stmt|;
name|readFileAfterOpen
operator|=
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-help"
argument_list|)
condition|)
block|{
name|displayUsage
argument_list|()
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Test Inputs: "
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"           Test Operation: "
operator|+
name|operation
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"               Start time: "
operator|+
name|sdf
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|(
name|startTime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"           Number of maps: "
operator|+
name|numberOfMaps
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"        Number of reduces: "
operator|+
name|numberOfReduces
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"               Block Size: "
operator|+
name|blockSize
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"           Bytes to write: "
operator|+
name|bytesToWrite
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"       Bytes per checksum: "
operator|+
name|bytesPerChecksum
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"          Number of files: "
operator|+
name|numberOfFiles
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"       Replication factor: "
operator|+
name|replicationFactorPerFile
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"                 Base dir: "
operator|+
name|baseDir
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"     Read file after open: "
operator|+
name|readFileAfterOpen
argument_list|)
expr_stmt|;
comment|// Set user-defined parameters, so the map method can access the values
name|config
operator|.
name|set
argument_list|(
literal|"test.nnbench.operation"
argument_list|,
name|operation
argument_list|)
expr_stmt|;
name|config
operator|.
name|setLong
argument_list|(
literal|"test.nnbench.maps"
argument_list|,
name|numberOfMaps
argument_list|)
expr_stmt|;
name|config
operator|.
name|setLong
argument_list|(
literal|"test.nnbench.reduces"
argument_list|,
name|numberOfReduces
argument_list|)
expr_stmt|;
name|config
operator|.
name|setLong
argument_list|(
literal|"test.nnbench.starttime"
argument_list|,
name|startTime
argument_list|)
expr_stmt|;
name|config
operator|.
name|setLong
argument_list|(
literal|"test.nnbench.blocksize"
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
name|config
operator|.
name|setInt
argument_list|(
literal|"test.nnbench.bytestowrite"
argument_list|,
name|bytesToWrite
argument_list|)
expr_stmt|;
name|config
operator|.
name|setLong
argument_list|(
literal|"test.nnbench.bytesperchecksum"
argument_list|,
name|bytesPerChecksum
argument_list|)
expr_stmt|;
name|config
operator|.
name|setLong
argument_list|(
literal|"test.nnbench.numberoffiles"
argument_list|,
name|numberOfFiles
argument_list|)
expr_stmt|;
name|config
operator|.
name|setInt
argument_list|(
literal|"test.nnbench.replicationfactor"
argument_list|,
operator|(
name|int
operator|)
name|replicationFactorPerFile
argument_list|)
expr_stmt|;
name|config
operator|.
name|set
argument_list|(
literal|"test.nnbench.basedir"
argument_list|,
name|baseDir
argument_list|)
expr_stmt|;
name|config
operator|.
name|setBoolean
argument_list|(
literal|"test.nnbench.readFileAfterOpen"
argument_list|,
name|readFileAfterOpen
argument_list|)
expr_stmt|;
name|config
operator|.
name|set
argument_list|(
literal|"test.nnbench.datadir.name"
argument_list|,
name|DATA_DIR_NAME
argument_list|)
expr_stmt|;
name|config
operator|.
name|set
argument_list|(
literal|"test.nnbench.outputdir.name"
argument_list|,
name|OUTPUT_DIR_NAME
argument_list|)
expr_stmt|;
name|config
operator|.
name|set
argument_list|(
literal|"test.nnbench.controldir.name"
argument_list|,
name|CONTROL_DIR_NAME
argument_list|)
expr_stmt|;
block|}
comment|/**    * Analyze the results    *     * @throws IOException on error    */
DECL|method|analyzeResults ()
specifier|private
specifier|static
name|void
name|analyzeResults
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|config
argument_list|)
decl_stmt|;
name|Path
name|reduceDir
init|=
operator|new
name|Path
argument_list|(
name|baseDir
argument_list|,
name|OUTPUT_DIR_NAME
argument_list|)
decl_stmt|;
name|long
name|totalTimeAL1
init|=
literal|0l
decl_stmt|;
name|long
name|totalTimeAL2
init|=
literal|0l
decl_stmt|;
name|long
name|totalTimeTPmS
init|=
literal|0l
decl_stmt|;
name|long
name|lateMaps
init|=
literal|0l
decl_stmt|;
name|long
name|numOfExceptions
init|=
literal|0l
decl_stmt|;
name|long
name|successfulFileOps
init|=
literal|0l
decl_stmt|;
name|long
name|mapStartTimeTPmS
init|=
literal|0l
decl_stmt|;
name|long
name|mapEndTimeTPmS
init|=
literal|0l
decl_stmt|;
name|FileStatus
index|[]
name|fss
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|reduceDir
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|status
range|:
name|fss
control|)
block|{
name|Path
name|reduceFile
init|=
name|status
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|DataInputStream
name|in
decl_stmt|;
name|in
operator|=
operator|new
name|DataInputStream
argument_list|(
name|fs
operator|.
name|open
argument_list|(
name|reduceFile
argument_list|)
argument_list|)
expr_stmt|;
name|BufferedReader
name|lines
decl_stmt|;
name|lines
operator|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|line
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|lines
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|StringTokenizer
name|tokens
init|=
operator|new
name|StringTokenizer
argument_list|(
name|line
argument_list|,
literal|" \t\n\r\f%;"
argument_list|)
decl_stmt|;
name|String
name|attr
init|=
name|tokens
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|attr
operator|.
name|endsWith
argument_list|(
literal|":totalTimeAL1"
argument_list|)
condition|)
block|{
name|totalTimeAL1
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|tokens
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attr
operator|.
name|endsWith
argument_list|(
literal|":totalTimeAL2"
argument_list|)
condition|)
block|{
name|totalTimeAL2
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|tokens
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attr
operator|.
name|endsWith
argument_list|(
literal|":totalTimeTPmS"
argument_list|)
condition|)
block|{
name|totalTimeTPmS
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|tokens
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attr
operator|.
name|endsWith
argument_list|(
literal|":latemaps"
argument_list|)
condition|)
block|{
name|lateMaps
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|tokens
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attr
operator|.
name|endsWith
argument_list|(
literal|":numOfExceptions"
argument_list|)
condition|)
block|{
name|numOfExceptions
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|tokens
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attr
operator|.
name|endsWith
argument_list|(
literal|":successfulFileOps"
argument_list|)
condition|)
block|{
name|successfulFileOps
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|tokens
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attr
operator|.
name|endsWith
argument_list|(
literal|":mapStartTimeTPmS"
argument_list|)
condition|)
block|{
name|mapStartTimeTPmS
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|tokens
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attr
operator|.
name|endsWith
argument_list|(
literal|":mapEndTimeTPmS"
argument_list|)
condition|)
block|{
name|mapEndTimeTPmS
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|tokens
operator|.
name|nextToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Average latency is the average time to perform 'n' number of
comment|// operations, n being the number of files
name|double
name|avgLatency1
init|=
operator|(
name|double
operator|)
name|totalTimeAL1
operator|/
name|successfulFileOps
decl_stmt|;
name|double
name|avgLatency2
init|=
operator|(
name|double
operator|)
name|totalTimeAL2
operator|/
name|successfulFileOps
decl_stmt|;
comment|// The time it takes for the longest running map is measured. Using that,
comment|// cluster transactions per second is calculated. It includes time to
comment|// retry any of the failed operations
name|double
name|longestMapTimeTPmS
init|=
call|(
name|double
call|)
argument_list|(
name|mapEndTimeTPmS
operator|-
name|mapStartTimeTPmS
argument_list|)
decl_stmt|;
name|double
name|totalTimeTPS
init|=
operator|(
name|longestMapTimeTPmS
operator|==
literal|0
operator|)
condition|?
operator|(
literal|1000
operator|*
name|successfulFileOps
operator|)
else|:
call|(
name|double
call|)
argument_list|(
literal|1000
operator|*
name|successfulFileOps
argument_list|)
operator|/
name|longestMapTimeTPmS
decl_stmt|;
comment|// The time it takes to perform 'n' operations is calculated (in ms),
comment|// n being the number of files. Using that time, the average execution
comment|// time is calculated. It includes time to retry any of the
comment|// failed operations
name|double
name|AverageExecutionTime
init|=
operator|(
name|totalTimeTPmS
operator|==
literal|0
operator|)
condition|?
operator|(
name|double
operator|)
name|successfulFileOps
else|:
operator|(
name|double
operator|)
name|totalTimeTPmS
operator|/
name|successfulFileOps
decl_stmt|;
name|String
name|resultTPSLine1
init|=
literal|null
decl_stmt|;
name|String
name|resultTPSLine2
init|=
literal|null
decl_stmt|;
name|String
name|resultALLine1
init|=
literal|null
decl_stmt|;
name|String
name|resultALLine2
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|operation
operator|.
name|equals
argument_list|(
name|OP_CREATE_WRITE
argument_list|)
condition|)
block|{
comment|// For create/write/close, it is treated as two transactions,
comment|// since a file create from a client perspective involves create and close
name|resultTPSLine1
operator|=
literal|"               TPS: Create/Write/Close: "
operator|+
call|(
name|int
call|)
argument_list|(
name|totalTimeTPS
operator|*
literal|2
argument_list|)
expr_stmt|;
name|resultTPSLine2
operator|=
literal|"Avg exec time (ms): Create/Write/Close: "
operator|+
name|AverageExecutionTime
expr_stmt|;
name|resultALLine1
operator|=
literal|"            Avg Lat (ms): Create/Write: "
operator|+
name|avgLatency1
expr_stmt|;
name|resultALLine2
operator|=
literal|"                   Avg Lat (ms): Close: "
operator|+
name|avgLatency2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|.
name|equals
argument_list|(
name|OP_OPEN_READ
argument_list|)
condition|)
block|{
name|resultTPSLine1
operator|=
literal|"                        TPS: Open/Read: "
operator|+
operator|(
name|int
operator|)
name|totalTimeTPS
expr_stmt|;
name|resultTPSLine2
operator|=
literal|"         Avg Exec time (ms): Open/Read: "
operator|+
name|AverageExecutionTime
expr_stmt|;
name|resultALLine1
operator|=
literal|"                    Avg Lat (ms): Open: "
operator|+
name|avgLatency1
expr_stmt|;
if|if
condition|(
name|readFileAfterOpen
condition|)
block|{
name|resultALLine2
operator|=
literal|"                  Avg Lat (ms): Read: "
operator|+
name|avgLatency2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|operation
operator|.
name|equals
argument_list|(
name|OP_RENAME
argument_list|)
condition|)
block|{
name|resultTPSLine1
operator|=
literal|"                           TPS: Rename: "
operator|+
operator|(
name|int
operator|)
name|totalTimeTPS
expr_stmt|;
name|resultTPSLine2
operator|=
literal|"            Avg Exec time (ms): Rename: "
operator|+
name|AverageExecutionTime
expr_stmt|;
name|resultALLine1
operator|=
literal|"                  Avg Lat (ms): Rename: "
operator|+
name|avgLatency1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|.
name|equals
argument_list|(
name|OP_DELETE
argument_list|)
condition|)
block|{
name|resultTPSLine1
operator|=
literal|"                           TPS: Delete: "
operator|+
operator|(
name|int
operator|)
name|totalTimeTPS
expr_stmt|;
name|resultTPSLine2
operator|=
literal|"            Avg Exec time (ms): Delete: "
operator|+
name|AverageExecutionTime
expr_stmt|;
name|resultALLine1
operator|=
literal|"                  Avg Lat (ms): Delete: "
operator|+
name|avgLatency1
expr_stmt|;
block|}
name|String
name|resultLines
index|[]
init|=
block|{
literal|"-------------- NNBench -------------- : "
block|,
literal|"                               Version: "
operator|+
name|NNBENCH_VERSION
block|,
literal|"                           Date& time: "
operator|+
name|sdf
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
argument_list|)
block|,
literal|""
block|,
literal|"                        Test Operation: "
operator|+
name|operation
block|,
literal|"                            Start time: "
operator|+
name|sdf
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|(
name|startTime
argument_list|)
argument_list|)
block|,
literal|"                           Maps to run: "
operator|+
name|numberOfMaps
block|,
literal|"                        Reduces to run: "
operator|+
name|numberOfReduces
block|,
literal|"                    Block Size (bytes): "
operator|+
name|blockSize
block|,
literal|"                        Bytes to write: "
operator|+
name|bytesToWrite
block|,
literal|"                    Bytes per checksum: "
operator|+
name|bytesPerChecksum
block|,
literal|"                       Number of files: "
operator|+
name|numberOfFiles
block|,
literal|"                    Replication factor: "
operator|+
name|replicationFactorPerFile
block|,
literal|"            Successful file operations: "
operator|+
name|successfulFileOps
block|,
literal|""
block|,
literal|"        # maps that missed the barrier: "
operator|+
name|lateMaps
block|,
literal|"                          # exceptions: "
operator|+
name|numOfExceptions
block|,
literal|""
block|,
name|resultTPSLine1
block|,
name|resultTPSLine2
block|,
name|resultALLine1
block|,
name|resultALLine2
block|,
literal|""
block|,
literal|"                 RAW DATA: AL Total #1: "
operator|+
name|totalTimeAL1
block|,
literal|"                 RAW DATA: AL Total #2: "
operator|+
name|totalTimeAL2
block|,
literal|"              RAW DATA: TPS Total (ms): "
operator|+
name|totalTimeTPmS
block|,
literal|"       RAW DATA: Longest Map Time (ms): "
operator|+
name|longestMapTimeTPmS
block|,
literal|"                   RAW DATA: Late maps: "
operator|+
name|lateMaps
block|,
literal|"             RAW DATA: # of exceptions: "
operator|+
name|numOfExceptions
block|,
literal|""
block|}
decl_stmt|;
name|PrintStream
name|res
init|=
operator|new
name|PrintStream
argument_list|(
operator|new
name|FileOutputStream
argument_list|(
operator|new
name|File
argument_list|(
name|DEFAULT_RES_FILE_NAME
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
comment|// Write to a file and also dump to log
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|resultLines
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|resultLines
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|res
operator|.
name|println
argument_list|(
name|resultLines
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Run the test    *     * @throws IOException on error    */
DECL|method|runTests ()
specifier|public
specifier|static
name|void
name|runTests
parameter_list|()
throws|throws
name|IOException
block|{
name|config
operator|.
name|setLong
argument_list|(
literal|"io.bytes.per.checksum"
argument_list|,
name|bytesPerChecksum
argument_list|)
expr_stmt|;
name|JobConf
name|job
init|=
operator|new
name|JobConf
argument_list|(
name|config
argument_list|,
name|NNBench
operator|.
name|class
argument_list|)
decl_stmt|;
name|job
operator|.
name|setJobName
argument_list|(
literal|"NNBench-"
operator|+
name|operation
argument_list|)
expr_stmt|;
name|FileInputFormat
operator|.
name|setInputPaths
argument_list|(
name|job
argument_list|,
operator|new
name|Path
argument_list|(
name|baseDir
argument_list|,
name|CONTROL_DIR_NAME
argument_list|)
argument_list|)
expr_stmt|;
name|job
operator|.
name|setInputFormat
argument_list|(
name|SequenceFileInputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// Explicitly set number of max map attempts to 1.
name|job
operator|.
name|setMaxMapAttempts
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// Explicitly turn off speculative execution
name|job
operator|.
name|setSpeculativeExecution
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|job
operator|.
name|setMapperClass
argument_list|(
name|NNBenchMapper
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setReducerClass
argument_list|(
name|NNBenchReducer
operator|.
name|class
argument_list|)
expr_stmt|;
name|FileOutputFormat
operator|.
name|setOutputPath
argument_list|(
name|job
argument_list|,
operator|new
name|Path
argument_list|(
name|baseDir
argument_list|,
name|OUTPUT_DIR_NAME
argument_list|)
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputKeyClass
argument_list|(
name|Text
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setOutputValueClass
argument_list|(
name|Text
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setNumReduceTasks
argument_list|(
operator|(
name|int
operator|)
name|numberOfReduces
argument_list|)
expr_stmt|;
name|JobClient
operator|.
name|runJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
comment|/**    * Validate the inputs    */
DECL|method|validateInputs ()
specifier|public
specifier|static
name|void
name|validateInputs
parameter_list|()
block|{
comment|// If it is not one of the four operations, then fail
if|if
condition|(
operator|!
name|operation
operator|.
name|equals
argument_list|(
name|OP_CREATE_WRITE
argument_list|)
operator|&&
operator|!
name|operation
operator|.
name|equals
argument_list|(
name|OP_OPEN_READ
argument_list|)
operator|&&
operator|!
name|operation
operator|.
name|equals
argument_list|(
name|OP_RENAME
argument_list|)
operator|&&
operator|!
name|operation
operator|.
name|equals
argument_list|(
name|OP_DELETE
argument_list|)
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Error: Unknown operation: "
operator|+
name|operation
argument_list|)
expr_stmt|;
name|displayUsage
argument_list|()
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// If number of maps is a negative number, then fail
comment|// Hadoop allows the number of maps to be 0
if|if
condition|(
name|numberOfMaps
operator|<
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Error: Number of maps must be a positive number"
argument_list|)
expr_stmt|;
name|displayUsage
argument_list|()
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// If number of reduces is a negative number or 0, then fail
if|if
condition|(
name|numberOfReduces
operator|<=
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Error: Number of reduces must be a positive number"
argument_list|)
expr_stmt|;
name|displayUsage
argument_list|()
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// If blocksize is a negative number or 0, then fail
if|if
condition|(
name|blockSize
operator|<=
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Error: Block size must be a positive number"
argument_list|)
expr_stmt|;
name|displayUsage
argument_list|()
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// If bytes to write is a negative number, then fail
if|if
condition|(
name|bytesToWrite
operator|<
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Error: Bytes to write must be a positive number"
argument_list|)
expr_stmt|;
name|displayUsage
argument_list|()
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// If bytes per checksum is a negative number, then fail
if|if
condition|(
name|bytesPerChecksum
operator|<
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Error: Bytes per checksum must be a positive number"
argument_list|)
expr_stmt|;
name|displayUsage
argument_list|()
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// If number of files is a negative number, then fail
if|if
condition|(
name|numberOfFiles
operator|<
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Error: Number of files must be a positive number"
argument_list|)
expr_stmt|;
name|displayUsage
argument_list|()
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// If replication factor is a negative number, then fail
if|if
condition|(
name|replicationFactorPerFile
operator|<
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Error: Replication factor must be a positive number"
argument_list|)
expr_stmt|;
name|displayUsage
argument_list|()
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// If block size is not a multiple of bytesperchecksum, fail
if|if
condition|(
name|blockSize
operator|%
name|bytesPerChecksum
operator|!=
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Error: Block Size in bytes must be a multiple of "
operator|+
literal|"bytes per checksum: "
argument_list|)
expr_stmt|;
name|displayUsage
argument_list|()
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**   * Main method for running the NNBench benchmarks   *   * @param args array of command line arguments   * @throws IOException indicates a problem with test startup   */
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Display the application version string
name|displayVersion
argument_list|()
expr_stmt|;
comment|// Parse the inputs
name|parseInputs
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|// Validate inputs
name|validateInputs
argument_list|()
expr_stmt|;
comment|// Clean up files before the test run
name|cleanupBeforeTestrun
argument_list|()
expr_stmt|;
comment|// Create control files before test run
name|createControlFiles
argument_list|()
expr_stmt|;
comment|// Run the tests as a map reduce job
name|runTests
argument_list|()
expr_stmt|;
comment|// Analyze results
name|analyzeResults
argument_list|()
expr_stmt|;
block|}
comment|/**    * Mapper class    */
DECL|class|NNBenchMapper
specifier|static
class|class
name|NNBenchMapper
extends|extends
name|Configured
implements|implements
name|Mapper
argument_list|<
name|Text
argument_list|,
name|LongWritable
argument_list|,
name|Text
argument_list|,
name|Text
argument_list|>
block|{
DECL|field|filesystem
name|FileSystem
name|filesystem
init|=
literal|null
decl_stmt|;
DECL|field|hostName
specifier|private
name|String
name|hostName
init|=
literal|null
decl_stmt|;
DECL|field|numberOfFiles
name|long
name|numberOfFiles
init|=
literal|1l
decl_stmt|;
DECL|field|blkSize
name|long
name|blkSize
init|=
literal|1l
decl_stmt|;
DECL|field|replFactor
name|short
name|replFactor
init|=
literal|1
decl_stmt|;
DECL|field|bytesToWrite
name|int
name|bytesToWrite
init|=
literal|0
decl_stmt|;
DECL|field|baseDir
name|String
name|baseDir
init|=
literal|null
decl_stmt|;
DECL|field|dataDirName
name|String
name|dataDirName
init|=
literal|null
decl_stmt|;
DECL|field|op
name|String
name|op
init|=
literal|null
decl_stmt|;
DECL|field|readFile
name|boolean
name|readFile
init|=
literal|false
decl_stmt|;
DECL|field|MAX_OPERATION_EXCEPTIONS
specifier|final
name|int
name|MAX_OPERATION_EXCEPTIONS
init|=
literal|1000
decl_stmt|;
comment|// Data to collect from the operation
DECL|field|numOfExceptions
name|int
name|numOfExceptions
init|=
literal|0
decl_stmt|;
DECL|field|startTimeAL
name|long
name|startTimeAL
init|=
literal|0l
decl_stmt|;
DECL|field|totalTimeAL1
name|long
name|totalTimeAL1
init|=
literal|0l
decl_stmt|;
DECL|field|totalTimeAL2
name|long
name|totalTimeAL2
init|=
literal|0l
decl_stmt|;
DECL|field|successfulFileOps
name|long
name|successfulFileOps
init|=
literal|0l
decl_stmt|;
comment|/**      * Constructor      */
DECL|method|NNBenchMapper ()
specifier|public
name|NNBenchMapper
parameter_list|()
block|{     }
comment|/**      * Mapper base implementation      */
DECL|method|configure (JobConf conf)
specifier|public
name|void
name|configure
parameter_list|(
name|JobConf
name|conf
parameter_list|)
block|{
name|setConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
try|try
block|{
name|filesystem
operator|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Cannot get file system."
argument_list|,
name|e
argument_list|)
throw|;
block|}
try|try
block|{
name|hostName
operator|=
name|InetAddress
operator|.
name|getLocalHost
argument_list|()
operator|.
name|getHostName
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Error getting hostname"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Mapper base implementation      */
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{     }
comment|/**      * Returns when the current number of seconds from the epoch equals      * the command line argument given by<code>-startTime</code>.      * This allows multiple instances of this program, running on clock      * synchronized nodes, to start at roughly the same time.      * @return true if the method was able to sleep for<code>-startTime</code>      * without interruption; false otherwise      */
DECL|method|barrier ()
specifier|private
name|boolean
name|barrier
parameter_list|()
block|{
name|long
name|startTime
init|=
name|getConf
argument_list|()
operator|.
name|getLong
argument_list|(
literal|"test.nnbench.starttime"
argument_list|,
literal|0l
argument_list|)
decl_stmt|;
name|long
name|currentTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|long
name|sleepTime
init|=
name|startTime
operator|-
name|currentTime
decl_stmt|;
name|boolean
name|retVal
init|=
literal|false
decl_stmt|;
comment|// If the sleep time is greater than 0, then sleep and return
if|if
condition|(
name|sleepTime
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting in barrier for: "
operator|+
name|sleepTime
operator|+
literal|" ms"
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepTime
argument_list|)
expr_stmt|;
name|retVal
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|retVal
operator|=
literal|false
expr_stmt|;
block|}
block|}
return|return
name|retVal
return|;
block|}
comment|/**      * Map method      */
DECL|method|map (Text key, LongWritable value, OutputCollector<Text, Text> output, Reporter reporter)
specifier|public
name|void
name|map
parameter_list|(
name|Text
name|key
parameter_list|,
name|LongWritable
name|value
parameter_list|,
name|OutputCollector
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|output
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
name|filesystem
operator|.
name|getConf
argument_list|()
decl_stmt|;
name|numberOfFiles
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"test.nnbench.numberoffiles"
argument_list|,
literal|1l
argument_list|)
expr_stmt|;
name|blkSize
operator|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"test.nnbench.blocksize"
argument_list|,
literal|1l
argument_list|)
expr_stmt|;
name|replFactor
operator|=
call|(
name|short
call|)
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
literal|"test.nnbench.replicationfactor"
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|bytesToWrite
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"test.nnbench.bytestowrite"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|baseDir
operator|=
name|conf
operator|.
name|get
argument_list|(
literal|"test.nnbench.basedir"
argument_list|)
expr_stmt|;
name|dataDirName
operator|=
name|conf
operator|.
name|get
argument_list|(
literal|"test.nnbench.datadir.name"
argument_list|)
expr_stmt|;
name|op
operator|=
name|conf
operator|.
name|get
argument_list|(
literal|"test.nnbench.operation"
argument_list|)
expr_stmt|;
name|readFile
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"test.nnbench.readFileAfterOpen"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|long
name|totalTimeTPmS
init|=
literal|0l
decl_stmt|;
name|long
name|startTimeTPmS
init|=
literal|0l
decl_stmt|;
name|long
name|endTimeTPms
init|=
literal|0l
decl_stmt|;
name|numOfExceptions
operator|=
literal|0
expr_stmt|;
name|startTimeAL
operator|=
literal|0l
expr_stmt|;
name|totalTimeAL1
operator|=
literal|0l
expr_stmt|;
name|totalTimeAL2
operator|=
literal|0l
expr_stmt|;
name|successfulFileOps
operator|=
literal|0l
expr_stmt|;
if|if
condition|(
name|barrier
argument_list|()
condition|)
block|{
name|String
name|fileName
init|=
literal|"file_"
operator|+
name|value
decl_stmt|;
if|if
condition|(
name|op
operator|.
name|equals
argument_list|(
name|OP_CREATE_WRITE
argument_list|)
condition|)
block|{
name|startTimeTPmS
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|doCreateWriteOp
argument_list|(
name|fileName
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|.
name|equals
argument_list|(
name|OP_OPEN_READ
argument_list|)
condition|)
block|{
name|startTimeTPmS
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|doOpenReadOp
argument_list|(
name|fileName
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|.
name|equals
argument_list|(
name|OP_RENAME
argument_list|)
condition|)
block|{
name|startTimeTPmS
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|doRenameOp
argument_list|(
name|fileName
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|.
name|equals
argument_list|(
name|OP_DELETE
argument_list|)
condition|)
block|{
name|startTimeTPmS
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|doDeleteOp
argument_list|(
name|fileName
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"unsupported operation ["
operator|+
name|op
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|endTimeTPms
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|totalTimeTPmS
operator|=
name|endTimeTPms
operator|-
name|startTimeTPmS
expr_stmt|;
block|}
else|else
block|{
name|output
operator|.
name|collect
argument_list|(
operator|new
name|Text
argument_list|(
literal|"l:latemaps"
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// collect after the map end time is measured
name|output
operator|.
name|collect
argument_list|(
operator|new
name|Text
argument_list|(
literal|"l:totalTimeAL1"
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|totalTimeAL1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|.
name|collect
argument_list|(
operator|new
name|Text
argument_list|(
literal|"l:totalTimeAL2"
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|totalTimeAL2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|.
name|collect
argument_list|(
operator|new
name|Text
argument_list|(
literal|"l:numOfExceptions"
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|numOfExceptions
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|.
name|collect
argument_list|(
operator|new
name|Text
argument_list|(
literal|"l:successfulFileOps"
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|successfulFileOps
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|.
name|collect
argument_list|(
operator|new
name|Text
argument_list|(
literal|"l:totalTimeTPmS"
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|totalTimeTPmS
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|.
name|collect
argument_list|(
operator|new
name|Text
argument_list|(
literal|"min:mapStartTimeTPmS"
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|startTimeTPmS
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|output
operator|.
name|collect
argument_list|(
operator|new
name|Text
argument_list|(
literal|"max:mapEndTimeTPmS"
argument_list|)
argument_list|,
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|endTimeTPms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create and Write operation.      * @param name of the prefix of the putput file to be created      * @param reporter an instanse of (@link Reporter) to be used for      *   status' updates      */
DECL|method|doCreateWriteOp (String name, Reporter reporter)
specifier|private
name|void
name|doCreateWriteOp
parameter_list|(
name|String
name|name
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
block|{
name|FSDataOutputStream
name|out
decl_stmt|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
name|bytesToWrite
index|]
decl_stmt|;
for|for
control|(
name|long
name|l
init|=
literal|0l
init|;
name|l
operator|<
name|numberOfFiles
condition|;
name|l
operator|++
control|)
block|{
name|Path
name|filePath
init|=
operator|new
name|Path
argument_list|(
operator|new
name|Path
argument_list|(
name|baseDir
argument_list|,
name|dataDirName
argument_list|)
argument_list|,
name|name
operator|+
literal|"_"
operator|+
name|l
argument_list|)
decl_stmt|;
name|boolean
name|successfulOp
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|successfulOp
operator|&&
name|numOfExceptions
operator|<
name|MAX_OPERATION_EXCEPTIONS
condition|)
block|{
try|try
block|{
comment|// Set up timer for measuring AL (transaction #1)
name|startTimeAL
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
comment|// Create the file
comment|// Use a buffer size of 512
name|out
operator|=
name|filesystem
operator|.
name|create
argument_list|(
name|filePath
argument_list|,
literal|true
argument_list|,
literal|512
argument_list|,
name|replFactor
argument_list|,
name|blkSize
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|totalTimeAL1
operator|+=
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTimeAL
operator|)
expr_stmt|;
comment|// Close the file / file output stream
comment|// Set up timers for measuring AL (transaction #2)
name|startTimeAL
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|totalTimeAL2
operator|+=
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTimeAL
operator|)
expr_stmt|;
name|successfulOp
operator|=
literal|true
expr_stmt|;
name|successfulFileOps
operator|++
expr_stmt|;
name|reporter
operator|.
name|setStatus
argument_list|(
literal|"Finish "
operator|+
name|l
operator|+
literal|" files"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception recorded in op: Create/Write/Close, "
operator|+
literal|"file: \""
operator|+
name|filePath
operator|+
literal|"\""
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|numOfExceptions
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Open operation      * @param name of the prefix of the putput file to be read      * @param reporter an instanse of (@link Reporter) to be used for      *   status' updates      */
DECL|method|doOpenReadOp (String name, Reporter reporter)
specifier|private
name|void
name|doOpenReadOp
parameter_list|(
name|String
name|name
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
block|{
name|FSDataInputStream
name|input
decl_stmt|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
name|bytesToWrite
index|]
decl_stmt|;
for|for
control|(
name|long
name|l
init|=
literal|0l
init|;
name|l
operator|<
name|numberOfFiles
condition|;
name|l
operator|++
control|)
block|{
name|Path
name|filePath
init|=
operator|new
name|Path
argument_list|(
operator|new
name|Path
argument_list|(
name|baseDir
argument_list|,
name|dataDirName
argument_list|)
argument_list|,
name|name
operator|+
literal|"_"
operator|+
name|l
argument_list|)
decl_stmt|;
name|boolean
name|successfulOp
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|successfulOp
operator|&&
name|numOfExceptions
operator|<
name|MAX_OPERATION_EXCEPTIONS
condition|)
block|{
try|try
block|{
comment|// Set up timer for measuring AL
name|startTimeAL
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|input
operator|=
name|filesystem
operator|.
name|open
argument_list|(
name|filePath
argument_list|)
expr_stmt|;
name|totalTimeAL1
operator|+=
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTimeAL
operator|)
expr_stmt|;
comment|// If the file needs to be read (specified at command line)
if|if
condition|(
name|readFile
condition|)
block|{
name|startTimeAL
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|input
operator|.
name|readFully
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|totalTimeAL2
operator|+=
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTimeAL
operator|)
expr_stmt|;
block|}
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|successfulOp
operator|=
literal|true
expr_stmt|;
name|successfulFileOps
operator|++
expr_stmt|;
name|reporter
operator|.
name|setStatus
argument_list|(
literal|"Finish "
operator|+
name|l
operator|+
literal|" files"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception recorded in op: OpenRead, "
operator|+
literal|"file: \""
operator|+
name|filePath
operator|+
literal|"\""
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|numOfExceptions
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Rename operation      * @param name of prefix of the file to be renamed      * @param reporter an instanse of (@link Reporter) to be used for      *   status' updates      */
DECL|method|doRenameOp (String name, Reporter reporter)
specifier|private
name|void
name|doRenameOp
parameter_list|(
name|String
name|name
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
block|{
for|for
control|(
name|long
name|l
init|=
literal|0l
init|;
name|l
operator|<
name|numberOfFiles
condition|;
name|l
operator|++
control|)
block|{
name|Path
name|filePath
init|=
operator|new
name|Path
argument_list|(
operator|new
name|Path
argument_list|(
name|baseDir
argument_list|,
name|dataDirName
argument_list|)
argument_list|,
name|name
operator|+
literal|"_"
operator|+
name|l
argument_list|)
decl_stmt|;
name|Path
name|filePathR
init|=
operator|new
name|Path
argument_list|(
operator|new
name|Path
argument_list|(
name|baseDir
argument_list|,
name|dataDirName
argument_list|)
argument_list|,
name|name
operator|+
literal|"_r_"
operator|+
name|l
argument_list|)
decl_stmt|;
name|boolean
name|successfulOp
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|successfulOp
operator|&&
name|numOfExceptions
operator|<
name|MAX_OPERATION_EXCEPTIONS
condition|)
block|{
try|try
block|{
comment|// Set up timer for measuring AL
name|startTimeAL
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|filesystem
operator|.
name|rename
argument_list|(
name|filePath
argument_list|,
name|filePathR
argument_list|)
expr_stmt|;
name|totalTimeAL1
operator|+=
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTimeAL
operator|)
expr_stmt|;
name|successfulOp
operator|=
literal|true
expr_stmt|;
name|successfulFileOps
operator|++
expr_stmt|;
name|reporter
operator|.
name|setStatus
argument_list|(
literal|"Finish "
operator|+
name|l
operator|+
literal|" files"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception recorded in op: Rename, "
operator|+
literal|"file: \""
operator|+
name|filePath
operator|+
literal|"\""
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|numOfExceptions
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Delete operation      * @param name of prefix of the file to be deleted      * @param reporter an instanse of (@link Reporter) to be used for      *   status' updates      */
DECL|method|doDeleteOp (String name, Reporter reporter)
specifier|private
name|void
name|doDeleteOp
parameter_list|(
name|String
name|name
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
block|{
for|for
control|(
name|long
name|l
init|=
literal|0l
init|;
name|l
operator|<
name|numberOfFiles
condition|;
name|l
operator|++
control|)
block|{
name|Path
name|filePath
init|=
operator|new
name|Path
argument_list|(
operator|new
name|Path
argument_list|(
name|baseDir
argument_list|,
name|dataDirName
argument_list|)
argument_list|,
name|name
operator|+
literal|"_"
operator|+
name|l
argument_list|)
decl_stmt|;
name|boolean
name|successfulOp
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|successfulOp
operator|&&
name|numOfExceptions
operator|<
name|MAX_OPERATION_EXCEPTIONS
condition|)
block|{
try|try
block|{
comment|// Set up timer for measuring AL
name|startTimeAL
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|filesystem
operator|.
name|delete
argument_list|(
name|filePath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|totalTimeAL1
operator|+=
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|startTimeAL
operator|)
expr_stmt|;
name|successfulOp
operator|=
literal|true
expr_stmt|;
name|successfulFileOps
operator|++
expr_stmt|;
name|reporter
operator|.
name|setStatus
argument_list|(
literal|"Finish "
operator|+
name|l
operator|+
literal|" files"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception recorded in op: Delete, "
operator|+
literal|"file: \""
operator|+
name|filePath
operator|+
literal|"\""
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|numOfExceptions
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**    * Reducer class    */
DECL|class|NNBenchReducer
specifier|static
class|class
name|NNBenchReducer
extends|extends
name|MapReduceBase
implements|implements
name|Reducer
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|,
name|Text
argument_list|,
name|Text
argument_list|>
block|{
DECL|field|hostName
specifier|protected
name|String
name|hostName
decl_stmt|;
DECL|method|NNBenchReducer ()
specifier|public
name|NNBenchReducer
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting NNBenchReducer !!!"
argument_list|)
expr_stmt|;
try|try
block|{
name|hostName
operator|=
name|java
operator|.
name|net
operator|.
name|InetAddress
operator|.
name|getLocalHost
argument_list|()
operator|.
name|getHostName
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|hostName
operator|=
literal|"localhost"
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting NNBenchReducer on "
operator|+
name|hostName
argument_list|)
expr_stmt|;
block|}
comment|/**      * Reduce method      */
DECL|method|reduce (Text key, Iterator<Text> values, OutputCollector<Text, Text> output, Reporter reporter )
specifier|public
name|void
name|reduce
parameter_list|(
name|Text
name|key
parameter_list|,
name|Iterator
argument_list|<
name|Text
argument_list|>
name|values
parameter_list|,
name|OutputCollector
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|output
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|field
init|=
name|key
operator|.
name|toString
argument_list|()
decl_stmt|;
name|reporter
operator|.
name|setStatus
argument_list|(
literal|"starting "
operator|+
name|field
operator|+
literal|" ::host = "
operator|+
name|hostName
argument_list|)
expr_stmt|;
comment|// sum long values
if|if
condition|(
name|field
operator|.
name|startsWith
argument_list|(
literal|"l:"
argument_list|)
condition|)
block|{
name|long
name|lSum
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|values
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|lSum
operator|+=
name|Long
operator|.
name|parseLong
argument_list|(
name|values
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|output
operator|.
name|collect
argument_list|(
name|key
argument_list|,
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|lSum
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|field
operator|.
name|startsWith
argument_list|(
literal|"min:"
argument_list|)
condition|)
block|{
name|long
name|minVal
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|values
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|long
name|value
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|values
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|minVal
operator|==
operator|-
literal|1
condition|)
block|{
name|minVal
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|value
operator|<
name|minVal
condition|)
block|{
name|minVal
operator|=
name|value
expr_stmt|;
block|}
block|}
block|}
name|output
operator|.
name|collect
argument_list|(
name|key
argument_list|,
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|minVal
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|field
operator|.
name|startsWith
argument_list|(
literal|"max:"
argument_list|)
condition|)
block|{
name|long
name|maxVal
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|values
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|long
name|value
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|values
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxVal
operator|==
operator|-
literal|1
condition|)
block|{
name|maxVal
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|value
operator|>
name|maxVal
condition|)
block|{
name|maxVal
operator|=
name|value
expr_stmt|;
block|}
block|}
block|}
name|output
operator|.
name|collect
argument_list|(
name|key
argument_list|,
operator|new
name|Text
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|maxVal
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|reporter
operator|.
name|setStatus
argument_list|(
literal|"finished "
operator|+
name|field
operator|+
literal|" ::host = "
operator|+
name|hostName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

