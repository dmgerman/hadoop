begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.slive
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|slive
package|;
end_package

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|NumberFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|slive
operator|.
name|Constants
operator|.
name|Distribution
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|slive
operator|.
name|Constants
operator|.
name|OperationType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|slive
operator|.
name|Weights
operator|.
name|UniformWeight
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|slive
operator|.
name|ObserveableOp
operator|.
name|Observer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_comment
comment|/**  * This class is the main handler that selects operations to run using the  * currently held selection object. It configures and weights each operation and  * then hands the operations + weights off to the selector object to determine  * which one should be ran. If no operations are left to be ran then it will  * return null.  */
end_comment

begin_class
DECL|class|WeightSelector
class|class
name|WeightSelector
block|{
comment|// what a weight calculation means
DECL|interface|Weightable
interface|interface
name|Weightable
block|{
DECL|method|weight (int elapsed, int duration)
name|Double
name|weight
parameter_list|(
name|int
name|elapsed
parameter_list|,
name|int
name|duration
parameter_list|)
function_decl|;
block|}
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|WeightSelector
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|class|OperationInfo
specifier|private
specifier|static
class|class
name|OperationInfo
block|{
DECL|field|amountLeft
name|Integer
name|amountLeft
decl_stmt|;
DECL|field|operation
name|Operation
name|operation
decl_stmt|;
DECL|field|distribution
name|Distribution
name|distribution
decl_stmt|;
block|}
DECL|field|operations
specifier|private
name|Map
argument_list|<
name|OperationType
argument_list|,
name|OperationInfo
argument_list|>
name|operations
decl_stmt|;
DECL|field|weights
specifier|private
name|Map
argument_list|<
name|Distribution
argument_list|,
name|Weightable
argument_list|>
name|weights
decl_stmt|;
DECL|field|selector
specifier|private
name|RouletteSelector
name|selector
decl_stmt|;
DECL|field|factory
specifier|private
name|OperationFactory
name|factory
decl_stmt|;
DECL|method|WeightSelector (ConfigExtractor cfg, Random rnd)
name|WeightSelector
parameter_list|(
name|ConfigExtractor
name|cfg
parameter_list|,
name|Random
name|rnd
parameter_list|)
block|{
name|selector
operator|=
operator|new
name|RouletteSelector
argument_list|(
name|rnd
argument_list|)
expr_stmt|;
name|factory
operator|=
operator|new
name|OperationFactory
argument_list|(
name|cfg
argument_list|,
name|rnd
argument_list|)
expr_stmt|;
name|configureOperations
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|configureWeights
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
block|}
DECL|method|getSelector ()
specifier|protected
name|RouletteSelector
name|getSelector
parameter_list|()
block|{
return|return
name|selector
return|;
block|}
DECL|method|configureWeights (ConfigExtractor e)
specifier|private
name|void
name|configureWeights
parameter_list|(
name|ConfigExtractor
name|e
parameter_list|)
block|{
name|weights
operator|=
operator|new
name|HashMap
argument_list|<
name|Distribution
argument_list|,
name|Weightable
argument_list|>
argument_list|()
expr_stmt|;
name|weights
operator|.
name|put
argument_list|(
name|Distribution
operator|.
name|UNIFORM
argument_list|,
operator|new
name|UniformWeight
argument_list|()
argument_list|)
expr_stmt|;
comment|// weights.put(Distribution.BEG, new BeginWeight());
comment|// weights.put(Distribution.END, new EndWeight());
comment|// weights.put(Distribution.MID, new MidWeight());
block|}
comment|/**    * Determines how many initial operations a given operation data should have    *     * @param totalAm    *          the total amount of operations allowed    *     * @param opData    *          the given operation information (with a valid percentage>= 0)    *     * @return the number of items to allow to run    *     * @throws IllegalArgumentException    *           if negative operations are determined    */
DECL|method|determineHowMany (int totalAm, OperationData opData, OperationType type)
specifier|static
name|int
name|determineHowMany
parameter_list|(
name|int
name|totalAm
parameter_list|,
name|OperationData
name|opData
parameter_list|,
name|OperationType
name|type
parameter_list|)
block|{
if|if
condition|(
name|totalAm
operator|<=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|amLeft
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|floor
argument_list|(
name|opData
operator|.
name|getPercent
argument_list|()
operator|*
name|totalAm
argument_list|)
decl_stmt|;
if|if
condition|(
name|amLeft
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid amount "
operator|+
name|amLeft
operator|+
literal|" determined for operation type "
operator|+
name|type
operator|.
name|name
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|amLeft
return|;
block|}
comment|/**    * Sets up the operation using the given configuration by setting up the    * number of operations to perform (and how many are left) and setting up the    * operation objects to be used throughout selection.    *     * @param cfg    *          ConfigExtractor.    */
DECL|method|configureOperations (ConfigExtractor cfg)
specifier|private
name|void
name|configureOperations
parameter_list|(
name|ConfigExtractor
name|cfg
parameter_list|)
block|{
name|operations
operator|=
operator|new
name|TreeMap
argument_list|<
name|OperationType
argument_list|,
name|OperationInfo
argument_list|>
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|OperationType
argument_list|,
name|OperationData
argument_list|>
name|opinfo
init|=
name|cfg
operator|.
name|getOperations
argument_list|()
decl_stmt|;
name|int
name|totalAm
init|=
name|cfg
operator|.
name|getOpCount
argument_list|()
decl_stmt|;
name|int
name|opsLeft
init|=
name|totalAm
decl_stmt|;
name|NumberFormat
name|formatter
init|=
name|Formatter
operator|.
name|getPercentFormatter
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|OperationType
name|type
range|:
name|opinfo
operator|.
name|keySet
argument_list|()
control|)
block|{
name|OperationData
name|opData
init|=
name|opinfo
operator|.
name|get
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|OperationInfo
name|info
init|=
operator|new
name|OperationInfo
argument_list|()
decl_stmt|;
name|info
operator|.
name|distribution
operator|=
name|opData
operator|.
name|getDistribution
argument_list|()
expr_stmt|;
name|int
name|amLeft
init|=
name|determineHowMany
argument_list|(
name|totalAm
argument_list|,
name|opData
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|opsLeft
operator|-=
name|amLeft
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|type
operator|.
name|name
argument_list|()
operator|+
literal|" has "
operator|+
name|amLeft
operator|+
literal|" initial operations out of "
operator|+
name|totalAm
operator|+
literal|" for its ratio "
operator|+
name|formatter
operator|.
name|format
argument_list|(
name|opData
operator|.
name|getPercent
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|.
name|amountLeft
operator|=
name|amLeft
expr_stmt|;
name|Operation
name|op
init|=
name|factory
operator|.
name|getOperation
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|// wrap operation in finalizer so that amount left gets decrements when
comment|// its done
if|if
condition|(
name|op
operator|!=
literal|null
condition|)
block|{
name|Observer
name|fn
init|=
operator|new
name|Observer
argument_list|()
block|{
specifier|public
name|void
name|notifyFinished
parameter_list|(
name|Operation
name|op
parameter_list|)
block|{
name|OperationInfo
name|opInfo
init|=
name|operations
operator|.
name|get
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|opInfo
operator|!=
literal|null
condition|)
block|{
operator|--
name|opInfo
operator|.
name|amountLeft
expr_stmt|;
block|}
block|}
specifier|public
name|void
name|notifyStarting
parameter_list|(
name|Operation
name|op
parameter_list|)
block|{           }
block|}
decl_stmt|;
name|info
operator|.
name|operation
operator|=
operator|new
name|ObserveableOp
argument_list|(
name|op
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|operations
operator|.
name|put
argument_list|(
name|type
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|opsLeft
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|opsLeft
operator|+
literal|" left over operations found (due to inability to support partial operations)"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Selects an operation from the known operation set or returns null if none    * are available by applying the weighting algorithms and then handing off the    * weight operations to the selection object.    *     * @param elapsed    *          the currently elapsed time (milliseconds) of the running program    * @param duration    *          the maximum amount of milliseconds of the running program    *     * @return operation or null if none left    */
DECL|method|select (int elapsed, int duration)
name|Operation
name|select
parameter_list|(
name|int
name|elapsed
parameter_list|,
name|int
name|duration
parameter_list|)
block|{
name|List
argument_list|<
name|OperationWeight
argument_list|>
name|validOps
init|=
operator|new
name|ArrayList
argument_list|<
name|OperationWeight
argument_list|>
argument_list|(
name|operations
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|OperationType
name|type
range|:
name|operations
operator|.
name|keySet
argument_list|()
control|)
block|{
name|OperationInfo
name|opinfo
init|=
name|operations
operator|.
name|get
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|opinfo
operator|==
literal|null
operator|||
name|opinfo
operator|.
name|amountLeft
operator|<=
literal|0
condition|)
block|{
continue|continue;
block|}
name|Weightable
name|weighter
init|=
name|weights
operator|.
name|get
argument_list|(
name|opinfo
operator|.
name|distribution
argument_list|)
decl_stmt|;
if|if
condition|(
name|weighter
operator|!=
literal|null
condition|)
block|{
name|OperationWeight
name|weightOp
init|=
operator|new
name|OperationWeight
argument_list|(
name|opinfo
operator|.
name|operation
argument_list|,
name|weighter
operator|.
name|weight
argument_list|(
name|elapsed
argument_list|,
name|duration
argument_list|)
argument_list|)
decl_stmt|;
name|validOps
operator|.
name|add
argument_list|(
name|weightOp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Unable to get weight for distribution "
operator|+
name|opinfo
operator|.
name|distribution
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|validOps
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|getSelector
argument_list|()
operator|.
name|select
argument_list|(
name|validOps
argument_list|)
return|;
block|}
block|}
end_class

end_unit

