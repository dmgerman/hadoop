begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapreduce.util
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|util
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_comment
comment|/**  * A test for MRAsyncDiskService.  */
end_comment

begin_class
DECL|class|TestMRAsyncDiskService
specifier|public
class|class
name|TestMRAsyncDiskService
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TestMRAsyncDiskService
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TEST_ROOT_DIR
specifier|private
specifier|static
name|String
name|TEST_ROOT_DIR
init|=
operator|new
name|Path
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"test.build.data"
argument_list|,
literal|"/tmp"
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
annotation|@
name|Before
DECL|method|setUp ()
specifier|public
name|void
name|setUp
parameter_list|()
block|{
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
operator|new
name|File
argument_list|(
name|TEST_ROOT_DIR
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Given 'pathname', compute an equivalent path relative to the cwd.    * @param pathname the path to a directory.    * @return the path to that same directory, relative to ${user.dir}.    */
DECL|method|relativeToWorking (String pathname)
specifier|private
name|String
name|relativeToWorking
parameter_list|(
name|String
name|pathname
parameter_list|)
block|{
name|String
name|cwd
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"user.dir"
argument_list|,
literal|"/"
argument_list|)
decl_stmt|;
comment|// normalize pathname and cwd into full directory paths.
name|pathname
operator|=
operator|(
operator|new
name|Path
argument_list|(
name|pathname
argument_list|)
operator|)
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
expr_stmt|;
name|cwd
operator|=
operator|(
operator|new
name|Path
argument_list|(
name|cwd
argument_list|)
operator|)
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
expr_stmt|;
name|String
index|[]
name|cwdParts
init|=
name|cwd
operator|.
name|split
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
decl_stmt|;
name|String
index|[]
name|pathParts
init|=
name|pathname
operator|.
name|split
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
decl_stmt|;
comment|// There are three possible cases:
comment|// 1) pathname and cwd are equal. Return '.'
comment|// 2) pathname is under cwd. Return the components that are under it.
comment|//     e.g., cwd = /a/b, path = /a/b/c, return 'c'
comment|// 3) pathname is outside of cwd. Find the common components, if any,
comment|//    and subtract them from the returned path, then return enough '..'
comment|//    components to "undo" the non-common components of cwd, then all
comment|//    the remaining parts of pathname.
comment|//    e.g., cwd = /a/b, path = /a/c, return '../c'
if|if
condition|(
name|cwd
operator|.
name|equals
argument_list|(
name|pathname
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"relative to working: "
operator|+
name|pathname
operator|+
literal|" -> ."
argument_list|)
expr_stmt|;
return|return
literal|"."
return|;
comment|// They match exactly.
block|}
comment|// Determine how many path components are in common between cwd and path.
name|int
name|common
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Math
operator|.
name|min
argument_list|(
name|cwdParts
operator|.
name|length
argument_list|,
name|pathParts
operator|.
name|length
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cwdParts
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
name|pathParts
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|common
operator|++
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
comment|// output path stringbuilder.
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// For everything in cwd that isn't in pathname, add a '..' to undo it.
name|int
name|parentDirsRequired
init|=
name|cwdParts
operator|.
name|length
operator|-
name|common
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parentDirsRequired
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
expr_stmt|;
block|}
comment|// Then append all non-common parts of 'pathname' itself.
for|for
control|(
name|int
name|i
init|=
name|common
init|;
name|i
operator|<
name|pathParts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|pathParts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
expr_stmt|;
block|}
comment|// Don't end with a '/'.
name|String
name|s
init|=
name|sb
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|endsWith
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
condition|)
block|{
name|s
operator|=
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"relative to working: "
operator|+
name|pathname
operator|+
literal|" -> "
operator|+
name|s
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
annotation|@
name|Test
comment|/** Test that the relativeToWorking() method above does what we expect. */
DECL|method|testRelativeToWorking ()
specifier|public
name|void
name|testRelativeToWorking
parameter_list|()
block|{
name|assertEquals
argument_list|(
literal|"."
argument_list|,
name|relativeToWorking
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"user.dir"
argument_list|,
literal|"."
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|cwd
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"user.dir"
argument_list|,
literal|"."
argument_list|)
decl_stmt|;
name|Path
name|cwdPath
init|=
operator|new
name|Path
argument_list|(
name|cwd
argument_list|)
decl_stmt|;
name|Path
name|subdir
init|=
operator|new
name|Path
argument_list|(
name|cwdPath
argument_list|,
literal|"foo"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"foo"
argument_list|,
name|relativeToWorking
argument_list|(
name|subdir
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|subsubdir
init|=
operator|new
name|Path
argument_list|(
name|subdir
argument_list|,
literal|"bar"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"foo/bar"
argument_list|,
name|relativeToWorking
argument_list|(
name|subsubdir
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|parent
init|=
operator|new
name|Path
argument_list|(
name|cwdPath
argument_list|,
literal|".."
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|".."
argument_list|,
name|relativeToWorking
argument_list|(
name|parent
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|sideways
init|=
operator|new
name|Path
argument_list|(
name|parent
argument_list|,
literal|"baz"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"../baz"
argument_list|,
name|relativeToWorking
argument_list|(
name|sideways
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test that volumes specified as relative paths are handled properly    * by MRAsyncDiskService (MAPREDUCE-1887).    */
DECL|method|testVolumeNormalization ()
specifier|public
name|void
name|testVolumeNormalization
parameter_list|()
throws|throws
name|Throwable
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"TEST_ROOT_DIR is "
operator|+
name|TEST_ROOT_DIR
argument_list|)
expr_stmt|;
name|String
name|relativeTestRoot
init|=
name|relativeToWorking
argument_list|(
name|TEST_ROOT_DIR
argument_list|)
decl_stmt|;
name|FileSystem
name|localFileSystem
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|)
decl_stmt|;
name|String
index|[]
name|vols
init|=
operator|new
name|String
index|[]
block|{
name|relativeTestRoot
operator|+
literal|"/0"
block|,
name|relativeTestRoot
operator|+
literal|"/1"
block|}
decl_stmt|;
comment|// Put a file in one of the volumes to be cleared on startup.
name|Path
name|delDir
init|=
operator|new
name|Path
argument_list|(
name|vols
index|[
literal|0
index|]
argument_list|,
name|MRAsyncDiskService
operator|.
name|TOBEDELETED
argument_list|)
decl_stmt|;
name|localFileSystem
operator|.
name|mkdirs
argument_list|(
name|delDir
argument_list|)
expr_stmt|;
name|localFileSystem
operator|.
name|create
argument_list|(
operator|new
name|Path
argument_list|(
name|delDir
argument_list|,
literal|"foo"
argument_list|)
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
name|MRAsyncDiskService
name|service
init|=
operator|new
name|MRAsyncDiskService
argument_list|(
name|localFileSystem
argument_list|,
name|vols
argument_list|)
decl_stmt|;
name|makeSureCleanedUp
argument_list|(
name|vols
argument_list|,
name|service
argument_list|)
expr_stmt|;
block|}
comment|/**    * This test creates some directories and then removes them through     * MRAsyncDiskService.     */
annotation|@
name|Test
DECL|method|testMRAsyncDiskService ()
specifier|public
name|void
name|testMRAsyncDiskService
parameter_list|()
throws|throws
name|Throwable
block|{
name|FileSystem
name|localFileSystem
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|)
decl_stmt|;
name|String
index|[]
name|vols
init|=
operator|new
name|String
index|[]
block|{
name|TEST_ROOT_DIR
operator|+
literal|"/0"
block|,
name|TEST_ROOT_DIR
operator|+
literal|"/1"
block|}
decl_stmt|;
name|MRAsyncDiskService
name|service
init|=
operator|new
name|MRAsyncDiskService
argument_list|(
name|localFileSystem
argument_list|,
name|vols
argument_list|)
decl_stmt|;
name|String
name|a
init|=
literal|"a"
decl_stmt|;
name|String
name|b
init|=
literal|"b"
decl_stmt|;
name|String
name|c
init|=
literal|"b/c"
decl_stmt|;
name|String
name|d
init|=
literal|"d"
decl_stmt|;
name|File
name|fa
init|=
operator|new
name|File
argument_list|(
name|vols
index|[
literal|0
index|]
argument_list|,
name|a
argument_list|)
decl_stmt|;
name|File
name|fb
init|=
operator|new
name|File
argument_list|(
name|vols
index|[
literal|1
index|]
argument_list|,
name|b
argument_list|)
decl_stmt|;
name|File
name|fc
init|=
operator|new
name|File
argument_list|(
name|vols
index|[
literal|1
index|]
argument_list|,
name|c
argument_list|)
decl_stmt|;
name|File
name|fd
init|=
operator|new
name|File
argument_list|(
name|vols
index|[
literal|1
index|]
argument_list|,
name|d
argument_list|)
decl_stmt|;
comment|// Create the directories
name|fa
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|fb
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|fc
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|fd
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|fa
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fb
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fd
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
comment|// Move and delete them
name|service
operator|.
name|moveAndDeleteRelativePath
argument_list|(
name|vols
index|[
literal|0
index|]
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fa
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|service
operator|.
name|moveAndDeleteRelativePath
argument_list|(
name|vols
index|[
literal|1
index|]
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fb
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|service
operator|.
name|moveAndDeleteRelativePath
argument_list|(
name|vols
index|[
literal|1
index|]
argument_list|,
literal|"not_exists"
argument_list|)
argument_list|)
expr_stmt|;
comment|// asyncDiskService is NOT able to delete files outside all volumes.
name|IOException
name|ee
init|=
literal|null
decl_stmt|;
try|try
block|{
name|service
operator|.
name|moveAndDeleteAbsolutePath
argument_list|(
name|TEST_ROOT_DIR
operator|+
literal|"/2"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|ee
operator|=
name|e
expr_stmt|;
block|}
name|assertNotNull
argument_list|(
literal|"asyncDiskService should not be able to delete files "
operator|+
literal|"outside all volumes"
argument_list|,
name|ee
argument_list|)
expr_stmt|;
comment|// asyncDiskService is able to automatically find the file in one
comment|// of the volumes.
name|assertTrue
argument_list|(
name|service
operator|.
name|moveAndDeleteAbsolutePath
argument_list|(
name|vols
index|[
literal|1
index|]
operator|+
name|Path
operator|.
name|SEPARATOR_CHAR
operator|+
name|d
argument_list|)
argument_list|)
expr_stmt|;
comment|// Make sure everything is cleaned up
name|makeSureCleanedUp
argument_list|(
name|vols
argument_list|,
name|service
argument_list|)
expr_stmt|;
block|}
comment|/**    * This test creates some directories inside the volume roots, and then     * call asyncDiskService.MoveAndDeleteAllVolumes.    * We should be able to delete all files/dirs inside the volumes except    * the toBeDeleted directory.    */
annotation|@
name|Test
DECL|method|testMRAsyncDiskServiceMoveAndDeleteAllVolumes ()
specifier|public
name|void
name|testMRAsyncDiskServiceMoveAndDeleteAllVolumes
parameter_list|()
throws|throws
name|Throwable
block|{
name|FileSystem
name|localFileSystem
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|)
decl_stmt|;
name|String
index|[]
name|vols
init|=
operator|new
name|String
index|[]
block|{
name|TEST_ROOT_DIR
operator|+
literal|"/0"
block|,
name|TEST_ROOT_DIR
operator|+
literal|"/1"
block|}
decl_stmt|;
name|MRAsyncDiskService
name|service
init|=
operator|new
name|MRAsyncDiskService
argument_list|(
name|localFileSystem
argument_list|,
name|vols
argument_list|)
decl_stmt|;
name|String
name|a
init|=
literal|"a"
decl_stmt|;
name|String
name|b
init|=
literal|"b"
decl_stmt|;
name|String
name|c
init|=
literal|"b/c"
decl_stmt|;
name|String
name|d
init|=
literal|"d"
decl_stmt|;
name|File
name|fa
init|=
operator|new
name|File
argument_list|(
name|vols
index|[
literal|0
index|]
argument_list|,
name|a
argument_list|)
decl_stmt|;
name|File
name|fb
init|=
operator|new
name|File
argument_list|(
name|vols
index|[
literal|1
index|]
argument_list|,
name|b
argument_list|)
decl_stmt|;
name|File
name|fc
init|=
operator|new
name|File
argument_list|(
name|vols
index|[
literal|1
index|]
argument_list|,
name|c
argument_list|)
decl_stmt|;
name|File
name|fd
init|=
operator|new
name|File
argument_list|(
name|vols
index|[
literal|1
index|]
argument_list|,
name|d
argument_list|)
decl_stmt|;
comment|// Create the directories
name|fa
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|fb
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|fc
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|fd
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|fa
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fb
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fd
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
comment|// Delete all of them
name|service
operator|.
name|cleanupAllVolumes
argument_list|()
expr_stmt|;
name|assertFalse
argument_list|(
name|fa
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fb
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fd
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
comment|// Make sure everything is cleaned up
name|makeSureCleanedUp
argument_list|(
name|vols
argument_list|,
name|service
argument_list|)
expr_stmt|;
block|}
comment|/**    * This test creates some directories inside the toBeDeleted directory and    * then start the asyncDiskService.    * AsyncDiskService will create tasks to delete the content inside the    * toBeDeleted directories.    */
annotation|@
name|Test
DECL|method|testMRAsyncDiskServiceStartupCleaning ()
specifier|public
name|void
name|testMRAsyncDiskServiceStartupCleaning
parameter_list|()
throws|throws
name|Throwable
block|{
name|FileSystem
name|localFileSystem
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|)
decl_stmt|;
name|String
index|[]
name|vols
init|=
operator|new
name|String
index|[]
block|{
name|TEST_ROOT_DIR
operator|+
literal|"/0"
block|,
name|TEST_ROOT_DIR
operator|+
literal|"/1"
block|}
decl_stmt|;
name|String
name|a
init|=
literal|"a"
decl_stmt|;
name|String
name|b
init|=
literal|"b"
decl_stmt|;
name|String
name|c
init|=
literal|"b/c"
decl_stmt|;
name|String
name|d
init|=
literal|"d"
decl_stmt|;
comment|// Create directories inside SUBDIR
name|String
name|suffix
init|=
name|Path
operator|.
name|SEPARATOR_CHAR
operator|+
name|MRAsyncDiskService
operator|.
name|TOBEDELETED
decl_stmt|;
name|File
name|fa
init|=
operator|new
name|File
argument_list|(
name|vols
index|[
literal|0
index|]
operator|+
name|suffix
argument_list|,
name|a
argument_list|)
decl_stmt|;
name|File
name|fb
init|=
operator|new
name|File
argument_list|(
name|vols
index|[
literal|1
index|]
operator|+
name|suffix
argument_list|,
name|b
argument_list|)
decl_stmt|;
name|File
name|fc
init|=
operator|new
name|File
argument_list|(
name|vols
index|[
literal|1
index|]
operator|+
name|suffix
argument_list|,
name|c
argument_list|)
decl_stmt|;
name|File
name|fd
init|=
operator|new
name|File
argument_list|(
name|vols
index|[
literal|1
index|]
operator|+
name|suffix
argument_list|,
name|d
argument_list|)
decl_stmt|;
comment|// Create the directories
name|fa
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|fb
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|fc
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|fd
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|fa
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fb
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fd
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
comment|// Create the asyncDiskService which will delete all contents inside SUBDIR
name|MRAsyncDiskService
name|service
init|=
operator|new
name|MRAsyncDiskService
argument_list|(
name|localFileSystem
argument_list|,
name|vols
argument_list|)
decl_stmt|;
comment|// Make sure everything is cleaned up
name|makeSureCleanedUp
argument_list|(
name|vols
argument_list|,
name|service
argument_list|)
expr_stmt|;
block|}
DECL|method|makeSureCleanedUp (String[] vols, MRAsyncDiskService service)
specifier|private
name|void
name|makeSureCleanedUp
parameter_list|(
name|String
index|[]
name|vols
parameter_list|,
name|MRAsyncDiskService
name|service
parameter_list|)
throws|throws
name|Throwable
block|{
comment|// Sleep at most 5 seconds to make sure the deleted items are all gone.
name|service
operator|.
name|shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|service
operator|.
name|awaitTermination
argument_list|(
literal|5000
argument_list|)
condition|)
block|{
name|fail
argument_list|(
literal|"MRAsyncDiskService is still not shutdown in 5 seconds!"
argument_list|)
expr_stmt|;
block|}
comment|// All contents should be gone by now.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vols
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|File
name|subDir
init|=
operator|new
name|File
argument_list|(
name|vols
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|String
index|[]
name|subDirContent
init|=
name|subDir
operator|.
name|list
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Volume should contain a single child: "
operator|+
name|MRAsyncDiskService
operator|.
name|TOBEDELETED
argument_list|,
literal|1
argument_list|,
name|subDirContent
operator|.
name|length
argument_list|)
expr_stmt|;
name|File
name|toBeDeletedDir
init|=
operator|new
name|File
argument_list|(
name|vols
index|[
literal|0
index|]
argument_list|,
name|MRAsyncDiskService
operator|.
name|TOBEDELETED
argument_list|)
decl_stmt|;
name|String
index|[]
name|content
init|=
name|toBeDeletedDir
operator|.
name|list
argument_list|()
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"Cannot find "
operator|+
name|toBeDeletedDir
argument_list|,
name|content
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|""
operator|+
name|toBeDeletedDir
operator|+
literal|" should be empty now."
argument_list|,
literal|0
argument_list|,
name|content
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testToleratesSomeUnwritableVolumes ()
specifier|public
name|void
name|testToleratesSomeUnwritableVolumes
parameter_list|()
throws|throws
name|Throwable
block|{
name|FileSystem
name|localFileSystem
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|)
decl_stmt|;
name|String
index|[]
name|vols
init|=
operator|new
name|String
index|[]
block|{
name|TEST_ROOT_DIR
operator|+
literal|"/0"
block|,
name|TEST_ROOT_DIR
operator|+
literal|"/1"
block|}
decl_stmt|;
name|assertTrue
argument_list|(
operator|new
name|File
argument_list|(
name|vols
index|[
literal|0
index|]
argument_list|)
operator|.
name|mkdirs
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|FileUtil
operator|.
name|chmod
argument_list|(
name|vols
index|[
literal|0
index|]
argument_list|,
literal|"400"
argument_list|)
argument_list|)
expr_stmt|;
comment|// read only
try|try
block|{
operator|new
name|MRAsyncDiskService
argument_list|(
name|localFileSystem
argument_list|,
name|vols
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|FileUtil
operator|.
name|chmod
argument_list|(
name|vols
index|[
literal|0
index|]
argument_list|,
literal|"755"
argument_list|)
expr_stmt|;
comment|// make writable again
block|}
block|}
block|}
end_class

end_unit

