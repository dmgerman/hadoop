begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred.lib
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|lib
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Mapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|OutputCollector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Reporter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_comment
comment|/**  * The ChainMapper class allows to use multiple Mapper classes within a single  * Map task.  *<p>  * The Mapper classes are invoked in a chained (or piped) fashion, the output of  * the first becomes the input of the second, and so on until the last Mapper,  * the output of the last Mapper will be written to the task's output.  *<p>  * The key functionality of this feature is that the Mappers in the chain do not  * need to be aware that they are executed in a chain. This enables having  * reusable specialized Mappers that can be combined to perform composite  * operations within a single task.  *<p>  * Special care has to be taken when creating chains that the key/values output  * by a Mapper are valid for the following Mapper in the chain. It is assumed  * all Mappers and the Reduce in the chain use maching output and input key and  * value classes as no conversion is done by the chaining code.  *<p>  * Using the ChainMapper and the ChainReducer classes is possible to compose  * Map/Reduce jobs that look like<code>[MAP+ / REDUCE MAP*]</code>. And  * immediate benefit of this pattern is a dramatic reduction in disk IO.  *<p>  * IMPORTANT: There is no need to specify the output key/value classes for the  * ChainMapper, this is done by the addMapper for the last mapper in the chain.  *<p>  * ChainMapper usage pattern:  *<p>  *<pre>  * ...  * conf.setJobName("chain");  * conf.setInputFormat(TextInputFormat.class);  * conf.setOutputFormat(TextOutputFormat.class);  *  * JobConf mapAConf = new JobConf(false);  * ...  * ChainMapper.addMapper(conf, AMap.class, LongWritable.class, Text.class,  *   Text.class, Text.class, true, mapAConf);  *  * JobConf mapBConf = new JobConf(false);  * ...  * ChainMapper.addMapper(conf, BMap.class, Text.class, Text.class,  *   LongWritable.class, Text.class, false, mapBConf);  *  * JobConf reduceConf = new JobConf(false);  * ...  * ChainReducer.setReducer(conf, XReduce.class, LongWritable.class, Text.class,  *   Text.class, Text.class, true, reduceConf);  *  * ChainReducer.addMapper(conf, CMap.class, Text.class, Text.class,  *   LongWritable.class, Text.class, false, null);  *  * ChainReducer.addMapper(conf, DMap.class, LongWritable.class, Text.class,  *   LongWritable.class, LongWritable.class, true, null);  *  * FileInputFormat.setInputPaths(conf, inDir);  * FileOutputFormat.setOutputPath(conf, outDir);  * ...  *  * JobClient jc = new JobClient(conf);  * RunningJob job = jc.submitJob(conf);  * ...  *</pre>  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Stable
DECL|class|ChainMapper
specifier|public
class|class
name|ChainMapper
implements|implements
name|Mapper
block|{
comment|/**    * Adds a Mapper class to the chain job's JobConf.    *<p>    * It has to be specified how key and values are passed from one element of    * the chain to the next, by value or by reference. If a Mapper leverages the    * assumed semantics that the key and values are not modified by the collector    * 'by value' must be used. If the Mapper does not expect this semantics, as    * an optimization to avoid serialization and deserialization 'by reference'    * can be used.    *<p>    * For the added Mapper the configuration given for it,    *<code>mapperConf</code>, have precedence over the job's JobConf. This    * precedence is in effect when the task is running.    *<p>    * IMPORTANT: There is no need to specify the output key/value classes for the    * ChainMapper, this is done by the addMapper for the last mapper in the chain    *<p>    *    * @param job              job's JobConf to add the Mapper class.    * @param klass            the Mapper class to add.    * @param inputKeyClass    mapper input key class.    * @param inputValueClass  mapper input value class.    * @param outputKeyClass   mapper output key class.    * @param outputValueClass mapper output value class.    * @param byValue          indicates if key/values should be passed by value    * to the next Mapper in the chain, if any.    * @param mapperConf       a JobConf with the configuration for the Mapper    * class. It is recommended to use a JobConf without default values using the    *<code>JobConf(boolean loadDefaults)</code> constructor with FALSE.    */
DECL|method|addMapper (JobConf job, Class<? extends Mapper<K1, V1, K2, V2>> klass, Class<? extends K1> inputKeyClass, Class<? extends V1> inputValueClass, Class<? extends K2> outputKeyClass, Class<? extends V2> outputValueClass, boolean byValue, JobConf mapperConf)
specifier|public
specifier|static
parameter_list|<
name|K1
parameter_list|,
name|V1
parameter_list|,
name|K2
parameter_list|,
name|V2
parameter_list|>
name|void
name|addMapper
parameter_list|(
name|JobConf
name|job
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Mapper
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|,
name|K2
argument_list|,
name|V2
argument_list|>
argument_list|>
name|klass
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|K1
argument_list|>
name|inputKeyClass
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|V1
argument_list|>
name|inputValueClass
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|K2
argument_list|>
name|outputKeyClass
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|V2
argument_list|>
name|outputValueClass
parameter_list|,
name|boolean
name|byValue
parameter_list|,
name|JobConf
name|mapperConf
parameter_list|)
block|{
name|job
operator|.
name|setMapperClass
argument_list|(
name|ChainMapper
operator|.
name|class
argument_list|)
expr_stmt|;
name|job
operator|.
name|setMapOutputKeyClass
argument_list|(
name|outputKeyClass
argument_list|)
expr_stmt|;
name|job
operator|.
name|setMapOutputValueClass
argument_list|(
name|outputValueClass
argument_list|)
expr_stmt|;
name|Chain
operator|.
name|addMapper
argument_list|(
literal|true
argument_list|,
name|job
argument_list|,
name|klass
argument_list|,
name|inputKeyClass
argument_list|,
name|inputValueClass
argument_list|,
name|outputKeyClass
argument_list|,
name|outputValueClass
argument_list|,
name|byValue
argument_list|,
name|mapperConf
argument_list|)
expr_stmt|;
block|}
DECL|field|chain
specifier|private
name|Chain
name|chain
decl_stmt|;
comment|/**    * Constructor.    */
DECL|method|ChainMapper ()
specifier|public
name|ChainMapper
parameter_list|()
block|{
name|chain
operator|=
operator|new
name|Chain
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Configures the ChainMapper and all the Mappers in the chain.    *<p>    * If this method is overriden<code>super.configure(...)</code> should be    * invoked at the beginning of the overwriter method.    */
DECL|method|configure (JobConf job)
specifier|public
name|void
name|configure
parameter_list|(
name|JobConf
name|job
parameter_list|)
block|{
name|chain
operator|.
name|configure
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
comment|/**    * Chains the<code>map(...)</code> methods of the Mappers in the chain.    */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unchecked"
block|}
argument_list|)
DECL|method|map (Object key, Object value, OutputCollector output, Reporter reporter)
specifier|public
name|void
name|map
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|,
name|OutputCollector
name|output
parameter_list|,
name|Reporter
name|reporter
parameter_list|)
throws|throws
name|IOException
block|{
name|Mapper
name|mapper
init|=
name|chain
operator|.
name|getFirstMap
argument_list|()
decl_stmt|;
if|if
condition|(
name|mapper
operator|!=
literal|null
condition|)
block|{
name|mapper
operator|.
name|map
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
name|chain
operator|.
name|getMapperCollector
argument_list|(
literal|0
argument_list|,
name|output
argument_list|,
name|reporter
argument_list|)
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Closes  the ChainMapper and all the Mappers in the chain.    *<p>    * If this method is overriden<code>super.close()</code> should be    * invoked at the end of the overwriter method.    */
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|chain
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

