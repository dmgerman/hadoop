begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapreduce.lib.partition
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|partition
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|UnsupportedEncodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|UTF8ByteArrayUtils
import|;
end_import

begin_comment
comment|/**  * This is used in {@link KeyFieldBasedComparator}&   * {@link KeyFieldBasedPartitioner}. Defines all the methods  * for parsing key specifications. The key specification is of the form:  * -k pos1[,pos2], where pos is of the form f[.c][opts], where f is the number  *  of the field to use, and c is the number of the first character from the  *  beginning of the field. Fields and character posns are numbered starting  *  with 1; a character position of zero in pos2 indicates the field's last  *  character. If '.c' is omitted from pos1, it defaults to 1 (the beginning  *  of the field); if omitted from pos2, it defaults to 0 (the end of the  *  field). opts are ordering options (supported options are 'nr').   */
end_comment

begin_class
DECL|class|KeyFieldHelper
class|class
name|KeyFieldHelper
block|{
DECL|class|KeyDescription
specifier|protected
specifier|static
class|class
name|KeyDescription
block|{
DECL|field|beginFieldIdx
name|int
name|beginFieldIdx
init|=
literal|1
decl_stmt|;
DECL|field|beginChar
name|int
name|beginChar
init|=
literal|1
decl_stmt|;
DECL|field|endFieldIdx
name|int
name|endFieldIdx
init|=
literal|0
decl_stmt|;
DECL|field|endChar
name|int
name|endChar
init|=
literal|0
decl_stmt|;
DECL|field|numeric
name|boolean
name|numeric
decl_stmt|;
DECL|field|reverse
name|boolean
name|reverse
decl_stmt|;
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"-k"
operator|+
name|beginFieldIdx
operator|+
literal|"."
operator|+
name|beginChar
operator|+
literal|","
operator|+
name|endFieldIdx
operator|+
literal|"."
operator|+
name|endChar
operator|+
operator|(
name|numeric
condition|?
literal|"n"
else|:
literal|""
operator|)
operator|+
operator|(
name|reverse
condition|?
literal|"r"
else|:
literal|""
operator|)
return|;
block|}
block|}
DECL|field|allKeySpecs
specifier|private
name|List
argument_list|<
name|KeyDescription
argument_list|>
name|allKeySpecs
init|=
operator|new
name|ArrayList
argument_list|<
name|KeyDescription
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|keyFieldSeparator
specifier|private
name|byte
index|[]
name|keyFieldSeparator
decl_stmt|;
DECL|field|keySpecSeen
specifier|private
name|boolean
name|keySpecSeen
init|=
literal|false
decl_stmt|;
DECL|method|setKeyFieldSeparator (String keyFieldSeparator)
specifier|public
name|void
name|setKeyFieldSeparator
parameter_list|(
name|String
name|keyFieldSeparator
parameter_list|)
block|{
try|try
block|{
name|this
operator|.
name|keyFieldSeparator
operator|=
name|keyFieldSeparator
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedEncodingException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"The current system does not "
operator|+
literal|"support UTF-8 encoding!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Required for backcompatibility with num.key.fields.for.partition in    * {@link KeyFieldBasedPartitioner} */
DECL|method|setKeyFieldSpec (int start, int end)
specifier|public
name|void
name|setKeyFieldSpec
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
if|if
condition|(
name|end
operator|>=
name|start
condition|)
block|{
name|KeyDescription
name|k
init|=
operator|new
name|KeyDescription
argument_list|()
decl_stmt|;
name|k
operator|.
name|beginFieldIdx
operator|=
name|start
expr_stmt|;
name|k
operator|.
name|endFieldIdx
operator|=
name|end
expr_stmt|;
name|keySpecSeen
operator|=
literal|true
expr_stmt|;
name|allKeySpecs
operator|.
name|add
argument_list|(
name|k
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|keySpecs ()
specifier|public
name|List
argument_list|<
name|KeyDescription
argument_list|>
name|keySpecs
parameter_list|()
block|{
return|return
name|allKeySpecs
return|;
block|}
DECL|method|getWordLengths (byte []b, int start, int end)
specifier|public
name|int
index|[]
name|getWordLengths
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
comment|//Given a string like "hello how are you", it returns an array
comment|//like [4 5, 3, 3, 3], where the first element is the number of
comment|//fields
if|if
condition|(
operator|!
name|keySpecSeen
condition|)
block|{
comment|//if there were no key specs, then the whole key is one word
return|return
operator|new
name|int
index|[]
block|{
literal|1
block|}
return|;
block|}
name|int
index|[]
name|lengths
init|=
operator|new
name|int
index|[
literal|10
index|]
decl_stmt|;
name|int
name|currLenLengths
init|=
name|lengths
operator|.
name|length
decl_stmt|;
name|int
name|idx
init|=
literal|1
decl_stmt|;
name|int
name|pos
decl_stmt|;
while|while
condition|(
operator|(
name|pos
operator|=
name|UTF8ByteArrayUtils
operator|.
name|findBytes
argument_list|(
name|b
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|keyFieldSeparator
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|++
name|idx
operator|==
name|currLenLengths
condition|)
block|{
name|int
index|[]
name|temp
init|=
name|lengths
decl_stmt|;
name|lengths
operator|=
operator|new
name|int
index|[
operator|(
name|currLenLengths
operator|=
name|currLenLengths
operator|*
literal|2
operator|)
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|,
name|lengths
argument_list|,
literal|0
argument_list|,
name|temp
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
name|lengths
index|[
name|idx
operator|-
literal|1
index|]
operator|=
name|pos
operator|-
name|start
expr_stmt|;
name|start
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|!=
name|end
condition|)
block|{
name|lengths
index|[
name|idx
index|]
operator|=
name|end
operator|-
name|start
expr_stmt|;
block|}
name|lengths
index|[
literal|0
index|]
operator|=
name|idx
expr_stmt|;
comment|//number of words is the first element
return|return
name|lengths
return|;
block|}
DECL|method|getStartOffset (byte[]b, int start, int end, int []lengthIndices, KeyDescription k)
specifier|public
name|int
name|getStartOffset
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|int
index|[]
name|lengthIndices
parameter_list|,
name|KeyDescription
name|k
parameter_list|)
block|{
comment|//if -k2.5,2 is the keyspec, the startChar is lengthIndices[1] + 5
comment|//note that the [0]'th element is the number of fields in the key
if|if
condition|(
name|lengthIndices
index|[
literal|0
index|]
operator|>=
name|k
operator|.
name|beginFieldIdx
condition|)
block|{
name|int
name|position
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|k
operator|.
name|beginFieldIdx
condition|;
name|i
operator|++
control|)
block|{
name|position
operator|+=
name|lengthIndices
index|[
name|i
index|]
operator|+
name|keyFieldSeparator
operator|.
name|length
expr_stmt|;
block|}
if|if
condition|(
name|position
operator|+
name|k
operator|.
name|beginChar
operator|<=
operator|(
name|end
operator|-
name|start
operator|)
condition|)
block|{
return|return
name|start
operator|+
name|position
operator|+
name|k
operator|.
name|beginChar
operator|-
literal|1
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|method|getEndOffset (byte[]b, int start, int end, int []lengthIndices, KeyDescription k)
specifier|public
name|int
name|getEndOffset
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|int
index|[]
name|lengthIndices
parameter_list|,
name|KeyDescription
name|k
parameter_list|)
block|{
comment|//if -k2,2.8 is the keyspec, the endChar is lengthIndices[1] + 8
comment|//note that the [0]'th element is the number of fields in the key
if|if
condition|(
name|k
operator|.
name|endFieldIdx
operator|==
literal|0
condition|)
block|{
comment|//there is no end field specified for this keyspec. So the remaining
comment|//part of the key is considered in its entirety.
return|return
name|end
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|lengthIndices
index|[
literal|0
index|]
operator|>=
name|k
operator|.
name|endFieldIdx
condition|)
block|{
name|int
name|position
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|k
operator|.
name|endFieldIdx
condition|;
name|i
operator|++
control|)
block|{
name|position
operator|+=
name|lengthIndices
index|[
name|i
index|]
operator|+
name|keyFieldSeparator
operator|.
name|length
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|.
name|endChar
operator|==
literal|0
condition|)
block|{
name|position
operator|+=
name|lengthIndices
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|position
operator|+
name|k
operator|.
name|endChar
operator|<=
operator|(
name|end
operator|-
name|start
operator|)
condition|)
block|{
return|return
name|start
operator|+
name|position
operator|+
name|k
operator|.
name|endChar
operator|-
literal|1
return|;
block|}
return|return
name|end
operator|-
literal|1
return|;
block|}
return|return
name|end
operator|-
literal|1
return|;
block|}
DECL|method|parseOption (String option)
specifier|public
name|void
name|parseOption
parameter_list|(
name|String
name|option
parameter_list|)
block|{
if|if
condition|(
name|option
operator|==
literal|null
operator|||
name|option
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
comment|//we will have only default comparison
return|return;
block|}
name|StringTokenizer
name|args
init|=
operator|new
name|StringTokenizer
argument_list|(
name|option
argument_list|)
decl_stmt|;
name|KeyDescription
name|global
init|=
operator|new
name|KeyDescription
argument_list|()
decl_stmt|;
while|while
condition|(
name|args
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|arg
init|=
name|args
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|arg
operator|.
name|equals
argument_list|(
literal|"-n"
argument_list|)
condition|)
block|{
name|global
operator|.
name|numeric
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|.
name|equals
argument_list|(
literal|"-r"
argument_list|)
condition|)
block|{
name|global
operator|.
name|reverse
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|.
name|equals
argument_list|(
literal|"-nr"
argument_list|)
condition|)
block|{
name|global
operator|.
name|numeric
operator|=
literal|true
expr_stmt|;
name|global
operator|.
name|reverse
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|.
name|startsWith
argument_list|(
literal|"-k"
argument_list|)
condition|)
block|{
name|KeyDescription
name|k
init|=
name|parseKey
argument_list|(
name|arg
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|k
operator|!=
literal|null
condition|)
block|{
name|allKeySpecs
operator|.
name|add
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|keySpecSeen
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|KeyDescription
name|key
range|:
name|allKeySpecs
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|key
operator|.
name|reverse
operator||
name|key
operator|.
name|numeric
operator|)
condition|)
block|{
name|key
operator|.
name|reverse
operator|=
name|global
operator|.
name|reverse
expr_stmt|;
name|key
operator|.
name|numeric
operator|=
name|global
operator|.
name|numeric
expr_stmt|;
block|}
block|}
if|if
condition|(
name|allKeySpecs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|allKeySpecs
operator|.
name|add
argument_list|(
name|global
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|parseKey (String arg, StringTokenizer args)
specifier|private
name|KeyDescription
name|parseKey
parameter_list|(
name|String
name|arg
parameter_list|,
name|StringTokenizer
name|args
parameter_list|)
block|{
comment|//we allow for -k<arg> and -k<arg>
name|String
name|keyArgs
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|arg
operator|.
name|length
argument_list|()
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|args
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|keyArgs
operator|=
name|args
operator|.
name|nextToken
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|keyArgs
operator|=
name|arg
operator|.
name|substring
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keyArgs
operator|==
literal|null
operator|||
name|keyArgs
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|StringTokenizer
name|st
init|=
operator|new
name|StringTokenizer
argument_list|(
name|keyArgs
argument_list|,
literal|"nr.,"
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|KeyDescription
name|key
init|=
operator|new
name|KeyDescription
argument_list|()
decl_stmt|;
name|String
name|token
decl_stmt|;
comment|//the key is of the form 1[.3][nr][,1.5][nr]
if|if
condition|(
name|st
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|token
operator|=
name|st
operator|.
name|nextToken
argument_list|()
expr_stmt|;
comment|//the first token must be a number
name|key
operator|.
name|beginFieldIdx
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|st
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|token
operator|=
name|st
operator|.
name|nextToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|.
name|equals
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
name|token
operator|=
name|st
operator|.
name|nextToken
argument_list|()
expr_stmt|;
name|key
operator|.
name|beginChar
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|token
operator|=
name|st
operator|.
name|nextToken
argument_list|()
expr_stmt|;
block|}
else|else
block|{
return|return
name|key
return|;
block|}
block|}
do|do
block|{
if|if
condition|(
name|token
operator|.
name|equals
argument_list|(
literal|"n"
argument_list|)
condition|)
block|{
name|key
operator|.
name|numeric
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|equals
argument_list|(
literal|"r"
argument_list|)
condition|)
block|{
name|key
operator|.
name|reverse
operator|=
literal|true
expr_stmt|;
block|}
else|else
break|break;
if|if
condition|(
name|st
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|token
operator|=
name|st
operator|.
name|nextToken
argument_list|()
expr_stmt|;
block|}
else|else
block|{
return|return
name|key
return|;
block|}
block|}
do|while
condition|(
literal|true
condition|)
do|;
if|if
condition|(
name|token
operator|.
name|equals
argument_list|(
literal|","
argument_list|)
condition|)
block|{
name|token
operator|=
name|st
operator|.
name|nextToken
argument_list|()
expr_stmt|;
comment|//the first token must be a number
name|key
operator|.
name|endFieldIdx
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|token
operator|=
name|st
operator|.
name|nextToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|.
name|equals
argument_list|(
literal|"."
argument_list|)
condition|)
block|{
name|token
operator|=
name|st
operator|.
name|nextToken
argument_list|()
expr_stmt|;
name|key
operator|.
name|endChar
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|token
operator|=
name|st
operator|.
name|nextToken
argument_list|()
expr_stmt|;
block|}
else|else
block|{
return|return
name|key
return|;
block|}
block|}
do|do
block|{
if|if
condition|(
name|token
operator|.
name|equals
argument_list|(
literal|"n"
argument_list|)
condition|)
block|{
name|key
operator|.
name|numeric
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|equals
argument_list|(
literal|"r"
argument_list|)
condition|)
block|{
name|key
operator|.
name|reverse
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid -k argument. "
operator|+
literal|"Must be of the form -k pos1,[pos2], where pos is of the form "
operator|+
literal|"f[.c]nr"
argument_list|)
throw|;
block|}
if|if
condition|(
name|st
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|token
operator|=
name|st
operator|.
name|nextToken
argument_list|()
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
do|while
condition|(
literal|true
condition|)
do|;
block|}
return|return
name|key
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid -k argument. "
operator|+
literal|"Must be of the form -k pos1,[pos2], where pos is of the form "
operator|+
literal|"f[.c]nr"
argument_list|)
throw|;
block|}
return|return
name|key
return|;
block|}
DECL|method|printKey (KeyDescription key)
specifier|private
name|void
name|printKey
parameter_list|(
name|KeyDescription
name|key
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"key.beginFieldIdx: "
operator|+
name|key
operator|.
name|beginFieldIdx
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"key.beginChar: "
operator|+
name|key
operator|.
name|beginChar
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"key.endFieldIdx: "
operator|+
name|key
operator|.
name|endFieldIdx
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"key.endChar: "
operator|+
name|key
operator|.
name|endChar
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"key.numeric: "
operator|+
name|key
operator|.
name|numeric
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"key.reverse: "
operator|+
name|key
operator|.
name|reverse
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"parseKey over"
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

