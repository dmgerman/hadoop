begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteOrder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|IntBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
operator|.
name|Statistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocalFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RawLocalFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|DataInputBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|RawComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SequenceFile
operator|.
name|CompressionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|CompressionCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|DefaultCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|serializer
operator|.
name|Deserializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|serializer
operator|.
name|SerializationFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|serializer
operator|.
name|Serializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|IFile
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Merger
operator|.
name|Segment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|SortedRanges
operator|.
name|SkipRangeIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRJobConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskCounter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|FileInputFormatCounter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|map
operator|.
name|WrappedMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|FileOutputFormatCounter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|split
operator|.
name|JobSplit
operator|.
name|TaskSplitIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|task
operator|.
name|MapContextImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|CryptoUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|IndexedSortable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|IndexedSorter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Progress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|QuickSort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringInterner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_comment
comment|/** A Map task. */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"MapReduce"
block|}
argument_list|)
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|MapTask
specifier|public
class|class
name|MapTask
extends|extends
name|Task
block|{
comment|/**    * The size of each record in the index file for the map-outputs.    */
DECL|field|MAP_OUTPUT_INDEX_RECORD_LENGTH
specifier|public
specifier|static
specifier|final
name|int
name|MAP_OUTPUT_INDEX_RECORD_LENGTH
init|=
literal|24
decl_stmt|;
DECL|field|splitMetaInfo
specifier|private
name|TaskSplitIndex
name|splitMetaInfo
init|=
operator|new
name|TaskSplitIndex
argument_list|()
decl_stmt|;
DECL|field|APPROX_HEADER_LENGTH
specifier|private
specifier|final
specifier|static
name|int
name|APPROX_HEADER_LENGTH
init|=
literal|150
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|MapTask
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|mapPhase
specifier|private
name|Progress
name|mapPhase
decl_stmt|;
DECL|field|sortPhase
specifier|private
name|Progress
name|sortPhase
decl_stmt|;
block|{
comment|// set phase for this task
name|setPhase
parameter_list|(
name|TaskStatus
operator|.
name|Phase
operator|.
name|MAP
parameter_list|)
constructor_decl|;
name|getProgress
argument_list|()
operator|.
name|setStatus
argument_list|(
literal|"map"
argument_list|)
expr_stmt|;
block|}
DECL|method|MapTask ()
specifier|public
name|MapTask
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
DECL|method|MapTask (String jobFile, TaskAttemptID taskId, int partition, TaskSplitIndex splitIndex, int numSlotsRequired)
specifier|public
name|MapTask
parameter_list|(
name|String
name|jobFile
parameter_list|,
name|TaskAttemptID
name|taskId
parameter_list|,
name|int
name|partition
parameter_list|,
name|TaskSplitIndex
name|splitIndex
parameter_list|,
name|int
name|numSlotsRequired
parameter_list|)
block|{
name|super
argument_list|(
name|jobFile
argument_list|,
name|taskId
argument_list|,
name|partition
argument_list|,
name|numSlotsRequired
argument_list|)
expr_stmt|;
name|this
operator|.
name|splitMetaInfo
operator|=
name|splitIndex
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isMapTask ()
specifier|public
name|boolean
name|isMapTask
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|localizeConfiguration (JobConf conf)
specifier|public
name|void
name|localizeConfiguration
parameter_list|(
name|JobConf
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|localizeConfiguration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|write (DataOutput out)
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|isMapOrReduce
argument_list|()
condition|)
block|{
name|splitMetaInfo
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|splitMetaInfo
operator|=
literal|null
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|readFields (DataInput in)
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|isMapOrReduce
argument_list|()
condition|)
block|{
name|splitMetaInfo
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This class wraps the user's record reader to update the counters and progress    * as records are read.    * @param<K>    * @param<V>    */
DECL|class|TrackedRecordReader
class|class
name|TrackedRecordReader
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|RecordReader
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|rawIn
specifier|private
name|RecordReader
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rawIn
decl_stmt|;
DECL|field|fileInputByteCounter
specifier|private
name|Counters
operator|.
name|Counter
name|fileInputByteCounter
decl_stmt|;
DECL|field|inputRecordCounter
specifier|private
name|Counters
operator|.
name|Counter
name|inputRecordCounter
decl_stmt|;
DECL|field|reporter
specifier|private
name|TaskReporter
name|reporter
decl_stmt|;
DECL|field|bytesInPrev
specifier|private
name|long
name|bytesInPrev
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|bytesInCurr
specifier|private
name|long
name|bytesInCurr
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|fsStats
specifier|private
specifier|final
name|List
argument_list|<
name|Statistics
argument_list|>
name|fsStats
decl_stmt|;
DECL|method|TrackedRecordReader (TaskReporter reporter, JobConf job)
name|TrackedRecordReader
parameter_list|(
name|TaskReporter
name|reporter
parameter_list|,
name|JobConf
name|job
parameter_list|)
throws|throws
name|IOException
block|{
name|inputRecordCounter
operator|=
name|reporter
operator|.
name|getCounter
argument_list|(
name|TaskCounter
operator|.
name|MAP_INPUT_RECORDS
argument_list|)
expr_stmt|;
name|fileInputByteCounter
operator|=
name|reporter
operator|.
name|getCounter
argument_list|(
name|FileInputFormatCounter
operator|.
name|BYTES_READ
argument_list|)
expr_stmt|;
name|this
operator|.
name|reporter
operator|=
name|reporter
expr_stmt|;
name|List
argument_list|<
name|Statistics
argument_list|>
name|matchedStats
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|reporter
operator|.
name|getInputSplit
argument_list|()
operator|instanceof
name|FileSplit
condition|)
block|{
name|matchedStats
operator|=
name|getFsStatistics
argument_list|(
operator|(
operator|(
name|FileSplit
operator|)
name|this
operator|.
name|reporter
operator|.
name|getInputSplit
argument_list|()
operator|)
operator|.
name|getPath
argument_list|()
argument_list|,
name|job
argument_list|)
expr_stmt|;
block|}
name|fsStats
operator|=
name|matchedStats
expr_stmt|;
name|bytesInPrev
operator|=
name|getInputBytes
argument_list|(
name|fsStats
argument_list|)
expr_stmt|;
name|rawIn
operator|=
name|job
operator|.
name|getInputFormat
argument_list|()
operator|.
name|getRecordReader
argument_list|(
name|reporter
operator|.
name|getInputSplit
argument_list|()
argument_list|,
name|job
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
name|bytesInCurr
operator|=
name|getInputBytes
argument_list|(
name|fsStats
argument_list|)
expr_stmt|;
name|fileInputByteCounter
operator|.
name|increment
argument_list|(
name|bytesInCurr
operator|-
name|bytesInPrev
argument_list|)
expr_stmt|;
block|}
DECL|method|createKey ()
specifier|public
name|K
name|createKey
parameter_list|()
block|{
return|return
name|rawIn
operator|.
name|createKey
argument_list|()
return|;
block|}
DECL|method|createValue ()
specifier|public
name|V
name|createValue
parameter_list|()
block|{
return|return
name|rawIn
operator|.
name|createValue
argument_list|()
return|;
block|}
DECL|method|next (K key, V value)
specifier|public
specifier|synchronized
name|boolean
name|next
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|ret
init|=
name|moveToNext
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|incrCounters
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
DECL|method|incrCounters ()
specifier|protected
name|void
name|incrCounters
parameter_list|()
block|{
name|inputRecordCounter
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|moveToNext (K key, V value)
specifier|protected
specifier|synchronized
name|boolean
name|moveToNext
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|bytesInPrev
operator|=
name|getInputBytes
argument_list|(
name|fsStats
argument_list|)
expr_stmt|;
name|boolean
name|ret
init|=
name|rawIn
operator|.
name|next
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|bytesInCurr
operator|=
name|getInputBytes
argument_list|(
name|fsStats
argument_list|)
expr_stmt|;
name|fileInputByteCounter
operator|.
name|increment
argument_list|(
name|bytesInCurr
operator|-
name|bytesInPrev
argument_list|)
expr_stmt|;
name|reporter
operator|.
name|setProgress
argument_list|(
name|getProgress
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
DECL|method|getPos ()
specifier|public
name|long
name|getPos
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|rawIn
operator|.
name|getPos
argument_list|()
return|;
block|}
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|bytesInPrev
operator|=
name|getInputBytes
argument_list|(
name|fsStats
argument_list|)
expr_stmt|;
name|rawIn
operator|.
name|close
argument_list|()
expr_stmt|;
name|bytesInCurr
operator|=
name|getInputBytes
argument_list|(
name|fsStats
argument_list|)
expr_stmt|;
name|fileInputByteCounter
operator|.
name|increment
argument_list|(
name|bytesInCurr
operator|-
name|bytesInPrev
argument_list|)
expr_stmt|;
block|}
DECL|method|getProgress ()
specifier|public
name|float
name|getProgress
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|rawIn
operator|.
name|getProgress
argument_list|()
return|;
block|}
DECL|method|getTaskReporter ()
name|TaskReporter
name|getTaskReporter
parameter_list|()
block|{
return|return
name|reporter
return|;
block|}
DECL|method|getInputBytes (List<Statistics> stats)
specifier|private
name|long
name|getInputBytes
parameter_list|(
name|List
argument_list|<
name|Statistics
argument_list|>
name|stats
parameter_list|)
block|{
if|if
condition|(
name|stats
operator|==
literal|null
condition|)
return|return
literal|0
return|;
name|long
name|bytesRead
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Statistics
name|stat
range|:
name|stats
control|)
block|{
name|bytesRead
operator|=
name|bytesRead
operator|+
name|stat
operator|.
name|getBytesRead
argument_list|()
expr_stmt|;
block|}
return|return
name|bytesRead
return|;
block|}
block|}
comment|/**    * This class skips the records based on the failed ranges from previous     * attempts.    */
DECL|class|SkippingRecordReader
class|class
name|SkippingRecordReader
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|TrackedRecordReader
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|skipIt
specifier|private
name|SkipRangeIterator
name|skipIt
decl_stmt|;
DECL|field|skipWriter
specifier|private
name|SequenceFile
operator|.
name|Writer
name|skipWriter
decl_stmt|;
DECL|field|toWriteSkipRecs
specifier|private
name|boolean
name|toWriteSkipRecs
decl_stmt|;
DECL|field|umbilical
specifier|private
name|TaskUmbilicalProtocol
name|umbilical
decl_stmt|;
DECL|field|skipRecCounter
specifier|private
name|Counters
operator|.
name|Counter
name|skipRecCounter
decl_stmt|;
DECL|field|recIndex
specifier|private
name|long
name|recIndex
init|=
operator|-
literal|1
decl_stmt|;
DECL|method|SkippingRecordReader (TaskUmbilicalProtocol umbilical, TaskReporter reporter, JobConf job)
name|SkippingRecordReader
parameter_list|(
name|TaskUmbilicalProtocol
name|umbilical
parameter_list|,
name|TaskReporter
name|reporter
parameter_list|,
name|JobConf
name|job
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|reporter
argument_list|,
name|job
argument_list|)
expr_stmt|;
name|this
operator|.
name|umbilical
operator|=
name|umbilical
expr_stmt|;
name|this
operator|.
name|skipRecCounter
operator|=
name|reporter
operator|.
name|getCounter
argument_list|(
name|TaskCounter
operator|.
name|MAP_SKIPPED_RECORDS
argument_list|)
expr_stmt|;
name|this
operator|.
name|toWriteSkipRecs
operator|=
name|toWriteSkipRecs
argument_list|()
operator|&&
name|SkipBadRecords
operator|.
name|getSkipOutputPath
argument_list|(
name|conf
argument_list|)
operator|!=
literal|null
expr_stmt|;
name|skipIt
operator|=
name|getSkipRanges
argument_list|()
operator|.
name|skipRangeIterator
argument_list|()
expr_stmt|;
block|}
DECL|method|next (K key, V value)
specifier|public
specifier|synchronized
name|boolean
name|next
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|skipIt
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Further records got skipped."
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|boolean
name|ret
init|=
name|moveToNext
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
decl_stmt|;
name|long
name|nextRecIndex
init|=
name|skipIt
operator|.
name|next
argument_list|()
decl_stmt|;
name|long
name|skip
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|recIndex
operator|<
name|nextRecIndex
operator|&&
name|ret
condition|)
block|{
if|if
condition|(
name|toWriteSkipRecs
condition|)
block|{
name|writeSkippedRec
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|moveToNext
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|skip
operator|++
expr_stmt|;
block|}
comment|//close the skip writer once all the ranges are skipped
if|if
condition|(
name|skip
operator|>
literal|0
operator|&&
name|skipIt
operator|.
name|skippedAllRanges
argument_list|()
operator|&&
name|skipWriter
operator|!=
literal|null
condition|)
block|{
name|skipWriter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|skipRecCounter
operator|.
name|increment
argument_list|(
name|skip
argument_list|)
expr_stmt|;
name|reportNextRecordRange
argument_list|(
name|umbilical
argument_list|,
name|recIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|incrCounters
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
DECL|method|moveToNext (K key, V value)
specifier|protected
specifier|synchronized
name|boolean
name|moveToNext
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|recIndex
operator|++
expr_stmt|;
return|return
name|super
operator|.
name|moveToNext
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|writeSkippedRec (K key, V value)
specifier|private
name|void
name|writeSkippedRec
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|skipWriter
operator|==
literal|null
condition|)
block|{
name|Path
name|skipDir
init|=
name|SkipBadRecords
operator|.
name|getSkipOutputPath
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Path
name|skipFile
init|=
operator|new
name|Path
argument_list|(
name|skipDir
argument_list|,
name|getTaskID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|skipWriter
operator|=
name|SequenceFile
operator|.
name|createWriter
argument_list|(
name|skipFile
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
argument_list|,
name|conf
argument_list|,
name|skipFile
argument_list|,
operator|(
name|Class
argument_list|<
name|K
argument_list|>
operator|)
name|createKey
argument_list|()
operator|.
name|getClass
argument_list|()
argument_list|,
operator|(
name|Class
argument_list|<
name|V
argument_list|>
operator|)
name|createValue
argument_list|()
operator|.
name|getClass
argument_list|()
argument_list|,
name|CompressionType
operator|.
name|BLOCK
argument_list|,
name|getTaskReporter
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|skipWriter
operator|.
name|append
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|run (final JobConf job, final TaskUmbilicalProtocol umbilical)
specifier|public
name|void
name|run
parameter_list|(
specifier|final
name|JobConf
name|job
parameter_list|,
specifier|final
name|TaskUmbilicalProtocol
name|umbilical
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
throws|,
name|InterruptedException
block|{
name|this
operator|.
name|umbilical
operator|=
name|umbilical
expr_stmt|;
if|if
condition|(
name|isMapTask
argument_list|()
condition|)
block|{
comment|// If there are no reducers then there won't be any sort. Hence the map
comment|// phase will govern the entire attempt's progress.
if|if
condition|(
name|conf
operator|.
name|getNumReduceTasks
argument_list|()
operator|==
literal|0
condition|)
block|{
name|mapPhase
operator|=
name|getProgress
argument_list|()
operator|.
name|addPhase
argument_list|(
literal|"map"
argument_list|,
literal|1.0f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If there are reducers then the entire attempt's progress will be
comment|// split between the map phase (67%) and the sort phase (33%).
name|mapPhase
operator|=
name|getProgress
argument_list|()
operator|.
name|addPhase
argument_list|(
literal|"map"
argument_list|,
literal|0.667f
argument_list|)
expr_stmt|;
name|sortPhase
operator|=
name|getProgress
argument_list|()
operator|.
name|addPhase
argument_list|(
literal|"sort"
argument_list|,
literal|0.333f
argument_list|)
expr_stmt|;
block|}
block|}
name|TaskReporter
name|reporter
init|=
name|startReporter
argument_list|(
name|umbilical
argument_list|)
decl_stmt|;
name|boolean
name|useNewApi
init|=
name|job
operator|.
name|getUseNewMapper
argument_list|()
decl_stmt|;
name|initialize
argument_list|(
name|job
argument_list|,
name|getJobID
argument_list|()
argument_list|,
name|reporter
argument_list|,
name|useNewApi
argument_list|)
expr_stmt|;
comment|// check if it is a cleanupJobTask
if|if
condition|(
name|jobCleanup
condition|)
block|{
name|runJobCleanupTask
argument_list|(
name|umbilical
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|jobSetup
condition|)
block|{
name|runJobSetupTask
argument_list|(
name|umbilical
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|taskCleanup
condition|)
block|{
name|runTaskCleanupTask
argument_list|(
name|umbilical
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|useNewApi
condition|)
block|{
name|runNewMapper
argument_list|(
name|job
argument_list|,
name|splitMetaInfo
argument_list|,
name|umbilical
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|runOldMapper
argument_list|(
name|job
argument_list|,
name|splitMetaInfo
argument_list|,
name|umbilical
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
block|}
name|done
argument_list|(
name|umbilical
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
block|}
DECL|method|getSortPhase ()
specifier|public
name|Progress
name|getSortPhase
parameter_list|()
block|{
return|return
name|sortPhase
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getSplitDetails (Path file, long offset)
specifier|private
parameter_list|<
name|T
parameter_list|>
name|T
name|getSplitDetails
parameter_list|(
name|Path
name|file
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|FileSystem
name|fs
init|=
name|file
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FSDataInputStream
name|inFile
init|=
name|fs
operator|.
name|open
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|inFile
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|String
name|className
init|=
name|StringInterner
operator|.
name|weakIntern
argument_list|(
name|Text
operator|.
name|readString
argument_list|(
name|inFile
argument_list|)
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|T
argument_list|>
name|cls
decl_stmt|;
try|try
block|{
name|cls
operator|=
operator|(
name|Class
argument_list|<
name|T
argument_list|>
operator|)
name|conf
operator|.
name|getClassByName
argument_list|(
name|className
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|ce
parameter_list|)
block|{
name|IOException
name|wrap
init|=
operator|new
name|IOException
argument_list|(
literal|"Split class "
operator|+
name|className
operator|+
literal|" not found"
argument_list|)
decl_stmt|;
name|wrap
operator|.
name|initCause
argument_list|(
name|ce
argument_list|)
expr_stmt|;
throw|throw
name|wrap
throw|;
block|}
name|SerializationFactory
name|factory
init|=
operator|new
name|SerializationFactory
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Deserializer
argument_list|<
name|T
argument_list|>
name|deserializer
init|=
operator|(
name|Deserializer
argument_list|<
name|T
argument_list|>
operator|)
name|factory
operator|.
name|getDeserializer
argument_list|(
name|cls
argument_list|)
decl_stmt|;
name|deserializer
operator|.
name|open
argument_list|(
name|inFile
argument_list|)
expr_stmt|;
name|T
name|split
init|=
name|deserializer
operator|.
name|deserialize
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|long
name|pos
init|=
name|inFile
operator|.
name|getPos
argument_list|()
decl_stmt|;
name|getCounters
argument_list|()
operator|.
name|findCounter
argument_list|(
name|TaskCounter
operator|.
name|SPLIT_RAW_BYTES
argument_list|)
operator|.
name|increment
argument_list|(
name|pos
operator|-
name|offset
argument_list|)
expr_stmt|;
name|inFile
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|split
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
parameter_list|<
name|KEY
parameter_list|,
name|VALUE
parameter_list|>
name|MapOutputCollector
argument_list|<
name|KEY
argument_list|,
name|VALUE
argument_list|>
DECL|method|createSortingCollector (JobConf job, TaskReporter reporter)
name|createSortingCollector
parameter_list|(
name|JobConf
name|job
parameter_list|,
name|TaskReporter
name|reporter
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|MapOutputCollector
operator|.
name|Context
name|context
init|=
operator|new
name|MapOutputCollector
operator|.
name|Context
argument_list|(
name|this
argument_list|,
name|job
argument_list|,
name|reporter
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|collectorClasses
init|=
name|job
operator|.
name|getClasses
argument_list|(
name|JobContext
operator|.
name|MAP_OUTPUT_COLLECTOR_CLASS_ATTR
argument_list|,
name|MapOutputBuffer
operator|.
name|class
argument_list|)
decl_stmt|;
name|int
name|remainingCollectors
init|=
name|collectorClasses
operator|.
name|length
decl_stmt|;
name|Exception
name|lastException
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Class
name|clazz
range|:
name|collectorClasses
control|)
block|{
try|try
block|{
if|if
condition|(
operator|!
name|MapOutputCollector
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|clazz
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid output collector class: "
operator|+
name|clazz
operator|.
name|getName
argument_list|()
operator|+
literal|" (does not implement MapOutputCollector)"
argument_list|)
throw|;
block|}
name|Class
argument_list|<
name|?
extends|extends
name|MapOutputCollector
argument_list|>
name|subclazz
init|=
name|clazz
operator|.
name|asSubclass
argument_list|(
name|MapOutputCollector
operator|.
name|class
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying map output collector class: "
operator|+
name|subclazz
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|MapOutputCollector
argument_list|<
name|KEY
argument_list|,
name|VALUE
argument_list|>
name|collector
init|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|subclazz
argument_list|,
name|job
argument_list|)
decl_stmt|;
name|collector
operator|.
name|init
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Map output collector class = "
operator|+
name|collector
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|collector
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|String
name|msg
init|=
literal|"Unable to initialize MapOutputCollector "
operator|+
name|clazz
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|--
name|remainingCollectors
operator|>
literal|0
condition|)
block|{
name|msg
operator|+=
literal|" ("
operator|+
name|remainingCollectors
operator|+
literal|" more collector(s) to try)"
expr_stmt|;
block|}
name|lastException
operator|=
name|e
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Initialization of all the collectors failed. "
operator|+
literal|"Error in last collector was :"
operator|+
name|lastException
operator|.
name|getMessage
argument_list|()
argument_list|,
name|lastException
argument_list|)
throw|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
parameter_list|<
name|INKEY
parameter_list|,
name|INVALUE
parameter_list|,
name|OUTKEY
parameter_list|,
name|OUTVALUE
parameter_list|>
DECL|method|runOldMapper (final JobConf job, final TaskSplitIndex splitIndex, final TaskUmbilicalProtocol umbilical, TaskReporter reporter )
name|void
name|runOldMapper
parameter_list|(
specifier|final
name|JobConf
name|job
parameter_list|,
specifier|final
name|TaskSplitIndex
name|splitIndex
parameter_list|,
specifier|final
name|TaskUmbilicalProtocol
name|umbilical
parameter_list|,
name|TaskReporter
name|reporter
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|ClassNotFoundException
block|{
name|InputSplit
name|inputSplit
init|=
name|getSplitDetails
argument_list|(
operator|new
name|Path
argument_list|(
name|splitIndex
operator|.
name|getSplitLocation
argument_list|()
argument_list|)
argument_list|,
name|splitIndex
operator|.
name|getStartOffset
argument_list|()
argument_list|)
decl_stmt|;
name|updateJobWithSplit
argument_list|(
name|job
argument_list|,
name|inputSplit
argument_list|)
expr_stmt|;
name|reporter
operator|.
name|setInputSplit
argument_list|(
name|inputSplit
argument_list|)
expr_stmt|;
name|RecordReader
argument_list|<
name|INKEY
argument_list|,
name|INVALUE
argument_list|>
name|in
init|=
name|isSkipping
argument_list|()
condition|?
operator|new
name|SkippingRecordReader
argument_list|<
name|INKEY
argument_list|,
name|INVALUE
argument_list|>
argument_list|(
name|umbilical
argument_list|,
name|reporter
argument_list|,
name|job
argument_list|)
else|:
operator|new
name|TrackedRecordReader
argument_list|<
name|INKEY
argument_list|,
name|INVALUE
argument_list|>
argument_list|(
name|reporter
argument_list|,
name|job
argument_list|)
decl_stmt|;
name|job
operator|.
name|setBoolean
argument_list|(
name|JobContext
operator|.
name|SKIP_RECORDS
argument_list|,
name|isSkipping
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|numReduceTasks
init|=
name|conf
operator|.
name|getNumReduceTasks
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"numReduceTasks: "
operator|+
name|numReduceTasks
argument_list|)
expr_stmt|;
name|MapOutputCollector
argument_list|<
name|OUTKEY
argument_list|,
name|OUTVALUE
argument_list|>
name|collector
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|numReduceTasks
operator|>
literal|0
condition|)
block|{
name|collector
operator|=
name|createSortingCollector
argument_list|(
name|job
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|collector
operator|=
operator|new
name|DirectMapOutputCollector
argument_list|<
name|OUTKEY
argument_list|,
name|OUTVALUE
argument_list|>
argument_list|()
expr_stmt|;
name|MapOutputCollector
operator|.
name|Context
name|context
init|=
operator|new
name|MapOutputCollector
operator|.
name|Context
argument_list|(
name|this
argument_list|,
name|job
argument_list|,
name|reporter
argument_list|)
decl_stmt|;
name|collector
operator|.
name|init
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
name|MapRunnable
argument_list|<
name|INKEY
argument_list|,
name|INVALUE
argument_list|,
name|OUTKEY
argument_list|,
name|OUTVALUE
argument_list|>
name|runner
init|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|job
operator|.
name|getMapRunnerClass
argument_list|()
argument_list|,
name|job
argument_list|)
decl_stmt|;
try|try
block|{
name|runner
operator|.
name|run
argument_list|(
name|in
argument_list|,
operator|new
name|OldOutputCollector
argument_list|(
name|collector
argument_list|,
name|conf
argument_list|)
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
name|mapPhase
operator|.
name|complete
argument_list|()
expr_stmt|;
comment|// start the sort phase only if there are reducers
if|if
condition|(
name|numReduceTasks
operator|>
literal|0
condition|)
block|{
name|setPhase
argument_list|(
name|TaskStatus
operator|.
name|Phase
operator|.
name|SORT
argument_list|)
expr_stmt|;
block|}
name|statusUpdate
argument_list|(
name|umbilical
argument_list|)
expr_stmt|;
name|collector
operator|.
name|flush
argument_list|()
expr_stmt|;
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
name|in
operator|=
literal|null
expr_stmt|;
name|collector
operator|.
name|close
argument_list|()
expr_stmt|;
name|collector
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
name|closeQuietly
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|closeQuietly
argument_list|(
name|collector
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Update the job with details about the file split    * @param job the job configuration to update    * @param inputSplit the file split    */
DECL|method|updateJobWithSplit (final JobConf job, InputSplit inputSplit)
specifier|private
name|void
name|updateJobWithSplit
parameter_list|(
specifier|final
name|JobConf
name|job
parameter_list|,
name|InputSplit
name|inputSplit
parameter_list|)
block|{
if|if
condition|(
name|inputSplit
operator|instanceof
name|FileSplit
condition|)
block|{
name|FileSplit
name|fileSplit
init|=
operator|(
name|FileSplit
operator|)
name|inputSplit
decl_stmt|;
name|job
operator|.
name|set
argument_list|(
name|JobContext
operator|.
name|MAP_INPUT_FILE
argument_list|,
name|fileSplit
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|setLong
argument_list|(
name|JobContext
operator|.
name|MAP_INPUT_START
argument_list|,
name|fileSplit
operator|.
name|getStart
argument_list|()
argument_list|)
expr_stmt|;
name|job
operator|.
name|setLong
argument_list|(
name|JobContext
operator|.
name|MAP_INPUT_PATH
argument_list|,
name|fileSplit
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing split: "
operator|+
name|inputSplit
argument_list|)
expr_stmt|;
block|}
DECL|class|NewTrackingRecordReader
specifier|static
class|class
name|NewTrackingRecordReader
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|RecordReader
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|real
specifier|private
specifier|final
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|RecordReader
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|real
decl_stmt|;
DECL|field|inputRecordCounter
specifier|private
specifier|final
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Counter
name|inputRecordCounter
decl_stmt|;
DECL|field|fileInputByteCounter
specifier|private
specifier|final
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Counter
name|fileInputByteCounter
decl_stmt|;
DECL|field|reporter
specifier|private
specifier|final
name|TaskReporter
name|reporter
decl_stmt|;
DECL|field|fsStats
specifier|private
specifier|final
name|List
argument_list|<
name|Statistics
argument_list|>
name|fsStats
decl_stmt|;
DECL|method|NewTrackingRecordReader (org.apache.hadoop.mapreduce.InputSplit split, org.apache.hadoop.mapreduce.InputFormat<K, V> inputFormat, TaskReporter reporter, org.apache.hadoop.mapreduce.TaskAttemptContext taskContext)
name|NewTrackingRecordReader
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|InputSplit
name|split
parameter_list|,
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|InputFormat
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|inputFormat
parameter_list|,
name|TaskReporter
name|reporter
parameter_list|,
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptContext
name|taskContext
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|IOException
block|{
name|this
operator|.
name|reporter
operator|=
name|reporter
expr_stmt|;
name|this
operator|.
name|inputRecordCounter
operator|=
name|reporter
operator|.
name|getCounter
argument_list|(
name|TaskCounter
operator|.
name|MAP_INPUT_RECORDS
argument_list|)
expr_stmt|;
name|this
operator|.
name|fileInputByteCounter
operator|=
name|reporter
operator|.
name|getCounter
argument_list|(
name|FileInputFormatCounter
operator|.
name|BYTES_READ
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Statistics
argument_list|>
name|matchedStats
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|split
operator|instanceof
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|FileSplit
condition|)
block|{
name|matchedStats
operator|=
name|getFsStatistics
argument_list|(
operator|(
operator|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|input
operator|.
name|FileSplit
operator|)
name|split
operator|)
operator|.
name|getPath
argument_list|()
argument_list|,
name|taskContext
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fsStats
operator|=
name|matchedStats
expr_stmt|;
name|long
name|bytesInPrev
init|=
name|getInputBytes
argument_list|(
name|fsStats
argument_list|)
decl_stmt|;
name|this
operator|.
name|real
operator|=
name|inputFormat
operator|.
name|createRecordReader
argument_list|(
name|split
argument_list|,
name|taskContext
argument_list|)
expr_stmt|;
name|long
name|bytesInCurr
init|=
name|getInputBytes
argument_list|(
name|fsStats
argument_list|)
decl_stmt|;
name|fileInputByteCounter
operator|.
name|increment
argument_list|(
name|bytesInCurr
operator|-
name|bytesInPrev
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|bytesInPrev
init|=
name|getInputBytes
argument_list|(
name|fsStats
argument_list|)
decl_stmt|;
name|real
operator|.
name|close
argument_list|()
expr_stmt|;
name|long
name|bytesInCurr
init|=
name|getInputBytes
argument_list|(
name|fsStats
argument_list|)
decl_stmt|;
name|fileInputByteCounter
operator|.
name|increment
argument_list|(
name|bytesInCurr
operator|-
name|bytesInPrev
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getCurrentKey ()
specifier|public
name|K
name|getCurrentKey
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|real
operator|.
name|getCurrentKey
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getCurrentValue ()
specifier|public
name|V
name|getCurrentValue
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|real
operator|.
name|getCurrentValue
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getProgress ()
specifier|public
name|float
name|getProgress
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|real
operator|.
name|getProgress
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|initialize (org.apache.hadoop.mapreduce.InputSplit split, org.apache.hadoop.mapreduce.TaskAttemptContext context )
specifier|public
name|void
name|initialize
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|InputSplit
name|split
parameter_list|,
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|long
name|bytesInPrev
init|=
name|getInputBytes
argument_list|(
name|fsStats
argument_list|)
decl_stmt|;
name|real
operator|.
name|initialize
argument_list|(
name|split
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|long
name|bytesInCurr
init|=
name|getInputBytes
argument_list|(
name|fsStats
argument_list|)
decl_stmt|;
name|fileInputByteCounter
operator|.
name|increment
argument_list|(
name|bytesInCurr
operator|-
name|bytesInPrev
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|nextKeyValue ()
specifier|public
name|boolean
name|nextKeyValue
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|long
name|bytesInPrev
init|=
name|getInputBytes
argument_list|(
name|fsStats
argument_list|)
decl_stmt|;
name|boolean
name|result
init|=
name|real
operator|.
name|nextKeyValue
argument_list|()
decl_stmt|;
name|long
name|bytesInCurr
init|=
name|getInputBytes
argument_list|(
name|fsStats
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|inputRecordCounter
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fileInputByteCounter
operator|.
name|increment
argument_list|(
name|bytesInCurr
operator|-
name|bytesInPrev
argument_list|)
expr_stmt|;
name|reporter
operator|.
name|setProgress
argument_list|(
name|getProgress
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
DECL|method|getInputBytes (List<Statistics> stats)
specifier|private
name|long
name|getInputBytes
parameter_list|(
name|List
argument_list|<
name|Statistics
argument_list|>
name|stats
parameter_list|)
block|{
if|if
condition|(
name|stats
operator|==
literal|null
condition|)
return|return
literal|0
return|;
name|long
name|bytesRead
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Statistics
name|stat
range|:
name|stats
control|)
block|{
name|bytesRead
operator|=
name|bytesRead
operator|+
name|stat
operator|.
name|getBytesRead
argument_list|()
expr_stmt|;
block|}
return|return
name|bytesRead
return|;
block|}
block|}
comment|/**    * Since the mapred and mapreduce Partitioners don't share a common interface    * (JobConfigurable is deprecated and a subtype of mapred.Partitioner), the    * partitioner lives in Old/NewOutputCollector. Note that, for map-only jobs,    * the configured partitioner should not be called. It's common for    * partitioners to compute a result mod numReduces, which causes a div0 error    */
DECL|class|OldOutputCollector
specifier|private
specifier|static
class|class
name|OldOutputCollector
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|OutputCollector
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|partitioner
specifier|private
specifier|final
name|Partitioner
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|partitioner
decl_stmt|;
DECL|field|collector
specifier|private
specifier|final
name|MapOutputCollector
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|collector
decl_stmt|;
DECL|field|numPartitions
specifier|private
specifier|final
name|int
name|numPartitions
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|OldOutputCollector (MapOutputCollector<K,V> collector, JobConf conf)
name|OldOutputCollector
parameter_list|(
name|MapOutputCollector
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|collector
parameter_list|,
name|JobConf
name|conf
parameter_list|)
block|{
name|numPartitions
operator|=
name|conf
operator|.
name|getNumReduceTasks
argument_list|()
expr_stmt|;
if|if
condition|(
name|numPartitions
operator|>
literal|1
condition|)
block|{
name|partitioner
operator|=
operator|(
name|Partitioner
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|conf
operator|.
name|getPartitionerClass
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|partitioner
operator|=
operator|new
name|Partitioner
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|configure
parameter_list|(
name|JobConf
name|job
parameter_list|)
block|{ }
annotation|@
name|Override
specifier|public
name|int
name|getPartition
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|,
name|int
name|numPartitions
parameter_list|)
block|{
return|return
name|numPartitions
operator|-
literal|1
return|;
block|}
block|}
expr_stmt|;
block|}
name|this
operator|.
name|collector
operator|=
name|collector
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|collect (K key, V value)
specifier|public
name|void
name|collect
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|collector
operator|.
name|collect
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
name|partitioner
operator|.
name|getPartition
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
name|numPartitions
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"interrupt exception"
argument_list|,
name|ie
argument_list|)
throw|;
block|}
block|}
block|}
DECL|class|NewDirectOutputCollector
specifier|private
class|class
name|NewDirectOutputCollector
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|RecordWriter
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|out
specifier|private
specifier|final
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|RecordWriter
name|out
decl_stmt|;
DECL|field|reporter
specifier|private
specifier|final
name|TaskReporter
name|reporter
decl_stmt|;
DECL|field|mapOutputRecordCounter
specifier|private
specifier|final
name|Counters
operator|.
name|Counter
name|mapOutputRecordCounter
decl_stmt|;
DECL|field|fileOutputByteCounter
specifier|private
specifier|final
name|Counters
operator|.
name|Counter
name|fileOutputByteCounter
decl_stmt|;
DECL|field|fsStats
specifier|private
specifier|final
name|List
argument_list|<
name|Statistics
argument_list|>
name|fsStats
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|NewDirectOutputCollector (MRJobConfig jobContext, JobConf job, TaskUmbilicalProtocol umbilical, TaskReporter reporter)
name|NewDirectOutputCollector
parameter_list|(
name|MRJobConfig
name|jobContext
parameter_list|,
name|JobConf
name|job
parameter_list|,
name|TaskUmbilicalProtocol
name|umbilical
parameter_list|,
name|TaskReporter
name|reporter
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
throws|,
name|InterruptedException
block|{
name|this
operator|.
name|reporter
operator|=
name|reporter
expr_stmt|;
name|mapOutputRecordCounter
operator|=
name|reporter
operator|.
name|getCounter
argument_list|(
name|TaskCounter
operator|.
name|MAP_OUTPUT_RECORDS
argument_list|)
expr_stmt|;
name|fileOutputByteCounter
operator|=
name|reporter
operator|.
name|getCounter
argument_list|(
name|FileOutputFormatCounter
operator|.
name|BYTES_WRITTEN
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Statistics
argument_list|>
name|matchedStats
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|outputFormat
operator|instanceof
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|FileOutputFormat
condition|)
block|{
name|matchedStats
operator|=
name|getFsStatistics
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|output
operator|.
name|FileOutputFormat
operator|.
name|getOutputPath
argument_list|(
name|taskContext
argument_list|)
argument_list|,
name|taskContext
operator|.
name|getConfiguration
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fsStats
operator|=
name|matchedStats
expr_stmt|;
name|long
name|bytesOutPrev
init|=
name|getOutputBytes
argument_list|(
name|fsStats
argument_list|)
decl_stmt|;
name|out
operator|=
name|outputFormat
operator|.
name|getRecordWriter
argument_list|(
name|taskContext
argument_list|)
expr_stmt|;
name|long
name|bytesOutCurr
init|=
name|getOutputBytes
argument_list|(
name|fsStats
argument_list|)
decl_stmt|;
name|fileOutputByteCounter
operator|.
name|increment
argument_list|(
name|bytesOutCurr
operator|-
name|bytesOutPrev
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|write (K key, V value)
specifier|public
name|void
name|write
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|reporter
operator|.
name|progress
argument_list|()
expr_stmt|;
name|long
name|bytesOutPrev
init|=
name|getOutputBytes
argument_list|(
name|fsStats
argument_list|)
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|long
name|bytesOutCurr
init|=
name|getOutputBytes
argument_list|(
name|fsStats
argument_list|)
decl_stmt|;
name|fileOutputByteCounter
operator|.
name|increment
argument_list|(
name|bytesOutCurr
operator|-
name|bytesOutPrev
argument_list|)
expr_stmt|;
name|mapOutputRecordCounter
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|close (TaskAttemptContext context)
specifier|public
name|void
name|close
parameter_list|(
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|reporter
operator|.
name|progress
argument_list|()
expr_stmt|;
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|long
name|bytesOutPrev
init|=
name|getOutputBytes
argument_list|(
name|fsStats
argument_list|)
decl_stmt|;
name|out
operator|.
name|close
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|long
name|bytesOutCurr
init|=
name|getOutputBytes
argument_list|(
name|fsStats
argument_list|)
decl_stmt|;
name|fileOutputByteCounter
operator|.
name|increment
argument_list|(
name|bytesOutCurr
operator|-
name|bytesOutPrev
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getOutputBytes (List<Statistics> stats)
specifier|private
name|long
name|getOutputBytes
parameter_list|(
name|List
argument_list|<
name|Statistics
argument_list|>
name|stats
parameter_list|)
block|{
if|if
condition|(
name|stats
operator|==
literal|null
condition|)
return|return
literal|0
return|;
name|long
name|bytesWritten
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Statistics
name|stat
range|:
name|stats
control|)
block|{
name|bytesWritten
operator|=
name|bytesWritten
operator|+
name|stat
operator|.
name|getBytesWritten
argument_list|()
expr_stmt|;
block|}
return|return
name|bytesWritten
return|;
block|}
block|}
DECL|class|NewOutputCollector
specifier|private
class|class
name|NewOutputCollector
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|RecordWriter
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|collector
specifier|private
specifier|final
name|MapOutputCollector
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|collector
decl_stmt|;
DECL|field|partitioner
specifier|private
specifier|final
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Partitioner
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|partitioner
decl_stmt|;
DECL|field|partitions
specifier|private
specifier|final
name|int
name|partitions
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|NewOutputCollector (org.apache.hadoop.mapreduce.JobContext jobContext, JobConf job, TaskUmbilicalProtocol umbilical, TaskReporter reporter )
name|NewOutputCollector
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobContext
name|jobContext
parameter_list|,
name|JobConf
name|job
parameter_list|,
name|TaskUmbilicalProtocol
name|umbilical
parameter_list|,
name|TaskReporter
name|reporter
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|collector
operator|=
name|createSortingCollector
argument_list|(
name|job
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
name|partitions
operator|=
name|jobContext
operator|.
name|getNumReduceTasks
argument_list|()
expr_stmt|;
if|if
condition|(
name|partitions
operator|>
literal|1
condition|)
block|{
name|partitioner
operator|=
operator|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Partitioner
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|jobContext
operator|.
name|getPartitionerClass
argument_list|()
argument_list|,
name|job
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|partitioner
operator|=
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Partitioner
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|getPartition
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|,
name|int
name|numPartitions
parameter_list|)
block|{
return|return
name|partitions
operator|-
literal|1
return|;
block|}
block|}
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|write (K key, V value)
specifier|public
name|void
name|write
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|collector
operator|.
name|collect
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
name|partitioner
operator|.
name|getPartition
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
name|partitions
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|close (TaskAttemptContext context )
specifier|public
name|void
name|close
parameter_list|(
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
try|try
block|{
name|collector
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|cnf
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"can't find class "
argument_list|,
name|cnf
argument_list|)
throw|;
block|}
name|collector
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
parameter_list|<
name|INKEY
parameter_list|,
name|INVALUE
parameter_list|,
name|OUTKEY
parameter_list|,
name|OUTVALUE
parameter_list|>
DECL|method|runNewMapper (final JobConf job, final TaskSplitIndex splitIndex, final TaskUmbilicalProtocol umbilical, TaskReporter reporter )
name|void
name|runNewMapper
parameter_list|(
specifier|final
name|JobConf
name|job
parameter_list|,
specifier|final
name|TaskSplitIndex
name|splitIndex
parameter_list|,
specifier|final
name|TaskUmbilicalProtocol
name|umbilical
parameter_list|,
name|TaskReporter
name|reporter
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
throws|,
name|InterruptedException
block|{
comment|// make a task context so we can get the classes
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptContext
name|taskContext
init|=
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|task
operator|.
name|TaskAttemptContextImpl
argument_list|(
name|job
argument_list|,
name|getTaskID
argument_list|()
argument_list|,
name|reporter
argument_list|)
decl_stmt|;
comment|// make a mapper
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Mapper
argument_list|<
name|INKEY
argument_list|,
name|INVALUE
argument_list|,
name|OUTKEY
argument_list|,
name|OUTVALUE
argument_list|>
name|mapper
init|=
operator|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Mapper
argument_list|<
name|INKEY
argument_list|,
name|INVALUE
argument_list|,
name|OUTKEY
argument_list|,
name|OUTVALUE
argument_list|>
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|taskContext
operator|.
name|getMapperClass
argument_list|()
argument_list|,
name|job
argument_list|)
decl_stmt|;
comment|// make the input format
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|InputFormat
argument_list|<
name|INKEY
argument_list|,
name|INVALUE
argument_list|>
name|inputFormat
init|=
operator|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|InputFormat
argument_list|<
name|INKEY
argument_list|,
name|INVALUE
argument_list|>
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|taskContext
operator|.
name|getInputFormatClass
argument_list|()
argument_list|,
name|job
argument_list|)
decl_stmt|;
comment|// rebuild the input split
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|InputSplit
name|split
init|=
literal|null
decl_stmt|;
name|split
operator|=
name|getSplitDetails
argument_list|(
operator|new
name|Path
argument_list|(
name|splitIndex
operator|.
name|getSplitLocation
argument_list|()
argument_list|)
argument_list|,
name|splitIndex
operator|.
name|getStartOffset
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Processing split: "
operator|+
name|split
argument_list|)
expr_stmt|;
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|RecordReader
argument_list|<
name|INKEY
argument_list|,
name|INVALUE
argument_list|>
name|input
init|=
operator|new
name|NewTrackingRecordReader
argument_list|<
name|INKEY
argument_list|,
name|INVALUE
argument_list|>
argument_list|(
name|split
argument_list|,
name|inputFormat
argument_list|,
name|reporter
argument_list|,
name|taskContext
argument_list|)
decl_stmt|;
name|job
operator|.
name|setBoolean
argument_list|(
name|JobContext
operator|.
name|SKIP_RECORDS
argument_list|,
name|isSkipping
argument_list|()
argument_list|)
expr_stmt|;
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|RecordWriter
name|output
init|=
literal|null
decl_stmt|;
comment|// get an output object
if|if
condition|(
name|job
operator|.
name|getNumReduceTasks
argument_list|()
operator|==
literal|0
condition|)
block|{
name|output
operator|=
operator|new
name|NewDirectOutputCollector
argument_list|(
name|taskContext
argument_list|,
name|job
argument_list|,
name|umbilical
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output
operator|=
operator|new
name|NewOutputCollector
argument_list|(
name|taskContext
argument_list|,
name|job
argument_list|,
name|umbilical
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
block|}
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MapContext
argument_list|<
name|INKEY
argument_list|,
name|INVALUE
argument_list|,
name|OUTKEY
argument_list|,
name|OUTVALUE
argument_list|>
name|mapContext
init|=
operator|new
name|MapContextImpl
argument_list|<
name|INKEY
argument_list|,
name|INVALUE
argument_list|,
name|OUTKEY
argument_list|,
name|OUTVALUE
argument_list|>
argument_list|(
name|job
argument_list|,
name|getTaskID
argument_list|()
argument_list|,
name|input
argument_list|,
name|output
argument_list|,
name|committer
argument_list|,
name|reporter
argument_list|,
name|split
argument_list|)
decl_stmt|;
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Mapper
argument_list|<
name|INKEY
argument_list|,
name|INVALUE
argument_list|,
name|OUTKEY
argument_list|,
name|OUTVALUE
argument_list|>
operator|.
name|Context
name|mapperContext
init|=
operator|new
name|WrappedMapper
argument_list|<
name|INKEY
argument_list|,
name|INVALUE
argument_list|,
name|OUTKEY
argument_list|,
name|OUTVALUE
argument_list|>
argument_list|()
operator|.
name|getMapContext
argument_list|(
name|mapContext
argument_list|)
decl_stmt|;
try|try
block|{
name|input
operator|.
name|initialize
argument_list|(
name|split
argument_list|,
name|mapperContext
argument_list|)
expr_stmt|;
name|mapper
operator|.
name|run
argument_list|(
name|mapperContext
argument_list|)
expr_stmt|;
name|mapPhase
operator|.
name|complete
argument_list|()
expr_stmt|;
name|setPhase
argument_list|(
name|TaskStatus
operator|.
name|Phase
operator|.
name|SORT
argument_list|)
expr_stmt|;
name|statusUpdate
argument_list|(
name|umbilical
argument_list|)
expr_stmt|;
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|input
operator|=
literal|null
expr_stmt|;
name|output
operator|.
name|close
argument_list|(
name|mapperContext
argument_list|)
expr_stmt|;
name|output
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
name|closeQuietly
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|closeQuietly
argument_list|(
name|output
argument_list|,
name|mapperContext
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|DirectMapOutputCollector
class|class
name|DirectMapOutputCollector
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|MapOutputCollector
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|out
specifier|private
name|RecordWriter
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|out
init|=
literal|null
decl_stmt|;
DECL|field|reporter
specifier|private
name|TaskReporter
name|reporter
init|=
literal|null
decl_stmt|;
DECL|field|mapOutputRecordCounter
specifier|private
name|Counters
operator|.
name|Counter
name|mapOutputRecordCounter
decl_stmt|;
DECL|field|fileOutputByteCounter
specifier|private
name|Counters
operator|.
name|Counter
name|fileOutputByteCounter
decl_stmt|;
DECL|field|fsStats
specifier|private
name|List
argument_list|<
name|Statistics
argument_list|>
name|fsStats
decl_stmt|;
DECL|method|DirectMapOutputCollector ()
specifier|public
name|DirectMapOutputCollector
parameter_list|()
block|{     }
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|init (MapOutputCollector.Context context )
specifier|public
name|void
name|init
parameter_list|(
name|MapOutputCollector
operator|.
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|this
operator|.
name|reporter
operator|=
name|context
operator|.
name|getReporter
argument_list|()
expr_stmt|;
name|JobConf
name|job
init|=
name|context
operator|.
name|getJobConf
argument_list|()
decl_stmt|;
name|String
name|finalName
init|=
name|getOutputName
argument_list|(
name|getPartition
argument_list|()
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|job
argument_list|)
decl_stmt|;
name|OutputFormat
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|outputFormat
init|=
name|job
operator|.
name|getOutputFormat
argument_list|()
decl_stmt|;
name|mapOutputRecordCounter
operator|=
name|reporter
operator|.
name|getCounter
argument_list|(
name|TaskCounter
operator|.
name|MAP_OUTPUT_RECORDS
argument_list|)
expr_stmt|;
name|fileOutputByteCounter
operator|=
name|reporter
operator|.
name|getCounter
argument_list|(
name|FileOutputFormatCounter
operator|.
name|BYTES_WRITTEN
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Statistics
argument_list|>
name|matchedStats
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|outputFormat
operator|instanceof
name|FileOutputFormat
condition|)
block|{
name|matchedStats
operator|=
name|getFsStatistics
argument_list|(
name|FileOutputFormat
operator|.
name|getOutputPath
argument_list|(
name|job
argument_list|)
argument_list|,
name|job
argument_list|)
expr_stmt|;
block|}
name|fsStats
operator|=
name|matchedStats
expr_stmt|;
name|long
name|bytesOutPrev
init|=
name|getOutputBytes
argument_list|(
name|fsStats
argument_list|)
decl_stmt|;
name|out
operator|=
name|job
operator|.
name|getOutputFormat
argument_list|()
operator|.
name|getRecordWriter
argument_list|(
name|fs
argument_list|,
name|job
argument_list|,
name|finalName
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
name|long
name|bytesOutCurr
init|=
name|getOutputBytes
argument_list|(
name|fsStats
argument_list|)
decl_stmt|;
name|fileOutputByteCounter
operator|.
name|increment
argument_list|(
name|bytesOutCurr
operator|-
name|bytesOutPrev
argument_list|)
expr_stmt|;
block|}
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|out
operator|!=
literal|null
condition|)
block|{
name|long
name|bytesOutPrev
init|=
name|getOutputBytes
argument_list|(
name|fsStats
argument_list|)
decl_stmt|;
name|out
operator|.
name|close
argument_list|(
name|this
operator|.
name|reporter
argument_list|)
expr_stmt|;
name|long
name|bytesOutCurr
init|=
name|getOutputBytes
argument_list|(
name|fsStats
argument_list|)
decl_stmt|;
name|fileOutputByteCounter
operator|.
name|increment
argument_list|(
name|bytesOutCurr
operator|-
name|bytesOutPrev
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|flush ()
specifier|public
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|ClassNotFoundException
block|{     }
DECL|method|collect (K key, V value, int partition)
specifier|public
name|void
name|collect
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|,
name|int
name|partition
parameter_list|)
throws|throws
name|IOException
block|{
name|reporter
operator|.
name|progress
argument_list|()
expr_stmt|;
name|long
name|bytesOutPrev
init|=
name|getOutputBytes
argument_list|(
name|fsStats
argument_list|)
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|long
name|bytesOutCurr
init|=
name|getOutputBytes
argument_list|(
name|fsStats
argument_list|)
decl_stmt|;
name|fileOutputByteCounter
operator|.
name|increment
argument_list|(
name|bytesOutCurr
operator|-
name|bytesOutPrev
argument_list|)
expr_stmt|;
name|mapOutputRecordCounter
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|getOutputBytes (List<Statistics> stats)
specifier|private
name|long
name|getOutputBytes
parameter_list|(
name|List
argument_list|<
name|Statistics
argument_list|>
name|stats
parameter_list|)
block|{
if|if
condition|(
name|stats
operator|==
literal|null
condition|)
return|return
literal|0
return|;
name|long
name|bytesWritten
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Statistics
name|stat
range|:
name|stats
control|)
block|{
name|bytesWritten
operator|=
name|bytesWritten
operator|+
name|stat
operator|.
name|getBytesWritten
argument_list|()
expr_stmt|;
block|}
return|return
name|bytesWritten
return|;
block|}
block|}
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"MapReduce"
block|}
argument_list|)
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|MapOutputBuffer
specifier|public
specifier|static
class|class
name|MapOutputBuffer
parameter_list|<
name|K
extends|extends
name|Object
parameter_list|,
name|V
extends|extends
name|Object
parameter_list|>
implements|implements
name|MapOutputCollector
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|,
name|IndexedSortable
block|{
DECL|field|partitions
specifier|private
name|int
name|partitions
decl_stmt|;
DECL|field|job
specifier|private
name|JobConf
name|job
decl_stmt|;
DECL|field|reporter
specifier|private
name|TaskReporter
name|reporter
decl_stmt|;
DECL|field|keyClass
specifier|private
name|Class
argument_list|<
name|K
argument_list|>
name|keyClass
decl_stmt|;
DECL|field|valClass
specifier|private
name|Class
argument_list|<
name|V
argument_list|>
name|valClass
decl_stmt|;
DECL|field|comparator
specifier|private
name|RawComparator
argument_list|<
name|K
argument_list|>
name|comparator
decl_stmt|;
DECL|field|serializationFactory
specifier|private
name|SerializationFactory
name|serializationFactory
decl_stmt|;
DECL|field|keySerializer
specifier|private
name|Serializer
argument_list|<
name|K
argument_list|>
name|keySerializer
decl_stmt|;
DECL|field|valSerializer
specifier|private
name|Serializer
argument_list|<
name|V
argument_list|>
name|valSerializer
decl_stmt|;
DECL|field|combinerRunner
specifier|private
name|CombinerRunner
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|combinerRunner
decl_stmt|;
DECL|field|combineCollector
specifier|private
name|CombineOutputCollector
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|combineCollector
decl_stmt|;
comment|// Compression for map-outputs
DECL|field|codec
specifier|private
name|CompressionCodec
name|codec
decl_stmt|;
comment|// k/v accounting
DECL|field|kvmeta
specifier|private
name|IntBuffer
name|kvmeta
decl_stmt|;
comment|// metadata overlay on backing store
DECL|field|kvstart
name|int
name|kvstart
decl_stmt|;
comment|// marks origin of spill metadata
DECL|field|kvend
name|int
name|kvend
decl_stmt|;
comment|// marks end of spill metadata
DECL|field|kvindex
name|int
name|kvindex
decl_stmt|;
comment|// marks end of fully serialized records
DECL|field|equator
name|int
name|equator
decl_stmt|;
comment|// marks origin of meta/serialization
DECL|field|bufstart
name|int
name|bufstart
decl_stmt|;
comment|// marks beginning of spill
DECL|field|bufend
name|int
name|bufend
decl_stmt|;
comment|// marks beginning of collectable
DECL|field|bufmark
name|int
name|bufmark
decl_stmt|;
comment|// marks end of record
DECL|field|bufindex
name|int
name|bufindex
decl_stmt|;
comment|// marks end of collected
DECL|field|bufvoid
name|int
name|bufvoid
decl_stmt|;
comment|// marks the point where we should stop
comment|// reading at the end of the buffer
DECL|field|kvbuffer
name|byte
index|[]
name|kvbuffer
decl_stmt|;
comment|// main output buffer
DECL|field|b0
specifier|private
specifier|final
name|byte
index|[]
name|b0
init|=
operator|new
name|byte
index|[
literal|0
index|]
decl_stmt|;
DECL|field|VALSTART
specifier|private
specifier|static
specifier|final
name|int
name|VALSTART
init|=
literal|0
decl_stmt|;
comment|// val offset in acct
DECL|field|KEYSTART
specifier|private
specifier|static
specifier|final
name|int
name|KEYSTART
init|=
literal|1
decl_stmt|;
comment|// key offset in acct
DECL|field|PARTITION
specifier|private
specifier|static
specifier|final
name|int
name|PARTITION
init|=
literal|2
decl_stmt|;
comment|// partition offset in acct
DECL|field|VALLEN
specifier|private
specifier|static
specifier|final
name|int
name|VALLEN
init|=
literal|3
decl_stmt|;
comment|// length of value
DECL|field|NMETA
specifier|private
specifier|static
specifier|final
name|int
name|NMETA
init|=
literal|4
decl_stmt|;
comment|// num meta ints
DECL|field|METASIZE
specifier|private
specifier|static
specifier|final
name|int
name|METASIZE
init|=
name|NMETA
operator|*
literal|4
decl_stmt|;
comment|// size in bytes
comment|// spill accounting
DECL|field|maxRec
specifier|private
name|int
name|maxRec
decl_stmt|;
DECL|field|softLimit
specifier|private
name|int
name|softLimit
decl_stmt|;
DECL|field|spillInProgress
name|boolean
name|spillInProgress
decl_stmt|;
empty_stmt|;
DECL|field|bufferRemaining
name|int
name|bufferRemaining
decl_stmt|;
DECL|field|sortSpillException
specifier|volatile
name|Throwable
name|sortSpillException
init|=
literal|null
decl_stmt|;
DECL|field|numSpills
name|int
name|numSpills
init|=
literal|0
decl_stmt|;
DECL|field|minSpillsForCombine
specifier|private
name|int
name|minSpillsForCombine
decl_stmt|;
DECL|field|sorter
specifier|private
name|IndexedSorter
name|sorter
decl_stmt|;
DECL|field|spillLock
specifier|final
name|ReentrantLock
name|spillLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
DECL|field|spillDone
specifier|final
name|Condition
name|spillDone
init|=
name|spillLock
operator|.
name|newCondition
argument_list|()
decl_stmt|;
DECL|field|spillReady
specifier|final
name|Condition
name|spillReady
init|=
name|spillLock
operator|.
name|newCondition
argument_list|()
decl_stmt|;
DECL|field|bb
specifier|final
name|BlockingBuffer
name|bb
init|=
operator|new
name|BlockingBuffer
argument_list|()
decl_stmt|;
DECL|field|spillThreadRunning
specifier|volatile
name|boolean
name|spillThreadRunning
init|=
literal|false
decl_stmt|;
DECL|field|spillThread
specifier|final
name|SpillThread
name|spillThread
init|=
operator|new
name|SpillThread
argument_list|()
decl_stmt|;
DECL|field|rfs
specifier|private
name|FileSystem
name|rfs
decl_stmt|;
comment|// Counters
DECL|field|mapOutputByteCounter
specifier|private
name|Counters
operator|.
name|Counter
name|mapOutputByteCounter
decl_stmt|;
DECL|field|mapOutputRecordCounter
specifier|private
name|Counters
operator|.
name|Counter
name|mapOutputRecordCounter
decl_stmt|;
DECL|field|fileOutputByteCounter
specifier|private
name|Counters
operator|.
name|Counter
name|fileOutputByteCounter
decl_stmt|;
DECL|field|indexCacheList
specifier|final
name|ArrayList
argument_list|<
name|SpillRecord
argument_list|>
name|indexCacheList
init|=
operator|new
name|ArrayList
argument_list|<
name|SpillRecord
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|totalIndexCacheMemory
specifier|private
name|int
name|totalIndexCacheMemory
decl_stmt|;
DECL|field|indexCacheMemoryLimit
specifier|private
name|int
name|indexCacheMemoryLimit
decl_stmt|;
DECL|field|INDEX_CACHE_MEMORY_LIMIT_DEFAULT
specifier|private
specifier|static
specifier|final
name|int
name|INDEX_CACHE_MEMORY_LIMIT_DEFAULT
init|=
literal|1024
operator|*
literal|1024
decl_stmt|;
DECL|field|mapTask
specifier|private
name|MapTask
name|mapTask
decl_stmt|;
DECL|field|mapOutputFile
specifier|private
name|MapOutputFile
name|mapOutputFile
decl_stmt|;
DECL|field|sortPhase
specifier|private
name|Progress
name|sortPhase
decl_stmt|;
DECL|field|spilledRecordsCounter
specifier|private
name|Counters
operator|.
name|Counter
name|spilledRecordsCounter
decl_stmt|;
DECL|method|MapOutputBuffer ()
specifier|public
name|MapOutputBuffer
parameter_list|()
block|{     }
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|init (MapOutputCollector.Context context )
specifier|public
name|void
name|init
parameter_list|(
name|MapOutputCollector
operator|.
name|Context
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|job
operator|=
name|context
operator|.
name|getJobConf
argument_list|()
expr_stmt|;
name|reporter
operator|=
name|context
operator|.
name|getReporter
argument_list|()
expr_stmt|;
name|mapTask
operator|=
name|context
operator|.
name|getMapTask
argument_list|()
expr_stmt|;
name|mapOutputFile
operator|=
name|mapTask
operator|.
name|getMapOutputFile
argument_list|()
expr_stmt|;
name|sortPhase
operator|=
name|mapTask
operator|.
name|getSortPhase
argument_list|()
expr_stmt|;
name|spilledRecordsCounter
operator|=
name|reporter
operator|.
name|getCounter
argument_list|(
name|TaskCounter
operator|.
name|SPILLED_RECORDS
argument_list|)
expr_stmt|;
name|partitions
operator|=
name|job
operator|.
name|getNumReduceTasks
argument_list|()
expr_stmt|;
name|rfs
operator|=
operator|(
operator|(
name|LocalFileSystem
operator|)
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|job
argument_list|)
operator|)
operator|.
name|getRaw
argument_list|()
expr_stmt|;
comment|//sanity checks
specifier|final
name|float
name|spillper
init|=
name|job
operator|.
name|getFloat
argument_list|(
name|JobContext
operator|.
name|MAP_SORT_SPILL_PERCENT
argument_list|,
operator|(
name|float
operator|)
literal|0.8
argument_list|)
decl_stmt|;
specifier|final
name|int
name|sortmb
init|=
name|job
operator|.
name|getInt
argument_list|(
name|JobContext
operator|.
name|IO_SORT_MB
argument_list|,
literal|100
argument_list|)
decl_stmt|;
name|indexCacheMemoryLimit
operator|=
name|job
operator|.
name|getInt
argument_list|(
name|JobContext
operator|.
name|INDEX_CACHE_MEMORY_LIMIT
argument_list|,
name|INDEX_CACHE_MEMORY_LIMIT_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|spillper
operator|>
operator|(
name|float
operator|)
literal|1.0
operator|||
name|spillper
operator|<=
operator|(
name|float
operator|)
literal|0.0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid \""
operator|+
name|JobContext
operator|.
name|MAP_SORT_SPILL_PERCENT
operator|+
literal|"\": "
operator|+
name|spillper
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|sortmb
operator|&
literal|0x7FF
operator|)
operator|!=
name|sortmb
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid \""
operator|+
name|JobContext
operator|.
name|IO_SORT_MB
operator|+
literal|"\": "
operator|+
name|sortmb
argument_list|)
throw|;
block|}
name|sorter
operator|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|job
operator|.
name|getClass
argument_list|(
literal|"map.sort.class"
argument_list|,
name|QuickSort
operator|.
name|class
argument_list|,
name|IndexedSorter
operator|.
name|class
argument_list|)
argument_list|,
name|job
argument_list|)
expr_stmt|;
comment|// buffers and accounting
name|int
name|maxMemUsage
init|=
name|sortmb
operator|<<
literal|20
decl_stmt|;
name|maxMemUsage
operator|-=
name|maxMemUsage
operator|%
name|METASIZE
expr_stmt|;
name|kvbuffer
operator|=
operator|new
name|byte
index|[
name|maxMemUsage
index|]
expr_stmt|;
name|bufvoid
operator|=
name|kvbuffer
operator|.
name|length
expr_stmt|;
name|kvmeta
operator|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|kvbuffer
argument_list|)
operator|.
name|order
argument_list|(
name|ByteOrder
operator|.
name|nativeOrder
argument_list|()
argument_list|)
operator|.
name|asIntBuffer
argument_list|()
expr_stmt|;
name|setEquator
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bufstart
operator|=
name|bufend
operator|=
name|bufindex
operator|=
name|equator
expr_stmt|;
name|kvstart
operator|=
name|kvend
operator|=
name|kvindex
expr_stmt|;
name|maxRec
operator|=
name|kvmeta
operator|.
name|capacity
argument_list|()
operator|/
name|NMETA
expr_stmt|;
name|softLimit
operator|=
call|(
name|int
call|)
argument_list|(
name|kvbuffer
operator|.
name|length
operator|*
name|spillper
argument_list|)
expr_stmt|;
name|bufferRemaining
operator|=
name|softLimit
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|JobContext
operator|.
name|IO_SORT_MB
operator|+
literal|": "
operator|+
name|sortmb
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"soft limit at "
operator|+
name|softLimit
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"bufstart = "
operator|+
name|bufstart
operator|+
literal|"; bufvoid = "
operator|+
name|bufvoid
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"kvstart = "
operator|+
name|kvstart
operator|+
literal|"; length = "
operator|+
name|maxRec
argument_list|)
expr_stmt|;
comment|// k/v serialization
name|comparator
operator|=
name|job
operator|.
name|getOutputKeyComparator
argument_list|()
expr_stmt|;
name|keyClass
operator|=
operator|(
name|Class
argument_list|<
name|K
argument_list|>
operator|)
name|job
operator|.
name|getMapOutputKeyClass
argument_list|()
expr_stmt|;
name|valClass
operator|=
operator|(
name|Class
argument_list|<
name|V
argument_list|>
operator|)
name|job
operator|.
name|getMapOutputValueClass
argument_list|()
expr_stmt|;
name|serializationFactory
operator|=
operator|new
name|SerializationFactory
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|keySerializer
operator|=
name|serializationFactory
operator|.
name|getSerializer
argument_list|(
name|keyClass
argument_list|)
expr_stmt|;
name|keySerializer
operator|.
name|open
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|valSerializer
operator|=
name|serializationFactory
operator|.
name|getSerializer
argument_list|(
name|valClass
argument_list|)
expr_stmt|;
name|valSerializer
operator|.
name|open
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|// output counters
name|mapOutputByteCounter
operator|=
name|reporter
operator|.
name|getCounter
argument_list|(
name|TaskCounter
operator|.
name|MAP_OUTPUT_BYTES
argument_list|)
expr_stmt|;
name|mapOutputRecordCounter
operator|=
name|reporter
operator|.
name|getCounter
argument_list|(
name|TaskCounter
operator|.
name|MAP_OUTPUT_RECORDS
argument_list|)
expr_stmt|;
name|fileOutputByteCounter
operator|=
name|reporter
operator|.
name|getCounter
argument_list|(
name|TaskCounter
operator|.
name|MAP_OUTPUT_MATERIALIZED_BYTES
argument_list|)
expr_stmt|;
comment|// compression
if|if
condition|(
name|job
operator|.
name|getCompressMapOutput
argument_list|()
condition|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|CompressionCodec
argument_list|>
name|codecClass
init|=
name|job
operator|.
name|getMapOutputCompressorClass
argument_list|(
name|DefaultCodec
operator|.
name|class
argument_list|)
decl_stmt|;
name|codec
operator|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|codecClass
argument_list|,
name|job
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|codec
operator|=
literal|null
expr_stmt|;
block|}
comment|// combiner
specifier|final
name|Counters
operator|.
name|Counter
name|combineInputCounter
init|=
name|reporter
operator|.
name|getCounter
argument_list|(
name|TaskCounter
operator|.
name|COMBINE_INPUT_RECORDS
argument_list|)
decl_stmt|;
name|combinerRunner
operator|=
name|CombinerRunner
operator|.
name|create
argument_list|(
name|job
argument_list|,
name|getTaskID
argument_list|()
argument_list|,
name|combineInputCounter
argument_list|,
name|reporter
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|combinerRunner
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Counters
operator|.
name|Counter
name|combineOutputCounter
init|=
name|reporter
operator|.
name|getCounter
argument_list|(
name|TaskCounter
operator|.
name|COMBINE_OUTPUT_RECORDS
argument_list|)
decl_stmt|;
name|combineCollector
operator|=
operator|new
name|CombineOutputCollector
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|combineOutputCounter
argument_list|,
name|reporter
argument_list|,
name|job
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|combineCollector
operator|=
literal|null
expr_stmt|;
block|}
name|spillInProgress
operator|=
literal|false
expr_stmt|;
name|minSpillsForCombine
operator|=
name|job
operator|.
name|getInt
argument_list|(
name|JobContext
operator|.
name|MAP_COMBINE_MIN_SPILLS
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|spillThread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|spillThread
operator|.
name|setName
argument_list|(
literal|"SpillThread"
argument_list|)
expr_stmt|;
name|spillLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|spillThread
operator|.
name|start
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|spillThreadRunning
condition|)
block|{
name|spillDone
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Spill thread failed to initialize"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|spillLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|sortSpillException
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Spill thread failed to initialize"
argument_list|,
name|sortSpillException
argument_list|)
throw|;
block|}
block|}
comment|/**      * Serialize the key, value to intermediate storage.      * When this method returns, kvindex must refer to sufficient unused      * storage to store one METADATA.      */
DECL|method|collect (K key, V value, final int partition )
specifier|public
specifier|synchronized
name|void
name|collect
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|,
specifier|final
name|int
name|partition
parameter_list|)
throws|throws
name|IOException
block|{
name|reporter
operator|.
name|progress
argument_list|()
expr_stmt|;
if|if
condition|(
name|key
operator|.
name|getClass
argument_list|()
operator|!=
name|keyClass
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Type mismatch in key from map: expected "
operator|+
name|keyClass
operator|.
name|getName
argument_list|()
operator|+
literal|", received "
operator|+
name|key
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|value
operator|.
name|getClass
argument_list|()
operator|!=
name|valClass
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Type mismatch in value from map: expected "
operator|+
name|valClass
operator|.
name|getName
argument_list|()
operator|+
literal|", received "
operator|+
name|value
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|partition
operator|<
literal|0
operator|||
name|partition
operator|>=
name|partitions
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Illegal partition for "
operator|+
name|key
operator|+
literal|" ("
operator|+
name|partition
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|checkSpillException
argument_list|()
expr_stmt|;
name|bufferRemaining
operator|-=
name|METASIZE
expr_stmt|;
if|if
condition|(
name|bufferRemaining
operator|<=
literal|0
condition|)
block|{
comment|// start spill if the thread is not running and the soft limit has been
comment|// reached
name|spillLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
do|do
block|{
if|if
condition|(
operator|!
name|spillInProgress
condition|)
block|{
specifier|final
name|int
name|kvbidx
init|=
literal|4
operator|*
name|kvindex
decl_stmt|;
specifier|final
name|int
name|kvbend
init|=
literal|4
operator|*
name|kvend
decl_stmt|;
comment|// serialized, unspilled bytes always lie between kvindex and
comment|// bufindex, crossing the equator. Note that any void space
comment|// created by a reset must be included in "used" bytes
specifier|final
name|int
name|bUsed
init|=
name|distanceTo
argument_list|(
name|kvbidx
argument_list|,
name|bufindex
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|bufsoftlimit
init|=
name|bUsed
operator|>=
name|softLimit
decl_stmt|;
if|if
condition|(
operator|(
name|kvbend
operator|+
name|METASIZE
operator|)
operator|%
name|kvbuffer
operator|.
name|length
operator|!=
name|equator
operator|-
operator|(
name|equator
operator|%
name|METASIZE
operator|)
condition|)
block|{
comment|// spill finished, reclaim space
name|resetSpill
argument_list|()
expr_stmt|;
name|bufferRemaining
operator|=
name|Math
operator|.
name|min
argument_list|(
name|distanceTo
argument_list|(
name|bufindex
argument_list|,
name|kvbidx
argument_list|)
operator|-
literal|2
operator|*
name|METASIZE
argument_list|,
name|softLimit
operator|-
name|bUsed
argument_list|)
operator|-
name|METASIZE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|bufsoftlimit
operator|&&
name|kvindex
operator|!=
name|kvend
condition|)
block|{
comment|// spill records, if any collected; check latter, as it may
comment|// be possible for metadata alignment to hit spill pcnt
name|startSpill
argument_list|()
expr_stmt|;
specifier|final
name|int
name|avgRec
init|=
call|(
name|int
call|)
argument_list|(
name|mapOutputByteCounter
operator|.
name|getCounter
argument_list|()
operator|/
name|mapOutputRecordCounter
operator|.
name|getCounter
argument_list|()
argument_list|)
decl_stmt|;
comment|// leave at least half the split buffer for serialization data
comment|// ensure that kvindex>= bufindex
specifier|final
name|int
name|distkvi
init|=
name|distanceTo
argument_list|(
name|bufindex
argument_list|,
name|kvbidx
argument_list|)
decl_stmt|;
specifier|final
name|int
name|newPos
init|=
operator|(
name|bufindex
operator|+
name|Math
operator|.
name|max
argument_list|(
literal|2
operator|*
name|METASIZE
operator|-
literal|1
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|distkvi
operator|/
literal|2
argument_list|,
name|distkvi
operator|/
operator|(
name|METASIZE
operator|+
name|avgRec
operator|)
operator|*
name|METASIZE
argument_list|)
argument_list|)
operator|)
operator|%
name|kvbuffer
operator|.
name|length
decl_stmt|;
name|setEquator
argument_list|(
name|newPos
argument_list|)
expr_stmt|;
name|bufmark
operator|=
name|bufindex
operator|=
name|newPos
expr_stmt|;
specifier|final
name|int
name|serBound
init|=
literal|4
operator|*
name|kvend
decl_stmt|;
comment|// bytes remaining before the lock must be held and limits
comment|// checked is the minimum of three arcs: the metadata space, the
comment|// serialization space, and the soft limit
name|bufferRemaining
operator|=
name|Math
operator|.
name|min
argument_list|(
comment|// metadata max
name|distanceTo
argument_list|(
name|bufend
argument_list|,
name|newPos
argument_list|)
argument_list|,
name|Math
operator|.
name|min
argument_list|(
comment|// serialization max
name|distanceTo
argument_list|(
name|newPos
argument_list|,
name|serBound
argument_list|)
argument_list|,
comment|// soft limit
name|softLimit
argument_list|)
argument_list|)
operator|-
literal|2
operator|*
name|METASIZE
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
literal|false
condition|)
do|;
block|}
finally|finally
block|{
name|spillLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
try|try
block|{
comment|// serialize key bytes into buffer
name|int
name|keystart
init|=
name|bufindex
decl_stmt|;
name|keySerializer
operator|.
name|serialize
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufindex
operator|<
name|keystart
condition|)
block|{
comment|// wrapped the key; must make contiguous
name|bb
operator|.
name|shiftBufferedKey
argument_list|()
expr_stmt|;
name|keystart
operator|=
literal|0
expr_stmt|;
block|}
comment|// serialize value bytes into buffer
specifier|final
name|int
name|valstart
init|=
name|bufindex
decl_stmt|;
name|valSerializer
operator|.
name|serialize
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|// It's possible for records to have zero length, i.e. the serializer
comment|// will perform no writes. To ensure that the boundary conditions are
comment|// checked and that the kvindex invariant is maintained, perform a
comment|// zero-length write into the buffer. The logic monitoring this could be
comment|// moved into collect, but this is cleaner and inexpensive. For now, it
comment|// is acceptable.
name|bb
operator|.
name|write
argument_list|(
name|b0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// the record must be marked after the preceding write, as the metadata
comment|// for this record are not yet written
name|int
name|valend
init|=
name|bb
operator|.
name|markRecord
argument_list|()
decl_stmt|;
name|mapOutputRecordCounter
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|mapOutputByteCounter
operator|.
name|increment
argument_list|(
name|distanceTo
argument_list|(
name|keystart
argument_list|,
name|valend
argument_list|,
name|bufvoid
argument_list|)
argument_list|)
expr_stmt|;
comment|// write accounting info
name|kvmeta
operator|.
name|put
argument_list|(
name|kvindex
operator|+
name|PARTITION
argument_list|,
name|partition
argument_list|)
expr_stmt|;
name|kvmeta
operator|.
name|put
argument_list|(
name|kvindex
operator|+
name|KEYSTART
argument_list|,
name|keystart
argument_list|)
expr_stmt|;
name|kvmeta
operator|.
name|put
argument_list|(
name|kvindex
operator|+
name|VALSTART
argument_list|,
name|valstart
argument_list|)
expr_stmt|;
name|kvmeta
operator|.
name|put
argument_list|(
name|kvindex
operator|+
name|VALLEN
argument_list|,
name|distanceTo
argument_list|(
name|valstart
argument_list|,
name|valend
argument_list|)
argument_list|)
expr_stmt|;
comment|// advance kvindex
name|kvindex
operator|=
operator|(
name|kvindex
operator|-
name|NMETA
operator|+
name|kvmeta
operator|.
name|capacity
argument_list|()
operator|)
operator|%
name|kvmeta
operator|.
name|capacity
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MapBufferTooSmallException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Record too large for in-memory buffer: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|spillSingleRecord
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
name|partition
argument_list|)
expr_stmt|;
name|mapOutputRecordCounter
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
DECL|method|getTaskID ()
specifier|private
name|TaskAttemptID
name|getTaskID
parameter_list|()
block|{
return|return
name|mapTask
operator|.
name|getTaskID
argument_list|()
return|;
block|}
comment|/**      * Set the point from which meta and serialization data expand. The meta      * indices are aligned with the buffer, so metadata never spans the ends of      * the circular buffer.      */
DECL|method|setEquator (int pos)
specifier|private
name|void
name|setEquator
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
name|equator
operator|=
name|pos
expr_stmt|;
comment|// set index prior to first entry, aligned at meta boundary
specifier|final
name|int
name|aligned
init|=
name|pos
operator|-
operator|(
name|pos
operator|%
name|METASIZE
operator|)
decl_stmt|;
comment|// Cast one of the operands to long to avoid integer overflow
name|kvindex
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|long
operator|)
name|aligned
operator|-
name|METASIZE
operator|+
name|kvbuffer
operator|.
name|length
operator|)
operator|%
name|kvbuffer
operator|.
name|length
argument_list|)
operator|/
literal|4
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"(EQUATOR) "
operator|+
name|pos
operator|+
literal|" kvi "
operator|+
name|kvindex
operator|+
literal|"("
operator|+
operator|(
name|kvindex
operator|*
literal|4
operator|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
comment|/**      * The spill is complete, so set the buffer and meta indices to be equal to      * the new equator to free space for continuing collection. Note that when      * kvindex == kvend == kvstart, the buffer is empty.      */
DECL|method|resetSpill ()
specifier|private
name|void
name|resetSpill
parameter_list|()
block|{
specifier|final
name|int
name|e
init|=
name|equator
decl_stmt|;
name|bufstart
operator|=
name|bufend
operator|=
name|e
expr_stmt|;
specifier|final
name|int
name|aligned
init|=
name|e
operator|-
operator|(
name|e
operator|%
name|METASIZE
operator|)
decl_stmt|;
comment|// set start/end to point to first meta record
comment|// Cast one of the operands to long to avoid integer overflow
name|kvstart
operator|=
name|kvend
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|long
operator|)
name|aligned
operator|-
name|METASIZE
operator|+
name|kvbuffer
operator|.
name|length
operator|)
operator|%
name|kvbuffer
operator|.
name|length
argument_list|)
operator|/
literal|4
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"(RESET) equator "
operator|+
name|e
operator|+
literal|" kv "
operator|+
name|kvstart
operator|+
literal|"("
operator|+
operator|(
name|kvstart
operator|*
literal|4
operator|)
operator|+
literal|")"
operator|+
literal|" kvi "
operator|+
name|kvindex
operator|+
literal|"("
operator|+
operator|(
name|kvindex
operator|*
literal|4
operator|)
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Compute the distance in bytes between two indices in the serialization      * buffer.      * @see #distanceTo(int,int,int)      */
DECL|method|distanceTo (final int i, final int j)
specifier|final
name|int
name|distanceTo
parameter_list|(
specifier|final
name|int
name|i
parameter_list|,
specifier|final
name|int
name|j
parameter_list|)
block|{
return|return
name|distanceTo
argument_list|(
name|i
argument_list|,
name|j
argument_list|,
name|kvbuffer
operator|.
name|length
argument_list|)
return|;
block|}
comment|/**      * Compute the distance between two indices in the circular buffer given the      * max distance.      */
DECL|method|distanceTo (final int i, final int j, final int mod)
name|int
name|distanceTo
parameter_list|(
specifier|final
name|int
name|i
parameter_list|,
specifier|final
name|int
name|j
parameter_list|,
specifier|final
name|int
name|mod
parameter_list|)
block|{
return|return
name|i
operator|<=
name|j
condition|?
name|j
operator|-
name|i
else|:
name|mod
operator|-
name|i
operator|+
name|j
return|;
block|}
comment|/**      * For the given meta position, return the offset into the int-sized      * kvmeta buffer.      */
DECL|method|offsetFor (int metapos)
name|int
name|offsetFor
parameter_list|(
name|int
name|metapos
parameter_list|)
block|{
return|return
name|metapos
operator|*
name|NMETA
return|;
block|}
comment|/**      * Compare logical range, st i, j MOD offset capacity.      * Compare by partition, then by key.      * @see IndexedSortable#compare      */
annotation|@
name|Override
DECL|method|compare (final int mi, final int mj)
specifier|public
name|int
name|compare
parameter_list|(
specifier|final
name|int
name|mi
parameter_list|,
specifier|final
name|int
name|mj
parameter_list|)
block|{
specifier|final
name|int
name|kvi
init|=
name|offsetFor
argument_list|(
name|mi
operator|%
name|maxRec
argument_list|)
decl_stmt|;
specifier|final
name|int
name|kvj
init|=
name|offsetFor
argument_list|(
name|mj
operator|%
name|maxRec
argument_list|)
decl_stmt|;
specifier|final
name|int
name|kvip
init|=
name|kvmeta
operator|.
name|get
argument_list|(
name|kvi
operator|+
name|PARTITION
argument_list|)
decl_stmt|;
specifier|final
name|int
name|kvjp
init|=
name|kvmeta
operator|.
name|get
argument_list|(
name|kvj
operator|+
name|PARTITION
argument_list|)
decl_stmt|;
comment|// sort by partition
if|if
condition|(
name|kvip
operator|!=
name|kvjp
condition|)
block|{
return|return
name|kvip
operator|-
name|kvjp
return|;
block|}
comment|// sort by key
return|return
name|comparator
operator|.
name|compare
argument_list|(
name|kvbuffer
argument_list|,
name|kvmeta
operator|.
name|get
argument_list|(
name|kvi
operator|+
name|KEYSTART
argument_list|)
argument_list|,
name|kvmeta
operator|.
name|get
argument_list|(
name|kvi
operator|+
name|VALSTART
argument_list|)
operator|-
name|kvmeta
operator|.
name|get
argument_list|(
name|kvi
operator|+
name|KEYSTART
argument_list|)
argument_list|,
name|kvbuffer
argument_list|,
name|kvmeta
operator|.
name|get
argument_list|(
name|kvj
operator|+
name|KEYSTART
argument_list|)
argument_list|,
name|kvmeta
operator|.
name|get
argument_list|(
name|kvj
operator|+
name|VALSTART
argument_list|)
operator|-
name|kvmeta
operator|.
name|get
argument_list|(
name|kvj
operator|+
name|KEYSTART
argument_list|)
argument_list|)
return|;
block|}
DECL|field|META_BUFFER_TMP
specifier|final
name|byte
name|META_BUFFER_TMP
index|[]
init|=
operator|new
name|byte
index|[
name|METASIZE
index|]
decl_stmt|;
comment|/**      * Swap metadata for items i, j      * @see IndexedSortable#swap      */
annotation|@
name|Override
DECL|method|swap (final int mi, final int mj)
specifier|public
name|void
name|swap
parameter_list|(
specifier|final
name|int
name|mi
parameter_list|,
specifier|final
name|int
name|mj
parameter_list|)
block|{
name|int
name|iOff
init|=
operator|(
name|mi
operator|%
name|maxRec
operator|)
operator|*
name|METASIZE
decl_stmt|;
name|int
name|jOff
init|=
operator|(
name|mj
operator|%
name|maxRec
operator|)
operator|*
name|METASIZE
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|kvbuffer
argument_list|,
name|iOff
argument_list|,
name|META_BUFFER_TMP
argument_list|,
literal|0
argument_list|,
name|METASIZE
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|kvbuffer
argument_list|,
name|jOff
argument_list|,
name|kvbuffer
argument_list|,
name|iOff
argument_list|,
name|METASIZE
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|META_BUFFER_TMP
argument_list|,
literal|0
argument_list|,
name|kvbuffer
argument_list|,
name|jOff
argument_list|,
name|METASIZE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Inner class managing the spill of serialized records to disk.      */
DECL|class|BlockingBuffer
specifier|protected
class|class
name|BlockingBuffer
extends|extends
name|DataOutputStream
block|{
DECL|method|BlockingBuffer ()
specifier|public
name|BlockingBuffer
parameter_list|()
block|{
name|super
argument_list|(
operator|new
name|Buffer
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**        * Mark end of record. Note that this is required if the buffer is to        * cut the spill in the proper place.        */
DECL|method|markRecord ()
specifier|public
name|int
name|markRecord
parameter_list|()
block|{
name|bufmark
operator|=
name|bufindex
expr_stmt|;
return|return
name|bufindex
return|;
block|}
comment|/**        * Set position from last mark to end of writable buffer, then rewrite        * the data between last mark and kvindex.        * This handles a special case where the key wraps around the buffer.        * If the key is to be passed to a RawComparator, then it must be        * contiguous in the buffer. This recopies the data in the buffer back        * into itself, but starting at the beginning of the buffer. Note that        * this method should<b>only</b> be called immediately after detecting        * this condition. To call it at any other time is undefined and would        * likely result in data loss or corruption.        * @see #markRecord()        */
DECL|method|shiftBufferedKey ()
specifier|protected
name|void
name|shiftBufferedKey
parameter_list|()
throws|throws
name|IOException
block|{
comment|// spillLock unnecessary; both kvend and kvindex are current
name|int
name|headbytelen
init|=
name|bufvoid
operator|-
name|bufmark
decl_stmt|;
name|bufvoid
operator|=
name|bufmark
expr_stmt|;
specifier|final
name|int
name|kvbidx
init|=
literal|4
operator|*
name|kvindex
decl_stmt|;
specifier|final
name|int
name|kvbend
init|=
literal|4
operator|*
name|kvend
decl_stmt|;
specifier|final
name|int
name|avail
init|=
name|Math
operator|.
name|min
argument_list|(
name|distanceTo
argument_list|(
literal|0
argument_list|,
name|kvbidx
argument_list|)
argument_list|,
name|distanceTo
argument_list|(
literal|0
argument_list|,
name|kvbend
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bufindex
operator|+
name|headbytelen
operator|<
name|avail
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|kvbuffer
argument_list|,
literal|0
argument_list|,
name|kvbuffer
argument_list|,
name|headbytelen
argument_list|,
name|bufindex
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|kvbuffer
argument_list|,
name|bufvoid
argument_list|,
name|kvbuffer
argument_list|,
literal|0
argument_list|,
name|headbytelen
argument_list|)
expr_stmt|;
name|bufindex
operator|+=
name|headbytelen
expr_stmt|;
name|bufferRemaining
operator|-=
name|kvbuffer
operator|.
name|length
operator|-
name|bufvoid
expr_stmt|;
block|}
else|else
block|{
name|byte
index|[]
name|keytmp
init|=
operator|new
name|byte
index|[
name|bufindex
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|kvbuffer
argument_list|,
literal|0
argument_list|,
name|keytmp
argument_list|,
literal|0
argument_list|,
name|bufindex
argument_list|)
expr_stmt|;
name|bufindex
operator|=
literal|0
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|kvbuffer
argument_list|,
name|bufmark
argument_list|,
name|headbytelen
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|keytmp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|Buffer
specifier|public
class|class
name|Buffer
extends|extends
name|OutputStream
block|{
DECL|field|scratch
specifier|private
specifier|final
name|byte
index|[]
name|scratch
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
annotation|@
name|Override
DECL|method|write (int v)
specifier|public
name|void
name|write
parameter_list|(
name|int
name|v
parameter_list|)
throws|throws
name|IOException
block|{
name|scratch
index|[
literal|0
index|]
operator|=
operator|(
name|byte
operator|)
name|v
expr_stmt|;
name|write
argument_list|(
name|scratch
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**        * Attempt to write a sequence of bytes to the collection buffer.        * This method will block if the spill thread is running and it        * cannot write.        * @throws MapBufferTooSmallException if record is too large to        *    deserialize into the collection buffer.        */
annotation|@
name|Override
DECL|method|write (byte b[], int off, int len)
specifier|public
name|void
name|write
parameter_list|(
name|byte
name|b
index|[]
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
comment|// must always verify the invariant that at least METASIZE bytes are
comment|// available beyond kvindex, even when len == 0
name|bufferRemaining
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|bufferRemaining
operator|<=
literal|0
condition|)
block|{
comment|// writing these bytes could exhaust available buffer space or fill
comment|// the buffer to soft limit. check if spill or blocking are necessary
name|boolean
name|blockwrite
init|=
literal|false
decl_stmt|;
name|spillLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
do|do
block|{
name|checkSpillException
argument_list|()
expr_stmt|;
specifier|final
name|int
name|kvbidx
init|=
literal|4
operator|*
name|kvindex
decl_stmt|;
specifier|final
name|int
name|kvbend
init|=
literal|4
operator|*
name|kvend
decl_stmt|;
comment|// ser distance to key index
specifier|final
name|int
name|distkvi
init|=
name|distanceTo
argument_list|(
name|bufindex
argument_list|,
name|kvbidx
argument_list|)
decl_stmt|;
comment|// ser distance to spill end index
specifier|final
name|int
name|distkve
init|=
name|distanceTo
argument_list|(
name|bufindex
argument_list|,
name|kvbend
argument_list|)
decl_stmt|;
comment|// if kvindex is closer than kvend, then a spill is neither in
comment|// progress nor complete and reset since the lock was held. The
comment|// write should block only if there is insufficient space to
comment|// complete the current write, write the metadata for this record,
comment|// and write the metadata for the next record. If kvend is closer,
comment|// then the write should block if there is too little space for
comment|// either the metadata or the current write. Note that collect
comment|// ensures its metadata requirement with a zero-length write
name|blockwrite
operator|=
name|distkvi
operator|<=
name|distkve
condition|?
name|distkvi
operator|<=
name|len
operator|+
literal|2
operator|*
name|METASIZE
else|:
name|distkve
operator|<=
name|len
operator|||
name|distanceTo
argument_list|(
name|bufend
argument_list|,
name|kvbidx
argument_list|)
operator|<
literal|2
operator|*
name|METASIZE
expr_stmt|;
if|if
condition|(
operator|!
name|spillInProgress
condition|)
block|{
if|if
condition|(
name|blockwrite
condition|)
block|{
if|if
condition|(
operator|(
name|kvbend
operator|+
name|METASIZE
operator|)
operator|%
name|kvbuffer
operator|.
name|length
operator|!=
name|equator
operator|-
operator|(
name|equator
operator|%
name|METASIZE
operator|)
condition|)
block|{
comment|// spill finished, reclaim space
comment|// need to use meta exclusively; zero-len rec& 100% spill
comment|// pcnt would fail
name|resetSpill
argument_list|()
expr_stmt|;
comment|// resetSpill doesn't move bufindex, kvindex
name|bufferRemaining
operator|=
name|Math
operator|.
name|min
argument_list|(
name|distkvi
operator|-
literal|2
operator|*
name|METASIZE
argument_list|,
name|softLimit
operator|-
name|distanceTo
argument_list|(
name|kvbidx
argument_list|,
name|bufindex
argument_list|)
argument_list|)
operator|-
name|len
expr_stmt|;
continue|continue;
block|}
comment|// we have records we can spill; only spill if blocked
if|if
condition|(
name|kvindex
operator|!=
name|kvend
condition|)
block|{
name|startSpill
argument_list|()
expr_stmt|;
comment|// Blocked on this write, waiting for the spill just
comment|// initiated to finish. Instead of repositioning the marker
comment|// and copying the partial record, we set the record start
comment|// to be the new equator
name|setEquator
argument_list|(
name|bufmark
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// We have no buffered records, and this record is too large
comment|// to write into kvbuffer. We must spill it directly from
comment|// collect
specifier|final
name|int
name|size
init|=
name|distanceTo
argument_list|(
name|bufstart
argument_list|,
name|bufindex
argument_list|)
operator|+
name|len
decl_stmt|;
name|setEquator
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bufstart
operator|=
name|bufend
operator|=
name|bufindex
operator|=
name|equator
expr_stmt|;
name|kvstart
operator|=
name|kvend
operator|=
name|kvindex
expr_stmt|;
name|bufvoid
operator|=
name|kvbuffer
operator|.
name|length
expr_stmt|;
throw|throw
operator|new
name|MapBufferTooSmallException
argument_list|(
name|size
operator|+
literal|" bytes"
argument_list|)
throw|;
block|}
block|}
block|}
if|if
condition|(
name|blockwrite
condition|)
block|{
comment|// wait for spill
try|try
block|{
while|while
condition|(
name|spillInProgress
condition|)
block|{
name|reporter
operator|.
name|progress
argument_list|()
expr_stmt|;
name|spillDone
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Buffer interrupted while waiting for the writer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
do|while
condition|(
name|blockwrite
condition|)
do|;
block|}
finally|finally
block|{
name|spillLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|// here, we know that we have sufficient space to write
if|if
condition|(
name|bufindex
operator|+
name|len
operator|>
name|bufvoid
condition|)
block|{
specifier|final
name|int
name|gaplen
init|=
name|bufvoid
operator|-
name|bufindex
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|kvbuffer
argument_list|,
name|bufindex
argument_list|,
name|gaplen
argument_list|)
expr_stmt|;
name|len
operator|-=
name|gaplen
expr_stmt|;
name|off
operator|+=
name|gaplen
expr_stmt|;
name|bufindex
operator|=
literal|0
expr_stmt|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|kvbuffer
argument_list|,
name|bufindex
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bufindex
operator|+=
name|len
expr_stmt|;
block|}
block|}
DECL|method|flush ()
specifier|public
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
throws|,
name|InterruptedException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting flush of map output"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kvbuffer
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"kvbuffer is null. Skipping flush."
argument_list|)
expr_stmt|;
return|return;
block|}
name|spillLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
while|while
condition|(
name|spillInProgress
condition|)
block|{
name|reporter
operator|.
name|progress
argument_list|()
expr_stmt|;
name|spillDone
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
name|checkSpillException
argument_list|()
expr_stmt|;
specifier|final
name|int
name|kvbend
init|=
literal|4
operator|*
name|kvend
decl_stmt|;
if|if
condition|(
operator|(
name|kvbend
operator|+
name|METASIZE
operator|)
operator|%
name|kvbuffer
operator|.
name|length
operator|!=
name|equator
operator|-
operator|(
name|equator
operator|%
name|METASIZE
operator|)
condition|)
block|{
comment|// spill finished
name|resetSpill
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|kvindex
operator|!=
name|kvend
condition|)
block|{
name|kvend
operator|=
operator|(
name|kvindex
operator|+
name|NMETA
operator|)
operator|%
name|kvmeta
operator|.
name|capacity
argument_list|()
expr_stmt|;
name|bufend
operator|=
name|bufmark
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Spilling map output"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"bufstart = "
operator|+
name|bufstart
operator|+
literal|"; bufend = "
operator|+
name|bufmark
operator|+
literal|"; bufvoid = "
operator|+
name|bufvoid
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"kvstart = "
operator|+
name|kvstart
operator|+
literal|"("
operator|+
operator|(
name|kvstart
operator|*
literal|4
operator|)
operator|+
literal|"); kvend = "
operator|+
name|kvend
operator|+
literal|"("
operator|+
operator|(
name|kvend
operator|*
literal|4
operator|)
operator|+
literal|"); length = "
operator|+
operator|(
name|distanceTo
argument_list|(
name|kvend
argument_list|,
name|kvstart
argument_list|,
name|kvmeta
operator|.
name|capacity
argument_list|()
argument_list|)
operator|+
literal|1
operator|)
operator|+
literal|"/"
operator|+
name|maxRec
argument_list|)
expr_stmt|;
name|sortAndSpill
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Interrupted while waiting for the writer"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|spillLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
assert|assert
operator|!
name|spillLock
operator|.
name|isHeldByCurrentThread
argument_list|()
assert|;
comment|// shut down spill thread and wait for it to exit. Since the preceding
comment|// ensures that it is finished with its work (and sortAndSpill did not
comment|// throw), we elect to use an interrupt instead of setting a flag.
comment|// Spilling simultaneously from this thread while the spill thread
comment|// finishes its work might be both a useful way to extend this and also
comment|// sufficient motivation for the latter approach.
try|try
block|{
name|spillThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|spillThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Spill failed"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// release sort buffer before the merge
name|kvbuffer
operator|=
literal|null
expr_stmt|;
name|mergeParts
argument_list|()
expr_stmt|;
name|Path
name|outputPath
init|=
name|mapOutputFile
operator|.
name|getOutputFile
argument_list|()
decl_stmt|;
name|fileOutputByteCounter
operator|.
name|increment
argument_list|(
name|rfs
operator|.
name|getFileStatus
argument_list|(
name|outputPath
argument_list|)
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
block|{ }
DECL|class|SpillThread
specifier|protected
class|class
name|SpillThread
extends|extends
name|Thread
block|{
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|spillLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|spillThreadRunning
operator|=
literal|true
expr_stmt|;
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|spillDone
operator|.
name|signal
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|spillInProgress
condition|)
block|{
name|spillReady
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|spillLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|sortAndSpill
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|sortSpillException
operator|=
name|t
expr_stmt|;
block|}
finally|finally
block|{
name|spillLock
operator|.
name|lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|bufend
operator|<
name|bufstart
condition|)
block|{
name|bufvoid
operator|=
name|kvbuffer
operator|.
name|length
expr_stmt|;
block|}
name|kvstart
operator|=
name|kvend
expr_stmt|;
name|bufstart
operator|=
name|bufend
expr_stmt|;
name|spillInProgress
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|spillLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|spillThreadRunning
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
DECL|method|checkSpillException ()
specifier|private
name|void
name|checkSpillException
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|Throwable
name|lspillException
init|=
name|sortSpillException
decl_stmt|;
if|if
condition|(
name|lspillException
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|lspillException
operator|instanceof
name|Error
condition|)
block|{
specifier|final
name|String
name|logMsg
init|=
literal|"Task "
operator|+
name|getTaskID
argument_list|()
operator|+
literal|" failed : "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|lspillException
argument_list|)
decl_stmt|;
name|mapTask
operator|.
name|reportFatalError
argument_list|(
name|getTaskID
argument_list|()
argument_list|,
name|lspillException
argument_list|,
name|logMsg
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Spill failed"
argument_list|,
name|lspillException
argument_list|)
throw|;
block|}
block|}
DECL|method|startSpill ()
specifier|private
name|void
name|startSpill
parameter_list|()
block|{
assert|assert
operator|!
name|spillInProgress
assert|;
name|kvend
operator|=
operator|(
name|kvindex
operator|+
name|NMETA
operator|)
operator|%
name|kvmeta
operator|.
name|capacity
argument_list|()
expr_stmt|;
name|bufend
operator|=
name|bufmark
expr_stmt|;
name|spillInProgress
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Spilling map output"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"bufstart = "
operator|+
name|bufstart
operator|+
literal|"; bufend = "
operator|+
name|bufmark
operator|+
literal|"; bufvoid = "
operator|+
name|bufvoid
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"kvstart = "
operator|+
name|kvstart
operator|+
literal|"("
operator|+
operator|(
name|kvstart
operator|*
literal|4
operator|)
operator|+
literal|"); kvend = "
operator|+
name|kvend
operator|+
literal|"("
operator|+
operator|(
name|kvend
operator|*
literal|4
operator|)
operator|+
literal|"); length = "
operator|+
operator|(
name|distanceTo
argument_list|(
name|kvend
argument_list|,
name|kvstart
argument_list|,
name|kvmeta
operator|.
name|capacity
argument_list|()
argument_list|)
operator|+
literal|1
operator|)
operator|+
literal|"/"
operator|+
name|maxRec
argument_list|)
expr_stmt|;
name|spillReady
operator|.
name|signal
argument_list|()
expr_stmt|;
block|}
DECL|method|sortAndSpill ()
specifier|private
name|void
name|sortAndSpill
parameter_list|()
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
throws|,
name|InterruptedException
block|{
comment|//approximate the length of the output file to be the length of the
comment|//buffer + header lengths for the partitions
specifier|final
name|long
name|size
init|=
name|distanceTo
argument_list|(
name|bufstart
argument_list|,
name|bufend
argument_list|,
name|bufvoid
argument_list|)
operator|+
name|partitions
operator|*
name|APPROX_HEADER_LENGTH
decl_stmt|;
name|FSDataOutputStream
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// create spill file
specifier|final
name|SpillRecord
name|spillRec
init|=
operator|new
name|SpillRecord
argument_list|(
name|partitions
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|filename
init|=
name|mapOutputFile
operator|.
name|getSpillFileForWrite
argument_list|(
name|numSpills
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|out
operator|=
name|rfs
operator|.
name|create
argument_list|(
name|filename
argument_list|)
expr_stmt|;
specifier|final
name|int
name|mstart
init|=
name|kvend
operator|/
name|NMETA
decl_stmt|;
specifier|final
name|int
name|mend
init|=
literal|1
operator|+
comment|// kvend is a valid record
operator|(
name|kvstart
operator|>=
name|kvend
condition|?
name|kvstart
else|:
name|kvmeta
operator|.
name|capacity
argument_list|()
operator|+
name|kvstart
operator|)
operator|/
name|NMETA
decl_stmt|;
name|sorter
operator|.
name|sort
argument_list|(
name|MapOutputBuffer
operator|.
name|this
argument_list|,
name|mstart
argument_list|,
name|mend
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
name|int
name|spindex
init|=
name|mstart
decl_stmt|;
specifier|final
name|IndexRecord
name|rec
init|=
operator|new
name|IndexRecord
argument_list|()
decl_stmt|;
specifier|final
name|InMemValBytes
name|value
init|=
operator|new
name|InMemValBytes
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partitions
condition|;
operator|++
name|i
control|)
block|{
name|IFile
operator|.
name|Writer
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|writer
init|=
literal|null
decl_stmt|;
try|try
block|{
name|long
name|segmentStart
init|=
name|out
operator|.
name|getPos
argument_list|()
decl_stmt|;
name|FSDataOutputStream
name|partitionOut
init|=
name|CryptoUtils
operator|.
name|wrapIfNecessary
argument_list|(
name|job
argument_list|,
name|out
argument_list|)
decl_stmt|;
name|writer
operator|=
operator|new
name|Writer
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|job
argument_list|,
name|partitionOut
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|codec
argument_list|,
name|spilledRecordsCounter
argument_list|)
expr_stmt|;
if|if
condition|(
name|combinerRunner
operator|==
literal|null
condition|)
block|{
comment|// spill directly
name|DataInputBuffer
name|key
init|=
operator|new
name|DataInputBuffer
argument_list|()
decl_stmt|;
while|while
condition|(
name|spindex
operator|<
name|mend
operator|&&
name|kvmeta
operator|.
name|get
argument_list|(
name|offsetFor
argument_list|(
name|spindex
operator|%
name|maxRec
argument_list|)
operator|+
name|PARTITION
argument_list|)
operator|==
name|i
condition|)
block|{
specifier|final
name|int
name|kvoff
init|=
name|offsetFor
argument_list|(
name|spindex
operator|%
name|maxRec
argument_list|)
decl_stmt|;
name|int
name|keystart
init|=
name|kvmeta
operator|.
name|get
argument_list|(
name|kvoff
operator|+
name|KEYSTART
argument_list|)
decl_stmt|;
name|int
name|valstart
init|=
name|kvmeta
operator|.
name|get
argument_list|(
name|kvoff
operator|+
name|VALSTART
argument_list|)
decl_stmt|;
name|key
operator|.
name|reset
argument_list|(
name|kvbuffer
argument_list|,
name|keystart
argument_list|,
name|valstart
operator|-
name|keystart
argument_list|)
expr_stmt|;
name|getVBytesForOffset
argument_list|(
name|kvoff
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|writer
operator|.
name|append
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
operator|++
name|spindex
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|spstart
init|=
name|spindex
decl_stmt|;
while|while
condition|(
name|spindex
operator|<
name|mend
operator|&&
name|kvmeta
operator|.
name|get
argument_list|(
name|offsetFor
argument_list|(
name|spindex
operator|%
name|maxRec
argument_list|)
operator|+
name|PARTITION
argument_list|)
operator|==
name|i
condition|)
block|{
operator|++
name|spindex
expr_stmt|;
block|}
comment|// Note: we would like to avoid the combiner if we've fewer
comment|// than some threshold of records for a partition
if|if
condition|(
name|spstart
operator|!=
name|spindex
condition|)
block|{
name|combineCollector
operator|.
name|setWriter
argument_list|(
name|writer
argument_list|)
expr_stmt|;
name|RawKeyValueIterator
name|kvIter
init|=
operator|new
name|MRResultIterator
argument_list|(
name|spstart
argument_list|,
name|spindex
argument_list|)
decl_stmt|;
name|combinerRunner
operator|.
name|combine
argument_list|(
name|kvIter
argument_list|,
name|combineCollector
argument_list|)
expr_stmt|;
block|}
block|}
comment|// close the writer
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// record offsets
name|rec
operator|.
name|startOffset
operator|=
name|segmentStart
expr_stmt|;
name|rec
operator|.
name|rawLength
operator|=
name|writer
operator|.
name|getRawLength
argument_list|()
operator|+
name|CryptoUtils
operator|.
name|cryptoPadding
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|rec
operator|.
name|partLength
operator|=
name|writer
operator|.
name|getCompressedLength
argument_list|()
operator|+
name|CryptoUtils
operator|.
name|cryptoPadding
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|spillRec
operator|.
name|putIndex
argument_list|(
name|rec
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|writer
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
literal|null
operator|!=
name|writer
condition|)
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|totalIndexCacheMemory
operator|>=
name|indexCacheMemoryLimit
condition|)
block|{
comment|// create spill index file
name|Path
name|indexFilename
init|=
name|mapOutputFile
operator|.
name|getSpillIndexFileForWrite
argument_list|(
name|numSpills
argument_list|,
name|partitions
operator|*
name|MAP_OUTPUT_INDEX_RECORD_LENGTH
argument_list|)
decl_stmt|;
name|spillRec
operator|.
name|writeToFile
argument_list|(
name|indexFilename
argument_list|,
name|job
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexCacheList
operator|.
name|add
argument_list|(
name|spillRec
argument_list|)
expr_stmt|;
name|totalIndexCacheMemory
operator|+=
name|spillRec
operator|.
name|size
argument_list|()
operator|*
name|MAP_OUTPUT_INDEX_RECORD_LENGTH
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Finished spill "
operator|+
name|numSpills
argument_list|)
expr_stmt|;
operator|++
name|numSpills
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Handles the degenerate case where serialization fails to fit in      * the in-memory buffer, so we must spill the record from collect      * directly to a spill file. Consider this "losing".      */
DECL|method|spillSingleRecord (final K key, final V value, int partition)
specifier|private
name|void
name|spillSingleRecord
parameter_list|(
specifier|final
name|K
name|key
parameter_list|,
specifier|final
name|V
name|value
parameter_list|,
name|int
name|partition
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|size
init|=
name|kvbuffer
operator|.
name|length
operator|+
name|partitions
operator|*
name|APPROX_HEADER_LENGTH
decl_stmt|;
name|FSDataOutputStream
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// create spill file
specifier|final
name|SpillRecord
name|spillRec
init|=
operator|new
name|SpillRecord
argument_list|(
name|partitions
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|filename
init|=
name|mapOutputFile
operator|.
name|getSpillFileForWrite
argument_list|(
name|numSpills
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|out
operator|=
name|rfs
operator|.
name|create
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|// we don't run the combiner for a single record
name|IndexRecord
name|rec
init|=
operator|new
name|IndexRecord
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partitions
condition|;
operator|++
name|i
control|)
block|{
name|IFile
operator|.
name|Writer
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|writer
init|=
literal|null
decl_stmt|;
try|try
block|{
name|long
name|segmentStart
init|=
name|out
operator|.
name|getPos
argument_list|()
decl_stmt|;
comment|// Create a new codec, don't care!
name|FSDataOutputStream
name|partitionOut
init|=
name|CryptoUtils
operator|.
name|wrapIfNecessary
argument_list|(
name|job
argument_list|,
name|out
argument_list|)
decl_stmt|;
name|writer
operator|=
operator|new
name|IFile
operator|.
name|Writer
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|job
argument_list|,
name|partitionOut
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|codec
argument_list|,
name|spilledRecordsCounter
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|partition
condition|)
block|{
specifier|final
name|long
name|recordStart
init|=
name|out
operator|.
name|getPos
argument_list|()
decl_stmt|;
name|writer
operator|.
name|append
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|// Note that our map byte count will not be accurate with
comment|// compression
name|mapOutputByteCounter
operator|.
name|increment
argument_list|(
name|out
operator|.
name|getPos
argument_list|()
operator|-
name|recordStart
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// record offsets
name|rec
operator|.
name|startOffset
operator|=
name|segmentStart
expr_stmt|;
name|rec
operator|.
name|rawLength
operator|=
name|writer
operator|.
name|getRawLength
argument_list|()
operator|+
name|CryptoUtils
operator|.
name|cryptoPadding
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|rec
operator|.
name|partLength
operator|=
name|writer
operator|.
name|getCompressedLength
argument_list|()
operator|+
name|CryptoUtils
operator|.
name|cryptoPadding
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|spillRec
operator|.
name|putIndex
argument_list|(
name|rec
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|writer
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
literal|null
operator|!=
name|writer
condition|)
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
if|if
condition|(
name|totalIndexCacheMemory
operator|>=
name|indexCacheMemoryLimit
condition|)
block|{
comment|// create spill index file
name|Path
name|indexFilename
init|=
name|mapOutputFile
operator|.
name|getSpillIndexFileForWrite
argument_list|(
name|numSpills
argument_list|,
name|partitions
operator|*
name|MAP_OUTPUT_INDEX_RECORD_LENGTH
argument_list|)
decl_stmt|;
name|spillRec
operator|.
name|writeToFile
argument_list|(
name|indexFilename
argument_list|,
name|job
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexCacheList
operator|.
name|add
argument_list|(
name|spillRec
argument_list|)
expr_stmt|;
name|totalIndexCacheMemory
operator|+=
name|spillRec
operator|.
name|size
argument_list|()
operator|*
name|MAP_OUTPUT_INDEX_RECORD_LENGTH
expr_stmt|;
block|}
operator|++
name|numSpills
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Given an offset, populate vbytes with the associated set of      * deserialized value bytes. Should only be called during a spill.      */
DECL|method|getVBytesForOffset (int kvoff, InMemValBytes vbytes)
specifier|private
name|void
name|getVBytesForOffset
parameter_list|(
name|int
name|kvoff
parameter_list|,
name|InMemValBytes
name|vbytes
parameter_list|)
block|{
comment|// get the keystart for the next serialized value to be the end
comment|// of this value. If this is the last value in the buffer, use bufend
specifier|final
name|int
name|vallen
init|=
name|kvmeta
operator|.
name|get
argument_list|(
name|kvoff
operator|+
name|VALLEN
argument_list|)
decl_stmt|;
assert|assert
name|vallen
operator|>=
literal|0
assert|;
name|vbytes
operator|.
name|reset
argument_list|(
name|kvbuffer
argument_list|,
name|kvmeta
operator|.
name|get
argument_list|(
name|kvoff
operator|+
name|VALSTART
argument_list|)
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
block|}
comment|/**      * Inner class wrapping valuebytes, used for appendRaw.      */
DECL|class|InMemValBytes
specifier|protected
class|class
name|InMemValBytes
extends|extends
name|DataInputBuffer
block|{
DECL|field|buffer
specifier|private
name|byte
index|[]
name|buffer
decl_stmt|;
DECL|field|start
specifier|private
name|int
name|start
decl_stmt|;
DECL|field|length
specifier|private
name|int
name|length
decl_stmt|;
DECL|method|reset (byte[] buffer, int start, int length)
specifier|public
name|void
name|reset
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|this
operator|.
name|buffer
operator|=
name|buffer
expr_stmt|;
name|this
operator|.
name|start
operator|=
name|start
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|start
operator|+
name|length
operator|>
name|bufvoid
condition|)
block|{
name|this
operator|.
name|buffer
operator|=
operator|new
name|byte
index|[
name|this
operator|.
name|length
index|]
expr_stmt|;
specifier|final
name|int
name|taillen
init|=
name|bufvoid
operator|-
name|start
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|buffer
argument_list|,
name|start
argument_list|,
name|this
operator|.
name|buffer
argument_list|,
literal|0
argument_list|,
name|taillen
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|this
operator|.
name|buffer
argument_list|,
name|taillen
argument_list|,
name|length
operator|-
name|taillen
argument_list|)
expr_stmt|;
name|this
operator|.
name|start
operator|=
literal|0
expr_stmt|;
block|}
name|super
operator|.
name|reset
argument_list|(
name|this
operator|.
name|buffer
argument_list|,
name|this
operator|.
name|start
argument_list|,
name|this
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|MRResultIterator
specifier|protected
class|class
name|MRResultIterator
implements|implements
name|RawKeyValueIterator
block|{
DECL|field|keybuf
specifier|private
specifier|final
name|DataInputBuffer
name|keybuf
init|=
operator|new
name|DataInputBuffer
argument_list|()
decl_stmt|;
DECL|field|vbytes
specifier|private
specifier|final
name|InMemValBytes
name|vbytes
init|=
operator|new
name|InMemValBytes
argument_list|()
decl_stmt|;
DECL|field|end
specifier|private
specifier|final
name|int
name|end
decl_stmt|;
DECL|field|current
specifier|private
name|int
name|current
decl_stmt|;
DECL|method|MRResultIterator (int start, int end)
specifier|public
name|MRResultIterator
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|this
operator|.
name|end
operator|=
name|end
expr_stmt|;
name|current
operator|=
name|start
operator|-
literal|1
expr_stmt|;
block|}
DECL|method|next ()
specifier|public
name|boolean
name|next
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|++
name|current
operator|<
name|end
return|;
block|}
DECL|method|getKey ()
specifier|public
name|DataInputBuffer
name|getKey
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|kvoff
init|=
name|offsetFor
argument_list|(
name|current
operator|%
name|maxRec
argument_list|)
decl_stmt|;
name|keybuf
operator|.
name|reset
argument_list|(
name|kvbuffer
argument_list|,
name|kvmeta
operator|.
name|get
argument_list|(
name|kvoff
operator|+
name|KEYSTART
argument_list|)
argument_list|,
name|kvmeta
operator|.
name|get
argument_list|(
name|kvoff
operator|+
name|VALSTART
argument_list|)
operator|-
name|kvmeta
operator|.
name|get
argument_list|(
name|kvoff
operator|+
name|KEYSTART
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|keybuf
return|;
block|}
DECL|method|getValue ()
specifier|public
name|DataInputBuffer
name|getValue
parameter_list|()
throws|throws
name|IOException
block|{
name|getVBytesForOffset
argument_list|(
name|offsetFor
argument_list|(
name|current
operator|%
name|maxRec
argument_list|)
argument_list|,
name|vbytes
argument_list|)
expr_stmt|;
return|return
name|vbytes
return|;
block|}
DECL|method|getProgress ()
specifier|public
name|Progress
name|getProgress
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
block|{ }
block|}
DECL|method|mergeParts ()
specifier|private
name|void
name|mergeParts
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|ClassNotFoundException
block|{
comment|// get the approximate size of the final output/index files
name|long
name|finalOutFileSize
init|=
literal|0
decl_stmt|;
name|long
name|finalIndexFileSize
init|=
literal|0
decl_stmt|;
specifier|final
name|Path
index|[]
name|filename
init|=
operator|new
name|Path
index|[
name|numSpills
index|]
decl_stmt|;
specifier|final
name|TaskAttemptID
name|mapId
init|=
name|getTaskID
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSpills
condition|;
name|i
operator|++
control|)
block|{
name|filename
index|[
name|i
index|]
operator|=
name|mapOutputFile
operator|.
name|getSpillFile
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|finalOutFileSize
operator|+=
name|rfs
operator|.
name|getFileStatus
argument_list|(
name|filename
index|[
name|i
index|]
argument_list|)
operator|.
name|getLen
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|numSpills
operator|==
literal|1
condition|)
block|{
comment|//the spill is the final output
name|sameVolRename
argument_list|(
name|filename
index|[
literal|0
index|]
argument_list|,
name|mapOutputFile
operator|.
name|getOutputFileForWriteInVolume
argument_list|(
name|filename
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexCacheList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|sameVolRename
argument_list|(
name|mapOutputFile
operator|.
name|getSpillIndexFile
argument_list|(
literal|0
argument_list|)
argument_list|,
name|mapOutputFile
operator|.
name|getOutputIndexFileForWriteInVolume
argument_list|(
name|filename
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexCacheList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|writeToFile
argument_list|(
name|mapOutputFile
operator|.
name|getOutputIndexFileForWriteInVolume
argument_list|(
name|filename
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|job
argument_list|)
expr_stmt|;
block|}
name|sortPhase
operator|.
name|complete
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// read in paged indices
for|for
control|(
name|int
name|i
init|=
name|indexCacheList
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|numSpills
condition|;
operator|++
name|i
control|)
block|{
name|Path
name|indexFileName
init|=
name|mapOutputFile
operator|.
name|getSpillIndexFile
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|indexCacheList
operator|.
name|add
argument_list|(
operator|new
name|SpillRecord
argument_list|(
name|indexFileName
argument_list|,
name|job
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//make correction in the length to include the sequence file header
comment|//lengths for each partition
name|finalOutFileSize
operator|+=
name|partitions
operator|*
name|APPROX_HEADER_LENGTH
expr_stmt|;
name|finalIndexFileSize
operator|=
name|partitions
operator|*
name|MAP_OUTPUT_INDEX_RECORD_LENGTH
expr_stmt|;
name|Path
name|finalOutputFile
init|=
name|mapOutputFile
operator|.
name|getOutputFileForWrite
argument_list|(
name|finalOutFileSize
argument_list|)
decl_stmt|;
name|Path
name|finalIndexFile
init|=
name|mapOutputFile
operator|.
name|getOutputIndexFileForWrite
argument_list|(
name|finalIndexFileSize
argument_list|)
decl_stmt|;
comment|//The output stream for the final single output file
name|FSDataOutputStream
name|finalOut
init|=
name|rfs
operator|.
name|create
argument_list|(
name|finalOutputFile
argument_list|,
literal|true
argument_list|,
literal|4096
argument_list|)
decl_stmt|;
if|if
condition|(
name|numSpills
operator|==
literal|0
condition|)
block|{
comment|//create dummy files
name|IndexRecord
name|rec
init|=
operator|new
name|IndexRecord
argument_list|()
decl_stmt|;
name|SpillRecord
name|sr
init|=
operator|new
name|SpillRecord
argument_list|(
name|partitions
argument_list|)
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|partitions
condition|;
name|i
operator|++
control|)
block|{
name|long
name|segmentStart
init|=
name|finalOut
operator|.
name|getPos
argument_list|()
decl_stmt|;
name|FSDataOutputStream
name|finalPartitionOut
init|=
name|CryptoUtils
operator|.
name|wrapIfNecessary
argument_list|(
name|job
argument_list|,
name|finalOut
argument_list|)
decl_stmt|;
name|Writer
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|writer
init|=
operator|new
name|Writer
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|job
argument_list|,
name|finalPartitionOut
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|codec
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
name|rec
operator|.
name|startOffset
operator|=
name|segmentStart
expr_stmt|;
name|rec
operator|.
name|rawLength
operator|=
name|writer
operator|.
name|getRawLength
argument_list|()
operator|+
name|CryptoUtils
operator|.
name|cryptoPadding
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|rec
operator|.
name|partLength
operator|=
name|writer
operator|.
name|getCompressedLength
argument_list|()
operator|+
name|CryptoUtils
operator|.
name|cryptoPadding
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|sr
operator|.
name|putIndex
argument_list|(
name|rec
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|sr
operator|.
name|writeToFile
argument_list|(
name|finalIndexFile
argument_list|,
name|job
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|finalOut
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|sortPhase
operator|.
name|complete
argument_list|()
expr_stmt|;
return|return;
block|}
block|{
name|sortPhase
operator|.
name|addPhases
argument_list|(
name|partitions
argument_list|)
expr_stmt|;
comment|// Divide sort phase into sub-phases
name|IndexRecord
name|rec
init|=
operator|new
name|IndexRecord
argument_list|()
decl_stmt|;
specifier|final
name|SpillRecord
name|spillRec
init|=
operator|new
name|SpillRecord
argument_list|(
name|partitions
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|parts
init|=
literal|0
init|;
name|parts
operator|<
name|partitions
condition|;
name|parts
operator|++
control|)
block|{
comment|//create the segments to be merged
name|List
argument_list|<
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|segmentList
init|=
operator|new
name|ArrayList
argument_list|<
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|(
name|numSpills
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSpills
condition|;
name|i
operator|++
control|)
block|{
name|IndexRecord
name|indexRecord
init|=
name|indexCacheList
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|getIndex
argument_list|(
name|parts
argument_list|)
decl_stmt|;
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
init|=
operator|new
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|job
argument_list|,
name|rfs
argument_list|,
name|filename
index|[
name|i
index|]
argument_list|,
name|indexRecord
operator|.
name|startOffset
argument_list|,
name|indexRecord
operator|.
name|partLength
argument_list|,
name|codec
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|segmentList
operator|.
name|add
argument_list|(
name|i
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"MapId="
operator|+
name|mapId
operator|+
literal|" Reducer="
operator|+
name|parts
operator|+
literal|"Spill ="
operator|+
name|i
operator|+
literal|"("
operator|+
name|indexRecord
operator|.
name|startOffset
operator|+
literal|","
operator|+
name|indexRecord
operator|.
name|rawLength
operator|+
literal|", "
operator|+
name|indexRecord
operator|.
name|partLength
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|mergeFactor
init|=
name|job
operator|.
name|getInt
argument_list|(
name|JobContext
operator|.
name|IO_SORT_FACTOR
argument_list|,
literal|100
argument_list|)
decl_stmt|;
comment|// sort the segments only if there are intermediate merges
name|boolean
name|sortSegments
init|=
name|segmentList
operator|.
name|size
argument_list|()
operator|>
name|mergeFactor
decl_stmt|;
comment|//merge
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|RawKeyValueIterator
name|kvIter
init|=
name|Merger
operator|.
name|merge
argument_list|(
name|job
argument_list|,
name|rfs
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|codec
argument_list|,
name|segmentList
argument_list|,
name|mergeFactor
argument_list|,
operator|new
name|Path
argument_list|(
name|mapId
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|job
operator|.
name|getOutputKeyComparator
argument_list|()
argument_list|,
name|reporter
argument_list|,
name|sortSegments
argument_list|,
literal|null
argument_list|,
name|spilledRecordsCounter
argument_list|,
name|sortPhase
operator|.
name|phase
argument_list|()
argument_list|,
name|TaskType
operator|.
name|MAP
argument_list|)
decl_stmt|;
comment|//write merged output to disk
name|long
name|segmentStart
init|=
name|finalOut
operator|.
name|getPos
argument_list|()
decl_stmt|;
name|FSDataOutputStream
name|finalPartitionOut
init|=
name|CryptoUtils
operator|.
name|wrapIfNecessary
argument_list|(
name|job
argument_list|,
name|finalOut
argument_list|)
decl_stmt|;
name|Writer
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|writer
init|=
operator|new
name|Writer
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|job
argument_list|,
name|finalPartitionOut
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|codec
argument_list|,
name|spilledRecordsCounter
argument_list|)
decl_stmt|;
if|if
condition|(
name|combinerRunner
operator|==
literal|null
operator|||
name|numSpills
operator|<
name|minSpillsForCombine
condition|)
block|{
name|Merger
operator|.
name|writeFile
argument_list|(
name|kvIter
argument_list|,
name|writer
argument_list|,
name|reporter
argument_list|,
name|job
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|combineCollector
operator|.
name|setWriter
argument_list|(
name|writer
argument_list|)
expr_stmt|;
name|combinerRunner
operator|.
name|combine
argument_list|(
name|kvIter
argument_list|,
name|combineCollector
argument_list|)
expr_stmt|;
block|}
comment|//close
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
name|sortPhase
operator|.
name|startNextPhase
argument_list|()
expr_stmt|;
comment|// record offsets
name|rec
operator|.
name|startOffset
operator|=
name|segmentStart
expr_stmt|;
name|rec
operator|.
name|rawLength
operator|=
name|writer
operator|.
name|getRawLength
argument_list|()
operator|+
name|CryptoUtils
operator|.
name|cryptoPadding
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|rec
operator|.
name|partLength
operator|=
name|writer
operator|.
name|getCompressedLength
argument_list|()
operator|+
name|CryptoUtils
operator|.
name|cryptoPadding
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|spillRec
operator|.
name|putIndex
argument_list|(
name|rec
argument_list|,
name|parts
argument_list|)
expr_stmt|;
block|}
name|spillRec
operator|.
name|writeToFile
argument_list|(
name|finalIndexFile
argument_list|,
name|job
argument_list|)
expr_stmt|;
name|finalOut
operator|.
name|close
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numSpills
condition|;
name|i
operator|++
control|)
block|{
name|rfs
operator|.
name|delete
argument_list|(
name|filename
index|[
name|i
index|]
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Rename srcPath to dstPath on the same volume. This is the same      * as RawLocalFileSystem's rename method, except that it will not      * fall back to a copy, and it will create the target directory      * if it doesn't exist.      */
DECL|method|sameVolRename (Path srcPath, Path dstPath)
specifier|private
name|void
name|sameVolRename
parameter_list|(
name|Path
name|srcPath
parameter_list|,
name|Path
name|dstPath
parameter_list|)
throws|throws
name|IOException
block|{
name|RawLocalFileSystem
name|rfs
init|=
operator|(
name|RawLocalFileSystem
operator|)
name|this
operator|.
name|rfs
decl_stmt|;
name|File
name|src
init|=
name|rfs
operator|.
name|pathToFile
argument_list|(
name|srcPath
argument_list|)
decl_stmt|;
name|File
name|dst
init|=
name|rfs
operator|.
name|pathToFile
argument_list|(
name|dstPath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dst
operator|.
name|getParentFile
argument_list|()
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|dst
operator|.
name|getParentFile
argument_list|()
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
operator|+
literal|": couldn't create parent directory"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|src
operator|.
name|renameTo
argument_list|(
name|dst
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to rename "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
argument_list|)
throw|;
block|}
block|}
block|}
comment|// MapOutputBuffer
comment|/**    * Exception indicating that the allocated sort buffer is insufficient    * to hold the current record.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|MapBufferTooSmallException
specifier|private
specifier|static
class|class
name|MapBufferTooSmallException
extends|extends
name|IOException
block|{
DECL|method|MapBufferTooSmallException (String s)
specifier|public
name|MapBufferTooSmallException
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|super
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
parameter_list|<
name|INKEY
parameter_list|,
name|INVALUE
parameter_list|,
name|OUTKEY
parameter_list|,
name|OUTVALUE
parameter_list|>
DECL|method|closeQuietly (RecordReader<INKEY, INVALUE> c)
name|void
name|closeQuietly
parameter_list|(
name|RecordReader
argument_list|<
name|INKEY
argument_list|,
name|INVALUE
argument_list|>
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|c
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
comment|// Ignore
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignoring exception during close for "
operator|+
name|c
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
parameter_list|<
name|OUTKEY
parameter_list|,
name|OUTVALUE
parameter_list|>
DECL|method|closeQuietly (MapOutputCollector<OUTKEY, OUTVALUE> c)
name|void
name|closeQuietly
parameter_list|(
name|MapOutputCollector
argument_list|<
name|OUTKEY
argument_list|,
name|OUTVALUE
argument_list|>
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|c
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ie
parameter_list|)
block|{
comment|// Ignore
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignoring exception during close for "
operator|+
name|c
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
parameter_list|<
name|INKEY
parameter_list|,
name|INVALUE
parameter_list|,
name|OUTKEY
parameter_list|,
name|OUTVALUE
parameter_list|>
DECL|method|closeQuietly ( org.apache.hadoop.mapreduce.RecordReader<INKEY, INVALUE> c)
name|void
name|closeQuietly
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|RecordReader
argument_list|<
name|INKEY
argument_list|,
name|INVALUE
argument_list|>
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|c
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ie
parameter_list|)
block|{
comment|// Ignore
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignoring exception during close for "
operator|+
name|c
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|private
parameter_list|<
name|INKEY
parameter_list|,
name|INVALUE
parameter_list|,
name|OUTKEY
parameter_list|,
name|OUTVALUE
parameter_list|>
DECL|method|closeQuietly ( org.apache.hadoop.mapreduce.RecordWriter<OUTKEY, OUTVALUE> c, org.apache.hadoop.mapreduce.Mapper<INKEY,INVALUE,OUTKEY,OUTVALUE>.Context mapperContext)
name|void
name|closeQuietly
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|RecordWriter
argument_list|<
name|OUTKEY
argument_list|,
name|OUTVALUE
argument_list|>
name|c
parameter_list|,
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Mapper
argument_list|<
name|INKEY
argument_list|,
name|INVALUE
argument_list|,
name|OUTKEY
argument_list|,
name|OUTVALUE
argument_list|>
operator|.
name|Context
name|mapperContext
parameter_list|)
block|{
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|c
operator|.
name|close
argument_list|(
name|mapperContext
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ie
parameter_list|)
block|{
comment|// Ignore
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignoring exception during close for "
operator|+
name|c
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

