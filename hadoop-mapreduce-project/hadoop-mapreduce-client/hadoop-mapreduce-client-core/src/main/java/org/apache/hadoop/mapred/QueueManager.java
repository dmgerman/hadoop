begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|QueueState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|AccessControlList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|JsonFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|JsonGenerationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|JsonGenerator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_comment
comment|/**  * Class that exposes information about queues maintained by the Hadoop  * Map/Reduce framework.  *<p/>  * The Map/Reduce framework can be configured with one or more queues,  * depending on the scheduler it is configured with. While some  * schedulers work only with one queue, some schedulers support multiple  * queues. Some schedulers also support the notion of queues within  * queues - a feature called hierarchical queues.  *<p/>  * Queue names are unique, and used as a key to lookup queues. Hierarchical  * queues are named by a 'fully qualified name' such as q1:q2:q3, where  * q2 is a child queue of q1 and q3 is a child queue of q2.  *<p/>  * Leaf level queues are queues that contain no queues within them. Jobs  * can be submitted only to leaf level queues.  *<p/>  * Queues can be configured with various properties. Some of these  * properties are common to all schedulers, and those are handled by this  * class. Schedulers might also associate several custom properties with  * queues. These properties are parsed and maintained per queue by the  * framework. If schedulers need more complicated structure to maintain  * configuration per queue, they are free to not use the facilities  * provided by the framework, but define their own mechanisms. In such cases,  * it is likely that the name of the queue will be used to relate the  * common properties of a queue with scheduler specific properties.  *<p/>  * Information related to a queue, such as its name, properties, scheduling  * information and children are exposed by this class via a serializable  * class called {@link JobQueueInfo}.  *<p/>  * Queues are configured in the configuration file mapred-queues.xml.  * To support backwards compatibility, queues can also be configured  * in mapred-site.xml. However, when configured in the latter, there is  * no support for hierarchical queues.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|QueueManager
specifier|public
class|class
name|QueueManager
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|QueueManager
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Map of a queue name and Queue object
DECL|field|leafQueues
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Queue
argument_list|>
name|leafQueues
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Queue
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|allQueues
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Queue
argument_list|>
name|allQueues
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Queue
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|QUEUE_CONF_FILE_NAME
specifier|public
specifier|static
specifier|final
name|String
name|QUEUE_CONF_FILE_NAME
init|=
literal|"mapred-queues.xml"
decl_stmt|;
DECL|field|QUEUE_CONF_DEFAULT_FILE_NAME
specifier|static
specifier|final
name|String
name|QUEUE_CONF_DEFAULT_FILE_NAME
init|=
literal|"mapred-queues-default.xml"
decl_stmt|;
comment|//Prefix in configuration for queue related keys
DECL|field|QUEUE_CONF_PROPERTY_NAME_PREFIX
specifier|static
specifier|final
name|String
name|QUEUE_CONF_PROPERTY_NAME_PREFIX
init|=
literal|"mapred.queue."
decl_stmt|;
comment|//Resource in which queue acls are configured.
DECL|field|root
specifier|private
name|Queue
name|root
init|=
literal|null
decl_stmt|;
comment|// represents if job and queue acls are enabled on the mapreduce cluster
DECL|field|areAclsEnabled
specifier|private
name|boolean
name|areAclsEnabled
init|=
literal|false
decl_stmt|;
comment|/**    * Factory method to create an appropriate instance of a queue    * configuration parser.    *<p/>    * Returns a parser that can parse either the deprecated property    * style queue configuration in mapred-site.xml, or one that can    * parse hierarchical queues in mapred-queues.xml. First preference    * is given to configuration in mapred-site.xml. If no queue    * configuration is found there, then a parser that can parse    * configuration in mapred-queues.xml is created.    *    * @param conf Configuration instance that determines which parser    *             to use.    * @return Queue configuration parser    */
DECL|method|getQueueConfigurationParser ( Configuration conf, boolean reloadConf, boolean areAclsEnabled)
specifier|static
name|QueueConfigurationParser
name|getQueueConfigurationParser
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|reloadConf
parameter_list|,
name|boolean
name|areAclsEnabled
parameter_list|)
block|{
if|if
condition|(
name|conf
operator|!=
literal|null
operator|&&
name|conf
operator|.
name|get
argument_list|(
name|DeprecatedQueueConfigurationParser
operator|.
name|MAPRED_QUEUE_NAMES_KEY
argument_list|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|reloadConf
condition|)
block|{
name|conf
operator|.
name|reloadConfiguration
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|DeprecatedQueueConfigurationParser
argument_list|(
name|conf
argument_list|)
return|;
block|}
else|else
block|{
name|URL
name|xmlInUrl
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getContextClassLoader
argument_list|()
operator|.
name|getResource
argument_list|(
name|QUEUE_CONF_FILE_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|xmlInUrl
operator|==
literal|null
condition|)
block|{
name|xmlInUrl
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getContextClassLoader
argument_list|()
operator|.
name|getResource
argument_list|(
name|QUEUE_CONF_DEFAULT_FILE_NAME
argument_list|)
expr_stmt|;
assert|assert
name|xmlInUrl
operator|!=
literal|null
assert|;
comment|// this should be in our jar
block|}
name|InputStream
name|stream
init|=
literal|null
decl_stmt|;
try|try
block|{
name|stream
operator|=
name|xmlInUrl
operator|.
name|openStream
argument_list|()
expr_stmt|;
return|return
operator|new
name|QueueConfigurationParser
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
name|stream
argument_list|)
argument_list|,
name|areAclsEnabled
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Couldn't open queue configuration at "
operator|+
name|xmlInUrl
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|QueueManager ()
name|QueueManager
parameter_list|()
block|{
comment|// acls are disabled
name|this
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|QueueManager (boolean areAclsEnabled)
name|QueueManager
parameter_list|(
name|boolean
name|areAclsEnabled
parameter_list|)
block|{
name|this
operator|.
name|areAclsEnabled
operator|=
name|areAclsEnabled
expr_stmt|;
name|initialize
argument_list|(
name|getQueueConfigurationParser
argument_list|(
literal|null
argument_list|,
literal|false
argument_list|,
name|areAclsEnabled
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct a new QueueManager using configuration specified in the passed    * in {@link org.apache.hadoop.conf.Configuration} object.    *<p/>    * This instance supports queue configuration specified in mapred-site.xml,    * but without support for hierarchical queues. If no queue configuration    * is found in mapred-site.xml, it will then look for site configuration    * in mapred-queues.xml supporting hierarchical queues.    *    * @param clusterConf    mapreduce cluster configuration    */
DECL|method|QueueManager (Configuration clusterConf)
specifier|public
name|QueueManager
parameter_list|(
name|Configuration
name|clusterConf
parameter_list|)
block|{
name|areAclsEnabled
operator|=
name|clusterConf
operator|.
name|getBoolean
argument_list|(
name|MRConfig
operator|.
name|MR_ACLS_ENABLED
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|initialize
argument_list|(
name|getQueueConfigurationParser
argument_list|(
name|clusterConf
argument_list|,
literal|false
argument_list|,
name|areAclsEnabled
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create an instance that supports hierarchical queues, defined in    * the passed in configuration file.    *<p/>    * This is mainly used for testing purposes and should not called from    * production code.    *    * @param confFile File where the queue configuration is found.    */
DECL|method|QueueManager (String confFile, boolean areAclsEnabled)
name|QueueManager
parameter_list|(
name|String
name|confFile
parameter_list|,
name|boolean
name|areAclsEnabled
parameter_list|)
block|{
name|this
operator|.
name|areAclsEnabled
operator|=
name|areAclsEnabled
expr_stmt|;
name|QueueConfigurationParser
name|cp
init|=
operator|new
name|QueueConfigurationParser
argument_list|(
name|confFile
argument_list|,
name|areAclsEnabled
argument_list|)
decl_stmt|;
name|initialize
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/**    * Initialize the queue-manager with the queue hierarchy specified by the    * given {@link QueueConfigurationParser}.    *     * @param cp    */
DECL|method|initialize (QueueConfigurationParser cp)
specifier|private
name|void
name|initialize
parameter_list|(
name|QueueConfigurationParser
name|cp
parameter_list|)
block|{
name|this
operator|.
name|root
operator|=
name|cp
operator|.
name|getRoot
argument_list|()
expr_stmt|;
name|leafQueues
operator|.
name|clear
argument_list|()
expr_stmt|;
name|allQueues
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|//At this point we have root populated
comment|//update data structures leafNodes.
name|leafQueues
operator|=
name|getRoot
argument_list|()
operator|.
name|getLeafQueues
argument_list|()
expr_stmt|;
name|allQueues
operator|.
name|putAll
argument_list|(
name|getRoot
argument_list|()
operator|.
name|getInnerQueues
argument_list|()
argument_list|)
expr_stmt|;
name|allQueues
operator|.
name|putAll
argument_list|(
name|leafQueues
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"AllQueues : "
operator|+
name|allQueues
operator|+
literal|"; LeafQueues : "
operator|+
name|leafQueues
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return the set of leaf level queues configured in the system to    * which jobs are submitted.    *<p/>    * The number of queues configured should be dependent on the Scheduler    * configured. Note that some schedulers work with only one queue, whereas    * others can support multiple queues.    *    * @return Set of queue names.    */
DECL|method|getLeafQueueNames ()
specifier|public
specifier|synchronized
name|Set
argument_list|<
name|String
argument_list|>
name|getLeafQueueNames
parameter_list|()
block|{
return|return
name|leafQueues
operator|.
name|keySet
argument_list|()
return|;
block|}
comment|/**    * Return true if the given user is part of the ACL for the given    * {@link QueueACL} name for the given queue.    *<p/>    * An operation is allowed if all users are provided access for this    * operation, or if either the user or any of the groups specified is    * provided access.    *    * @param queueName Queue on which the operation needs to be performed.    * @param qACL      The queue ACL name to be checked    * @param ugi       The user and groups who wish to perform the operation.    * @return true     if the operation is allowed, false otherwise.    */
DECL|method|hasAccess ( String queueName, QueueACL qACL, UserGroupInformation ugi)
specifier|public
specifier|synchronized
name|boolean
name|hasAccess
parameter_list|(
name|String
name|queueName
parameter_list|,
name|QueueACL
name|qACL
parameter_list|,
name|UserGroupInformation
name|ugi
parameter_list|)
block|{
name|Queue
name|q
init|=
name|leafQueues
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Queue "
operator|+
name|queueName
operator|+
literal|" is not present"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|q
operator|.
name|getChildren
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|q
operator|.
name|getChildren
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cannot submit job to parent queue "
operator|+
name|q
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|areAclsEnabled
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Checking access for the acl "
operator|+
name|toFullPropertyName
argument_list|(
name|queueName
argument_list|,
name|qACL
operator|.
name|getAclName
argument_list|()
argument_list|)
operator|+
literal|" for user "
operator|+
name|ugi
operator|.
name|getShortUserName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|AccessControlList
name|acl
init|=
name|q
operator|.
name|getAcls
argument_list|()
operator|.
name|get
argument_list|(
name|toFullPropertyName
argument_list|(
name|queueName
argument_list|,
name|qACL
operator|.
name|getAclName
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|acl
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// Check if user is part of the ACL
return|return
name|acl
operator|.
name|isUserAllowed
argument_list|(
name|ugi
argument_list|)
return|;
block|}
comment|/**    * Checks whether the given queue is running or not.    *    * @param queueName name of the queue    * @return true, if the queue is running.    */
DECL|method|isRunning (String queueName)
specifier|synchronized
name|boolean
name|isRunning
parameter_list|(
name|String
name|queueName
parameter_list|)
block|{
name|Queue
name|q
init|=
name|leafQueues
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
return|return
name|q
operator|.
name|getState
argument_list|()
operator|.
name|equals
argument_list|(
name|QueueState
operator|.
name|RUNNING
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Set a generic Object that represents scheduling information relevant    * to a queue.    *<p/>    * A string representation of this Object will be used by the framework    * to display in user facing applications like the JobTracker web UI and    * the hadoop CLI.    *    * @param queueName queue for which the scheduling information is to be set.    * @param queueInfo scheduling information for this queue.    */
DECL|method|setSchedulerInfo ( String queueName, Object queueInfo)
specifier|public
specifier|synchronized
name|void
name|setSchedulerInfo
parameter_list|(
name|String
name|queueName
parameter_list|,
name|Object
name|queueInfo
parameter_list|)
block|{
if|if
condition|(
name|allQueues
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|allQueues
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
operator|.
name|setSchedulingInfo
argument_list|(
name|queueInfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Return the scheduler information configured for this queue.    *    * @param queueName queue for which the scheduling information is required.    * @return The scheduling information for this queue.    */
DECL|method|getSchedulerInfo (String queueName)
specifier|public
specifier|synchronized
name|Object
name|getSchedulerInfo
parameter_list|(
name|String
name|queueName
parameter_list|)
block|{
if|if
condition|(
name|allQueues
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return
name|allQueues
operator|.
name|get
argument_list|(
name|queueName
argument_list|)
operator|.
name|getSchedulingInfo
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|field|MSG_REFRESH_FAILURE_WITH_CHANGE_OF_HIERARCHY
specifier|static
specifier|final
name|String
name|MSG_REFRESH_FAILURE_WITH_CHANGE_OF_HIERARCHY
init|=
literal|"Unable to refresh queues because queue-hierarchy changed. "
operator|+
literal|"Retaining existing configuration. "
decl_stmt|;
DECL|field|MSG_REFRESH_FAILURE_WITH_SCHEDULER_FAILURE
specifier|static
specifier|final
name|String
name|MSG_REFRESH_FAILURE_WITH_SCHEDULER_FAILURE
init|=
literal|"Scheduler couldn't refresh it's queues with the new"
operator|+
literal|" configuration properties. "
operator|+
literal|"Retaining existing configuration throughout the system."
decl_stmt|;
comment|/**    * Refresh acls, state and scheduler properties for the configured queues.    *<p/>    * This method reloads configuration related to queues, but does not    * support changes to the list of queues or hierarchy. The expected usage    * is that an administrator can modify the queue configuration file and    * fire an admin command to reload queue configuration. If there is a    * problem in reloading configuration, then this method guarantees that    * existing queue configuration is untouched and in a consistent state.    *     * @param schedulerRefresher    * @throws IOException when queue configuration file is invalid.    */
DECL|method|refreshQueues (Configuration conf, QueueRefresher schedulerRefresher)
specifier|synchronized
name|void
name|refreshQueues
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|QueueRefresher
name|schedulerRefresher
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Create a new configuration parser using the passed conf object.
name|QueueConfigurationParser
name|cp
init|=
name|getQueueConfigurationParser
argument_list|(
name|conf
argument_list|,
literal|true
argument_list|,
name|areAclsEnabled
argument_list|)
decl_stmt|;
comment|/*      * (1) Validate the refresh of properties owned by QueueManager. As of now,      * while refreshing queue properties, we only check that the hierarchy is      * the same w.r.t queue names, ACLs and state for each queue and don't      * support adding new queues or removing old queues      */
if|if
condition|(
operator|!
name|root
operator|.
name|isHierarchySameAs
argument_list|(
name|cp
operator|.
name|getRoot
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|MSG_REFRESH_FAILURE_WITH_CHANGE_OF_HIERARCHY
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|MSG_REFRESH_FAILURE_WITH_CHANGE_OF_HIERARCHY
argument_list|)
throw|;
block|}
comment|/*      * (2) QueueManager owned properties are validated. Now validate and      * refresh the properties of scheduler in a single step.      */
if|if
condition|(
name|schedulerRefresher
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|schedulerRefresher
operator|.
name|refreshQueues
argument_list|(
name|cp
operator|.
name|getRoot
argument_list|()
operator|.
name|getJobQueueInfo
argument_list|()
operator|.
name|getChildren
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|StringBuilder
name|msg
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"Scheduler's refresh-queues failed with the exception : "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
decl_stmt|;
name|msg
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|msg
operator|.
name|append
argument_list|(
name|MSG_REFRESH_FAILURE_WITH_SCHEDULER_FAILURE
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|msg
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|msg
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/*      * (3) Scheduler has validated and refreshed its queues successfully, now      * refresh the properties owned by QueueManager      */
comment|// First copy the scheduling information recursively into the new
comment|// queue-hierarchy. This is done to retain old scheduling information. This
comment|// is done after scheduler refresh and not before it because during refresh,
comment|// schedulers may wish to change their scheduling info objects too.
name|cp
operator|.
name|getRoot
argument_list|()
operator|.
name|copySchedulingInfo
argument_list|(
name|this
operator|.
name|root
argument_list|)
expr_stmt|;
comment|// Now switch roots.
name|initialize
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Queue configuration is refreshed successfully."
argument_list|)
expr_stmt|;
block|}
comment|// this method is for internal use only
DECL|method|toFullPropertyName ( String queue, String property)
specifier|public
specifier|static
specifier|final
name|String
name|toFullPropertyName
parameter_list|(
name|String
name|queue
parameter_list|,
name|String
name|property
parameter_list|)
block|{
return|return
name|QUEUE_CONF_PROPERTY_NAME_PREFIX
operator|+
name|queue
operator|+
literal|"."
operator|+
name|property
return|;
block|}
comment|/**    * Return an array of {@link JobQueueInfo} objects for all the    * queues configurated in the system.    *    * @return array of JobQueueInfo objects.    */
DECL|method|getJobQueueInfos ()
specifier|synchronized
name|JobQueueInfo
index|[]
name|getJobQueueInfos
parameter_list|()
block|{
name|ArrayList
argument_list|<
name|JobQueueInfo
argument_list|>
name|queueInfoList
init|=
operator|new
name|ArrayList
argument_list|<
name|JobQueueInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|queue
range|:
name|allQueues
operator|.
name|keySet
argument_list|()
control|)
block|{
name|JobQueueInfo
name|queueInfo
init|=
name|getJobQueueInfo
argument_list|(
name|queue
argument_list|)
decl_stmt|;
if|if
condition|(
name|queueInfo
operator|!=
literal|null
condition|)
block|{
name|queueInfoList
operator|.
name|add
argument_list|(
name|queueInfo
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|queueInfoList
operator|.
name|toArray
argument_list|(
operator|new
name|JobQueueInfo
index|[
name|queueInfoList
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * Return {@link JobQueueInfo} for a given queue.    *    * @param queue name of the queue    * @return JobQueueInfo for the queue, null if the queue is not found.    */
DECL|method|getJobQueueInfo (String queue)
specifier|synchronized
name|JobQueueInfo
name|getJobQueueInfo
parameter_list|(
name|String
name|queue
parameter_list|)
block|{
if|if
condition|(
name|allQueues
operator|.
name|containsKey
argument_list|(
name|queue
argument_list|)
condition|)
block|{
return|return
name|allQueues
operator|.
name|get
argument_list|(
name|queue
argument_list|)
operator|.
name|getJobQueueInfo
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * JobQueueInfo for all the queues.    *<p/>    * Contribs can use this data structure to either create a hierarchy or for    * traversing.    * They can also use this to refresh properties in case of refreshQueues    *    * @return a map for easy navigation.    */
DECL|method|getJobQueueInfoMapping ()
specifier|synchronized
name|Map
argument_list|<
name|String
argument_list|,
name|JobQueueInfo
argument_list|>
name|getJobQueueInfoMapping
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|JobQueueInfo
argument_list|>
name|m
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|JobQueueInfo
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Queue
argument_list|>
name|entry
range|:
name|allQueues
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|m
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getJobQueueInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
comment|/**    * Generates the array of QueueAclsInfo object.    *<p/>    * The array consists of only those queues for which user has acls.    *    * @return QueueAclsInfo[]    * @throws java.io.IOException    */
DECL|method|getQueueAcls (UserGroupInformation ugi)
specifier|synchronized
name|QueueAclsInfo
index|[]
name|getQueueAcls
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|)
throws|throws
name|IOException
block|{
comment|//List of all QueueAclsInfo objects , this list is returned
name|ArrayList
argument_list|<
name|QueueAclsInfo
argument_list|>
name|queueAclsInfolist
init|=
operator|new
name|ArrayList
argument_list|<
name|QueueAclsInfo
argument_list|>
argument_list|()
decl_stmt|;
name|QueueACL
index|[]
name|qAcls
init|=
name|QueueACL
operator|.
name|values
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|queueName
range|:
name|leafQueues
operator|.
name|keySet
argument_list|()
control|)
block|{
name|QueueAclsInfo
name|queueAclsInfo
init|=
literal|null
decl_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|operationsAllowed
init|=
literal|null
decl_stmt|;
for|for
control|(
name|QueueACL
name|qAcl
range|:
name|qAcls
control|)
block|{
if|if
condition|(
name|hasAccess
argument_list|(
name|queueName
argument_list|,
name|qAcl
argument_list|,
name|ugi
argument_list|)
condition|)
block|{
if|if
condition|(
name|operationsAllowed
operator|==
literal|null
condition|)
block|{
name|operationsAllowed
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|operationsAllowed
operator|.
name|add
argument_list|(
name|qAcl
operator|.
name|getAclName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|operationsAllowed
operator|!=
literal|null
condition|)
block|{
comment|//There is atleast 1 operation supported for queue<queueName>
comment|//, hence initialize queueAclsInfo
name|queueAclsInfo
operator|=
operator|new
name|QueueAclsInfo
argument_list|(
name|queueName
argument_list|,
name|operationsAllowed
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|operationsAllowed
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|queueAclsInfolist
operator|.
name|add
argument_list|(
name|queueAclsInfo
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|queueAclsInfolist
operator|.
name|toArray
argument_list|(
operator|new
name|QueueAclsInfo
index|[
name|queueAclsInfolist
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * Return if ACLs are enabled for the Map/Reduce system    *    * @return true if ACLs are enabled.    */
DECL|method|areAclsEnabled ()
name|boolean
name|areAclsEnabled
parameter_list|()
block|{
return|return
name|areAclsEnabled
return|;
block|}
comment|/**    * Used only for test.    *    * @return    */
DECL|method|getRoot ()
name|Queue
name|getRoot
parameter_list|()
block|{
return|return
name|root
return|;
block|}
comment|/**    * Dumps the configuration of hierarchy of queues    * @param out the writer object to which dump is written    * @throws IOException    */
DECL|method|dumpConfiguration (Writer out,Configuration conf)
specifier|static
name|void
name|dumpConfiguration
parameter_list|(
name|Writer
name|out
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|dumpConfiguration
argument_list|(
name|out
argument_list|,
literal|null
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/***    * Dumps the configuration of hierarchy of queues with     * the xml file path given. It is to be used directly ONLY FOR TESTING.    * @param out the writer object to which dump is written to.    * @param configFile the filename of xml file    * @throws IOException    */
DECL|method|dumpConfiguration (Writer out, String configFile, Configuration conf)
specifier|static
name|void
name|dumpConfiguration
parameter_list|(
name|Writer
name|out
parameter_list|,
name|String
name|configFile
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|conf
operator|!=
literal|null
operator|&&
name|conf
operator|.
name|get
argument_list|(
name|DeprecatedQueueConfigurationParser
operator|.
name|MAPRED_QUEUE_NAMES_KEY
argument_list|)
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
name|JsonFactory
name|dumpFactory
init|=
operator|new
name|JsonFactory
argument_list|()
decl_stmt|;
name|JsonGenerator
name|dumpGenerator
init|=
name|dumpFactory
operator|.
name|createJsonGenerator
argument_list|(
name|out
argument_list|)
decl_stmt|;
name|QueueConfigurationParser
name|parser
decl_stmt|;
name|boolean
name|aclsEnabled
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|conf
operator|!=
literal|null
condition|)
block|{
name|aclsEnabled
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|MRConfig
operator|.
name|MR_ACLS_ENABLED
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|configFile
operator|!=
literal|null
operator|&&
operator|!
literal|""
operator|.
name|equals
argument_list|(
name|configFile
argument_list|)
condition|)
block|{
name|parser
operator|=
operator|new
name|QueueConfigurationParser
argument_list|(
name|configFile
argument_list|,
name|aclsEnabled
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parser
operator|=
name|getQueueConfigurationParser
argument_list|(
literal|null
argument_list|,
literal|false
argument_list|,
name|aclsEnabled
argument_list|)
expr_stmt|;
block|}
name|dumpGenerator
operator|.
name|writeStartObject
argument_list|()
expr_stmt|;
name|dumpGenerator
operator|.
name|writeFieldName
argument_list|(
literal|"queues"
argument_list|)
expr_stmt|;
name|dumpGenerator
operator|.
name|writeStartArray
argument_list|()
expr_stmt|;
name|dumpConfiguration
argument_list|(
name|dumpGenerator
argument_list|,
name|parser
operator|.
name|getRoot
argument_list|()
operator|.
name|getChildren
argument_list|()
argument_list|)
expr_stmt|;
name|dumpGenerator
operator|.
name|writeEndArray
argument_list|()
expr_stmt|;
name|dumpGenerator
operator|.
name|writeEndObject
argument_list|()
expr_stmt|;
name|dumpGenerator
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**    * method to perform depth-first search and write the parameters of every     * queue in JSON format.    * @param dumpGenerator JsonGenerator object which takes the dump and flushes    *  to a writer object    * @param rootQueues the top-level queues    * @throws JsonGenerationException    * @throws IOException    */
DECL|method|dumpConfiguration (JsonGenerator dumpGenerator, Set<Queue> rootQueues)
specifier|private
specifier|static
name|void
name|dumpConfiguration
parameter_list|(
name|JsonGenerator
name|dumpGenerator
parameter_list|,
name|Set
argument_list|<
name|Queue
argument_list|>
name|rootQueues
parameter_list|)
throws|throws
name|JsonGenerationException
throws|,
name|IOException
block|{
for|for
control|(
name|Queue
name|queue
range|:
name|rootQueues
control|)
block|{
name|dumpGenerator
operator|.
name|writeStartObject
argument_list|()
expr_stmt|;
name|dumpGenerator
operator|.
name|writeStringField
argument_list|(
literal|"name"
argument_list|,
name|queue
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|dumpGenerator
operator|.
name|writeStringField
argument_list|(
literal|"state"
argument_list|,
name|queue
operator|.
name|getState
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|AccessControlList
name|submitJobList
init|=
literal|null
decl_stmt|;
name|AccessControlList
name|administerJobsList
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|queue
operator|.
name|getAcls
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|submitJobList
operator|=
name|queue
operator|.
name|getAcls
argument_list|()
operator|.
name|get
argument_list|(
name|toFullPropertyName
argument_list|(
name|queue
operator|.
name|getName
argument_list|()
argument_list|,
name|QueueACL
operator|.
name|SUBMIT_JOB
operator|.
name|getAclName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|administerJobsList
operator|=
name|queue
operator|.
name|getAcls
argument_list|()
operator|.
name|get
argument_list|(
name|toFullPropertyName
argument_list|(
name|queue
operator|.
name|getName
argument_list|()
argument_list|,
name|QueueACL
operator|.
name|ADMINISTER_JOBS
operator|.
name|getAclName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|String
name|aclsSubmitJobValue
init|=
literal|" "
decl_stmt|;
if|if
condition|(
name|submitJobList
operator|!=
literal|null
condition|)
block|{
name|aclsSubmitJobValue
operator|=
name|submitJobList
operator|.
name|getAclString
argument_list|()
expr_stmt|;
block|}
name|dumpGenerator
operator|.
name|writeStringField
argument_list|(
literal|"acl_submit_job"
argument_list|,
name|aclsSubmitJobValue
argument_list|)
expr_stmt|;
name|String
name|aclsAdministerValue
init|=
literal|" "
decl_stmt|;
if|if
condition|(
name|administerJobsList
operator|!=
literal|null
condition|)
block|{
name|aclsAdministerValue
operator|=
name|administerJobsList
operator|.
name|getAclString
argument_list|()
expr_stmt|;
block|}
name|dumpGenerator
operator|.
name|writeStringField
argument_list|(
literal|"acl_administer_jobs"
argument_list|,
name|aclsAdministerValue
argument_list|)
expr_stmt|;
name|dumpGenerator
operator|.
name|writeFieldName
argument_list|(
literal|"properties"
argument_list|)
expr_stmt|;
name|dumpGenerator
operator|.
name|writeStartArray
argument_list|()
expr_stmt|;
if|if
condition|(
name|queue
operator|.
name|getProperties
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|property
range|:
name|queue
operator|.
name|getProperties
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|dumpGenerator
operator|.
name|writeStartObject
argument_list|()
expr_stmt|;
name|dumpGenerator
operator|.
name|writeStringField
argument_list|(
literal|"key"
argument_list|,
operator|(
name|String
operator|)
name|property
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|dumpGenerator
operator|.
name|writeStringField
argument_list|(
literal|"value"
argument_list|,
operator|(
name|String
operator|)
name|property
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|dumpGenerator
operator|.
name|writeEndObject
argument_list|()
expr_stmt|;
block|}
block|}
name|dumpGenerator
operator|.
name|writeEndArray
argument_list|()
expr_stmt|;
name|Set
argument_list|<
name|Queue
argument_list|>
name|childQueues
init|=
name|queue
operator|.
name|getChildren
argument_list|()
decl_stmt|;
name|dumpGenerator
operator|.
name|writeFieldName
argument_list|(
literal|"children"
argument_list|)
expr_stmt|;
name|dumpGenerator
operator|.
name|writeStartArray
argument_list|()
expr_stmt|;
if|if
condition|(
name|childQueues
operator|!=
literal|null
operator|&&
name|childQueues
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|dumpConfiguration
argument_list|(
name|dumpGenerator
argument_list|,
name|childQueues
argument_list|)
expr_stmt|;
block|}
name|dumpGenerator
operator|.
name|writeEndArray
argument_list|()
expr_stmt|;
name|dumpGenerator
operator|.
name|writeEndObject
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

