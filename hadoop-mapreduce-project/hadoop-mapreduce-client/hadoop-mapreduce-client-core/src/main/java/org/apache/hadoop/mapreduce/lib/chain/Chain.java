begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapreduce.lib.chain
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|chain
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|DefaultStringifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Stringifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|InputSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Job
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MapContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Mapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|RecordReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|RecordWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|ReduceContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Reducer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskInputOutputContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|map
operator|.
name|WrappedMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|lib
operator|.
name|reduce
operator|.
name|WrappedReducer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_comment
comment|/**  * The Chain class provides all the common functionality for the  * {@link ChainMapper} and the {@link ChainReducer} classes.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|Chain
specifier|public
class|class
name|Chain
block|{
DECL|field|CHAIN_MAPPER
specifier|protected
specifier|static
specifier|final
name|String
name|CHAIN_MAPPER
init|=
literal|"mapreduce.chain.mapper"
decl_stmt|;
DECL|field|CHAIN_REDUCER
specifier|protected
specifier|static
specifier|final
name|String
name|CHAIN_REDUCER
init|=
literal|"mapreduce.chain.reducer"
decl_stmt|;
DECL|field|CHAIN_MAPPER_SIZE
specifier|protected
specifier|static
specifier|final
name|String
name|CHAIN_MAPPER_SIZE
init|=
literal|".size"
decl_stmt|;
DECL|field|CHAIN_MAPPER_CLASS
specifier|protected
specifier|static
specifier|final
name|String
name|CHAIN_MAPPER_CLASS
init|=
literal|".mapper.class."
decl_stmt|;
DECL|field|CHAIN_MAPPER_CONFIG
specifier|protected
specifier|static
specifier|final
name|String
name|CHAIN_MAPPER_CONFIG
init|=
literal|".mapper.config."
decl_stmt|;
DECL|field|CHAIN_REDUCER_CLASS
specifier|protected
specifier|static
specifier|final
name|String
name|CHAIN_REDUCER_CLASS
init|=
literal|".reducer.class"
decl_stmt|;
DECL|field|CHAIN_REDUCER_CONFIG
specifier|protected
specifier|static
specifier|final
name|String
name|CHAIN_REDUCER_CONFIG
init|=
literal|".reducer.config"
decl_stmt|;
DECL|field|MAPPER_INPUT_KEY_CLASS
specifier|protected
specifier|static
specifier|final
name|String
name|MAPPER_INPUT_KEY_CLASS
init|=
literal|"mapreduce.chain.mapper.input.key.class"
decl_stmt|;
DECL|field|MAPPER_INPUT_VALUE_CLASS
specifier|protected
specifier|static
specifier|final
name|String
name|MAPPER_INPUT_VALUE_CLASS
init|=
literal|"mapreduce.chain.mapper.input.value.class"
decl_stmt|;
DECL|field|MAPPER_OUTPUT_KEY_CLASS
specifier|protected
specifier|static
specifier|final
name|String
name|MAPPER_OUTPUT_KEY_CLASS
init|=
literal|"mapreduce.chain.mapper.output.key.class"
decl_stmt|;
DECL|field|MAPPER_OUTPUT_VALUE_CLASS
specifier|protected
specifier|static
specifier|final
name|String
name|MAPPER_OUTPUT_VALUE_CLASS
init|=
literal|"mapreduce.chain.mapper.output.value.class"
decl_stmt|;
DECL|field|REDUCER_INPUT_KEY_CLASS
specifier|protected
specifier|static
specifier|final
name|String
name|REDUCER_INPUT_KEY_CLASS
init|=
literal|"mapreduce.chain.reducer.input.key.class"
decl_stmt|;
DECL|field|REDUCER_INPUT_VALUE_CLASS
specifier|protected
specifier|static
specifier|final
name|String
name|REDUCER_INPUT_VALUE_CLASS
init|=
literal|"maperduce.chain.reducer.input.value.class"
decl_stmt|;
DECL|field|REDUCER_OUTPUT_KEY_CLASS
specifier|protected
specifier|static
specifier|final
name|String
name|REDUCER_OUTPUT_KEY_CLASS
init|=
literal|"mapreduce.chain.reducer.output.key.class"
decl_stmt|;
DECL|field|REDUCER_OUTPUT_VALUE_CLASS
specifier|protected
specifier|static
specifier|final
name|String
name|REDUCER_OUTPUT_VALUE_CLASS
init|=
literal|"mapreduce.chain.reducer.output.value.class"
decl_stmt|;
DECL|field|isMap
specifier|protected
name|boolean
name|isMap
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|field|mappers
specifier|private
name|List
argument_list|<
name|Mapper
argument_list|>
name|mappers
init|=
operator|new
name|ArrayList
argument_list|<
name|Mapper
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|reducer
specifier|private
name|Reducer
argument_list|<
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|>
name|reducer
decl_stmt|;
DECL|field|confList
specifier|private
name|List
argument_list|<
name|Configuration
argument_list|>
name|confList
init|=
operator|new
name|ArrayList
argument_list|<
name|Configuration
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|rConf
specifier|private
name|Configuration
name|rConf
decl_stmt|;
DECL|field|threads
specifier|private
name|List
argument_list|<
name|Thread
argument_list|>
name|threads
init|=
operator|new
name|ArrayList
argument_list|<
name|Thread
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|blockingQueues
specifier|private
name|List
argument_list|<
name|ChainBlockingQueue
argument_list|<
name|?
argument_list|>
argument_list|>
name|blockingQueues
init|=
operator|new
name|ArrayList
argument_list|<
name|ChainBlockingQueue
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|throwable
specifier|private
name|Throwable
name|throwable
init|=
literal|null
decl_stmt|;
comment|/**    * Creates a Chain instance configured for a Mapper or a Reducer.    *     * @param isMap    *          TRUE indicates the chain is for a Mapper, FALSE that is for a    *          Reducer.    */
DECL|method|Chain (boolean isMap)
specifier|protected
name|Chain
parameter_list|(
name|boolean
name|isMap
parameter_list|)
block|{
name|this
operator|.
name|isMap
operator|=
name|isMap
expr_stmt|;
block|}
DECL|class|KeyValuePair
specifier|static
class|class
name|KeyValuePair
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
DECL|field|key
name|K
name|key
decl_stmt|;
DECL|field|value
name|V
name|value
decl_stmt|;
DECL|field|endOfInput
name|boolean
name|endOfInput
decl_stmt|;
DECL|method|KeyValuePair (K key, V value)
name|KeyValuePair
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|this
operator|.
name|endOfInput
operator|=
literal|false
expr_stmt|;
block|}
DECL|method|KeyValuePair (boolean eof)
name|KeyValuePair
parameter_list|(
name|boolean
name|eof
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|value
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|endOfInput
operator|=
name|eof
expr_stmt|;
block|}
block|}
comment|// ChainRecordReader either reads from blocking queue or task context.
DECL|class|ChainRecordReader
specifier|private
specifier|static
class|class
name|ChainRecordReader
parameter_list|<
name|KEYIN
parameter_list|,
name|VALUEIN
parameter_list|>
extends|extends
name|RecordReader
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|>
block|{
DECL|field|keyClass
specifier|private
name|Class
argument_list|<
name|?
argument_list|>
name|keyClass
decl_stmt|;
DECL|field|valueClass
specifier|private
name|Class
argument_list|<
name|?
argument_list|>
name|valueClass
decl_stmt|;
DECL|field|key
specifier|private
name|KEYIN
name|key
decl_stmt|;
DECL|field|value
specifier|private
name|VALUEIN
name|value
decl_stmt|;
DECL|field|conf
specifier|private
name|Configuration
name|conf
decl_stmt|;
DECL|field|inputContext
name|TaskInputOutputContext
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|,
name|?
argument_list|,
name|?
argument_list|>
name|inputContext
init|=
literal|null
decl_stmt|;
DECL|field|inputQueue
name|ChainBlockingQueue
argument_list|<
name|KeyValuePair
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|>
argument_list|>
name|inputQueue
init|=
literal|null
decl_stmt|;
comment|// constructor to read from a blocking queue
DECL|method|ChainRecordReader (Class<?> keyClass, Class<?> valueClass, ChainBlockingQueue<KeyValuePair<KEYIN, VALUEIN>> inputQueue, Configuration conf)
name|ChainRecordReader
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|keyClass
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|valueClass
parameter_list|,
name|ChainBlockingQueue
argument_list|<
name|KeyValuePair
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|>
argument_list|>
name|inputQueue
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|keyClass
operator|=
name|keyClass
expr_stmt|;
name|this
operator|.
name|valueClass
operator|=
name|valueClass
expr_stmt|;
name|this
operator|.
name|inputQueue
operator|=
name|inputQueue
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
block|}
comment|// constructor to read from the context
DECL|method|ChainRecordReader (TaskInputOutputContext<KEYIN, VALUEIN, ?, ?> context)
name|ChainRecordReader
parameter_list|(
name|TaskInputOutputContext
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|,
name|?
argument_list|,
name|?
argument_list|>
name|context
parameter_list|)
block|{
name|inputContext
operator|=
name|context
expr_stmt|;
block|}
DECL|method|initialize (InputSplit split, TaskAttemptContext context)
specifier|public
name|void
name|initialize
parameter_list|(
name|InputSplit
name|split
parameter_list|,
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{     }
comment|/**      * Advance to the next key, value pair, returning null if at end.      *       * @return the key object that was read into, or null if no more      */
DECL|method|nextKeyValue ()
specifier|public
name|boolean
name|nextKeyValue
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|inputQueue
operator|!=
literal|null
condition|)
block|{
return|return
name|readFromQueue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|inputContext
operator|.
name|nextKeyValue
argument_list|()
condition|)
block|{
name|this
operator|.
name|key
operator|=
name|inputContext
operator|.
name|getCurrentKey
argument_list|()
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|inputContext
operator|.
name|getCurrentValue
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|readFromQueue ()
specifier|private
name|boolean
name|readFromQueue
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|KeyValuePair
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|>
name|kv
init|=
literal|null
decl_stmt|;
comment|// wait for input on queue
name|kv
operator|=
name|inputQueue
operator|.
name|dequeue
argument_list|()
expr_stmt|;
if|if
condition|(
name|kv
operator|.
name|endOfInput
condition|)
block|{
return|return
literal|false
return|;
block|}
name|key
operator|=
operator|(
name|KEYIN
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|keyClass
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|VALUEIN
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|valueClass
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|ReflectionUtils
operator|.
name|copy
argument_list|(
name|conf
argument_list|,
name|kv
operator|.
name|key
argument_list|,
name|this
operator|.
name|key
argument_list|)
expr_stmt|;
name|ReflectionUtils
operator|.
name|copy
argument_list|(
name|conf
argument_list|,
name|kv
operator|.
name|value
argument_list|,
name|this
operator|.
name|value
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * Get the current key.      *       * @return the current key object or null if there isn't one      * @throws IOException      * @throws InterruptedException      */
DECL|method|getCurrentKey ()
specifier|public
name|KEYIN
name|getCurrentKey
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|this
operator|.
name|key
return|;
block|}
comment|/**      * Get the current value.      *       * @return the value object that was read into      * @throws IOException      * @throws InterruptedException      */
DECL|method|getCurrentValue ()
specifier|public
name|VALUEIN
name|getCurrentValue
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|this
operator|.
name|value
return|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{     }
annotation|@
name|Override
DECL|method|getProgress ()
specifier|public
name|float
name|getProgress
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
literal|0
return|;
block|}
block|}
comment|// ChainRecordWriter either writes to blocking queue or task context
DECL|class|ChainRecordWriter
specifier|private
specifier|static
class|class
name|ChainRecordWriter
parameter_list|<
name|KEYOUT
parameter_list|,
name|VALUEOUT
parameter_list|>
extends|extends
name|RecordWriter
argument_list|<
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
block|{
DECL|field|outputContext
name|TaskInputOutputContext
argument_list|<
name|?
argument_list|,
name|?
argument_list|,
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
name|outputContext
init|=
literal|null
decl_stmt|;
DECL|field|outputQueue
name|ChainBlockingQueue
argument_list|<
name|KeyValuePair
argument_list|<
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
argument_list|>
name|outputQueue
init|=
literal|null
decl_stmt|;
DECL|field|keyout
name|KEYOUT
name|keyout
decl_stmt|;
DECL|field|valueout
name|VALUEOUT
name|valueout
decl_stmt|;
DECL|field|conf
name|Configuration
name|conf
decl_stmt|;
DECL|field|keyClass
name|Class
argument_list|<
name|?
argument_list|>
name|keyClass
decl_stmt|;
DECL|field|valueClass
name|Class
argument_list|<
name|?
argument_list|>
name|valueClass
decl_stmt|;
comment|// constructor to write to context
DECL|method|ChainRecordWriter (TaskInputOutputContext<?, ?, KEYOUT, VALUEOUT> context)
name|ChainRecordWriter
parameter_list|(
name|TaskInputOutputContext
argument_list|<
name|?
argument_list|,
name|?
argument_list|,
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
name|context
parameter_list|)
block|{
name|outputContext
operator|=
name|context
expr_stmt|;
block|}
comment|// constructor to write to blocking queue
DECL|method|ChainRecordWriter (Class<?> keyClass, Class<?> valueClass, ChainBlockingQueue<KeyValuePair<KEYOUT, VALUEOUT>> output, Configuration conf)
name|ChainRecordWriter
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|keyClass
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|valueClass
parameter_list|,
name|ChainBlockingQueue
argument_list|<
name|KeyValuePair
argument_list|<
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
argument_list|>
name|output
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|keyClass
operator|=
name|keyClass
expr_stmt|;
name|this
operator|.
name|valueClass
operator|=
name|valueClass
expr_stmt|;
name|this
operator|.
name|outputQueue
operator|=
name|output
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
block|}
comment|/**      * Writes a key/value pair.      *       * @param key      *          the key to write.      * @param value      *          the value to write.      * @throws IOException      */
DECL|method|write (KEYOUT key, VALUEOUT value)
specifier|public
name|void
name|write
parameter_list|(
name|KEYOUT
name|key
parameter_list|,
name|VALUEOUT
name|value
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|outputQueue
operator|!=
literal|null
condition|)
block|{
name|writeToQueue
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outputContext
operator|.
name|write
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|writeToQueue (KEYOUT key, VALUEOUT value)
specifier|private
name|void
name|writeToQueue
parameter_list|(
name|KEYOUT
name|key
parameter_list|,
name|VALUEOUT
name|value
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|this
operator|.
name|keyout
operator|=
operator|(
name|KEYOUT
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|keyClass
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|valueout
operator|=
operator|(
name|VALUEOUT
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|valueClass
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|ReflectionUtils
operator|.
name|copy
argument_list|(
name|conf
argument_list|,
name|key
argument_list|,
name|this
operator|.
name|keyout
argument_list|)
expr_stmt|;
name|ReflectionUtils
operator|.
name|copy
argument_list|(
name|conf
argument_list|,
name|value
argument_list|,
name|this
operator|.
name|valueout
argument_list|)
expr_stmt|;
comment|// wait to write output to queuue
name|outputQueue
operator|.
name|enqueue
argument_list|(
operator|new
name|KeyValuePair
argument_list|<
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
argument_list|(
name|keyout
argument_list|,
name|valueout
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Close this<code>RecordWriter</code> to future operations.      *       * @param context      *          the context of the task      * @throws IOException      */
DECL|method|close (TaskAttemptContext context)
specifier|public
name|void
name|close
parameter_list|(
name|TaskAttemptContext
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|outputQueue
operator|!=
literal|null
condition|)
block|{
comment|// write end of input
name|outputQueue
operator|.
name|enqueue
argument_list|(
operator|new
name|KeyValuePair
argument_list|<
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getThrowable ()
specifier|private
specifier|synchronized
name|Throwable
name|getThrowable
parameter_list|()
block|{
return|return
name|throwable
return|;
block|}
DECL|method|setIfUnsetThrowable (Throwable th)
specifier|private
specifier|synchronized
name|boolean
name|setIfUnsetThrowable
parameter_list|(
name|Throwable
name|th
parameter_list|)
block|{
if|if
condition|(
name|throwable
operator|==
literal|null
condition|)
block|{
name|throwable
operator|=
name|th
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|class|MapRunner
specifier|private
class|class
name|MapRunner
parameter_list|<
name|KEYIN
parameter_list|,
name|VALUEIN
parameter_list|,
name|KEYOUT
parameter_list|,
name|VALUEOUT
parameter_list|>
extends|extends
name|Thread
block|{
DECL|field|mapper
specifier|private
name|Mapper
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|,
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
name|mapper
decl_stmt|;
specifier|private
name|Mapper
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|,
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
operator|.
name|Context
name|chainContext
decl_stmt|;
DECL|field|rr
specifier|private
name|RecordReader
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|>
name|rr
decl_stmt|;
DECL|field|rw
specifier|private
name|RecordWriter
argument_list|<
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
name|rw
decl_stmt|;
DECL|method|MapRunner (Mapper<KEYIN, VALUEIN, KEYOUT, VALUEOUT> mapper, Mapper<KEYIN, VALUEIN, KEYOUT, VALUEOUT>.Context mapperContext, RecordReader<KEYIN, VALUEIN> rr, RecordWriter<KEYOUT, VALUEOUT> rw)
specifier|public
name|MapRunner
parameter_list|(
name|Mapper
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|,
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
name|mapper
parameter_list|,
name|Mapper
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|,
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
operator|.
name|Context
name|mapperContext
parameter_list|,
name|RecordReader
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|>
name|rr
parameter_list|,
name|RecordWriter
argument_list|<
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
name|rw
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|this
operator|.
name|mapper
operator|=
name|mapper
expr_stmt|;
name|this
operator|.
name|rr
operator|=
name|rr
expr_stmt|;
name|this
operator|.
name|rw
operator|=
name|rw
expr_stmt|;
name|this
operator|.
name|chainContext
operator|=
name|mapperContext
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|getThrowable
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
try|try
block|{
name|mapper
operator|.
name|run
argument_list|(
name|chainContext
argument_list|)
expr_stmt|;
name|rr
operator|.
name|close
argument_list|()
expr_stmt|;
name|rw
operator|.
name|close
argument_list|(
name|chainContext
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|th
parameter_list|)
block|{
if|if
condition|(
name|setIfUnsetThrowable
argument_list|(
name|th
argument_list|)
condition|)
block|{
name|interruptAllThreads
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|class|ReduceRunner
specifier|private
class|class
name|ReduceRunner
parameter_list|<
name|KEYIN
parameter_list|,
name|VALUEIN
parameter_list|,
name|KEYOUT
parameter_list|,
name|VALUEOUT
parameter_list|>
extends|extends
name|Thread
block|{
DECL|field|reducer
specifier|private
name|Reducer
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|,
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
name|reducer
decl_stmt|;
specifier|private
name|Reducer
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|,
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
operator|.
name|Context
name|chainContext
decl_stmt|;
DECL|field|rw
specifier|private
name|RecordWriter
argument_list|<
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
name|rw
decl_stmt|;
DECL|method|ReduceRunner (Reducer<KEYIN, VALUEIN, KEYOUT, VALUEOUT>.Context context, Reducer<KEYIN, VALUEIN, KEYOUT, VALUEOUT> reducer, RecordWriter<KEYOUT, VALUEOUT> rw)
name|ReduceRunner
parameter_list|(
name|Reducer
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|,
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
operator|.
name|Context
name|context
parameter_list|,
name|Reducer
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|,
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
name|reducer
parameter_list|,
name|RecordWriter
argument_list|<
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
name|rw
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
name|this
operator|.
name|chainContext
operator|=
name|context
expr_stmt|;
name|this
operator|.
name|rw
operator|=
name|rw
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|reducer
operator|.
name|run
argument_list|(
name|chainContext
argument_list|)
expr_stmt|;
name|rw
operator|.
name|close
argument_list|(
name|chainContext
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|th
parameter_list|)
block|{
if|if
condition|(
name|setIfUnsetThrowable
argument_list|(
name|th
argument_list|)
condition|)
block|{
name|interruptAllThreads
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|getConf (int index)
name|Configuration
name|getConf
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|confList
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
comment|/**    * Create a map context that is based on ChainMapContext and the given record    * reader and record writer    */
specifier|private
parameter_list|<
name|KEYIN
parameter_list|,
name|VALUEIN
parameter_list|,
name|KEYOUT
parameter_list|,
name|VALUEOUT
parameter_list|>
DECL|method|createMapContext ( RecordReader<KEYIN, VALUEIN> rr, RecordWriter<KEYOUT, VALUEOUT> rw, TaskInputOutputContext<KEYIN, VALUEIN, KEYOUT, VALUEOUT> context, Configuration conf)
name|Mapper
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|,
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
operator|.
name|Context
name|createMapContext
parameter_list|(
name|RecordReader
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|>
name|rr
parameter_list|,
name|RecordWriter
argument_list|<
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
name|rw
parameter_list|,
name|TaskInputOutputContext
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|,
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
name|context
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|MapContext
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|,
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
name|mapContext
init|=
operator|new
name|ChainMapContextImpl
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|,
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
argument_list|(
name|context
argument_list|,
name|rr
argument_list|,
name|rw
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|Mapper
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|,
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
operator|.
name|Context
name|mapperContext
init|=
operator|new
name|WrappedMapper
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|,
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
argument_list|()
operator|.
name|getMapContext
argument_list|(
name|mapContext
argument_list|)
decl_stmt|;
return|return
name|mapperContext
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|runMapper (TaskInputOutputContext context, int index)
name|void
name|runMapper
parameter_list|(
name|TaskInputOutputContext
name|context
parameter_list|,
name|int
name|index
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|Mapper
name|mapper
init|=
name|mappers
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|RecordReader
name|rr
init|=
operator|new
name|ChainRecordReader
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|RecordWriter
name|rw
init|=
operator|new
name|ChainRecordWriter
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|Mapper
operator|.
name|Context
name|mapperContext
init|=
name|createMapContext
argument_list|(
name|rr
argument_list|,
name|rw
argument_list|,
name|context
argument_list|,
name|getConf
argument_list|(
name|index
argument_list|)
argument_list|)
decl_stmt|;
name|mapper
operator|.
name|run
argument_list|(
name|mapperContext
argument_list|)
expr_stmt|;
name|rr
operator|.
name|close
argument_list|()
expr_stmt|;
name|rw
operator|.
name|close
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add mapper(the first mapper) that reads input from the input    * context and writes to queue    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|addMapper (TaskInputOutputContext inputContext, ChainBlockingQueue<KeyValuePair<?, ?>> output, int index)
name|void
name|addMapper
parameter_list|(
name|TaskInputOutputContext
name|inputContext
parameter_list|,
name|ChainBlockingQueue
argument_list|<
name|KeyValuePair
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|output
parameter_list|,
name|int
name|index
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|keyOutClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|MAPPER_OUTPUT_KEY_CLASS
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|valueOutClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|MAPPER_OUTPUT_VALUE_CLASS
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
name|RecordReader
name|rr
init|=
operator|new
name|ChainRecordReader
argument_list|(
name|inputContext
argument_list|)
decl_stmt|;
name|RecordWriter
name|rw
init|=
operator|new
name|ChainRecordWriter
argument_list|(
name|keyOutClass
argument_list|,
name|valueOutClass
argument_list|,
name|output
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|Mapper
operator|.
name|Context
name|mapperContext
init|=
name|createMapContext
argument_list|(
name|rr
argument_list|,
name|rw
argument_list|,
operator|(
name|MapContext
operator|)
name|inputContext
argument_list|,
name|getConf
argument_list|(
name|index
argument_list|)
argument_list|)
decl_stmt|;
name|MapRunner
name|runner
init|=
operator|new
name|MapRunner
argument_list|(
name|mappers
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|,
name|mapperContext
argument_list|,
name|rr
argument_list|,
name|rw
argument_list|)
decl_stmt|;
name|threads
operator|.
name|add
argument_list|(
name|runner
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add mapper(the last mapper) that reads input from    * queue and writes output to the output context    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|addMapper (ChainBlockingQueue<KeyValuePair<?, ?>> input, TaskInputOutputContext outputContext, int index)
name|void
name|addMapper
parameter_list|(
name|ChainBlockingQueue
argument_list|<
name|KeyValuePair
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|input
parameter_list|,
name|TaskInputOutputContext
name|outputContext
parameter_list|,
name|int
name|index
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|keyClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|MAPPER_INPUT_KEY_CLASS
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|valueClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|MAPPER_INPUT_VALUE_CLASS
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
name|RecordReader
name|rr
init|=
operator|new
name|ChainRecordReader
argument_list|(
name|keyClass
argument_list|,
name|valueClass
argument_list|,
name|input
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|RecordWriter
name|rw
init|=
operator|new
name|ChainRecordWriter
argument_list|(
name|outputContext
argument_list|)
decl_stmt|;
name|MapRunner
name|runner
init|=
operator|new
name|MapRunner
argument_list|(
name|mappers
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|,
name|createMapContext
argument_list|(
name|rr
argument_list|,
name|rw
argument_list|,
name|outputContext
argument_list|,
name|getConf
argument_list|(
name|index
argument_list|)
argument_list|)
argument_list|,
name|rr
argument_list|,
name|rw
argument_list|)
decl_stmt|;
name|threads
operator|.
name|add
argument_list|(
name|runner
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add mapper that reads and writes from/to the queue    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|addMapper (ChainBlockingQueue<KeyValuePair<?, ?>> input, ChainBlockingQueue<KeyValuePair<?, ?>> output, TaskInputOutputContext context, int index)
name|void
name|addMapper
parameter_list|(
name|ChainBlockingQueue
argument_list|<
name|KeyValuePair
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|input
parameter_list|,
name|ChainBlockingQueue
argument_list|<
name|KeyValuePair
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|output
parameter_list|,
name|TaskInputOutputContext
name|context
parameter_list|,
name|int
name|index
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|keyClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|MAPPER_INPUT_KEY_CLASS
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|valueClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|MAPPER_INPUT_VALUE_CLASS
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|keyOutClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|MAPPER_OUTPUT_KEY_CLASS
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|valueOutClass
init|=
name|conf
operator|.
name|getClass
argument_list|(
name|MAPPER_OUTPUT_VALUE_CLASS
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
name|RecordReader
name|rr
init|=
operator|new
name|ChainRecordReader
argument_list|(
name|keyClass
argument_list|,
name|valueClass
argument_list|,
name|input
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|RecordWriter
name|rw
init|=
operator|new
name|ChainRecordWriter
argument_list|(
name|keyOutClass
argument_list|,
name|valueOutClass
argument_list|,
name|output
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|MapRunner
name|runner
init|=
operator|new
name|MapRunner
argument_list|(
name|mappers
operator|.
name|get
argument_list|(
name|index
argument_list|)
argument_list|,
name|createMapContext
argument_list|(
name|rr
argument_list|,
name|rw
argument_list|,
name|context
argument_list|,
name|getConf
argument_list|(
name|index
argument_list|)
argument_list|)
argument_list|,
name|rr
argument_list|,
name|rw
argument_list|)
decl_stmt|;
name|threads
operator|.
name|add
argument_list|(
name|runner
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a reduce context that is based on ChainMapContext and the given    * record writer    */
specifier|private
parameter_list|<
name|KEYIN
parameter_list|,
name|VALUEIN
parameter_list|,
name|KEYOUT
parameter_list|,
name|VALUEOUT
parameter_list|>
DECL|method|createReduceContext ( RecordWriter<KEYOUT, VALUEOUT> rw, ReduceContext<KEYIN, VALUEIN, KEYOUT, VALUEOUT> context, Configuration conf)
name|Reducer
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|,
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
operator|.
name|Context
name|createReduceContext
parameter_list|(
name|RecordWriter
argument_list|<
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
name|rw
parameter_list|,
name|ReduceContext
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|,
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
name|context
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|ReduceContext
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|,
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
name|reduceContext
init|=
operator|new
name|ChainReduceContextImpl
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|,
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
argument_list|(
name|context
argument_list|,
name|rw
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|Reducer
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|,
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
operator|.
name|Context
name|reducerContext
init|=
operator|new
name|WrappedReducer
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|,
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
argument_list|()
operator|.
name|getReducerContext
argument_list|(
name|reduceContext
argument_list|)
decl_stmt|;
return|return
name|reducerContext
return|;
block|}
comment|// Run the reducer directly.
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|runReducer ( TaskInputOutputContext<KEYIN, VALUEIN, KEYOUT, VALUEOUT> context)
parameter_list|<
name|KEYIN
parameter_list|,
name|VALUEIN
parameter_list|,
name|KEYOUT
parameter_list|,
name|VALUEOUT
parameter_list|>
name|void
name|runReducer
parameter_list|(
name|TaskInputOutputContext
argument_list|<
name|KEYIN
argument_list|,
name|VALUEIN
argument_list|,
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
name|context
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|RecordWriter
argument_list|<
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
name|rw
init|=
operator|new
name|ChainRecordWriter
argument_list|<
name|KEYOUT
argument_list|,
name|VALUEOUT
argument_list|>
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|Reducer
operator|.
name|Context
name|reducerContext
init|=
name|createReduceContext
argument_list|(
name|rw
argument_list|,
operator|(
name|ReduceContext
operator|)
name|context
argument_list|,
name|rConf
argument_list|)
decl_stmt|;
name|reducer
operator|.
name|run
argument_list|(
name|reducerContext
argument_list|)
expr_stmt|;
name|rw
operator|.
name|close
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add reducer that reads from context and writes to a queue    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|addReducer (TaskInputOutputContext inputContext, ChainBlockingQueue<KeyValuePair<?, ?>> outputQueue)
name|void
name|addReducer
parameter_list|(
name|TaskInputOutputContext
name|inputContext
parameter_list|,
name|ChainBlockingQueue
argument_list|<
name|KeyValuePair
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|outputQueue
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|keyOutClass
init|=
name|rConf
operator|.
name|getClass
argument_list|(
name|REDUCER_OUTPUT_KEY_CLASS
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|valueOutClass
init|=
name|rConf
operator|.
name|getClass
argument_list|(
name|REDUCER_OUTPUT_VALUE_CLASS
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
name|RecordWriter
name|rw
init|=
operator|new
name|ChainRecordWriter
argument_list|(
name|keyOutClass
argument_list|,
name|valueOutClass
argument_list|,
name|outputQueue
argument_list|,
name|rConf
argument_list|)
decl_stmt|;
name|Reducer
operator|.
name|Context
name|reducerContext
init|=
name|createReduceContext
argument_list|(
name|rw
argument_list|,
operator|(
name|ReduceContext
operator|)
name|inputContext
argument_list|,
name|rConf
argument_list|)
decl_stmt|;
name|ReduceRunner
name|runner
init|=
operator|new
name|ReduceRunner
argument_list|(
name|reducerContext
argument_list|,
name|reducer
argument_list|,
name|rw
argument_list|)
decl_stmt|;
name|threads
operator|.
name|add
argument_list|(
name|runner
argument_list|)
expr_stmt|;
block|}
comment|// start all the threads
DECL|method|startAllThreads ()
name|void
name|startAllThreads
parameter_list|()
block|{
for|for
control|(
name|Thread
name|thread
range|:
name|threads
control|)
block|{
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
comment|// wait till all threads finish
DECL|method|joinAllThreads ()
name|void
name|joinAllThreads
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
for|for
control|(
name|Thread
name|thread
range|:
name|threads
control|)
block|{
name|thread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
name|Throwable
name|th
init|=
name|getThrowable
argument_list|()
decl_stmt|;
if|if
condition|(
name|th
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|th
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
name|th
throw|;
block|}
elseif|else
if|if
condition|(
name|th
operator|instanceof
name|InterruptedException
condition|)
block|{
throw|throw
operator|(
name|InterruptedException
operator|)
name|th
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|th
argument_list|)
throw|;
block|}
block|}
block|}
comment|// interrupt all threads
DECL|method|interruptAllThreads ()
specifier|private
specifier|synchronized
name|void
name|interruptAllThreads
parameter_list|()
block|{
for|for
control|(
name|Thread
name|th
range|:
name|threads
control|)
block|{
name|th
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|ChainBlockingQueue
argument_list|<
name|?
argument_list|>
name|queue
range|:
name|blockingQueues
control|)
block|{
name|queue
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Returns the prefix to use for the configuration of the chain depending if    * it is for a Mapper or a Reducer.    *     * @param isMap    *          TRUE for Mapper, FALSE for Reducer.    * @return the prefix to use.    */
DECL|method|getPrefix (boolean isMap)
specifier|protected
specifier|static
name|String
name|getPrefix
parameter_list|(
name|boolean
name|isMap
parameter_list|)
block|{
return|return
operator|(
name|isMap
operator|)
condition|?
name|CHAIN_MAPPER
else|:
name|CHAIN_REDUCER
return|;
block|}
DECL|method|getIndex (Configuration conf, String prefix)
specifier|protected
specifier|static
name|int
name|getIndex
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|prefix
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getInt
argument_list|(
name|prefix
operator|+
name|CHAIN_MAPPER_SIZE
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Creates a {@link Configuration} for the Map or Reduce in the chain.    *     *<p>    * It creates a new Configuration using the chain job's Configuration as base    * and adds to it the configuration properties for the chain element. The keys    * of the chain element Configuration have precedence over the given    * Configuration.    *</p>    *     * @param jobConf    *          the chain job's Configuration.    * @param confKey    *          the key for chain element configuration serialized in the chain    *          job's Configuration.    * @return a new Configuration aggregating the chain job's Configuration with    *         the chain element configuration properties.    */
DECL|method|getChainElementConf (Configuration jobConf, String confKey)
specifier|protected
specifier|static
name|Configuration
name|getChainElementConf
parameter_list|(
name|Configuration
name|jobConf
parameter_list|,
name|String
name|confKey
parameter_list|)
block|{
name|Configuration
name|conf
init|=
literal|null
decl_stmt|;
try|try
init|(
name|Stringifier
argument_list|<
name|Configuration
argument_list|>
name|stringifier
init|=
operator|new
name|DefaultStringifier
argument_list|<
name|Configuration
argument_list|>
argument_list|(
name|jobConf
argument_list|,
name|Configuration
operator|.
name|class
argument_list|)
init|;
init|)
block|{
name|String
name|confString
init|=
name|jobConf
operator|.
name|get
argument_list|(
name|confKey
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|confString
operator|!=
literal|null
condition|)
block|{
name|conf
operator|=
name|stringifier
operator|.
name|fromString
argument_list|(
name|jobConf
operator|.
name|get
argument_list|(
name|confKey
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioex
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ioex
argument_list|)
throw|;
block|}
comment|// we have to do this because the Writable desearialization clears all
comment|// values set in the conf making not possible do a
comment|// new Configuration(jobConf) in the creation of the conf above
name|jobConf
operator|=
operator|new
name|Configuration
argument_list|(
name|jobConf
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|conf
control|)
block|{
name|jobConf
operator|.
name|set
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|jobConf
return|;
block|}
comment|/**    * Adds a Mapper class to the chain job.    *     *<p>    * The configuration properties of the chain job have precedence over the    * configuration properties of the Mapper.    *     * @param isMap    *          indicates if the Chain is for a Mapper or for a Reducer.    * @param job    *          chain job.    * @param klass    *          the Mapper class to add.    * @param inputKeyClass    *          mapper input key class.    * @param inputValueClass    *          mapper input value class.    * @param outputKeyClass    *          mapper output key class.    * @param outputValueClass    *          mapper output value class.    * @param mapperConf    *          a configuration for the Mapper class. It is recommended to use a    *          Configuration without default values using the    *<code>Configuration(boolean loadDefaults)</code> constructor with    *          FALSE.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|addMapper (boolean isMap, Job job, Class<? extends Mapper> klass, Class<?> inputKeyClass, Class<?> inputValueClass, Class<?> outputKeyClass, Class<?> outputValueClass, Configuration mapperConf)
specifier|protected
specifier|static
name|void
name|addMapper
parameter_list|(
name|boolean
name|isMap
parameter_list|,
name|Job
name|job
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Mapper
argument_list|>
name|klass
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|inputKeyClass
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|inputValueClass
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|outputKeyClass
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|outputValueClass
parameter_list|,
name|Configuration
name|mapperConf
parameter_list|)
block|{
name|String
name|prefix
init|=
name|getPrefix
argument_list|(
name|isMap
argument_list|)
decl_stmt|;
name|Configuration
name|jobConf
init|=
name|job
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
comment|// if a reducer chain check the Reducer has been already set
name|checkReducerAlreadySet
argument_list|(
name|isMap
argument_list|,
name|jobConf
argument_list|,
name|prefix
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// set the mapper class
name|int
name|index
init|=
name|getIndex
argument_list|(
name|jobConf
argument_list|,
name|prefix
argument_list|)
decl_stmt|;
name|jobConf
operator|.
name|setClass
argument_list|(
name|prefix
operator|+
name|CHAIN_MAPPER_CLASS
operator|+
name|index
argument_list|,
name|klass
argument_list|,
name|Mapper
operator|.
name|class
argument_list|)
expr_stmt|;
name|validateKeyValueTypes
argument_list|(
name|isMap
argument_list|,
name|jobConf
argument_list|,
name|inputKeyClass
argument_list|,
name|inputValueClass
argument_list|,
name|outputKeyClass
argument_list|,
name|outputValueClass
argument_list|,
name|index
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|setMapperConf
argument_list|(
name|isMap
argument_list|,
name|jobConf
argument_list|,
name|inputKeyClass
argument_list|,
name|inputValueClass
argument_list|,
name|outputKeyClass
argument_list|,
name|outputValueClass
argument_list|,
name|mapperConf
argument_list|,
name|index
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
comment|// if a reducer chain check the Reducer has been already set or not
DECL|method|checkReducerAlreadySet (boolean isMap, Configuration jobConf, String prefix, boolean shouldSet)
specifier|protected
specifier|static
name|void
name|checkReducerAlreadySet
parameter_list|(
name|boolean
name|isMap
parameter_list|,
name|Configuration
name|jobConf
parameter_list|,
name|String
name|prefix
parameter_list|,
name|boolean
name|shouldSet
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isMap
condition|)
block|{
if|if
condition|(
name|shouldSet
condition|)
block|{
if|if
condition|(
name|jobConf
operator|.
name|getClass
argument_list|(
name|prefix
operator|+
name|CHAIN_REDUCER_CLASS
argument_list|,
literal|null
argument_list|)
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"A Mapper can be added to the chain only after the Reducer has "
operator|+
literal|"been set"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|jobConf
operator|.
name|getClass
argument_list|(
name|prefix
operator|+
name|CHAIN_REDUCER_CLASS
argument_list|,
literal|null
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Reducer has been already set"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
DECL|method|validateKeyValueTypes (boolean isMap, Configuration jobConf, Class<?> inputKeyClass, Class<?> inputValueClass, Class<?> outputKeyClass, Class<?> outputValueClass, int index, String prefix)
specifier|protected
specifier|static
name|void
name|validateKeyValueTypes
parameter_list|(
name|boolean
name|isMap
parameter_list|,
name|Configuration
name|jobConf
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|inputKeyClass
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|inputValueClass
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|outputKeyClass
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|outputValueClass
parameter_list|,
name|int
name|index
parameter_list|,
name|String
name|prefix
parameter_list|)
block|{
comment|// if it is a reducer chain and the first Mapper is being added check the
comment|// key and value input classes of the mapper match those of the reducer
comment|// output.
if|if
condition|(
operator|!
name|isMap
operator|&&
name|index
operator|==
literal|0
condition|)
block|{
name|Configuration
name|reducerConf
init|=
name|getChainElementConf
argument_list|(
name|jobConf
argument_list|,
name|prefix
operator|+
name|CHAIN_REDUCER_CONFIG
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|inputKeyClass
operator|.
name|isAssignableFrom
argument_list|(
name|reducerConf
operator|.
name|getClass
argument_list|(
name|REDUCER_OUTPUT_KEY_CLASS
argument_list|,
literal|null
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The Reducer output key class does"
operator|+
literal|" not match the Mapper input key class"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|inputValueClass
operator|.
name|isAssignableFrom
argument_list|(
name|reducerConf
operator|.
name|getClass
argument_list|(
name|REDUCER_OUTPUT_VALUE_CLASS
argument_list|,
literal|null
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The Reducer output value class"
operator|+
literal|" does not match the Mapper input value class"
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|index
operator|>
literal|0
condition|)
block|{
comment|// check the that the new Mapper in the chain key and value input classes
comment|// match those of the previous Mapper output.
name|Configuration
name|previousMapperConf
init|=
name|getChainElementConf
argument_list|(
name|jobConf
argument_list|,
name|prefix
operator|+
name|CHAIN_MAPPER_CONFIG
operator|+
operator|(
name|index
operator|-
literal|1
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|inputKeyClass
operator|.
name|isAssignableFrom
argument_list|(
name|previousMapperConf
operator|.
name|getClass
argument_list|(
name|MAPPER_OUTPUT_KEY_CLASS
argument_list|,
literal|null
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The specified Mapper input key class does"
operator|+
literal|" not match the previous Mapper's output key class."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|inputValueClass
operator|.
name|isAssignableFrom
argument_list|(
name|previousMapperConf
operator|.
name|getClass
argument_list|(
name|MAPPER_OUTPUT_VALUE_CLASS
argument_list|,
literal|null
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The specified Mapper input value class"
operator|+
literal|" does not match the previous Mapper's output value class."
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|setMapperConf (boolean isMap, Configuration jobConf, Class<?> inputKeyClass, Class<?> inputValueClass, Class<?> outputKeyClass, Class<?> outputValueClass, Configuration mapperConf, int index, String prefix)
specifier|protected
specifier|static
name|void
name|setMapperConf
parameter_list|(
name|boolean
name|isMap
parameter_list|,
name|Configuration
name|jobConf
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|inputKeyClass
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|inputValueClass
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|outputKeyClass
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|outputValueClass
parameter_list|,
name|Configuration
name|mapperConf
parameter_list|,
name|int
name|index
parameter_list|,
name|String
name|prefix
parameter_list|)
block|{
comment|// if the Mapper does not have a configuration, create an empty one
if|if
condition|(
name|mapperConf
operator|==
literal|null
condition|)
block|{
comment|// using a Configuration without defaults to make it lightweight.
comment|// still the chain's conf may have all defaults and this conf is
comment|// overlapped to the chain configuration one.
name|mapperConf
operator|=
operator|new
name|Configuration
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// store the input/output classes of the mapper in the mapper conf
name|mapperConf
operator|.
name|setClass
argument_list|(
name|MAPPER_INPUT_KEY_CLASS
argument_list|,
name|inputKeyClass
argument_list|,
name|Object
operator|.
name|class
argument_list|)
expr_stmt|;
name|mapperConf
operator|.
name|setClass
argument_list|(
name|MAPPER_INPUT_VALUE_CLASS
argument_list|,
name|inputValueClass
argument_list|,
name|Object
operator|.
name|class
argument_list|)
expr_stmt|;
name|mapperConf
operator|.
name|setClass
argument_list|(
name|MAPPER_OUTPUT_KEY_CLASS
argument_list|,
name|outputKeyClass
argument_list|,
name|Object
operator|.
name|class
argument_list|)
expr_stmt|;
name|mapperConf
operator|.
name|setClass
argument_list|(
name|MAPPER_OUTPUT_VALUE_CLASS
argument_list|,
name|outputValueClass
argument_list|,
name|Object
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// serialize the mapper configuration in the chain configuration.
name|Stringifier
argument_list|<
name|Configuration
argument_list|>
name|stringifier
init|=
operator|new
name|DefaultStringifier
argument_list|<
name|Configuration
argument_list|>
argument_list|(
name|jobConf
argument_list|,
name|Configuration
operator|.
name|class
argument_list|)
decl_stmt|;
try|try
block|{
name|jobConf
operator|.
name|set
argument_list|(
name|prefix
operator|+
name|CHAIN_MAPPER_CONFIG
operator|+
name|index
argument_list|,
name|stringifier
operator|.
name|toString
argument_list|(
operator|new
name|Configuration
argument_list|(
name|mapperConf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioEx
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ioEx
argument_list|)
throw|;
block|}
comment|// increment the chain counter
name|jobConf
operator|.
name|setInt
argument_list|(
name|prefix
operator|+
name|CHAIN_MAPPER_SIZE
argument_list|,
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**    * Sets the Reducer class to the chain job.    *     *<p>    * The configuration properties of the chain job have precedence over the    * configuration properties of the Reducer.    *     * @param job    *          the chain job.    * @param klass    *          the Reducer class to add.    * @param inputKeyClass    *          reducer input key class.    * @param inputValueClass    *          reducer input value class.    * @param outputKeyClass    *          reducer output key class.    * @param outputValueClass    *          reducer output value class.    * @param reducerConf    *          a configuration for the Reducer class. It is recommended to use a    *          Configuration without default values using the    *<code>Configuration(boolean loadDefaults)</code> constructor with    *          FALSE.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|setReducer (Job job, Class<? extends Reducer> klass, Class<?> inputKeyClass, Class<?> inputValueClass, Class<?> outputKeyClass, Class<?> outputValueClass, Configuration reducerConf)
specifier|protected
specifier|static
name|void
name|setReducer
parameter_list|(
name|Job
name|job
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Reducer
argument_list|>
name|klass
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|inputKeyClass
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|inputValueClass
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|outputKeyClass
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|outputValueClass
parameter_list|,
name|Configuration
name|reducerConf
parameter_list|)
block|{
name|String
name|prefix
init|=
name|getPrefix
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|Configuration
name|jobConf
init|=
name|job
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
name|checkReducerAlreadySet
argument_list|(
literal|false
argument_list|,
name|jobConf
argument_list|,
name|prefix
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|setClass
argument_list|(
name|prefix
operator|+
name|CHAIN_REDUCER_CLASS
argument_list|,
name|klass
argument_list|,
name|Reducer
operator|.
name|class
argument_list|)
expr_stmt|;
name|setReducerConf
argument_list|(
name|jobConf
argument_list|,
name|inputKeyClass
argument_list|,
name|inputValueClass
argument_list|,
name|outputKeyClass
argument_list|,
name|outputValueClass
argument_list|,
name|reducerConf
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
DECL|method|setReducerConf (Configuration jobConf, Class<?> inputKeyClass, Class<?> inputValueClass, Class<?> outputKeyClass, Class<?> outputValueClass, Configuration reducerConf, String prefix)
specifier|protected
specifier|static
name|void
name|setReducerConf
parameter_list|(
name|Configuration
name|jobConf
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|inputKeyClass
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|inputValueClass
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|outputKeyClass
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|outputValueClass
parameter_list|,
name|Configuration
name|reducerConf
parameter_list|,
name|String
name|prefix
parameter_list|)
block|{
comment|// if the Reducer does not have a Configuration, create an empty one
if|if
condition|(
name|reducerConf
operator|==
literal|null
condition|)
block|{
comment|// using a Configuration without defaults to make it lightweight.
comment|// still the chain's conf may have all defaults and this conf is
comment|// overlapped to the chain's Configuration one.
name|reducerConf
operator|=
operator|new
name|Configuration
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// store the input/output classes of the reducer in
comment|// the reducer configuration
name|reducerConf
operator|.
name|setClass
argument_list|(
name|REDUCER_INPUT_KEY_CLASS
argument_list|,
name|inputKeyClass
argument_list|,
name|Object
operator|.
name|class
argument_list|)
expr_stmt|;
name|reducerConf
operator|.
name|setClass
argument_list|(
name|REDUCER_INPUT_VALUE_CLASS
argument_list|,
name|inputValueClass
argument_list|,
name|Object
operator|.
name|class
argument_list|)
expr_stmt|;
name|reducerConf
operator|.
name|setClass
argument_list|(
name|REDUCER_OUTPUT_KEY_CLASS
argument_list|,
name|outputKeyClass
argument_list|,
name|Object
operator|.
name|class
argument_list|)
expr_stmt|;
name|reducerConf
operator|.
name|setClass
argument_list|(
name|REDUCER_OUTPUT_VALUE_CLASS
argument_list|,
name|outputValueClass
argument_list|,
name|Object
operator|.
name|class
argument_list|)
expr_stmt|;
comment|// serialize the reducer configuration in the chain's configuration.
name|Stringifier
argument_list|<
name|Configuration
argument_list|>
name|stringifier
init|=
operator|new
name|DefaultStringifier
argument_list|<
name|Configuration
argument_list|>
argument_list|(
name|jobConf
argument_list|,
name|Configuration
operator|.
name|class
argument_list|)
decl_stmt|;
try|try
block|{
name|jobConf
operator|.
name|set
argument_list|(
name|prefix
operator|+
name|CHAIN_REDUCER_CONFIG
argument_list|,
name|stringifier
operator|.
name|toString
argument_list|(
operator|new
name|Configuration
argument_list|(
name|reducerConf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioEx
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ioEx
argument_list|)
throw|;
block|}
block|}
comment|/**    * Setup the chain.    *     * @param jobConf    *          chain job's {@link Configuration}.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|setup (Configuration jobConf)
name|void
name|setup
parameter_list|(
name|Configuration
name|jobConf
parameter_list|)
block|{
name|String
name|prefix
init|=
name|getPrefix
argument_list|(
name|isMap
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|jobConf
operator|.
name|getInt
argument_list|(
name|prefix
operator|+
name|CHAIN_MAPPER_SIZE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|index
condition|;
name|i
operator|++
control|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|Mapper
argument_list|>
name|klass
init|=
name|jobConf
operator|.
name|getClass
argument_list|(
name|prefix
operator|+
name|CHAIN_MAPPER_CLASS
operator|+
name|i
argument_list|,
literal|null
argument_list|,
name|Mapper
operator|.
name|class
argument_list|)
decl_stmt|;
name|Configuration
name|mConf
init|=
name|getChainElementConf
argument_list|(
name|jobConf
argument_list|,
name|prefix
operator|+
name|CHAIN_MAPPER_CONFIG
operator|+
name|i
argument_list|)
decl_stmt|;
name|confList
operator|.
name|add
argument_list|(
name|mConf
argument_list|)
expr_stmt|;
name|Mapper
name|mapper
init|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|klass
argument_list|,
name|mConf
argument_list|)
decl_stmt|;
name|mappers
operator|.
name|add
argument_list|(
name|mapper
argument_list|)
expr_stmt|;
block|}
name|Class
argument_list|<
name|?
extends|extends
name|Reducer
argument_list|>
name|klass
init|=
name|jobConf
operator|.
name|getClass
argument_list|(
name|prefix
operator|+
name|CHAIN_REDUCER_CLASS
argument_list|,
literal|null
argument_list|,
name|Reducer
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|klass
operator|!=
literal|null
condition|)
block|{
name|rConf
operator|=
name|getChainElementConf
argument_list|(
name|jobConf
argument_list|,
name|prefix
operator|+
name|CHAIN_REDUCER_CONFIG
argument_list|)
expr_stmt|;
name|reducer
operator|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|klass
argument_list|,
name|rConf
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getAllMappers ()
name|List
argument_list|<
name|Mapper
argument_list|>
name|getAllMappers
parameter_list|()
block|{
return|return
name|mappers
return|;
block|}
comment|/**    * Returns the Reducer instance in the chain.    *     * @return the Reducer instance in the chain or NULL if none.    */
DECL|method|getReducer ()
name|Reducer
argument_list|<
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|,
name|?
argument_list|>
name|getReducer
parameter_list|()
block|{
return|return
name|reducer
return|;
block|}
comment|/**    * Creates a ChainBlockingQueue with KeyValuePair as element    *     * @return the ChainBlockingQueue    */
DECL|method|createBlockingQueue ()
name|ChainBlockingQueue
argument_list|<
name|KeyValuePair
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|createBlockingQueue
parameter_list|()
block|{
return|return
operator|new
name|ChainBlockingQueue
argument_list|<
name|KeyValuePair
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
argument_list|()
return|;
block|}
comment|/**    * A blocking queue with one element.    *       * @param<E>    */
DECL|class|ChainBlockingQueue
class|class
name|ChainBlockingQueue
parameter_list|<
name|E
parameter_list|>
block|{
DECL|field|element
name|E
name|element
init|=
literal|null
decl_stmt|;
DECL|field|isInterrupted
name|boolean
name|isInterrupted
init|=
literal|false
decl_stmt|;
DECL|method|ChainBlockingQueue ()
name|ChainBlockingQueue
parameter_list|()
block|{
name|blockingQueues
operator|.
name|add
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|enqueue (E e)
specifier|synchronized
name|void
name|enqueue
parameter_list|(
name|E
name|e
parameter_list|)
throws|throws
name|InterruptedException
block|{
while|while
condition|(
name|element
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|isInterrupted
condition|)
block|{
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
name|this
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
name|element
operator|=
name|e
expr_stmt|;
name|this
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
DECL|method|dequeue ()
specifier|synchronized
name|E
name|dequeue
parameter_list|()
throws|throws
name|InterruptedException
block|{
while|while
condition|(
name|element
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|isInterrupted
condition|)
block|{
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
name|this
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
name|E
name|e
init|=
name|element
decl_stmt|;
name|element
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|notify
argument_list|()
expr_stmt|;
return|return
name|e
return|;
block|}
DECL|method|interrupt ()
specifier|synchronized
name|void
name|interrupt
parameter_list|()
block|{
name|isInterrupted
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

