begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapreduce
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|Private
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
operator|.
name|Unstable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
operator|.
name|IntegerRanges
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|RawComparator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|filecache
operator|.
name|DistributedCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|protocol
operator|.
name|ClientProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|task
operator|.
name|JobContextImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|util
operator|.
name|ConfigUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ReservationId
import|;
end_import

begin_comment
comment|/**  * The job submitter's view of the Job.  *   *<p>It allows the user to configure the  * job, submit it, control its execution, and query the state. The set methods  * only work until the job is submitted, afterwards they will throw an   * IllegalStateException.</p>  *   *<p>  * Normally the user creates the application, describes various facets of the  * job via {@link Job} and then submits the job and monitor its progress.</p>  *   *<p>Here is an example on how to submit a job:</p>  *<p><blockquote><pre>  *     // Create a new Job  *     Job job = Job.getInstance();  *     job.setJarByClass(MyJob.class);  *       *     // Specify various job-specific parameters       *     job.setJobName("myjob");  *       *     job.setInputPath(new Path("in"));  *     job.setOutputPath(new Path("out"));  *       *     job.setMapperClass(MyJob.MyMapper.class);  *     job.setReducerClass(MyJob.MyReducer.class);  *  *     // Submit the job, then poll for progress until the job is complete  *     job.waitForCompletion(true);  *</pre></blockquote>  *   *   */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|Job
specifier|public
class|class
name|Job
extends|extends
name|JobContextImpl
implements|implements
name|JobContext
implements|,
name|AutoCloseable
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|Job
operator|.
name|class
argument_list|)
decl_stmt|;
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|enum|JobState
DECL|enumConstant|DEFINE
DECL|enumConstant|RUNNING
specifier|public
enum|enum
name|JobState
block|{
name|DEFINE
block|,
name|RUNNING
block|}
empty_stmt|;
DECL|field|MAX_JOBSTATUS_AGE
specifier|private
specifier|static
specifier|final
name|long
name|MAX_JOBSTATUS_AGE
init|=
literal|1000
operator|*
literal|2
decl_stmt|;
DECL|field|OUTPUT_FILTER
specifier|public
specifier|static
specifier|final
name|String
name|OUTPUT_FILTER
init|=
literal|"mapreduce.client.output.filter"
decl_stmt|;
comment|/** Key in mapred-*.xml that sets completionPollInvervalMillis */
DECL|field|COMPLETION_POLL_INTERVAL_KEY
specifier|public
specifier|static
specifier|final
name|String
name|COMPLETION_POLL_INTERVAL_KEY
init|=
literal|"mapreduce.client.completion.pollinterval"
decl_stmt|;
comment|/** Default completionPollIntervalMillis is 5000 ms. */
DECL|field|DEFAULT_COMPLETION_POLL_INTERVAL
specifier|static
specifier|final
name|int
name|DEFAULT_COMPLETION_POLL_INTERVAL
init|=
literal|5000
decl_stmt|;
comment|/** Key in mapred-*.xml that sets progMonitorPollIntervalMillis */
DECL|field|PROGRESS_MONITOR_POLL_INTERVAL_KEY
specifier|public
specifier|static
specifier|final
name|String
name|PROGRESS_MONITOR_POLL_INTERVAL_KEY
init|=
literal|"mapreduce.client.progressmonitor.pollinterval"
decl_stmt|;
comment|/** Default progMonitorPollIntervalMillis is 1000 ms. */
DECL|field|DEFAULT_MONITOR_POLL_INTERVAL
specifier|static
specifier|final
name|int
name|DEFAULT_MONITOR_POLL_INTERVAL
init|=
literal|1000
decl_stmt|;
DECL|field|USED_GENERIC_PARSER
specifier|public
specifier|static
specifier|final
name|String
name|USED_GENERIC_PARSER
init|=
literal|"mapreduce.client.genericoptionsparser.used"
decl_stmt|;
DECL|field|SUBMIT_REPLICATION
specifier|public
specifier|static
specifier|final
name|String
name|SUBMIT_REPLICATION
init|=
literal|"mapreduce.client.submit.file.replication"
decl_stmt|;
DECL|field|DEFAULT_SUBMIT_REPLICATION
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_SUBMIT_REPLICATION
init|=
literal|10
decl_stmt|;
DECL|field|USE_WILDCARD_FOR_LIBJARS
specifier|public
specifier|static
specifier|final
name|String
name|USE_WILDCARD_FOR_LIBJARS
init|=
literal|"mapreduce.client.libjars.wildcard"
decl_stmt|;
DECL|field|DEFAULT_USE_WILDCARD_FOR_LIBJARS
specifier|public
specifier|static
specifier|final
name|boolean
name|DEFAULT_USE_WILDCARD_FOR_LIBJARS
init|=
literal|true
decl_stmt|;
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|enum|TaskStatusFilter
DECL|enumConstant|NONE
DECL|enumConstant|KILLED
DECL|enumConstant|FAILED
DECL|enumConstant|SUCCEEDED
DECL|enumConstant|ALL
specifier|public
enum|enum
name|TaskStatusFilter
block|{
name|NONE
block|,
name|KILLED
block|,
name|FAILED
block|,
name|SUCCEEDED
block|,
name|ALL
block|}
static|static
block|{
name|ConfigUtil
operator|.
name|loadResources
argument_list|()
expr_stmt|;
block|}
DECL|field|state
specifier|private
name|JobState
name|state
init|=
name|JobState
operator|.
name|DEFINE
decl_stmt|;
DECL|field|status
specifier|private
name|JobStatus
name|status
decl_stmt|;
DECL|field|statustime
specifier|private
name|long
name|statustime
decl_stmt|;
DECL|field|cluster
specifier|private
name|Cluster
name|cluster
decl_stmt|;
DECL|field|reservationId
specifier|private
name|ReservationId
name|reservationId
decl_stmt|;
comment|/**    * @deprecated Use {@link #getInstance()}    */
annotation|@
name|Deprecated
DECL|method|Job ()
specifier|public
name|Job
parameter_list|()
throws|throws
name|IOException
block|{
name|this
argument_list|(
operator|new
name|JobConf
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * @deprecated Use {@link #getInstance(Configuration)}    */
annotation|@
name|Deprecated
DECL|method|Job (Configuration conf)
specifier|public
name|Job
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
operator|new
name|JobConf
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * @deprecated Use {@link #getInstance(Configuration, String)}    */
annotation|@
name|Deprecated
DECL|method|Job (Configuration conf, String jobName)
specifier|public
name|Job
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|jobName
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
operator|new
name|JobConf
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|setJobName
argument_list|(
name|jobName
argument_list|)
expr_stmt|;
block|}
DECL|method|Job (JobConf conf)
name|Job
parameter_list|(
name|JobConf
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|conf
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// propagate existing user credentials to job
name|this
operator|.
name|credentials
operator|.
name|mergeAll
argument_list|(
name|this
operator|.
name|ugi
operator|.
name|getCredentials
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|cluster
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|Job (JobStatus status, JobConf conf)
name|Job
parameter_list|(
name|JobStatus
name|status
parameter_list|,
name|JobConf
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|setJobID
argument_list|(
name|status
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|state
operator|=
name|JobState
operator|.
name|RUNNING
expr_stmt|;
block|}
comment|/**    * Creates a new {@link Job} with no particular {@link Cluster} .    * A Cluster will be created with a generic {@link Configuration}.    *     * @return the {@link Job} , with no connection to a cluster yet.    * @throws IOException    */
DECL|method|getInstance ()
specifier|public
specifier|static
name|Job
name|getInstance
parameter_list|()
throws|throws
name|IOException
block|{
comment|// create with a null Cluster
return|return
name|getInstance
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Creates a new {@link Job} with no particular {@link Cluster} and a     * given {@link Configuration}.    *     * The<code>Job</code> makes a copy of the<code>Configuration</code> so     * that any necessary internal modifications do not reflect on the incoming     * parameter.    *     * A Cluster will be created from the conf parameter only when it's needed.    *     * @param conf the configuration    * @return the {@link Job} , with no connection to a cluster yet.    * @throws IOException    */
DECL|method|getInstance (Configuration conf)
specifier|public
specifier|static
name|Job
name|getInstance
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// create with a null Cluster
name|JobConf
name|jobConf
init|=
operator|new
name|JobConf
argument_list|(
name|conf
argument_list|)
decl_stmt|;
return|return
operator|new
name|Job
argument_list|(
name|jobConf
argument_list|)
return|;
block|}
comment|/**    * Creates a new {@link Job} with no particular {@link Cluster} and a given jobName.    * A Cluster will be created from the conf parameter only when it's needed.    *    * The<code>Job</code> makes a copy of the<code>Configuration</code> so     * that any necessary internal modifications do not reflect on the incoming     * parameter.    *     * @param conf the configuration    * @return the {@link Job} , with no connection to a cluster yet.    * @throws IOException    */
DECL|method|getInstance (Configuration conf, String jobName)
specifier|public
specifier|static
name|Job
name|getInstance
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|jobName
parameter_list|)
throws|throws
name|IOException
block|{
comment|// create with a null Cluster
name|Job
name|result
init|=
name|getInstance
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|result
operator|.
name|setJobName
argument_list|(
name|jobName
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Creates a new {@link Job} with no particular {@link Cluster} and given    * {@link Configuration} and {@link JobStatus}.    * A Cluster will be created from the conf parameter only when it's needed.    *     * The<code>Job</code> makes a copy of the<code>Configuration</code> so     * that any necessary internal modifications do not reflect on the incoming     * parameter.    *     * @param status job status    * @param conf job configuration    * @return the {@link Job} , with no connection to a cluster yet.    * @throws IOException    */
DECL|method|getInstance (JobStatus status, Configuration conf)
specifier|public
specifier|static
name|Job
name|getInstance
parameter_list|(
name|JobStatus
name|status
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|Job
argument_list|(
name|status
argument_list|,
operator|new
name|JobConf
argument_list|(
name|conf
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Creates a new {@link Job} with no particular {@link Cluster}.    * A Cluster will be created from the conf parameter only when it's needed.    *    * The<code>Job</code> makes a copy of the<code>Configuration</code> so     * that any necessary internal modifications do not reflect on the incoming     * parameter.    *     * @param ignored    * @return the {@link Job} , with no connection to a cluster yet.    * @throws IOException    * @deprecated Use {@link #getInstance()}    */
annotation|@
name|Deprecated
DECL|method|getInstance (Cluster ignored)
specifier|public
specifier|static
name|Job
name|getInstance
parameter_list|(
name|Cluster
name|ignored
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getInstance
argument_list|()
return|;
block|}
comment|/**    * Creates a new {@link Job} with no particular {@link Cluster} and given    * {@link Configuration}.    * A Cluster will be created from the conf parameter only when it's needed.    *     * The<code>Job</code> makes a copy of the<code>Configuration</code> so     * that any necessary internal modifications do not reflect on the incoming     * parameter.    *     * @param ignored    * @param conf job configuration    * @return the {@link Job} , with no connection to a cluster yet.    * @throws IOException    * @deprecated Use {@link #getInstance(Configuration)}    */
annotation|@
name|Deprecated
DECL|method|getInstance (Cluster ignored, Configuration conf)
specifier|public
specifier|static
name|Job
name|getInstance
parameter_list|(
name|Cluster
name|ignored
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getInstance
argument_list|(
name|conf
argument_list|)
return|;
block|}
comment|/**    * Creates a new {@link Job} with no particular {@link Cluster} and given    * {@link Configuration} and {@link JobStatus}.    * A Cluster will be created from the conf parameter only when it's needed.    *     * The<code>Job</code> makes a copy of the<code>Configuration</code> so     * that any necessary internal modifications do not reflect on the incoming     * parameter.    *     * @param cluster cluster    * @param status job status    * @param conf job configuration    * @return the {@link Job} , with no connection to a cluster yet.    * @throws IOException    */
annotation|@
name|Private
DECL|method|getInstance (Cluster cluster, JobStatus status, Configuration conf)
specifier|public
specifier|static
name|Job
name|getInstance
parameter_list|(
name|Cluster
name|cluster
parameter_list|,
name|JobStatus
name|status
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|Job
name|job
init|=
name|getInstance
argument_list|(
name|status
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|job
operator|.
name|setCluster
argument_list|(
name|cluster
argument_list|)
expr_stmt|;
return|return
name|job
return|;
block|}
DECL|method|ensureState (JobState state)
specifier|private
name|void
name|ensureState
parameter_list|(
name|JobState
name|state
parameter_list|)
throws|throws
name|IllegalStateException
block|{
if|if
condition|(
name|state
operator|!=
name|this
operator|.
name|state
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Job in state "
operator|+
name|this
operator|.
name|state
operator|+
literal|" instead of "
operator|+
name|state
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|JobState
operator|.
name|RUNNING
operator|&&
name|cluster
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Job in state "
operator|+
name|this
operator|.
name|state
operator|+
literal|", but it isn't attached to any job tracker!"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Some methods rely on having a recent job status object.  Refresh    * it, if necessary    */
DECL|method|ensureFreshStatus ()
specifier|synchronized
name|void
name|ensureFreshStatus
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|statustime
operator|>
name|MAX_JOBSTATUS_AGE
condition|)
block|{
name|updateStatus
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Some methods need to update status immediately. So, refresh    * immediately    * @throws IOException    */
DECL|method|updateStatus ()
specifier|synchronized
name|void
name|updateStatus
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|this
operator|.
name|status
operator|=
name|ugi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|JobStatus
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|JobStatus
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|cluster
operator|.
name|getClient
argument_list|()
operator|.
name|getJobStatus
argument_list|(
name|getJobID
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
if|if
condition|(
name|this
operator|.
name|status
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Job status not available "
argument_list|)
throw|;
block|}
name|this
operator|.
name|statustime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
DECL|method|getStatus ()
specifier|public
name|JobStatus
name|getStatus
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
name|updateStatus
argument_list|()
expr_stmt|;
return|return
name|status
return|;
block|}
comment|/**    * Returns the current state of the Job.    *     * @return JobStatus#State    * @throws IOException    * @throws InterruptedException    */
DECL|method|getJobState ()
specifier|public
name|JobStatus
operator|.
name|State
name|getJobState
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
name|updateStatus
argument_list|()
expr_stmt|;
return|return
name|status
operator|.
name|getState
argument_list|()
return|;
block|}
comment|/**    * Get the URL where some job progress information will be displayed.    *     * @return the URL where some job progress information will be displayed.    */
DECL|method|getTrackingURL ()
specifier|public
name|String
name|getTrackingURL
parameter_list|()
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
return|return
name|status
operator|.
name|getTrackingUrl
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Get the path of the submitted job configuration.    *     * @return the path of the submitted job configuration.    */
DECL|method|getJobFile ()
specifier|public
name|String
name|getJobFile
parameter_list|()
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
return|return
name|status
operator|.
name|getJobFile
argument_list|()
return|;
block|}
comment|/**    * Get start time of the job.    *     * @return the start time of the job    */
DECL|method|getStartTime ()
specifier|public
name|long
name|getStartTime
parameter_list|()
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
return|return
name|status
operator|.
name|getStartTime
argument_list|()
return|;
block|}
comment|/**    * Get finish time of the job.    *     * @return the finish time of the job    */
DECL|method|getFinishTime ()
specifier|public
name|long
name|getFinishTime
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
name|updateStatus
argument_list|()
expr_stmt|;
return|return
name|status
operator|.
name|getFinishTime
argument_list|()
return|;
block|}
comment|/**    * Get scheduling info of the job.    *     * @return the scheduling info of the job    */
DECL|method|getSchedulingInfo ()
specifier|public
name|String
name|getSchedulingInfo
parameter_list|()
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
return|return
name|status
operator|.
name|getSchedulingInfo
argument_list|()
return|;
block|}
comment|/**    * Get scheduling info of the job.    *     * @return the priority info of the job    */
DECL|method|getPriority ()
specifier|public
name|JobPriority
name|getPriority
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
name|updateStatus
argument_list|()
expr_stmt|;
return|return
name|status
operator|.
name|getPriority
argument_list|()
return|;
block|}
comment|/**    * The user-specified job name.    */
DECL|method|getJobName ()
specifier|public
name|String
name|getJobName
parameter_list|()
block|{
if|if
condition|(
name|state
operator|==
name|JobState
operator|.
name|DEFINE
operator|||
name|status
operator|==
literal|null
condition|)
block|{
return|return
name|super
operator|.
name|getJobName
argument_list|()
return|;
block|}
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
return|return
name|status
operator|.
name|getJobName
argument_list|()
return|;
block|}
DECL|method|getHistoryUrl ()
specifier|public
name|String
name|getHistoryUrl
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
name|updateStatus
argument_list|()
expr_stmt|;
return|return
name|status
operator|.
name|getHistoryFile
argument_list|()
return|;
block|}
DECL|method|isRetired ()
specifier|public
name|boolean
name|isRetired
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
name|updateStatus
argument_list|()
expr_stmt|;
return|return
name|status
operator|.
name|isRetired
argument_list|()
return|;
block|}
annotation|@
name|Private
DECL|method|getCluster ()
specifier|public
name|Cluster
name|getCluster
parameter_list|()
block|{
return|return
name|cluster
return|;
block|}
comment|/** Only for mocks in unit tests. */
annotation|@
name|Private
DECL|method|setCluster (Cluster cluster)
specifier|private
name|void
name|setCluster
parameter_list|(
name|Cluster
name|cluster
parameter_list|)
block|{
name|this
operator|.
name|cluster
operator|=
name|cluster
expr_stmt|;
block|}
comment|/**    * Dump stats to screen.    */
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
name|String
name|reasonforFailure
init|=
literal|" "
decl_stmt|;
name|int
name|numMaps
init|=
literal|0
decl_stmt|;
name|int
name|numReduces
init|=
literal|0
decl_stmt|;
try|try
block|{
name|updateStatus
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|getState
argument_list|()
operator|.
name|equals
argument_list|(
name|JobStatus
operator|.
name|State
operator|.
name|FAILED
argument_list|)
condition|)
name|reasonforFailure
operator|=
name|getTaskFailureEventString
argument_list|()
expr_stmt|;
name|numMaps
operator|=
name|getTaskReports
argument_list|(
name|TaskType
operator|.
name|MAP
argument_list|)
operator|.
name|length
expr_stmt|;
name|numReduces
operator|=
name|getTaskReports
argument_list|(
name|TaskType
operator|.
name|REDUCE
argument_list|)
operator|.
name|length
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{     }
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{     }
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Job: "
argument_list|)
operator|.
name|append
argument_list|(
name|status
operator|.
name|getJobID
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Job File: "
argument_list|)
operator|.
name|append
argument_list|(
name|status
operator|.
name|getJobFile
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Job Tracking URL : "
argument_list|)
operator|.
name|append
argument_list|(
name|status
operator|.
name|getTrackingUrl
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Uber job : "
argument_list|)
operator|.
name|append
argument_list|(
name|status
operator|.
name|isUber
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Number of maps: "
argument_list|)
operator|.
name|append
argument_list|(
name|numMaps
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Number of reduces: "
argument_list|)
operator|.
name|append
argument_list|(
name|numReduces
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"map() completion: "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|status
operator|.
name|getMapProgress
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"reduce() completion: "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|status
operator|.
name|getReduceProgress
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Job state: "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|status
operator|.
name|getState
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"retired: "
argument_list|)
operator|.
name|append
argument_list|(
name|status
operator|.
name|isRetired
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"reason for failure: "
argument_list|)
operator|.
name|append
argument_list|(
name|reasonforFailure
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * @return taskid which caused job failure    * @throws IOException    * @throws InterruptedException    */
DECL|method|getTaskFailureEventString ()
name|String
name|getTaskFailureEventString
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|int
name|failCount
init|=
literal|1
decl_stmt|;
name|TaskCompletionEvent
name|lastEvent
init|=
literal|null
decl_stmt|;
name|TaskCompletionEvent
index|[]
name|events
init|=
name|ugi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|TaskCompletionEvent
index|[]
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|TaskCompletionEvent
index|[]
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|cluster
operator|.
name|getClient
argument_list|()
operator|.
name|getTaskCompletionEvents
argument_list|(
name|status
operator|.
name|getJobID
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
for|for
control|(
name|TaskCompletionEvent
name|event
range|:
name|events
control|)
block|{
if|if
condition|(
name|event
operator|.
name|getStatus
argument_list|()
operator|.
name|equals
argument_list|(
name|TaskCompletionEvent
operator|.
name|Status
operator|.
name|FAILED
argument_list|)
condition|)
block|{
name|failCount
operator|++
expr_stmt|;
name|lastEvent
operator|=
name|event
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lastEvent
operator|==
literal|null
condition|)
block|{
return|return
literal|"There are no failed tasks for the job. "
operator|+
literal|"Job is failed due to some other reason and reason "
operator|+
literal|"can be found in the logs."
return|;
block|}
name|String
index|[]
name|taskAttemptID
init|=
name|lastEvent
operator|.
name|getTaskAttemptId
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|split
argument_list|(
literal|"_"
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|String
name|taskID
init|=
name|taskAttemptID
index|[
literal|1
index|]
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|taskAttemptID
index|[
literal|1
index|]
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
decl_stmt|;
return|return
operator|(
literal|" task "
operator|+
name|taskID
operator|+
literal|" failed "
operator|+
name|failCount
operator|+
literal|" times "
operator|+
literal|"For details check tasktracker at: "
operator|+
name|lastEvent
operator|.
name|getTaskTrackerHttp
argument_list|()
operator|)
return|;
block|}
comment|/**    * Get the information of the current state of the tasks of a job.    *     * @param type Type of the task    * @return the list of all of the map tips.    * @throws IOException    */
DECL|method|getTaskReports (TaskType type)
specifier|public
name|TaskReport
index|[]
name|getTaskReports
parameter_list|(
name|TaskType
name|type
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
specifier|final
name|TaskType
name|tmpType
init|=
name|type
decl_stmt|;
return|return
name|ugi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|TaskReport
index|[]
argument_list|>
argument_list|()
block|{
specifier|public
name|TaskReport
index|[]
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|cluster
operator|.
name|getClient
argument_list|()
operator|.
name|getTaskReports
argument_list|(
name|getJobID
argument_list|()
argument_list|,
name|tmpType
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Get the<i>progress</i> of the job's map-tasks, as a float between 0.0     * and 1.0.  When all map tasks have completed, the function returns 1.0.    *     * @return the progress of the job's map-tasks.    * @throws IOException    */
DECL|method|mapProgress ()
specifier|public
name|float
name|mapProgress
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
name|ensureFreshStatus
argument_list|()
expr_stmt|;
return|return
name|status
operator|.
name|getMapProgress
argument_list|()
return|;
block|}
comment|/**    * Get the<i>progress</i> of the job's reduce-tasks, as a float between 0.0     * and 1.0.  When all reduce tasks have completed, the function returns 1.0.    *     * @return the progress of the job's reduce-tasks.    * @throws IOException    */
DECL|method|reduceProgress ()
specifier|public
name|float
name|reduceProgress
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
name|ensureFreshStatus
argument_list|()
expr_stmt|;
return|return
name|status
operator|.
name|getReduceProgress
argument_list|()
return|;
block|}
comment|/**    * Get the<i>progress</i> of the job's cleanup-tasks, as a float between 0.0     * and 1.0.  When all cleanup tasks have completed, the function returns 1.0.    *     * @return the progress of the job's cleanup-tasks.    * @throws IOException    */
DECL|method|cleanupProgress ()
specifier|public
name|float
name|cleanupProgress
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
name|ensureFreshStatus
argument_list|()
expr_stmt|;
return|return
name|status
operator|.
name|getCleanupProgress
argument_list|()
return|;
block|}
comment|/**    * Get the<i>progress</i> of the job's setup-tasks, as a float between 0.0     * and 1.0.  When all setup tasks have completed, the function returns 1.0.    *     * @return the progress of the job's setup-tasks.    * @throws IOException    */
DECL|method|setupProgress ()
specifier|public
name|float
name|setupProgress
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
name|ensureFreshStatus
argument_list|()
expr_stmt|;
return|return
name|status
operator|.
name|getSetupProgress
argument_list|()
return|;
block|}
comment|/**    * Check if the job is finished or not.     * This is a non-blocking call.    *     * @return<code>true</code> if the job is complete, else<code>false</code>.    * @throws IOException    */
DECL|method|isComplete ()
specifier|public
name|boolean
name|isComplete
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
name|updateStatus
argument_list|()
expr_stmt|;
return|return
name|status
operator|.
name|isJobComplete
argument_list|()
return|;
block|}
comment|/**    * Check if the job completed successfully.     *     * @return<code>true</code> if the job succeeded, else<code>false</code>.    * @throws IOException    */
DECL|method|isSuccessful ()
specifier|public
name|boolean
name|isSuccessful
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
name|updateStatus
argument_list|()
expr_stmt|;
return|return
name|status
operator|.
name|getState
argument_list|()
operator|==
name|JobStatus
operator|.
name|State
operator|.
name|SUCCEEDED
return|;
block|}
comment|/**    * Kill the running job.  Blocks until all job tasks have been    * killed as well.  If the job is no longer running, it simply returns.    *     * @throws IOException    */
DECL|method|killJob ()
specifier|public
name|void
name|killJob
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
try|try
block|{
name|cluster
operator|.
name|getClient
argument_list|()
operator|.
name|killJob
argument_list|(
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
block|}
comment|/**    * Set the priority of a running job.    * @param jobPriority the new priority for the job.    * @throws IOException    */
DECL|method|setPriority (JobPriority jobPriority)
specifier|public
name|void
name|setPriority
parameter_list|(
name|JobPriority
name|jobPriority
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|state
operator|==
name|JobState
operator|.
name|DEFINE
condition|)
block|{
if|if
condition|(
name|jobPriority
operator|==
name|JobPriority
operator|.
name|UNDEFINED_PRIORITY
condition|)
block|{
name|conf
operator|.
name|setJobPriorityAsInteger
argument_list|(
name|convertPriorityToInteger
argument_list|(
name|jobPriority
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|conf
operator|.
name|setJobPriority
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobPriority
operator|.
name|valueOf
argument_list|(
name|jobPriority
operator|.
name|name
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
specifier|final
name|int
name|tmpPriority
init|=
name|convertPriorityToInteger
argument_list|(
name|jobPriority
argument_list|)
decl_stmt|;
name|ugi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|cluster
operator|.
name|getClient
argument_list|()
operator|.
name|setJobPriority
argument_list|(
name|getJobID
argument_list|()
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|tmpPriority
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set the priority of a running job.    *    * @param jobPriority    *          the new priority for the job.    * @throws IOException    */
DECL|method|setPriorityAsInteger (int jobPriority)
specifier|public
name|void
name|setPriorityAsInteger
parameter_list|(
name|int
name|jobPriority
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
if|if
condition|(
name|state
operator|==
name|JobState
operator|.
name|DEFINE
condition|)
block|{
name|conf
operator|.
name|setJobPriorityAsInteger
argument_list|(
name|jobPriority
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
specifier|final
name|int
name|tmpPriority
init|=
name|jobPriority
decl_stmt|;
name|ugi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|cluster
operator|.
name|getClient
argument_list|()
operator|.
name|setJobPriority
argument_list|(
name|getJobID
argument_list|()
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|tmpPriority
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|convertPriorityToInteger (JobPriority jobPriority)
specifier|private
name|int
name|convertPriorityToInteger
parameter_list|(
name|JobPriority
name|jobPriority
parameter_list|)
block|{
switch|switch
condition|(
name|jobPriority
condition|)
block|{
case|case
name|VERY_HIGH
case|:
return|return
literal|5
return|;
case|case
name|HIGH
case|:
return|return
literal|4
return|;
case|case
name|NORMAL
case|:
return|return
literal|3
return|;
case|case
name|LOW
case|:
return|return
literal|2
return|;
case|case
name|VERY_LOW
case|:
return|return
literal|1
return|;
case|case
name|DEFAULT
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
comment|// For UNDEFINED_PRIORITY, we can set it to default for better handling
return|return
literal|0
return|;
block|}
comment|/**    * Get events indicating completion (success/failure) of component tasks.    *      * @param startFrom index to start fetching events from    * @param numEvents number of events to fetch    * @return an array of {@link TaskCompletionEvent}s    * @throws IOException    */
DECL|method|getTaskCompletionEvents (final int startFrom, final int numEvents)
specifier|public
name|TaskCompletionEvent
index|[]
name|getTaskCompletionEvents
parameter_list|(
specifier|final
name|int
name|startFrom
parameter_list|,
specifier|final
name|int
name|numEvents
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
return|return
name|ugi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|TaskCompletionEvent
index|[]
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|TaskCompletionEvent
index|[]
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|cluster
operator|.
name|getClient
argument_list|()
operator|.
name|getTaskCompletionEvents
argument_list|(
name|getJobID
argument_list|()
argument_list|,
name|startFrom
argument_list|,
name|numEvents
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Get events indicating completion (success/failure) of component tasks.    *      * @param startFrom index to start fetching events from    * @return an array of {@link org.apache.hadoop.mapred.TaskCompletionEvent}s    * @throws IOException    */
specifier|public
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskCompletionEvent
index|[]
DECL|method|getTaskCompletionEvents (final int startFrom)
name|getTaskCompletionEvents
parameter_list|(
specifier|final
name|int
name|startFrom
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|TaskCompletionEvent
index|[]
name|events
init|=
name|getTaskCompletionEvents
argument_list|(
name|startFrom
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskCompletionEvent
index|[]
name|retEvents
init|=
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskCompletionEvent
index|[
name|events
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|events
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|retEvents
index|[
name|i
index|]
operator|=
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskCompletionEvent
operator|.
name|downgrade
argument_list|(
name|events
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|retEvents
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
block|}
comment|/**    * Kill indicated task attempt.    * @param taskId the id of the task to kill.    * @param shouldFail if<code>true</code> the task is failed and added    *                   to failed tasks list, otherwise it is just killed,    *                   w/o affecting job failure status.    */
annotation|@
name|Private
DECL|method|killTask (final TaskAttemptID taskId, final boolean shouldFail)
specifier|public
name|boolean
name|killTask
parameter_list|(
specifier|final
name|TaskAttemptID
name|taskId
parameter_list|,
specifier|final
name|boolean
name|shouldFail
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|ugi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
specifier|public
name|Boolean
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|cluster
operator|.
name|getClient
argument_list|()
operator|.
name|killTask
argument_list|(
name|taskId
argument_list|,
name|shouldFail
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
block|}
comment|/**    * Kill indicated task attempt.    *     * @param taskId the id of the task to be terminated.    * @throws IOException    */
DECL|method|killTask (final TaskAttemptID taskId)
specifier|public
name|void
name|killTask
parameter_list|(
specifier|final
name|TaskAttemptID
name|taskId
parameter_list|)
throws|throws
name|IOException
block|{
name|killTask
argument_list|(
name|taskId
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Fail indicated task attempt.    *     * @param taskId the id of the task to be terminated.    * @throws IOException    */
DECL|method|failTask (final TaskAttemptID taskId)
specifier|public
name|void
name|failTask
parameter_list|(
specifier|final
name|TaskAttemptID
name|taskId
parameter_list|)
throws|throws
name|IOException
block|{
name|killTask
argument_list|(
name|taskId
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Gets the counters for this job. May return null if the job has been    * retired and the job is no longer in the completed job store.    *     * @return the counters for this job.    * @throws IOException    */
DECL|method|getCounters ()
specifier|public
name|Counters
name|getCounters
parameter_list|()
throws|throws
name|IOException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|ugi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Counters
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Counters
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|cluster
operator|.
name|getClient
argument_list|()
operator|.
name|getJobCounters
argument_list|(
name|getJobID
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ie
argument_list|)
throw|;
block|}
block|}
comment|/**    * Gets the diagnostic messages for a given task attempt.    * @param taskid    * @return the list of diagnostic messages for the task    * @throws IOException    */
DECL|method|getTaskDiagnostics (final TaskAttemptID taskid)
specifier|public
name|String
index|[]
name|getTaskDiagnostics
parameter_list|(
specifier|final
name|TaskAttemptID
name|taskid
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
return|return
name|ugi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|String
index|[]
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
index|[]
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|cluster
operator|.
name|getClient
argument_list|()
operator|.
name|getTaskDiagnostics
argument_list|(
name|taskid
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Set the number of reduce tasks for the job.    * @param tasks the number of reduce tasks    * @throws IllegalStateException if the job is submitted    */
DECL|method|setNumReduceTasks (int tasks)
specifier|public
name|void
name|setNumReduceTasks
parameter_list|(
name|int
name|tasks
parameter_list|)
throws|throws
name|IllegalStateException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setNumReduceTasks
argument_list|(
name|tasks
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the current working directory for the default file system.    *     * @param dir the new current working directory.    * @throws IllegalStateException if the job is submitted    */
DECL|method|setWorkingDirectory (Path dir)
specifier|public
name|void
name|setWorkingDirectory
parameter_list|(
name|Path
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setWorkingDirectory
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the {@link InputFormat} for the job.    * @param cls the<code>InputFormat</code> to use    * @throws IllegalStateException if the job is submitted    */
DECL|method|setInputFormatClass (Class<? extends InputFormat> cls )
specifier|public
name|void
name|setInputFormatClass
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|InputFormat
argument_list|>
name|cls
parameter_list|)
throws|throws
name|IllegalStateException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setClass
argument_list|(
name|INPUT_FORMAT_CLASS_ATTR
argument_list|,
name|cls
argument_list|,
name|InputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the {@link OutputFormat} for the job.    * @param cls the<code>OutputFormat</code> to use    * @throws IllegalStateException if the job is submitted    */
DECL|method|setOutputFormatClass (Class<? extends OutputFormat> cls )
specifier|public
name|void
name|setOutputFormatClass
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|OutputFormat
argument_list|>
name|cls
parameter_list|)
throws|throws
name|IllegalStateException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setClass
argument_list|(
name|OUTPUT_FORMAT_CLASS_ATTR
argument_list|,
name|cls
argument_list|,
name|OutputFormat
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the {@link Mapper} for the job.    * @param cls the<code>Mapper</code> to use    * @throws IllegalStateException if the job is submitted    */
DECL|method|setMapperClass (Class<? extends Mapper> cls )
specifier|public
name|void
name|setMapperClass
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Mapper
argument_list|>
name|cls
parameter_list|)
throws|throws
name|IllegalStateException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setClass
argument_list|(
name|MAP_CLASS_ATTR
argument_list|,
name|cls
argument_list|,
name|Mapper
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the Jar by finding where a given class came from.    * @param cls the example class    */
DECL|method|setJarByClass (Class<?> cls)
specifier|public
name|void
name|setJarByClass
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|cls
parameter_list|)
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setJarByClass
argument_list|(
name|cls
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the job jar     */
DECL|method|setJar (String jar)
specifier|public
name|void
name|setJar
parameter_list|(
name|String
name|jar
parameter_list|)
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setJar
argument_list|(
name|jar
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the reported username for this job.    *     * @param user the username for this job.    */
DECL|method|setUser (String user)
specifier|public
name|void
name|setUser
parameter_list|(
name|String
name|user
parameter_list|)
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setUser
argument_list|(
name|user
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the combiner class for the job.    * @param cls the combiner to use    * @throws IllegalStateException if the job is submitted    */
DECL|method|setCombinerClass (Class<? extends Reducer> cls )
specifier|public
name|void
name|setCombinerClass
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Reducer
argument_list|>
name|cls
parameter_list|)
throws|throws
name|IllegalStateException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setClass
argument_list|(
name|COMBINE_CLASS_ATTR
argument_list|,
name|cls
argument_list|,
name|Reducer
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the {@link Reducer} for the job.    * @param cls the<code>Reducer</code> to use    * @throws IllegalStateException if the job is submitted    */
DECL|method|setReducerClass (Class<? extends Reducer> cls )
specifier|public
name|void
name|setReducerClass
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Reducer
argument_list|>
name|cls
parameter_list|)
throws|throws
name|IllegalStateException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setClass
argument_list|(
name|REDUCE_CLASS_ATTR
argument_list|,
name|cls
argument_list|,
name|Reducer
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the {@link Partitioner} for the job.    * @param cls the<code>Partitioner</code> to use    * @throws IllegalStateException if the job is submitted    */
DECL|method|setPartitionerClass (Class<? extends Partitioner> cls )
specifier|public
name|void
name|setPartitionerClass
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Partitioner
argument_list|>
name|cls
parameter_list|)
throws|throws
name|IllegalStateException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setClass
argument_list|(
name|PARTITIONER_CLASS_ATTR
argument_list|,
name|cls
argument_list|,
name|Partitioner
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the key class for the map output data. This allows the user to    * specify the map output key class to be different than the final output    * value class.    *     * @param theClass the map output key class.    * @throws IllegalStateException if the job is submitted    */
DECL|method|setMapOutputKeyClass (Class<?> theClass )
specifier|public
name|void
name|setMapOutputKeyClass
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|theClass
parameter_list|)
throws|throws
name|IllegalStateException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setMapOutputKeyClass
argument_list|(
name|theClass
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the value class for the map output data. This allows the user to    * specify the map output value class to be different than the final output    * value class.    *     * @param theClass the map output value class.    * @throws IllegalStateException if the job is submitted    */
DECL|method|setMapOutputValueClass (Class<?> theClass )
specifier|public
name|void
name|setMapOutputValueClass
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|theClass
parameter_list|)
throws|throws
name|IllegalStateException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setMapOutputValueClass
argument_list|(
name|theClass
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the key class for the job output data.    *     * @param theClass the key class for the job output data.    * @throws IllegalStateException if the job is submitted    */
DECL|method|setOutputKeyClass (Class<?> theClass )
specifier|public
name|void
name|setOutputKeyClass
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|theClass
parameter_list|)
throws|throws
name|IllegalStateException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setOutputKeyClass
argument_list|(
name|theClass
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the value class for job outputs.    *     * @param theClass the value class for job outputs.    * @throws IllegalStateException if the job is submitted    */
DECL|method|setOutputValueClass (Class<?> theClass )
specifier|public
name|void
name|setOutputValueClass
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|theClass
parameter_list|)
throws|throws
name|IllegalStateException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setOutputValueClass
argument_list|(
name|theClass
argument_list|)
expr_stmt|;
block|}
comment|/**    * Define the comparator that controls which keys are grouped together    * for a single call to combiner,    * {@link Reducer#reduce(Object, Iterable,    * org.apache.hadoop.mapreduce.Reducer.Context)}    *    * @param cls the raw comparator to use    * @throws IllegalStateException if the job is submitted    */
DECL|method|setCombinerKeyGroupingComparatorClass ( Class<? extends RawComparator> cls)
specifier|public
name|void
name|setCombinerKeyGroupingComparatorClass
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|RawComparator
argument_list|>
name|cls
parameter_list|)
throws|throws
name|IllegalStateException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setCombinerKeyGroupingComparator
argument_list|(
name|cls
argument_list|)
expr_stmt|;
block|}
comment|/**    * Define the comparator that controls how the keys are sorted before they    * are passed to the {@link Reducer}.    * @param cls the raw comparator    * @throws IllegalStateException if the job is submitted    * @see #setCombinerKeyGroupingComparatorClass(Class)    */
DECL|method|setSortComparatorClass (Class<? extends RawComparator> cls )
specifier|public
name|void
name|setSortComparatorClass
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|RawComparator
argument_list|>
name|cls
parameter_list|)
throws|throws
name|IllegalStateException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setOutputKeyComparatorClass
argument_list|(
name|cls
argument_list|)
expr_stmt|;
block|}
comment|/**    * Define the comparator that controls which keys are grouped together    * for a single call to     * {@link Reducer#reduce(Object, Iterable,     *                       org.apache.hadoop.mapreduce.Reducer.Context)}    * @param cls the raw comparator to use    * @throws IllegalStateException if the job is submitted    * @see #setCombinerKeyGroupingComparatorClass(Class)    */
DECL|method|setGroupingComparatorClass (Class<? extends RawComparator> cls )
specifier|public
name|void
name|setGroupingComparatorClass
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|RawComparator
argument_list|>
name|cls
parameter_list|)
throws|throws
name|IllegalStateException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setOutputValueGroupingComparator
argument_list|(
name|cls
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the user-specified job name.    *     * @param name the job's new name.    * @throws IllegalStateException if the job is submitted    */
DECL|method|setJobName (String name)
specifier|public
name|void
name|setJobName
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IllegalStateException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setJobName
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|/**    * Turn speculative execution on or off for this job.     *     * @param speculativeExecution<code>true</code> if speculative execution     *                             should be turned on, else<code>false</code>.    */
DECL|method|setSpeculativeExecution (boolean speculativeExecution)
specifier|public
name|void
name|setSpeculativeExecution
parameter_list|(
name|boolean
name|speculativeExecution
parameter_list|)
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setSpeculativeExecution
argument_list|(
name|speculativeExecution
argument_list|)
expr_stmt|;
block|}
comment|/**    * Turn speculative execution on or off for this job for map tasks.     *     * @param speculativeExecution<code>true</code> if speculative execution     *                             should be turned on for map tasks,    *                             else<code>false</code>.    */
DECL|method|setMapSpeculativeExecution (boolean speculativeExecution)
specifier|public
name|void
name|setMapSpeculativeExecution
parameter_list|(
name|boolean
name|speculativeExecution
parameter_list|)
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setMapSpeculativeExecution
argument_list|(
name|speculativeExecution
argument_list|)
expr_stmt|;
block|}
comment|/**    * Turn speculative execution on or off for this job for reduce tasks.     *     * @param speculativeExecution<code>true</code> if speculative execution     *                             should be turned on for reduce tasks,    *                             else<code>false</code>.    */
DECL|method|setReduceSpeculativeExecution (boolean speculativeExecution)
specifier|public
name|void
name|setReduceSpeculativeExecution
parameter_list|(
name|boolean
name|speculativeExecution
parameter_list|)
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setReduceSpeculativeExecution
argument_list|(
name|speculativeExecution
argument_list|)
expr_stmt|;
block|}
comment|/**    * Specify whether job-setup and job-cleanup is needed for the job     *     * @param needed If<code>true</code>, job-setup and job-cleanup will be    *               considered from {@link OutputCommitter}     *               else ignored.    */
DECL|method|setJobSetupCleanupNeeded (boolean needed)
specifier|public
name|void
name|setJobSetupCleanupNeeded
parameter_list|(
name|boolean
name|needed
parameter_list|)
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|SETUP_CLEANUP_NEEDED
argument_list|,
name|needed
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the given set of archives    * @param archives The list of archives that need to be localized    */
DECL|method|setCacheArchives (URI[] archives)
specifier|public
name|void
name|setCacheArchives
parameter_list|(
name|URI
index|[]
name|archives
parameter_list|)
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|DistributedCache
operator|.
name|setCacheArchives
argument_list|(
name|archives
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the given set of files    * @param files The list of files that need to be localized    */
DECL|method|setCacheFiles (URI[] files)
specifier|public
name|void
name|setCacheFiles
parameter_list|(
name|URI
index|[]
name|files
parameter_list|)
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|DistributedCache
operator|.
name|setCacheFiles
argument_list|(
name|files
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a archives to be localized    * @param uri The uri of the cache to be localized    */
DECL|method|addCacheArchive (URI uri)
specifier|public
name|void
name|addCacheArchive
parameter_list|(
name|URI
name|uri
parameter_list|)
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|DistributedCache
operator|.
name|addCacheArchive
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a file to be localized    * @param uri The uri of the cache to be localized    */
DECL|method|addCacheFile (URI uri)
specifier|public
name|void
name|addCacheFile
parameter_list|(
name|URI
name|uri
parameter_list|)
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|DistributedCache
operator|.
name|addCacheFile
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add an file path to the current set of classpath entries It adds the file    * to cache as well.    *     * Files added with this method will not be unpacked while being added to the    * classpath.    * To add archives to classpath, use the {@link #addArchiveToClassPath(Path)}    * method instead.    *    * @param file Path of the file to be added    */
DECL|method|addFileToClassPath (Path file)
specifier|public
name|void
name|addFileToClassPath
parameter_list|(
name|Path
name|file
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|DistributedCache
operator|.
name|addFileToClassPath
argument_list|(
name|file
argument_list|,
name|conf
argument_list|,
name|file
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add an archive path to the current set of classpath entries. It adds the    * archive to cache as well.    *     * Archive files will be unpacked and added to the classpath    * when being distributed.    *    * @param archive Path of the archive to be added    */
DECL|method|addArchiveToClassPath (Path archive)
specifier|public
name|void
name|addArchiveToClassPath
parameter_list|(
name|Path
name|archive
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|DistributedCache
operator|.
name|addArchiveToClassPath
argument_list|(
name|archive
argument_list|,
name|conf
argument_list|,
name|archive
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Originally intended to enable symlinks, but currently symlinks cannot be    * disabled.    */
annotation|@
name|Deprecated
DECL|method|createSymlink ()
specifier|public
name|void
name|createSymlink
parameter_list|()
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|DistributedCache
operator|.
name|createSymlink
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**     * Expert: Set the number of maximum attempts that will be made to run a    * map task.    *     * @param n the number of attempts per map task.    */
DECL|method|setMaxMapAttempts (int n)
specifier|public
name|void
name|setMaxMapAttempts
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setMaxMapAttempts
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
comment|/**     * Expert: Set the number of maximum attempts that will be made to run a    * reduce task.    *     * @param n the number of attempts per reduce task.    */
DECL|method|setMaxReduceAttempts (int n)
specifier|public
name|void
name|setMaxReduceAttempts
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setMaxReduceAttempts
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set whether the system should collect profiler information for some of     * the tasks in this job? The information is stored in the user log     * directory.    * @param newValue true means it should be gathered    */
DECL|method|setProfileEnabled (boolean newValue)
specifier|public
name|void
name|setProfileEnabled
parameter_list|(
name|boolean
name|newValue
parameter_list|)
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setProfileEnabled
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the profiler configuration arguments. If the string contains a '%s' it    * will be replaced with the name of the profiling output file when the task    * runs.    *    * This value is passed to the task child JVM on the command line.    *    * @param value the configuration string    */
DECL|method|setProfileParams (String value)
specifier|public
name|void
name|setProfileParams
parameter_list|(
name|String
name|value
parameter_list|)
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setProfileParams
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the ranges of maps or reduces to profile. setProfileEnabled(true)     * must also be called.    * @param newValue a set of integer ranges of the map ids    */
DECL|method|setProfileTaskRange (boolean isMap, String newValue)
specifier|public
name|void
name|setProfileTaskRange
parameter_list|(
name|boolean
name|isMap
parameter_list|,
name|String
name|newValue
parameter_list|)
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setProfileTaskRange
argument_list|(
name|isMap
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
block|}
DECL|method|ensureNotSet (String attr, String msg)
specifier|private
name|void
name|ensureNotSet
parameter_list|(
name|String
name|attr
parameter_list|,
name|String
name|msg
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|conf
operator|.
name|get
argument_list|(
name|attr
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|attr
operator|+
literal|" is incompatible with "
operator|+
name|msg
operator|+
literal|" mode."
argument_list|)
throw|;
block|}
block|}
comment|/**    * Sets the flag that will allow the JobTracker to cancel the HDFS delegation    * tokens upon job completion. Defaults to true.    */
DECL|method|setCancelDelegationTokenUponJobCompletion (boolean value)
specifier|public
name|void
name|setCancelDelegationTokenUponJobCompletion
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|conf
operator|.
name|setBoolean
argument_list|(
name|JOB_CANCEL_DELEGATION_TOKEN
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/**    * Default to the new APIs unless they are explicitly set or the old mapper or    * reduce attributes are used.    * @throws IOException if the configuration is inconsistent    */
DECL|method|setUseNewAPI ()
specifier|private
name|void
name|setUseNewAPI
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|numReduces
init|=
name|conf
operator|.
name|getNumReduceTasks
argument_list|()
decl_stmt|;
name|String
name|oldMapperClass
init|=
literal|"mapred.mapper.class"
decl_stmt|;
name|String
name|oldReduceClass
init|=
literal|"mapred.reducer.class"
decl_stmt|;
name|conf
operator|.
name|setBooleanIfUnset
argument_list|(
literal|"mapred.mapper.new-api"
argument_list|,
name|conf
operator|.
name|get
argument_list|(
name|oldMapperClass
argument_list|)
operator|==
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getUseNewMapper
argument_list|()
condition|)
block|{
name|String
name|mode
init|=
literal|"new map API"
decl_stmt|;
name|ensureNotSet
argument_list|(
literal|"mapred.input.format.class"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|ensureNotSet
argument_list|(
name|oldMapperClass
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|numReduces
operator|!=
literal|0
condition|)
block|{
name|ensureNotSet
argument_list|(
literal|"mapred.partitioner.class"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ensureNotSet
argument_list|(
literal|"mapred.output.format.class"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|String
name|mode
init|=
literal|"map compatibility"
decl_stmt|;
name|ensureNotSet
argument_list|(
name|INPUT_FORMAT_CLASS_ATTR
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|ensureNotSet
argument_list|(
name|MAP_CLASS_ATTR
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|numReduces
operator|!=
literal|0
condition|)
block|{
name|ensureNotSet
argument_list|(
name|PARTITIONER_CLASS_ATTR
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ensureNotSet
argument_list|(
name|OUTPUT_FORMAT_CLASS_ATTR
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|numReduces
operator|!=
literal|0
condition|)
block|{
name|conf
operator|.
name|setBooleanIfUnset
argument_list|(
literal|"mapred.reducer.new-api"
argument_list|,
name|conf
operator|.
name|get
argument_list|(
name|oldReduceClass
argument_list|)
operator|==
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getUseNewReducer
argument_list|()
condition|)
block|{
name|String
name|mode
init|=
literal|"new reduce API"
decl_stmt|;
name|ensureNotSet
argument_list|(
literal|"mapred.output.format.class"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|ensureNotSet
argument_list|(
name|oldReduceClass
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|mode
init|=
literal|"reduce compatibility"
decl_stmt|;
name|ensureNotSet
argument_list|(
name|OUTPUT_FORMAT_CLASS_ATTR
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|ensureNotSet
argument_list|(
name|REDUCE_CLASS_ATTR
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Add a file to job config for shared cache processing. If shared cache is    * enabled, it will return true, otherwise, return false. We don't check with    * SCM here given application might not be able to provide the job id;    * ClientSCMProtocol.use requires the application id. Job Submitter will read    * the files from job config and take care of things.    *    * @param resource The resource that Job Submitter will process later using    *          shared cache.    * @param conf Configuration to add the resource to    * @return whether the resource has been added to the configuration    */
annotation|@
name|Unstable
DECL|method|addFileToSharedCache (URI resource, Configuration conf)
specifier|public
specifier|static
name|boolean
name|addFileToSharedCache
parameter_list|(
name|URI
name|resource
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|SharedCacheConfig
name|scConfig
init|=
operator|new
name|SharedCacheConfig
argument_list|()
decl_stmt|;
name|scConfig
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|scConfig
operator|.
name|isSharedCacheFilesEnabled
argument_list|()
condition|)
block|{
name|String
name|files
init|=
name|conf
operator|.
name|get
argument_list|(
name|MRJobConfig
operator|.
name|FILES_FOR_SHARED_CACHE
argument_list|)
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|MRJobConfig
operator|.
name|FILES_FOR_SHARED_CACHE
argument_list|,
name|files
operator|==
literal|null
condition|?
name|resource
operator|.
name|toString
argument_list|()
else|:
name|files
operator|+
literal|","
operator|+
name|resource
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Add a file to job config for shared cache processing. If shared cache is    * enabled, it will return true, otherwise, return false. We don't check with    * SCM here given application might not be able to provide the job id;    * ClientSCMProtocol.use requires the application id. Job Submitter will read    * the files from job config and take care of things. Job Submitter will also    * add the file to classpath. Intended to be used by user code.    *    * @param resource The resource that Job Submitter will process later using    *          shared cache.    * @param conf Configuration to add the resource to    * @return whether the resource has been added to the configuration    */
annotation|@
name|Unstable
DECL|method|addFileToSharedCacheAndClasspath (URI resource, Configuration conf)
specifier|public
specifier|static
name|boolean
name|addFileToSharedCacheAndClasspath
parameter_list|(
name|URI
name|resource
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|SharedCacheConfig
name|scConfig
init|=
operator|new
name|SharedCacheConfig
argument_list|()
decl_stmt|;
name|scConfig
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|scConfig
operator|.
name|isSharedCacheLibjarsEnabled
argument_list|()
condition|)
block|{
name|String
name|files
init|=
name|conf
operator|.
name|get
argument_list|(
name|MRJobConfig
operator|.
name|FILES_FOR_CLASSPATH_AND_SHARED_CACHE
argument_list|)
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|MRJobConfig
operator|.
name|FILES_FOR_CLASSPATH_AND_SHARED_CACHE
argument_list|,
name|files
operator|==
literal|null
condition|?
name|resource
operator|.
name|toString
argument_list|()
else|:
name|files
operator|+
literal|","
operator|+
name|resource
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Add an archive to job config for shared cache processing. If shared cache    * is enabled, it will return true, otherwise, return false. We don't check    * with SCM here given application might not be able to provide the job id;    * ClientSCMProtocol.use requires the application id. Job Submitter will read    * the files from job config and take care of things. Intended to be used by    * user code.    *    * @param resource The resource that Job Submitter will process later using    *          shared cache.    * @param conf Configuration to add the resource to    * @return whether the resource has been added to the configuration    */
annotation|@
name|Unstable
DECL|method|addArchiveToSharedCache (URI resource, Configuration conf)
specifier|public
specifier|static
name|boolean
name|addArchiveToSharedCache
parameter_list|(
name|URI
name|resource
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|SharedCacheConfig
name|scConfig
init|=
operator|new
name|SharedCacheConfig
argument_list|()
decl_stmt|;
name|scConfig
operator|.
name|init
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|scConfig
operator|.
name|isSharedCacheArchivesEnabled
argument_list|()
condition|)
block|{
name|String
name|files
init|=
name|conf
operator|.
name|get
argument_list|(
name|MRJobConfig
operator|.
name|ARCHIVES_FOR_SHARED_CACHE
argument_list|)
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|MRJobConfig
operator|.
name|ARCHIVES_FOR_SHARED_CACHE
argument_list|,
name|files
operator|==
literal|null
condition|?
name|resource
operator|.
name|toString
argument_list|()
else|:
name|files
operator|+
literal|","
operator|+
name|resource
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    * This is to set the shared cache upload policies for files. If the parameter    * was previously set, this method will replace the old value with the new    * provided map.    *    * @param conf Configuration which stores the shared cache upload policies    * @param policies A map containing the shared cache upload policies for a set    *          of resources. The key is the url of the resource and the value is    *          the upload policy. True if it should be uploaded, false otherwise.    */
annotation|@
name|Unstable
DECL|method|setFileSharedCacheUploadPolicies (Configuration conf, Map<String, Boolean> policies)
specifier|public
specifier|static
name|void
name|setFileSharedCacheUploadPolicies
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|policies
parameter_list|)
block|{
name|setSharedCacheUploadPolicies
argument_list|(
name|conf
argument_list|,
name|policies
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * This is to set the shared cache upload policies for archives. If the    * parameter was previously set, this method will replace the old value with    * the new provided map.    *    * @param conf Configuration which stores the shared cache upload policies    * @param policies A map containing the shared cache upload policies for a set    *          of resources. The key is the url of the resource and the value is    *          the upload policy. True if it should be uploaded, false otherwise.    */
annotation|@
name|Unstable
DECL|method|setArchiveSharedCacheUploadPolicies (Configuration conf, Map<String, Boolean> policies)
specifier|public
specifier|static
name|void
name|setArchiveSharedCacheUploadPolicies
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|policies
parameter_list|)
block|{
name|setSharedCacheUploadPolicies
argument_list|(
name|conf
argument_list|,
name|policies
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// We use a double colon because a colon is a reserved character in a URI and
comment|// there should not be two colons next to each other.
DECL|field|DELIM
specifier|private
specifier|static
specifier|final
name|String
name|DELIM
init|=
literal|"::"
decl_stmt|;
comment|/**    * Set the shared cache upload policies config parameter. This is done by    * serializing the provided map of shared cache upload policies into a config    * parameter. If the parameter was previously set, this method will replace    * the old value with the new provided map.    *    * @param conf Configuration which stores the shared cache upload policies    * @param policies A map containing the shared cache upload policies for a set    *          of resources. The key is the url of the resource and the value is    *          the upload policy. True if it should be uploaded, false otherwise.    * @param areFiles True if these policies are for files, false if they are for    *          archives.    */
DECL|method|setSharedCacheUploadPolicies (Configuration conf, Map<String, Boolean> policies, boolean areFiles)
specifier|private
specifier|static
name|void
name|setSharedCacheUploadPolicies
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|policies
parameter_list|,
name|boolean
name|areFiles
parameter_list|)
block|{
if|if
condition|(
name|policies
operator|!=
literal|null
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
argument_list|>
name|it
init|=
name|policies
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|e
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|e
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
operator|+
name|DELIM
operator|+
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// policies is an empty map, just skip setting the parameter
return|return;
block|}
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|e
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|","
operator|+
name|e
operator|.
name|getKey
argument_list|()
operator|+
name|DELIM
operator|+
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
name|confParam
init|=
name|areFiles
condition|?
name|MRJobConfig
operator|.
name|CACHE_FILES_SHARED_CACHE_UPLOAD_POLICIES
else|:
name|MRJobConfig
operator|.
name|CACHE_ARCHIVES_SHARED_CACHE_UPLOAD_POLICIES
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|confParam
argument_list|,
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Deserialize a map of shared cache upload policies from a config parameter.    *    * @param conf Configuration which stores the shared cache upload policies    * @param areFiles True if these policies are for files, false if they are for    *          archives.    * @return A map containing the shared cache upload policies for a set of    *         resources. The key is the url of the resource and the value is the    *         upload policy. True if it should be uploaded, false otherwise.    */
DECL|method|getSharedCacheUploadPolicies ( Configuration conf, boolean areFiles)
specifier|private
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|getSharedCacheUploadPolicies
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|areFiles
parameter_list|)
block|{
name|String
name|confParam
init|=
name|areFiles
condition|?
name|MRJobConfig
operator|.
name|CACHE_FILES_SHARED_CACHE_UPLOAD_POLICIES
else|:
name|MRJobConfig
operator|.
name|CACHE_ARCHIVES_SHARED_CACHE_UPLOAD_POLICIES
decl_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|policies
init|=
name|conf
operator|.
name|getStringCollection
argument_list|(
name|confParam
argument_list|)
decl_stmt|;
name|String
index|[]
name|policy
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|policyMap
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|s
range|:
name|policies
control|)
block|{
name|policy
operator|=
name|s
operator|.
name|split
argument_list|(
name|DELIM
argument_list|)
expr_stmt|;
if|if
condition|(
name|policy
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|confParam
operator|+
literal|" is mis-formatted, returning empty shared cache upload policies."
operator|+
literal|" Error on ["
operator|+
name|s
operator|+
literal|"]"
argument_list|)
expr_stmt|;
return|return
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
argument_list|()
return|;
block|}
name|policyMap
operator|.
name|put
argument_list|(
name|policy
index|[
literal|0
index|]
argument_list|,
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|policy
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|policyMap
return|;
block|}
comment|/**    * This is to get the shared cache upload policies for files.    *    * @param conf Configuration which stores the shared cache upload policies    * @return A map containing the shared cache upload policies for a set of    *         resources. The key is the url of the resource and the value is the    *         upload policy. True if it should be uploaded, false otherwise.    */
annotation|@
name|Unstable
DECL|method|getFileSharedCacheUploadPolicies ( Configuration conf)
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|getFileSharedCacheUploadPolicies
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|getSharedCacheUploadPolicies
argument_list|(
name|conf
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * This is to get the shared cache upload policies for archives.    *    * @param conf Configuration which stores the shared cache upload policies    * @return A map containing the shared cache upload policies for a set of    *         resources. The key is the url of the resource and the value is the    *         upload policy. True if it should be uploaded, false otherwise.    */
annotation|@
name|Unstable
DECL|method|getArchiveSharedCacheUploadPolicies ( Configuration conf)
specifier|public
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|Boolean
argument_list|>
name|getArchiveSharedCacheUploadPolicies
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|getSharedCacheUploadPolicies
argument_list|(
name|conf
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|connect ()
specifier|private
specifier|synchronized
name|void
name|connect
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|ClassNotFoundException
block|{
if|if
condition|(
name|cluster
operator|==
literal|null
condition|)
block|{
name|cluster
operator|=
name|ugi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Cluster
argument_list|>
argument_list|()
block|{
specifier|public
name|Cluster
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|ClassNotFoundException
block|{
return|return
operator|new
name|Cluster
argument_list|(
name|getConfiguration
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|isConnected ()
name|boolean
name|isConnected
parameter_list|()
block|{
return|return
name|cluster
operator|!=
literal|null
return|;
block|}
comment|/** Only for mocking via unit tests. */
annotation|@
name|Private
DECL|method|getJobSubmitter (FileSystem fs, ClientProtocol submitClient)
specifier|public
name|JobSubmitter
name|getJobSubmitter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|ClientProtocol
name|submitClient
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|JobSubmitter
argument_list|(
name|fs
argument_list|,
name|submitClient
argument_list|)
return|;
block|}
comment|/**    * Submit the job to the cluster and return immediately.    * @throws IOException    */
DECL|method|submit ()
specifier|public
name|void
name|submit
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|ClassNotFoundException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|DEFINE
argument_list|)
expr_stmt|;
name|setUseNewAPI
argument_list|()
expr_stmt|;
name|connect
argument_list|()
expr_stmt|;
specifier|final
name|JobSubmitter
name|submitter
init|=
name|getJobSubmitter
argument_list|(
name|cluster
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|cluster
operator|.
name|getClient
argument_list|()
argument_list|)
decl_stmt|;
name|status
operator|=
name|ugi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|JobStatus
argument_list|>
argument_list|()
block|{
specifier|public
name|JobStatus
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|ClassNotFoundException
block|{
return|return
name|submitter
operator|.
name|submitJobInternal
argument_list|(
name|Job
operator|.
name|this
argument_list|,
name|cluster
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|state
operator|=
name|JobState
operator|.
name|RUNNING
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"The url to track the job: "
operator|+
name|getTrackingURL
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Submit the job to the cluster and wait for it to finish.    * @param verbose print the progress to the user    * @return true if the job succeeded    * @throws IOException thrown if the communication with the     *<code>JobTracker</code> is lost    */
DECL|method|waitForCompletion (boolean verbose )
specifier|public
name|boolean
name|waitForCompletion
parameter_list|(
name|boolean
name|verbose
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|ClassNotFoundException
block|{
if|if
condition|(
name|state
operator|==
name|JobState
operator|.
name|DEFINE
condition|)
block|{
name|submit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
block|{
name|monitorAndPrintJob
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// get the completion poll interval from the client.
name|int
name|completionPollIntervalMillis
init|=
name|Job
operator|.
name|getCompletionPollInterval
argument_list|(
name|cluster
operator|.
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|isComplete
argument_list|()
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|completionPollIntervalMillis
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{         }
block|}
block|}
return|return
name|isSuccessful
argument_list|()
return|;
block|}
comment|/**    * Monitor a job and print status in real-time as progress is made and tasks     * fail.    * @return true if the job succeeded    * @throws IOException if communication to the JobTracker fails    */
DECL|method|monitorAndPrintJob ()
specifier|public
name|boolean
name|monitorAndPrintJob
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|String
name|lastReport
init|=
literal|null
decl_stmt|;
name|Job
operator|.
name|TaskStatusFilter
name|filter
decl_stmt|;
name|Configuration
name|clientConf
init|=
name|getConfiguration
argument_list|()
decl_stmt|;
name|filter
operator|=
name|Job
operator|.
name|getTaskOutputFilter
argument_list|(
name|clientConf
argument_list|)
expr_stmt|;
name|JobID
name|jobId
init|=
name|getJobID
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Running job: "
operator|+
name|jobId
argument_list|)
expr_stmt|;
name|int
name|eventCounter
init|=
literal|0
decl_stmt|;
name|boolean
name|profiling
init|=
name|getProfileEnabled
argument_list|()
decl_stmt|;
name|IntegerRanges
name|mapRanges
init|=
name|getProfileTaskRange
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|IntegerRanges
name|reduceRanges
init|=
name|getProfileTaskRange
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|int
name|progMonitorPollIntervalMillis
init|=
name|Job
operator|.
name|getProgressPollInterval
argument_list|(
name|clientConf
argument_list|)
decl_stmt|;
comment|/* make sure to report full progress after the job is done */
name|boolean
name|reportedAfterCompletion
init|=
literal|false
decl_stmt|;
name|boolean
name|reportedUberMode
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|isComplete
argument_list|()
operator|||
operator|!
name|reportedAfterCompletion
condition|)
block|{
if|if
condition|(
name|isComplete
argument_list|()
condition|)
block|{
name|reportedAfterCompletion
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|progMonitorPollIntervalMillis
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|.
name|getState
argument_list|()
operator|==
name|JobStatus
operator|.
name|State
operator|.
name|PREP
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|reportedUberMode
condition|)
block|{
name|reportedUberMode
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Job "
operator|+
name|jobId
operator|+
literal|" running in uber mode : "
operator|+
name|isUber
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|String
name|report
init|=
operator|(
literal|" map "
operator|+
name|StringUtils
operator|.
name|formatPercent
argument_list|(
name|mapProgress
argument_list|()
argument_list|,
literal|0
argument_list|)
operator|+
literal|" reduce "
operator|+
name|StringUtils
operator|.
name|formatPercent
argument_list|(
name|reduceProgress
argument_list|()
argument_list|,
literal|0
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|report
operator|.
name|equals
argument_list|(
name|lastReport
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|report
argument_list|)
expr_stmt|;
name|lastReport
operator|=
name|report
expr_stmt|;
block|}
name|TaskCompletionEvent
index|[]
name|events
init|=
name|getTaskCompletionEvents
argument_list|(
name|eventCounter
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|eventCounter
operator|+=
name|events
operator|.
name|length
expr_stmt|;
name|printTaskEvents
argument_list|(
name|events
argument_list|,
name|filter
argument_list|,
name|profiling
argument_list|,
name|mapRanges
argument_list|,
name|reduceRanges
argument_list|)
expr_stmt|;
block|}
name|boolean
name|success
init|=
name|isSuccessful
argument_list|()
decl_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Job "
operator|+
name|jobId
operator|+
literal|" completed successfully"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Job "
operator|+
name|jobId
operator|+
literal|" failed with state "
operator|+
name|status
operator|.
name|getState
argument_list|()
operator|+
literal|" due to: "
operator|+
name|status
operator|.
name|getFailureInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Counters
name|counters
init|=
name|getCounters
argument_list|()
decl_stmt|;
if|if
condition|(
name|counters
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|counters
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
DECL|method|printTaskEvents (TaskCompletionEvent[] events, Job.TaskStatusFilter filter, boolean profiling, IntegerRanges mapRanges, IntegerRanges reduceRanges)
specifier|private
name|void
name|printTaskEvents
parameter_list|(
name|TaskCompletionEvent
index|[]
name|events
parameter_list|,
name|Job
operator|.
name|TaskStatusFilter
name|filter
parameter_list|,
name|boolean
name|profiling
parameter_list|,
name|IntegerRanges
name|mapRanges
parameter_list|,
name|IntegerRanges
name|reduceRanges
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
for|for
control|(
name|TaskCompletionEvent
name|event
range|:
name|events
control|)
block|{
switch|switch
condition|(
name|filter
condition|)
block|{
case|case
name|NONE
case|:
break|break;
case|case
name|SUCCEEDED
case|:
if|if
condition|(
name|event
operator|.
name|getStatus
argument_list|()
operator|==
name|TaskCompletionEvent
operator|.
name|Status
operator|.
name|SUCCEEDED
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|event
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FAILED
case|:
if|if
condition|(
name|event
operator|.
name|getStatus
argument_list|()
operator|==
name|TaskCompletionEvent
operator|.
name|Status
operator|.
name|FAILED
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|event
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Displaying the task diagnostic information
name|TaskAttemptID
name|taskId
init|=
name|event
operator|.
name|getTaskAttemptId
argument_list|()
decl_stmt|;
name|String
index|[]
name|taskDiagnostics
init|=
name|getTaskDiagnostics
argument_list|(
name|taskId
argument_list|)
decl_stmt|;
if|if
condition|(
name|taskDiagnostics
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|diagnostics
range|:
name|taskDiagnostics
control|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|diagnostics
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|KILLED
case|:
if|if
condition|(
name|event
operator|.
name|getStatus
argument_list|()
operator|==
name|TaskCompletionEvent
operator|.
name|Status
operator|.
name|KILLED
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|event
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ALL
case|:
name|LOG
operator|.
name|info
argument_list|(
name|event
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/** The interval at which monitorAndPrintJob() prints status */
DECL|method|getProgressPollInterval (Configuration conf)
specifier|public
specifier|static
name|int
name|getProgressPollInterval
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
comment|// Read progress monitor poll interval from config. Default is 1 second.
name|int
name|progMonitorPollIntervalMillis
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|PROGRESS_MONITOR_POLL_INTERVAL_KEY
argument_list|,
name|DEFAULT_MONITOR_POLL_INTERVAL
argument_list|)
decl_stmt|;
if|if
condition|(
name|progMonitorPollIntervalMillis
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|PROGRESS_MONITOR_POLL_INTERVAL_KEY
operator|+
literal|" has been set to an invalid value; "
operator|+
literal|" replacing with "
operator|+
name|DEFAULT_MONITOR_POLL_INTERVAL
argument_list|)
expr_stmt|;
name|progMonitorPollIntervalMillis
operator|=
name|DEFAULT_MONITOR_POLL_INTERVAL
expr_stmt|;
block|}
return|return
name|progMonitorPollIntervalMillis
return|;
block|}
comment|/** The interval at which waitForCompletion() should check. */
DECL|method|getCompletionPollInterval (Configuration conf)
specifier|public
specifier|static
name|int
name|getCompletionPollInterval
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|int
name|completionPollIntervalMillis
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|COMPLETION_POLL_INTERVAL_KEY
argument_list|,
name|DEFAULT_COMPLETION_POLL_INTERVAL
argument_list|)
decl_stmt|;
if|if
condition|(
name|completionPollIntervalMillis
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|COMPLETION_POLL_INTERVAL_KEY
operator|+
literal|" has been set to an invalid value; "
operator|+
literal|"replacing with "
operator|+
name|DEFAULT_COMPLETION_POLL_INTERVAL
argument_list|)
expr_stmt|;
name|completionPollIntervalMillis
operator|=
name|DEFAULT_COMPLETION_POLL_INTERVAL
expr_stmt|;
block|}
return|return
name|completionPollIntervalMillis
return|;
block|}
comment|/**    * Get the task output filter.    *     * @param conf the configuration.    * @return the filter level.    */
DECL|method|getTaskOutputFilter (Configuration conf)
specifier|public
specifier|static
name|TaskStatusFilter
name|getTaskOutputFilter
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|TaskStatusFilter
operator|.
name|valueOf
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|Job
operator|.
name|OUTPUT_FILTER
argument_list|,
literal|"FAILED"
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Modify the Configuration to set the task output filter.    *     * @param conf the Configuration to modify.    * @param newValue the value to set.    */
DECL|method|setTaskOutputFilter (Configuration conf, TaskStatusFilter newValue)
specifier|public
specifier|static
name|void
name|setTaskOutputFilter
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|TaskStatusFilter
name|newValue
parameter_list|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|Job
operator|.
name|OUTPUT_FILTER
argument_list|,
name|newValue
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|isUber ()
specifier|public
name|boolean
name|isUber
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|ensureState
argument_list|(
name|JobState
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
name|updateStatus
argument_list|()
expr_stmt|;
return|return
name|status
operator|.
name|isUber
argument_list|()
return|;
block|}
comment|/**    * Get the reservation to which the job is submitted to, if any    *    * @return the reservationId the identifier of the job's reservation, null if    *         the job does not have any reservation associated with it    */
DECL|method|getReservationId ()
specifier|public
name|ReservationId
name|getReservationId
parameter_list|()
block|{
return|return
name|reservationId
return|;
block|}
comment|/**    * Set the reservation to which the job is submitted to    *    * @param reservationId the reservationId to set    */
DECL|method|setReservationId (ReservationId reservationId)
specifier|public
name|void
name|setReservationId
parameter_list|(
name|ReservationId
name|reservationId
parameter_list|)
block|{
name|this
operator|.
name|reservationId
operator|=
name|reservationId
expr_stmt|;
block|}
comment|/**    * Close the<code>Job</code>.    * @throws IOException if fail to close.    */
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|close
argument_list|()
expr_stmt|;
name|cluster
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

