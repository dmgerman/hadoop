begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocalDirAllocator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|DataInputBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|DataOutputBuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|IFile
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|IFile
operator|.
name|Writer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Merger
operator|.
name|Segment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRJobConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|CryptoUtils
import|;
end_import

begin_comment
comment|/**  *<code>BackupStore</code> is an utility class that is used to support  * the mark-reset functionality of values iterator  *  *<p>It has two caches - a memory cache and a file cache where values are  * stored as they are iterated, after a mark. On reset, values are retrieved  * from these caches. Framework moves from the memory cache to the   * file cache when the memory cache becomes full.  *   */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|BackupStore
specifier|public
class|class
name|BackupStore
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|BackupStore
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|MAX_VINT_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|MAX_VINT_SIZE
init|=
literal|9
decl_stmt|;
DECL|field|EOF_MARKER_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|EOF_MARKER_SIZE
init|=
literal|2
operator|*
name|MAX_VINT_SIZE
decl_stmt|;
DECL|field|tid
specifier|private
specifier|final
name|TaskAttemptID
name|tid
decl_stmt|;
DECL|field|memCache
specifier|private
name|MemoryCache
name|memCache
decl_stmt|;
DECL|field|fileCache
specifier|private
name|FileCache
name|fileCache
decl_stmt|;
DECL|field|segmentList
name|List
argument_list|<
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|segmentList
init|=
operator|new
name|LinkedList
argument_list|<
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|readSegmentIndex
specifier|private
name|int
name|readSegmentIndex
init|=
literal|0
decl_stmt|;
DECL|field|firstSegmentOffset
specifier|private
name|int
name|firstSegmentOffset
init|=
literal|0
decl_stmt|;
DECL|field|currentKVOffset
specifier|private
name|int
name|currentKVOffset
init|=
literal|0
decl_stmt|;
DECL|field|nextKVOffset
specifier|private
name|int
name|nextKVOffset
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|currentKey
specifier|private
name|DataInputBuffer
name|currentKey
init|=
literal|null
decl_stmt|;
DECL|field|currentValue
specifier|private
name|DataInputBuffer
name|currentValue
init|=
operator|new
name|DataInputBuffer
argument_list|()
decl_stmt|;
DECL|field|currentDiskValue
specifier|private
name|DataInputBuffer
name|currentDiskValue
init|=
operator|new
name|DataInputBuffer
argument_list|()
decl_stmt|;
DECL|field|hasMore
specifier|private
name|boolean
name|hasMore
init|=
literal|false
decl_stmt|;
DECL|field|inReset
specifier|private
name|boolean
name|inReset
init|=
literal|false
decl_stmt|;
DECL|field|clearMarkFlag
specifier|private
name|boolean
name|clearMarkFlag
init|=
literal|false
decl_stmt|;
DECL|field|lastSegmentEOF
specifier|private
name|boolean
name|lastSegmentEOF
init|=
literal|false
decl_stmt|;
DECL|field|conf
specifier|private
name|Configuration
name|conf
decl_stmt|;
DECL|method|BackupStore (Configuration conf, TaskAttemptID taskid)
specifier|public
name|BackupStore
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|TaskAttemptID
name|taskid
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|float
name|bufferPercent
init|=
name|conf
operator|.
name|getFloat
argument_list|(
name|JobContext
operator|.
name|REDUCE_MARKRESET_BUFFER_PERCENT
argument_list|,
literal|0f
argument_list|)
decl_stmt|;
if|if
condition|(
name|bufferPercent
operator|>
literal|1.0
operator|||
name|bufferPercent
operator|<
literal|0.0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|JobContext
operator|.
name|REDUCE_MARKRESET_BUFFER_PERCENT
operator|+
name|bufferPercent
argument_list|)
throw|;
block|}
name|int
name|maxSize
init|=
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|maxMemory
argument_list|()
operator|*
name|bufferPercent
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
comment|// Support an absolute size also.
name|int
name|tmp
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|JobContext
operator|.
name|REDUCE_MARKRESET_BUFFER_SIZE
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|>
literal|0
condition|)
block|{
name|maxSize
operator|=
name|tmp
expr_stmt|;
block|}
name|memCache
operator|=
operator|new
name|MemoryCache
argument_list|(
name|maxSize
argument_list|)
expr_stmt|;
name|fileCache
operator|=
operator|new
name|FileCache
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|tid
operator|=
name|taskid
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Created a new BackupStore with a memory of "
operator|+
name|maxSize
argument_list|)
expr_stmt|;
block|}
comment|/**    * Write the given K,V to the cache.     * Write to memcache if space is available, else write to the filecache    * @param key    * @param value    * @throws IOException    */
DECL|method|write (DataInputBuffer key, DataInputBuffer value)
specifier|public
name|void
name|write
parameter_list|(
name|DataInputBuffer
name|key
parameter_list|,
name|DataInputBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
operator|(
name|key
operator|!=
literal|null
operator|&&
name|value
operator|!=
literal|null
operator|)
assert|;
if|if
condition|(
name|fileCache
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|fileCache
operator|.
name|write
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|memCache
operator|.
name|reserveSpace
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
condition|)
block|{
name|memCache
operator|.
name|write
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fileCache
operator|.
name|activate
argument_list|()
expr_stmt|;
name|fileCache
operator|.
name|write
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|mark ()
specifier|public
name|void
name|mark
parameter_list|()
throws|throws
name|IOException
block|{
comment|// We read one KV pair in advance in hasNext.
comment|// If hasNext has read the next KV pair from a new segment, but the
comment|// user has not called next() for that KV, then reset the readSegmentIndex
comment|// to the previous segment
if|if
condition|(
name|nextKVOffset
operator|==
literal|0
condition|)
block|{
assert|assert
operator|(
name|readSegmentIndex
operator|!=
literal|0
operator|)
assert|;
assert|assert
operator|(
name|currentKVOffset
operator|!=
literal|0
operator|)
assert|;
name|readSegmentIndex
operator|--
expr_stmt|;
block|}
comment|// just drop segments before the current active segment
name|int
name|i
init|=
literal|0
decl_stmt|;
name|Iterator
argument_list|<
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|itr
init|=
name|segmentList
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|itr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
init|=
name|itr
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|readSegmentIndex
condition|)
block|{
break|break;
block|}
name|s
operator|.
name|close
argument_list|()
expr_stmt|;
name|itr
operator|.
name|remove
argument_list|()
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Dropping a segment"
argument_list|)
expr_stmt|;
block|}
comment|// FirstSegmentOffset is the offset in the current segment from where we
comment|// need to start reading on the next reset
name|firstSegmentOffset
operator|=
name|currentKVOffset
expr_stmt|;
name|readSegmentIndex
operator|=
literal|0
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Setting the FirsSegmentOffset to "
operator|+
name|currentKVOffset
argument_list|)
expr_stmt|;
block|}
DECL|method|reset ()
specifier|public
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Create a new segment for the previously written records only if we
comment|// are not already in the reset mode
if|if
condition|(
operator|!
name|inReset
condition|)
block|{
if|if
condition|(
name|fileCache
operator|.
name|isActive
condition|)
block|{
name|fileCache
operator|.
name|createInDiskSegment
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|memCache
operator|.
name|createInMemorySegment
argument_list|()
expr_stmt|;
block|}
block|}
name|inReset
operator|=
literal|true
expr_stmt|;
comment|// Reset the segments to the correct position from where the next read
comment|// should begin.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segmentList
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
init|=
name|segmentList
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|inMemory
argument_list|()
condition|)
block|{
name|int
name|offset
init|=
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
name|firstSegmentOffset
else|:
literal|0
decl_stmt|;
name|s
operator|.
name|getReader
argument_list|()
operator|.
name|reset
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|.
name|closeReader
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|s
operator|.
name|reinitReader
argument_list|(
name|firstSegmentOffset
argument_list|)
expr_stmt|;
name|s
operator|.
name|getReader
argument_list|()
operator|.
name|disableChecksumValidation
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|currentKVOffset
operator|=
name|firstSegmentOffset
expr_stmt|;
name|nextKVOffset
operator|=
operator|-
literal|1
expr_stmt|;
name|readSegmentIndex
operator|=
literal|0
expr_stmt|;
name|hasMore
operator|=
literal|false
expr_stmt|;
name|lastSegmentEOF
operator|=
literal|false
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reset - First segment offset is "
operator|+
name|firstSegmentOffset
operator|+
literal|" Segment List Size is "
operator|+
name|segmentList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|lastSegmentEOF
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// We read the next KV from the cache to decide if there is any left.
comment|// Since hasNext can be called several times before the actual call to
comment|// next(), we use hasMore to avoid extra reads. hasMore is set to false
comment|// when the user actually consumes this record in next()
if|if
condition|(
name|hasMore
condition|)
block|{
return|return
literal|true
return|;
block|}
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|seg
init|=
name|segmentList
operator|.
name|get
argument_list|(
name|readSegmentIndex
argument_list|)
decl_stmt|;
comment|// Mark the current position. This would be set to currentKVOffset
comment|// when the user consumes this record in next().
name|nextKVOffset
operator|=
operator|(
name|int
operator|)
name|seg
operator|.
name|getActualPosition
argument_list|()
expr_stmt|;
if|if
condition|(
name|seg
operator|.
name|nextRawKey
argument_list|()
condition|)
block|{
name|currentKey
operator|=
name|seg
operator|.
name|getKey
argument_list|()
expr_stmt|;
name|seg
operator|.
name|getValue
argument_list|(
name|currentValue
argument_list|)
expr_stmt|;
name|hasMore
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|seg
operator|.
name|inMemory
argument_list|()
condition|)
block|{
name|seg
operator|.
name|closeReader
argument_list|()
expr_stmt|;
block|}
block|}
comment|// If this is the last segment, mark the lastSegmentEOF flag and return
if|if
condition|(
name|readSegmentIndex
operator|==
name|segmentList
operator|.
name|size
argument_list|()
operator|-
literal|1
condition|)
block|{
name|nextKVOffset
operator|=
operator|-
literal|1
expr_stmt|;
name|lastSegmentEOF
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
name|nextKVOffset
operator|=
literal|0
expr_stmt|;
name|readSegmentIndex
operator|++
expr_stmt|;
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextSegment
init|=
name|segmentList
operator|.
name|get
argument_list|(
name|readSegmentIndex
argument_list|)
decl_stmt|;
comment|// We possibly are moving from a memory segment to a disk segment.
comment|// Reset so that we do not corrupt the in-memory segment buffer.
comment|// See HADOOP-5494
if|if
condition|(
operator|!
name|nextSegment
operator|.
name|inMemory
argument_list|()
condition|)
block|{
name|currentValue
operator|.
name|reset
argument_list|(
name|currentDiskValue
operator|.
name|getData
argument_list|()
argument_list|,
name|currentDiskValue
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|nextSegment
operator|.
name|init
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nextSegment
operator|.
name|nextRawKey
argument_list|()
condition|)
block|{
name|currentKey
operator|=
name|nextSegment
operator|.
name|getKey
argument_list|()
expr_stmt|;
name|nextSegment
operator|.
name|getValue
argument_list|(
name|currentValue
argument_list|)
expr_stmt|;
name|hasMore
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"New segment did not have even one K/V"
argument_list|)
throw|;
block|}
block|}
DECL|method|next ()
specifier|public
name|void
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|(
literal|"iterate past last value"
argument_list|)
throw|;
block|}
comment|// Reset hasMore. See comment in hasNext()
name|hasMore
operator|=
literal|false
expr_stmt|;
name|currentKVOffset
operator|=
name|nextKVOffset
expr_stmt|;
name|nextKVOffset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
DECL|method|nextValue ()
specifier|public
name|DataInputBuffer
name|nextValue
parameter_list|()
block|{
return|return
name|currentValue
return|;
block|}
DECL|method|nextKey ()
specifier|public
name|DataInputBuffer
name|nextKey
parameter_list|()
block|{
return|return
name|currentKey
return|;
block|}
DECL|method|reinitialize ()
specifier|public
name|void
name|reinitialize
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|segmentList
operator|.
name|size
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|clearSegmentList
argument_list|()
expr_stmt|;
block|}
name|memCache
operator|.
name|reinitialize
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|fileCache
operator|.
name|reinitialize
argument_list|()
expr_stmt|;
name|readSegmentIndex
operator|=
name|firstSegmentOffset
operator|=
literal|0
expr_stmt|;
name|currentKVOffset
operator|=
literal|0
expr_stmt|;
name|nextKVOffset
operator|=
operator|-
literal|1
expr_stmt|;
name|hasMore
operator|=
name|inReset
operator|=
name|clearMarkFlag
operator|=
literal|false
expr_stmt|;
block|}
comment|/**    * This function is called the ValuesIterator when a mark is called    * outside of a reset zone.      */
DECL|method|exitResetMode ()
specifier|public
name|void
name|exitResetMode
parameter_list|()
throws|throws
name|IOException
block|{
name|inReset
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|clearMarkFlag
condition|)
block|{
comment|// If a flag was set to clear mark, do the reinit now.
comment|// See clearMark()
name|reinitialize
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|fileCache
operator|.
name|isActive
condition|)
block|{
name|memCache
operator|.
name|reinitialize
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** For writing the first key and value bytes directly from the    *  value iterators, pass the current underlying output stream    *  @param length The length of the impending write    */
DECL|method|getOutputStream (int length)
specifier|public
name|DataOutputStream
name|getOutputStream
parameter_list|(
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|memCache
operator|.
name|reserveSpace
argument_list|(
name|length
argument_list|)
condition|)
block|{
return|return
name|memCache
operator|.
name|dataOut
return|;
block|}
else|else
block|{
name|fileCache
operator|.
name|activate
argument_list|()
expr_stmt|;
return|return
name|fileCache
operator|.
name|writer
operator|.
name|getOutputStream
argument_list|()
return|;
block|}
block|}
comment|/** This method is called by the valueIterators after writing the first    *  key and value bytes to the BackupStore    * @param length     */
DECL|method|updateCounters (int length)
specifier|public
name|void
name|updateCounters
parameter_list|(
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|fileCache
operator|.
name|isActive
condition|)
block|{
name|fileCache
operator|.
name|writer
operator|.
name|updateCountersForExternalAppend
argument_list|(
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memCache
operator|.
name|usedSize
operator|+=
name|length
expr_stmt|;
block|}
block|}
DECL|method|clearMark ()
specifier|public
name|void
name|clearMark
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|inReset
condition|)
block|{
comment|// If we are in the reset mode, we just mark a flag and come out
comment|// The actual re initialization would be done when we exit the reset
comment|// mode
name|clearMarkFlag
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|reinitialize
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|clearSegmentList ()
specifier|private
name|void
name|clearSegmentList
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
range|:
name|segmentList
control|)
block|{
name|long
name|len
init|=
name|segment
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|segment
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|segment
operator|.
name|inMemory
argument_list|()
condition|)
block|{
name|memCache
operator|.
name|unreserve
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
block|}
name|segmentList
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|class|MemoryCache
class|class
name|MemoryCache
block|{
DECL|field|dataOut
specifier|private
name|DataOutputBuffer
name|dataOut
decl_stmt|;
DECL|field|blockSize
specifier|private
name|int
name|blockSize
decl_stmt|;
DECL|field|usedSize
specifier|private
name|int
name|usedSize
decl_stmt|;
DECL|field|ramManager
specifier|private
specifier|final
name|BackupRamManager
name|ramManager
decl_stmt|;
comment|// Memory cache is made up of blocks.
DECL|field|defaultBlockSize
specifier|private
name|int
name|defaultBlockSize
init|=
literal|1024
operator|*
literal|1024
decl_stmt|;
DECL|method|MemoryCache (int maxSize)
specifier|public
name|MemoryCache
parameter_list|(
name|int
name|maxSize
parameter_list|)
block|{
name|ramManager
operator|=
operator|new
name|BackupRamManager
argument_list|(
name|maxSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxSize
operator|<
name|defaultBlockSize
condition|)
block|{
name|defaultBlockSize
operator|=
name|maxSize
expr_stmt|;
block|}
block|}
DECL|method|unreserve (long len)
specifier|public
name|void
name|unreserve
parameter_list|(
name|long
name|len
parameter_list|)
block|{
name|ramManager
operator|.
name|unreserve
argument_list|(
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
comment|/**      * Re-initialize the memory cache.      *       * @param clearAll If true, re-initialize the ramManager also.      */
DECL|method|reinitialize (boolean clearAll)
name|void
name|reinitialize
parameter_list|(
name|boolean
name|clearAll
parameter_list|)
block|{
if|if
condition|(
name|clearAll
condition|)
block|{
name|ramManager
operator|.
name|reinitialize
argument_list|()
expr_stmt|;
block|}
name|int
name|allocatedSize
init|=
name|createNewMemoryBlock
argument_list|(
name|defaultBlockSize
argument_list|,
name|defaultBlockSize
argument_list|)
decl_stmt|;
assert|assert
operator|(
name|allocatedSize
operator|==
name|defaultBlockSize
operator|||
name|allocatedSize
operator|==
literal|0
operator|)
assert|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created a new mem block of "
operator|+
name|allocatedSize
argument_list|)
expr_stmt|;
block|}
DECL|method|createNewMemoryBlock (int requestedSize, int minSize)
specifier|private
name|int
name|createNewMemoryBlock
parameter_list|(
name|int
name|requestedSize
parameter_list|,
name|int
name|minSize
parameter_list|)
block|{
name|int
name|allocatedSize
init|=
name|ramManager
operator|.
name|reserve
argument_list|(
name|requestedSize
argument_list|,
name|minSize
argument_list|)
decl_stmt|;
name|usedSize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|allocatedSize
operator|==
literal|0
condition|)
block|{
name|dataOut
operator|=
literal|null
expr_stmt|;
name|blockSize
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|dataOut
operator|=
operator|new
name|DataOutputBuffer
argument_list|(
name|allocatedSize
argument_list|)
expr_stmt|;
name|blockSize
operator|=
name|allocatedSize
expr_stmt|;
block|}
return|return
name|allocatedSize
return|;
block|}
comment|/**      * This method determines if there is enough space left in the       * memory cache to write to the requested length + space for      * subsequent EOF makers.      * @param length      * @return true if enough space is available      */
DECL|method|reserveSpace (int length)
name|boolean
name|reserveSpace
parameter_list|(
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|availableSize
init|=
name|blockSize
operator|-
name|usedSize
decl_stmt|;
if|if
condition|(
name|availableSize
operator|>=
name|length
operator|+
name|EOF_MARKER_SIZE
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// Not enough available. Close this block
assert|assert
operator|(
operator|!
name|inReset
operator|)
assert|;
name|createInMemorySegment
argument_list|()
expr_stmt|;
comment|// Create a new block
name|int
name|tmp
init|=
name|Math
operator|.
name|max
argument_list|(
name|length
operator|+
name|EOF_MARKER_SIZE
argument_list|,
name|defaultBlockSize
argument_list|)
decl_stmt|;
name|availableSize
operator|=
name|createNewMemoryBlock
argument_list|(
name|tmp
argument_list|,
operator|(
name|length
operator|+
name|EOF_MARKER_SIZE
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|availableSize
operator|==
literal|0
operator|)
condition|?
literal|false
else|:
literal|true
return|;
block|}
DECL|method|reserveSpace (DataInputBuffer key, DataInputBuffer value)
name|boolean
name|reserveSpace
parameter_list|(
name|DataInputBuffer
name|key
parameter_list|,
name|DataInputBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|keyLength
init|=
name|key
operator|.
name|getLength
argument_list|()
operator|-
name|key
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|int
name|valueLength
init|=
name|value
operator|.
name|getLength
argument_list|()
operator|-
name|value
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|int
name|requestedSize
init|=
name|keyLength
operator|+
name|valueLength
operator|+
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|keyLength
argument_list|)
operator|+
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|valueLength
argument_list|)
decl_stmt|;
return|return
name|reserveSpace
argument_list|(
name|requestedSize
argument_list|)
return|;
block|}
comment|/**      * Write the key and value to the cache in the IFile format      * @param key      * @param value      * @throws IOException      */
DECL|method|write (DataInputBuffer key, DataInputBuffer value)
specifier|public
name|void
name|write
parameter_list|(
name|DataInputBuffer
name|key
parameter_list|,
name|DataInputBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|keyLength
init|=
name|key
operator|.
name|getLength
argument_list|()
operator|-
name|key
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|int
name|valueLength
init|=
name|value
operator|.
name|getLength
argument_list|()
operator|-
name|value
operator|.
name|getPosition
argument_list|()
decl_stmt|;
name|WritableUtils
operator|.
name|writeVInt
argument_list|(
name|dataOut
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
name|WritableUtils
operator|.
name|writeVInt
argument_list|(
name|dataOut
argument_list|,
name|valueLength
argument_list|)
expr_stmt|;
name|dataOut
operator|.
name|write
argument_list|(
name|key
operator|.
name|getData
argument_list|()
argument_list|,
name|key
operator|.
name|getPosition
argument_list|()
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
name|dataOut
operator|.
name|write
argument_list|(
name|value
operator|.
name|getData
argument_list|()
argument_list|,
name|value
operator|.
name|getPosition
argument_list|()
argument_list|,
name|valueLength
argument_list|)
expr_stmt|;
name|usedSize
operator|+=
name|keyLength
operator|+
name|valueLength
operator|+
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|keyLength
argument_list|)
operator|+
name|WritableUtils
operator|.
name|getVIntSize
argument_list|(
name|valueLength
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"ID: "
operator|+
name|segmentList
operator|.
name|size
argument_list|()
operator|+
literal|" WRITE TO MEM"
argument_list|)
expr_stmt|;
block|}
comment|/**      * This method creates a memory segment from the existing buffer      * @throws IOException      */
DECL|method|createInMemorySegment ()
name|void
name|createInMemorySegment
parameter_list|()
throws|throws
name|IOException
block|{
comment|// If nothing was written in this block because the record size
comment|// was greater than the allocated block size, just return.
if|if
condition|(
name|usedSize
operator|==
literal|0
condition|)
block|{
name|ramManager
operator|.
name|unreserve
argument_list|(
name|blockSize
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// spaceAvailable would have ensured that there is enough space
comment|// left for the EOF markers.
assert|assert
operator|(
operator|(
name|blockSize
operator|-
name|usedSize
operator|)
operator|>=
name|EOF_MARKER_SIZE
operator|)
assert|;
name|WritableUtils
operator|.
name|writeVInt
argument_list|(
name|dataOut
argument_list|,
name|IFile
operator|.
name|EOF_MARKER
argument_list|)
expr_stmt|;
name|WritableUtils
operator|.
name|writeVInt
argument_list|(
name|dataOut
argument_list|,
name|IFile
operator|.
name|EOF_MARKER
argument_list|)
expr_stmt|;
name|usedSize
operator|+=
name|EOF_MARKER_SIZE
expr_stmt|;
name|ramManager
operator|.
name|unreserve
argument_list|(
name|blockSize
operator|-
name|usedSize
argument_list|)
expr_stmt|;
name|Reader
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|reader
init|=
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|task
operator|.
name|reduce
operator|.
name|InMemoryReader
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
literal|null
argument_list|,
operator|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|TaskAttemptID
operator|)
name|tid
argument_list|,
name|dataOut
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|usedSize
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
init|=
operator|new
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|reader
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|segmentList
operator|.
name|add
argument_list|(
name|segment
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Added Memory Segment to List. List Size is "
operator|+
name|segmentList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|FileCache
class|class
name|FileCache
block|{
DECL|field|lDirAlloc
specifier|private
name|LocalDirAllocator
name|lDirAlloc
decl_stmt|;
DECL|field|conf
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
DECL|field|fs
specifier|private
specifier|final
name|FileSystem
name|fs
decl_stmt|;
DECL|field|isActive
specifier|private
name|boolean
name|isActive
init|=
literal|false
decl_stmt|;
DECL|field|file
specifier|private
name|Path
name|file
init|=
literal|null
decl_stmt|;
DECL|field|writer
specifier|private
name|IFile
operator|.
name|Writer
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|writer
init|=
literal|null
decl_stmt|;
DECL|field|spillNumber
specifier|private
name|int
name|spillNumber
init|=
literal|0
decl_stmt|;
DECL|method|FileCache (Configuration conf)
specifier|public
name|FileCache
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|fs
operator|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|lDirAlloc
operator|=
operator|new
name|LocalDirAllocator
argument_list|(
name|MRConfig
operator|.
name|LOCAL_DIR
argument_list|)
expr_stmt|;
block|}
DECL|method|write (DataInputBuffer key, DataInputBuffer value)
name|void
name|write
parameter_list|(
name|DataInputBuffer
name|key
parameter_list|,
name|DataInputBuffer
name|value
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|writer
operator|==
literal|null
condition|)
block|{
comment|// If spillNumber is 0, we should have called activate and not
comment|// come here at all
assert|assert
operator|(
name|spillNumber
operator|!=
literal|0
operator|)
assert|;
name|writer
operator|=
name|createSpillFile
argument_list|()
expr_stmt|;
block|}
name|writer
operator|.
name|append
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"ID: "
operator|+
name|segmentList
operator|.
name|size
argument_list|()
operator|+
literal|" WRITE TO DISK"
argument_list|)
expr_stmt|;
block|}
DECL|method|reinitialize ()
name|void
name|reinitialize
parameter_list|()
block|{
name|spillNumber
operator|=
literal|0
expr_stmt|;
name|writer
operator|=
literal|null
expr_stmt|;
name|isActive
operator|=
literal|false
expr_stmt|;
block|}
DECL|method|activate ()
name|void
name|activate
parameter_list|()
throws|throws
name|IOException
block|{
name|isActive
operator|=
literal|true
expr_stmt|;
name|writer
operator|=
name|createSpillFile
argument_list|()
expr_stmt|;
block|}
DECL|method|createInDiskSegment ()
name|void
name|createInDiskSegment
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
operator|(
name|writer
operator|!=
literal|null
operator|)
assert|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
init|=
operator|new
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|,
name|file
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|writer
operator|=
literal|null
expr_stmt|;
name|segmentList
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Disk Segment added to List. Size is "
operator|+
name|segmentList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|isActive ()
name|boolean
name|isActive
parameter_list|()
block|{
return|return
name|isActive
return|;
block|}
DECL|method|createSpillFile ()
specifier|private
name|Writer
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|createSpillFile
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|tmp
init|=
operator|new
name|Path
argument_list|(
name|MRJobConfig
operator|.
name|OUTPUT
operator|+
literal|"/backup_"
operator|+
name|tid
operator|.
name|getId
argument_list|()
operator|+
literal|"_"
operator|+
operator|(
name|spillNumber
operator|++
operator|)
operator|+
literal|".out"
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Created file: "
operator|+
name|tmp
argument_list|)
expr_stmt|;
name|file
operator|=
name|lDirAlloc
operator|.
name|getLocalPathForWrite
argument_list|(
name|tmp
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|FSDataOutputStream
name|out
init|=
name|fs
operator|.
name|create
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|out
operator|=
name|CryptoUtils
operator|.
name|wrapIfNecessary
argument_list|(
name|conf
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return
operator|new
name|Writer
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|conf
argument_list|,
name|out
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
DECL|class|BackupRamManager
specifier|static
class|class
name|BackupRamManager
implements|implements
name|RamManager
block|{
DECL|field|availableSize
specifier|private
name|int
name|availableSize
init|=
literal|0
decl_stmt|;
DECL|field|maxSize
specifier|private
specifier|final
name|int
name|maxSize
decl_stmt|;
DECL|method|BackupRamManager (int size)
specifier|public
name|BackupRamManager
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|availableSize
operator|=
name|maxSize
operator|=
name|size
expr_stmt|;
block|}
DECL|method|reserve (int requestedSize, InputStream in)
specifier|public
name|boolean
name|reserve
parameter_list|(
name|int
name|requestedSize
parameter_list|,
name|InputStream
name|in
parameter_list|)
block|{
comment|// Not used
name|LOG
operator|.
name|warn
argument_list|(
literal|"Reserve(int, InputStream) not supported by BackupRamManager"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
DECL|method|reserve (int requestedSize)
name|int
name|reserve
parameter_list|(
name|int
name|requestedSize
parameter_list|)
block|{
if|if
condition|(
name|availableSize
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|reservedSize
init|=
name|Math
operator|.
name|min
argument_list|(
name|requestedSize
argument_list|,
name|availableSize
argument_list|)
decl_stmt|;
name|availableSize
operator|-=
name|reservedSize
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reserving: "
operator|+
name|reservedSize
operator|+
literal|" Requested: "
operator|+
name|requestedSize
argument_list|)
expr_stmt|;
return|return
name|reservedSize
return|;
block|}
DECL|method|reserve (int requestedSize, int minSize)
name|int
name|reserve
parameter_list|(
name|int
name|requestedSize
parameter_list|,
name|int
name|minSize
parameter_list|)
block|{
if|if
condition|(
name|availableSize
operator|<
name|minSize
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No Space available. Available: "
operator|+
name|availableSize
operator|+
literal|" MinSize: "
operator|+
name|minSize
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|reserve
argument_list|(
name|requestedSize
argument_list|)
return|;
block|}
block|}
DECL|method|unreserve (int requestedSize)
specifier|public
name|void
name|unreserve
parameter_list|(
name|int
name|requestedSize
parameter_list|)
block|{
name|availableSize
operator|+=
name|requestedSize
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unreserving: "
operator|+
name|requestedSize
operator|+
literal|". Available: "
operator|+
name|availableSize
argument_list|)
expr_stmt|;
block|}
DECL|method|reinitialize ()
name|void
name|reinitialize
parameter_list|()
block|{
name|availableSize
operator|=
name|maxSize
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

