begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapreduce.task.reduce
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|task
operator|.
name|reduce
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|ConnectException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|HttpURLConnection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLConnection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|GeneralSecurityException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|crypto
operator|.
name|SecretKey
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|net
operator|.
name|ssl
operator|.
name|HttpsURLConnection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Counters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobConf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|Reporter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRJobConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskAttemptID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|security
operator|.
name|SecureShuffleUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|CryptoUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|ssl
operator|.
name|SSLFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_class
DECL|class|Fetcher
class|class
name|Fetcher
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Thread
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|Fetcher
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Number of ms before timing out a copy */
DECL|field|DEFAULT_STALLED_COPY_TIMEOUT
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_STALLED_COPY_TIMEOUT
init|=
literal|3
operator|*
literal|60
operator|*
literal|1000
decl_stmt|;
comment|/** Basic/unit connection timeout (in milliseconds) */
DECL|field|UNIT_CONNECT_TIMEOUT
specifier|private
specifier|final
specifier|static
name|int
name|UNIT_CONNECT_TIMEOUT
init|=
literal|60
operator|*
literal|1000
decl_stmt|;
comment|/* Default read timeout (in milliseconds) */
DECL|field|DEFAULT_READ_TIMEOUT
specifier|private
specifier|final
specifier|static
name|int
name|DEFAULT_READ_TIMEOUT
init|=
literal|3
operator|*
literal|60
operator|*
literal|1000
decl_stmt|;
comment|// This should be kept in sync with ShuffleHandler.FETCH_RETRY_DELAY.
DECL|field|FETCH_RETRY_DELAY_DEFAULT
specifier|private
specifier|static
specifier|final
name|long
name|FETCH_RETRY_DELAY_DEFAULT
init|=
literal|1000L
decl_stmt|;
DECL|field|TOO_MANY_REQ_STATUS_CODE
specifier|static
specifier|final
name|int
name|TOO_MANY_REQ_STATUS_CODE
init|=
literal|429
decl_stmt|;
DECL|field|FETCH_RETRY_AFTER_HEADER
specifier|private
specifier|static
specifier|final
name|String
name|FETCH_RETRY_AFTER_HEADER
init|=
literal|"Retry-After"
decl_stmt|;
DECL|field|reporter
specifier|protected
specifier|final
name|Reporter
name|reporter
decl_stmt|;
DECL|enum|ShuffleErrors
DECL|enumConstant|IO_ERROR
DECL|enumConstant|WRONG_LENGTH
DECL|enumConstant|BAD_ID
DECL|enumConstant|WRONG_MAP
specifier|private
enum|enum
name|ShuffleErrors
block|{
name|IO_ERROR
block|,
name|WRONG_LENGTH
block|,
name|BAD_ID
block|,
name|WRONG_MAP
block|,
DECL|enumConstant|CONNECTION
DECL|enumConstant|WRONG_REDUCE
name|CONNECTION
block|,
name|WRONG_REDUCE
block|}
DECL|field|SHUFFLE_ERR_GRP_NAME
specifier|private
specifier|final
specifier|static
name|String
name|SHUFFLE_ERR_GRP_NAME
init|=
literal|"Shuffle Errors"
decl_stmt|;
DECL|field|jobConf
specifier|private
specifier|final
name|JobConf
name|jobConf
decl_stmt|;
DECL|field|connectionErrs
specifier|private
specifier|final
name|Counters
operator|.
name|Counter
name|connectionErrs
decl_stmt|;
DECL|field|ioErrs
specifier|private
specifier|final
name|Counters
operator|.
name|Counter
name|ioErrs
decl_stmt|;
DECL|field|wrongLengthErrs
specifier|private
specifier|final
name|Counters
operator|.
name|Counter
name|wrongLengthErrs
decl_stmt|;
DECL|field|badIdErrs
specifier|private
specifier|final
name|Counters
operator|.
name|Counter
name|badIdErrs
decl_stmt|;
DECL|field|wrongMapErrs
specifier|private
specifier|final
name|Counters
operator|.
name|Counter
name|wrongMapErrs
decl_stmt|;
DECL|field|wrongReduceErrs
specifier|private
specifier|final
name|Counters
operator|.
name|Counter
name|wrongReduceErrs
decl_stmt|;
DECL|field|merger
specifier|protected
specifier|final
name|MergeManager
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|merger
decl_stmt|;
DECL|field|scheduler
specifier|protected
specifier|final
name|ShuffleSchedulerImpl
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|scheduler
decl_stmt|;
DECL|field|metrics
specifier|protected
specifier|final
name|ShuffleClientMetrics
name|metrics
decl_stmt|;
DECL|field|exceptionReporter
specifier|protected
specifier|final
name|ExceptionReporter
name|exceptionReporter
decl_stmt|;
DECL|field|id
specifier|protected
specifier|final
name|int
name|id
decl_stmt|;
DECL|field|nextId
specifier|private
specifier|static
name|int
name|nextId
init|=
literal|0
decl_stmt|;
DECL|field|reduce
specifier|protected
specifier|final
name|int
name|reduce
decl_stmt|;
DECL|field|connectionTimeout
specifier|private
specifier|final
name|int
name|connectionTimeout
decl_stmt|;
DECL|field|readTimeout
specifier|private
specifier|final
name|int
name|readTimeout
decl_stmt|;
DECL|field|fetchRetryTimeout
specifier|private
specifier|final
name|int
name|fetchRetryTimeout
decl_stmt|;
DECL|field|fetchRetryInterval
specifier|private
specifier|final
name|int
name|fetchRetryInterval
decl_stmt|;
DECL|field|fetchRetryEnabled
specifier|private
specifier|final
name|boolean
name|fetchRetryEnabled
decl_stmt|;
DECL|field|shuffleSecretKey
specifier|private
specifier|final
name|SecretKey
name|shuffleSecretKey
decl_stmt|;
DECL|field|connection
specifier|protected
name|HttpURLConnection
name|connection
decl_stmt|;
DECL|field|stopped
specifier|private
specifier|volatile
name|boolean
name|stopped
init|=
literal|false
decl_stmt|;
comment|// Initiative value is 0, which means it hasn't retried yet.
DECL|field|retryStartTime
specifier|private
name|long
name|retryStartTime
init|=
literal|0
decl_stmt|;
DECL|field|sslShuffle
specifier|private
specifier|static
name|boolean
name|sslShuffle
decl_stmt|;
DECL|field|sslFactory
specifier|private
specifier|static
name|SSLFactory
name|sslFactory
decl_stmt|;
DECL|method|Fetcher (JobConf job, TaskAttemptID reduceId, ShuffleSchedulerImpl<K,V> scheduler, MergeManager<K,V> merger, Reporter reporter, ShuffleClientMetrics metrics, ExceptionReporter exceptionReporter, SecretKey shuffleKey)
specifier|public
name|Fetcher
parameter_list|(
name|JobConf
name|job
parameter_list|,
name|TaskAttemptID
name|reduceId
parameter_list|,
name|ShuffleSchedulerImpl
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|scheduler
parameter_list|,
name|MergeManager
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|merger
parameter_list|,
name|Reporter
name|reporter
parameter_list|,
name|ShuffleClientMetrics
name|metrics
parameter_list|,
name|ExceptionReporter
name|exceptionReporter
parameter_list|,
name|SecretKey
name|shuffleKey
parameter_list|)
block|{
name|this
argument_list|(
name|job
argument_list|,
name|reduceId
argument_list|,
name|scheduler
argument_list|,
name|merger
argument_list|,
name|reporter
argument_list|,
name|metrics
argument_list|,
name|exceptionReporter
argument_list|,
name|shuffleKey
argument_list|,
operator|++
name|nextId
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|Fetcher (JobConf job, TaskAttemptID reduceId, ShuffleSchedulerImpl<K,V> scheduler, MergeManager<K,V> merger, Reporter reporter, ShuffleClientMetrics metrics, ExceptionReporter exceptionReporter, SecretKey shuffleKey, int id)
name|Fetcher
parameter_list|(
name|JobConf
name|job
parameter_list|,
name|TaskAttemptID
name|reduceId
parameter_list|,
name|ShuffleSchedulerImpl
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|scheduler
parameter_list|,
name|MergeManager
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|merger
parameter_list|,
name|Reporter
name|reporter
parameter_list|,
name|ShuffleClientMetrics
name|metrics
parameter_list|,
name|ExceptionReporter
name|exceptionReporter
parameter_list|,
name|SecretKey
name|shuffleKey
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|this
operator|.
name|jobConf
operator|=
name|job
expr_stmt|;
name|this
operator|.
name|reporter
operator|=
name|reporter
expr_stmt|;
name|this
operator|.
name|scheduler
operator|=
name|scheduler
expr_stmt|;
name|this
operator|.
name|merger
operator|=
name|merger
expr_stmt|;
name|this
operator|.
name|metrics
operator|=
name|metrics
expr_stmt|;
name|this
operator|.
name|exceptionReporter
operator|=
name|exceptionReporter
expr_stmt|;
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|this
operator|.
name|reduce
operator|=
name|reduceId
operator|.
name|getTaskID
argument_list|()
operator|.
name|getId
argument_list|()
expr_stmt|;
name|this
operator|.
name|shuffleSecretKey
operator|=
name|shuffleKey
expr_stmt|;
name|ioErrs
operator|=
name|reporter
operator|.
name|getCounter
argument_list|(
name|SHUFFLE_ERR_GRP_NAME
argument_list|,
name|ShuffleErrors
operator|.
name|IO_ERROR
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|wrongLengthErrs
operator|=
name|reporter
operator|.
name|getCounter
argument_list|(
name|SHUFFLE_ERR_GRP_NAME
argument_list|,
name|ShuffleErrors
operator|.
name|WRONG_LENGTH
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|badIdErrs
operator|=
name|reporter
operator|.
name|getCounter
argument_list|(
name|SHUFFLE_ERR_GRP_NAME
argument_list|,
name|ShuffleErrors
operator|.
name|BAD_ID
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|wrongMapErrs
operator|=
name|reporter
operator|.
name|getCounter
argument_list|(
name|SHUFFLE_ERR_GRP_NAME
argument_list|,
name|ShuffleErrors
operator|.
name|WRONG_MAP
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|connectionErrs
operator|=
name|reporter
operator|.
name|getCounter
argument_list|(
name|SHUFFLE_ERR_GRP_NAME
argument_list|,
name|ShuffleErrors
operator|.
name|CONNECTION
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|wrongReduceErrs
operator|=
name|reporter
operator|.
name|getCounter
argument_list|(
name|SHUFFLE_ERR_GRP_NAME
argument_list|,
name|ShuffleErrors
operator|.
name|WRONG_REDUCE
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|connectionTimeout
operator|=
name|job
operator|.
name|getInt
argument_list|(
name|MRJobConfig
operator|.
name|SHUFFLE_CONNECT_TIMEOUT
argument_list|,
name|DEFAULT_STALLED_COPY_TIMEOUT
argument_list|)
expr_stmt|;
name|this
operator|.
name|readTimeout
operator|=
name|job
operator|.
name|getInt
argument_list|(
name|MRJobConfig
operator|.
name|SHUFFLE_READ_TIMEOUT
argument_list|,
name|DEFAULT_READ_TIMEOUT
argument_list|)
expr_stmt|;
name|this
operator|.
name|fetchRetryInterval
operator|=
name|job
operator|.
name|getInt
argument_list|(
name|MRJobConfig
operator|.
name|SHUFFLE_FETCH_RETRY_INTERVAL_MS
argument_list|,
name|MRJobConfig
operator|.
name|DEFAULT_SHUFFLE_FETCH_RETRY_INTERVAL_MS
argument_list|)
expr_stmt|;
name|this
operator|.
name|fetchRetryTimeout
operator|=
name|job
operator|.
name|getInt
argument_list|(
name|MRJobConfig
operator|.
name|SHUFFLE_FETCH_RETRY_TIMEOUT_MS
argument_list|,
name|DEFAULT_STALLED_COPY_TIMEOUT
argument_list|)
expr_stmt|;
name|boolean
name|shuffleFetchEnabledDefault
init|=
name|job
operator|.
name|getBoolean
argument_list|(
name|YarnConfiguration
operator|.
name|NM_RECOVERY_ENABLED
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_NM_RECOVERY_ENABLED
argument_list|)
decl_stmt|;
name|this
operator|.
name|fetchRetryEnabled
operator|=
name|job
operator|.
name|getBoolean
argument_list|(
name|MRJobConfig
operator|.
name|SHUFFLE_FETCH_RETRY_ENABLED
argument_list|,
name|shuffleFetchEnabledDefault
argument_list|)
expr_stmt|;
name|setName
argument_list|(
literal|"fetcher#"
operator|+
name|id
argument_list|)
expr_stmt|;
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|Fetcher
operator|.
name|class
init|)
block|{
name|sslShuffle
operator|=
name|job
operator|.
name|getBoolean
argument_list|(
name|MRConfig
operator|.
name|SHUFFLE_SSL_ENABLED_KEY
argument_list|,
name|MRConfig
operator|.
name|SHUFFLE_SSL_ENABLED_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sslShuffle
operator|&&
name|sslFactory
operator|==
literal|null
condition|)
block|{
name|sslFactory
operator|=
operator|new
name|SSLFactory
argument_list|(
name|SSLFactory
operator|.
name|Mode
operator|.
name|CLIENT
argument_list|,
name|job
argument_list|)
expr_stmt|;
try|try
block|{
name|sslFactory
operator|.
name|init
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|sslFactory
operator|.
name|destroy
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
block|}
block|}
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
while|while
condition|(
operator|!
name|stopped
operator|&&
operator|!
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
name|MapHost
name|host
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// If merge is on, block
name|merger
operator|.
name|waitForResource
argument_list|()
expr_stmt|;
comment|// Get a host to shuffle from
name|host
operator|=
name|scheduler
operator|.
name|getHost
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|threadBusy
argument_list|()
expr_stmt|;
comment|// Shuffle
name|copyFromHost
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|host
operator|!=
literal|null
condition|)
block|{
name|scheduler
operator|.
name|freeHost
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|threadFree
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
return|return;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|exceptionReporter
operator|.
name|reportException
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|interrupt ()
specifier|public
name|void
name|interrupt
parameter_list|()
block|{
try|try
block|{
name|closeConnection
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|super
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|shutDown ()
specifier|public
name|void
name|shutDown
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|this
operator|.
name|stopped
operator|=
literal|true
expr_stmt|;
name|interrupt
argument_list|()
expr_stmt|;
try|try
block|{
name|join
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Got interrupt while joining "
operator|+
name|getName
argument_list|()
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sslFactory
operator|!=
literal|null
condition|)
block|{
name|sslFactory
operator|.
name|destroy
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|openConnection (URL url)
specifier|protected
specifier|synchronized
name|void
name|openConnection
parameter_list|(
name|URL
name|url
parameter_list|)
throws|throws
name|IOException
block|{
name|HttpURLConnection
name|conn
init|=
operator|(
name|HttpURLConnection
operator|)
name|url
operator|.
name|openConnection
argument_list|()
decl_stmt|;
if|if
condition|(
name|sslShuffle
condition|)
block|{
name|HttpsURLConnection
name|httpsConn
init|=
operator|(
name|HttpsURLConnection
operator|)
name|conn
decl_stmt|;
try|try
block|{
name|httpsConn
operator|.
name|setSSLSocketFactory
argument_list|(
name|sslFactory
operator|.
name|createSSLSocketFactory
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|GeneralSecurityException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
name|httpsConn
operator|.
name|setHostnameVerifier
argument_list|(
name|sslFactory
operator|.
name|getHostnameVerifier
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|connection
operator|=
name|conn
expr_stmt|;
block|}
DECL|method|closeConnection ()
specifier|protected
specifier|synchronized
name|void
name|closeConnection
parameter_list|()
block|{
comment|// Note that HttpURLConnection::disconnect() doesn't trash the object.
comment|// connect() attempts to reconnect in a loop, possibly reversing this
if|if
condition|(
name|connection
operator|!=
literal|null
condition|)
block|{
name|connection
operator|.
name|disconnect
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|abortConnect (MapHost host, Set<TaskAttemptID> remaining)
specifier|private
name|void
name|abortConnect
parameter_list|(
name|MapHost
name|host
parameter_list|,
name|Set
argument_list|<
name|TaskAttemptID
argument_list|>
name|remaining
parameter_list|)
block|{
for|for
control|(
name|TaskAttemptID
name|left
range|:
name|remaining
control|)
block|{
name|scheduler
operator|.
name|putBackKnownMapOutput
argument_list|(
name|host
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
name|closeConnection
argument_list|()
expr_stmt|;
block|}
DECL|method|openShuffleUrl (MapHost host, Set<TaskAttemptID> remaining, URL url)
specifier|private
name|DataInputStream
name|openShuffleUrl
parameter_list|(
name|MapHost
name|host
parameter_list|,
name|Set
argument_list|<
name|TaskAttemptID
argument_list|>
name|remaining
parameter_list|,
name|URL
name|url
parameter_list|)
block|{
name|DataInputStream
name|input
init|=
literal|null
decl_stmt|;
try|try
block|{
name|setupConnectionsWithRetry
argument_list|(
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|stopped
condition|)
block|{
name|abortConnect
argument_list|(
name|host
argument_list|,
name|remaining
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|input
operator|=
operator|new
name|DataInputStream
argument_list|(
name|connection
operator|.
name|getInputStream
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|TryAgainLaterException
name|te
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Connection rejected by the host "
operator|+
name|te
operator|.
name|host
operator|+
literal|". Will retry later."
argument_list|)
expr_stmt|;
name|scheduler
operator|.
name|penalize
argument_list|(
name|host
argument_list|,
name|te
operator|.
name|backoff
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|boolean
name|connectExcpt
init|=
name|ie
operator|instanceof
name|ConnectException
decl_stmt|;
name|ioErrs
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to connect to "
operator|+
name|host
operator|+
literal|" with "
operator|+
name|remaining
operator|.
name|size
argument_list|()
operator|+
literal|" map outputs"
argument_list|,
name|ie
argument_list|)
expr_stmt|;
comment|// If connect did not succeed, just mark all the maps as failed,
comment|// indirectly penalizing the host
name|scheduler
operator|.
name|hostFailed
argument_list|(
name|host
operator|.
name|getHostName
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|TaskAttemptID
name|left
range|:
name|remaining
control|)
block|{
name|scheduler
operator|.
name|copyFailed
argument_list|(
name|left
argument_list|,
name|host
argument_list|,
literal|false
argument_list|,
name|connectExcpt
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|input
return|;
block|}
comment|/**    * The crux of the matter...    *     * @param host {@link MapHost} from which we need to      *              shuffle available map-outputs.    */
annotation|@
name|VisibleForTesting
DECL|method|copyFromHost (MapHost host)
specifier|protected
name|void
name|copyFromHost
parameter_list|(
name|MapHost
name|host
parameter_list|)
throws|throws
name|IOException
block|{
comment|// reset retryStartTime for a new host
name|retryStartTime
operator|=
literal|0
expr_stmt|;
comment|// Get completed maps on 'host'
name|List
argument_list|<
name|TaskAttemptID
argument_list|>
name|maps
init|=
name|scheduler
operator|.
name|getMapsForHost
argument_list|(
name|host
argument_list|)
decl_stmt|;
comment|// Sanity check to catch hosts with only 'OBSOLETE' maps,
comment|// especially at the tail of large jobs
if|if
condition|(
name|maps
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Fetcher "
operator|+
name|id
operator|+
literal|" going to fetch from "
operator|+
name|host
operator|+
literal|" for: "
operator|+
name|maps
argument_list|)
expr_stmt|;
block|}
comment|// List of maps to be fetched yet
name|Set
argument_list|<
name|TaskAttemptID
argument_list|>
name|remaining
init|=
operator|new
name|HashSet
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|(
name|maps
argument_list|)
decl_stmt|;
comment|// Construct the url and connect
name|URL
name|url
init|=
name|getMapOutputURL
argument_list|(
name|host
argument_list|,
name|maps
argument_list|)
decl_stmt|;
name|DataInputStream
name|input
init|=
literal|null
decl_stmt|;
try|try
block|{
name|input
operator|=
name|openShuffleUrl
argument_list|(
name|host
argument_list|,
name|remaining
argument_list|,
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|input
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// Loop through available map-outputs and fetch them
comment|// On any error, faildTasks is not null and we exit
comment|// after putting back the remaining maps to the
comment|// yet_to_be_fetched list and marking the failed tasks.
name|TaskAttemptID
index|[]
name|failedTasks
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|!
name|remaining
operator|.
name|isEmpty
argument_list|()
operator|&&
name|failedTasks
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|failedTasks
operator|=
name|copyMapOutput
argument_list|(
name|host
argument_list|,
name|input
argument_list|,
name|remaining
argument_list|,
name|fetchRetryEnabled
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|IOUtils
operator|.
name|cleanupWithLogger
argument_list|(
name|LOG
argument_list|,
name|input
argument_list|)
expr_stmt|;
comment|//
comment|// Setup connection again if disconnected by NM
name|connection
operator|.
name|disconnect
argument_list|()
expr_stmt|;
comment|// Get map output from remaining tasks only.
name|url
operator|=
name|getMapOutputURL
argument_list|(
name|host
argument_list|,
name|remaining
argument_list|)
expr_stmt|;
name|input
operator|=
name|openShuffleUrl
argument_list|(
name|host
argument_list|,
name|remaining
argument_list|,
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|input
operator|==
literal|null
condition|)
block|{
return|return;
block|}
block|}
block|}
if|if
condition|(
name|failedTasks
operator|!=
literal|null
operator|&&
name|failedTasks
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"copyMapOutput failed for tasks "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|failedTasks
argument_list|)
argument_list|)
expr_stmt|;
name|scheduler
operator|.
name|hostFailed
argument_list|(
name|host
operator|.
name|getHostName
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|TaskAttemptID
name|left
range|:
name|failedTasks
control|)
block|{
name|scheduler
operator|.
name|copyFailed
argument_list|(
name|left
argument_list|,
name|host
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Sanity check
if|if
condition|(
name|failedTasks
operator|==
literal|null
operator|&&
operator|!
name|remaining
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"server didn't return all expected map outputs: "
operator|+
name|remaining
operator|.
name|size
argument_list|()
operator|+
literal|" left."
argument_list|)
throw|;
block|}
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
name|input
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|input
operator|!=
literal|null
condition|)
block|{
name|IOUtils
operator|.
name|cleanupWithLogger
argument_list|(
name|LOG
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|input
operator|=
literal|null
expr_stmt|;
block|}
for|for
control|(
name|TaskAttemptID
name|left
range|:
name|remaining
control|)
block|{
name|scheduler
operator|.
name|putBackKnownMapOutput
argument_list|(
name|host
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|setupConnectionsWithRetry (URL url)
specifier|private
name|void
name|setupConnectionsWithRetry
parameter_list|(
name|URL
name|url
parameter_list|)
throws|throws
name|IOException
block|{
name|openConnectionWithRetry
argument_list|(
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|stopped
condition|)
block|{
return|return;
block|}
comment|// generate hash of the url
name|String
name|msgToEncode
init|=
name|SecureShuffleUtils
operator|.
name|buildMsgFrom
argument_list|(
name|url
argument_list|)
decl_stmt|;
name|String
name|encHash
init|=
name|SecureShuffleUtils
operator|.
name|hashFromString
argument_list|(
name|msgToEncode
argument_list|,
name|shuffleSecretKey
argument_list|)
decl_stmt|;
name|setupShuffleConnection
argument_list|(
name|encHash
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|connection
argument_list|,
name|connectionTimeout
argument_list|)
expr_stmt|;
comment|// verify that the thread wasn't stopped during calls to connect
if|if
condition|(
name|stopped
condition|)
block|{
return|return;
block|}
name|verifyConnection
argument_list|(
name|url
argument_list|,
name|msgToEncode
argument_list|,
name|encHash
argument_list|)
expr_stmt|;
block|}
DECL|method|openConnectionWithRetry (URL url)
specifier|private
name|void
name|openConnectionWithRetry
parameter_list|(
name|URL
name|url
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|startTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|boolean
name|shouldWait
init|=
literal|true
decl_stmt|;
while|while
condition|(
name|shouldWait
condition|)
block|{
try|try
block|{
name|openConnection
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|shouldWait
operator|=
literal|false
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fetchRetryEnabled
condition|)
block|{
comment|// throw exception directly if fetch's retry is not enabled
throw|throw
name|e
throw|;
block|}
if|if
condition|(
operator|(
name|Time
operator|.
name|monotonicNow
argument_list|()
operator|-
name|startTime
operator|)
operator|>=
name|this
operator|.
name|fetchRetryTimeout
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to connect to host: "
operator|+
name|url
operator|+
literal|"after "
operator|+
name|fetchRetryTimeout
operator|+
literal|" milliseconds."
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|this
operator|.
name|fetchRetryInterval
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e1
parameter_list|)
block|{
if|if
condition|(
name|stopped
condition|)
block|{
return|return;
block|}
block|}
block|}
block|}
block|}
DECL|method|verifyConnection (URL url, String msgToEncode, String encHash)
specifier|private
name|void
name|verifyConnection
parameter_list|(
name|URL
name|url
parameter_list|,
name|String
name|msgToEncode
parameter_list|,
name|String
name|encHash
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Validate response code
name|int
name|rc
init|=
name|connection
operator|.
name|getResponseCode
argument_list|()
decl_stmt|;
comment|// See if the shuffleHandler rejected the connection due to too many
comment|// reducer requests. If so, signal fetchers to back off.
if|if
condition|(
name|rc
operator|==
name|TOO_MANY_REQ_STATUS_CODE
condition|)
block|{
name|long
name|backoff
init|=
name|connection
operator|.
name|getHeaderFieldLong
argument_list|(
name|FETCH_RETRY_AFTER_HEADER
argument_list|,
name|FETCH_RETRY_DELAY_DEFAULT
argument_list|)
decl_stmt|;
comment|// in case we get a negative backoff from ShuffleHandler
if|if
condition|(
name|backoff
operator|<
literal|0
condition|)
block|{
name|backoff
operator|=
name|FETCH_RETRY_DELAY_DEFAULT
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Get a negative backoff value from ShuffleHandler. Setting"
operator|+
literal|" it to the default value "
operator|+
name|FETCH_RETRY_DELAY_DEFAULT
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|TryAgainLaterException
argument_list|(
name|backoff
argument_list|,
name|url
operator|.
name|getHost
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|rc
operator|!=
name|HttpURLConnection
operator|.
name|HTTP_OK
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Got invalid response code "
operator|+
name|rc
operator|+
literal|" from "
operator|+
name|url
operator|+
literal|": "
operator|+
name|connection
operator|.
name|getResponseMessage
argument_list|()
argument_list|)
throw|;
block|}
comment|// get the shuffle version
if|if
condition|(
operator|!
name|ShuffleHeader
operator|.
name|DEFAULT_HTTP_HEADER_NAME
operator|.
name|equals
argument_list|(
name|connection
operator|.
name|getHeaderField
argument_list|(
name|ShuffleHeader
operator|.
name|HTTP_HEADER_NAME
argument_list|)
argument_list|)
operator|||
operator|!
name|ShuffleHeader
operator|.
name|DEFAULT_HTTP_HEADER_VERSION
operator|.
name|equals
argument_list|(
name|connection
operator|.
name|getHeaderField
argument_list|(
name|ShuffleHeader
operator|.
name|HTTP_HEADER_VERSION
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Incompatible shuffle response version"
argument_list|)
throw|;
block|}
comment|// get the replyHash which is HMac of the encHash we sent to the server
name|String
name|replyHash
init|=
name|connection
operator|.
name|getHeaderField
argument_list|(
name|SecureShuffleUtils
operator|.
name|HTTP_HEADER_REPLY_URL_HASH
argument_list|)
decl_stmt|;
if|if
condition|(
name|replyHash
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"security validation of TT Map output failed"
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"url="
operator|+
name|msgToEncode
operator|+
literal|";encHash="
operator|+
name|encHash
operator|+
literal|";replyHash="
operator|+
name|replyHash
argument_list|)
expr_stmt|;
comment|// verify that replyHash is HMac of encHash
name|SecureShuffleUtils
operator|.
name|verifyReply
argument_list|(
name|replyHash
argument_list|,
name|encHash
argument_list|,
name|shuffleSecretKey
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"for url="
operator|+
name|msgToEncode
operator|+
literal|" sent hash and received reply"
argument_list|)
expr_stmt|;
block|}
DECL|method|setupShuffleConnection (String encHash)
specifier|private
name|void
name|setupShuffleConnection
parameter_list|(
name|String
name|encHash
parameter_list|)
block|{
comment|// put url hash into http header
name|connection
operator|.
name|addRequestProperty
argument_list|(
name|SecureShuffleUtils
operator|.
name|HTTP_HEADER_URL_HASH
argument_list|,
name|encHash
argument_list|)
expr_stmt|;
comment|// set the read timeout
name|connection
operator|.
name|setReadTimeout
argument_list|(
name|readTimeout
argument_list|)
expr_stmt|;
comment|// put shuffle version into http header
name|connection
operator|.
name|addRequestProperty
argument_list|(
name|ShuffleHeader
operator|.
name|HTTP_HEADER_NAME
argument_list|,
name|ShuffleHeader
operator|.
name|DEFAULT_HTTP_HEADER_NAME
argument_list|)
expr_stmt|;
name|connection
operator|.
name|addRequestProperty
argument_list|(
name|ShuffleHeader
operator|.
name|HTTP_HEADER_VERSION
argument_list|,
name|ShuffleHeader
operator|.
name|DEFAULT_HTTP_HEADER_VERSION
argument_list|)
expr_stmt|;
block|}
DECL|field|EMPTY_ATTEMPT_ID_ARRAY
specifier|private
specifier|static
name|TaskAttemptID
index|[]
name|EMPTY_ATTEMPT_ID_ARRAY
init|=
operator|new
name|TaskAttemptID
index|[
literal|0
index|]
decl_stmt|;
DECL|method|copyMapOutput (MapHost host, DataInputStream input, Set<TaskAttemptID> remaining, boolean canRetry)
specifier|private
name|TaskAttemptID
index|[]
name|copyMapOutput
parameter_list|(
name|MapHost
name|host
parameter_list|,
name|DataInputStream
name|input
parameter_list|,
name|Set
argument_list|<
name|TaskAttemptID
argument_list|>
name|remaining
parameter_list|,
name|boolean
name|canRetry
parameter_list|)
throws|throws
name|IOException
block|{
name|MapOutput
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|mapOutput
init|=
literal|null
decl_stmt|;
name|TaskAttemptID
name|mapId
init|=
literal|null
decl_stmt|;
name|long
name|decompressedLength
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|compressedLength
init|=
operator|-
literal|1
decl_stmt|;
try|try
block|{
name|long
name|startTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|int
name|forReduce
init|=
operator|-
literal|1
decl_stmt|;
comment|//Read the shuffle header
try|try
block|{
name|ShuffleHeader
name|header
init|=
operator|new
name|ShuffleHeader
argument_list|()
decl_stmt|;
name|header
operator|.
name|readFields
argument_list|(
name|input
argument_list|)
expr_stmt|;
name|mapId
operator|=
name|TaskAttemptID
operator|.
name|forName
argument_list|(
name|header
operator|.
name|mapId
argument_list|)
expr_stmt|;
name|compressedLength
operator|=
name|header
operator|.
name|compressedLength
expr_stmt|;
name|decompressedLength
operator|=
name|header
operator|.
name|uncompressedLength
expr_stmt|;
name|forReduce
operator|=
name|header
operator|.
name|forReduce
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|badIdErrs
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Invalid map id "
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|//Don't know which one was bad, so consider all of them as bad
return|return
name|remaining
operator|.
name|toArray
argument_list|(
operator|new
name|TaskAttemptID
index|[
name|remaining
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
name|InputStream
name|is
init|=
name|input
decl_stmt|;
name|is
operator|=
name|CryptoUtils
operator|.
name|wrapIfNecessary
argument_list|(
name|jobConf
argument_list|,
name|is
argument_list|,
name|compressedLength
argument_list|)
expr_stmt|;
name|compressedLength
operator|-=
name|CryptoUtils
operator|.
name|cryptoPadding
argument_list|(
name|jobConf
argument_list|)
expr_stmt|;
name|decompressedLength
operator|-=
name|CryptoUtils
operator|.
name|cryptoPadding
argument_list|(
name|jobConf
argument_list|)
expr_stmt|;
comment|// Do some basic sanity verification
if|if
condition|(
operator|!
name|verifySanity
argument_list|(
name|compressedLength
argument_list|,
name|decompressedLength
argument_list|,
name|forReduce
argument_list|,
name|remaining
argument_list|,
name|mapId
argument_list|)
condition|)
block|{
return|return
operator|new
name|TaskAttemptID
index|[]
block|{
name|mapId
block|}
return|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"header: "
operator|+
name|mapId
operator|+
literal|", len: "
operator|+
name|compressedLength
operator|+
literal|", decomp len: "
operator|+
name|decompressedLength
argument_list|)
expr_stmt|;
block|}
comment|// Get the location for the map output - either in-memory or on-disk
try|try
block|{
name|mapOutput
operator|=
name|merger
operator|.
name|reserve
argument_list|(
name|mapId
argument_list|,
name|decompressedLength
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// kill this reduce attempt
name|ioErrs
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|scheduler
operator|.
name|reportLocalError
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
return|return
name|EMPTY_ATTEMPT_ID_ARRAY
return|;
block|}
comment|// Check if we can shuffle *now* ...
if|if
condition|(
name|mapOutput
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"fetcher#"
operator|+
name|id
operator|+
literal|" - MergeManager returned status WAIT ..."
argument_list|)
expr_stmt|;
comment|//Not an error but wait to process data.
return|return
name|EMPTY_ATTEMPT_ID_ARRAY
return|;
block|}
comment|// The codec for lz0,lz4,snappy,bz2,etc. throw java.lang.InternalError
comment|// on decompression failures. Catching and re-throwing as IOException
comment|// to allow fetch failure logic to be processed
try|try
block|{
comment|// Go!
name|LOG
operator|.
name|info
argument_list|(
literal|"fetcher#"
operator|+
name|id
operator|+
literal|" about to shuffle output of map "
operator|+
name|mapOutput
operator|.
name|getMapId
argument_list|()
operator|+
literal|" decomp: "
operator|+
name|decompressedLength
operator|+
literal|" len: "
operator|+
name|compressedLength
operator|+
literal|" to "
operator|+
name|mapOutput
operator|.
name|getDescription
argument_list|()
argument_list|)
expr_stmt|;
name|mapOutput
operator|.
name|shuffle
argument_list|(
name|host
argument_list|,
name|is
argument_list|,
name|compressedLength
argument_list|,
name|decompressedLength
argument_list|,
name|metrics
argument_list|,
name|reporter
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|lang
operator|.
name|InternalError
decl||
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to shuffle for fetcher#"
operator|+
name|id
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
comment|// Inform the shuffle scheduler
name|long
name|endTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
comment|// Reset retryStartTime as map task make progress if retried before.
name|retryStartTime
operator|=
literal|0
expr_stmt|;
name|scheduler
operator|.
name|copySucceeded
argument_list|(
name|mapId
argument_list|,
name|host
argument_list|,
name|compressedLength
argument_list|,
name|startTime
argument_list|,
name|endTime
argument_list|,
name|mapOutput
argument_list|)
expr_stmt|;
comment|// Note successful shuffle
name|remaining
operator|.
name|remove
argument_list|(
name|mapId
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|successFetch
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
if|if
condition|(
name|mapOutput
operator|!=
literal|null
condition|)
block|{
name|mapOutput
operator|.
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|canRetry
condition|)
block|{
name|checkTimeoutOrRetry
argument_list|(
name|host
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
name|ioErrs
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapId
operator|==
literal|null
operator|||
name|mapOutput
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"fetcher#"
operator|+
name|id
operator|+
literal|" failed to read map header"
operator|+
name|mapId
operator|+
literal|" decomp: "
operator|+
name|decompressedLength
operator|+
literal|", "
operator|+
name|compressedLength
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapId
operator|==
literal|null
condition|)
block|{
return|return
name|remaining
operator|.
name|toArray
argument_list|(
operator|new
name|TaskAttemptID
index|[
name|remaining
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|TaskAttemptID
index|[]
block|{
name|mapId
block|}
return|;
block|}
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to shuffle output of "
operator|+
name|mapId
operator|+
literal|" from "
operator|+
name|host
operator|.
name|getHostName
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
comment|// Inform the shuffle-scheduler
name|metrics
operator|.
name|failedFetch
argument_list|()
expr_stmt|;
return|return
operator|new
name|TaskAttemptID
index|[]
block|{
name|mapId
block|}
return|;
block|}
block|}
comment|/** check if hit timeout of retry, if not, throw an exception and start a     *  new round of retry.*/
DECL|method|checkTimeoutOrRetry (MapHost host, IOException ioe)
specifier|private
name|void
name|checkTimeoutOrRetry
parameter_list|(
name|MapHost
name|host
parameter_list|,
name|IOException
name|ioe
parameter_list|)
throws|throws
name|IOException
block|{
comment|// First time to retry.
name|long
name|currentTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
if|if
condition|(
name|retryStartTime
operator|==
literal|0
condition|)
block|{
name|retryStartTime
operator|=
name|currentTime
expr_stmt|;
block|}
comment|// Retry is not timeout, let's do retry with throwing an exception.
if|if
condition|(
name|currentTime
operator|-
name|retryStartTime
operator|<
name|this
operator|.
name|fetchRetryTimeout
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Shuffle output from "
operator|+
name|host
operator|.
name|getHostName
argument_list|()
operator|+
literal|" failed, retry it."
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
else|else
block|{
comment|// timeout, prepare to be failed.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Timeout for copying MapOutput with retry on host "
operator|+
name|host
operator|+
literal|"after "
operator|+
name|fetchRetryTimeout
operator|+
literal|" milliseconds."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Do some basic verification on the input received -- Being defensive    * @param compressedLength    * @param decompressedLength    * @param forReduce    * @param remaining    * @param mapId    * @return true/false, based on if the verification succeeded or not    */
DECL|method|verifySanity (long compressedLength, long decompressedLength, int forReduce, Set<TaskAttemptID> remaining, TaskAttemptID mapId)
specifier|private
name|boolean
name|verifySanity
parameter_list|(
name|long
name|compressedLength
parameter_list|,
name|long
name|decompressedLength
parameter_list|,
name|int
name|forReduce
parameter_list|,
name|Set
argument_list|<
name|TaskAttemptID
argument_list|>
name|remaining
parameter_list|,
name|TaskAttemptID
name|mapId
parameter_list|)
block|{
if|if
condition|(
name|compressedLength
operator|<
literal|0
operator|||
name|decompressedLength
operator|<
literal|0
condition|)
block|{
name|wrongLengthErrs
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|getName
argument_list|()
operator|+
literal|" invalid lengths in map output header: id: "
operator|+
name|mapId
operator|+
literal|" len: "
operator|+
name|compressedLength
operator|+
literal|", decomp len: "
operator|+
name|decompressedLength
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|forReduce
operator|!=
name|reduce
condition|)
block|{
name|wrongReduceErrs
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|getName
argument_list|()
operator|+
literal|" data for the wrong reduce map: "
operator|+
name|mapId
operator|+
literal|" len: "
operator|+
name|compressedLength
operator|+
literal|" decomp len: "
operator|+
name|decompressedLength
operator|+
literal|" for reduce "
operator|+
name|forReduce
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Sanity check
if|if
condition|(
operator|!
name|remaining
operator|.
name|contains
argument_list|(
name|mapId
argument_list|)
condition|)
block|{
name|wrongMapErrs
operator|.
name|increment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Invalid map-output! Received output for "
operator|+
name|mapId
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Create the map-output-url. This will contain all the map ids    * separated by commas    * @param host    * @param maps    * @return    * @throws MalformedURLException    */
DECL|method|getMapOutputURL (MapHost host, Collection<TaskAttemptID> maps )
specifier|private
name|URL
name|getMapOutputURL
parameter_list|(
name|MapHost
name|host
parameter_list|,
name|Collection
argument_list|<
name|TaskAttemptID
argument_list|>
name|maps
parameter_list|)
throws|throws
name|MalformedURLException
block|{
comment|// Get the base url
name|StringBuffer
name|url
init|=
operator|new
name|StringBuffer
argument_list|(
name|host
operator|.
name|getBaseUrl
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|TaskAttemptID
name|mapId
range|:
name|maps
control|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
block|{
name|url
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|url
operator|.
name|append
argument_list|(
name|mapId
argument_list|)
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"MapOutput URL for "
operator|+
name|host
operator|+
literal|" -> "
operator|+
name|url
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|URL
argument_list|(
name|url
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**     * The connection establishment is attempted multiple times and is given up     * only on the last failure. Instead of connecting with a timeout of     * X, we try connecting with a timeout of x< X but multiple times.     */
DECL|method|connect (URLConnection connection, int connectionTimeout)
specifier|private
name|void
name|connect
parameter_list|(
name|URLConnection
name|connection
parameter_list|,
name|int
name|connectionTimeout
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|unit
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|connectionTimeout
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid timeout "
operator|+
literal|"[timeout = "
operator|+
name|connectionTimeout
operator|+
literal|" ms]"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|connectionTimeout
operator|>
literal|0
condition|)
block|{
name|unit
operator|=
name|Math
operator|.
name|min
argument_list|(
name|UNIT_CONNECT_TIMEOUT
argument_list|,
name|connectionTimeout
argument_list|)
expr_stmt|;
block|}
name|long
name|startTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|long
name|lastTime
init|=
name|startTime
decl_stmt|;
name|int
name|attempts
init|=
literal|0
decl_stmt|;
comment|// set the connect timeout to the unit-connect-timeout
name|connection
operator|.
name|setConnectTimeout
argument_list|(
name|unit
argument_list|)
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|attempts
operator|++
expr_stmt|;
name|connection
operator|.
name|connect
argument_list|()
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|long
name|currentTime
init|=
name|Time
operator|.
name|monotonicNow
argument_list|()
decl_stmt|;
name|long
name|retryTime
init|=
name|currentTime
operator|-
name|startTime
decl_stmt|;
name|long
name|leftTime
init|=
name|connectionTimeout
operator|-
name|retryTime
decl_stmt|;
name|long
name|timeSinceLastIteration
init|=
name|currentTime
operator|-
name|lastTime
decl_stmt|;
comment|// throw an exception if we have waited for timeout amount of time
comment|// note that the updated value if timeout is used here
if|if
condition|(
name|leftTime
operator|<=
literal|0
condition|)
block|{
name|int
name|retryTimeInSeconds
init|=
operator|(
name|int
operator|)
name|retryTime
operator|/
literal|1000
decl_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Connection retry failed with "
operator|+
name|attempts
operator|+
literal|" attempts in "
operator|+
name|retryTimeInSeconds
operator|+
literal|" seconds"
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
comment|// reset the connect timeout for the last try
if|if
condition|(
name|leftTime
operator|<
name|unit
condition|)
block|{
name|unit
operator|=
operator|(
name|int
operator|)
name|leftTime
expr_stmt|;
comment|// reset the connect time out for the final connect
name|connection
operator|.
name|setConnectTimeout
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeSinceLastIteration
operator|<
name|unit
condition|)
block|{
try|try
block|{
comment|// sleep the left time of unit
name|sleep
argument_list|(
name|unit
operator|-
name|timeSinceLastIteration
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Sleep in connection retry get interrupted."
argument_list|)
expr_stmt|;
if|if
condition|(
name|stopped
condition|)
block|{
return|return;
block|}
block|}
block|}
comment|// update the total remaining connect-timeout
name|lastTime
operator|=
name|Time
operator|.
name|monotonicNow
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|class|TryAgainLaterException
specifier|private
specifier|static
class|class
name|TryAgainLaterException
extends|extends
name|IOException
block|{
DECL|field|backoff
specifier|public
specifier|final
name|long
name|backoff
decl_stmt|;
DECL|field|host
specifier|public
specifier|final
name|String
name|host
decl_stmt|;
DECL|method|TryAgainLaterException (long backoff, String host)
specifier|public
name|TryAgainLaterException
parameter_list|(
name|long
name|backoff
parameter_list|,
name|String
name|host
parameter_list|)
block|{
name|super
argument_list|(
literal|"Too many requests to a map host"
argument_list|)
expr_stmt|;
name|this
operator|.
name|backoff
operator|=
name|backoff
expr_stmt|;
name|this
operator|.
name|host
operator|=
name|host
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

