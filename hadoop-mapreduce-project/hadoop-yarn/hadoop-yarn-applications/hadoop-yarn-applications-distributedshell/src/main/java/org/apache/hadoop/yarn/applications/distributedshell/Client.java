begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.yarn.applications.distributedshell
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|applications
operator|.
name|distributedshell
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|CommandLine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|GnuParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|HelpFormatter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|ParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|ApplicationConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|ClientRMProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|GetApplicationReportRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|GetApplicationReportResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|GetClusterMetricsRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|GetClusterMetricsResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|GetClusterNodesRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|GetClusterNodesResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|GetNewApplicationRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|GetNewApplicationResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|GetQueueInfoRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|GetQueueInfoResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|GetQueueUserAclsInfoRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|GetQueueUserAclsInfoResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|KillApplicationRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|protocolrecords
operator|.
name|SubmitApplicationRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ApplicationSubmissionContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|ContainerLaunchContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|FinalApplicationStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|LocalResource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|LocalResourceType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|LocalResourceVisibility
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|NodeReport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Priority
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|QueueUserACLInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|Resource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|api
operator|.
name|records
operator|.
name|YarnApplicationState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|conf
operator|.
name|YarnConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|exceptions
operator|.
name|YarnRemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|ipc
operator|.
name|YarnRPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|ConverterUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|yarn
operator|.
name|util
operator|.
name|Records
import|;
end_import

begin_comment
comment|/**  * Client for Distributed Shell application submission to YARN.  *   *<p> The distributed shell client allows an application master to be launched that in turn would run   * the provided shell command on a set of containers.</p>  *   *<p>This client is meant to act as an example on how to write yarn-based applications.</p>  *   *<p> To submit an application, a client first needs to connect to the<code>ResourceManager</code>   * aka ApplicationsManager or ASM via the {@link ClientRMProtocol}. The {@link ClientRMProtocol}   * provides a way for the client to get access to cluster information and to request for a  * new {@link ApplicationId}.<p>  *   *<p> For the actual job submission, the client first has to create an {@link ApplicationSubmissionContext}.   * The {@link ApplicationSubmissionContext} defines the application details such as {@link ApplicationId}   * and application name, the priority assigned to the application and the queue  * to which this application needs to be assigned. In addition to this, the {@link ApplicationSubmissionContext}  * also defines the {@link ContainerLaunchContext} which describes the<code>Container</code> with which   * the {@link ApplicationMaster} is launched.</p>  *   *<p> The {@link ContainerLaunchContext} in this scenario defines the resources to be allocated for the   * {@link ApplicationMaster}'s container, the local resources (jars, configuration files) to be made available   * and the environment to be set for the {@link ApplicationMaster} and the commands to be executed to run the   * {@link ApplicationMaster}.<p>  *   *<p> Using the {@link ApplicationSubmissionContext}, the client submits the application to the   *<code>ResourceManager</code> and then monitors the application by requesting the<code>ResourceManager</code>   * for an {@link ApplicationReport} at regular time intervals. In case of the application taking too long, the client   * kills the application by submitting a {@link KillApplicationRequest} to the<code>ResourceManager</code>.</p>  *  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|Client
specifier|public
class|class
name|Client
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|Client
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Configuration
DECL|field|conf
specifier|private
name|Configuration
name|conf
decl_stmt|;
comment|// RPC to communicate to RM
DECL|field|rpc
specifier|private
name|YarnRPC
name|rpc
decl_stmt|;
comment|// Handle to talk to the Resource Manager/Applications Manager
DECL|field|applicationsManager
specifier|private
name|ClientRMProtocol
name|applicationsManager
decl_stmt|;
comment|// Application master specific info to register a new Application with RM/ASM
DECL|field|appName
specifier|private
name|String
name|appName
init|=
literal|""
decl_stmt|;
comment|// App master priority
DECL|field|amPriority
specifier|private
name|int
name|amPriority
init|=
literal|0
decl_stmt|;
comment|// Queue for App master
DECL|field|amQueue
specifier|private
name|String
name|amQueue
init|=
literal|""
decl_stmt|;
comment|// Amt. of memory resource to request for to run the App Master
DECL|field|amMemory
specifier|private
name|int
name|amMemory
init|=
literal|10
decl_stmt|;
comment|// Application master jar file
DECL|field|appMasterJar
specifier|private
name|String
name|appMasterJar
init|=
literal|""
decl_stmt|;
comment|// Main class to invoke application master
DECL|field|appMasterMainClass
specifier|private
name|String
name|appMasterMainClass
init|=
literal|""
decl_stmt|;
comment|// Shell command to be executed
DECL|field|shellCommand
specifier|private
name|String
name|shellCommand
init|=
literal|""
decl_stmt|;
comment|// Location of shell script
DECL|field|shellScriptPath
specifier|private
name|String
name|shellScriptPath
init|=
literal|""
decl_stmt|;
comment|// Args to be passed to the shell command
DECL|field|shellArgs
specifier|private
name|String
name|shellArgs
init|=
literal|""
decl_stmt|;
comment|// Env variables to be setup for the shell command
DECL|field|shellEnv
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|shellEnv
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// Shell Command Container priority
DECL|field|shellCmdPriority
specifier|private
name|int
name|shellCmdPriority
init|=
literal|0
decl_stmt|;
comment|// Amt of memory to request for container in which shell script will be executed
DECL|field|containerMemory
specifier|private
name|int
name|containerMemory
init|=
literal|10
decl_stmt|;
comment|// No. of containers in which the shell script needs to be executed
DECL|field|numContainers
specifier|private
name|int
name|numContainers
init|=
literal|1
decl_stmt|;
comment|// log4j.properties file
comment|// if available, add to local resources and set into classpath
DECL|field|log4jPropFile
specifier|private
name|String
name|log4jPropFile
init|=
literal|""
decl_stmt|;
comment|// Start time for client
DECL|field|clientStartTime
specifier|private
specifier|final
name|long
name|clientStartTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// Timeout threshold for client. Kill app after time interval expires.
DECL|field|clientTimeout
specifier|private
name|long
name|clientTimeout
init|=
literal|600000
decl_stmt|;
comment|// Debug flag
DECL|field|debugFlag
name|boolean
name|debugFlag
init|=
literal|false
decl_stmt|;
comment|/**    * @param args Command line arguments     */
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|boolean
name|result
init|=
literal|false
decl_stmt|;
try|try
block|{
name|Client
name|client
init|=
operator|new
name|Client
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Initializing Client"
argument_list|)
expr_stmt|;
name|boolean
name|doRun
init|=
name|client
operator|.
name|init
argument_list|(
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|doRun
condition|)
block|{
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|client
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Error running CLient"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Application completed successfully"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Application failed to complete successfully"
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/**    */
DECL|method|Client (Configuration conf)
specifier|public
name|Client
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|Exception
block|{
comment|// Set up the configuration and RPC
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|rpc
operator|=
name|YarnRPC
operator|.
name|create
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    */
DECL|method|Client ()
specifier|public
name|Client
parameter_list|()
throws|throws
name|Exception
block|{
name|this
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Helper function to print out usage    * @param opts Parsed command line options     */
DECL|method|printUsage (Options opts)
specifier|private
name|void
name|printUsage
parameter_list|(
name|Options
name|opts
parameter_list|)
block|{
operator|new
name|HelpFormatter
argument_list|()
operator|.
name|printHelp
argument_list|(
literal|"Client"
argument_list|,
name|opts
argument_list|)
expr_stmt|;
block|}
comment|/**    * Parse command line options    * @param args Parsed command line options     * @return Whether the init was successful to run the client    * @throws ParseException    */
DECL|method|init (String[] args)
specifier|public
name|boolean
name|init
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|ParseException
block|{
name|Options
name|opts
init|=
operator|new
name|Options
argument_list|()
decl_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"appname"
argument_list|,
literal|true
argument_list|,
literal|"Application Name. Default value - DistributedShell"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"priority"
argument_list|,
literal|true
argument_list|,
literal|"Application Priority. Default 0"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"queue"
argument_list|,
literal|true
argument_list|,
literal|"RM Queue in which this application is to be submitted"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"timeout"
argument_list|,
literal|true
argument_list|,
literal|"Application timeout in milliseconds"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"master_memory"
argument_list|,
literal|true
argument_list|,
literal|"Amount of memory in MB to be requested to run the application master"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"jar"
argument_list|,
literal|true
argument_list|,
literal|"Jar file containing the application master"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"class"
argument_list|,
literal|true
argument_list|,
literal|"Main class to  be run for the Application Master."
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"shell_command"
argument_list|,
literal|true
argument_list|,
literal|"Shell command to be executed by the Application Master"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"shell_script"
argument_list|,
literal|true
argument_list|,
literal|"Location of the shell script to be executed"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"shell_args"
argument_list|,
literal|true
argument_list|,
literal|"Command line args for the shell script"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"shell_env"
argument_list|,
literal|true
argument_list|,
literal|"Environment for shell script. Specified as env_key=env_val pairs"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"shell_cmd_priority"
argument_list|,
literal|true
argument_list|,
literal|"Priority for the shell command containers"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"container_memory"
argument_list|,
literal|true
argument_list|,
literal|"Amount of memory in MB to be requested to run the shell command"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"num_containers"
argument_list|,
literal|true
argument_list|,
literal|"No. of containers on which the shell command needs to be executed"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"log_properties"
argument_list|,
literal|true
argument_list|,
literal|"log4j.properties file"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"debug"
argument_list|,
literal|false
argument_list|,
literal|"Dump out debug information"
argument_list|)
expr_stmt|;
name|opts
operator|.
name|addOption
argument_list|(
literal|"help"
argument_list|,
literal|false
argument_list|,
literal|"Print usage"
argument_list|)
expr_stmt|;
name|CommandLine
name|cliParser
init|=
operator|new
name|GnuParser
argument_list|()
operator|.
name|parse
argument_list|(
name|opts
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|printUsage
argument_list|(
name|opts
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No args specified for client to initialize"
argument_list|)
throw|;
block|}
if|if
condition|(
name|cliParser
operator|.
name|hasOption
argument_list|(
literal|"help"
argument_list|)
condition|)
block|{
name|printUsage
argument_list|(
name|opts
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|cliParser
operator|.
name|hasOption
argument_list|(
literal|"debug"
argument_list|)
condition|)
block|{
name|debugFlag
operator|=
literal|true
expr_stmt|;
block|}
name|appName
operator|=
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"appname"
argument_list|,
literal|"DistributedShell"
argument_list|)
expr_stmt|;
name|amPriority
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"priority"
argument_list|,
literal|"0"
argument_list|)
argument_list|)
expr_stmt|;
name|amQueue
operator|=
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"queue"
argument_list|,
literal|"default"
argument_list|)
expr_stmt|;
name|amMemory
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"master_memory"
argument_list|,
literal|"10"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|amMemory
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid memory specified for application master, exiting."
operator|+
literal|" Specified memory="
operator|+
name|amMemory
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|cliParser
operator|.
name|hasOption
argument_list|(
literal|"jar"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No jar file specified for application master"
argument_list|)
throw|;
block|}
name|appMasterJar
operator|=
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"jar"
argument_list|)
expr_stmt|;
name|appMasterMainClass
operator|=
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"class"
argument_list|,
literal|"org.apache.hadoop.yarn.applications.distributedshell.ApplicationMaster"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cliParser
operator|.
name|hasOption
argument_list|(
literal|"shell_command"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No shell command specified to be executed by application master"
argument_list|)
throw|;
block|}
name|shellCommand
operator|=
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"shell_command"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cliParser
operator|.
name|hasOption
argument_list|(
literal|"shell_script"
argument_list|)
condition|)
block|{
name|shellScriptPath
operator|=
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"shell_script"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cliParser
operator|.
name|hasOption
argument_list|(
literal|"shell_args"
argument_list|)
condition|)
block|{
name|shellArgs
operator|=
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"shell_args"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cliParser
operator|.
name|hasOption
argument_list|(
literal|"shell_env"
argument_list|)
condition|)
block|{
name|String
name|envs
index|[]
init|=
name|cliParser
operator|.
name|getOptionValues
argument_list|(
literal|"shell_env"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|env
range|:
name|envs
control|)
block|{
name|env
operator|=
name|env
operator|.
name|trim
argument_list|()
expr_stmt|;
name|int
name|index
init|=
name|env
operator|.
name|indexOf
argument_list|(
literal|'='
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|shellEnv
operator|.
name|put
argument_list|(
name|env
argument_list|,
literal|""
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|String
name|key
init|=
name|env
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|index
argument_list|)
decl_stmt|;
name|String
name|val
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|index
operator|<
operator|(
name|env
operator|.
name|length
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
name|val
operator|=
name|env
operator|.
name|substring
argument_list|(
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|shellEnv
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
name|shellCmdPriority
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"shell_cmd_priority"
argument_list|,
literal|"0"
argument_list|)
argument_list|)
expr_stmt|;
name|containerMemory
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"container_memory"
argument_list|,
literal|"10"
argument_list|)
argument_list|)
expr_stmt|;
name|numContainers
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"num_containers"
argument_list|,
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|containerMemory
operator|<
literal|0
operator|||
name|numContainers
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid no. of containers or container memory specified, exiting."
operator|+
literal|" Specified containerMemory="
operator|+
name|containerMemory
operator|+
literal|", numContainer="
operator|+
name|numContainers
argument_list|)
throw|;
block|}
name|clientTimeout
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"timeout"
argument_list|,
literal|"600000"
argument_list|)
argument_list|)
expr_stmt|;
name|log4jPropFile
operator|=
name|cliParser
operator|.
name|getOptionValue
argument_list|(
literal|"log_properties"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**    * Main run function for the client    * @return true if application completed successfully    * @throws IOException    */
DECL|method|run ()
specifier|public
name|boolean
name|run
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting Client"
argument_list|)
expr_stmt|;
comment|// Connect to ResourceManager
name|connectToASM
argument_list|()
expr_stmt|;
assert|assert
operator|(
name|applicationsManager
operator|!=
literal|null
operator|)
assert|;
comment|// Use ClientRMProtocol handle to general cluster information
name|GetClusterMetricsRequest
name|clusterMetricsReq
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|GetClusterMetricsRequest
operator|.
name|class
argument_list|)
decl_stmt|;
name|GetClusterMetricsResponse
name|clusterMetricsResp
init|=
name|applicationsManager
operator|.
name|getClusterMetrics
argument_list|(
name|clusterMetricsReq
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Got Cluster metric info from ASM"
operator|+
literal|", numNodeManagers="
operator|+
name|clusterMetricsResp
operator|.
name|getClusterMetrics
argument_list|()
operator|.
name|getNumNodeManagers
argument_list|()
argument_list|)
expr_stmt|;
name|GetClusterNodesRequest
name|clusterNodesReq
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|GetClusterNodesRequest
operator|.
name|class
argument_list|)
decl_stmt|;
name|GetClusterNodesResponse
name|clusterNodesResp
init|=
name|applicationsManager
operator|.
name|getClusterNodes
argument_list|(
name|clusterNodesReq
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Got Cluster node info from ASM"
argument_list|)
expr_stmt|;
for|for
control|(
name|NodeReport
name|node
range|:
name|clusterNodesResp
operator|.
name|getNodeReports
argument_list|()
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Got node report from ASM for"
operator|+
literal|", nodeId="
operator|+
name|node
operator|.
name|getNodeId
argument_list|()
operator|+
literal|", nodeAddress"
operator|+
name|node
operator|.
name|getHttpAddress
argument_list|()
operator|+
literal|", nodeRackName"
operator|+
name|node
operator|.
name|getRackName
argument_list|()
operator|+
literal|", nodeNumContainers"
operator|+
name|node
operator|.
name|getNumContainers
argument_list|()
operator|+
literal|", nodeHealthStatus"
operator|+
name|node
operator|.
name|getNodeHealthStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|GetQueueInfoRequest
name|queueInfoReq
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|GetQueueInfoRequest
operator|.
name|class
argument_list|)
decl_stmt|;
name|queueInfoReq
operator|.
name|setQueueName
argument_list|(
name|this
operator|.
name|amQueue
argument_list|)
expr_stmt|;
name|GetQueueInfoResponse
name|queueInfoResp
init|=
name|applicationsManager
operator|.
name|getQueueInfo
argument_list|(
name|queueInfoReq
argument_list|)
decl_stmt|;
name|QueueInfo
name|queueInfo
init|=
name|queueInfoResp
operator|.
name|getQueueInfo
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Queue info"
operator|+
literal|", queueName="
operator|+
name|queueInfo
operator|.
name|getQueueName
argument_list|()
operator|+
literal|", queueCurrentCapacity="
operator|+
name|queueInfo
operator|.
name|getCurrentCapacity
argument_list|()
operator|+
literal|", queueMaxCapacity="
operator|+
name|queueInfo
operator|.
name|getMaximumCapacity
argument_list|()
operator|+
literal|", queueApplicationCount="
operator|+
name|queueInfo
operator|.
name|getApplications
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|", queueChildQueueCount="
operator|+
name|queueInfo
operator|.
name|getChildQueues
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|GetQueueUserAclsInfoRequest
name|queueUserAclsReq
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|GetQueueUserAclsInfoRequest
operator|.
name|class
argument_list|)
decl_stmt|;
name|GetQueueUserAclsInfoResponse
name|queueUserAclsResp
init|=
name|applicationsManager
operator|.
name|getQueueUserAcls
argument_list|(
name|queueUserAclsReq
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|QueueUserACLInfo
argument_list|>
name|listAclInfo
init|=
name|queueUserAclsResp
operator|.
name|getUserAclsInfoList
argument_list|()
decl_stmt|;
for|for
control|(
name|QueueUserACLInfo
name|aclInfo
range|:
name|listAclInfo
control|)
block|{
for|for
control|(
name|QueueACL
name|userAcl
range|:
name|aclInfo
operator|.
name|getUserAcls
argument_list|()
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"User ACL Info for Queue"
operator|+
literal|", queueName="
operator|+
name|aclInfo
operator|.
name|getQueueName
argument_list|()
operator|+
literal|", userAcl="
operator|+
name|userAcl
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Get a new application id
name|GetNewApplicationResponse
name|newApp
init|=
name|getApplication
argument_list|()
decl_stmt|;
name|ApplicationId
name|appId
init|=
name|newApp
operator|.
name|getApplicationId
argument_list|()
decl_stmt|;
comment|// TODO get min/max resource capabilities from RM and change memory ask if needed
comment|// If we do not have min/max, we may not be able to correctly request
comment|// the required resources from the RM for the app master
comment|// Memory ask has to be a multiple of min and less than max.
comment|// Dump out information about cluster capability as seen by the resource manager
name|int
name|minMem
init|=
name|newApp
operator|.
name|getMinimumResourceCapability
argument_list|()
operator|.
name|getMemory
argument_list|()
decl_stmt|;
name|int
name|maxMem
init|=
name|newApp
operator|.
name|getMaximumResourceCapability
argument_list|()
operator|.
name|getMemory
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Min mem capabililty of resources in this cluster "
operator|+
name|minMem
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Max mem capabililty of resources in this cluster "
operator|+
name|maxMem
argument_list|)
expr_stmt|;
comment|// A resource ask has to be atleast the minimum of the capability of the cluster, the value has to be
comment|// a multiple of the min value and cannot exceed the max.
comment|// If it is not an exact multiple of min, the RM will allocate to the nearest multiple of min
if|if
condition|(
name|amMemory
operator|<
name|minMem
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"AM memory specified below min threshold of cluster. Using min value."
operator|+
literal|", specified="
operator|+
name|amMemory
operator|+
literal|", min="
operator|+
name|minMem
argument_list|)
expr_stmt|;
name|amMemory
operator|=
name|minMem
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|amMemory
operator|>
name|maxMem
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"AM memory specified above max threshold of cluster. Using max value."
operator|+
literal|", specified="
operator|+
name|amMemory
operator|+
literal|", max="
operator|+
name|maxMem
argument_list|)
expr_stmt|;
name|amMemory
operator|=
name|maxMem
expr_stmt|;
block|}
comment|// Create launch context for app master
name|LOG
operator|.
name|info
argument_list|(
literal|"Setting up application submission context for ASM"
argument_list|)
expr_stmt|;
name|ApplicationSubmissionContext
name|appContext
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|ApplicationSubmissionContext
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// set the application id
name|appContext
operator|.
name|setApplicationId
argument_list|(
name|appId
argument_list|)
expr_stmt|;
comment|// set the application name
name|appContext
operator|.
name|setApplicationName
argument_list|(
name|appName
argument_list|)
expr_stmt|;
comment|// Set up the container launch context for the application master
name|ContainerLaunchContext
name|amContainer
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|ContainerLaunchContext
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// set local resources for the application master
comment|// local files or archives as needed
comment|// In this scenario, the jar file for the application master is part of the local resources
name|Map
argument_list|<
name|String
argument_list|,
name|LocalResource
argument_list|>
name|localResources
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|LocalResource
argument_list|>
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Copy App Master jar from local filesystem and add to local environment"
argument_list|)
expr_stmt|;
comment|// Copy the application master jar to the filesystem
comment|// Create a local resource to point to the destination jar path
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Path
name|src
init|=
operator|new
name|Path
argument_list|(
name|appMasterJar
argument_list|)
decl_stmt|;
name|String
name|pathSuffix
init|=
name|appName
operator|+
literal|"/"
operator|+
name|appId
operator|.
name|getId
argument_list|()
operator|+
literal|"/AppMaster.jar"
decl_stmt|;
name|Path
name|dst
init|=
operator|new
name|Path
argument_list|(
name|fs
operator|.
name|getHomeDirectory
argument_list|()
argument_list|,
name|pathSuffix
argument_list|)
decl_stmt|;
name|fs
operator|.
name|copyFromLocalFile
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|FileStatus
name|destStatus
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|dst
argument_list|)
decl_stmt|;
name|LocalResource
name|amJarRsrc
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|LocalResource
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Set the type of resource - file or archive
comment|// archives are untarred at destination
comment|// we don't need the jar file to be untarred for now
name|amJarRsrc
operator|.
name|setType
argument_list|(
name|LocalResourceType
operator|.
name|FILE
argument_list|)
expr_stmt|;
comment|// Set visibility of the resource
comment|// Setting to most private option
name|amJarRsrc
operator|.
name|setVisibility
argument_list|(
name|LocalResourceVisibility
operator|.
name|APPLICATION
argument_list|)
expr_stmt|;
comment|// Set the resource to be copied over
name|amJarRsrc
operator|.
name|setResource
argument_list|(
name|ConverterUtils
operator|.
name|getYarnUrlFromPath
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
comment|// Set timestamp and length of file so that the framework
comment|// can do basic sanity checks for the local resource
comment|// after it has been copied over to ensure it is the same
comment|// resource the client intended to use with the application
name|amJarRsrc
operator|.
name|setTimestamp
argument_list|(
name|destStatus
operator|.
name|getModificationTime
argument_list|()
argument_list|)
expr_stmt|;
name|amJarRsrc
operator|.
name|setSize
argument_list|(
name|destStatus
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
name|localResources
operator|.
name|put
argument_list|(
literal|"AppMaster.jar"
argument_list|,
name|amJarRsrc
argument_list|)
expr_stmt|;
comment|// Set the log4j properties if needed
if|if
condition|(
operator|!
name|log4jPropFile
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Path
name|log4jSrc
init|=
operator|new
name|Path
argument_list|(
name|log4jPropFile
argument_list|)
decl_stmt|;
name|Path
name|log4jDst
init|=
operator|new
name|Path
argument_list|(
name|fs
operator|.
name|getHomeDirectory
argument_list|()
argument_list|,
literal|"log4j.props"
argument_list|)
decl_stmt|;
name|fs
operator|.
name|copyFromLocalFile
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
name|log4jSrc
argument_list|,
name|log4jDst
argument_list|)
expr_stmt|;
name|FileStatus
name|log4jFileStatus
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|log4jDst
argument_list|)
decl_stmt|;
name|LocalResource
name|log4jRsrc
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|LocalResource
operator|.
name|class
argument_list|)
decl_stmt|;
name|log4jRsrc
operator|.
name|setType
argument_list|(
name|LocalResourceType
operator|.
name|FILE
argument_list|)
expr_stmt|;
name|log4jRsrc
operator|.
name|setVisibility
argument_list|(
name|LocalResourceVisibility
operator|.
name|APPLICATION
argument_list|)
expr_stmt|;
name|log4jRsrc
operator|.
name|setResource
argument_list|(
name|ConverterUtils
operator|.
name|getYarnUrlFromURI
argument_list|(
name|log4jDst
operator|.
name|toUri
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|log4jRsrc
operator|.
name|setTimestamp
argument_list|(
name|log4jFileStatus
operator|.
name|getModificationTime
argument_list|()
argument_list|)
expr_stmt|;
name|log4jRsrc
operator|.
name|setSize
argument_list|(
name|log4jFileStatus
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
name|localResources
operator|.
name|put
argument_list|(
literal|"log4j.properties"
argument_list|,
name|log4jRsrc
argument_list|)
expr_stmt|;
block|}
comment|// The shell script has to be made available on the final container(s)
comment|// where it will be executed.
comment|// To do this, we need to first copy into the filesystem that is visible
comment|// to the yarn framework.
comment|// We do not need to set this as a local resource for the application
comment|// master as the application master does not need it.
name|String
name|hdfsShellScriptLocation
init|=
literal|""
decl_stmt|;
name|long
name|hdfsShellScriptLen
init|=
literal|0
decl_stmt|;
name|long
name|hdfsShellScriptTimestamp
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|shellScriptPath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Path
name|shellSrc
init|=
operator|new
name|Path
argument_list|(
name|shellScriptPath
argument_list|)
decl_stmt|;
name|String
name|shellPathSuffix
init|=
name|appName
operator|+
literal|"/"
operator|+
name|appId
operator|.
name|getId
argument_list|()
operator|+
literal|"/ExecShellScript.sh"
decl_stmt|;
name|Path
name|shellDst
init|=
operator|new
name|Path
argument_list|(
name|fs
operator|.
name|getHomeDirectory
argument_list|()
argument_list|,
name|shellPathSuffix
argument_list|)
decl_stmt|;
name|fs
operator|.
name|copyFromLocalFile
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|,
name|shellSrc
argument_list|,
name|shellDst
argument_list|)
expr_stmt|;
name|hdfsShellScriptLocation
operator|=
name|shellDst
operator|.
name|toUri
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
name|FileStatus
name|shellFileStatus
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|shellDst
argument_list|)
decl_stmt|;
name|hdfsShellScriptLen
operator|=
name|shellFileStatus
operator|.
name|getLen
argument_list|()
expr_stmt|;
name|hdfsShellScriptTimestamp
operator|=
name|shellFileStatus
operator|.
name|getModificationTime
argument_list|()
expr_stmt|;
block|}
comment|// Set local resource info into app master container launch context
name|amContainer
operator|.
name|setLocalResources
argument_list|(
name|localResources
argument_list|)
expr_stmt|;
comment|// Set the necessary security tokens as needed
comment|//amContainer.setContainerTokens(containerToken);
comment|// Set the env variables to be setup in the env where the application master will be run
name|LOG
operator|.
name|info
argument_list|(
literal|"Set the environment for the application master"
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// put location of shell script into env
comment|// using the env info, the application master will create the correct local resource for the
comment|// eventual containers that will be launched to execute the shell scripts
name|env
operator|.
name|put
argument_list|(
name|DSConstants
operator|.
name|DISTRIBUTEDSHELLSCRIPTLOCATION
argument_list|,
name|hdfsShellScriptLocation
argument_list|)
expr_stmt|;
name|env
operator|.
name|put
argument_list|(
name|DSConstants
operator|.
name|DISTRIBUTEDSHELLSCRIPTTIMESTAMP
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|hdfsShellScriptTimestamp
argument_list|)
argument_list|)
expr_stmt|;
name|env
operator|.
name|put
argument_list|(
name|DSConstants
operator|.
name|DISTRIBUTEDSHELLSCRIPTLEN
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|hdfsShellScriptLen
argument_list|)
argument_list|)
expr_stmt|;
comment|// Add AppMaster.jar location to classpath
comment|// At some point we should not be required to add
comment|// the hadoop specific classpaths to the env.
comment|// It should be provided out of the box.
comment|// For now setting all required classpaths including
comment|// the classpath to "." for the application jar
name|StringBuilder
name|classPathEnv
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"${CLASSPATH}:./*"
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|c
range|:
name|conf
operator|.
name|get
argument_list|(
name|YarnConfiguration
operator|.
name|YARN_APPLICATION_CLASSPATH
argument_list|)
operator|.
name|split
argument_list|(
literal|","
argument_list|)
control|)
block|{
name|classPathEnv
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|classPathEnv
operator|.
name|append
argument_list|(
name|c
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|classPathEnv
operator|.
name|append
argument_list|(
literal|":./log4j.properties"
argument_list|)
expr_stmt|;
comment|// add the runtime classpath needed for tests to work
name|String
name|testRuntimeClassPath
init|=
name|Client
operator|.
name|getTestRuntimeClasspath
argument_list|()
decl_stmt|;
name|classPathEnv
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|classPathEnv
operator|.
name|append
argument_list|(
name|testRuntimeClassPath
argument_list|)
expr_stmt|;
name|env
operator|.
name|put
argument_list|(
literal|"CLASSPATH"
argument_list|,
name|classPathEnv
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|amContainer
operator|.
name|setEnvironment
argument_list|(
name|env
argument_list|)
expr_stmt|;
comment|// Set the necessary command to execute the application master
name|Vector
argument_list|<
name|CharSequence
argument_list|>
name|vargs
init|=
operator|new
name|Vector
argument_list|<
name|CharSequence
argument_list|>
argument_list|(
literal|30
argument_list|)
decl_stmt|;
comment|// Set java executable command
name|LOG
operator|.
name|info
argument_list|(
literal|"Setting up app master command"
argument_list|)
expr_stmt|;
name|vargs
operator|.
name|add
argument_list|(
literal|"${JAVA_HOME}"
operator|+
literal|"/bin/java"
argument_list|)
expr_stmt|;
comment|// Set Xmx based on am memory size
name|vargs
operator|.
name|add
argument_list|(
literal|"-Xmx"
operator|+
name|amMemory
operator|+
literal|"m"
argument_list|)
expr_stmt|;
comment|// Set class name
name|vargs
operator|.
name|add
argument_list|(
name|appMasterMainClass
argument_list|)
expr_stmt|;
comment|// Set params for Application Master
name|vargs
operator|.
name|add
argument_list|(
literal|"--container_memory "
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|containerMemory
argument_list|)
argument_list|)
expr_stmt|;
name|vargs
operator|.
name|add
argument_list|(
literal|"--num_containers "
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|numContainers
argument_list|)
argument_list|)
expr_stmt|;
name|vargs
operator|.
name|add
argument_list|(
literal|"--priority "
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|shellCmdPriority
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shellCommand
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|vargs
operator|.
name|add
argument_list|(
literal|"--shell_command "
operator|+
name|shellCommand
operator|+
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|shellArgs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|vargs
operator|.
name|add
argument_list|(
literal|"--shell_args "
operator|+
name|shellArgs
operator|+
literal|""
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|shellEnv
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|vargs
operator|.
name|add
argument_list|(
literal|"--shell_env "
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|+
literal|"="
operator|+
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debugFlag
condition|)
block|{
name|vargs
operator|.
name|add
argument_list|(
literal|"--debug"
argument_list|)
expr_stmt|;
block|}
name|vargs
operator|.
name|add
argument_list|(
literal|"1>"
operator|+
name|ApplicationConstants
operator|.
name|LOG_DIR_EXPANSION_VAR
operator|+
literal|"/AppMaster.stdout"
argument_list|)
expr_stmt|;
name|vargs
operator|.
name|add
argument_list|(
literal|"2>"
operator|+
name|ApplicationConstants
operator|.
name|LOG_DIR_EXPANSION_VAR
operator|+
literal|"/AppMaster.stderr"
argument_list|)
expr_stmt|;
comment|// Get final commmand
name|StringBuilder
name|command
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|CharSequence
name|str
range|:
name|vargs
control|)
block|{
name|command
operator|.
name|append
argument_list|(
name|str
argument_list|)
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Completed setting up app master command "
operator|+
name|command
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|commands
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|commands
operator|.
name|add
argument_list|(
name|command
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|amContainer
operator|.
name|setCommands
argument_list|(
name|commands
argument_list|)
expr_stmt|;
comment|// Set up resource type requirements
comment|// For now, only memory is supported so we set memory requirements
name|Resource
name|capability
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|Resource
operator|.
name|class
argument_list|)
decl_stmt|;
name|capability
operator|.
name|setMemory
argument_list|(
name|amMemory
argument_list|)
expr_stmt|;
name|amContainer
operator|.
name|setResource
argument_list|(
name|capability
argument_list|)
expr_stmt|;
comment|// Service data is a binary blob that can be passed to the application
comment|// Not needed in this scenario
comment|// amContainer.setServiceData(serviceData);
comment|// The following are not required for launching an application master
comment|// amContainer.setContainerId(containerId);
name|appContext
operator|.
name|setAMContainerSpec
argument_list|(
name|amContainer
argument_list|)
expr_stmt|;
comment|// Set the priority for the application master
name|Priority
name|pri
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|Priority
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// TODO - what is the range for priority? how to decide?
name|pri
operator|.
name|setPriority
argument_list|(
name|amPriority
argument_list|)
expr_stmt|;
name|appContext
operator|.
name|setPriority
argument_list|(
name|pri
argument_list|)
expr_stmt|;
comment|// Set the queue to which this application is to be submitted in the RM
name|appContext
operator|.
name|setQueue
argument_list|(
name|amQueue
argument_list|)
expr_stmt|;
comment|// Create the request to send to the applications manager
name|SubmitApplicationRequest
name|appRequest
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|SubmitApplicationRequest
operator|.
name|class
argument_list|)
decl_stmt|;
name|appRequest
operator|.
name|setApplicationSubmissionContext
argument_list|(
name|appContext
argument_list|)
expr_stmt|;
comment|// Submit the application to the applications manager
comment|// SubmitApplicationResponse submitResp = applicationsManager.submitApplication(appRequest);
comment|// Ignore the response as either a valid response object is returned on success
comment|// or an exception thrown to denote some form of a failure
name|LOG
operator|.
name|info
argument_list|(
literal|"Submitting application to ASM"
argument_list|)
expr_stmt|;
name|applicationsManager
operator|.
name|submitApplication
argument_list|(
name|appRequest
argument_list|)
expr_stmt|;
comment|// TODO
comment|// Try submitting the same request again
comment|// app submission failure?
comment|// Monitor the application
return|return
name|monitorApplication
argument_list|(
name|appId
argument_list|)
return|;
block|}
comment|/**    * Monitor the submitted application for completion.     * Kill application if time expires.     * @param appId Application Id of application to be monitored    * @return true if application completed successfully    * @throws YarnRemoteException    */
DECL|method|monitorApplication (ApplicationId appId)
specifier|private
name|boolean
name|monitorApplication
parameter_list|(
name|ApplicationId
name|appId
parameter_list|)
throws|throws
name|YarnRemoteException
block|{
while|while
condition|(
literal|true
condition|)
block|{
comment|// Check app status every 1 second.
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Thread sleep in monitoring loop interrupted"
argument_list|)
expr_stmt|;
block|}
comment|// Get application report for the appId we are interested in
name|GetApplicationReportRequest
name|reportRequest
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|GetApplicationReportRequest
operator|.
name|class
argument_list|)
decl_stmt|;
name|reportRequest
operator|.
name|setApplicationId
argument_list|(
name|appId
argument_list|)
expr_stmt|;
name|GetApplicationReportResponse
name|reportResponse
init|=
name|applicationsManager
operator|.
name|getApplicationReport
argument_list|(
name|reportRequest
argument_list|)
decl_stmt|;
name|ApplicationReport
name|report
init|=
name|reportResponse
operator|.
name|getApplicationReport
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Got application report from ASM for"
operator|+
literal|", appId="
operator|+
name|appId
operator|.
name|getId
argument_list|()
operator|+
literal|", clientToken="
operator|+
name|report
operator|.
name|getClientToken
argument_list|()
operator|+
literal|", appDiagnostics="
operator|+
name|report
operator|.
name|getDiagnostics
argument_list|()
operator|+
literal|", appMasterHost="
operator|+
name|report
operator|.
name|getHost
argument_list|()
operator|+
literal|", appQueue="
operator|+
name|report
operator|.
name|getQueue
argument_list|()
operator|+
literal|", appMasterRpcPort="
operator|+
name|report
operator|.
name|getRpcPort
argument_list|()
operator|+
literal|", appStartTime="
operator|+
name|report
operator|.
name|getStartTime
argument_list|()
operator|+
literal|", yarnAppState="
operator|+
name|report
operator|.
name|getYarnApplicationState
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|", distributedFinalState="
operator|+
name|report
operator|.
name|getFinalApplicationStatus
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|", appTrackingUrl="
operator|+
name|report
operator|.
name|getTrackingUrl
argument_list|()
operator|+
literal|", appUser="
operator|+
name|report
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
name|YarnApplicationState
name|state
init|=
name|report
operator|.
name|getYarnApplicationState
argument_list|()
decl_stmt|;
name|FinalApplicationStatus
name|dsStatus
init|=
name|report
operator|.
name|getFinalApplicationStatus
argument_list|()
decl_stmt|;
if|if
condition|(
name|YarnApplicationState
operator|.
name|FINISHED
operator|==
name|state
condition|)
block|{
if|if
condition|(
name|FinalApplicationStatus
operator|.
name|SUCCEEDED
operator|==
name|dsStatus
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Application has completed successfully. Breaking monitoring loop"
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Application did finished unsuccessfully."
operator|+
literal|" YarnState="
operator|+
name|state
operator|.
name|toString
argument_list|()
operator|+
literal|", DSFinalStatus="
operator|+
name|dsStatus
operator|.
name|toString
argument_list|()
operator|+
literal|". Breaking monitoring loop"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|YarnApplicationState
operator|.
name|KILLED
operator|==
name|state
operator|||
name|YarnApplicationState
operator|.
name|FAILED
operator|==
name|state
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Application did not finish."
operator|+
literal|" YarnState="
operator|+
name|state
operator|.
name|toString
argument_list|()
operator|+
literal|", DSFinalStatus="
operator|+
name|dsStatus
operator|.
name|toString
argument_list|()
operator|+
literal|". Breaking monitoring loop"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|>
operator|(
name|clientStartTime
operator|+
name|clientTimeout
operator|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Reached client specified timeout for application. Killing application"
argument_list|)
expr_stmt|;
name|killApplication
argument_list|(
name|appId
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
comment|/**    * Kill a submitted application by sending a call to the ASM    * @param appId Application Id to be killed.     * @throws YarnRemoteException    */
DECL|method|killApplication (ApplicationId appId)
specifier|private
name|void
name|killApplication
parameter_list|(
name|ApplicationId
name|appId
parameter_list|)
throws|throws
name|YarnRemoteException
block|{
name|KillApplicationRequest
name|request
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|KillApplicationRequest
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// TODO clarify whether multiple jobs with the same app id can be submitted and be running at
comment|// the same time.
comment|// If yes, can we kill a particular attempt only?
name|request
operator|.
name|setApplicationId
argument_list|(
name|appId
argument_list|)
expr_stmt|;
comment|// KillApplicationResponse response = applicationsManager.forceKillApplication(request);
comment|// Response can be ignored as it is non-null on success or
comment|// throws an exception in case of failures
name|applicationsManager
operator|.
name|forceKillApplication
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
comment|/**    * Connect to the Resource Manager/Applications Manager    * @return Handle to communicate with the ASM    * @throws IOException     */
DECL|method|connectToASM ()
specifier|private
name|void
name|connectToASM
parameter_list|()
throws|throws
name|IOException
block|{
comment|/* 		UserGroupInformation user = UserGroupInformation.getCurrentUser(); 		applicationsManager = user.doAs(new PrivilegedAction<ClientRMProtocol>() { 			public ClientRMProtocol run() { 				InetSocketAddress rmAddress = NetUtils.createSocketAddr(conf.get( 					YarnConfiguration.RM_SCHEDULER_ADDRESS, 					YarnConfiguration.DEFAULT_RM_SCHEDULER_ADDRESS));		 				LOG.info("Connecting to ResourceManager at " + rmAddress); 				Configuration appsManagerServerConf = new Configuration(conf); 				appsManagerServerConf.setClass(YarnConfiguration.YARN_SECURITY_INFO, 				ClientRMSecurityInfo.class, SecurityInfo.class); 				ClientRMProtocol asm = ((ClientRMProtocol) rpc.getProxy(ClientRMProtocol.class, rmAddress, appsManagerServerConf)); 				return asm; 			} 		});      */
name|YarnConfiguration
name|yarnConf
init|=
operator|new
name|YarnConfiguration
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|InetSocketAddress
name|rmAddress
init|=
name|yarnConf
operator|.
name|getSocketAddr
argument_list|(
name|YarnConfiguration
operator|.
name|RM_ADDRESS
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_RM_ADDRESS
argument_list|,
name|YarnConfiguration
operator|.
name|DEFAULT_RM_PORT
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Connecting to ResourceManager at "
operator|+
name|rmAddress
argument_list|)
expr_stmt|;
name|applicationsManager
operator|=
operator|(
operator|(
name|ClientRMProtocol
operator|)
name|rpc
operator|.
name|getProxy
argument_list|(
name|ClientRMProtocol
operator|.
name|class
argument_list|,
name|rmAddress
argument_list|,
name|conf
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/**    * Get a new application from the ASM     * @return New Application    * @throws YarnRemoteException    */
DECL|method|getApplication ()
specifier|private
name|GetNewApplicationResponse
name|getApplication
parameter_list|()
throws|throws
name|YarnRemoteException
block|{
name|GetNewApplicationRequest
name|request
init|=
name|Records
operator|.
name|newRecord
argument_list|(
name|GetNewApplicationRequest
operator|.
name|class
argument_list|)
decl_stmt|;
name|GetNewApplicationResponse
name|response
init|=
name|applicationsManager
operator|.
name|getNewApplication
argument_list|(
name|request
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Got new application id="
operator|+
name|response
operator|.
name|getApplicationId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|response
return|;
block|}
DECL|method|getTestRuntimeClasspath ()
specifier|private
specifier|static
name|String
name|getTestRuntimeClasspath
parameter_list|()
block|{
name|InputStream
name|classpathFileStream
init|=
literal|null
decl_stmt|;
name|BufferedReader
name|reader
init|=
literal|null
decl_stmt|;
name|String
name|envClassPath
init|=
literal|""
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Trying to generate classpath for app master from current thread's classpath"
argument_list|)
expr_stmt|;
try|try
block|{
comment|// Create classpath from generated classpath
comment|// Check maven ppom.xml for generated classpath info
comment|// Works if compile time env is same as runtime. Mainly tests.
name|ClassLoader
name|thisClassLoader
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getContextClassLoader
argument_list|()
decl_stmt|;
name|String
name|generatedClasspathFile
init|=
literal|"yarn-apps-ds-generated-classpath"
decl_stmt|;
name|classpathFileStream
operator|=
name|thisClassLoader
operator|.
name|getResourceAsStream
argument_list|(
name|generatedClasspathFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|classpathFileStream
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Could not classpath resource from class loader"
argument_list|)
expr_stmt|;
return|return
name|envClassPath
return|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Readable bytes from stream="
operator|+
name|classpathFileStream
operator|.
name|available
argument_list|()
argument_list|)
expr_stmt|;
name|reader
operator|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|classpathFileStream
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|cp
init|=
name|reader
operator|.
name|readLine
argument_list|()
decl_stmt|;
if|if
condition|(
name|cp
operator|!=
literal|null
condition|)
block|{
name|envClassPath
operator|+=
name|cp
operator|.
name|trim
argument_list|()
operator|+
literal|":"
expr_stmt|;
block|}
comment|// Put the file itself on classpath for tasks.
name|envClassPath
operator|+=
name|thisClassLoader
operator|.
name|getResource
argument_list|(
name|generatedClasspathFile
argument_list|)
operator|.
name|getFile
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Could not find the necessary resource to generate class path for tests. Error="
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|classpathFileStream
operator|!=
literal|null
condition|)
block|{
name|classpathFileStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|reader
operator|!=
literal|null
condition|)
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to close class path file stream or reader. Error="
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|envClassPath
return|;
block|}
block|}
end_class

end_unit

