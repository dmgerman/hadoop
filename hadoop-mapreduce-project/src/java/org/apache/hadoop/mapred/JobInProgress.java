begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Vector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocalFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|CleanupQueue
operator|.
name|PathDeletionContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobCounter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobSubmissionFiles
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|MRJobConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|counters
operator|.
name|LimitExceededException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|jobhistory
operator|.
name|JobFinishedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|jobhistory
operator|.
name|JobHistory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|jobhistory
operator|.
name|JobInfoChangeEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|jobhistory
operator|.
name|JobInitedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|jobhistory
operator|.
name|JobPriorityChangeEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|jobhistory
operator|.
name|JobStatusChangedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|jobhistory
operator|.
name|JobSubmittedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|jobhistory
operator|.
name|JobUnsuccessfulCompletionEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|jobhistory
operator|.
name|MapAttemptFinishedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|jobhistory
operator|.
name|ReduceAttemptFinishedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|jobhistory
operator|.
name|TaskAttemptStartedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|jobhistory
operator|.
name|TaskAttemptUnsuccessfulCompletionEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|jobhistory
operator|.
name|TaskFailedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|jobhistory
operator|.
name|TaskFinishedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|jobhistory
operator|.
name|TaskStartedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|security
operator|.
name|TokenCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|Credentials
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|security
operator|.
name|token
operator|.
name|DelegationTokenRenewal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|security
operator|.
name|token
operator|.
name|JobTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|server
operator|.
name|jobtracker
operator|.
name|TaskTracker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|split
operator|.
name|JobSplit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|split
operator|.
name|SplitMetaInfoReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|split
operator|.
name|JobSplit
operator|.
name|TaskSplitMetaInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|task
operator|.
name|JobContextImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetworkTopology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_comment
comment|/**  * JobInProgress maintains all the info for keeping a Job on the straight and  * narrow. It keeps its JobProfile and its latest JobStatus, plus a set of  * tables for doing bookkeeping of its Tasks.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"MapReduce"
block|}
argument_list|)
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|JobInProgress
specifier|public
class|class
name|JobInProgress
block|{
comment|/**    * Used when the a kill is issued to a job which is initializing.    */
DECL|class|KillInterruptedException
specifier|static
class|class
name|KillInterruptedException
extends|extends
name|InterruptedException
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
DECL|method|KillInterruptedException (String msg)
specifier|public
name|KillInterruptedException
parameter_list|(
name|String
name|msg
parameter_list|)
block|{
name|super
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|JobInProgress
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|profile
name|JobProfile
name|profile
decl_stmt|;
DECL|field|status
name|JobStatus
name|status
decl_stmt|;
DECL|field|jobFile
name|Path
name|jobFile
init|=
literal|null
decl_stmt|;
DECL|field|localJobFile
name|Path
name|localJobFile
init|=
literal|null
decl_stmt|;
DECL|field|maps
name|TaskInProgress
name|maps
index|[]
init|=
operator|new
name|TaskInProgress
index|[
literal|0
index|]
decl_stmt|;
DECL|field|reduces
name|TaskInProgress
name|reduces
index|[]
init|=
operator|new
name|TaskInProgress
index|[
literal|0
index|]
decl_stmt|;
DECL|field|cleanup
name|TaskInProgress
name|cleanup
index|[]
init|=
operator|new
name|TaskInProgress
index|[
literal|0
index|]
decl_stmt|;
DECL|field|setup
name|TaskInProgress
name|setup
index|[]
init|=
operator|new
name|TaskInProgress
index|[
literal|0
index|]
decl_stmt|;
DECL|field|numMapTasks
name|int
name|numMapTasks
init|=
literal|0
decl_stmt|;
DECL|field|numReduceTasks
name|int
name|numReduceTasks
init|=
literal|0
decl_stmt|;
DECL|field|memoryPerMap
specifier|final
name|long
name|memoryPerMap
decl_stmt|;
DECL|field|memoryPerReduce
specifier|final
name|long
name|memoryPerReduce
decl_stmt|;
DECL|field|numSlotsPerMap
specifier|volatile
name|int
name|numSlotsPerMap
init|=
literal|1
decl_stmt|;
DECL|field|numSlotsPerReduce
specifier|volatile
name|int
name|numSlotsPerReduce
init|=
literal|1
decl_stmt|;
DECL|field|maxTaskFailuresPerTracker
specifier|final
name|int
name|maxTaskFailuresPerTracker
decl_stmt|;
comment|// Counters to track currently running/finished/failed Map/Reduce task-attempts
DECL|field|runningMapTasks
name|int
name|runningMapTasks
init|=
literal|0
decl_stmt|;
DECL|field|runningReduceTasks
name|int
name|runningReduceTasks
init|=
literal|0
decl_stmt|;
DECL|field|finishedMapTasks
name|int
name|finishedMapTasks
init|=
literal|0
decl_stmt|;
DECL|field|finishedReduceTasks
name|int
name|finishedReduceTasks
init|=
literal|0
decl_stmt|;
DECL|field|failedMapTasks
name|int
name|failedMapTasks
init|=
literal|0
decl_stmt|;
DECL|field|failedReduceTasks
name|int
name|failedReduceTasks
init|=
literal|0
decl_stmt|;
DECL|field|DEFAULT_COMPLETED_MAPS_PERCENT_FOR_REDUCE_SLOWSTART
specifier|static
specifier|final
name|float
name|DEFAULT_COMPLETED_MAPS_PERCENT_FOR_REDUCE_SLOWSTART
init|=
literal|0.05f
decl_stmt|;
DECL|field|completedMapsForReduceSlowstart
name|int
name|completedMapsForReduceSlowstart
init|=
literal|0
decl_stmt|;
comment|// runningMapTasks include speculative tasks, so we need to capture
comment|// speculative tasks separately
DECL|field|speculativeMapTasks
name|int
name|speculativeMapTasks
init|=
literal|0
decl_stmt|;
DECL|field|speculativeReduceTasks
name|int
name|speculativeReduceTasks
init|=
literal|0
decl_stmt|;
DECL|field|mapFailuresPercent
name|int
name|mapFailuresPercent
init|=
literal|0
decl_stmt|;
DECL|field|reduceFailuresPercent
name|int
name|reduceFailuresPercent
init|=
literal|0
decl_stmt|;
DECL|field|failedMapTIPs
name|int
name|failedMapTIPs
init|=
literal|0
decl_stmt|;
DECL|field|failedReduceTIPs
name|int
name|failedReduceTIPs
init|=
literal|0
decl_stmt|;
DECL|field|launchedCleanup
specifier|private
specifier|volatile
name|boolean
name|launchedCleanup
init|=
literal|false
decl_stmt|;
DECL|field|launchedSetup
specifier|private
specifier|volatile
name|boolean
name|launchedSetup
init|=
literal|false
decl_stmt|;
DECL|field|jobKilled
specifier|private
specifier|volatile
name|boolean
name|jobKilled
init|=
literal|false
decl_stmt|;
DECL|field|jobFailed
specifier|private
specifier|volatile
name|boolean
name|jobFailed
init|=
literal|false
decl_stmt|;
DECL|field|jobSetupCleanupNeeded
specifier|private
specifier|final
name|boolean
name|jobSetupCleanupNeeded
decl_stmt|;
DECL|field|taskCleanupNeeded
specifier|private
specifier|final
name|boolean
name|taskCleanupNeeded
decl_stmt|;
DECL|field|priority
name|JobPriority
name|priority
init|=
name|JobPriority
operator|.
name|NORMAL
decl_stmt|;
DECL|field|jobtracker
specifier|protected
name|JobTracker
name|jobtracker
decl_stmt|;
DECL|field|tokenStorage
specifier|protected
name|Credentials
name|tokenStorage
decl_stmt|;
DECL|field|jobHistory
name|JobHistory
name|jobHistory
decl_stmt|;
comment|// NetworkTopology Node to the set of TIPs
DECL|field|nonRunningMapCache
name|Map
argument_list|<
name|Node
argument_list|,
name|List
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|>
name|nonRunningMapCache
decl_stmt|;
comment|// Map of NetworkTopology Node to set of running TIPs
DECL|field|runningMapCache
name|Map
argument_list|<
name|Node
argument_list|,
name|Set
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|>
name|runningMapCache
decl_stmt|;
comment|// A list of non-local non-running maps
DECL|field|nonLocalMaps
name|List
argument_list|<
name|TaskInProgress
argument_list|>
name|nonLocalMaps
decl_stmt|;
comment|// A set of non-local running maps
DECL|field|nonLocalRunningMaps
name|Set
argument_list|<
name|TaskInProgress
argument_list|>
name|nonLocalRunningMaps
decl_stmt|;
comment|// A list of non-running reduce TIPs
DECL|field|nonRunningReduces
name|List
argument_list|<
name|TaskInProgress
argument_list|>
name|nonRunningReduces
decl_stmt|;
comment|// A set of running reduce TIPs
DECL|field|runningReduces
name|Set
argument_list|<
name|TaskInProgress
argument_list|>
name|runningReduces
decl_stmt|;
comment|// A list of cleanup tasks for the map task attempts, to be launched
DECL|field|mapCleanupTasks
name|List
argument_list|<
name|TaskAttemptID
argument_list|>
name|mapCleanupTasks
init|=
operator|new
name|LinkedList
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|()
decl_stmt|;
comment|// A list of cleanup tasks for the reduce task attempts, to be launched
DECL|field|reduceCleanupTasks
name|List
argument_list|<
name|TaskAttemptID
argument_list|>
name|reduceCleanupTasks
init|=
operator|new
name|LinkedList
argument_list|<
name|TaskAttemptID
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|maxLevel
name|int
name|maxLevel
decl_stmt|;
comment|/**    * A special value indicating that     * {@link #findNewMapTask(TaskTrackerStatus, int, int, int, double)} should    * schedule any available map tasks for this job, including speculative tasks.    */
DECL|field|anyCacheLevel
name|int
name|anyCacheLevel
decl_stmt|;
comment|/**    * A special value indicating that     * {@link #findNewMapTask(TaskTrackerStatus, int, int, int, double)} should    * schedule any only off-switch and speculative map tasks for this job.    */
DECL|field|NON_LOCAL_CACHE_LEVEL
specifier|private
specifier|static
specifier|final
name|int
name|NON_LOCAL_CACHE_LEVEL
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|taskCompletionEventTracker
specifier|private
name|int
name|taskCompletionEventTracker
init|=
literal|0
decl_stmt|;
DECL|field|taskCompletionEvents
name|List
argument_list|<
name|TaskCompletionEvent
argument_list|>
name|taskCompletionEvents
decl_stmt|;
comment|// The maximum percentage of trackers in cluster added to the 'blacklist'.
DECL|field|CLUSTER_BLACKLIST_PERCENT
specifier|private
specifier|static
specifier|final
name|double
name|CLUSTER_BLACKLIST_PERCENT
init|=
literal|0.25
decl_stmt|;
comment|// The maximum percentage of fetch failures allowed for a map
DECL|field|MAX_ALLOWED_FETCH_FAILURES_PERCENT
specifier|private
specifier|static
specifier|final
name|double
name|MAX_ALLOWED_FETCH_FAILURES_PERCENT
init|=
literal|0.5
decl_stmt|;
comment|// No. of tasktrackers in the cluster
DECL|field|clusterSize
specifier|private
specifier|volatile
name|int
name|clusterSize
init|=
literal|0
decl_stmt|;
comment|// The no. of tasktrackers where>= conf.getMaxTaskFailuresPerTracker()
comment|// tasks have failed
DECL|field|flakyTaskTrackers
specifier|private
specifier|volatile
name|int
name|flakyTaskTrackers
init|=
literal|0
decl_stmt|;
comment|// Map of trackerHostName -> no. of task failures
DECL|field|trackerToFailuresMap
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|trackerToFailuresMap
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
comment|//Confine estimation algorithms to an "oracle" class that JIP queries.
DECL|field|resourceEstimator
name|ResourceEstimator
name|resourceEstimator
decl_stmt|;
DECL|field|startTime
name|long
name|startTime
decl_stmt|;
DECL|field|launchTime
name|long
name|launchTime
decl_stmt|;
DECL|field|finishTime
name|long
name|finishTime
decl_stmt|;
comment|// First *task launch times
DECL|field|firstTaskLaunchTimes
specifier|final
name|Map
argument_list|<
name|TaskType
argument_list|,
name|Long
argument_list|>
name|firstTaskLaunchTimes
init|=
operator|new
name|EnumMap
argument_list|<
name|TaskType
argument_list|,
name|Long
argument_list|>
argument_list|(
name|TaskType
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Indicates how many times the job got restarted
DECL|field|restartCount
specifier|private
specifier|final
name|int
name|restartCount
decl_stmt|;
DECL|field|conf
name|JobConf
name|conf
decl_stmt|;
DECL|field|tasksInited
specifier|protected
name|AtomicBoolean
name|tasksInited
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|field|jobInitKillStatus
specifier|private
name|JobInitKillStatus
name|jobInitKillStatus
init|=
operator|new
name|JobInitKillStatus
argument_list|()
decl_stmt|;
DECL|field|localFs
name|LocalFileSystem
name|localFs
decl_stmt|;
DECL|field|fs
name|FileSystem
name|fs
decl_stmt|;
DECL|field|user
name|String
name|user
decl_stmt|;
DECL|field|jobId
name|JobID
name|jobId
decl_stmt|;
DECL|field|hasSpeculativeMaps
specifier|volatile
specifier|private
name|boolean
name|hasSpeculativeMaps
decl_stmt|;
DECL|field|hasSpeculativeReduces
specifier|volatile
specifier|private
name|boolean
name|hasSpeculativeReduces
decl_stmt|;
DECL|field|inputLength
name|long
name|inputLength
init|=
literal|0
decl_stmt|;
DECL|field|jobCounters
name|Counters
name|jobCounters
init|=
operator|new
name|Counters
argument_list|()
decl_stmt|;
comment|// Maximum no. of fetch-failure notifications after which map task is killed
DECL|field|MAX_FETCH_FAILURES_NOTIFICATIONS
specifier|private
specifier|static
specifier|final
name|int
name|MAX_FETCH_FAILURES_NOTIFICATIONS
init|=
literal|3
decl_stmt|;
comment|// Don't lower speculativeCap below one TT's worth (for small clusters)
DECL|field|MIN_SPEC_CAP
specifier|private
specifier|static
specifier|final
name|int
name|MIN_SPEC_CAP
init|=
literal|10
decl_stmt|;
DECL|field|MIN_SLOTS_CAP
specifier|private
specifier|static
specifier|final
name|float
name|MIN_SLOTS_CAP
init|=
literal|0.01f
decl_stmt|;
comment|// Map of mapTaskId -> no. of fetch failures
DECL|field|mapTaskIdToFetchFailuresMap
specifier|private
name|Map
argument_list|<
name|TaskAttemptID
argument_list|,
name|Integer
argument_list|>
name|mapTaskIdToFetchFailuresMap
init|=
operator|new
name|TreeMap
argument_list|<
name|TaskAttemptID
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|schedulingInfo
specifier|private
name|Object
name|schedulingInfo
decl_stmt|;
DECL|field|submitHostName
specifier|private
name|String
name|submitHostName
decl_stmt|;
DECL|field|submitHostAddress
specifier|private
name|String
name|submitHostAddress
decl_stmt|;
comment|//thresholds for speculative execution
DECL|field|slowTaskThreshold
name|float
name|slowTaskThreshold
decl_stmt|;
DECL|field|speculativeCap
name|float
name|speculativeCap
decl_stmt|;
DECL|field|slowNodeThreshold
name|float
name|slowNodeThreshold
decl_stmt|;
comment|//standard deviations
comment|//Statistics are maintained for a couple of things
comment|//mapTaskStats is used for maintaining statistics about
comment|//the completion time of map tasks on the trackers. On a per
comment|//tracker basis, the mean time for task completion is maintained
DECL|field|mapTaskStats
specifier|private
name|DataStatistics
name|mapTaskStats
init|=
operator|new
name|DataStatistics
argument_list|()
decl_stmt|;
comment|//reduceTaskStats is used for maintaining statistics about
comment|//the completion time of reduce tasks on the trackers. On a per
comment|//tracker basis, the mean time for task completion is maintained
DECL|field|reduceTaskStats
specifier|private
name|DataStatistics
name|reduceTaskStats
init|=
operator|new
name|DataStatistics
argument_list|()
decl_stmt|;
comment|//trackerMapStats used to maintain a mapping from the tracker to the
comment|//the statistics about completion time of map tasks
DECL|field|trackerMapStats
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|DataStatistics
argument_list|>
name|trackerMapStats
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|DataStatistics
argument_list|>
argument_list|()
decl_stmt|;
comment|//trackerReduceStats used to maintain a mapping from the tracker to the
comment|//the statistics about completion time of reduce tasks
DECL|field|trackerReduceStats
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|DataStatistics
argument_list|>
name|trackerReduceStats
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|DataStatistics
argument_list|>
argument_list|()
decl_stmt|;
comment|//runningMapStats used to maintain the RUNNING map tasks' statistics
DECL|field|runningMapTaskStats
specifier|private
name|DataStatistics
name|runningMapTaskStats
init|=
operator|new
name|DataStatistics
argument_list|()
decl_stmt|;
comment|//runningReduceStats used to maintain the RUNNING reduce tasks' statistics
DECL|field|runningReduceTaskStats
specifier|private
name|DataStatistics
name|runningReduceTaskStats
init|=
operator|new
name|DataStatistics
argument_list|()
decl_stmt|;
DECL|class|FallowSlotInfo
specifier|private
specifier|static
class|class
name|FallowSlotInfo
block|{
DECL|field|timestamp
name|long
name|timestamp
decl_stmt|;
DECL|field|numSlots
name|int
name|numSlots
decl_stmt|;
DECL|method|FallowSlotInfo (long timestamp, int numSlots)
specifier|public
name|FallowSlotInfo
parameter_list|(
name|long
name|timestamp
parameter_list|,
name|int
name|numSlots
parameter_list|)
block|{
name|this
operator|.
name|timestamp
operator|=
name|timestamp
expr_stmt|;
name|this
operator|.
name|numSlots
operator|=
name|numSlots
expr_stmt|;
block|}
DECL|method|getTimestamp ()
specifier|public
name|long
name|getTimestamp
parameter_list|()
block|{
return|return
name|timestamp
return|;
block|}
DECL|method|setTimestamp (long timestamp)
specifier|public
name|void
name|setTimestamp
parameter_list|(
name|long
name|timestamp
parameter_list|)
block|{
name|this
operator|.
name|timestamp
operator|=
name|timestamp
expr_stmt|;
block|}
DECL|method|getNumSlots ()
specifier|public
name|int
name|getNumSlots
parameter_list|()
block|{
return|return
name|numSlots
return|;
block|}
DECL|method|setNumSlots (int numSlots)
specifier|public
name|void
name|setNumSlots
parameter_list|(
name|int
name|numSlots
parameter_list|)
block|{
name|this
operator|.
name|numSlots
operator|=
name|numSlots
expr_stmt|;
block|}
block|}
DECL|field|trackersReservedForMaps
specifier|private
name|Map
argument_list|<
name|TaskTracker
argument_list|,
name|FallowSlotInfo
argument_list|>
name|trackersReservedForMaps
init|=
operator|new
name|HashMap
argument_list|<
name|TaskTracker
argument_list|,
name|FallowSlotInfo
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|trackersReservedForReduces
specifier|private
name|Map
argument_list|<
name|TaskTracker
argument_list|,
name|FallowSlotInfo
argument_list|>
name|trackersReservedForReduces
init|=
operator|new
name|HashMap
argument_list|<
name|TaskTracker
argument_list|,
name|FallowSlotInfo
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|jobSubmitDir
specifier|private
name|Path
name|jobSubmitDir
init|=
literal|null
decl_stmt|;
comment|/**    * Create an almost empty JobInProgress, which can be used only for tests    */
DECL|method|JobInProgress (JobID jobid, JobConf conf, JobTracker tracker)
specifier|protected
name|JobInProgress
parameter_list|(
name|JobID
name|jobid
parameter_list|,
name|JobConf
name|conf
parameter_list|,
name|JobTracker
name|tracker
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|jobId
operator|=
name|jobid
expr_stmt|;
name|this
operator|.
name|numMapTasks
operator|=
name|conf
operator|.
name|getNumMapTasks
argument_list|()
expr_stmt|;
name|this
operator|.
name|numReduceTasks
operator|=
name|conf
operator|.
name|getNumReduceTasks
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxLevel
operator|=
name|NetworkTopology
operator|.
name|DEFAULT_HOST_LEVEL
expr_stmt|;
name|this
operator|.
name|anyCacheLevel
operator|=
name|this
operator|.
name|maxLevel
operator|+
literal|1
expr_stmt|;
name|this
operator|.
name|jobtracker
operator|=
name|tracker
expr_stmt|;
name|this
operator|.
name|restartCount
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|profile
operator|=
operator|new
name|JobProfile
argument_list|(
name|conf
operator|.
name|getUser
argument_list|()
argument_list|,
name|jobid
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|conf
operator|.
name|getJobName
argument_list|()
argument_list|,
name|conf
operator|.
name|getQueueName
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|memoryPerMap
operator|=
name|conf
operator|.
name|getMemoryForMapTask
argument_list|()
expr_stmt|;
name|this
operator|.
name|memoryPerReduce
operator|=
name|conf
operator|.
name|getMemoryForReduceTask
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxTaskFailuresPerTracker
operator|=
name|conf
operator|.
name|getMaxTaskFailuresPerTracker
argument_list|()
expr_stmt|;
name|hasSpeculativeMaps
operator|=
name|conf
operator|.
name|getMapSpeculativeExecution
argument_list|()
expr_stmt|;
name|hasSpeculativeReduces
operator|=
name|conf
operator|.
name|getReduceSpeculativeExecution
argument_list|()
expr_stmt|;
name|this
operator|.
name|nonLocalMaps
operator|=
operator|new
name|LinkedList
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|nonLocalRunningMaps
operator|=
operator|new
name|LinkedHashSet
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|runningMapCache
operator|=
operator|new
name|IdentityHashMap
argument_list|<
name|Node
argument_list|,
name|Set
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|nonRunningReduces
operator|=
operator|new
name|LinkedList
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|runningReduces
operator|=
operator|new
name|LinkedHashSet
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|resourceEstimator
operator|=
operator|new
name|ResourceEstimator
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|status
operator|=
operator|new
name|JobStatus
argument_list|(
name|jobid
argument_list|,
literal|0.0f
argument_list|,
literal|0.0f
argument_list|,
name|JobStatus
operator|.
name|PREP
argument_list|,
name|this
operator|.
name|profile
operator|.
name|getUser
argument_list|()
argument_list|,
name|this
operator|.
name|profile
operator|.
name|getJobName
argument_list|()
argument_list|,
name|this
operator|.
name|profile
operator|.
name|getJobFile
argument_list|()
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|this
operator|.
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|addPrepJob
argument_list|(
name|conf
argument_list|,
name|jobid
argument_list|)
expr_stmt|;
name|this
operator|.
name|taskCompletionEvents
operator|=
operator|new
name|ArrayList
argument_list|<
name|TaskCompletionEvent
argument_list|>
argument_list|(
name|numMapTasks
operator|+
name|numReduceTasks
operator|+
literal|10
argument_list|)
expr_stmt|;
name|this
operator|.
name|slowTaskThreshold
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|0.0f
argument_list|,
name|conf
operator|.
name|getFloat
argument_list|(
name|MRJobConfig
operator|.
name|SPECULATIVE_SLOWTASK_THRESHOLD
argument_list|,
literal|1.0f
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|speculativeCap
operator|=
name|conf
operator|.
name|getFloat
argument_list|(
name|MRJobConfig
operator|.
name|SPECULATIVECAP
argument_list|,
literal|0.1f
argument_list|)
expr_stmt|;
name|this
operator|.
name|slowNodeThreshold
operator|=
name|conf
operator|.
name|getFloat
argument_list|(
name|MRJobConfig
operator|.
name|SPECULATIVE_SLOWNODE_THRESHOLD
argument_list|,
literal|1.0f
argument_list|)
expr_stmt|;
name|this
operator|.
name|jobSetupCleanupNeeded
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|MRJobConfig
operator|.
name|SETUP_CLEANUP_NEEDED
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|taskCleanupNeeded
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|MRJobConfig
operator|.
name|TASK_CLEANUP_NEEDED
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracker
operator|!=
literal|null
condition|)
block|{
comment|// Some mock tests have null tracker
name|this
operator|.
name|jobHistory
operator|=
name|tracker
operator|.
name|getJobHistory
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|tokenStorage
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|JobInProgress (JobConf conf)
name|JobInProgress
parameter_list|(
name|JobConf
name|conf
parameter_list|)
block|{
name|restartCount
operator|=
literal|0
expr_stmt|;
name|jobSetupCleanupNeeded
operator|=
literal|false
expr_stmt|;
name|taskCleanupNeeded
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|memoryPerMap
operator|=
name|conf
operator|.
name|getMemoryForMapTask
argument_list|()
expr_stmt|;
name|this
operator|.
name|memoryPerReduce
operator|=
name|conf
operator|.
name|getMemoryForReduceTask
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxTaskFailuresPerTracker
operator|=
name|conf
operator|.
name|getMaxTaskFailuresPerTracker
argument_list|()
expr_stmt|;
block|}
comment|/**    * Create a JobInProgress with the given job file, plus a handle    * to the tracker.    */
DECL|method|JobInProgress (JobTracker jobtracker, final JobConf default_conf, int rCount, JobInfo jobInfo, Credentials ts )
specifier|public
name|JobInProgress
parameter_list|(
name|JobTracker
name|jobtracker
parameter_list|,
specifier|final
name|JobConf
name|default_conf
parameter_list|,
name|int
name|rCount
parameter_list|,
name|JobInfo
name|jobInfo
parameter_list|,
name|Credentials
name|ts
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
try|try
block|{
name|this
operator|.
name|restartCount
operator|=
name|rCount
expr_stmt|;
name|this
operator|.
name|jobId
operator|=
name|JobID
operator|.
name|downgrade
argument_list|(
name|jobInfo
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|url
init|=
literal|"http://"
operator|+
name|jobtracker
operator|.
name|getJobTrackerMachine
argument_list|()
operator|+
literal|":"
operator|+
name|jobtracker
operator|.
name|getInfoPort
argument_list|()
operator|+
literal|"/jobdetails.jsp?jobid="
operator|+
name|this
operator|.
name|jobId
decl_stmt|;
name|this
operator|.
name|jobtracker
operator|=
name|jobtracker
expr_stmt|;
name|this
operator|.
name|jobHistory
operator|=
name|jobtracker
operator|.
name|getJobHistory
argument_list|()
expr_stmt|;
name|this
operator|.
name|startTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
name|this
operator|.
name|localFs
operator|=
name|jobtracker
operator|.
name|getLocalFileSystem
argument_list|()
expr_stmt|;
name|this
operator|.
name|tokenStorage
operator|=
name|ts
expr_stmt|;
comment|// use the user supplied token to add user credentials to the conf
name|jobSubmitDir
operator|=
name|jobInfo
operator|.
name|getJobSubmitDir
argument_list|()
expr_stmt|;
name|user
operator|=
name|jobInfo
operator|.
name|getUser
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
name|UserGroupInformation
name|ugi
init|=
name|UserGroupInformation
operator|.
name|createRemoteUser
argument_list|(
name|user
argument_list|)
decl_stmt|;
if|if
condition|(
name|ts
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|token
range|:
name|ts
operator|.
name|getAllTokens
argument_list|()
control|)
block|{
name|ugi
operator|.
name|addToken
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
block|}
name|fs
operator|=
name|ugi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|FileSystem
argument_list|>
argument_list|()
block|{
specifier|public
name|FileSystem
name|run
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|jobSubmitDir
operator|.
name|getFileSystem
argument_list|(
name|default_conf
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|this
operator|.
name|localJobFile
operator|=
name|default_conf
operator|.
name|getLocalPath
argument_list|(
name|JobTracker
operator|.
name|SUBDIR
operator|+
literal|"/"
operator|+
name|this
operator|.
name|jobId
operator|+
literal|".xml"
argument_list|)
expr_stmt|;
name|jobFile
operator|=
name|JobSubmissionFiles
operator|.
name|getJobConfPath
argument_list|(
name|jobSubmitDir
argument_list|)
expr_stmt|;
name|fs
operator|.
name|copyToLocalFile
argument_list|(
name|jobFile
argument_list|,
name|localJobFile
argument_list|)
expr_stmt|;
name|conf
operator|=
operator|new
name|JobConf
argument_list|(
name|localJobFile
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getUser
argument_list|()
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|conf
operator|.
name|setUser
argument_list|(
name|user
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|conf
operator|.
name|getUser
argument_list|()
operator|.
name|equals
argument_list|(
name|user
argument_list|)
condition|)
block|{
name|String
name|desc
init|=
literal|"The username "
operator|+
name|conf
operator|.
name|getUser
argument_list|()
operator|+
literal|" obtained from the "
operator|+
literal|"conf doesn't match the username "
operator|+
name|user
operator|+
literal|" the user "
operator|+
literal|"authenticated as"
decl_stmt|;
name|AuditLogger
operator|.
name|logFailure
argument_list|(
name|user
argument_list|,
name|Operation
operator|.
name|SUBMIT_JOB
operator|.
name|name
argument_list|()
argument_list|,
name|conf
operator|.
name|getUser
argument_list|()
argument_list|,
name|jobId
operator|.
name|toString
argument_list|()
argument_list|,
name|desc
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|desc
argument_list|)
throw|;
block|}
name|String
name|userGroups
index|[]
init|=
name|ugi
operator|.
name|getGroupNames
argument_list|()
decl_stmt|;
name|String
name|primaryGroup
init|=
operator|(
name|userGroups
operator|.
name|length
operator|>
literal|0
operator|)
condition|?
name|userGroups
index|[
literal|0
index|]
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|primaryGroup
operator|!=
literal|null
condition|)
block|{
name|conf
operator|.
name|set
argument_list|(
literal|"group.name"
argument_list|,
name|primaryGroup
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|priority
operator|=
name|conf
operator|.
name|getJobPriority
argument_list|()
expr_stmt|;
name|this
operator|.
name|profile
operator|=
operator|new
name|JobProfile
argument_list|(
name|conf
operator|.
name|getUser
argument_list|()
argument_list|,
name|this
operator|.
name|jobId
argument_list|,
name|jobFile
operator|.
name|toString
argument_list|()
argument_list|,
name|url
argument_list|,
name|conf
operator|.
name|getJobName
argument_list|()
argument_list|,
name|conf
operator|.
name|getQueueName
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|status
operator|=
operator|new
name|JobStatus
argument_list|(
name|this
operator|.
name|jobId
argument_list|,
literal|0.0f
argument_list|,
literal|0.0f
argument_list|,
name|JobStatus
operator|.
name|PREP
argument_list|,
name|profile
operator|.
name|getUser
argument_list|()
argument_list|,
name|profile
operator|.
name|getJobName
argument_list|()
argument_list|,
name|profile
operator|.
name|getJobFile
argument_list|()
argument_list|,
name|profile
operator|.
name|getURL
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|addPrepJob
argument_list|(
name|conf
argument_list|,
name|this
operator|.
name|jobId
argument_list|)
expr_stmt|;
name|status
operator|.
name|setStartTime
argument_list|(
name|startTime
argument_list|)
expr_stmt|;
name|this
operator|.
name|status
operator|.
name|setJobPriority
argument_list|(
name|this
operator|.
name|priority
argument_list|)
expr_stmt|;
name|this
operator|.
name|numMapTasks
operator|=
name|conf
operator|.
name|getNumMapTasks
argument_list|()
expr_stmt|;
name|this
operator|.
name|numReduceTasks
operator|=
name|conf
operator|.
name|getNumReduceTasks
argument_list|()
expr_stmt|;
name|this
operator|.
name|memoryPerMap
operator|=
name|conf
operator|.
name|getMemoryForMapTask
argument_list|()
expr_stmt|;
name|this
operator|.
name|memoryPerReduce
operator|=
name|conf
operator|.
name|getMemoryForReduceTask
argument_list|()
expr_stmt|;
name|this
operator|.
name|taskCompletionEvents
operator|=
operator|new
name|ArrayList
argument_list|<
name|TaskCompletionEvent
argument_list|>
argument_list|(
name|numMapTasks
operator|+
name|numReduceTasks
operator|+
literal|10
argument_list|)
expr_stmt|;
name|JobContext
name|jobContext
init|=
operator|new
name|JobContextImpl
argument_list|(
name|conf
argument_list|,
name|jobId
argument_list|)
decl_stmt|;
name|this
operator|.
name|jobSetupCleanupNeeded
operator|=
name|jobContext
operator|.
name|getJobSetupCleanupNeeded
argument_list|()
expr_stmt|;
name|this
operator|.
name|taskCleanupNeeded
operator|=
name|jobContext
operator|.
name|getTaskCleanupNeeded
argument_list|()
expr_stmt|;
comment|// Construct the jobACLs
name|status
operator|.
name|setJobACLs
argument_list|(
name|jobtracker
operator|.
name|getJobACLsManager
argument_list|()
operator|.
name|constructJobACLs
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|mapFailuresPercent
operator|=
name|conf
operator|.
name|getMaxMapTaskFailuresPercent
argument_list|()
expr_stmt|;
name|this
operator|.
name|reduceFailuresPercent
operator|=
name|conf
operator|.
name|getMaxReduceTaskFailuresPercent
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxTaskFailuresPerTracker
operator|=
name|conf
operator|.
name|getMaxTaskFailuresPerTracker
argument_list|()
expr_stmt|;
name|hasSpeculativeMaps
operator|=
name|conf
operator|.
name|getMapSpeculativeExecution
argument_list|()
expr_stmt|;
name|hasSpeculativeReduces
operator|=
name|conf
operator|.
name|getReduceSpeculativeExecution
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxLevel
operator|=
name|jobtracker
operator|.
name|getNumTaskCacheLevels
argument_list|()
expr_stmt|;
name|this
operator|.
name|anyCacheLevel
operator|=
name|this
operator|.
name|maxLevel
operator|+
literal|1
expr_stmt|;
name|this
operator|.
name|nonLocalMaps
operator|=
operator|new
name|LinkedList
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|nonLocalRunningMaps
operator|=
operator|new
name|LinkedHashSet
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|runningMapCache
operator|=
operator|new
name|IdentityHashMap
argument_list|<
name|Node
argument_list|,
name|Set
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|nonRunningReduces
operator|=
operator|new
name|LinkedList
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|runningReduces
operator|=
operator|new
name|LinkedHashSet
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|resourceEstimator
operator|=
operator|new
name|ResourceEstimator
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|submitHostName
operator|=
name|conf
operator|.
name|getJobSubmitHostName
argument_list|()
expr_stmt|;
name|this
operator|.
name|submitHostAddress
operator|=
name|conf
operator|.
name|getJobSubmitHostAddress
argument_list|()
expr_stmt|;
name|this
operator|.
name|slowTaskThreshold
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|0.0f
argument_list|,
name|conf
operator|.
name|getFloat
argument_list|(
name|MRJobConfig
operator|.
name|SPECULATIVE_SLOWTASK_THRESHOLD
argument_list|,
literal|1.0f
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|speculativeCap
operator|=
name|conf
operator|.
name|getFloat
argument_list|(
name|MRJobConfig
operator|.
name|SPECULATIVECAP
argument_list|,
literal|0.1f
argument_list|)
expr_stmt|;
name|this
operator|.
name|slowNodeThreshold
operator|=
name|conf
operator|.
name|getFloat
argument_list|(
name|MRJobConfig
operator|.
name|SPECULATIVE_SLOWNODE_THRESHOLD
argument_list|,
literal|1.0f
argument_list|)
expr_stmt|;
comment|// register job's tokens for renewal
name|DelegationTokenRenewal
operator|.
name|registerDelegationTokensForRenewal
argument_list|(
name|jobInfo
operator|.
name|getJobID
argument_list|()
argument_list|,
name|ts
argument_list|,
name|jobtracker
operator|.
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// close all FileSystems that was created above for the current user
comment|// At this point, this constructor is called in the context of an RPC, and
comment|// hence the "current user" is actually referring to the kerberos
comment|// authenticated user (if security is ON).
name|FileSystem
operator|.
name|closeAllForUGI
argument_list|(
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|printCache (Map<Node, List<TaskInProgress>> cache)
specifier|private
name|void
name|printCache
parameter_list|(
name|Map
argument_list|<
name|Node
argument_list|,
name|List
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|>
name|cache
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"The taskcache info:"
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Node
argument_list|,
name|List
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|>
name|n
range|:
name|cache
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|List
argument_list|<
name|TaskInProgress
argument_list|>
name|tips
init|=
name|n
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Cached TIPs on node: "
operator|+
name|n
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|TaskInProgress
name|tip
range|:
name|tips
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"tip : "
operator|+
name|tip
operator|.
name|getTIPId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|createCache ( TaskSplitMetaInfo[] splits, int maxLevel)
name|Map
argument_list|<
name|Node
argument_list|,
name|List
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|>
name|createCache
parameter_list|(
name|TaskSplitMetaInfo
index|[]
name|splits
parameter_list|,
name|int
name|maxLevel
parameter_list|)
block|{
name|Map
argument_list|<
name|Node
argument_list|,
name|List
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|>
name|cache
init|=
operator|new
name|IdentityHashMap
argument_list|<
name|Node
argument_list|,
name|List
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|>
argument_list|(
name|maxLevel
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|splits
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
index|[]
name|splitLocations
init|=
name|splits
index|[
name|i
index|]
operator|.
name|getLocations
argument_list|()
decl_stmt|;
if|if
condition|(
name|splitLocations
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|nonLocalMaps
operator|.
name|add
argument_list|(
name|maps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|String
name|host
range|:
name|splitLocations
control|)
block|{
name|Node
name|node
init|=
name|jobtracker
operator|.
name|resolveAndAddToTopology
argument_list|(
name|host
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"tip:"
operator|+
name|maps
index|[
name|i
index|]
operator|.
name|getTIPId
argument_list|()
operator|+
literal|" has split on node:"
operator|+
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|maxLevel
condition|;
name|j
operator|++
control|)
block|{
name|List
argument_list|<
name|TaskInProgress
argument_list|>
name|hostMaps
init|=
name|cache
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|hostMaps
operator|==
literal|null
condition|)
block|{
name|hostMaps
operator|=
operator|new
name|ArrayList
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|()
expr_stmt|;
name|cache
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|hostMaps
argument_list|)
expr_stmt|;
name|hostMaps
operator|.
name|add
argument_list|(
name|maps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|//check whether the hostMaps already contains an entry for a TIP
comment|//This will be true for nodes that are racks and multiple nodes in
comment|//the rack contain the input for a tip. Note that if it already
comment|//exists in the hostMaps, it must be the last element there since
comment|//we process one TIP at a time sequentially in the split-size order
if|if
condition|(
name|hostMaps
operator|.
name|get
argument_list|(
name|hostMaps
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|!=
name|maps
index|[
name|i
index|]
condition|)
block|{
name|hostMaps
operator|.
name|add
argument_list|(
name|maps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|node
operator|=
name|node
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
name|cache
return|;
block|}
comment|/**    * Check if the job has been initialized.    * @return<code>true</code> if the job has been initialized,     *<code>false</code> otherwise    */
DECL|method|inited ()
specifier|public
name|boolean
name|inited
parameter_list|()
block|{
return|return
name|tasksInited
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Get the user for the job    */
DECL|method|getUser ()
specifier|public
name|String
name|getUser
parameter_list|()
block|{
return|return
name|user
return|;
block|}
DECL|method|getMapSpeculativeExecution ()
name|boolean
name|getMapSpeculativeExecution
parameter_list|()
block|{
return|return
name|hasSpeculativeMaps
return|;
block|}
DECL|method|getReduceSpeculativeExecution ()
name|boolean
name|getReduceSpeculativeExecution
parameter_list|()
block|{
return|return
name|hasSpeculativeReduces
return|;
block|}
DECL|method|getMemoryForMapTask ()
name|long
name|getMemoryForMapTask
parameter_list|()
block|{
return|return
name|memoryPerMap
return|;
block|}
DECL|method|getMemoryForReduceTask ()
name|long
name|getMemoryForReduceTask
parameter_list|()
block|{
return|return
name|memoryPerReduce
return|;
block|}
comment|/**    * Get the number of slots required to run a single map task-attempt.    * @return the number of slots required to run a single map task-attempt    */
DECL|method|getNumSlotsPerMap ()
name|int
name|getNumSlotsPerMap
parameter_list|()
block|{
return|return
name|numSlotsPerMap
return|;
block|}
comment|/**    * Set the number of slots required to run a single map task-attempt.    * This is typically set by schedulers which support high-ram jobs.    * @param slots the number of slots required to run a single map task-attempt    */
DECL|method|setNumSlotsPerMap (int numSlotsPerMap)
name|void
name|setNumSlotsPerMap
parameter_list|(
name|int
name|numSlotsPerMap
parameter_list|)
block|{
name|this
operator|.
name|numSlotsPerMap
operator|=
name|numSlotsPerMap
expr_stmt|;
block|}
comment|/**    * Get the number of slots required to run a single reduce task-attempt.    * @return the number of slots required to run a single reduce task-attempt    */
DECL|method|getNumSlotsPerReduce ()
name|int
name|getNumSlotsPerReduce
parameter_list|()
block|{
return|return
name|numSlotsPerReduce
return|;
block|}
comment|/**    * Set the number of slots required to run a single reduce task-attempt.    * This is typically set by schedulers which support high-ram jobs.    * @param slots the number of slots required to run a single reduce     *              task-attempt    */
DECL|method|setNumSlotsPerReduce (int numSlotsPerReduce)
name|void
name|setNumSlotsPerReduce
parameter_list|(
name|int
name|numSlotsPerReduce
parameter_list|)
block|{
name|this
operator|.
name|numSlotsPerReduce
operator|=
name|numSlotsPerReduce
expr_stmt|;
block|}
comment|/**    * Construct the splits, etc.  This is invoked from an async    * thread so that split-computation doesn't block anyone. Only the     * {@link JobTracker} should invoke this api. Look     * at {@link JobTracker#initJob(JobInProgress)} for more details.    */
DECL|method|initTasks ()
specifier|public
specifier|synchronized
name|void
name|initTasks
parameter_list|()
throws|throws
name|IOException
throws|,
name|KillInterruptedException
throws|,
name|UnknownHostException
block|{
if|if
condition|(
name|tasksInited
operator|.
name|get
argument_list|()
operator|||
name|isComplete
argument_list|()
condition|)
block|{
return|return;
block|}
synchronized|synchronized
init|(
name|jobInitKillStatus
init|)
block|{
if|if
condition|(
name|jobInitKillStatus
operator|.
name|killed
operator|||
name|jobInitKillStatus
operator|.
name|initStarted
condition|)
block|{
return|return;
block|}
name|jobInitKillStatus
operator|.
name|initStarted
operator|=
literal|true
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Initializing "
operator|+
name|jobId
argument_list|)
expr_stmt|;
name|logSubmissionToJobHistory
argument_list|()
expr_stmt|;
comment|// log the job priority
name|setPriority
argument_list|(
name|this
operator|.
name|priority
argument_list|)
expr_stmt|;
comment|//
comment|// generate security keys needed by Tasks
comment|//
name|generateAndStoreTokens
argument_list|()
expr_stmt|;
comment|//
comment|// read input splits and create a map per a split
comment|//
name|TaskSplitMetaInfo
index|[]
name|taskSplitMetaInfo
init|=
name|createSplits
argument_list|(
name|jobId
argument_list|)
decl_stmt|;
name|numMapTasks
operator|=
name|taskSplitMetaInfo
operator|.
name|length
expr_stmt|;
name|checkTaskLimits
argument_list|()
expr_stmt|;
comment|// Sanity check the locations so we don't create/initialize unnecessary tasks
for|for
control|(
name|TaskSplitMetaInfo
name|split
range|:
name|taskSplitMetaInfo
control|)
block|{
name|NetUtils
operator|.
name|verifyHostnames
argument_list|(
name|split
operator|.
name|getLocations
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|addWaitingMaps
argument_list|(
name|getJobID
argument_list|()
argument_list|,
name|numMapTasks
argument_list|)
expr_stmt|;
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|addWaitingReduces
argument_list|(
name|getJobID
argument_list|()
argument_list|,
name|numReduceTasks
argument_list|)
expr_stmt|;
name|createMapTasks
argument_list|(
name|jobFile
operator|.
name|toString
argument_list|()
argument_list|,
name|taskSplitMetaInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|numMapTasks
operator|>
literal|0
condition|)
block|{
name|nonRunningMapCache
operator|=
name|createCache
argument_list|(
name|taskSplitMetaInfo
argument_list|,
name|maxLevel
argument_list|)
expr_stmt|;
block|}
comment|// set the launch time
name|this
operator|.
name|launchTime
operator|=
name|JobTracker
operator|.
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
expr_stmt|;
name|createReduceTasks
argument_list|(
name|jobFile
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Calculate the minimum number of maps to be complete before
comment|// we should start scheduling reduces
name|completedMapsForReduceSlowstart
operator|=
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
operator|(
name|conf
operator|.
name|getFloat
argument_list|(
name|MRJobConfig
operator|.
name|COMPLETED_MAPS_FOR_REDUCE_SLOWSTART
argument_list|,
name|DEFAULT_COMPLETED_MAPS_PERCENT_FOR_REDUCE_SLOWSTART
argument_list|)
operator|*
name|numMapTasks
operator|)
argument_list|)
expr_stmt|;
name|initSetupCleanupTasks
argument_list|(
name|jobFile
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|jobInitKillStatus
init|)
block|{
name|jobInitKillStatus
operator|.
name|initDone
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|jobInitKillStatus
operator|.
name|killed
condition|)
block|{
comment|//setup not launched so directly terminate
throw|throw
operator|new
name|KillInterruptedException
argument_list|(
literal|"Job "
operator|+
name|jobId
operator|+
literal|" killed in init"
argument_list|)
throw|;
block|}
block|}
name|tasksInited
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|JobInitedEvent
name|jie
init|=
operator|new
name|JobInitedEvent
argument_list|(
name|profile
operator|.
name|getJobID
argument_list|()
argument_list|,
name|this
operator|.
name|launchTime
argument_list|,
name|numMapTasks
argument_list|,
name|numReduceTasks
argument_list|,
name|JobStatus
operator|.
name|getJobRunState
argument_list|(
name|JobStatus
operator|.
name|PREP
argument_list|)
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|jobHistory
operator|.
name|logEvent
argument_list|(
name|jie
argument_list|,
name|jobId
argument_list|)
expr_stmt|;
comment|// Log the number of map and reduce tasks
name|LOG
operator|.
name|info
argument_list|(
literal|"Job "
operator|+
name|jobId
operator|+
literal|" initialized successfully with "
operator|+
name|numMapTasks
operator|+
literal|" map tasks and "
operator|+
name|numReduceTasks
operator|+
literal|" reduce tasks."
argument_list|)
expr_stmt|;
block|}
comment|// Returns true if the job is empty (0 maps, 0 reduces and no setup-cleanup)
comment|// else return false.
DECL|method|isJobEmpty ()
specifier|synchronized
name|boolean
name|isJobEmpty
parameter_list|()
block|{
return|return
name|maps
operator|.
name|length
operator|==
literal|0
operator|&&
name|reduces
operator|.
name|length
operator|==
literal|0
operator|&&
operator|!
name|jobSetupCleanupNeeded
return|;
block|}
DECL|method|isSetupCleanupRequired ()
specifier|synchronized
name|boolean
name|isSetupCleanupRequired
parameter_list|()
block|{
return|return
name|jobSetupCleanupNeeded
return|;
block|}
comment|// Should be called once the init is done. This will complete the job
comment|// because the job is empty (0 maps, 0 reduces and no setup-cleanup).
DECL|method|completeEmptyJob ()
specifier|synchronized
name|void
name|completeEmptyJob
parameter_list|()
block|{
name|jobComplete
argument_list|()
expr_stmt|;
block|}
DECL|method|completeSetup ()
specifier|synchronized
name|void
name|completeSetup
parameter_list|()
block|{
name|setupComplete
argument_list|()
expr_stmt|;
block|}
DECL|method|logSubmissionToJobHistory ()
name|void
name|logSubmissionToJobHistory
parameter_list|()
throws|throws
name|IOException
block|{
comment|// log job info
name|String
name|username
init|=
name|conf
operator|.
name|getUser
argument_list|()
decl_stmt|;
if|if
condition|(
name|username
operator|==
literal|null
condition|)
block|{
name|username
operator|=
literal|""
expr_stmt|;
block|}
name|String
name|jobname
init|=
name|conf
operator|.
name|getJobName
argument_list|()
decl_stmt|;
name|String
name|jobQueueName
init|=
name|conf
operator|.
name|getQueueName
argument_list|()
decl_stmt|;
name|setUpLocalizedJobConf
argument_list|(
name|conf
argument_list|,
name|jobId
argument_list|)
expr_stmt|;
name|jobHistory
operator|.
name|setupEventWriter
argument_list|(
name|jobId
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|JobSubmittedEvent
name|jse
init|=
operator|new
name|JobSubmittedEvent
argument_list|(
name|jobId
argument_list|,
name|jobname
argument_list|,
name|username
argument_list|,
name|this
operator|.
name|startTime
argument_list|,
name|jobFile
operator|.
name|toString
argument_list|()
argument_list|,
name|status
operator|.
name|getJobACLs
argument_list|()
argument_list|,
name|jobQueueName
argument_list|)
decl_stmt|;
name|jobHistory
operator|.
name|logEvent
argument_list|(
name|jse
argument_list|,
name|jobId
argument_list|)
expr_stmt|;
block|}
DECL|method|createSplits (org.apache.hadoop.mapreduce.JobID jobId)
name|TaskSplitMetaInfo
index|[]
name|createSplits
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobID
name|jobId
parameter_list|)
throws|throws
name|IOException
block|{
name|TaskSplitMetaInfo
index|[]
name|allTaskSplitMetaInfo
init|=
name|SplitMetaInfoReader
operator|.
name|readSplitMetaInfo
argument_list|(
name|jobId
argument_list|,
name|fs
argument_list|,
name|conf
argument_list|,
name|jobSubmitDir
argument_list|)
decl_stmt|;
return|return
name|allTaskSplitMetaInfo
return|;
block|}
comment|/**    * If the number of taks is greater than the configured value    * throw an exception that will fail job initialization    */
DECL|method|checkTaskLimits ()
name|void
name|checkTaskLimits
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|maxTasks
init|=
name|jobtracker
operator|.
name|getMaxTasksPerJob
argument_list|()
decl_stmt|;
if|if
condition|(
name|maxTasks
operator|>
literal|0
operator|&&
name|numMapTasks
operator|+
name|numReduceTasks
operator|>
name|maxTasks
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The number of tasks for this job "
operator|+
operator|(
name|numMapTasks
operator|+
name|numReduceTasks
operator|)
operator|+
literal|" exceeds the configured limit "
operator|+
name|maxTasks
argument_list|)
throw|;
block|}
block|}
DECL|method|createMapTasks (String jobFile, TaskSplitMetaInfo[] splits)
specifier|synchronized
name|void
name|createMapTasks
parameter_list|(
name|String
name|jobFile
parameter_list|,
name|TaskSplitMetaInfo
index|[]
name|splits
parameter_list|)
block|{
name|maps
operator|=
operator|new
name|TaskInProgress
index|[
name|numMapTasks
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numMapTasks
condition|;
operator|++
name|i
control|)
block|{
name|inputLength
operator|+=
name|splits
index|[
name|i
index|]
operator|.
name|getInputDataLength
argument_list|()
expr_stmt|;
name|maps
index|[
name|i
index|]
operator|=
operator|new
name|TaskInProgress
argument_list|(
name|jobId
argument_list|,
name|jobFile
argument_list|,
name|splits
index|[
name|i
index|]
argument_list|,
name|jobtracker
argument_list|,
name|conf
argument_list|,
name|this
argument_list|,
name|i
argument_list|,
name|numSlotsPerMap
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Input size for job "
operator|+
name|jobId
operator|+
literal|" = "
operator|+
name|inputLength
operator|+
literal|". Number of splits = "
operator|+
name|splits
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
DECL|method|createReduceTasks (String jobFile)
specifier|synchronized
name|void
name|createReduceTasks
parameter_list|(
name|String
name|jobFile
parameter_list|)
block|{
name|this
operator|.
name|reduces
operator|=
operator|new
name|TaskInProgress
index|[
name|numReduceTasks
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numReduceTasks
condition|;
name|i
operator|++
control|)
block|{
name|reduces
index|[
name|i
index|]
operator|=
operator|new
name|TaskInProgress
argument_list|(
name|jobId
argument_list|,
name|jobFile
argument_list|,
name|numMapTasks
argument_list|,
name|i
argument_list|,
name|jobtracker
argument_list|,
name|conf
argument_list|,
name|this
argument_list|,
name|numSlotsPerReduce
argument_list|)
expr_stmt|;
name|nonRunningReduces
operator|.
name|add
argument_list|(
name|reduces
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|initSetupCleanupTasks (String jobFile)
specifier|synchronized
name|void
name|initSetupCleanupTasks
parameter_list|(
name|String
name|jobFile
parameter_list|)
block|{
if|if
condition|(
operator|!
name|jobSetupCleanupNeeded
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Setup/Cleanup not needed for job "
operator|+
name|jobId
argument_list|)
expr_stmt|;
comment|// nothing to initialize
return|return;
block|}
comment|// create cleanup two cleanup tips, one map and one reduce.
name|cleanup
operator|=
operator|new
name|TaskInProgress
index|[
literal|2
index|]
expr_stmt|;
comment|// cleanup map tip. This map doesn't use any splits. Just assign an empty
comment|// split.
name|TaskSplitMetaInfo
name|emptySplit
init|=
name|JobSplit
operator|.
name|EMPTY_TASK_SPLIT
decl_stmt|;
name|cleanup
index|[
literal|0
index|]
operator|=
operator|new
name|TaskInProgress
argument_list|(
name|jobId
argument_list|,
name|jobFile
argument_list|,
name|emptySplit
argument_list|,
name|jobtracker
argument_list|,
name|conf
argument_list|,
name|this
argument_list|,
name|numMapTasks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cleanup
index|[
literal|0
index|]
operator|.
name|setJobCleanupTask
argument_list|()
expr_stmt|;
comment|// cleanup reduce tip.
name|cleanup
index|[
literal|1
index|]
operator|=
operator|new
name|TaskInProgress
argument_list|(
name|jobId
argument_list|,
name|jobFile
argument_list|,
name|numMapTasks
argument_list|,
name|numReduceTasks
argument_list|,
name|jobtracker
argument_list|,
name|conf
argument_list|,
name|this
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cleanup
index|[
literal|1
index|]
operator|.
name|setJobCleanupTask
argument_list|()
expr_stmt|;
comment|// create two setup tips, one map and one reduce.
name|setup
operator|=
operator|new
name|TaskInProgress
index|[
literal|2
index|]
expr_stmt|;
comment|// setup map tip. This map doesn't use any split. Just assign an empty
comment|// split.
name|setup
index|[
literal|0
index|]
operator|=
operator|new
name|TaskInProgress
argument_list|(
name|jobId
argument_list|,
name|jobFile
argument_list|,
name|emptySplit
argument_list|,
name|jobtracker
argument_list|,
name|conf
argument_list|,
name|this
argument_list|,
name|numMapTasks
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|setup
index|[
literal|0
index|]
operator|.
name|setJobSetupTask
argument_list|()
expr_stmt|;
comment|// setup reduce tip.
name|setup
index|[
literal|1
index|]
operator|=
operator|new
name|TaskInProgress
argument_list|(
name|jobId
argument_list|,
name|jobFile
argument_list|,
name|numMapTasks
argument_list|,
name|numReduceTasks
operator|+
literal|1
argument_list|,
name|jobtracker
argument_list|,
name|conf
argument_list|,
name|this
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|setup
index|[
literal|1
index|]
operator|.
name|setJobSetupTask
argument_list|()
expr_stmt|;
block|}
DECL|method|setupComplete ()
name|void
name|setupComplete
parameter_list|()
block|{
name|status
operator|.
name|setSetupProgress
argument_list|(
literal|1.0f
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|JobStatus
operator|.
name|PREP
condition|)
block|{
name|changeStateTo
argument_list|(
name|JobStatus
operator|.
name|RUNNING
argument_list|)
expr_stmt|;
name|JobStatusChangedEvent
name|jse
init|=
operator|new
name|JobStatusChangedEvent
argument_list|(
name|profile
operator|.
name|getJobID
argument_list|()
argument_list|,
name|JobStatus
operator|.
name|getJobRunState
argument_list|(
name|JobStatus
operator|.
name|RUNNING
argument_list|)
argument_list|)
decl_stmt|;
name|jobHistory
operator|.
name|logEvent
argument_list|(
name|jse
argument_list|,
name|profile
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/////////////////////////////////////////////////////
comment|// Accessors for the JobInProgress
comment|/////////////////////////////////////////////////////
DECL|method|getProfile ()
specifier|public
name|JobProfile
name|getProfile
parameter_list|()
block|{
return|return
name|profile
return|;
block|}
DECL|method|getStatus ()
specifier|public
name|JobStatus
name|getStatus
parameter_list|()
block|{
return|return
name|status
return|;
block|}
DECL|method|getLaunchTime ()
specifier|public
specifier|synchronized
name|long
name|getLaunchTime
parameter_list|()
block|{
return|return
name|launchTime
return|;
block|}
DECL|method|getFirstTaskLaunchTimes ()
name|Map
argument_list|<
name|TaskType
argument_list|,
name|Long
argument_list|>
name|getFirstTaskLaunchTimes
parameter_list|()
block|{
return|return
name|firstTaskLaunchTimes
return|;
block|}
DECL|method|getStartTime ()
specifier|public
name|long
name|getStartTime
parameter_list|()
block|{
return|return
name|startTime
return|;
block|}
DECL|method|getFinishTime ()
specifier|public
name|long
name|getFinishTime
parameter_list|()
block|{
return|return
name|finishTime
return|;
block|}
DECL|method|desiredMaps ()
specifier|public
name|int
name|desiredMaps
parameter_list|()
block|{
return|return
name|numMapTasks
return|;
block|}
DECL|method|finishedMaps ()
specifier|public
specifier|synchronized
name|int
name|finishedMaps
parameter_list|()
block|{
return|return
name|finishedMapTasks
return|;
block|}
DECL|method|desiredReduces ()
specifier|public
name|int
name|desiredReduces
parameter_list|()
block|{
return|return
name|numReduceTasks
return|;
block|}
DECL|method|runningMaps ()
specifier|public
specifier|synchronized
name|int
name|runningMaps
parameter_list|()
block|{
return|return
name|runningMapTasks
return|;
block|}
DECL|method|runningReduces ()
specifier|public
specifier|synchronized
name|int
name|runningReduces
parameter_list|()
block|{
return|return
name|runningReduceTasks
return|;
block|}
DECL|method|finishedReduces ()
specifier|public
specifier|synchronized
name|int
name|finishedReduces
parameter_list|()
block|{
return|return
name|finishedReduceTasks
return|;
block|}
DECL|method|pendingMaps ()
specifier|public
specifier|synchronized
name|int
name|pendingMaps
parameter_list|()
block|{
return|return
name|numMapTasks
operator|-
name|runningMapTasks
operator|-
name|failedMapTIPs
operator|-
name|finishedMapTasks
operator|+
name|speculativeMapTasks
return|;
block|}
DECL|method|pendingReduces ()
specifier|public
specifier|synchronized
name|int
name|pendingReduces
parameter_list|()
block|{
return|return
name|numReduceTasks
operator|-
name|runningReduceTasks
operator|-
name|failedReduceTIPs
operator|-
name|finishedReduceTasks
operator|+
name|speculativeReduceTasks
return|;
block|}
DECL|method|getNumSlotsPerTask (TaskType taskType)
specifier|public
name|int
name|getNumSlotsPerTask
parameter_list|(
name|TaskType
name|taskType
parameter_list|)
block|{
if|if
condition|(
name|taskType
operator|==
name|TaskType
operator|.
name|MAP
condition|)
block|{
return|return
name|numSlotsPerMap
return|;
block|}
elseif|else
if|if
condition|(
name|taskType
operator|==
name|TaskType
operator|.
name|REDUCE
condition|)
block|{
return|return
name|numSlotsPerReduce
return|;
block|}
else|else
block|{
return|return
literal|1
return|;
block|}
block|}
DECL|method|getPriority ()
specifier|public
name|JobPriority
name|getPriority
parameter_list|()
block|{
return|return
name|this
operator|.
name|priority
return|;
block|}
DECL|method|setPriority (JobPriority priority)
specifier|public
name|void
name|setPriority
parameter_list|(
name|JobPriority
name|priority
parameter_list|)
block|{
if|if
condition|(
name|priority
operator|==
literal|null
condition|)
block|{
name|priority
operator|=
name|JobPriority
operator|.
name|NORMAL
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
name|this
operator|.
name|priority
operator|=
name|priority
expr_stmt|;
name|status
operator|.
name|setJobPriority
argument_list|(
name|priority
argument_list|)
expr_stmt|;
comment|// log and change to the job's priority
name|JobPriorityChangeEvent
name|prEvent
init|=
operator|new
name|JobPriorityChangeEvent
argument_list|(
name|jobId
argument_list|,
name|priority
argument_list|)
decl_stmt|;
name|jobHistory
operator|.
name|logEvent
argument_list|(
name|prEvent
argument_list|,
name|jobId
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Update the job start/launch time (upon restart) and log to history
DECL|method|updateJobInfo (long startTime, long launchTime)
specifier|synchronized
name|void
name|updateJobInfo
parameter_list|(
name|long
name|startTime
parameter_list|,
name|long
name|launchTime
parameter_list|)
block|{
comment|// log and change to the job's start/launch time
name|this
operator|.
name|startTime
operator|=
name|startTime
expr_stmt|;
name|this
operator|.
name|launchTime
operator|=
name|launchTime
expr_stmt|;
name|JobInfoChangeEvent
name|event
init|=
operator|new
name|JobInfoChangeEvent
argument_list|(
name|jobId
argument_list|,
name|startTime
argument_list|,
name|launchTime
argument_list|)
decl_stmt|;
name|jobHistory
operator|.
name|logEvent
argument_list|(
name|event
argument_list|,
name|jobId
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the number of times the job has restarted    */
DECL|method|getNumRestarts ()
name|int
name|getNumRestarts
parameter_list|()
block|{
return|return
name|restartCount
return|;
block|}
DECL|method|getInputLength ()
name|long
name|getInputLength
parameter_list|()
block|{
return|return
name|inputLength
return|;
block|}
DECL|method|isCleanupLaunched ()
name|boolean
name|isCleanupLaunched
parameter_list|()
block|{
return|return
name|launchedCleanup
return|;
block|}
DECL|method|isSetupLaunched ()
name|boolean
name|isSetupLaunched
parameter_list|()
block|{
return|return
name|launchedSetup
return|;
block|}
comment|/**     * Get all the tasks of the desired type in this job.    * @param type {@link TaskType} of the tasks required    * @return An array of {@link TaskInProgress} matching the given type.     *         Returns an empty array if no tasks are found for the given type.      */
DECL|method|getTasks (TaskType type)
name|TaskInProgress
index|[]
name|getTasks
parameter_list|(
name|TaskType
name|type
parameter_list|)
block|{
name|TaskInProgress
index|[]
name|tasks
init|=
literal|null
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MAP
case|:
block|{
name|tasks
operator|=
name|maps
expr_stmt|;
block|}
break|break;
case|case
name|REDUCE
case|:
block|{
name|tasks
operator|=
name|reduces
expr_stmt|;
block|}
break|break;
case|case
name|JOB_SETUP
case|:
block|{
name|tasks
operator|=
name|setup
expr_stmt|;
block|}
break|break;
case|case
name|JOB_CLEANUP
case|:
block|{
name|tasks
operator|=
name|cleanup
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|tasks
operator|=
operator|new
name|TaskInProgress
index|[
literal|0
index|]
expr_stmt|;
block|}
break|break;
block|}
return|return
name|tasks
return|;
block|}
comment|/**    * Return the nonLocalRunningMaps    * @return    */
DECL|method|getNonLocalRunningMaps ()
name|Set
argument_list|<
name|TaskInProgress
argument_list|>
name|getNonLocalRunningMaps
parameter_list|()
block|{
return|return
name|nonLocalRunningMaps
return|;
block|}
comment|/**    * Return the runningMapCache    * @return    */
DECL|method|getRunningMapCache ()
name|Map
argument_list|<
name|Node
argument_list|,
name|Set
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|>
name|getRunningMapCache
parameter_list|()
block|{
return|return
name|runningMapCache
return|;
block|}
comment|/**    * Return runningReduces    * @return    */
DECL|method|getRunningReduces ()
name|Set
argument_list|<
name|TaskInProgress
argument_list|>
name|getRunningReduces
parameter_list|()
block|{
return|return
name|runningReduces
return|;
block|}
comment|/**    * Get the job configuration    * @return the job's configuration    */
DECL|method|getJobConf ()
name|JobConf
name|getJobConf
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
comment|/**    * Return a vector of completed TaskInProgress objects    */
DECL|method|reportTasksInProgress (boolean shouldBeMap, boolean shouldBeComplete)
specifier|public
specifier|synchronized
name|Vector
argument_list|<
name|TaskInProgress
argument_list|>
name|reportTasksInProgress
parameter_list|(
name|boolean
name|shouldBeMap
parameter_list|,
name|boolean
name|shouldBeComplete
parameter_list|)
block|{
name|Vector
argument_list|<
name|TaskInProgress
argument_list|>
name|results
init|=
operator|new
name|Vector
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|()
decl_stmt|;
name|TaskInProgress
name|tips
index|[]
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|shouldBeMap
condition|)
block|{
name|tips
operator|=
name|maps
expr_stmt|;
block|}
else|else
block|{
name|tips
operator|=
name|reduces
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tips
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tips
index|[
name|i
index|]
operator|.
name|isComplete
argument_list|()
operator|==
name|shouldBeComplete
condition|)
block|{
name|results
operator|.
name|add
argument_list|(
name|tips
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|results
return|;
block|}
comment|/**    * Return a vector of cleanup TaskInProgress objects    */
DECL|method|reportCleanupTIPs ( boolean shouldBeComplete)
specifier|public
specifier|synchronized
name|Vector
argument_list|<
name|TaskInProgress
argument_list|>
name|reportCleanupTIPs
parameter_list|(
name|boolean
name|shouldBeComplete
parameter_list|)
block|{
name|Vector
argument_list|<
name|TaskInProgress
argument_list|>
name|results
init|=
operator|new
name|Vector
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cleanup
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cleanup
index|[
name|i
index|]
operator|.
name|isComplete
argument_list|()
operator|==
name|shouldBeComplete
condition|)
block|{
name|results
operator|.
name|add
argument_list|(
name|cleanup
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|results
return|;
block|}
comment|/**    * Return a vector of setup TaskInProgress objects    */
DECL|method|reportSetupTIPs ( boolean shouldBeComplete)
specifier|public
specifier|synchronized
name|Vector
argument_list|<
name|TaskInProgress
argument_list|>
name|reportSetupTIPs
parameter_list|(
name|boolean
name|shouldBeComplete
parameter_list|)
block|{
name|Vector
argument_list|<
name|TaskInProgress
argument_list|>
name|results
init|=
operator|new
name|Vector
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|setup
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|setup
index|[
name|i
index|]
operator|.
name|isComplete
argument_list|()
operator|==
name|shouldBeComplete
condition|)
block|{
name|results
operator|.
name|add
argument_list|(
name|setup
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|results
return|;
block|}
comment|////////////////////////////////////////////////////
comment|// Status update methods
comment|////////////////////////////////////////////////////
comment|/**    * Assuming {@link JobTracker} is locked on entry.    */
DECL|method|updateTaskStatus (TaskInProgress tip, TaskStatus status)
specifier|public
specifier|synchronized
name|void
name|updateTaskStatus
parameter_list|(
name|TaskInProgress
name|tip
parameter_list|,
name|TaskStatus
name|status
parameter_list|)
block|{
name|double
name|oldProgress
init|=
name|tip
operator|.
name|getProgress
argument_list|()
decl_stmt|;
comment|// save old progress
name|boolean
name|wasRunning
init|=
name|tip
operator|.
name|isRunning
argument_list|()
decl_stmt|;
name|boolean
name|wasComplete
init|=
name|tip
operator|.
name|isComplete
argument_list|()
decl_stmt|;
name|boolean
name|wasPending
init|=
name|tip
operator|.
name|isOnlyCommitPending
argument_list|()
decl_stmt|;
name|TaskAttemptID
name|taskid
init|=
name|status
operator|.
name|getTaskID
argument_list|()
decl_stmt|;
name|boolean
name|wasAttemptRunning
init|=
name|tip
operator|.
name|isAttemptRunning
argument_list|(
name|taskid
argument_list|)
decl_stmt|;
comment|// If the TIP is already completed and the task reports as SUCCEEDED then
comment|// mark the task as KILLED.
comment|// In case of task with no promotion the task tracker will mark the task
comment|// as SUCCEEDED.
comment|// User has requested to kill the task, but TT reported SUCCEEDED,
comment|// mark the task KILLED.
if|if
condition|(
operator|(
name|wasComplete
operator|||
name|tip
operator|.
name|wasKilled
argument_list|(
name|taskid
argument_list|)
operator|)
operator|&&
operator|(
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|SUCCEEDED
operator|)
condition|)
block|{
name|status
operator|.
name|setRunState
argument_list|(
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED
argument_list|)
expr_stmt|;
block|}
comment|// If the job is complete or task-cleanup is switched off
comment|// and a task has just reported its state as FAILED_UNCLEAN/KILLED_UNCLEAN,
comment|// make the task's state FAILED/KILLED without launching cleanup attempt.
comment|// Note that if task is already a cleanup attempt,
comment|// we don't change the state to make sure the task gets a killTaskAction
if|if
condition|(
operator|(
name|this
operator|.
name|isComplete
argument_list|()
operator|||
name|jobFailed
operator|||
name|jobKilled
operator|||
operator|!
name|taskCleanupNeeded
operator|)
operator|&&
operator|!
name|tip
operator|.
name|isCleanupAttempt
argument_list|(
name|taskid
argument_list|)
condition|)
block|{
if|if
condition|(
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED_UNCLEAN
condition|)
block|{
name|status
operator|.
name|setRunState
argument_list|(
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED_UNCLEAN
condition|)
block|{
name|status
operator|.
name|setRunState
argument_list|(
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED
argument_list|)
expr_stmt|;
block|}
block|}
name|boolean
name|change
init|=
name|tip
operator|.
name|updateStatus
argument_list|(
name|status
argument_list|)
decl_stmt|;
if|if
condition|(
name|change
condition|)
block|{
name|TaskStatus
operator|.
name|State
name|state
init|=
name|status
operator|.
name|getRunState
argument_list|()
decl_stmt|;
comment|// get the TaskTrackerStatus where the task ran
name|TaskTracker
name|taskTracker
init|=
name|this
operator|.
name|jobtracker
operator|.
name|getTaskTracker
argument_list|(
name|tip
operator|.
name|machineWhereTaskRan
argument_list|(
name|taskid
argument_list|)
argument_list|)
decl_stmt|;
name|TaskTrackerStatus
name|ttStatus
init|=
operator|(
name|taskTracker
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|taskTracker
operator|.
name|getStatus
argument_list|()
decl_stmt|;
name|String
name|taskTrackerHttpLocation
init|=
literal|null
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|ttStatus
condition|)
block|{
name|String
name|host
decl_stmt|;
if|if
condition|(
name|NetUtils
operator|.
name|getStaticResolution
argument_list|(
name|ttStatus
operator|.
name|getHost
argument_list|()
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|host
operator|=
name|NetUtils
operator|.
name|getStaticResolution
argument_list|(
name|ttStatus
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|host
operator|=
name|ttStatus
operator|.
name|getHost
argument_list|()
expr_stmt|;
block|}
name|taskTrackerHttpLocation
operator|=
literal|"http://"
operator|+
name|host
operator|+
literal|":"
operator|+
name|ttStatus
operator|.
name|getHttpPort
argument_list|()
expr_stmt|;
block|}
name|TaskCompletionEvent
name|taskEvent
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|SUCCEEDED
condition|)
block|{
name|taskEvent
operator|=
operator|new
name|TaskCompletionEvent
argument_list|(
name|taskCompletionEventTracker
argument_list|,
name|taskid
argument_list|,
name|tip
operator|.
name|idWithinJob
argument_list|()
argument_list|,
name|status
operator|.
name|getIsMap
argument_list|()
operator|&&
operator|!
name|tip
operator|.
name|isJobCleanupTask
argument_list|()
operator|&&
operator|!
name|tip
operator|.
name|isJobSetupTask
argument_list|()
argument_list|,
name|TaskCompletionEvent
operator|.
name|Status
operator|.
name|SUCCEEDED
argument_list|,
name|taskTrackerHttpLocation
argument_list|)
expr_stmt|;
name|taskEvent
operator|.
name|setTaskRunTime
argument_list|(
call|(
name|int
call|)
argument_list|(
name|status
operator|.
name|getFinishTime
argument_list|()
operator|-
name|status
operator|.
name|getStartTime
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|tip
operator|.
name|setSuccessEventNumber
argument_list|(
name|taskCompletionEventTracker
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|COMMIT_PENDING
condition|)
block|{
comment|// If it is the first attempt reporting COMMIT_PENDING
comment|// ask the task to commit.
if|if
condition|(
operator|!
name|wasComplete
operator|&&
operator|!
name|wasPending
condition|)
block|{
name|tip
operator|.
name|doCommit
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED_UNCLEAN
operator|||
name|state
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED_UNCLEAN
condition|)
block|{
name|tip
operator|.
name|incompleteSubTask
argument_list|(
name|taskid
argument_list|,
name|this
operator|.
name|status
argument_list|)
expr_stmt|;
comment|// add this task, to be rescheduled as cleanup attempt
if|if
condition|(
name|tip
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
name|mapCleanupTasks
operator|.
name|add
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reduceCleanupTasks
operator|.
name|add
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
block|}
comment|// Remove the task entry from jobtracker
name|jobtracker
operator|.
name|removeTaskEntry
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
block|}
comment|//For a failed task update the JT datastructures.
elseif|else
if|if
condition|(
name|state
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
operator|||
name|state
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|KILLED
condition|)
block|{
comment|// Get the event number for the (possibly) previously successful
comment|// task. If there exists one, then set that status to OBSOLETE
name|int
name|eventNumber
decl_stmt|;
if|if
condition|(
operator|(
name|eventNumber
operator|=
name|tip
operator|.
name|getSuccessEventNumber
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|TaskCompletionEvent
name|t
init|=
name|this
operator|.
name|taskCompletionEvents
operator|.
name|get
argument_list|(
name|eventNumber
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|getTaskAttemptId
argument_list|()
operator|.
name|equals
argument_list|(
name|taskid
argument_list|)
condition|)
name|t
operator|.
name|setTaskStatus
argument_list|(
name|TaskCompletionEvent
operator|.
name|Status
operator|.
name|OBSOLETE
argument_list|)
expr_stmt|;
block|}
comment|// Tell the job to fail the relevant task
name|failedTask
argument_list|(
name|tip
argument_list|,
name|taskid
argument_list|,
name|status
argument_list|,
name|taskTracker
argument_list|,
name|wasRunning
argument_list|,
name|wasComplete
argument_list|,
name|wasAttemptRunning
argument_list|)
expr_stmt|;
comment|// Did the task failure lead to tip failure?
name|TaskCompletionEvent
operator|.
name|Status
name|taskCompletionStatus
init|=
operator|(
name|state
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
operator|)
condition|?
name|TaskCompletionEvent
operator|.
name|Status
operator|.
name|FAILED
else|:
name|TaskCompletionEvent
operator|.
name|Status
operator|.
name|KILLED
decl_stmt|;
if|if
condition|(
name|tip
operator|.
name|isFailed
argument_list|()
condition|)
block|{
name|taskCompletionStatus
operator|=
name|TaskCompletionEvent
operator|.
name|Status
operator|.
name|TIPFAILED
expr_stmt|;
block|}
name|taskEvent
operator|=
operator|new
name|TaskCompletionEvent
argument_list|(
name|taskCompletionEventTracker
argument_list|,
name|taskid
argument_list|,
name|tip
operator|.
name|idWithinJob
argument_list|()
argument_list|,
name|status
operator|.
name|getIsMap
argument_list|()
operator|&&
operator|!
name|tip
operator|.
name|isJobCleanupTask
argument_list|()
operator|&&
operator|!
name|tip
operator|.
name|isJobSetupTask
argument_list|()
argument_list|,
name|taskCompletionStatus
argument_list|,
name|taskTrackerHttpLocation
argument_list|)
expr_stmt|;
block|}
comment|// Add the 'complete' task i.e. successful/failed
comment|// It _is_ safe to add the TaskCompletionEvent.Status.SUCCEEDED
comment|// *before* calling TIP.completedTask since:
comment|// a. One and only one task of a TIP is declared as a SUCCESS, the
comment|//    other (speculative tasks) are marked KILLED
comment|// b. TIP.completedTask *does not* throw _any_ exception at all.
if|if
condition|(
name|taskEvent
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|taskCompletionEvents
operator|.
name|add
argument_list|(
name|taskEvent
argument_list|)
expr_stmt|;
name|taskCompletionEventTracker
operator|++
expr_stmt|;
name|JobTrackerStatistics
operator|.
name|TaskTrackerStat
name|ttStat
init|=
name|jobtracker
operator|.
name|getStatistics
argument_list|()
operator|.
name|getTaskTrackerStat
argument_list|(
name|tip
operator|.
name|machineWhereTaskRan
argument_list|(
name|taskid
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ttStat
operator|!=
literal|null
condition|)
block|{
comment|// ttStat can be null in case of lost tracker
name|ttStat
operator|.
name|incrTotalTasks
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|SUCCEEDED
condition|)
block|{
name|completedTask
argument_list|(
name|tip
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttStat
operator|!=
literal|null
condition|)
block|{
name|ttStat
operator|.
name|incrSucceededTasks
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|//
comment|// Update JobInProgress status
comment|//
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Taking progress for "
operator|+
name|tip
operator|.
name|getTIPId
argument_list|()
operator|+
literal|" from "
operator|+
name|oldProgress
operator|+
literal|" to "
operator|+
name|tip
operator|.
name|getProgress
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tip
operator|.
name|isJobCleanupTask
argument_list|()
operator|&&
operator|!
name|tip
operator|.
name|isJobSetupTask
argument_list|()
condition|)
block|{
name|double
name|progressDelta
init|=
name|tip
operator|.
name|getProgress
argument_list|()
operator|-
name|oldProgress
decl_stmt|;
if|if
condition|(
name|tip
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
name|this
operator|.
name|status
operator|.
name|setMapProgress
argument_list|(
call|(
name|float
call|)
argument_list|(
name|this
operator|.
name|status
operator|.
name|mapProgress
argument_list|()
operator|+
name|progressDelta
operator|/
name|maps
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|status
operator|.
name|setReduceProgress
argument_list|(
call|(
name|float
call|)
argument_list|(
name|this
operator|.
name|status
operator|.
name|reduceProgress
argument_list|()
operator|+
operator|(
name|progressDelta
operator|/
name|reduces
operator|.
name|length
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the job-level counters.    *     * @return the job-level counters.    */
DECL|method|getJobCounters ()
specifier|public
specifier|synchronized
name|Counters
name|getJobCounters
parameter_list|()
block|{
return|return
name|jobCounters
return|;
block|}
comment|/**    *  Returns map phase counters by summing over all map tasks in progress.    */
DECL|method|getMapCounters ()
specifier|public
specifier|synchronized
name|Counters
name|getMapCounters
parameter_list|()
block|{
return|return
name|incrementTaskCounters
argument_list|(
operator|new
name|Counters
argument_list|()
argument_list|,
name|maps
argument_list|)
return|;
block|}
comment|/**    *  Returns map phase counters by summing over all map tasks in progress.    */
DECL|method|getReduceCounters ()
specifier|public
specifier|synchronized
name|Counters
name|getReduceCounters
parameter_list|()
block|{
return|return
name|incrementTaskCounters
argument_list|(
operator|new
name|Counters
argument_list|()
argument_list|,
name|reduces
argument_list|)
return|;
block|}
comment|/**    *  Returns the total job counters, by adding together the job,     *  the map and the reduce counters.    */
DECL|method|getCounters ()
specifier|public
name|Counters
name|getCounters
parameter_list|()
block|{
name|Counters
name|result
init|=
operator|new
name|Counters
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|result
operator|.
name|incrAllCounters
argument_list|(
name|getJobCounters
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// the counters of TIPs are not updated in place.
comment|// hence read-only access is ok without any locks
name|incrementTaskCounters
argument_list|(
name|result
argument_list|,
name|maps
argument_list|)
expr_stmt|;
return|return
name|incrementTaskCounters
argument_list|(
name|result
argument_list|,
name|reduces
argument_list|)
return|;
block|}
comment|/**    * Increments the counters with the counters from each task.    * @param counters the counters to increment    * @param tips the tasks to add in to counters    * @return counters the same object passed in as counters    */
DECL|method|incrementTaskCounters (Counters counters, TaskInProgress[] tips)
specifier|private
name|Counters
name|incrementTaskCounters
parameter_list|(
name|Counters
name|counters
parameter_list|,
name|TaskInProgress
index|[]
name|tips
parameter_list|)
block|{
try|try
block|{
for|for
control|(
name|TaskInProgress
name|tip
range|:
name|tips
control|)
block|{
name|counters
operator|.
name|incrAllCounters
argument_list|(
name|tip
operator|.
name|getCounters
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LimitExceededException
name|e
parameter_list|)
block|{
comment|// too many user counters/groups, leaving existing counters intact.
block|}
return|return
name|counters
return|;
block|}
comment|/////////////////////////////////////////////////////
comment|// Create/manage tasks
comment|/////////////////////////////////////////////////////
comment|/**    * Return a MapTask, if appropriate, to run on the given tasktracker    */
DECL|method|obtainNewMapTask (TaskTrackerStatus tts, int clusterSize, int numUniqueHosts, int maxCacheLevel )
specifier|public
specifier|synchronized
name|Task
name|obtainNewMapTask
parameter_list|(
name|TaskTrackerStatus
name|tts
parameter_list|,
name|int
name|clusterSize
parameter_list|,
name|int
name|numUniqueHosts
parameter_list|,
name|int
name|maxCacheLevel
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|status
operator|.
name|getRunState
argument_list|()
operator|!=
name|JobStatus
operator|.
name|RUNNING
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cannot create task split for "
operator|+
name|profile
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|int
name|target
init|=
name|findNewMapTask
argument_list|(
name|tts
argument_list|,
name|clusterSize
argument_list|,
name|numUniqueHosts
argument_list|,
name|maxCacheLevel
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Task
name|result
init|=
name|maps
index|[
name|target
index|]
operator|.
name|getTaskToRun
argument_list|(
name|tts
operator|.
name|getTrackerName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
name|addRunningTaskToTIP
argument_list|(
name|maps
index|[
name|target
index|]
argument_list|,
name|result
operator|.
name|getTaskID
argument_list|()
argument_list|,
name|tts
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Return a MapTask, if appropriate, to run on the given tasktracker    */
DECL|method|obtainNewMapTask (TaskTrackerStatus tts, int clusterSize, int numUniqueHosts )
specifier|public
specifier|synchronized
name|Task
name|obtainNewMapTask
parameter_list|(
name|TaskTrackerStatus
name|tts
parameter_list|,
name|int
name|clusterSize
parameter_list|,
name|int
name|numUniqueHosts
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|obtainNewMapTask
argument_list|(
name|tts
argument_list|,
name|clusterSize
argument_list|,
name|numUniqueHosts
argument_list|,
name|anyCacheLevel
argument_list|)
return|;
block|}
comment|/*    * Return task cleanup attempt if any, to run on a given tracker    */
DECL|method|obtainTaskCleanupTask (TaskTrackerStatus tts, boolean isMapSlot)
specifier|public
name|Task
name|obtainTaskCleanupTask
parameter_list|(
name|TaskTrackerStatus
name|tts
parameter_list|,
name|boolean
name|isMapSlot
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|tasksInited
operator|.
name|get
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|this
operator|.
name|status
operator|.
name|getRunState
argument_list|()
operator|!=
name|JobStatus
operator|.
name|RUNNING
operator|||
name|jobFailed
operator|||
name|jobKilled
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|taskTracker
init|=
name|tts
operator|.
name|getTrackerName
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|shouldRunOnTaskTracker
argument_list|(
name|taskTracker
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|TaskAttemptID
name|taskid
init|=
literal|null
decl_stmt|;
name|TaskInProgress
name|tip
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isMapSlot
condition|)
block|{
if|if
condition|(
operator|!
name|mapCleanupTasks
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|taskid
operator|=
name|mapCleanupTasks
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tip
operator|=
name|maps
index|[
name|taskid
operator|.
name|getTaskID
argument_list|()
operator|.
name|getId
argument_list|()
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|reduceCleanupTasks
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|taskid
operator|=
name|reduceCleanupTasks
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tip
operator|=
name|reduces
index|[
name|taskid
operator|.
name|getTaskID
argument_list|()
operator|.
name|getId
argument_list|()
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tip
operator|!=
literal|null
condition|)
block|{
return|return
name|tip
operator|.
name|addRunningTask
argument_list|(
name|taskid
argument_list|,
name|taskTracker
argument_list|,
literal|true
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
DECL|method|obtainNewLocalMapTask (TaskTrackerStatus tts, int clusterSize, int numUniqueHosts)
specifier|public
specifier|synchronized
name|Task
name|obtainNewLocalMapTask
parameter_list|(
name|TaskTrackerStatus
name|tts
parameter_list|,
name|int
name|clusterSize
parameter_list|,
name|int
name|numUniqueHosts
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|tasksInited
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cannot create task split for "
operator|+
name|profile
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|obtainNewMapTask
argument_list|(
name|tts
argument_list|,
name|clusterSize
argument_list|,
name|numUniqueHosts
argument_list|,
name|maxLevel
argument_list|)
return|;
block|}
DECL|method|obtainNewNonLocalMapTask (TaskTrackerStatus tts, int clusterSize, int numUniqueHosts)
specifier|public
specifier|synchronized
name|Task
name|obtainNewNonLocalMapTask
parameter_list|(
name|TaskTrackerStatus
name|tts
parameter_list|,
name|int
name|clusterSize
parameter_list|,
name|int
name|numUniqueHosts
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|tasksInited
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cannot create task split for "
operator|+
name|profile
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|obtainNewMapTask
argument_list|(
name|tts
argument_list|,
name|clusterSize
argument_list|,
name|numUniqueHosts
argument_list|,
name|NON_LOCAL_CACHE_LEVEL
argument_list|)
return|;
block|}
comment|/**    * Return a CleanupTask, if appropriate, to run on the given tasktracker    *     */
DECL|method|obtainJobCleanupTask (TaskTrackerStatus tts, int clusterSize, int numUniqueHosts, boolean isMapSlot )
specifier|public
name|Task
name|obtainJobCleanupTask
parameter_list|(
name|TaskTrackerStatus
name|tts
parameter_list|,
name|int
name|clusterSize
parameter_list|,
name|int
name|numUniqueHosts
parameter_list|,
name|boolean
name|isMapSlot
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|tasksInited
operator|.
name|get
argument_list|()
operator|||
operator|!
name|jobSetupCleanupNeeded
condition|)
block|{
return|return
literal|null
return|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
operator|!
name|canLaunchJobCleanupTask
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|taskTracker
init|=
name|tts
operator|.
name|getTrackerName
argument_list|()
decl_stmt|;
comment|// Update the last-known clusterSize
name|this
operator|.
name|clusterSize
operator|=
name|clusterSize
expr_stmt|;
if|if
condition|(
operator|!
name|shouldRunOnTaskTracker
argument_list|(
name|taskTracker
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|TaskInProgress
argument_list|>
name|cleanupTaskList
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|isMapSlot
condition|)
block|{
name|cleanupTaskList
operator|.
name|add
argument_list|(
name|cleanup
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cleanupTaskList
operator|.
name|add
argument_list|(
name|cleanup
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|TaskInProgress
name|tip
init|=
name|findTaskFromList
argument_list|(
name|cleanupTaskList
argument_list|,
name|tts
argument_list|,
name|numUniqueHosts
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|tip
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Now launch the cleanupTask
name|Task
name|result
init|=
name|tip
operator|.
name|getTaskToRun
argument_list|(
name|tts
operator|.
name|getTrackerName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
name|addRunningTaskToTIP
argument_list|(
name|tip
argument_list|,
name|result
operator|.
name|getTaskID
argument_list|()
argument_list|,
name|tts
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|jobFailed
condition|)
block|{
name|result
operator|.
name|setJobCleanupTaskState
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobStatus
operator|.
name|State
operator|.
name|FAILED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jobKilled
condition|)
block|{
name|result
operator|.
name|setJobCleanupTaskState
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobStatus
operator|.
name|State
operator|.
name|KILLED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|setJobCleanupTaskState
argument_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobStatus
operator|.
name|State
operator|.
name|SUCCEEDED
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
block|}
comment|/**    * Check whether cleanup task can be launched for the job.    *     * Cleanup task can be launched if it is not already launched    * or job is Killed    * or all maps and reduces are complete    * @return true/false    */
DECL|method|canLaunchJobCleanupTask ()
specifier|private
specifier|synchronized
name|boolean
name|canLaunchJobCleanupTask
parameter_list|()
block|{
comment|// check if the job is running
if|if
condition|(
name|status
operator|.
name|getRunState
argument_list|()
operator|!=
name|JobStatus
operator|.
name|RUNNING
operator|&&
name|status
operator|.
name|getRunState
argument_list|()
operator|!=
name|JobStatus
operator|.
name|PREP
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// check if cleanup task has been launched already or if setup isn't
comment|// launched already. The later check is useful when number of maps is
comment|// zero.
if|if
condition|(
name|launchedCleanup
operator|||
operator|!
name|isSetupFinished
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// check if job has failed or killed
if|if
condition|(
name|jobKilled
operator|||
name|jobFailed
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// Check if all maps and reducers have finished.
name|boolean
name|launchCleanupTask
init|=
operator|(
operator|(
name|finishedMapTasks
operator|+
name|failedMapTIPs
operator|)
operator|==
operator|(
name|numMapTasks
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|launchCleanupTask
condition|)
block|{
name|launchCleanupTask
operator|=
operator|(
operator|(
name|finishedReduceTasks
operator|+
name|failedReduceTIPs
operator|)
operator|==
name|numReduceTasks
operator|)
expr_stmt|;
block|}
return|return
name|launchCleanupTask
return|;
block|}
comment|/**    * Return a SetupTask, if appropriate, to run on the given tasktracker    *     */
DECL|method|obtainJobSetupTask (TaskTrackerStatus tts, int clusterSize, int numUniqueHosts, boolean isMapSlot )
specifier|public
name|Task
name|obtainJobSetupTask
parameter_list|(
name|TaskTrackerStatus
name|tts
parameter_list|,
name|int
name|clusterSize
parameter_list|,
name|int
name|numUniqueHosts
parameter_list|,
name|boolean
name|isMapSlot
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|tasksInited
operator|.
name|get
argument_list|()
operator|||
operator|!
name|jobSetupCleanupNeeded
condition|)
block|{
return|return
literal|null
return|;
block|}
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
operator|!
name|canLaunchSetupTask
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|taskTracker
init|=
name|tts
operator|.
name|getTrackerName
argument_list|()
decl_stmt|;
comment|// Update the last-known clusterSize
name|this
operator|.
name|clusterSize
operator|=
name|clusterSize
expr_stmt|;
if|if
condition|(
operator|!
name|shouldRunOnTaskTracker
argument_list|(
name|taskTracker
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|TaskInProgress
argument_list|>
name|setupTaskList
init|=
operator|new
name|ArrayList
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|isMapSlot
condition|)
block|{
name|setupTaskList
operator|.
name|add
argument_list|(
name|setup
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setupTaskList
operator|.
name|add
argument_list|(
name|setup
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|TaskInProgress
name|tip
init|=
name|findTaskFromList
argument_list|(
name|setupTaskList
argument_list|,
name|tts
argument_list|,
name|numUniqueHosts
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|tip
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Now launch the setupTask
name|Task
name|result
init|=
name|tip
operator|.
name|getTaskToRun
argument_list|(
name|tts
operator|.
name|getTrackerName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
name|addRunningTaskToTIP
argument_list|(
name|tip
argument_list|,
name|result
operator|.
name|getTaskID
argument_list|()
argument_list|,
name|tts
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
DECL|method|scheduleReduces ()
specifier|public
specifier|synchronized
name|boolean
name|scheduleReduces
parameter_list|()
block|{
return|return
name|finishedMapTasks
operator|>=
name|completedMapsForReduceSlowstart
return|;
block|}
comment|/**    * Check whether setup task can be launched for the job.    *     * Setup task can be launched after the tasks are inited    * and Job is in PREP state    * and if it is not already launched    * or job is not Killed/Failed    * @return true/false    */
DECL|method|canLaunchSetupTask ()
specifier|private
specifier|synchronized
name|boolean
name|canLaunchSetupTask
parameter_list|()
block|{
return|return
operator|(
name|tasksInited
operator|.
name|get
argument_list|()
operator|&&
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|JobStatus
operator|.
name|PREP
operator|&&
operator|!
name|launchedSetup
operator|&&
operator|!
name|jobKilled
operator|&&
operator|!
name|jobFailed
operator|)
return|;
block|}
comment|/**    * Return a ReduceTask, if appropriate, to run on the given tasktracker.    * We don't have cache-sensitivity for reduce tasks, as they    *  work on temporary MapRed files.      */
DECL|method|obtainNewReduceTask (TaskTrackerStatus tts, int clusterSize, int numUniqueHosts )
specifier|public
specifier|synchronized
name|Task
name|obtainNewReduceTask
parameter_list|(
name|TaskTrackerStatus
name|tts
parameter_list|,
name|int
name|clusterSize
parameter_list|,
name|int
name|numUniqueHosts
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|status
operator|.
name|getRunState
argument_list|()
operator|!=
name|JobStatus
operator|.
name|RUNNING
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cannot create task split for "
operator|+
name|profile
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Ensure we have sufficient map outputs ready to shuffle before
comment|// scheduling reduces
if|if
condition|(
operator|!
name|scheduleReduces
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|target
init|=
name|findNewReduceTask
argument_list|(
name|tts
argument_list|,
name|clusterSize
argument_list|,
name|numUniqueHosts
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Task
name|result
init|=
name|reduces
index|[
name|target
index|]
operator|.
name|getTaskToRun
argument_list|(
name|tts
operator|.
name|getTrackerName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
name|addRunningTaskToTIP
argument_list|(
name|reduces
index|[
name|target
index|]
argument_list|,
name|result
operator|.
name|getTaskID
argument_list|()
argument_list|,
name|tts
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|// returns the (cache)level at which the nodes matches
DECL|method|getMatchingLevelForNodes (Node n1, Node n2)
specifier|private
name|int
name|getMatchingLevelForNodes
parameter_list|(
name|Node
name|n1
parameter_list|,
name|Node
name|n2
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
do|do
block|{
if|if
condition|(
name|n1
operator|.
name|equals
argument_list|(
name|n2
argument_list|)
condition|)
block|{
return|return
name|count
return|;
block|}
operator|++
name|count
expr_stmt|;
name|n1
operator|=
name|n1
operator|.
name|getParent
argument_list|()
expr_stmt|;
name|n2
operator|=
name|n2
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|n1
operator|!=
literal|null
condition|)
do|;
return|return
name|this
operator|.
name|maxLevel
return|;
block|}
comment|/**    * Populate the data structures as a task is scheduled.    *     * Assuming {@link JobTracker} is locked on entry.    *     * @param tip The tip for which the task is added    * @param id The attempt-id for the task    * @param tts task-tracker status    * @param isScheduled Whether this task is scheduled from the JT or has     *        joined back upon restart    */
DECL|method|addRunningTaskToTIP (TaskInProgress tip, TaskAttemptID id, TaskTrackerStatus tts, boolean isScheduled)
specifier|synchronized
name|void
name|addRunningTaskToTIP
parameter_list|(
name|TaskInProgress
name|tip
parameter_list|,
name|TaskAttemptID
name|id
parameter_list|,
name|TaskTrackerStatus
name|tts
parameter_list|,
name|boolean
name|isScheduled
parameter_list|)
block|{
comment|// Make an entry in the tip if the attempt is not scheduled i.e externally
comment|// added
if|if
condition|(
operator|!
name|isScheduled
condition|)
block|{
name|tip
operator|.
name|addRunningTask
argument_list|(
name|id
argument_list|,
name|tts
operator|.
name|getTrackerName
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|JobTrackerInstrumentation
name|metrics
init|=
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
decl_stmt|;
comment|// keeping the earlier ordering intact
name|TaskType
name|name
decl_stmt|;
name|String
name|splits
init|=
literal|""
decl_stmt|;
name|Enum
name|counter
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|tip
operator|.
name|isJobSetupTask
argument_list|()
condition|)
block|{
name|launchedSetup
operator|=
literal|true
expr_stmt|;
name|name
operator|=
name|TaskType
operator|.
name|JOB_SETUP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tip
operator|.
name|isJobCleanupTask
argument_list|()
condition|)
block|{
name|launchedCleanup
operator|=
literal|true
expr_stmt|;
name|name
operator|=
name|TaskType
operator|.
name|JOB_CLEANUP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tip
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
operator|++
name|runningMapTasks
expr_stmt|;
name|name
operator|=
name|TaskType
operator|.
name|MAP
expr_stmt|;
name|counter
operator|=
name|JobCounter
operator|.
name|TOTAL_LAUNCHED_MAPS
expr_stmt|;
name|splits
operator|=
name|tip
operator|.
name|getSplitNodes
argument_list|()
expr_stmt|;
if|if
condition|(
name|tip
operator|.
name|isSpeculating
argument_list|()
condition|)
block|{
name|speculativeMapTasks
operator|++
expr_stmt|;
name|metrics
operator|.
name|speculateMap
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Chosen speculative task, current speculativeMap task count: "
operator|+
name|speculativeMapTasks
argument_list|)
expr_stmt|;
block|}
block|}
name|metrics
operator|.
name|launchMap
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|runningReduceTasks
expr_stmt|;
name|name
operator|=
name|TaskType
operator|.
name|REDUCE
expr_stmt|;
name|counter
operator|=
name|JobCounter
operator|.
name|TOTAL_LAUNCHED_REDUCES
expr_stmt|;
if|if
condition|(
name|tip
operator|.
name|isSpeculating
argument_list|()
condition|)
block|{
name|speculativeReduceTasks
operator|++
expr_stmt|;
name|metrics
operator|.
name|speculateReduce
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Chosen speculative task, current speculativeReduce task count: "
operator|+
name|speculativeReduceTasks
argument_list|)
expr_stmt|;
block|}
block|}
name|metrics
operator|.
name|launchReduce
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
comment|// Note that the logs are for the scheduled tasks only. Tasks that join on
comment|// restart has already their logs in place.
if|if
condition|(
name|tip
operator|.
name|isFirstAttempt
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|TaskStartedEvent
name|tse
init|=
operator|new
name|TaskStartedEvent
argument_list|(
name|tip
operator|.
name|getTIPId
argument_list|()
argument_list|,
name|tip
operator|.
name|getExecStartTime
argument_list|()
argument_list|,
name|name
argument_list|,
name|splits
argument_list|)
decl_stmt|;
name|jobHistory
operator|.
name|logEvent
argument_list|(
name|tse
argument_list|,
name|tip
operator|.
name|getJob
argument_list|()
operator|.
name|jobId
argument_list|)
expr_stmt|;
name|setFirstTaskLaunchTime
argument_list|(
name|tip
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tip
operator|.
name|isJobSetupTask
argument_list|()
operator|&&
operator|!
name|tip
operator|.
name|isJobCleanupTask
argument_list|()
condition|)
block|{
name|jobCounters
operator|.
name|incrCounter
argument_list|(
name|counter
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|//TODO The only problem with these counters would be on restart.
comment|// The jobtracker updates the counter only when the task that is scheduled
comment|// if from a non-running tip and is local (data, rack ...). But upon restart
comment|// as the reports come from the task tracker, there is no good way to infer
comment|// when exactly to increment the locality counters. The only solution is to
comment|// increment the counters for all the tasks irrespective of
comment|//    - whether the tip is running or not
comment|//    - whether its a speculative task or not
comment|//
comment|// So to simplify, increment the data locality counter whenever there is
comment|// data locality.
if|if
condition|(
name|tip
operator|.
name|isMapTask
argument_list|()
operator|&&
operator|!
name|tip
operator|.
name|isJobSetupTask
argument_list|()
operator|&&
operator|!
name|tip
operator|.
name|isJobCleanupTask
argument_list|()
condition|)
block|{
comment|// increment the data locality counter for maps
name|int
name|level
init|=
name|getLocalityLevel
argument_list|(
name|tip
argument_list|,
name|tts
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|level
condition|)
block|{
case|case
literal|0
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Choosing data-local task "
operator|+
name|tip
operator|.
name|getTIPId
argument_list|()
argument_list|)
expr_stmt|;
name|jobCounters
operator|.
name|incrCounter
argument_list|(
name|JobCounter
operator|.
name|DATA_LOCAL_MAPS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|launchDataLocalMap
argument_list|(
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Choosing rack-local task "
operator|+
name|tip
operator|.
name|getTIPId
argument_list|()
argument_list|)
expr_stmt|;
name|jobCounters
operator|.
name|incrCounter
argument_list|(
name|JobCounter
operator|.
name|RACK_LOCAL_MAPS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|launchRackLocalMap
argument_list|(
name|id
argument_list|)
expr_stmt|;
break|break;
default|default :
comment|// check if there is any locality
if|if
condition|(
name|level
operator|!=
name|this
operator|.
name|maxLevel
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Choosing cached task at level "
operator|+
name|level
operator|+
name|tip
operator|.
name|getTIPId
argument_list|()
argument_list|)
expr_stmt|;
name|jobCounters
operator|.
name|incrCounter
argument_list|(
name|JobCounter
operator|.
name|OTHER_LOCAL_MAPS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
DECL|method|setFirstTaskLaunchTime (TaskInProgress tip)
name|void
name|setFirstTaskLaunchTime
parameter_list|(
name|TaskInProgress
name|tip
parameter_list|)
block|{
name|TaskType
name|key
init|=
name|getTaskType
argument_list|(
name|tip
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|firstTaskLaunchTimes
init|)
block|{
comment|// Could be optimized to do only one lookup with a little more code
if|if
condition|(
operator|!
name|firstTaskLaunchTimes
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|firstTaskLaunchTimes
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|tip
operator|.
name|getExecStartTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|convertTrackerNameToHostName (String trackerName)
specifier|public
specifier|static
name|String
name|convertTrackerNameToHostName
parameter_list|(
name|String
name|trackerName
parameter_list|)
block|{
comment|// Ugly!
comment|// Convert the trackerName to it's host name
name|int
name|indexOfColon
init|=
name|trackerName
operator|.
name|indexOf
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
name|String
name|trackerHostName
init|=
operator|(
name|indexOfColon
operator|==
operator|-
literal|1
operator|)
condition|?
name|trackerName
else|:
name|trackerName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|indexOfColon
argument_list|)
decl_stmt|;
return|return
name|trackerHostName
operator|.
name|substring
argument_list|(
literal|"tracker_"
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Note that a task has failed on a given tracker and add the tracker      * to the blacklist iff too many trackers in the cluster i.e.     * (clusterSize * CLUSTER_BLACKLIST_PERCENT) haven't turned 'flaky' already.    *     * @param taskTracker task-tracker on which a task failed    */
DECL|method|addTrackerTaskFailure (String trackerName, TaskTracker taskTracker)
specifier|synchronized
name|void
name|addTrackerTaskFailure
parameter_list|(
name|String
name|trackerName
parameter_list|,
name|TaskTracker
name|taskTracker
parameter_list|)
block|{
if|if
condition|(
name|flakyTaskTrackers
operator|<
operator|(
name|clusterSize
operator|*
name|CLUSTER_BLACKLIST_PERCENT
operator|)
condition|)
block|{
name|String
name|trackerHostName
init|=
name|convertTrackerNameToHostName
argument_list|(
name|trackerName
argument_list|)
decl_stmt|;
name|Integer
name|trackerFailures
init|=
name|trackerToFailuresMap
operator|.
name|get
argument_list|(
name|trackerHostName
argument_list|)
decl_stmt|;
if|if
condition|(
name|trackerFailures
operator|==
literal|null
condition|)
block|{
name|trackerFailures
operator|=
literal|0
expr_stmt|;
block|}
name|trackerToFailuresMap
operator|.
name|put
argument_list|(
name|trackerHostName
argument_list|,
operator|++
name|trackerFailures
argument_list|)
expr_stmt|;
comment|// Check if this tasktracker has turned 'flaky'
if|if
condition|(
name|trackerFailures
operator|.
name|intValue
argument_list|()
operator|==
name|maxTaskFailuresPerTracker
condition|)
block|{
operator|++
name|flakyTaskTrackers
expr_stmt|;
comment|// Cancel reservations if appropriate
if|if
condition|(
name|taskTracker
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|trackersReservedForMaps
operator|.
name|containsKey
argument_list|(
name|taskTracker
argument_list|)
condition|)
block|{
name|taskTracker
operator|.
name|unreserveSlots
argument_list|(
name|TaskType
operator|.
name|MAP
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trackersReservedForReduces
operator|.
name|containsKey
argument_list|(
name|taskTracker
argument_list|)
condition|)
block|{
name|taskTracker
operator|.
name|unreserveSlots
argument_list|(
name|TaskType
operator|.
name|REDUCE
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"TaskTracker at '"
operator|+
name|trackerHostName
operator|+
literal|"' turned 'flaky'"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|reserveTaskTracker (TaskTracker taskTracker, TaskType type, int numSlots)
specifier|public
specifier|synchronized
name|void
name|reserveTaskTracker
parameter_list|(
name|TaskTracker
name|taskTracker
parameter_list|,
name|TaskType
name|type
parameter_list|,
name|int
name|numSlots
parameter_list|)
block|{
name|Map
argument_list|<
name|TaskTracker
argument_list|,
name|FallowSlotInfo
argument_list|>
name|map
init|=
operator|(
name|type
operator|==
name|TaskType
operator|.
name|MAP
operator|)
condition|?
name|trackersReservedForMaps
else|:
name|trackersReservedForReduces
decl_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|FallowSlotInfo
name|info
init|=
name|map
operator|.
name|get
argument_list|(
name|taskTracker
argument_list|)
decl_stmt|;
name|int
name|reservedSlots
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
name|info
operator|=
operator|new
name|FallowSlotInfo
argument_list|(
name|now
argument_list|,
name|numSlots
argument_list|)
expr_stmt|;
name|reservedSlots
operator|=
name|numSlots
expr_stmt|;
block|}
else|else
block|{
comment|// Increment metering info if the reservation is changing
if|if
condition|(
name|info
operator|.
name|getNumSlots
argument_list|()
operator|!=
name|numSlots
condition|)
block|{
name|Enum
argument_list|<
name|JobCounter
argument_list|>
name|counter
init|=
operator|(
name|type
operator|==
name|TaskType
operator|.
name|MAP
operator|)
condition|?
name|JobCounter
operator|.
name|FALLOW_SLOTS_MILLIS_MAPS
else|:
name|JobCounter
operator|.
name|FALLOW_SLOTS_MILLIS_REDUCES
decl_stmt|;
name|long
name|fallowSlotMillis
init|=
operator|(
name|now
operator|-
name|info
operator|.
name|getTimestamp
argument_list|()
operator|)
operator|*
name|info
operator|.
name|getNumSlots
argument_list|()
decl_stmt|;
name|jobCounters
operator|.
name|incrCounter
argument_list|(
name|counter
argument_list|,
name|fallowSlotMillis
argument_list|)
expr_stmt|;
comment|// Update
name|reservedSlots
operator|=
name|numSlots
operator|-
name|info
operator|.
name|getNumSlots
argument_list|()
expr_stmt|;
name|info
operator|.
name|setTimestamp
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|info
operator|.
name|setNumSlots
argument_list|(
name|numSlots
argument_list|)
expr_stmt|;
block|}
block|}
name|map
operator|.
name|put
argument_list|(
name|taskTracker
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TaskType
operator|.
name|MAP
condition|)
block|{
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|addReservedMapSlots
argument_list|(
name|reservedSlots
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|addReservedReduceSlots
argument_list|(
name|reservedSlots
argument_list|)
expr_stmt|;
block|}
name|jobtracker
operator|.
name|incrementReservations
argument_list|(
name|type
argument_list|,
name|reservedSlots
argument_list|)
expr_stmt|;
block|}
DECL|method|unreserveTaskTracker (TaskTracker taskTracker, TaskType type)
specifier|public
specifier|synchronized
name|void
name|unreserveTaskTracker
parameter_list|(
name|TaskTracker
name|taskTracker
parameter_list|,
name|TaskType
name|type
parameter_list|)
block|{
name|Map
argument_list|<
name|TaskTracker
argument_list|,
name|FallowSlotInfo
argument_list|>
name|map
init|=
operator|(
name|type
operator|==
name|TaskType
operator|.
name|MAP
operator|)
condition|?
name|trackersReservedForMaps
else|:
name|trackersReservedForReduces
decl_stmt|;
name|FallowSlotInfo
name|info
init|=
name|map
operator|.
name|get
argument_list|(
name|taskTracker
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot find information about fallow slots for "
operator|+
name|taskTracker
operator|.
name|getTrackerName
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|Enum
argument_list|<
name|JobCounter
argument_list|>
name|counter
init|=
operator|(
name|type
operator|==
name|TaskType
operator|.
name|MAP
operator|)
condition|?
name|JobCounter
operator|.
name|FALLOW_SLOTS_MILLIS_MAPS
else|:
name|JobCounter
operator|.
name|FALLOW_SLOTS_MILLIS_REDUCES
decl_stmt|;
name|long
name|fallowSlotMillis
init|=
operator|(
name|now
operator|-
name|info
operator|.
name|getTimestamp
argument_list|()
operator|)
operator|*
name|info
operator|.
name|getNumSlots
argument_list|()
decl_stmt|;
name|jobCounters
operator|.
name|incrCounter
argument_list|(
name|counter
argument_list|,
name|fallowSlotMillis
argument_list|)
expr_stmt|;
name|map
operator|.
name|remove
argument_list|(
name|taskTracker
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TaskType
operator|.
name|MAP
condition|)
block|{
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|decReservedMapSlots
argument_list|(
name|info
operator|.
name|getNumSlots
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|decReservedReduceSlots
argument_list|(
name|info
operator|.
name|getNumSlots
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|jobtracker
operator|.
name|decrementReservations
argument_list|(
name|type
argument_list|,
name|info
operator|.
name|getNumSlots
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|getNumReservedTaskTrackersForMaps ()
specifier|public
name|int
name|getNumReservedTaskTrackersForMaps
parameter_list|()
block|{
return|return
name|trackersReservedForMaps
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|getNumReservedTaskTrackersForReduces ()
specifier|public
name|int
name|getNumReservedTaskTrackersForReduces
parameter_list|()
block|{
return|return
name|trackersReservedForReduces
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|getTrackerTaskFailures (String trackerName)
specifier|private
name|int
name|getTrackerTaskFailures
parameter_list|(
name|String
name|trackerName
parameter_list|)
block|{
name|String
name|trackerHostName
init|=
name|convertTrackerNameToHostName
argument_list|(
name|trackerName
argument_list|)
decl_stmt|;
name|Integer
name|failedTasks
init|=
name|trackerToFailuresMap
operator|.
name|get
argument_list|(
name|trackerHostName
argument_list|)
decl_stmt|;
return|return
operator|(
name|failedTasks
operator|!=
literal|null
operator|)
condition|?
name|failedTasks
operator|.
name|intValue
argument_list|()
else|:
literal|0
return|;
block|}
comment|/**    * Get the black listed trackers for the job    *     * @return List of blacklisted tracker names    */
DECL|method|getBlackListedTrackers ()
name|List
argument_list|<
name|String
argument_list|>
name|getBlackListedTrackers
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|blackListedTrackers
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|e
range|:
name|trackerToFailuresMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|intValue
argument_list|()
operator|>=
name|maxTaskFailuresPerTracker
condition|)
block|{
name|blackListedTrackers
operator|.
name|add
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|blackListedTrackers
return|;
block|}
comment|/**    * Get the no. of 'flaky' tasktrackers for a given job.    *     * @return the no. of 'flaky' tasktrackers for a given job.    */
DECL|method|getNoOfBlackListedTrackers ()
name|int
name|getNoOfBlackListedTrackers
parameter_list|()
block|{
return|return
name|flakyTaskTrackers
return|;
block|}
comment|/**    * Get the information on tasktrackers and no. of errors which occurred    * on them for a given job.     *     * @return the map of tasktrackers and no. of errors which occurred    *         on them for a given job.     */
DECL|method|getTaskTrackerErrors ()
specifier|synchronized
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|getTaskTrackerErrors
parameter_list|()
block|{
comment|// Clone the 'trackerToFailuresMap' and return the copy
name|Map
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
name|trackerErrors
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|Integer
argument_list|>
argument_list|(
name|trackerToFailuresMap
argument_list|)
decl_stmt|;
return|return
name|trackerErrors
return|;
block|}
comment|/**    * Remove a map TIP from the lists for running maps.    * Called when a map fails/completes (note if a map is killed,    * it won't be present in the list since it was completed earlier)    * @param tip the tip that needs to be retired    */
DECL|method|retireMap (TaskInProgress tip)
specifier|private
specifier|synchronized
name|void
name|retireMap
parameter_list|(
name|TaskInProgress
name|tip
parameter_list|)
block|{
if|if
condition|(
name|runningMapCache
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Running cache for maps missing!! "
operator|+
literal|"Job details are missing."
argument_list|)
expr_stmt|;
return|return;
block|}
name|String
index|[]
name|splitLocations
init|=
name|tip
operator|.
name|getSplitLocations
argument_list|()
decl_stmt|;
comment|// Remove the TIP from the list for running non-local maps
if|if
condition|(
name|splitLocations
operator|==
literal|null
operator|||
name|splitLocations
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|nonLocalRunningMaps
operator|.
name|remove
argument_list|(
name|tip
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Remove from the running map caches
for|for
control|(
name|String
name|host
range|:
name|splitLocations
control|)
block|{
name|Node
name|node
init|=
name|jobtracker
operator|.
name|getNode
argument_list|(
name|host
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|maxLevel
condition|;
operator|++
name|j
control|)
block|{
name|Set
argument_list|<
name|TaskInProgress
argument_list|>
name|hostMaps
init|=
name|runningMapCache
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|hostMaps
operator|!=
literal|null
condition|)
block|{
name|hostMaps
operator|.
name|remove
argument_list|(
name|tip
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostMaps
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|runningMapCache
operator|.
name|remove
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
name|node
operator|=
name|node
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Remove a reduce TIP from the list for running-reduces    * Called when a reduce fails/completes    * @param tip the tip that needs to be retired    */
DECL|method|retireReduce (TaskInProgress tip)
specifier|private
specifier|synchronized
name|void
name|retireReduce
parameter_list|(
name|TaskInProgress
name|tip
parameter_list|)
block|{
if|if
condition|(
name|runningReduces
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Running list for reducers missing!! "
operator|+
literal|"Job details are missing."
argument_list|)
expr_stmt|;
return|return;
block|}
name|runningReduces
operator|.
name|remove
argument_list|(
name|tip
argument_list|)
expr_stmt|;
block|}
comment|/**    * Adds a map tip to the list of running maps.    * @param tip the tip that needs to be scheduled as running    */
DECL|method|scheduleMap (TaskInProgress tip)
specifier|protected
specifier|synchronized
name|void
name|scheduleMap
parameter_list|(
name|TaskInProgress
name|tip
parameter_list|)
block|{
name|runningMapTaskStats
operator|.
name|add
argument_list|(
literal|0.0f
argument_list|)
expr_stmt|;
if|if
condition|(
name|runningMapCache
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Running cache for maps is missing!! "
operator|+
literal|"Job details are missing."
argument_list|)
expr_stmt|;
return|return;
block|}
name|String
index|[]
name|splitLocations
init|=
name|tip
operator|.
name|getSplitLocations
argument_list|()
decl_stmt|;
comment|// Add the TIP to the list of non-local running TIPs
if|if
condition|(
name|splitLocations
operator|==
literal|null
operator|||
name|splitLocations
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|nonLocalRunningMaps
operator|.
name|add
argument_list|(
name|tip
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|String
name|host
range|:
name|splitLocations
control|)
block|{
name|Node
name|node
init|=
name|jobtracker
operator|.
name|getNode
argument_list|(
name|host
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|maxLevel
condition|;
operator|++
name|j
control|)
block|{
name|Set
argument_list|<
name|TaskInProgress
argument_list|>
name|hostMaps
init|=
name|runningMapCache
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|hostMaps
operator|==
literal|null
condition|)
block|{
comment|// create a cache if needed
name|hostMaps
operator|=
operator|new
name|LinkedHashSet
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|()
expr_stmt|;
name|runningMapCache
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|hostMaps
argument_list|)
expr_stmt|;
block|}
name|hostMaps
operator|.
name|add
argument_list|(
name|tip
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Adds a reduce tip to the list of running reduces    * @param tip the tip that needs to be scheduled as running    */
DECL|method|scheduleReduce (TaskInProgress tip)
specifier|protected
specifier|synchronized
name|void
name|scheduleReduce
parameter_list|(
name|TaskInProgress
name|tip
parameter_list|)
block|{
name|runningReduceTaskStats
operator|.
name|add
argument_list|(
literal|0.0f
argument_list|)
expr_stmt|;
if|if
condition|(
name|runningReduces
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Running cache for reducers missing!! "
operator|+
literal|"Job details are missing."
argument_list|)
expr_stmt|;
return|return;
block|}
name|runningReduces
operator|.
name|add
argument_list|(
name|tip
argument_list|)
expr_stmt|;
block|}
comment|/**    * Adds the failed TIP in the front of the list for non-running maps    * @param tip the tip that needs to be failed    */
DECL|method|failMap (TaskInProgress tip)
specifier|private
specifier|synchronized
name|void
name|failMap
parameter_list|(
name|TaskInProgress
name|tip
parameter_list|)
block|{
if|if
condition|(
name|nonRunningMapCache
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Non-running cache for maps missing!! "
operator|+
literal|"Job details are missing."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// 1. Its added everywhere since other nodes (having this split local)
comment|//    might have removed this tip from their local cache
comment|// 2. Give high priority to failed tip - fail early
name|String
index|[]
name|splitLocations
init|=
name|tip
operator|.
name|getSplitLocations
argument_list|()
decl_stmt|;
comment|// Add the TIP in the front of the list for non-local non-running maps
if|if
condition|(
name|splitLocations
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|nonLocalMaps
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|tip
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|String
name|host
range|:
name|splitLocations
control|)
block|{
name|Node
name|node
init|=
name|jobtracker
operator|.
name|getNode
argument_list|(
name|host
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|maxLevel
condition|;
operator|++
name|j
control|)
block|{
name|List
argument_list|<
name|TaskInProgress
argument_list|>
name|hostMaps
init|=
name|nonRunningMapCache
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|hostMaps
operator|==
literal|null
condition|)
block|{
name|hostMaps
operator|=
operator|new
name|LinkedList
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|()
expr_stmt|;
name|nonRunningMapCache
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|hostMaps
argument_list|)
expr_stmt|;
block|}
name|hostMaps
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|tip
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Adds a failed TIP in the front of the list for non-running reduces    * @param tip the tip that needs to be failed    */
DECL|method|failReduce (TaskInProgress tip)
specifier|private
specifier|synchronized
name|void
name|failReduce
parameter_list|(
name|TaskInProgress
name|tip
parameter_list|)
block|{
if|if
condition|(
name|nonRunningReduces
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed cache for reducers missing!! "
operator|+
literal|"Job details are missing."
argument_list|)
expr_stmt|;
return|return;
block|}
name|nonRunningReduces
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|tip
argument_list|)
expr_stmt|;
block|}
comment|/**    * Find a non-running task in the passed list of TIPs    * @param tips a collection of TIPs    * @param ttStatus the status of tracker that has requested a task to run    * @param numUniqueHosts number of unique hosts that run trask trackers    * @param removeFailedTip whether to remove the failed tips    */
DECL|method|findTaskFromList ( Collection<TaskInProgress> tips, TaskTrackerStatus ttStatus, int numUniqueHosts, boolean removeFailedTip)
specifier|private
specifier|synchronized
name|TaskInProgress
name|findTaskFromList
parameter_list|(
name|Collection
argument_list|<
name|TaskInProgress
argument_list|>
name|tips
parameter_list|,
name|TaskTrackerStatus
name|ttStatus
parameter_list|,
name|int
name|numUniqueHosts
parameter_list|,
name|boolean
name|removeFailedTip
parameter_list|)
block|{
name|Iterator
argument_list|<
name|TaskInProgress
argument_list|>
name|iter
init|=
name|tips
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|TaskInProgress
name|tip
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// Select a tip if
comment|//   1. runnable   : still needs to be run and is not completed
comment|//   2. ~running   : no other node is running it
comment|//   3. earlier attempt failed : has not failed on this host
comment|//                               and has failed on all the other hosts
comment|// A TIP is removed from the list if
comment|// (1) this tip is scheduled
comment|// (2) if the passed list is a level 0 (host) cache
comment|// (3) when the TIP is non-schedulable (running, killed, complete)
if|if
condition|(
name|tip
operator|.
name|isRunnable
argument_list|()
operator|&&
operator|!
name|tip
operator|.
name|isRunning
argument_list|()
condition|)
block|{
comment|// check if the tip has failed on this host
if|if
condition|(
operator|!
name|tip
operator|.
name|hasFailedOnMachine
argument_list|(
name|ttStatus
operator|.
name|getHost
argument_list|()
argument_list|)
operator|||
name|tip
operator|.
name|getNumberOfFailedMachines
argument_list|()
operator|>=
name|numUniqueHosts
condition|)
block|{
comment|// check if the tip has failed on all the nodes
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
name|tip
return|;
block|}
elseif|else
if|if
condition|(
name|removeFailedTip
condition|)
block|{
comment|// the case where we want to remove a failed tip from the host cache
comment|// point#3 in the TIP removal logic above
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// see point#3 in the comment above for TIP removal logic
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|hasSpeculativeMaps ()
specifier|public
name|boolean
name|hasSpeculativeMaps
parameter_list|()
block|{
return|return
name|hasSpeculativeMaps
return|;
block|}
DECL|method|hasSpeculativeReduces ()
specifier|public
name|boolean
name|hasSpeculativeReduces
parameter_list|()
block|{
return|return
name|hasSpeculativeReduces
return|;
block|}
comment|/**    * Retrieve a task for speculation.    * If a task slot becomes available and there are less than SpeculativeCap    * speculative tasks running:     *  1)Ignore the request if the TT's progressRate is< SlowNodeThreshold    *  2)Choose candidate tasks - those tasks whose progress rate is below    *    slowTaskThreshold * mean(progress-rates)    *  3)Speculate task that's expected to complete last    * @param list pool of tasks to choose from    * @param taskTrackerName the name of the TaskTracker asking for a task    * @param taskTrackerHost the hostname of the TaskTracker asking for a task    * @param taskType the type of task (MAP/REDUCE) that we are considering    * @return the TIP to speculatively re-execute    */
DECL|method|findSpeculativeTask ( Collection<TaskInProgress> list, String taskTrackerName, String taskTrackerHost, TaskType taskType)
specifier|protected
specifier|synchronized
name|TaskInProgress
name|findSpeculativeTask
parameter_list|(
name|Collection
argument_list|<
name|TaskInProgress
argument_list|>
name|list
parameter_list|,
name|String
name|taskTrackerName
parameter_list|,
name|String
name|taskTrackerHost
parameter_list|,
name|TaskType
name|taskType
parameter_list|)
block|{
if|if
condition|(
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
name|long
name|now
init|=
name|JobTracker
operator|.
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
decl_stmt|;
comment|// Don't return anything if either the TaskTracker is slow or we have
comment|// already launched enough speculative tasks in the cluster.
if|if
condition|(
name|isSlowTracker
argument_list|(
name|taskTrackerName
argument_list|)
operator|||
name|atSpeculativeCap
argument_list|(
name|list
argument_list|,
name|taskType
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|TaskInProgress
name|slowestTIP
init|=
literal|null
decl_stmt|;
name|Comparator
argument_list|<
name|TaskInProgress
argument_list|>
name|LateComparator
init|=
operator|new
name|EstimatedTimeLeftComparator
argument_list|(
name|now
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|TaskInProgress
argument_list|>
name|iter
init|=
name|list
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|TaskInProgress
name|tip
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// If this tip has already run on this machine once or it doesn't need any
comment|// more speculative attempts, skip it.
if|if
condition|(
name|tip
operator|.
name|hasRunOnMachine
argument_list|(
name|taskTrackerHost
argument_list|,
name|taskTrackerName
argument_list|)
operator|||
operator|!
name|tip
operator|.
name|canBeSpeculated
argument_list|(
name|now
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|slowestTIP
operator|==
literal|null
condition|)
block|{
name|slowestTIP
operator|=
name|tip
expr_stmt|;
block|}
else|else
block|{
name|slowestTIP
operator|=
name|LateComparator
operator|.
name|compare
argument_list|(
name|tip
argument_list|,
name|slowestTIP
argument_list|)
operator|<
literal|0
condition|?
name|tip
else|:
name|slowestTIP
expr_stmt|;
block|}
block|}
if|if
condition|(
name|slowestTIP
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Chose task "
operator|+
name|slowestTIP
operator|.
name|getTIPId
argument_list|()
operator|+
literal|". Statistics: Task's : "
operator|+
name|slowestTIP
operator|.
name|getCurrentProgressRate
argument_list|(
name|now
argument_list|)
operator|+
literal|" Job's : "
operator|+
operator|(
name|slowestTIP
operator|.
name|isMapTask
argument_list|()
condition|?
name|runningMapTaskStats
else|:
name|runningReduceTaskStats
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|slowestTIP
return|;
block|}
comment|/**    * Find new map task    * @param tts The task tracker that is asking for a task    * @param clusterSize The number of task trackers in the cluster    * @param numUniqueHosts The number of hosts that run task trackers    * @param maxCacheLevel The maximum topology level until which to schedule    *                      maps.     *                      A value of {@link #anyCacheLevel} implies any     *                      available task (node-local, rack-local, off-switch and     *                      speculative tasks).    *                      A value of {@link #NON_LOCAL_CACHE_LEVEL} implies only    *                      off-switch/speculative tasks should be scheduled.    * @return the index in tasks of the selected task (or -1 for no task)    */
DECL|method|findNewMapTask (final TaskTrackerStatus tts, final int clusterSize, final int numUniqueHosts, final int maxCacheLevel)
specifier|private
specifier|synchronized
name|int
name|findNewMapTask
parameter_list|(
specifier|final
name|TaskTrackerStatus
name|tts
parameter_list|,
specifier|final
name|int
name|clusterSize
parameter_list|,
specifier|final
name|int
name|numUniqueHosts
parameter_list|,
specifier|final
name|int
name|maxCacheLevel
parameter_list|)
block|{
name|String
name|taskTrackerName
init|=
name|tts
operator|.
name|getTrackerName
argument_list|()
decl_stmt|;
name|String
name|taskTrackerHost
init|=
name|tts
operator|.
name|getHost
argument_list|()
decl_stmt|;
if|if
condition|(
name|numMapTasks
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No maps to schedule for "
operator|+
name|profile
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
name|TaskInProgress
name|tip
init|=
literal|null
decl_stmt|;
comment|//
comment|// Update the last-known clusterSize
comment|//
name|this
operator|.
name|clusterSize
operator|=
name|clusterSize
expr_stmt|;
if|if
condition|(
operator|!
name|shouldRunOnTaskTracker
argument_list|(
name|taskTrackerName
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|// Check to ensure this TaskTracker has enough resources to
comment|// run tasks from this job
name|long
name|outSize
init|=
name|resourceEstimator
operator|.
name|getEstimatedMapOutputSize
argument_list|()
decl_stmt|;
name|long
name|availSpace
init|=
name|tts
operator|.
name|getResourceStatus
argument_list|()
operator|.
name|getAvailableSpace
argument_list|()
decl_stmt|;
if|if
condition|(
name|availSpace
operator|<
name|outSize
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No room for map task. Node "
operator|+
name|tts
operator|.
name|getHost
argument_list|()
operator|+
literal|" has "
operator|+
name|availSpace
operator|+
literal|" bytes free; but we expect map to take "
operator|+
name|outSize
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|//see if a different TIP might work better.
block|}
comment|// For scheduling a map task, we have two caches and a list (optional)
comment|//  I)   one for non-running task
comment|//  II)  one for running task (this is for handling speculation)
comment|//  III) a list of TIPs that have empty locations (e.g., dummy splits),
comment|//       the list is empty if all TIPs have associated locations
comment|// First a look up is done on the non-running cache and on a miss, a look
comment|// up is done on the running cache. The order for lookup within the cache:
comment|//   1. from local node to root [bottom up]
comment|//   2. breadth wise for all the parent nodes at max level
comment|// We fall to linear scan of the list (III above) if we have misses in the
comment|// above caches
name|Node
name|node
init|=
name|jobtracker
operator|.
name|getNode
argument_list|(
name|tts
operator|.
name|getHost
argument_list|()
argument_list|)
decl_stmt|;
comment|//
comment|// I) Non-running TIP :
comment|//
comment|// 1. check from local node to the root [bottom up cache lookup]
comment|//    i.e if the cache is available and the host has been resolved
comment|//    (node!=null)
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|Node
name|key
init|=
name|node
decl_stmt|;
name|int
name|level
init|=
literal|0
decl_stmt|;
comment|// maxCacheLevel might be greater than this.maxLevel if findNewMapTask is
comment|// called to schedule any task (local, rack-local, off-switch or speculative)
comment|// tasks or it might be NON_LOCAL_CACHE_LEVEL (i.e. -1) if findNewMapTask is
comment|//  (i.e. -1) if findNewMapTask is to only schedule off-switch/speculative
comment|// tasks
name|int
name|maxLevelToSchedule
init|=
name|Math
operator|.
name|min
argument_list|(
name|maxCacheLevel
argument_list|,
name|maxLevel
argument_list|)
decl_stmt|;
for|for
control|(
name|level
operator|=
literal|0
init|;
name|level
operator|<
name|maxLevelToSchedule
condition|;
operator|++
name|level
control|)
block|{
name|List
argument_list|<
name|TaskInProgress
argument_list|>
name|cacheForLevel
init|=
name|nonRunningMapCache
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|cacheForLevel
operator|!=
literal|null
condition|)
block|{
name|tip
operator|=
name|findTaskFromList
argument_list|(
name|cacheForLevel
argument_list|,
name|tts
argument_list|,
name|numUniqueHosts
argument_list|,
name|level
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tip
operator|!=
literal|null
condition|)
block|{
comment|// Add to running cache
name|scheduleMap
argument_list|(
name|tip
argument_list|)
expr_stmt|;
comment|// remove the cache if its empty
if|if
condition|(
name|cacheForLevel
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|nonRunningMapCache
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
return|return
name|tip
operator|.
name|getIdWithinJob
argument_list|()
return|;
block|}
block|}
name|key
operator|=
name|key
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
comment|// Check if we need to only schedule a local task (node-local/rack-local)
if|if
condition|(
name|level
operator|==
name|maxCacheLevel
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|//2. Search breadth-wise across parents at max level for non-running
comment|//   TIP if
comment|//     - cache exists and there is a cache miss
comment|//     - node information for the tracker is missing (tracker's topology
comment|//       info not obtained yet)
comment|// collection of node at max level in the cache structure
name|Collection
argument_list|<
name|Node
argument_list|>
name|nodesAtMaxLevel
init|=
name|jobtracker
operator|.
name|getNodesAtMaxLevel
argument_list|()
decl_stmt|;
comment|// get the node parent at max level
name|Node
name|nodeParentAtMaxLevel
init|=
operator|(
name|node
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|JobTracker
operator|.
name|getParentNode
argument_list|(
name|node
argument_list|,
name|maxLevel
operator|-
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|Node
name|parent
range|:
name|nodesAtMaxLevel
control|)
block|{
comment|// skip the parent that has already been scanned
if|if
condition|(
name|parent
operator|==
name|nodeParentAtMaxLevel
condition|)
block|{
continue|continue;
block|}
name|List
argument_list|<
name|TaskInProgress
argument_list|>
name|cache
init|=
name|nonRunningMapCache
operator|.
name|get
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|cache
operator|!=
literal|null
condition|)
block|{
name|tip
operator|=
name|findTaskFromList
argument_list|(
name|cache
argument_list|,
name|tts
argument_list|,
name|numUniqueHosts
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|tip
operator|!=
literal|null
condition|)
block|{
comment|// Add to the running cache
name|scheduleMap
argument_list|(
name|tip
argument_list|)
expr_stmt|;
comment|// remove the cache if empty
if|if
condition|(
name|cache
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|nonRunningMapCache
operator|.
name|remove
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Choosing a non-local task "
operator|+
name|tip
operator|.
name|getTIPId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|tip
operator|.
name|getIdWithinJob
argument_list|()
return|;
block|}
block|}
block|}
comment|// 3. Search non-local tips for a new task
name|tip
operator|=
name|findTaskFromList
argument_list|(
name|nonLocalMaps
argument_list|,
name|tts
argument_list|,
name|numUniqueHosts
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|tip
operator|!=
literal|null
condition|)
block|{
comment|// Add to the running list
name|scheduleMap
argument_list|(
name|tip
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Choosing a non-local task "
operator|+
name|tip
operator|.
name|getTIPId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|tip
operator|.
name|getIdWithinJob
argument_list|()
return|;
block|}
comment|//
comment|// II) Running TIP :
comment|//
if|if
condition|(
name|hasSpeculativeMaps
condition|)
block|{
name|tip
operator|=
name|getSpeculativeMap
argument_list|(
name|taskTrackerName
argument_list|,
name|taskTrackerHost
argument_list|)
expr_stmt|;
if|if
condition|(
name|tip
operator|!=
literal|null
condition|)
block|{
return|return
name|tip
operator|.
name|getIdWithinJob
argument_list|()
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|method|getSpeculativeMap (String taskTrackerName, String taskTrackerHost)
specifier|private
specifier|synchronized
name|TaskInProgress
name|getSpeculativeMap
parameter_list|(
name|String
name|taskTrackerName
parameter_list|,
name|String
name|taskTrackerHost
parameter_list|)
block|{
comment|//////// Populate allTips with all TaskInProgress
name|Set
argument_list|<
name|TaskInProgress
argument_list|>
name|allTips
init|=
operator|new
name|HashSet
argument_list|<
name|TaskInProgress
argument_list|>
argument_list|()
decl_stmt|;
comment|// collection of node at max level in the cache structure
name|Collection
argument_list|<
name|Node
argument_list|>
name|nodesAtMaxLevel
init|=
name|jobtracker
operator|.
name|getNodesAtMaxLevel
argument_list|()
decl_stmt|;
comment|// Add all tasks from max-level nodes breadth-wise
for|for
control|(
name|Node
name|parent
range|:
name|nodesAtMaxLevel
control|)
block|{
name|Set
argument_list|<
name|TaskInProgress
argument_list|>
name|cache
init|=
name|runningMapCache
operator|.
name|get
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|cache
operator|!=
literal|null
condition|)
block|{
name|allTips
operator|.
name|addAll
argument_list|(
name|cache
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Add all non-local TIPs
name|allTips
operator|.
name|addAll
argument_list|(
name|nonLocalRunningMaps
argument_list|)
expr_stmt|;
comment|///////// Select a TIP to run on
name|TaskInProgress
name|tip
init|=
name|findSpeculativeTask
argument_list|(
name|allTips
argument_list|,
name|taskTrackerName
argument_list|,
name|taskTrackerHost
argument_list|,
name|TaskType
operator|.
name|MAP
argument_list|)
decl_stmt|;
if|if
condition|(
name|tip
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Choosing map task "
operator|+
name|tip
operator|.
name|getTIPId
argument_list|()
operator|+
literal|" for speculative execution"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No speculative map task found for tracker "
operator|+
name|taskTrackerName
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tip
return|;
block|}
comment|/**    * Find new reduce task    * @param tts The task tracker that is asking for a task    * @param clusterSize The number of task trackers in the cluster    * @param numUniqueHosts The number of hosts that run task trackers    * @return the index in tasks of the selected task (or -1 for no task)    */
DECL|method|findNewReduceTask (TaskTrackerStatus tts, int clusterSize, int numUniqueHosts)
specifier|private
specifier|synchronized
name|int
name|findNewReduceTask
parameter_list|(
name|TaskTrackerStatus
name|tts
parameter_list|,
name|int
name|clusterSize
parameter_list|,
name|int
name|numUniqueHosts
parameter_list|)
block|{
name|String
name|taskTrackerName
init|=
name|tts
operator|.
name|getTrackerName
argument_list|()
decl_stmt|;
name|String
name|taskTrackerHost
init|=
name|tts
operator|.
name|getHost
argument_list|()
decl_stmt|;
if|if
condition|(
name|numReduceTasks
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No reduces to schedule for "
operator|+
name|profile
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
name|TaskInProgress
name|tip
init|=
literal|null
decl_stmt|;
comment|// Update the last-known clusterSize
name|this
operator|.
name|clusterSize
operator|=
name|clusterSize
expr_stmt|;
if|if
condition|(
operator|!
name|shouldRunOnTaskTracker
argument_list|(
name|taskTrackerName
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|long
name|outSize
init|=
name|resourceEstimator
operator|.
name|getEstimatedReduceInputSize
argument_list|()
decl_stmt|;
name|long
name|availSpace
init|=
name|tts
operator|.
name|getResourceStatus
argument_list|()
operator|.
name|getAvailableSpace
argument_list|()
decl_stmt|;
if|if
condition|(
name|availSpace
operator|<
name|outSize
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No room for reduce task. Node "
operator|+
name|taskTrackerName
operator|+
literal|" has "
operator|+
name|availSpace
operator|+
literal|" bytes free; but we expect reduce input to take "
operator|+
name|outSize
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|//see if a different TIP might work better.
block|}
comment|// 1. check for a never-executed reduce tip
comment|// reducers don't have a cache and so pass -1 to explicitly call that out
name|tip
operator|=
name|findTaskFromList
argument_list|(
name|nonRunningReduces
argument_list|,
name|tts
argument_list|,
name|numUniqueHosts
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|tip
operator|!=
literal|null
condition|)
block|{
name|scheduleReduce
argument_list|(
name|tip
argument_list|)
expr_stmt|;
return|return
name|tip
operator|.
name|getIdWithinJob
argument_list|()
return|;
block|}
comment|// 2. check for a reduce tip to be speculated
if|if
condition|(
name|hasSpeculativeReduces
condition|)
block|{
name|tip
operator|=
name|getSpeculativeReduce
argument_list|(
name|taskTrackerName
argument_list|,
name|taskTrackerHost
argument_list|)
expr_stmt|;
if|if
condition|(
name|tip
operator|!=
literal|null
condition|)
block|{
return|return
name|tip
operator|.
name|getIdWithinJob
argument_list|()
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|method|getSpeculativeReduce ( String taskTrackerName, String taskTrackerHost)
specifier|private
specifier|synchronized
name|TaskInProgress
name|getSpeculativeReduce
parameter_list|(
name|String
name|taskTrackerName
parameter_list|,
name|String
name|taskTrackerHost
parameter_list|)
block|{
name|TaskInProgress
name|tip
init|=
name|findSpeculativeTask
argument_list|(
name|runningReduces
argument_list|,
name|taskTrackerName
argument_list|,
name|taskTrackerHost
argument_list|,
name|TaskType
operator|.
name|REDUCE
argument_list|)
decl_stmt|;
if|if
condition|(
name|tip
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Choosing reduce task "
operator|+
name|tip
operator|.
name|getTIPId
argument_list|()
operator|+
literal|" for speculative execution"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No speculative map task found for tracker "
operator|+
name|taskTrackerHost
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tip
return|;
block|}
comment|/**      * Check to see if the maximum number of speculative tasks are      * already being executed currently.      * @param tasks the set of tasks to test      * @param type the type of task (MAP/REDUCE) that we are considering      * @return has the cap been reached?      */
DECL|method|atSpeculativeCap (Collection<TaskInProgress> tasks, TaskType type)
specifier|private
name|boolean
name|atSpeculativeCap
parameter_list|(
name|Collection
argument_list|<
name|TaskInProgress
argument_list|>
name|tasks
parameter_list|,
name|TaskType
name|type
parameter_list|)
block|{
name|float
name|numTasks
init|=
name|tasks
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|numTasks
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
comment|// avoid divide by zero
block|}
name|int
name|speculativeTaskCount
init|=
name|type
operator|==
name|TaskType
operator|.
name|MAP
condition|?
name|speculativeMapTasks
else|:
name|speculativeReduceTasks
decl_stmt|;
comment|//return true if totalSpecTask< max(10, 0.01 * total-slots,
comment|//                                   0.1 * total-running-tasks)
if|if
condition|(
name|speculativeTaskCount
operator|<
name|MIN_SPEC_CAP
condition|)
block|{
return|return
literal|false
return|;
comment|// at least one slow tracker's worth of slots(default=10)
block|}
name|ClusterStatus
name|c
init|=
name|jobtracker
operator|.
name|getClusterStatus
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|int
name|numSlots
init|=
operator|(
name|type
operator|==
name|TaskType
operator|.
name|MAP
condition|?
name|c
operator|.
name|getMaxMapTasks
argument_list|()
else|:
name|c
operator|.
name|getMaxReduceTasks
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|float
operator|)
name|speculativeTaskCount
operator|<
name|numSlots
operator|*
name|MIN_SLOTS_CAP
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|atCap
init|=
operator|(
operator|(
call|(
name|float
call|)
argument_list|(
name|speculativeTaskCount
argument_list|)
operator|/
name|numTasks
operator|)
operator|>=
name|speculativeCap
operator|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"SpeculativeCap is "
operator|+
name|speculativeCap
operator|+
literal|", specTasks/numTasks is "
operator|+
operator|(
call|(
name|float
call|)
argument_list|(
name|speculativeTaskCount
argument_list|)
operator|/
name|numTasks
operator|)
operator|+
literal|", so atSpecCap() is returning "
operator|+
name|atCap
argument_list|)
expr_stmt|;
block|}
return|return
name|atCap
return|;
block|}
comment|/**    * A class for comparing the estimated time to completion of two tasks    */
DECL|class|EstimatedTimeLeftComparator
specifier|private
specifier|static
class|class
name|EstimatedTimeLeftComparator
implements|implements
name|Comparator
argument_list|<
name|TaskInProgress
argument_list|>
block|{
DECL|field|time
specifier|private
name|long
name|time
decl_stmt|;
DECL|method|EstimatedTimeLeftComparator (long now)
specifier|public
name|EstimatedTimeLeftComparator
parameter_list|(
name|long
name|now
parameter_list|)
block|{
name|this
operator|.
name|time
operator|=
name|now
expr_stmt|;
block|}
comment|/**      * Estimated time to completion is measured as:      *   % of task left to complete (1 - progress) / progress rate of the task.      *       * This assumes that tasks are linear in their progress, which is       * often wrong, especially since progress for reducers is currently      * calculated by evenly weighting their three stages (shuffle, sort, map)      * which rarely account for 1/3 each. This should be fixed in the future      * by calculating progressRate more intelligently or splitting these      * multi-phase tasks into individual tasks.      *       * The ordering this comparator defines is: task1< task2 if task1 is      * estimated to finish farther in the future => compare(t1,t2) returns -1      */
DECL|method|compare (TaskInProgress tip1, TaskInProgress tip2)
specifier|public
name|int
name|compare
parameter_list|(
name|TaskInProgress
name|tip1
parameter_list|,
name|TaskInProgress
name|tip2
parameter_list|)
block|{
comment|//we have to use the Math.max in the denominator to avoid divide by zero
comment|//error because prog and progRate can both be zero (if one is zero,
comment|//the other one will be 0 too).
comment|//We use inverse of time_reminaing=[(1- prog) / progRate]
comment|//so that (1-prog) is in denom. because tasks can have arbitrarily
comment|//low progRates in practice (e.g. a task that is half done after 1000
comment|//seconds will have progRate of 0.0000005) so we would rather
comment|//use Math.maxnon (1-prog) by putting it in the denominator
comment|//which will cause tasks with prog=1 look 99.99% done instead of 100%
comment|//which is okay
name|double
name|t1
init|=
name|tip1
operator|.
name|getCurrentProgressRate
argument_list|(
name|time
argument_list|)
operator|/
name|Math
operator|.
name|max
argument_list|(
literal|0.0001
argument_list|,
literal|1.0
operator|-
name|tip1
operator|.
name|getProgress
argument_list|()
argument_list|)
decl_stmt|;
name|double
name|t2
init|=
name|tip2
operator|.
name|getCurrentProgressRate
argument_list|(
name|time
argument_list|)
operator|/
name|Math
operator|.
name|max
argument_list|(
literal|0.0001
argument_list|,
literal|1.0
operator|-
name|tip2
operator|.
name|getProgress
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|t1
operator|<
name|t2
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|t2
operator|<
name|t1
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
block|}
comment|/**    * Compares the ave progressRate of tasks that have finished on this     * taskTracker to the ave of all succesfull tasks thus far to see if this     * TT one is too slow for speculating.    * slowNodeThreshold is used to determine the number of standard deviations    * @param taskTracker the name of the TaskTracker we are checking    * @return is this TaskTracker slow    */
DECL|method|isSlowTracker (String taskTracker)
specifier|protected
name|boolean
name|isSlowTracker
parameter_list|(
name|String
name|taskTracker
parameter_list|)
block|{
if|if
condition|(
name|trackerMapStats
operator|.
name|get
argument_list|(
name|taskTracker
argument_list|)
operator|!=
literal|null
operator|&&
name|trackerMapStats
operator|.
name|get
argument_list|(
name|taskTracker
argument_list|)
operator|.
name|mean
argument_list|()
operator|-
name|mapTaskStats
operator|.
name|mean
argument_list|()
operator|>
name|mapTaskStats
operator|.
name|std
argument_list|()
operator|*
name|slowNodeThreshold
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Tracker "
operator|+
name|taskTracker
operator|+
literal|" declared slow. trackerMapStats.get(taskTracker).mean() :"
operator|+
name|trackerMapStats
operator|.
name|get
argument_list|(
name|taskTracker
argument_list|)
operator|.
name|mean
argument_list|()
operator|+
literal|" mapTaskStats :"
operator|+
name|mapTaskStats
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
if|if
condition|(
name|trackerReduceStats
operator|.
name|get
argument_list|(
name|taskTracker
argument_list|)
operator|!=
literal|null
operator|&&
name|trackerReduceStats
operator|.
name|get
argument_list|(
name|taskTracker
argument_list|)
operator|.
name|mean
argument_list|()
operator|-
name|reduceTaskStats
operator|.
name|mean
argument_list|()
operator|>
name|reduceTaskStats
operator|.
name|std
argument_list|()
operator|*
name|slowNodeThreshold
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Tracker "
operator|+
name|taskTracker
operator|+
literal|" declared slow. trackerReduceStats.get(taskTracker).mean() :"
operator|+
name|trackerReduceStats
operator|.
name|get
argument_list|(
name|taskTracker
argument_list|)
operator|.
name|mean
argument_list|()
operator|+
literal|" reduceTaskStats :"
operator|+
name|reduceTaskStats
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|class|DataStatistics
specifier|static
class|class
name|DataStatistics
block|{
DECL|field|count
specifier|private
name|int
name|count
init|=
literal|0
decl_stmt|;
DECL|field|sum
specifier|private
name|double
name|sum
init|=
literal|0
decl_stmt|;
DECL|field|sumSquares
specifier|private
name|double
name|sumSquares
init|=
literal|0
decl_stmt|;
DECL|method|DataStatistics ()
specifier|public
name|DataStatistics
parameter_list|()
block|{     }
DECL|method|DataStatistics (double initNum)
specifier|public
name|DataStatistics
parameter_list|(
name|double
name|initNum
parameter_list|)
block|{
name|this
operator|.
name|count
operator|=
literal|1
expr_stmt|;
name|this
operator|.
name|sum
operator|=
name|initNum
expr_stmt|;
name|this
operator|.
name|sumSquares
operator|=
name|initNum
operator|*
name|initNum
expr_stmt|;
block|}
DECL|method|add (double newNum)
specifier|public
name|void
name|add
parameter_list|(
name|double
name|newNum
parameter_list|)
block|{
name|this
operator|.
name|count
operator|++
expr_stmt|;
name|this
operator|.
name|sum
operator|+=
name|newNum
expr_stmt|;
name|this
operator|.
name|sumSquares
operator|+=
name|newNum
operator|*
name|newNum
expr_stmt|;
block|}
DECL|method|updateStatistics (double old, double update)
specifier|public
name|void
name|updateStatistics
parameter_list|(
name|double
name|old
parameter_list|,
name|double
name|update
parameter_list|)
block|{
name|sub
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|update
argument_list|)
expr_stmt|;
block|}
DECL|method|sub (double oldNum)
specifier|private
name|void
name|sub
parameter_list|(
name|double
name|oldNum
parameter_list|)
block|{
name|this
operator|.
name|count
operator|--
expr_stmt|;
name|this
operator|.
name|sum
operator|=
name|Math
operator|.
name|max
argument_list|(
name|this
operator|.
name|sum
operator|-=
name|oldNum
argument_list|,
literal|0.0d
argument_list|)
expr_stmt|;
name|this
operator|.
name|sumSquares
operator|=
name|Math
operator|.
name|max
argument_list|(
name|this
operator|.
name|sumSquares
operator|-=
name|oldNum
operator|*
name|oldNum
argument_list|,
literal|0.0d
argument_list|)
expr_stmt|;
block|}
DECL|method|mean ()
specifier|public
name|double
name|mean
parameter_list|()
block|{
return|return
name|sum
operator|/
name|count
return|;
block|}
DECL|method|var ()
specifier|public
name|double
name|var
parameter_list|()
block|{
comment|// E(X^2) - E(X)^2
return|return
name|Math
operator|.
name|max
argument_list|(
operator|(
name|sumSquares
operator|/
name|count
operator|)
operator|-
name|mean
argument_list|()
operator|*
name|mean
argument_list|()
argument_list|,
literal|0.0d
argument_list|)
return|;
block|}
DECL|method|std ()
specifier|public
name|double
name|std
parameter_list|()
block|{
return|return
name|Math
operator|.
name|sqrt
argument_list|(
name|this
operator|.
name|var
argument_list|()
argument_list|)
return|;
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"DataStatistics: count is "
operator|+
name|count
operator|+
literal|", sum is "
operator|+
name|sum
operator|+
literal|", sumSquares is "
operator|+
name|sumSquares
operator|+
literal|" mean is "
operator|+
name|mean
argument_list|()
operator|+
literal|" std() is "
operator|+
name|std
argument_list|()
return|;
block|}
block|}
DECL|method|shouldRunOnTaskTracker (String taskTracker)
specifier|private
name|boolean
name|shouldRunOnTaskTracker
parameter_list|(
name|String
name|taskTracker
parameter_list|)
block|{
comment|//
comment|// Check if too many tasks of this job have failed on this
comment|// tasktracker prior to assigning it a new one.
comment|//
name|int
name|taskTrackerFailedTasks
init|=
name|getTrackerTaskFailures
argument_list|(
name|taskTracker
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|flakyTaskTrackers
operator|<
operator|(
name|clusterSize
operator|*
name|CLUSTER_BLACKLIST_PERCENT
operator|)
operator|)
operator|&&
name|taskTrackerFailedTasks
operator|>=
name|maxTaskFailuresPerTracker
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|String
name|flakyTracker
init|=
name|convertTrackerNameToHostName
argument_list|(
name|taskTracker
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ignoring the black-listed tasktracker: '"
operator|+
name|flakyTracker
operator|+
literal|"' for assigning a new task"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Metering: Occupied Slots * (Finish - Start)    * @param tip {@link TaskInProgress} to be metered which just completed,     *            cannot be<code>null</code>     * @param status {@link TaskStatus} of the completed task, cannot be     *<code>null</code>    */
DECL|method|meterTaskAttempt (TaskInProgress tip, TaskStatus status)
specifier|private
name|void
name|meterTaskAttempt
parameter_list|(
name|TaskInProgress
name|tip
parameter_list|,
name|TaskStatus
name|status
parameter_list|)
block|{
name|JobCounter
name|slotCounter
init|=
operator|(
name|tip
operator|.
name|isMapTask
argument_list|()
operator|)
condition|?
name|JobCounter
operator|.
name|SLOTS_MILLIS_MAPS
else|:
name|JobCounter
operator|.
name|SLOTS_MILLIS_REDUCES
decl_stmt|;
name|jobCounters
operator|.
name|incrCounter
argument_list|(
name|slotCounter
argument_list|,
name|tip
operator|.
name|getNumSlotsRequired
argument_list|()
operator|*
operator|(
name|status
operator|.
name|getFinishTime
argument_list|()
operator|-
name|status
operator|.
name|getStartTime
argument_list|()
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * A taskid assigned to this JobInProgress has reported in successfully.    */
DECL|method|completedTask (TaskInProgress tip, TaskStatus status)
specifier|public
specifier|synchronized
name|boolean
name|completedTask
parameter_list|(
name|TaskInProgress
name|tip
parameter_list|,
name|TaskStatus
name|status
parameter_list|)
block|{
name|TaskAttemptID
name|taskid
init|=
name|status
operator|.
name|getTaskID
argument_list|()
decl_stmt|;
specifier|final
name|JobTrackerInstrumentation
name|metrics
init|=
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
decl_stmt|;
comment|// Metering
name|meterTaskAttempt
argument_list|(
name|tip
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|// Sanity check: is the TIP already complete?
comment|// This would not happen,
comment|// because no two tasks are SUCCEEDED at the same time.
if|if
condition|(
name|tip
operator|.
name|isComplete
argument_list|()
condition|)
block|{
comment|// Mark this task as KILLED
name|tip
operator|.
name|alreadyCompletedTask
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
comment|// Let the JobTracker cleanup this taskid if the job isn't running
if|if
condition|(
name|this
operator|.
name|status
operator|.
name|getRunState
argument_list|()
operator|!=
name|JobStatus
operator|.
name|RUNNING
condition|)
block|{
name|jobtracker
operator|.
name|markCompletedTaskAttempt
argument_list|(
name|status
operator|.
name|getTaskTracker
argument_list|()
argument_list|,
name|taskid
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
name|boolean
name|wasSpeculating
init|=
name|tip
operator|.
name|isSpeculating
argument_list|()
decl_stmt|;
comment|//store this fact
name|LOG
operator|.
name|info
argument_list|(
literal|"Task '"
operator|+
name|taskid
operator|+
literal|"' has completed "
operator|+
name|tip
operator|.
name|getTIPId
argument_list|()
operator|+
literal|" successfully."
argument_list|)
expr_stmt|;
comment|// Mark the TIP as complete
name|tip
operator|.
name|completed
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
name|resourceEstimator
operator|.
name|updateWithCompletedTask
argument_list|(
name|status
argument_list|,
name|tip
argument_list|)
expr_stmt|;
comment|// Update jobhistory
name|TaskTrackerStatus
name|ttStatus
init|=
name|this
operator|.
name|jobtracker
operator|.
name|getTaskTrackerStatus
argument_list|(
name|status
operator|.
name|getTaskTracker
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|trackerHostname
init|=
name|jobtracker
operator|.
name|getNode
argument_list|(
name|ttStatus
operator|.
name|getHost
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
name|TaskType
name|taskType
init|=
name|getTaskType
argument_list|(
name|tip
argument_list|)
decl_stmt|;
name|TaskAttemptStartedEvent
name|tse
init|=
operator|new
name|TaskAttemptStartedEvent
argument_list|(
name|status
operator|.
name|getTaskID
argument_list|()
argument_list|,
name|taskType
argument_list|,
name|status
operator|.
name|getStartTime
argument_list|()
argument_list|,
name|status
operator|.
name|getTaskTracker
argument_list|()
argument_list|,
name|ttStatus
operator|.
name|getHttpPort
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|jobHistory
operator|.
name|logEvent
argument_list|(
name|tse
argument_list|,
name|status
operator|.
name|getTaskID
argument_list|()
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|TaskAttemptID
name|statusAttemptID
init|=
name|status
operator|.
name|getTaskID
argument_list|()
decl_stmt|;
if|if
condition|(
name|status
operator|.
name|getIsMap
argument_list|()
condition|)
block|{
name|MapAttemptFinishedEvent
name|mfe
init|=
operator|new
name|MapAttemptFinishedEvent
argument_list|(
name|statusAttemptID
argument_list|,
name|taskType
argument_list|,
name|TaskStatus
operator|.
name|State
operator|.
name|SUCCEEDED
operator|.
name|toString
argument_list|()
argument_list|,
name|status
operator|.
name|getMapFinishTime
argument_list|()
argument_list|,
name|status
operator|.
name|getFinishTime
argument_list|()
argument_list|,
name|trackerHostname
argument_list|,
operator|-
literal|1
argument_list|,
literal|""
argument_list|,
name|status
operator|.
name|getStateString
argument_list|()
argument_list|,
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Counters
argument_list|(
name|status
operator|.
name|getCounters
argument_list|()
argument_list|)
argument_list|,
name|tip
operator|.
name|getSplits
argument_list|(
name|statusAttemptID
argument_list|)
operator|.
name|burst
argument_list|()
argument_list|)
decl_stmt|;
name|jobHistory
operator|.
name|logEvent
argument_list|(
name|mfe
argument_list|,
name|status
operator|.
name|getTaskID
argument_list|()
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ReduceAttemptFinishedEvent
name|rfe
init|=
operator|new
name|ReduceAttemptFinishedEvent
argument_list|(
name|statusAttemptID
argument_list|,
name|taskType
argument_list|,
name|TaskStatus
operator|.
name|State
operator|.
name|SUCCEEDED
operator|.
name|toString
argument_list|()
argument_list|,
name|status
operator|.
name|getShuffleFinishTime
argument_list|()
argument_list|,
name|status
operator|.
name|getSortFinishTime
argument_list|()
argument_list|,
name|status
operator|.
name|getFinishTime
argument_list|()
argument_list|,
name|trackerHostname
argument_list|,
operator|-
literal|1
argument_list|,
literal|""
argument_list|,
name|status
operator|.
name|getStateString
argument_list|()
argument_list|,
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Counters
argument_list|(
name|status
operator|.
name|getCounters
argument_list|()
argument_list|)
argument_list|,
name|tip
operator|.
name|getSplits
argument_list|(
name|statusAttemptID
argument_list|)
operator|.
name|burst
argument_list|()
argument_list|)
decl_stmt|;
name|jobHistory
operator|.
name|logEvent
argument_list|(
name|rfe
argument_list|,
name|status
operator|.
name|getTaskID
argument_list|()
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|TaskFinishedEvent
name|tfe
init|=
operator|new
name|TaskFinishedEvent
argument_list|(
name|tip
operator|.
name|getTIPId
argument_list|()
argument_list|,
name|tip
operator|.
name|getExecFinishTime
argument_list|()
argument_list|,
name|taskType
argument_list|,
name|TaskStatus
operator|.
name|State
operator|.
name|SUCCEEDED
operator|.
name|toString
argument_list|()
argument_list|,
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Counters
argument_list|(
name|status
operator|.
name|getCounters
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|jobHistory
operator|.
name|logEvent
argument_list|(
name|tfe
argument_list|,
name|tip
operator|.
name|getJob
argument_list|()
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|tip
operator|.
name|isJobSetupTask
argument_list|()
condition|)
block|{
comment|// setup task has finished. kill the extra setup tip
name|killSetupTip
argument_list|(
operator|!
name|tip
operator|.
name|isMapTask
argument_list|()
argument_list|)
expr_stmt|;
name|setupComplete
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tip
operator|.
name|isJobCleanupTask
argument_list|()
condition|)
block|{
comment|// cleanup task has finished. Kill the extra cleanup tip
if|if
condition|(
name|tip
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
comment|// kill the reduce tip
name|cleanup
index|[
literal|1
index|]
operator|.
name|kill
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|cleanup
index|[
literal|0
index|]
operator|.
name|kill
argument_list|()
expr_stmt|;
block|}
comment|//
comment|// The Job is done
comment|// if the job is failed, then mark the job failed.
if|if
condition|(
name|jobFailed
condition|)
block|{
name|terminateJob
argument_list|(
name|JobStatus
operator|.
name|FAILED
argument_list|)
expr_stmt|;
block|}
comment|// if the job is killed, then mark the job killed.
if|if
condition|(
name|jobKilled
condition|)
block|{
name|terminateJob
argument_list|(
name|JobStatus
operator|.
name|KILLED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|jobComplete
argument_list|()
expr_stmt|;
block|}
comment|// The job has been killed/failed/successful
comment|// JobTracker should cleanup this task
name|jobtracker
operator|.
name|markCompletedTaskAttempt
argument_list|(
name|status
operator|.
name|getTaskTracker
argument_list|()
argument_list|,
name|taskid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tip
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
name|runningMapTasks
operator|-=
literal|1
expr_stmt|;
name|finishedMapTasks
operator|+=
literal|1
expr_stmt|;
name|metrics
operator|.
name|completeMap
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tip
operator|.
name|isJobSetupTask
argument_list|()
operator|&&
name|hasSpeculativeMaps
condition|)
block|{
name|updateTaskTrackerStats
argument_list|(
name|tip
argument_list|,
name|ttStatus
argument_list|,
name|trackerMapStats
argument_list|,
name|mapTaskStats
argument_list|)
expr_stmt|;
block|}
comment|// remove the completed map from the resp running caches
name|retireMap
argument_list|(
name|tip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|finishedMapTasks
operator|+
name|failedMapTIPs
operator|)
operator|==
operator|(
name|numMapTasks
operator|)
condition|)
block|{
name|this
operator|.
name|status
operator|.
name|setMapProgress
argument_list|(
literal|1.0f
argument_list|)
expr_stmt|;
if|if
condition|(
name|canLaunchJobCleanupTask
argument_list|()
condition|)
block|{
name|checkCountersLimitsOrFail
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|runningReduceTasks
operator|-=
literal|1
expr_stmt|;
name|finishedReduceTasks
operator|+=
literal|1
expr_stmt|;
name|metrics
operator|.
name|completeReduce
argument_list|(
name|taskid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tip
operator|.
name|isJobSetupTask
argument_list|()
operator|&&
name|hasSpeculativeReduces
condition|)
block|{
name|updateTaskTrackerStats
argument_list|(
name|tip
argument_list|,
name|ttStatus
argument_list|,
name|trackerReduceStats
argument_list|,
name|reduceTaskStats
argument_list|)
expr_stmt|;
block|}
comment|// remove the completed reduces from the running reducers set
name|retireReduce
argument_list|(
name|tip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|finishedReduceTasks
operator|+
name|failedReduceTIPs
operator|)
operator|==
operator|(
name|numReduceTasks
operator|)
condition|)
block|{
name|this
operator|.
name|status
operator|.
name|setReduceProgress
argument_list|(
literal|1.0f
argument_list|)
expr_stmt|;
if|if
condition|(
name|canLaunchJobCleanupTask
argument_list|()
condition|)
block|{
name|checkCountersLimitsOrFail
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|decrementSpeculativeCount
argument_list|(
name|wasSpeculating
argument_list|,
name|tip
argument_list|)
expr_stmt|;
comment|// is job complete?
if|if
condition|(
operator|!
name|jobSetupCleanupNeeded
operator|&&
name|canLaunchJobCleanupTask
argument_list|()
condition|)
block|{
name|jobComplete
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/*    * add up the counters and fail the job if it exceeds the limits.    * Make sure we do not recalculate the counters after we fail the job.    * Currently this is taken care by terminateJob() since it does not    * calculate the counters.    */
DECL|method|checkCountersLimitsOrFail ()
specifier|private
name|void
name|checkCountersLimitsOrFail
parameter_list|()
block|{
name|Counters
name|counters
init|=
name|getCounters
argument_list|()
decl_stmt|;
if|if
condition|(
name|counters
operator|.
name|limits
argument_list|()
operator|.
name|violation
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|jobtracker
operator|.
name|failJob
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|updateTaskTrackerStats (TaskInProgress tip, TaskTrackerStatus ttStatus, Map<String,DataStatistics> trackerStats, DataStatistics overallStats)
specifier|private
name|void
name|updateTaskTrackerStats
parameter_list|(
name|TaskInProgress
name|tip
parameter_list|,
name|TaskTrackerStatus
name|ttStatus
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|DataStatistics
argument_list|>
name|trackerStats
parameter_list|,
name|DataStatistics
name|overallStats
parameter_list|)
block|{
name|float
name|tipDuration
init|=
name|tip
operator|.
name|getExecFinishTime
argument_list|()
operator|-
name|tip
operator|.
name|getDispatchTime
argument_list|(
name|tip
operator|.
name|getSuccessfulTaskid
argument_list|()
argument_list|)
decl_stmt|;
name|DataStatistics
name|ttStats
init|=
name|trackerStats
operator|.
name|get
argument_list|(
name|ttStatus
operator|.
name|getTrackerName
argument_list|()
argument_list|)
decl_stmt|;
name|double
name|oldMean
init|=
literal|0.0d
decl_stmt|;
comment|//We maintain the mean of TaskTrackers' means. That way, we get a single
comment|//data-point for every tracker (used in the evaluation in isSlowTracker)
if|if
condition|(
name|ttStats
operator|!=
literal|null
condition|)
block|{
name|oldMean
operator|=
name|ttStats
operator|.
name|mean
argument_list|()
expr_stmt|;
name|ttStats
operator|.
name|add
argument_list|(
name|tipDuration
argument_list|)
expr_stmt|;
name|overallStats
operator|.
name|updateStatistics
argument_list|(
name|oldMean
argument_list|,
name|ttStats
operator|.
name|mean
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|trackerStats
operator|.
name|put
argument_list|(
name|ttStatus
operator|.
name|getTrackerName
argument_list|()
argument_list|,
operator|(
name|ttStats
operator|=
operator|new
name|DataStatistics
argument_list|(
name|tipDuration
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|overallStats
operator|.
name|add
argument_list|(
name|tipDuration
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Added mean of "
operator|+
name|ttStats
operator|.
name|mean
argument_list|()
operator|+
literal|" to trackerStats of type "
operator|+
operator|(
name|tip
operator|.
name|isMapTask
argument_list|()
condition|?
literal|"Map"
else|:
literal|"Reduce"
operator|)
operator|+
literal|" on "
operator|+
name|ttStatus
operator|.
name|getTrackerName
argument_list|()
operator|+
literal|". DataStatistics is now: "
operator|+
name|trackerStats
operator|.
name|get
argument_list|(
name|ttStatus
operator|.
name|getTrackerName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|updateStatistics (double oldProg, double newProg, boolean isMap)
specifier|public
name|void
name|updateStatistics
parameter_list|(
name|double
name|oldProg
parameter_list|,
name|double
name|newProg
parameter_list|,
name|boolean
name|isMap
parameter_list|)
block|{
if|if
condition|(
name|isMap
condition|)
block|{
name|runningMapTaskStats
operator|.
name|updateStatistics
argument_list|(
name|oldProg
argument_list|,
name|newProg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|runningReduceTaskStats
operator|.
name|updateStatistics
argument_list|(
name|oldProg
argument_list|,
name|newProg
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getRunningTaskStatistics (boolean isMap)
specifier|public
name|DataStatistics
name|getRunningTaskStatistics
parameter_list|(
name|boolean
name|isMap
parameter_list|)
block|{
if|if
condition|(
name|isMap
condition|)
block|{
return|return
name|runningMapTaskStats
return|;
block|}
else|else
block|{
return|return
name|runningReduceTaskStats
return|;
block|}
block|}
DECL|method|getSlowTaskThreshold ()
specifier|public
name|float
name|getSlowTaskThreshold
parameter_list|()
block|{
return|return
name|slowTaskThreshold
return|;
block|}
comment|/**    * Job state change must happen thru this call    */
DECL|method|changeStateTo (int newState)
specifier|private
name|void
name|changeStateTo
parameter_list|(
name|int
name|newState
parameter_list|)
block|{
name|int
name|oldState
init|=
name|this
operator|.
name|status
operator|.
name|getRunState
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldState
operator|==
name|newState
condition|)
block|{
return|return;
comment|//old and new states are same
block|}
name|this
operator|.
name|status
operator|.
name|setRunState
argument_list|(
name|newState
argument_list|)
expr_stmt|;
comment|//update the metrics
if|if
condition|(
name|oldState
operator|==
name|JobStatus
operator|.
name|PREP
condition|)
block|{
name|this
operator|.
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|decPrepJob
argument_list|(
name|conf
argument_list|,
name|jobId
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldState
operator|==
name|JobStatus
operator|.
name|RUNNING
condition|)
block|{
name|this
operator|.
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|decRunningJob
argument_list|(
name|conf
argument_list|,
name|jobId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newState
operator|==
name|JobStatus
operator|.
name|PREP
condition|)
block|{
name|this
operator|.
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|addPrepJob
argument_list|(
name|conf
argument_list|,
name|jobId
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newState
operator|==
name|JobStatus
operator|.
name|RUNNING
condition|)
block|{
name|this
operator|.
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|addRunningJob
argument_list|(
name|conf
argument_list|,
name|jobId
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * The job is done since all it's component tasks are either    * successful or have failed.    */
DECL|method|jobComplete ()
specifier|private
name|void
name|jobComplete
parameter_list|()
block|{
specifier|final
name|JobTrackerInstrumentation
name|metrics
init|=
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
decl_stmt|;
comment|//
comment|// All tasks are complete, then the job is done!
comment|//
if|if
condition|(
name|this
operator|.
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|JobStatus
operator|.
name|RUNNING
operator|||
name|this
operator|.
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|JobStatus
operator|.
name|PREP
condition|)
block|{
name|changeStateTo
argument_list|(
name|JobStatus
operator|.
name|SUCCEEDED
argument_list|)
expr_stmt|;
name|this
operator|.
name|status
operator|.
name|setCleanupProgress
argument_list|(
literal|1.0f
argument_list|)
expr_stmt|;
if|if
condition|(
name|maps
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|status
operator|.
name|setMapProgress
argument_list|(
literal|1.0f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reduces
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|status
operator|.
name|setReduceProgress
argument_list|(
literal|1.0f
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|finishTime
operator|=
name|JobTracker
operator|.
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
expr_stmt|;
name|this
operator|.
name|status
operator|.
name|setFinishTime
argument_list|(
name|this
operator|.
name|finishTime
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Job "
operator|+
name|this
operator|.
name|status
operator|.
name|getJobID
argument_list|()
operator|+
literal|" has completed successfully."
argument_list|)
expr_stmt|;
comment|// Log the job summary (this should be done prior to logging to
comment|// job-history to ensure job-counters are in-sync
name|JobSummary
operator|.
name|logJobSummary
argument_list|(
name|this
argument_list|,
name|jobtracker
operator|.
name|getClusterStatus
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// Log job-history
name|JobFinishedEvent
name|jfe
init|=
operator|new
name|JobFinishedEvent
argument_list|(
name|this
operator|.
name|status
operator|.
name|getJobID
argument_list|()
argument_list|,
name|this
operator|.
name|finishTime
argument_list|,
name|this
operator|.
name|finishedMapTasks
argument_list|,
name|this
operator|.
name|finishedReduceTasks
argument_list|,
name|failedMapTasks
argument_list|,
name|failedReduceTasks
argument_list|,
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Counters
argument_list|(
name|getMapCounters
argument_list|()
argument_list|)
argument_list|,
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Counters
argument_list|(
name|getReduceCounters
argument_list|()
argument_list|)
argument_list|,
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|Counters
argument_list|(
name|getCounters
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|jobHistory
operator|.
name|logEvent
argument_list|(
name|jfe
argument_list|,
name|this
operator|.
name|status
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|jobHistory
operator|.
name|closeWriter
argument_list|(
name|this
operator|.
name|status
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
comment|// Note that finalize will close the job history handles which garbage collect
comment|// might try to finalize
name|garbageCollect
argument_list|()
expr_stmt|;
name|metrics
operator|.
name|completeJob
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|this
operator|.
name|status
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|terminateJob (int jobTerminationState)
specifier|private
specifier|synchronized
name|void
name|terminateJob
parameter_list|(
name|int
name|jobTerminationState
parameter_list|)
block|{
if|if
condition|(
operator|(
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|JobStatus
operator|.
name|RUNNING
operator|)
operator|||
operator|(
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|JobStatus
operator|.
name|PREP
operator|)
condition|)
block|{
name|this
operator|.
name|finishTime
operator|=
name|JobTracker
operator|.
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
expr_stmt|;
name|this
operator|.
name|status
operator|.
name|setMapProgress
argument_list|(
literal|1.0f
argument_list|)
expr_stmt|;
name|this
operator|.
name|status
operator|.
name|setReduceProgress
argument_list|(
literal|1.0f
argument_list|)
expr_stmt|;
name|this
operator|.
name|status
operator|.
name|setCleanupProgress
argument_list|(
literal|1.0f
argument_list|)
expr_stmt|;
name|this
operator|.
name|status
operator|.
name|setFinishTime
argument_list|(
name|this
operator|.
name|finishTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|jobTerminationState
operator|==
name|JobStatus
operator|.
name|FAILED
condition|)
block|{
name|changeStateTo
argument_list|(
name|JobStatus
operator|.
name|FAILED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|changeStateTo
argument_list|(
name|JobStatus
operator|.
name|KILLED
argument_list|)
expr_stmt|;
block|}
comment|// Log the job summary
name|JobSummary
operator|.
name|logJobSummary
argument_list|(
name|this
argument_list|,
name|jobtracker
operator|.
name|getClusterStatus
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
name|JobUnsuccessfulCompletionEvent
name|failedEvent
init|=
operator|new
name|JobUnsuccessfulCompletionEvent
argument_list|(
name|this
operator|.
name|status
operator|.
name|getJobID
argument_list|()
argument_list|,
name|finishTime
argument_list|,
name|this
operator|.
name|finishedMapTasks
argument_list|,
name|this
operator|.
name|finishedReduceTasks
argument_list|,
name|JobStatus
operator|.
name|getJobRunState
argument_list|(
name|jobTerminationState
argument_list|)
argument_list|)
decl_stmt|;
name|jobHistory
operator|.
name|logEvent
argument_list|(
name|failedEvent
argument_list|,
name|this
operator|.
name|status
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|jobHistory
operator|.
name|closeWriter
argument_list|(
name|this
operator|.
name|status
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|garbageCollect
argument_list|()
expr_stmt|;
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|terminateJob
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|this
operator|.
name|status
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|jobTerminationState
operator|==
name|JobStatus
operator|.
name|FAILED
condition|)
block|{
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|failedJob
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|this
operator|.
name|status
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|killedJob
argument_list|(
name|this
operator|.
name|conf
argument_list|,
name|this
operator|.
name|status
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Terminate the job and all its component tasks.    * Calling this will lead to marking the job as failed/killed. Cleanup     * tip will be launched. If the job has not inited, it will directly call     * terminateJob as there is no need to launch cleanup tip.    * This method is reentrant.    * @param jobTerminationState job termination state    */
DECL|method|terminate (int jobTerminationState)
specifier|private
specifier|synchronized
name|void
name|terminate
parameter_list|(
name|int
name|jobTerminationState
parameter_list|)
block|{
if|if
condition|(
operator|!
name|tasksInited
operator|.
name|get
argument_list|()
condition|)
block|{
comment|//init could not be done, we just terminate directly.
name|terminateJob
argument_list|(
name|jobTerminationState
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|JobStatus
operator|.
name|RUNNING
operator|)
operator|||
operator|(
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|JobStatus
operator|.
name|PREP
operator|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Killing job '"
operator|+
name|this
operator|.
name|status
operator|.
name|getJobID
argument_list|()
operator|+
literal|"'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|jobTerminationState
operator|==
name|JobStatus
operator|.
name|FAILED
condition|)
block|{
if|if
condition|(
name|jobFailed
condition|)
block|{
comment|//reentrant
return|return;
block|}
name|jobFailed
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jobTerminationState
operator|==
name|JobStatus
operator|.
name|KILLED
condition|)
block|{
if|if
condition|(
name|jobKilled
condition|)
block|{
comment|//reentrant
return|return;
block|}
name|jobKilled
operator|=
literal|true
expr_stmt|;
block|}
comment|// clear all unclean tasks
name|clearUncleanTasks
argument_list|()
expr_stmt|;
comment|//
comment|// kill all TIPs.
comment|//
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|setup
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|setup
index|[
name|i
index|]
operator|.
name|kill
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maps
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|maps
index|[
name|i
index|]
operator|.
name|kill
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|reduces
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|reduces
index|[
name|i
index|]
operator|.
name|kill
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|jobSetupCleanupNeeded
condition|)
block|{
name|terminateJob
argument_list|(
name|jobTerminationState
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Cancel all reservations since the job is done    */
DECL|method|cancelReservedSlots ()
specifier|private
name|void
name|cancelReservedSlots
parameter_list|()
block|{
comment|// Make a copy of the set of TaskTrackers to prevent a
comment|// ConcurrentModificationException ...
name|Set
argument_list|<
name|TaskTracker
argument_list|>
name|tm
init|=
operator|new
name|HashSet
argument_list|<
name|TaskTracker
argument_list|>
argument_list|(
name|trackersReservedForMaps
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|TaskTracker
name|tt
range|:
name|tm
control|)
block|{
name|tt
operator|.
name|unreserveSlots
argument_list|(
name|TaskType
operator|.
name|MAP
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|TaskTracker
argument_list|>
name|tr
init|=
operator|new
name|HashSet
argument_list|<
name|TaskTracker
argument_list|>
argument_list|(
name|trackersReservedForReduces
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|TaskTracker
name|tt
range|:
name|tr
control|)
block|{
name|tt
operator|.
name|unreserveSlots
argument_list|(
name|TaskType
operator|.
name|REDUCE
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|clearUncleanTasks ()
specifier|private
name|void
name|clearUncleanTasks
parameter_list|()
block|{
name|TaskAttemptID
name|taskid
init|=
literal|null
decl_stmt|;
name|TaskInProgress
name|tip
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|!
name|mapCleanupTasks
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|taskid
operator|=
name|mapCleanupTasks
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tip
operator|=
name|maps
index|[
name|taskid
operator|.
name|getTaskID
argument_list|()
operator|.
name|getId
argument_list|()
index|]
expr_stmt|;
name|updateTaskStatus
argument_list|(
name|tip
argument_list|,
name|tip
operator|.
name|getTaskStatus
argument_list|(
name|taskid
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|reduceCleanupTasks
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|taskid
operator|=
name|reduceCleanupTasks
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tip
operator|=
name|reduces
index|[
name|taskid
operator|.
name|getTaskID
argument_list|()
operator|.
name|getId
argument_list|()
index|]
expr_stmt|;
name|updateTaskStatus
argument_list|(
name|tip
argument_list|,
name|tip
operator|.
name|getTaskStatus
argument_list|(
name|taskid
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Kill the job and all its component tasks. This method should be called from     * jobtracker and should return fast as it locks the jobtracker.    */
DECL|method|kill ()
specifier|public
name|void
name|kill
parameter_list|()
block|{
name|boolean
name|killNow
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|jobInitKillStatus
init|)
block|{
name|jobInitKillStatus
operator|.
name|killed
operator|=
literal|true
expr_stmt|;
comment|//if not in middle of init, terminate it now
if|if
condition|(
operator|!
name|jobInitKillStatus
operator|.
name|initStarted
operator|||
name|jobInitKillStatus
operator|.
name|initDone
condition|)
block|{
comment|//avoiding nested locking by setting flag
name|killNow
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|killNow
condition|)
block|{
name|terminate
argument_list|(
name|JobStatus
operator|.
name|KILLED
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Fails the job and all its component tasks. This should be called only from    * {@link JobInProgress} or {@link JobTracker}. Look at     * {@link JobTracker#failJob(JobInProgress)} for more details.    * Note that the job doesnt expect itself to be failed before its inited.     * Only when the init is done (successfully or otherwise), the job can be     * failed.     */
DECL|method|fail ()
specifier|synchronized
name|void
name|fail
parameter_list|()
block|{
name|terminate
argument_list|(
name|JobStatus
operator|.
name|FAILED
argument_list|)
expr_stmt|;
block|}
DECL|method|decrementSpeculativeCount (boolean wasSpeculating, TaskInProgress tip)
specifier|private
name|void
name|decrementSpeculativeCount
parameter_list|(
name|boolean
name|wasSpeculating
parameter_list|,
name|TaskInProgress
name|tip
parameter_list|)
block|{
if|if
condition|(
name|wasSpeculating
condition|)
block|{
if|if
condition|(
name|tip
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
name|speculativeMapTasks
operator|--
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Decremented count for "
operator|+
name|tip
operator|.
name|getTIPId
argument_list|()
operator|+
literal|"/"
operator|+
name|tip
operator|.
name|getJob
argument_list|()
operator|.
name|getJobID
argument_list|()
operator|+
literal|". Current speculativeMap task count: "
operator|+
name|speculativeMapTasks
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|speculativeReduceTasks
operator|--
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Decremented count for "
operator|+
name|tip
operator|.
name|getTIPId
argument_list|()
operator|+
literal|"/"
operator|+
name|tip
operator|.
name|getJob
argument_list|()
operator|.
name|getJobID
argument_list|()
operator|+
literal|". Current speculativeReduce task count: "
operator|+
name|speculativeReduceTasks
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * A task assigned to this JobInProgress has reported in as failed.    * Most of the time, we'll just reschedule execution.  However, after    * many repeated failures we may instead decide to allow the entire     * job to fail or succeed if the user doesn't care about a few tasks failing.    *    * Even if a task has reported as completed in the past, it might later    * be reported as failed.  That's because the TaskTracker that hosts a map    * task might die before the entire job can complete.  If that happens,    * we need to schedule reexecution so that downstream reduce tasks can     * obtain the map task's output.    */
DECL|method|failedTask (TaskInProgress tip, TaskAttemptID taskid, TaskStatus status, TaskTracker taskTracker, boolean wasRunning, boolean wasComplete, boolean wasAttemptRunning)
specifier|private
name|void
name|failedTask
parameter_list|(
name|TaskInProgress
name|tip
parameter_list|,
name|TaskAttemptID
name|taskid
parameter_list|,
name|TaskStatus
name|status
parameter_list|,
name|TaskTracker
name|taskTracker
parameter_list|,
name|boolean
name|wasRunning
parameter_list|,
name|boolean
name|wasComplete
parameter_list|,
name|boolean
name|wasAttemptRunning
parameter_list|)
block|{
comment|// check if the TIP is already failed
name|boolean
name|wasFailed
init|=
name|tip
operator|.
name|isFailed
argument_list|()
decl_stmt|;
name|boolean
name|wasSpeculating
init|=
name|tip
operator|.
name|isSpeculating
argument_list|()
decl_stmt|;
comment|// Mark the taskid as FAILED or KILLED
name|tip
operator|.
name|incompleteSubTask
argument_list|(
name|taskid
argument_list|,
name|this
operator|.
name|status
argument_list|)
expr_stmt|;
name|decrementSpeculativeCount
argument_list|(
name|wasSpeculating
argument_list|,
name|tip
argument_list|)
expr_stmt|;
name|boolean
name|isRunning
init|=
name|tip
operator|.
name|isRunning
argument_list|()
decl_stmt|;
name|boolean
name|isComplete
init|=
name|tip
operator|.
name|isComplete
argument_list|()
decl_stmt|;
if|if
condition|(
name|wasAttemptRunning
condition|)
block|{
comment|// We are decrementing counters without looking for isRunning ,
comment|// because we increment the counters when we obtain
comment|// new map task attempt or reduce task attempt.We do not really check
comment|// for tip being running.
comment|// Whenever we obtain new task attempt runningMapTasks incremented.
comment|// hence we are decrementing the same.
if|if
condition|(
operator|!
name|tip
operator|.
name|isJobCleanupTask
argument_list|()
operator|&&
operator|!
name|tip
operator|.
name|isJobSetupTask
argument_list|()
condition|)
block|{
if|if
condition|(
name|tip
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
name|runningMapTasks
operator|-=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|runningReduceTasks
operator|-=
literal|1
expr_stmt|;
block|}
block|}
comment|// Metering
name|meterTaskAttempt
argument_list|(
name|tip
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
comment|//update running  count on task failure.
if|if
condition|(
name|wasRunning
operator|&&
operator|!
name|isRunning
condition|)
block|{
if|if
condition|(
name|tip
operator|.
name|isJobCleanupTask
argument_list|()
condition|)
block|{
name|launchedCleanup
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tip
operator|.
name|isJobSetupTask
argument_list|()
condition|)
block|{
name|launchedSetup
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tip
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
comment|// remove from the running queue and put it in the non-running cache
comment|// if the tip is not complete i.e if the tip still needs to be run
if|if
condition|(
operator|!
name|isComplete
condition|)
block|{
name|retireMap
argument_list|(
name|tip
argument_list|)
expr_stmt|;
name|failMap
argument_list|(
name|tip
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// remove from the running queue and put in the failed queue if the tip
comment|// is not complete
if|if
condition|(
operator|!
name|isComplete
condition|)
block|{
name|retireReduce
argument_list|(
name|tip
argument_list|)
expr_stmt|;
name|failReduce
argument_list|(
name|tip
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// The case when the map was complete but the task tracker went down.
comment|// However, we don't need to do any metering here...
if|if
condition|(
name|wasComplete
operator|&&
operator|!
name|isComplete
condition|)
block|{
if|if
condition|(
name|tip
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
comment|// Put the task back in the cache. This will help locality for cases
comment|// where we have a different TaskTracker from the same rack/switch
comment|// asking for a task.
comment|// We bother about only those TIPs that were successful
comment|// earlier (wasComplete and !isComplete)
comment|// (since they might have been removed from the cache of other
comment|// racks/switches, if the input split blocks were present there too)
name|failMap
argument_list|(
name|tip
argument_list|)
expr_stmt|;
name|finishedMapTasks
operator|-=
literal|1
expr_stmt|;
block|}
block|}
comment|// update job history
comment|// get taskStatus from tip
name|TaskStatus
name|taskStatus
init|=
name|tip
operator|.
name|getTaskStatus
argument_list|(
name|taskid
argument_list|)
decl_stmt|;
name|String
name|taskTrackerName
init|=
name|taskStatus
operator|.
name|getTaskTracker
argument_list|()
decl_stmt|;
name|String
name|taskTrackerHostName
init|=
name|convertTrackerNameToHostName
argument_list|(
name|taskTrackerName
argument_list|)
decl_stmt|;
name|int
name|taskTrackerPort
init|=
operator|-
literal|1
decl_stmt|;
name|TaskTrackerStatus
name|taskTrackerStatus
init|=
operator|(
name|taskTracker
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|taskTracker
operator|.
name|getStatus
argument_list|()
decl_stmt|;
if|if
condition|(
name|taskTrackerStatus
operator|!=
literal|null
condition|)
block|{
name|taskTrackerPort
operator|=
name|taskTrackerStatus
operator|.
name|getHttpPort
argument_list|()
expr_stmt|;
block|}
name|long
name|startTime
init|=
name|taskStatus
operator|.
name|getStartTime
argument_list|()
decl_stmt|;
name|long
name|finishTime
init|=
name|taskStatus
operator|.
name|getFinishTime
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|taskDiagnosticInfo
init|=
name|tip
operator|.
name|getDiagnosticInfo
argument_list|(
name|taskid
argument_list|)
decl_stmt|;
name|String
name|diagInfo
init|=
name|taskDiagnosticInfo
operator|==
literal|null
condition|?
literal|""
else|:
name|StringUtils
operator|.
name|arrayToString
argument_list|(
name|taskDiagnosticInfo
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|TaskType
name|taskType
init|=
name|getTaskType
argument_list|(
name|tip
argument_list|)
decl_stmt|;
name|TaskAttemptStartedEvent
name|tse
init|=
operator|new
name|TaskAttemptStartedEvent
argument_list|(
name|taskid
argument_list|,
name|taskType
argument_list|,
name|startTime
argument_list|,
name|taskTrackerName
argument_list|,
name|taskTrackerPort
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|jobHistory
operator|.
name|logEvent
argument_list|(
name|tse
argument_list|,
name|taskid
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|ProgressSplitsBlock
name|splits
init|=
name|tip
operator|.
name|getSplits
argument_list|(
name|taskStatus
operator|.
name|getTaskID
argument_list|()
argument_list|)
decl_stmt|;
name|TaskAttemptUnsuccessfulCompletionEvent
name|tue
init|=
operator|new
name|TaskAttemptUnsuccessfulCompletionEvent
argument_list|(
name|taskid
argument_list|,
name|taskType
argument_list|,
name|taskStatus
operator|.
name|getRunState
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|finishTime
argument_list|,
name|taskTrackerHostName
argument_list|,
operator|-
literal|1
argument_list|,
name|diagInfo
argument_list|,
name|splits
operator|.
name|burst
argument_list|()
argument_list|)
decl_stmt|;
name|jobHistory
operator|.
name|logEvent
argument_list|(
name|tue
argument_list|,
name|taskid
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
comment|// After this, try to assign tasks with the one after this, so that
comment|// the failed task goes to the end of the list.
if|if
condition|(
operator|!
name|tip
operator|.
name|isJobCleanupTask
argument_list|()
operator|&&
operator|!
name|tip
operator|.
name|isJobSetupTask
argument_list|()
condition|)
block|{
if|if
condition|(
name|tip
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
name|failedMapTasks
operator|++
expr_stmt|;
block|}
else|else
block|{
name|failedReduceTasks
operator|++
expr_stmt|;
block|}
block|}
comment|//
comment|// Note down that a task has failed on this tasktracker
comment|//
if|if
condition|(
name|status
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
condition|)
block|{
name|addTrackerTaskFailure
argument_list|(
name|taskTrackerName
argument_list|,
name|taskTracker
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Let the JobTracker know that this task has failed
comment|//
name|jobtracker
operator|.
name|markCompletedTaskAttempt
argument_list|(
name|status
operator|.
name|getTaskTracker
argument_list|()
argument_list|,
name|taskid
argument_list|)
expr_stmt|;
comment|//
comment|// Check if we need to kill the job because of too many failures or
comment|// if the job is complete since all component tasks have completed
comment|// We do it once per TIP and that too for the task that fails the TIP
if|if
condition|(
operator|!
name|wasFailed
operator|&&
name|tip
operator|.
name|isFailed
argument_list|()
condition|)
block|{
comment|//
comment|// Allow upto 'mapFailuresPercent' of map tasks to fail or
comment|// 'reduceFailuresPercent' of reduce tasks to fail
comment|//
name|boolean
name|killJob
init|=
name|tip
operator|.
name|isJobCleanupTask
argument_list|()
operator|||
name|tip
operator|.
name|isJobSetupTask
argument_list|()
condition|?
literal|true
else|:
name|tip
operator|.
name|isMapTask
argument_list|()
condition|?
operator|(
operator|(
operator|++
name|failedMapTIPs
operator|*
literal|100
operator|)
operator|>
operator|(
name|mapFailuresPercent
operator|*
name|numMapTasks
operator|)
operator|)
else|:
operator|(
operator|(
operator|++
name|failedReduceTIPs
operator|*
literal|100
operator|)
operator|>
operator|(
name|reduceFailuresPercent
operator|*
name|numReduceTasks
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|killJob
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Aborting job "
operator|+
name|profile
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
name|TaskFailedEvent
name|tfe
init|=
operator|new
name|TaskFailedEvent
argument_list|(
name|tip
operator|.
name|getTIPId
argument_list|()
argument_list|,
name|finishTime
argument_list|,
name|taskType
argument_list|,
name|diagInfo
argument_list|,
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
operator|.
name|toString
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|jobHistory
operator|.
name|logEvent
argument_list|(
name|tfe
argument_list|,
name|tip
operator|.
name|getJob
argument_list|()
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|tip
operator|.
name|isJobCleanupTask
argument_list|()
condition|)
block|{
comment|// kill the other tip
if|if
condition|(
name|tip
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
name|cleanup
index|[
literal|1
index|]
operator|.
name|kill
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|cleanup
index|[
literal|0
index|]
operator|.
name|kill
argument_list|()
expr_stmt|;
block|}
name|terminateJob
argument_list|(
name|JobStatus
operator|.
name|FAILED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tip
operator|.
name|isJobSetupTask
argument_list|()
condition|)
block|{
comment|// kill the other tip
name|killSetupTip
argument_list|(
operator|!
name|tip
operator|.
name|isMapTask
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fail
argument_list|()
expr_stmt|;
block|}
block|}
comment|//
comment|// Update the counters
comment|//
if|if
condition|(
operator|!
name|tip
operator|.
name|isJobCleanupTask
argument_list|()
operator|&&
operator|!
name|tip
operator|.
name|isJobSetupTask
argument_list|()
condition|)
block|{
if|if
condition|(
name|tip
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
name|jobCounters
operator|.
name|incrCounter
argument_list|(
name|JobCounter
operator|.
name|NUM_FAILED_MAPS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|jobCounters
operator|.
name|incrCounter
argument_list|(
name|JobCounter
operator|.
name|NUM_FAILED_REDUCES
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|killSetupTip (boolean isMap)
name|void
name|killSetupTip
parameter_list|(
name|boolean
name|isMap
parameter_list|)
block|{
if|if
condition|(
name|isMap
condition|)
block|{
name|setup
index|[
literal|0
index|]
operator|.
name|kill
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|setup
index|[
literal|1
index|]
operator|.
name|kill
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|isSetupFinished ()
name|boolean
name|isSetupFinished
parameter_list|()
block|{
comment|// if there is no setup to be launched, consider setup is finished.
if|if
condition|(
operator|(
name|tasksInited
operator|.
name|get
argument_list|()
operator|&&
name|setup
operator|.
name|length
operator|==
literal|0
operator|)
operator|||
name|setup
index|[
literal|0
index|]
operator|.
name|isComplete
argument_list|()
operator|||
name|setup
index|[
literal|0
index|]
operator|.
name|isFailed
argument_list|()
operator|||
name|setup
index|[
literal|1
index|]
operator|.
name|isComplete
argument_list|()
operator|||
name|setup
index|[
literal|1
index|]
operator|.
name|isFailed
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Fail a task with a given reason, but without a status object.    *     * Assuming {@link JobTracker} is locked on entry.    *     * @param tip The task's tip    * @param taskid The task id    * @param reason The reason that the task failed    * @param trackerName The task tracker the task failed on    */
DECL|method|failedTask (TaskInProgress tip, TaskAttemptID taskid, String reason, TaskStatus.Phase phase, TaskStatus.State state, String trackerName)
specifier|public
specifier|synchronized
name|void
name|failedTask
parameter_list|(
name|TaskInProgress
name|tip
parameter_list|,
name|TaskAttemptID
name|taskid
parameter_list|,
name|String
name|reason
parameter_list|,
name|TaskStatus
operator|.
name|Phase
name|phase
parameter_list|,
name|TaskStatus
operator|.
name|State
name|state
parameter_list|,
name|String
name|trackerName
parameter_list|)
block|{
name|TaskStatus
name|status
init|=
name|TaskStatus
operator|.
name|createTaskStatus
argument_list|(
name|tip
operator|.
name|isMapTask
argument_list|()
argument_list|,
name|taskid
argument_list|,
literal|0.0f
argument_list|,
name|tip
operator|.
name|isMapTask
argument_list|()
condition|?
name|numSlotsPerMap
else|:
name|numSlotsPerReduce
argument_list|,
name|state
argument_list|,
name|reason
argument_list|,
name|reason
argument_list|,
name|trackerName
argument_list|,
name|phase
argument_list|,
operator|new
name|Counters
argument_list|()
argument_list|)
decl_stmt|;
comment|// update the actual start-time of the attempt
name|TaskStatus
name|oldStatus
init|=
name|tip
operator|.
name|getTaskStatus
argument_list|(
name|taskid
argument_list|)
decl_stmt|;
name|long
name|startTime
init|=
name|oldStatus
operator|==
literal|null
condition|?
name|JobTracker
operator|.
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
else|:
name|oldStatus
operator|.
name|getStartTime
argument_list|()
decl_stmt|;
name|status
operator|.
name|setStartTime
argument_list|(
name|startTime
argument_list|)
expr_stmt|;
name|status
operator|.
name|setFinishTime
argument_list|(
name|JobTracker
operator|.
name|getClock
argument_list|()
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|wasComplete
init|=
name|tip
operator|.
name|isComplete
argument_list|()
decl_stmt|;
name|updateTaskStatus
argument_list|(
name|tip
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|boolean
name|isComplete
init|=
name|tip
operator|.
name|isComplete
argument_list|()
decl_stmt|;
if|if
condition|(
name|wasComplete
operator|&&
operator|!
name|isComplete
condition|)
block|{
comment|// mark a successful tip as failed
name|TaskType
name|taskType
init|=
name|getTaskType
argument_list|(
name|tip
argument_list|)
decl_stmt|;
name|TaskFailedEvent
name|tfe
init|=
operator|new
name|TaskFailedEvent
argument_list|(
name|tip
operator|.
name|getTIPId
argument_list|()
argument_list|,
name|tip
operator|.
name|getExecFinishTime
argument_list|()
argument_list|,
name|taskType
argument_list|,
name|reason
argument_list|,
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
operator|.
name|toString
argument_list|()
argument_list|,
name|taskid
argument_list|)
decl_stmt|;
name|jobHistory
operator|.
name|logEvent
argument_list|(
name|tfe
argument_list|,
name|tip
operator|.
name|getJob
argument_list|()
operator|.
name|getJobID
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * The job is dead.  We're now GC'ing it, getting rid of the job    * from all tables.  Be sure to remove all of this job's tasks    * from the various tables.    */
DECL|method|garbageCollect ()
name|void
name|garbageCollect
parameter_list|()
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// Cancel task tracker reservation
name|cancelReservedSlots
argument_list|()
expr_stmt|;
comment|// Let the JobTracker know that a job is complete
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|decWaitingMaps
argument_list|(
name|getJobID
argument_list|()
argument_list|,
name|pendingMaps
argument_list|()
argument_list|)
expr_stmt|;
name|jobtracker
operator|.
name|getInstrumentation
argument_list|()
operator|.
name|decWaitingReduces
argument_list|(
name|getJobID
argument_list|()
argument_list|,
name|pendingReduces
argument_list|()
argument_list|)
expr_stmt|;
name|jobtracker
operator|.
name|storeCompletedJob
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|jobtracker
operator|.
name|finalizeJob
argument_list|(
name|this
argument_list|)
expr_stmt|;
try|try
block|{
comment|// Definitely remove the local-disk copy of the job file
if|if
condition|(
name|localJobFile
operator|!=
literal|null
condition|)
block|{
name|localFs
operator|.
name|delete
argument_list|(
name|localJobFile
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|localJobFile
operator|=
literal|null
expr_stmt|;
block|}
name|Path
name|tempDir
init|=
name|jobtracker
operator|.
name|getSystemDirectoryForJob
argument_list|(
name|getJobID
argument_list|()
argument_list|)
decl_stmt|;
operator|new
name|CleanupQueue
argument_list|()
operator|.
name|addToQueue
argument_list|(
operator|new
name|PathDeletionContext
argument_list|(
name|jobtracker
operator|.
name|getFileSystem
argument_list|()
argument_list|,
name|tempDir
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error cleaning up "
operator|+
name|profile
operator|.
name|getJobID
argument_list|()
operator|+
literal|": "
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
comment|// free up the memory used by the data structures
name|this
operator|.
name|nonRunningMapCache
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|runningMapCache
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|nonRunningReduces
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|runningReduces
operator|=
literal|null
expr_stmt|;
block|}
comment|// remove jobs delegation tokens
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|MRJobConfig
operator|.
name|JOB_CANCEL_DELEGATION_TOKEN
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|DelegationTokenRenewal
operator|.
name|removeDelegationTokenRenewalForJob
argument_list|(
name|jobId
argument_list|)
expr_stmt|;
block|}
comment|// else don't remove it.May be used by spawned tasks
block|}
comment|/**    * Return the TaskInProgress that matches the tipid.    */
DECL|method|getTaskInProgress (TaskID tipid)
specifier|public
specifier|synchronized
name|TaskInProgress
name|getTaskInProgress
parameter_list|(
name|TaskID
name|tipid
parameter_list|)
block|{
if|if
condition|(
name|tipid
operator|.
name|getTaskType
argument_list|()
operator|==
name|TaskType
operator|.
name|MAP
condition|)
block|{
comment|// cleanup map tip
if|if
condition|(
name|cleanup
operator|.
name|length
operator|>
literal|0
operator|&&
name|tipid
operator|.
name|equals
argument_list|(
name|cleanup
index|[
literal|0
index|]
operator|.
name|getTIPId
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|cleanup
index|[
literal|0
index|]
return|;
block|}
comment|// setup map tip
if|if
condition|(
name|setup
operator|.
name|length
operator|>
literal|0
operator|&&
name|tipid
operator|.
name|equals
argument_list|(
name|setup
index|[
literal|0
index|]
operator|.
name|getTIPId
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|setup
index|[
literal|0
index|]
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maps
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tipid
operator|.
name|equals
argument_list|(
name|maps
index|[
name|i
index|]
operator|.
name|getTIPId
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|maps
index|[
name|i
index|]
return|;
block|}
block|}
block|}
else|else
block|{
comment|// cleanup reduce tip
if|if
condition|(
name|cleanup
operator|.
name|length
operator|>
literal|0
operator|&&
name|tipid
operator|.
name|equals
argument_list|(
name|cleanup
index|[
literal|1
index|]
operator|.
name|getTIPId
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|cleanup
index|[
literal|1
index|]
return|;
block|}
comment|// setup reduce tip
if|if
condition|(
name|setup
operator|.
name|length
operator|>
literal|0
operator|&&
name|tipid
operator|.
name|equals
argument_list|(
name|setup
index|[
literal|1
index|]
operator|.
name|getTIPId
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|setup
index|[
literal|1
index|]
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|reduces
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tipid
operator|.
name|equals
argument_list|(
name|reduces
index|[
name|i
index|]
operator|.
name|getTIPId
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|reduces
index|[
name|i
index|]
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Find the details of someplace where a map has finished    * @param mapId the id of the map    * @return the task status of the completed task    */
DECL|method|findFinishedMap (int mapId)
specifier|public
specifier|synchronized
name|TaskStatus
name|findFinishedMap
parameter_list|(
name|int
name|mapId
parameter_list|)
block|{
name|TaskInProgress
name|tip
init|=
name|maps
index|[
name|mapId
index|]
decl_stmt|;
if|if
condition|(
name|tip
operator|.
name|isComplete
argument_list|()
condition|)
block|{
name|TaskStatus
index|[]
name|statuses
init|=
name|tip
operator|.
name|getTaskStatuses
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|statuses
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|statuses
index|[
name|i
index|]
operator|.
name|getRunState
argument_list|()
operator|==
name|TaskStatus
operator|.
name|State
operator|.
name|SUCCEEDED
condition|)
block|{
return|return
name|statuses
index|[
name|i
index|]
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|getNumTaskCompletionEvents ()
specifier|synchronized
name|int
name|getNumTaskCompletionEvents
parameter_list|()
block|{
return|return
name|taskCompletionEvents
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|getTaskCompletionEvents ( int fromEventId, int maxEvents)
specifier|synchronized
specifier|public
name|TaskCompletionEvent
index|[]
name|getTaskCompletionEvents
parameter_list|(
name|int
name|fromEventId
parameter_list|,
name|int
name|maxEvents
parameter_list|)
block|{
name|TaskCompletionEvent
index|[]
name|events
init|=
name|TaskCompletionEvent
operator|.
name|EMPTY_ARRAY
decl_stmt|;
if|if
condition|(
name|taskCompletionEvents
operator|.
name|size
argument_list|()
operator|>
name|fromEventId
condition|)
block|{
name|int
name|actualMax
init|=
name|Math
operator|.
name|min
argument_list|(
name|maxEvents
argument_list|,
operator|(
name|taskCompletionEvents
operator|.
name|size
argument_list|()
operator|-
name|fromEventId
operator|)
argument_list|)
decl_stmt|;
name|events
operator|=
name|taskCompletionEvents
operator|.
name|subList
argument_list|(
name|fromEventId
argument_list|,
name|actualMax
operator|+
name|fromEventId
argument_list|)
operator|.
name|toArray
argument_list|(
name|events
argument_list|)
expr_stmt|;
block|}
return|return
name|events
return|;
block|}
DECL|method|fetchFailureNotification (TaskInProgress tip, TaskAttemptID mapTaskId, String mapTrackerName, TaskAttemptID reduceTaskId, String reduceTrackerName)
specifier|synchronized
name|void
name|fetchFailureNotification
parameter_list|(
name|TaskInProgress
name|tip
parameter_list|,
name|TaskAttemptID
name|mapTaskId
parameter_list|,
name|String
name|mapTrackerName
parameter_list|,
name|TaskAttemptID
name|reduceTaskId
parameter_list|,
name|String
name|reduceTrackerName
parameter_list|)
block|{
name|Integer
name|fetchFailures
init|=
name|mapTaskIdToFetchFailuresMap
operator|.
name|get
argument_list|(
name|mapTaskId
argument_list|)
decl_stmt|;
name|fetchFailures
operator|=
operator|(
name|fetchFailures
operator|==
literal|null
operator|)
condition|?
literal|1
else|:
operator|(
name|fetchFailures
operator|+
literal|1
operator|)
expr_stmt|;
name|mapTaskIdToFetchFailuresMap
operator|.
name|put
argument_list|(
name|mapTaskId
argument_list|,
name|fetchFailures
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed fetch notification #"
operator|+
name|fetchFailures
operator|+
literal|" for map task: "
operator|+
name|mapTaskId
operator|+
literal|" running on tracker: "
operator|+
name|mapTrackerName
operator|+
literal|" and reduce task: "
operator|+
name|reduceTaskId
operator|+
literal|" running on tracker: "
operator|+
name|reduceTrackerName
argument_list|)
expr_stmt|;
name|float
name|failureRate
init|=
operator|(
name|float
operator|)
name|fetchFailures
operator|/
name|runningReduceTasks
decl_stmt|;
comment|// declare faulty if fetch-failures>= max-allowed-failures
name|boolean
name|isMapFaulty
init|=
operator|(
name|failureRate
operator|>=
name|MAX_ALLOWED_FETCH_FAILURES_PERCENT
operator|)
condition|?
literal|true
else|:
literal|false
decl_stmt|;
if|if
condition|(
name|fetchFailures
operator|>=
name|MAX_FETCH_FAILURES_NOTIFICATIONS
operator|&&
name|isMapFaulty
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Too many fetch-failures for output of task: "
operator|+
name|mapTaskId
operator|+
literal|" ... killing it"
argument_list|)
expr_stmt|;
name|failedTask
argument_list|(
name|tip
argument_list|,
name|mapTaskId
argument_list|,
literal|"Too many fetch-failures"
argument_list|,
operator|(
name|tip
operator|.
name|isMapTask
argument_list|()
condition|?
name|TaskStatus
operator|.
name|Phase
operator|.
name|MAP
else|:
name|TaskStatus
operator|.
name|Phase
operator|.
name|REDUCE
operator|)
argument_list|,
name|TaskStatus
operator|.
name|State
operator|.
name|FAILED
argument_list|,
name|mapTrackerName
argument_list|)
expr_stmt|;
name|mapTaskIdToFetchFailuresMap
operator|.
name|remove
argument_list|(
name|mapTaskId
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @return The JobID of this JobInProgress.    */
DECL|method|getJobID ()
specifier|public
name|JobID
name|getJobID
parameter_list|()
block|{
return|return
name|jobId
return|;
block|}
DECL|method|getSchedulingInfo ()
specifier|public
specifier|synchronized
name|Object
name|getSchedulingInfo
parameter_list|()
block|{
return|return
name|this
operator|.
name|schedulingInfo
return|;
block|}
DECL|method|setSchedulingInfo (Object schedulingInfo)
specifier|public
specifier|synchronized
name|void
name|setSchedulingInfo
parameter_list|(
name|Object
name|schedulingInfo
parameter_list|)
block|{
name|this
operator|.
name|schedulingInfo
operator|=
name|schedulingInfo
expr_stmt|;
name|this
operator|.
name|status
operator|.
name|setSchedulingInfo
argument_list|(
name|schedulingInfo
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * To keep track of kill and initTasks status of this job. initTasks() take     * a lock on JobInProgress object. kill should avoid waiting on     * JobInProgress lock since it may take a while to do initTasks().    */
DECL|class|JobInitKillStatus
specifier|private
specifier|static
class|class
name|JobInitKillStatus
block|{
comment|//flag to be set if kill is called
DECL|field|killed
name|boolean
name|killed
decl_stmt|;
DECL|field|initStarted
name|boolean
name|initStarted
decl_stmt|;
DECL|field|initDone
name|boolean
name|initDone
decl_stmt|;
block|}
DECL|method|isComplete ()
name|boolean
name|isComplete
parameter_list|()
block|{
return|return
name|status
operator|.
name|isJobComplete
argument_list|()
return|;
block|}
comment|/**    * Get the task type for logging it to {@link JobHistory}.    */
DECL|method|getTaskType (TaskInProgress tip)
specifier|private
name|TaskType
name|getTaskType
parameter_list|(
name|TaskInProgress
name|tip
parameter_list|)
block|{
if|if
condition|(
name|tip
operator|.
name|isJobCleanupTask
argument_list|()
condition|)
block|{
return|return
name|TaskType
operator|.
name|JOB_CLEANUP
return|;
block|}
elseif|else
if|if
condition|(
name|tip
operator|.
name|isJobSetupTask
argument_list|()
condition|)
block|{
return|return
name|TaskType
operator|.
name|JOB_SETUP
return|;
block|}
elseif|else
if|if
condition|(
name|tip
operator|.
name|isMapTask
argument_list|()
condition|)
block|{
return|return
name|TaskType
operator|.
name|MAP
return|;
block|}
else|else
block|{
return|return
name|TaskType
operator|.
name|REDUCE
return|;
block|}
block|}
comment|/**    * Get the level of locality that a given task would have if launched on    * a particular TaskTracker. Returns 0 if the task has data on that machine,    * 1 if it has data on the same rack, etc (depending on number of levels in    * the network hierarchy).    */
DECL|method|getLocalityLevel (TaskInProgress tip, TaskTrackerStatus tts)
name|int
name|getLocalityLevel
parameter_list|(
name|TaskInProgress
name|tip
parameter_list|,
name|TaskTrackerStatus
name|tts
parameter_list|)
block|{
name|Node
name|tracker
init|=
name|jobtracker
operator|.
name|getNode
argument_list|(
name|tts
operator|.
name|getHost
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|level
init|=
name|this
operator|.
name|maxLevel
decl_stmt|;
comment|// find the right level across split locations
for|for
control|(
name|String
name|local
range|:
name|maps
index|[
name|tip
operator|.
name|getIdWithinJob
argument_list|()
index|]
operator|.
name|getSplitLocations
argument_list|()
control|)
block|{
name|Node
name|datanode
init|=
name|jobtracker
operator|.
name|getNode
argument_list|(
name|local
argument_list|)
decl_stmt|;
name|int
name|newLevel
init|=
name|this
operator|.
name|maxLevel
decl_stmt|;
if|if
condition|(
name|tracker
operator|!=
literal|null
operator|&&
name|datanode
operator|!=
literal|null
condition|)
block|{
name|newLevel
operator|=
name|getMatchingLevelForNodes
argument_list|(
name|tracker
argument_list|,
name|datanode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newLevel
operator|<
name|level
condition|)
block|{
name|level
operator|=
name|newLevel
expr_stmt|;
comment|// an optimization
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
block|}
return|return
name|level
return|;
block|}
comment|/**    * Test method to set the cluster sizes    */
DECL|method|setClusterSize (int clusterSize)
name|void
name|setClusterSize
parameter_list|(
name|int
name|clusterSize
parameter_list|)
block|{
name|this
operator|.
name|clusterSize
operator|=
name|clusterSize
expr_stmt|;
block|}
DECL|class|JobSummary
specifier|static
class|class
name|JobSummary
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|JobSummary
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Escape sequences
DECL|field|EQUALS
specifier|static
specifier|final
name|char
name|EQUALS
init|=
literal|'='
decl_stmt|;
DECL|field|charsToEscape
specifier|static
specifier|final
name|char
index|[]
name|charsToEscape
init|=
block|{
name|StringUtils
operator|.
name|COMMA
block|,
name|EQUALS
block|,
name|StringUtils
operator|.
name|ESCAPE_CHAR
block|}
decl_stmt|;
DECL|class|SummaryBuilder
specifier|static
class|class
name|SummaryBuilder
block|{
DECL|field|buffer
specifier|final
name|StringBuilder
name|buffer
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// A little optimization for a very common case
DECL|method|add (String key, long value)
name|SummaryBuilder
name|add
parameter_list|(
name|String
name|key
parameter_list|,
name|long
name|value
parameter_list|)
block|{
return|return
name|_add
argument_list|(
name|key
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
block|}
DECL|method|add (String key, T value)
parameter_list|<
name|T
parameter_list|>
name|SummaryBuilder
name|add
parameter_list|(
name|String
name|key
parameter_list|,
name|T
name|value
parameter_list|)
block|{
return|return
name|_add
argument_list|(
name|key
argument_list|,
name|StringUtils
operator|.
name|escapeString
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
argument_list|,
name|StringUtils
operator|.
name|ESCAPE_CHAR
argument_list|,
name|charsToEscape
argument_list|)
argument_list|)
return|;
block|}
DECL|method|add (SummaryBuilder summary)
name|SummaryBuilder
name|add
parameter_list|(
name|SummaryBuilder
name|summary
parameter_list|)
block|{
if|if
condition|(
name|buffer
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|buffer
operator|.
name|append
argument_list|(
name|StringUtils
operator|.
name|COMMA
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|summary
operator|.
name|buffer
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|_add (String key, String value)
name|SummaryBuilder
name|_add
parameter_list|(
name|String
name|key
parameter_list|,
name|String
name|value
parameter_list|)
block|{
if|if
condition|(
name|buffer
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
name|buffer
operator|.
name|append
argument_list|(
name|StringUtils
operator|.
name|COMMA
argument_list|)
expr_stmt|;
name|buffer
operator|.
name|append
argument_list|(
name|key
argument_list|)
operator|.
name|append
argument_list|(
name|EQUALS
argument_list|)
operator|.
name|append
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|toString ()
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|buffer
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
DECL|method|getTaskLaunchTimesSummary (JobInProgress job)
specifier|static
name|SummaryBuilder
name|getTaskLaunchTimesSummary
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
block|{
name|SummaryBuilder
name|summary
init|=
operator|new
name|SummaryBuilder
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|TaskType
argument_list|,
name|Long
argument_list|>
name|timeMap
init|=
name|job
operator|.
name|getFirstTaskLaunchTimes
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|timeMap
init|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|TaskType
argument_list|,
name|Long
argument_list|>
name|e
range|:
name|timeMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|summary
operator|.
name|add
argument_list|(
literal|"first"
operator|+
name|StringUtils
operator|.
name|camelize
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
operator|+
literal|"TaskLaunchTime"
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
operator|.
name|longValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|summary
return|;
block|}
comment|/**      * Log a summary of the job's runtime.      *       * @param job {@link JobInProgress} whose summary is to be logged, cannot      *            be<code>null</code>.      * @param cluster {@link ClusterStatus} of the cluster on which the job was      *                run, cannot be<code>null</code>      */
DECL|method|logJobSummary (JobInProgress job, ClusterStatus cluster)
specifier|public
specifier|static
name|void
name|logJobSummary
parameter_list|(
name|JobInProgress
name|job
parameter_list|,
name|ClusterStatus
name|cluster
parameter_list|)
block|{
name|JobStatus
name|status
init|=
name|job
operator|.
name|getStatus
argument_list|()
decl_stmt|;
name|JobProfile
name|profile
init|=
name|job
operator|.
name|getProfile
argument_list|()
decl_stmt|;
name|Counters
name|jobCounters
init|=
name|job
operator|.
name|getJobCounters
argument_list|()
decl_stmt|;
name|long
name|mapSlotSeconds
init|=
operator|(
name|jobCounters
operator|.
name|getCounter
argument_list|(
name|JobCounter
operator|.
name|SLOTS_MILLIS_MAPS
argument_list|)
operator|+
name|jobCounters
operator|.
name|getCounter
argument_list|(
name|JobCounter
operator|.
name|FALLOW_SLOTS_MILLIS_MAPS
argument_list|)
operator|)
operator|/
literal|1000
decl_stmt|;
name|long
name|reduceSlotSeconds
init|=
operator|(
name|jobCounters
operator|.
name|getCounter
argument_list|(
name|JobCounter
operator|.
name|SLOTS_MILLIS_REDUCES
argument_list|)
operator|+
name|jobCounters
operator|.
name|getCounter
argument_list|(
name|JobCounter
operator|.
name|FALLOW_SLOTS_MILLIS_REDUCES
argument_list|)
operator|)
operator|/
literal|1000
decl_stmt|;
name|SummaryBuilder
name|summary
init|=
operator|new
name|SummaryBuilder
argument_list|()
operator|.
name|add
argument_list|(
literal|"jobId"
argument_list|,
name|job
operator|.
name|getJobID
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
literal|"submitTime"
argument_list|,
name|job
operator|.
name|getStartTime
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
literal|"launchTime"
argument_list|,
name|job
operator|.
name|getLaunchTime
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|getTaskLaunchTimesSummary
argument_list|(
name|job
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
literal|"finishTime"
argument_list|,
name|job
operator|.
name|getFinishTime
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
literal|"numMaps"
argument_list|,
name|job
operator|.
name|getTasks
argument_list|(
name|TaskType
operator|.
name|MAP
argument_list|)
operator|.
name|length
argument_list|)
operator|.
name|add
argument_list|(
literal|"numSlotsPerMap"
argument_list|,
name|job
operator|.
name|getNumSlotsPerMap
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
literal|"numReduces"
argument_list|,
name|job
operator|.
name|getTasks
argument_list|(
name|TaskType
operator|.
name|REDUCE
argument_list|)
operator|.
name|length
argument_list|)
operator|.
name|add
argument_list|(
literal|"numSlotsPerReduce"
argument_list|,
name|job
operator|.
name|getNumSlotsPerReduce
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
literal|"user"
argument_list|,
name|profile
operator|.
name|getUser
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
literal|"queue"
argument_list|,
name|profile
operator|.
name|getQueueName
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
literal|"status"
argument_list|,
name|JobStatus
operator|.
name|getJobRunState
argument_list|(
name|status
operator|.
name|getRunState
argument_list|()
argument_list|)
argument_list|)
operator|.
name|add
argument_list|(
literal|"mapSlotSeconds"
argument_list|,
name|mapSlotSeconds
argument_list|)
operator|.
name|add
argument_list|(
literal|"reduceSlotsSeconds"
argument_list|,
name|reduceSlotSeconds
argument_list|)
operator|.
name|add
argument_list|(
literal|"clusterMapCapacity"
argument_list|,
name|cluster
operator|.
name|getMaxMapTasks
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
literal|"clusterReduceCapacity"
argument_list|,
name|cluster
operator|.
name|getMaxReduceTasks
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|summary
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Creates the localized copy of job conf    * @param jobConf    * @param id    */
DECL|method|setUpLocalizedJobConf (JobConf jobConf, org.apache.hadoop.mapreduce.JobID id)
name|void
name|setUpLocalizedJobConf
parameter_list|(
name|JobConf
name|jobConf
parameter_list|,
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobID
name|id
parameter_list|)
block|{
name|String
name|localJobFilePath
init|=
name|jobtracker
operator|.
name|getLocalJobFilePath
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|File
name|localJobFile
init|=
operator|new
name|File
argument_list|(
name|localJobFilePath
argument_list|)
decl_stmt|;
name|FileOutputStream
name|jobOut
init|=
literal|null
decl_stmt|;
try|try
block|{
name|jobOut
operator|=
operator|new
name|FileOutputStream
argument_list|(
name|localJobFile
argument_list|)
expr_stmt|;
name|jobConf
operator|.
name|writeXml
argument_list|(
name|jobOut
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Job conf for "
operator|+
name|id
operator|+
literal|" stored at "
operator|+
name|localJobFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to store job conf on the local filesystem "
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|jobOut
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|jobOut
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to close the job configuration file "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ie
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Deletes localized copy of job conf    */
DECL|method|cleanupLocalizedJobConf (org.apache.hadoop.mapreduce.JobID id)
name|void
name|cleanupLocalizedJobConf
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|JobID
name|id
parameter_list|)
block|{
name|String
name|localJobFilePath
init|=
name|jobtracker
operator|.
name|getLocalJobFilePath
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|localJobFilePath
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleting localized job conf at "
operator|+
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|delete
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to delete file "
operator|+
name|f
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * generate job token and save it into the file    * @throws IOException    */
DECL|method|generateAndStoreTokens ()
specifier|private
name|void
name|generateAndStoreTokens
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|jobDir
init|=
name|jobtracker
operator|.
name|getSystemDirectoryForJob
argument_list|(
name|jobId
argument_list|)
decl_stmt|;
name|Path
name|keysFile
init|=
operator|new
name|Path
argument_list|(
name|jobDir
argument_list|,
name|TokenCache
operator|.
name|JOB_TOKEN_HDFS_FILE
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokenStorage
operator|==
literal|null
condition|)
block|{
name|tokenStorage
operator|=
operator|new
name|Credentials
argument_list|()
expr_stmt|;
block|}
comment|//create JobToken file and write token to it
name|JobTokenIdentifier
name|identifier
init|=
operator|new
name|JobTokenIdentifier
argument_list|(
operator|new
name|Text
argument_list|(
name|jobId
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|Token
argument_list|<
name|JobTokenIdentifier
argument_list|>
name|token
init|=
operator|new
name|Token
argument_list|<
name|JobTokenIdentifier
argument_list|>
argument_list|(
name|identifier
argument_list|,
name|jobtracker
operator|.
name|getJobTokenSecretManager
argument_list|()
argument_list|)
decl_stmt|;
name|token
operator|.
name|setService
argument_list|(
name|identifier
operator|.
name|getJobId
argument_list|()
argument_list|)
expr_stmt|;
name|TokenCache
operator|.
name|setJobToken
argument_list|(
name|token
argument_list|,
name|tokenStorage
argument_list|)
expr_stmt|;
comment|// write TokenStorage out
name|tokenStorage
operator|.
name|writeTokenStorageFile
argument_list|(
name|keysFile
argument_list|,
name|jobtracker
operator|.
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"jobToken generated and stored with users keys in "
operator|+
name|keysFile
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|getJobSubmitHostAddress ()
specifier|public
name|String
name|getJobSubmitHostAddress
parameter_list|()
block|{
return|return
name|submitHostAddress
return|;
block|}
DECL|method|getJobSubmitHostName ()
specifier|public
name|String
name|getJobSubmitHostName
parameter_list|()
block|{
return|return
name|submitHostName
return|;
block|}
block|}
end_class

end_unit

