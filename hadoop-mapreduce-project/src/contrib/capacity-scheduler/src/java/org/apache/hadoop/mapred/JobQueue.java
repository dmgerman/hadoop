begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapreduce
operator|.
name|TaskType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
operator|.
name|JobQueueJobInProgressListener
operator|.
name|JobSchedulingInfo
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_comment
comment|/**  *  */
end_comment

begin_class
DECL|class|JobQueue
class|class
name|JobQueue
extends|extends
name|AbstractQueue
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|JobQueue
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|method|JobQueue (AbstractQueue parent, QueueSchedulingContext qsc)
specifier|public
name|JobQueue
parameter_list|(
name|AbstractQueue
name|parent
parameter_list|,
name|QueueSchedulingContext
name|qsc
parameter_list|)
block|{
name|super
argument_list|(
name|parent
argument_list|,
name|qsc
argument_list|)
expr_stmt|;
if|if
condition|(
name|qsc
operator|.
name|supportsPriorities
argument_list|()
condition|)
block|{
comment|// use the default priority-aware comparator
name|comparator
operator|=
name|JobQueueJobInProgressListener
operator|.
name|FIFO_JOB_QUEUE_COMPARATOR
expr_stmt|;
block|}
else|else
block|{
name|comparator
operator|=
name|STARTTIME_JOB_COMPARATOR
expr_stmt|;
block|}
name|waitingJobs
operator|=
operator|new
name|TreeMap
argument_list|<
name|JobSchedulingInfo
argument_list|,
name|JobInProgress
argument_list|>
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
name|runningJobs
operator|=
operator|new
name|TreeMap
argument_list|<
name|JobSchedulingInfo
argument_list|,
name|JobInProgress
argument_list|>
argument_list|(
name|comparator
argument_list|)
expr_stmt|;
block|}
comment|/*   * If a queue supports priorities, jobs must be   * sorted on priorities, and then on their start times (technically,   * their insertion time.   * If a queue doesn't support priorities, jobs are   * sorted based on their start time.   */
specifier|static
specifier|final
name|Comparator
argument_list|<
name|JobSchedulingInfo
argument_list|>
DECL|field|STARTTIME_JOB_COMPARATOR
name|STARTTIME_JOB_COMPARATOR
decl_stmt|;
static|static
block|{
name|STARTTIME_JOB_COMPARATOR
operator|=
operator|new
name|Comparator
argument_list|<
name|JobSchedulingInfo
argument_list|>
argument_list|()
block|{
comment|// comparator for jobs in queues that don't support priorities
specifier|public
name|int
name|compare
parameter_list|(
name|JobSchedulingInfo
name|o1
parameter_list|,
name|JobSchedulingInfo
name|o2
parameter_list|)
block|{
comment|// the job that started earlier wins
if|if
condition|(
name|o1
operator|.
name|getStartTime
argument_list|()
operator|<
name|o2
operator|.
name|getStartTime
argument_list|()
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
operator|(
name|o1
operator|.
name|getStartTime
argument_list|()
operator|==
name|o2
operator|.
name|getStartTime
argument_list|()
condition|?
name|o1
operator|.
name|getJobID
argument_list|()
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|getJobID
argument_list|()
argument_list|)
else|:
literal|1
operator|)
return|;
block|}
block|}
block|}
expr_stmt|;
block|}
comment|/**    * This involves updating each qC structure.    *    * @param mapClusterCapacity    * @param reduceClusterCapacity    */
annotation|@
name|Override
DECL|method|update (int mapClusterCapacity, int reduceClusterCapacity)
specifier|public
name|void
name|update
parameter_list|(
name|int
name|mapClusterCapacity
parameter_list|,
name|int
name|reduceClusterCapacity
parameter_list|)
block|{
name|super
operator|.
name|update
argument_list|(
name|mapClusterCapacity
argument_list|,
name|reduceClusterCapacity
argument_list|)
expr_stmt|;
for|for
control|(
name|JobInProgress
name|j
range|:
name|this
operator|.
name|getRunningJobs
argument_list|()
control|)
block|{
name|updateStatsOnRunningJob
argument_list|(
name|qsc
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|updateStatsOnRunningJob ( QueueSchedulingContext qC, JobInProgress j)
specifier|private
name|void
name|updateStatsOnRunningJob
parameter_list|(
name|QueueSchedulingContext
name|qC
parameter_list|,
name|JobInProgress
name|j
parameter_list|)
block|{
if|if
condition|(
name|j
operator|.
name|getStatus
argument_list|()
operator|.
name|getRunState
argument_list|()
operator|!=
name|JobStatus
operator|.
name|RUNNING
condition|)
block|{
return|return;
block|}
name|TaskSchedulingContext
name|mapTSI
init|=
name|qC
operator|.
name|getMapTSC
argument_list|()
decl_stmt|;
name|TaskSchedulingContext
name|reduceTSI
init|=
name|qC
operator|.
name|getReduceTSC
argument_list|()
decl_stmt|;
name|int
name|numMapsRunningForThisJob
init|=
name|j
operator|.
name|runningMaps
argument_list|()
decl_stmt|;
name|int
name|numReducesRunningForThisJob
init|=
name|j
operator|.
name|runningReduces
argument_list|()
decl_stmt|;
name|TaskDataView
name|mapScheduler
init|=
name|TaskDataView
operator|.
name|getTaskDataView
argument_list|(
name|TaskType
operator|.
name|MAP
argument_list|)
decl_stmt|;
name|TaskDataView
name|reduceScheduler
init|=
name|TaskDataView
operator|.
name|getTaskDataView
argument_list|(
name|TaskType
operator|.
name|REDUCE
argument_list|)
decl_stmt|;
name|int
name|numRunningMapSlots
init|=
name|numMapsRunningForThisJob
operator|*
name|mapScheduler
operator|.
name|getSlotsPerTask
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|int
name|numRunningReduceSlots
init|=
name|numReducesRunningForThisJob
operator|*
name|reduceScheduler
operator|.
name|getSlotsPerTask
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|int
name|numMapSlotsForThisJob
init|=
name|mapScheduler
operator|.
name|getSlotsOccupied
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|int
name|numReduceSlotsForThisJob
init|=
name|reduceScheduler
operator|.
name|getSlotsOccupied
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|int
name|numReservedMapSlotsForThisJob
init|=
operator|(
name|mapScheduler
operator|.
name|getNumReservedTaskTrackers
argument_list|(
name|j
argument_list|)
operator|*
name|mapScheduler
operator|.
name|getSlotsPerTask
argument_list|(
name|j
argument_list|)
operator|)
decl_stmt|;
name|int
name|numReservedReduceSlotsForThisJob
init|=
operator|(
name|reduceScheduler
operator|.
name|getNumReservedTaskTrackers
argument_list|(
name|j
argument_list|)
operator|*
name|reduceScheduler
operator|.
name|getSlotsPerTask
argument_list|(
name|j
argument_list|)
operator|)
decl_stmt|;
name|j
operator|.
name|setSchedulingInfo
argument_list|(
name|getJobQueueSchedInfo
argument_list|(
name|numMapsRunningForThisJob
argument_list|,
name|numRunningMapSlots
argument_list|,
name|numReservedMapSlotsForThisJob
argument_list|,
name|numReducesRunningForThisJob
argument_list|,
name|numRunningReduceSlots
argument_list|,
name|numReservedReduceSlotsForThisJob
argument_list|)
argument_list|)
expr_stmt|;
name|mapTSI
operator|.
name|setNumRunningTasks
argument_list|(
name|mapTSI
operator|.
name|getNumRunningTasks
argument_list|()
operator|+
name|numMapsRunningForThisJob
argument_list|)
expr_stmt|;
name|reduceTSI
operator|.
name|setNumRunningTasks
argument_list|(
name|reduceTSI
operator|.
name|getNumRunningTasks
argument_list|()
operator|+
name|numReducesRunningForThisJob
argument_list|)
expr_stmt|;
name|mapTSI
operator|.
name|setNumSlotsOccupied
argument_list|(
name|mapTSI
operator|.
name|getNumSlotsOccupied
argument_list|()
operator|+
name|numMapSlotsForThisJob
argument_list|)
expr_stmt|;
name|reduceTSI
operator|.
name|setNumSlotsOccupied
argument_list|(
name|reduceTSI
operator|.
name|getNumSlotsOccupied
argument_list|()
operator|+
name|numReduceSlotsForThisJob
argument_list|)
expr_stmt|;
name|Integer
name|i
init|=
name|mapTSI
operator|.
name|getNumSlotsOccupiedByUser
argument_list|()
operator|.
name|get
argument_list|(
name|j
operator|.
name|getProfile
argument_list|()
operator|.
name|getUser
argument_list|()
argument_list|)
decl_stmt|;
name|mapTSI
operator|.
name|getNumSlotsOccupiedByUser
argument_list|()
operator|.
name|put
argument_list|(
name|j
operator|.
name|getProfile
argument_list|()
operator|.
name|getUser
argument_list|()
argument_list|,
name|i
operator|.
name|intValue
argument_list|()
operator|+
name|numMapSlotsForThisJob
argument_list|)
expr_stmt|;
name|i
operator|=
name|reduceTSI
operator|.
name|getNumSlotsOccupiedByUser
argument_list|()
operator|.
name|get
argument_list|(
name|j
operator|.
name|getProfile
argument_list|()
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
name|reduceTSI
operator|.
name|getNumSlotsOccupiedByUser
argument_list|()
operator|.
name|put
argument_list|(
name|j
operator|.
name|getProfile
argument_list|()
operator|.
name|getUser
argument_list|()
argument_list|,
name|i
operator|.
name|intValue
argument_list|()
operator|+
name|numReduceSlotsForThisJob
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
synchronized|synchronized
init|(
name|j
init|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"updateQSI: job %s: run(m)=%d, "
operator|+
literal|"occupied(m)=%d, run(r)=%d, occupied(r)=%d, finished(m)=%d,"
operator|+
literal|" finished(r)=%d, failed(m)=%d, failed(r)=%d, "
operator|+
literal|"spec(m)=%d, spec(r)=%d, total(m)=%d, total(r)=%d"
argument_list|,
name|j
operator|.
name|getJobID
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|numMapsRunningForThisJob
argument_list|,
name|numMapSlotsForThisJob
argument_list|,
name|numReducesRunningForThisJob
argument_list|,
name|numReduceSlotsForThisJob
argument_list|,
name|j
operator|.
name|finishedMaps
argument_list|()
argument_list|,
name|j
operator|.
name|finishedReduces
argument_list|()
argument_list|,
name|j
operator|.
name|failedMapTasks
argument_list|,
name|j
operator|.
name|failedReduceTasks
argument_list|,
name|j
operator|.
name|speculativeMapTasks
argument_list|,
name|j
operator|.
name|speculativeReduceTasks
argument_list|,
name|j
operator|.
name|numMapTasks
argument_list|,
name|j
operator|.
name|numReduceTasks
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*     * it's fine walking down the entire list of running jobs - there   * probably will not be many, plus, we may need to go through the   * list to compute numSlotsOccupiedByUser. If this is expensive, we   * can keep a list of running jobs per user. Then we only need to   * consider the first few jobs per user.   */
block|}
DECL|field|JOBQUEUE_SCHEDULINGINFO_INITIAL_LENGTH
specifier|private
specifier|static
specifier|final
name|int
name|JOBQUEUE_SCHEDULINGINFO_INITIAL_LENGTH
init|=
literal|175
decl_stmt|;
DECL|method|getJobQueueSchedInfo (int numMapsRunningForThisJob, int numRunningMapSlots, int numReservedMapSlotsForThisJob, int numReducesRunningForThisJob, int numRunningReduceSlots, int numReservedReduceSlotsForThisJob)
specifier|static
name|String
name|getJobQueueSchedInfo
parameter_list|(
name|int
name|numMapsRunningForThisJob
parameter_list|,
name|int
name|numRunningMapSlots
parameter_list|,
name|int
name|numReservedMapSlotsForThisJob
parameter_list|,
name|int
name|numReducesRunningForThisJob
parameter_list|,
name|int
name|numRunningReduceSlots
parameter_list|,
name|int
name|numReservedReduceSlotsForThisJob
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|JOBQUEUE_SCHEDULINGINFO_INITIAL_LENGTH
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|numMapsRunningForThisJob
argument_list|)
operator|.
name|append
argument_list|(
literal|" running map tasks using "
argument_list|)
operator|.
name|append
argument_list|(
name|numRunningMapSlots
argument_list|)
operator|.
name|append
argument_list|(
literal|" map slots. "
argument_list|)
operator|.
name|append
argument_list|(
name|numReservedMapSlotsForThisJob
argument_list|)
operator|.
name|append
argument_list|(
literal|" additional slots reserved. "
argument_list|)
operator|.
name|append
argument_list|(
name|numReducesRunningForThisJob
argument_list|)
operator|.
name|append
argument_list|(
literal|" running reduce tasks using "
argument_list|)
operator|.
name|append
argument_list|(
name|numRunningReduceSlots
argument_list|)
operator|.
name|append
argument_list|(
literal|" reduce slots. "
argument_list|)
operator|.
name|append
argument_list|(
name|numReservedReduceSlotsForThisJob
argument_list|)
operator|.
name|append
argument_list|(
literal|" additional slots reserved."
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
name|Map
argument_list|<
name|JobSchedulingInfo
argument_list|,
name|JobInProgress
argument_list|>
DECL|field|waitingJobs
name|waitingJobs
decl_stmt|;
comment|// for waiting jobs
name|Map
argument_list|<
name|JobSchedulingInfo
argument_list|,
name|JobInProgress
argument_list|>
DECL|field|runningJobs
name|runningJobs
decl_stmt|;
comment|// for running jobs
specifier|public
name|Comparator
argument_list|<
name|JobSchedulingInfo
argument_list|>
DECL|field|comparator
name|comparator
decl_stmt|;
DECL|method|getWaitingJobs ()
name|Collection
argument_list|<
name|JobInProgress
argument_list|>
name|getWaitingJobs
parameter_list|()
block|{
synchronized|synchronized
init|(
name|waitingJobs
init|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
operator|new
name|LinkedList
argument_list|<
name|JobInProgress
argument_list|>
argument_list|(
name|waitingJobs
operator|.
name|values
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
DECL|method|getRunningJobs ()
name|Collection
argument_list|<
name|JobInProgress
argument_list|>
name|getRunningJobs
parameter_list|()
block|{
synchronized|synchronized
init|(
name|runningJobs
init|)
block|{
return|return
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
operator|new
name|LinkedList
argument_list|<
name|JobInProgress
argument_list|>
argument_list|(
name|runningJobs
operator|.
name|values
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
DECL|method|addRunningJob (JobInProgress job)
specifier|private
name|void
name|addRunningJob
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
block|{
synchronized|synchronized
init|(
name|runningJobs
init|)
block|{
name|runningJobs
operator|.
name|put
argument_list|(
operator|new
name|JobSchedulingInfo
argument_list|(
name|job
argument_list|)
argument_list|,
name|job
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeRunningJob ( JobSchedulingInfo jobInfo)
specifier|private
name|JobInProgress
name|removeRunningJob
parameter_list|(
name|JobSchedulingInfo
name|jobInfo
parameter_list|)
block|{
synchronized|synchronized
init|(
name|runningJobs
init|)
block|{
return|return
name|runningJobs
operator|.
name|remove
argument_list|(
name|jobInfo
argument_list|)
return|;
block|}
block|}
DECL|method|removeWaitingJob ( JobSchedulingInfo schedInfo)
name|JobInProgress
name|removeWaitingJob
parameter_list|(
name|JobSchedulingInfo
name|schedInfo
parameter_list|)
block|{
synchronized|synchronized
init|(
name|waitingJobs
init|)
block|{
name|JobInProgress
name|jip
init|=
name|waitingJobs
operator|.
name|remove
argument_list|(
name|schedInfo
argument_list|)
decl_stmt|;
name|this
operator|.
name|qsc
operator|.
name|setNumOfWaitingJobs
argument_list|(
name|waitingJobs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|jip
return|;
block|}
block|}
DECL|method|addWaitingJob (JobInProgress job)
specifier|private
name|void
name|addWaitingJob
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
block|{
synchronized|synchronized
init|(
name|waitingJobs
init|)
block|{
name|waitingJobs
operator|.
name|put
argument_list|(
operator|new
name|JobSchedulingInfo
argument_list|(
name|job
argument_list|)
argument_list|,
name|job
argument_list|)
expr_stmt|;
name|this
operator|.
name|qsc
operator|.
name|setNumOfWaitingJobs
argument_list|(
name|waitingJobs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getWaitingJobCount ()
name|int
name|getWaitingJobCount
parameter_list|()
block|{
synchronized|synchronized
init|(
name|waitingJobs
init|)
block|{
return|return
name|waitingJobs
operator|.
name|size
argument_list|()
return|;
block|}
block|}
comment|// called when a job is added
DECL|method|jobAdded (JobInProgress job)
specifier|synchronized
name|void
name|jobAdded
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
throws|throws
name|IOException
block|{
comment|// add job to waiting queue. It will end up in the right place,
comment|// based on priority.
name|addWaitingJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
comment|// update user-specific info
name|Integer
name|i
init|=
name|qsc
operator|.
name|getNumJobsByUser
argument_list|()
operator|.
name|get
argument_list|(
name|job
operator|.
name|getProfile
argument_list|()
operator|.
name|getUser
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
literal|null
operator|==
name|i
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
comment|// set the count for running tasks to 0
name|qsc
operator|.
name|getMapTSC
argument_list|()
operator|.
name|getNumSlotsOccupiedByUser
argument_list|()
operator|.
name|put
argument_list|(
name|job
operator|.
name|getProfile
argument_list|()
operator|.
name|getUser
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|qsc
operator|.
name|getReduceTSC
argument_list|()
operator|.
name|getNumSlotsOccupiedByUser
argument_list|()
operator|.
name|put
argument_list|(
name|job
operator|.
name|getProfile
argument_list|()
operator|.
name|getUser
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|++
expr_stmt|;
block|}
name|qsc
operator|.
name|getNumJobsByUser
argument_list|()
operator|.
name|put
argument_list|(
name|job
operator|.
name|getProfile
argument_list|()
operator|.
name|getUser
argument_list|()
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|// setup scheduler specific job information
name|preInitializeJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Job "
operator|+
name|job
operator|.
name|getJobID
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|" is added under user "
operator|+
name|job
operator|.
name|getProfile
argument_list|()
operator|.
name|getUser
argument_list|()
operator|+
literal|", user now has "
operator|+
name|i
operator|+
literal|" jobs"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Setup {@link CapacityTaskScheduler} specific information prior to    * job initialization.    *<p/>    * TO DO: Currently this method uses , CapacityTaskScheduler based variables    * need to shift those.    */
DECL|method|preInitializeJob (JobInProgress job)
name|void
name|preInitializeJob
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
block|{
name|JobConf
name|jobConf
init|=
name|job
operator|.
name|getJobConf
argument_list|()
decl_stmt|;
comment|// Compute number of slots required to run a single map/reduce task
name|int
name|slotsPerMap
init|=
literal|1
decl_stmt|;
name|int
name|slotsPerReduce
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|MemoryMatcher
operator|.
name|isSchedulingBasedOnMemEnabled
argument_list|()
condition|)
block|{
name|slotsPerMap
operator|=
name|jobConf
operator|.
name|computeNumSlotsPerMap
argument_list|(
name|MemoryMatcher
operator|.
name|getMemSizeForMapSlot
argument_list|()
argument_list|)
expr_stmt|;
name|slotsPerReduce
operator|=
name|jobConf
operator|.
name|computeNumSlotsPerReduce
argument_list|(
name|MemoryMatcher
operator|.
name|getMemSizeForReduceSlot
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|job
operator|.
name|setNumSlotsPerMap
argument_list|(
name|slotsPerMap
argument_list|)
expr_stmt|;
name|job
operator|.
name|setNumSlotsPerReduce
argument_list|(
name|slotsPerReduce
argument_list|)
expr_stmt|;
block|}
comment|// called when a job completes
DECL|method|jobCompleted (JobInProgress job)
specifier|synchronized
name|void
name|jobCompleted
parameter_list|(
name|JobInProgress
name|job
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Job to be removed for user "
operator|+
name|job
operator|.
name|getProfile
argument_list|()
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Integer
name|i
init|=
name|qsc
operator|.
name|getNumJobsByUser
argument_list|()
operator|.
name|get
argument_list|(
name|job
operator|.
name|getProfile
argument_list|()
operator|.
name|getUser
argument_list|()
argument_list|)
decl_stmt|;
name|i
operator|--
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|i
operator|.
name|intValue
argument_list|()
condition|)
block|{
name|qsc
operator|.
name|getNumJobsByUser
argument_list|()
operator|.
name|remove
argument_list|(
name|job
operator|.
name|getProfile
argument_list|()
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
comment|// remove job footprint from our TSIs
name|qsc
operator|.
name|getMapTSC
argument_list|()
operator|.
name|getNumSlotsOccupiedByUser
argument_list|()
operator|.
name|remove
argument_list|(
name|job
operator|.
name|getProfile
argument_list|()
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
name|qsc
operator|.
name|getReduceTSC
argument_list|()
operator|.
name|getNumSlotsOccupiedByUser
argument_list|()
operator|.
name|remove
argument_list|(
name|job
operator|.
name|getProfile
argument_list|()
operator|.
name|getUser
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"No more jobs for user, number of users = "
operator|+
name|qsc
operator|.
name|getNumJobsByUser
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|qsc
operator|.
name|getNumJobsByUser
argument_list|()
operator|.
name|put
argument_list|(
name|job
operator|.
name|getProfile
argument_list|()
operator|.
name|getUser
argument_list|()
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"User still has "
operator|+
name|i
operator|+
literal|" jobs, number of users = "
operator|+
name|qsc
operator|.
name|getNumJobsByUser
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// This is used to reposition a job in the queue. A job can get repositioned
comment|// because of the change in the job priority or job start-time.
DECL|method|reorderJobs ( JobInProgress job, JobSchedulingInfo oldInfo )
specifier|private
name|void
name|reorderJobs
parameter_list|(
name|JobInProgress
name|job
parameter_list|,
name|JobSchedulingInfo
name|oldInfo
parameter_list|)
block|{
if|if
condition|(
name|removeWaitingJob
argument_list|(
name|oldInfo
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|addWaitingJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|removeRunningJob
argument_list|(
name|oldInfo
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|addRunningJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @return    */
annotation|@
name|Override
DECL|method|getDescendentJobQueues ()
name|List
argument_list|<
name|AbstractQueue
argument_list|>
name|getDescendentJobQueues
parameter_list|()
block|{
name|List
argument_list|<
name|AbstractQueue
argument_list|>
name|l
init|=
operator|new
name|ArrayList
argument_list|<
name|AbstractQueue
argument_list|>
argument_list|()
decl_stmt|;
name|l
operator|.
name|add
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|l
return|;
block|}
annotation|@
name|Override
DECL|method|getDescendantContainerQueues ()
name|List
argument_list|<
name|AbstractQueue
argument_list|>
name|getDescendantContainerQueues
parameter_list|()
block|{
return|return
operator|new
name|ArrayList
argument_list|<
name|AbstractQueue
argument_list|>
argument_list|()
return|;
block|}
DECL|method|jobUpdated (JobChangeEvent event)
specifier|public
name|void
name|jobUpdated
parameter_list|(
name|JobChangeEvent
name|event
parameter_list|)
block|{
comment|// Check if this is the status change
if|if
condition|(
name|event
operator|instanceof
name|JobStatusChangeEvent
condition|)
block|{
name|jobStateChanged
argument_list|(
operator|(
name|JobStatusChangeEvent
operator|)
name|event
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * @return    */
annotation|@
name|Override
DECL|method|getChildren ()
name|List
argument_list|<
name|AbstractQueue
argument_list|>
name|getChildren
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
comment|/**    * Dont do anything in sort , this is leaf level queue.    *    * @param queueComparator    */
annotation|@
name|Override
DECL|method|sort (Comparator queueComparator)
specifier|public
name|void
name|sort
parameter_list|(
name|Comparator
name|queueComparator
parameter_list|)
block|{
return|return;
block|}
comment|// Update the scheduler as job's state has changed
DECL|method|jobStateChanged (JobStatusChangeEvent event)
specifier|private
name|void
name|jobStateChanged
parameter_list|(
name|JobStatusChangeEvent
name|event
parameter_list|)
block|{
name|JobInProgress
name|job
init|=
name|event
operator|.
name|getJobInProgress
argument_list|()
decl_stmt|;
name|JobSchedulingInfo
name|oldJobStateInfo
init|=
operator|new
name|JobSchedulingInfo
argument_list|(
name|event
operator|.
name|getOldStatus
argument_list|()
argument_list|)
decl_stmt|;
comment|// Check if the ordering of the job has changed
comment|// For now priority and start-time can change the job ordering
if|if
condition|(
name|event
operator|.
name|getEventType
argument_list|()
operator|==
name|JobStatusChangeEvent
operator|.
name|EventType
operator|.
name|PRIORITY_CHANGED
operator|||
name|event
operator|.
name|getEventType
argument_list|()
operator|==
name|JobStatusChangeEvent
operator|.
name|EventType
operator|.
name|START_TIME_CHANGED
condition|)
block|{
comment|// Make a priority change
name|reorderJobs
argument_list|(
name|job
argument_list|,
name|oldJobStateInfo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|event
operator|.
name|getEventType
argument_list|()
operator|==
name|JobStatusChangeEvent
operator|.
name|EventType
operator|.
name|RUN_STATE_CHANGED
condition|)
block|{
comment|// Check if the job is complete
name|int
name|runState
init|=
name|job
operator|.
name|getStatus
argument_list|()
operator|.
name|getRunState
argument_list|()
decl_stmt|;
if|if
condition|(
name|runState
operator|==
name|JobStatus
operator|.
name|SUCCEEDED
operator|||
name|runState
operator|==
name|JobStatus
operator|.
name|FAILED
operator|||
name|runState
operator|==
name|JobStatus
operator|.
name|KILLED
condition|)
block|{
name|jobCompleted
argument_list|(
name|job
argument_list|,
name|oldJobStateInfo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|runState
operator|==
name|JobStatus
operator|.
name|RUNNING
condition|)
block|{
comment|// Removing of the job from job list is responsibility of the
comment|//initialization poller.
comment|// Add the job to the running queue
name|addRunningJob
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*   * Method removes the jobs from both running and waiting job queue in   * job queue manager.   */
DECL|method|jobCompleted ( JobInProgress job, JobSchedulingInfo oldInfo )
specifier|private
name|void
name|jobCompleted
parameter_list|(
name|JobInProgress
name|job
parameter_list|,
name|JobSchedulingInfo
name|oldInfo
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Job "
operator|+
name|job
operator|.
name|getJobID
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|" submitted to queue "
operator|+
name|job
operator|.
name|getProfile
argument_list|()
operator|.
name|getQueueName
argument_list|()
operator|+
literal|" has completed"
argument_list|)
expr_stmt|;
comment|//remove jobs from both queue's a job can be in
comment|//running and waiting queue at the same time.
name|removeRunningJob
argument_list|(
name|oldInfo
argument_list|)
expr_stmt|;
name|removeWaitingJob
argument_list|(
name|oldInfo
argument_list|)
expr_stmt|;
comment|// let scheduler know
name|jobCompleted
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|addChild (AbstractQueue queue)
specifier|public
name|void
name|addChild
parameter_list|(
name|AbstractQueue
name|queue
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"addChildren is not allowed for "
operator|+
literal|""
operator|+
name|getName
argument_list|()
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|distributeUnConfiguredCapacity ()
name|void
name|distributeUnConfiguredCapacity
parameter_list|()
block|{
return|return;
block|}
block|}
end_class

end_unit

