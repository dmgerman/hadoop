begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *<p/>  * http://www.apache.org/licenses/LICENSE-2.0  *<p/>  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.mapred
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|mapred
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * Parent class for hierarchy of queues.  * All queues extend this class.  *<p/>  * Even though all the Queue classes extend this class , there are 2 categories  * of queues define.  *<p/>  * 1.ContainerQueue: which are composite of queues.  * 2.JobQueue: leaf level queues.  *<p/>  * Typically ContainerQueue consists of JobQueue. All the SchedulingContext data  * in ContainerQueue is cummulative of its children.  *<p/>  * JobQueue consists of actual job list , i.e, runningJob, WaitingJob etc.  *<p/>  * This is done so to make sure that all the job related data is at one place  * and queues at higher level are typically cummulative data of organization at  * there children level.  */
end_comment

begin_class
DECL|class|AbstractQueue
specifier|abstract
class|class
name|AbstractQueue
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|AbstractQueue
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|qsc
specifier|protected
name|QueueSchedulingContext
name|qsc
decl_stmt|;
DECL|field|parent
specifier|protected
name|AbstractQueue
name|parent
decl_stmt|;
DECL|method|AbstractQueue (AbstractQueue parent, QueueSchedulingContext qsc)
specifier|protected
name|AbstractQueue
parameter_list|(
name|AbstractQueue
name|parent
parameter_list|,
name|QueueSchedulingContext
name|qsc
parameter_list|)
block|{
name|setParent
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|setQueueSchedulingContext
argument_list|(
name|qsc
argument_list|)
expr_stmt|;
comment|//Incase of root this value would be null
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|parent
operator|.
name|addChild
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This involves updating each qC structure.    *<p/>    * First update QueueSchedulingContext at this level is updated.    * then update QueueSchedulingContext of all the children.    *<p/>    * Children consider parent's capacity as the totalclustercapacity    * and do there calculations accordingly.    *    * @param mapClusterCapacity    * @param reduceClusterCapacity    */
DECL|method|update (int mapClusterCapacity, int reduceClusterCapacity)
specifier|public
name|void
name|update
parameter_list|(
name|int
name|mapClusterCapacity
parameter_list|,
name|int
name|reduceClusterCapacity
parameter_list|)
block|{
name|qsc
operator|.
name|updateContext
argument_list|(
name|mapClusterCapacity
argument_list|,
name|reduceClusterCapacity
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return qsc    */
DECL|method|getQueueSchedulingContext ()
specifier|public
name|QueueSchedulingContext
name|getQueueSchedulingContext
parameter_list|()
block|{
return|return
name|qsc
return|;
block|}
comment|/**    * Set the {@link QueueSchedulingContext} of this {@link AbstractQueue} to the    * passed context.    *     * @param qsc    */
DECL|method|setQueueSchedulingContext (QueueSchedulingContext qsc)
name|void
name|setQueueSchedulingContext
parameter_list|(
name|QueueSchedulingContext
name|qsc
parameter_list|)
block|{
name|this
operator|.
name|qsc
operator|=
name|qsc
expr_stmt|;
block|}
DECL|method|getName ()
name|String
name|getName
parameter_list|()
block|{
return|return
name|qsc
operator|.
name|getQueueName
argument_list|()
return|;
block|}
DECL|method|getParent ()
specifier|protected
name|AbstractQueue
name|getParent
parameter_list|()
block|{
return|return
name|parent
return|;
block|}
DECL|method|setParent (AbstractQueue queue)
specifier|protected
name|void
name|setParent
parameter_list|(
name|AbstractQueue
name|queue
parameter_list|)
block|{
name|this
operator|.
name|parent
operator|=
name|queue
expr_stmt|;
block|}
comment|/**    * Get a list of all the {@link JobQueue}s in the {@link AbstractQueue}    * hierarchy rooted by 'this' {@link AbstractQueue}.    *     *<p>    * The list is returned in a depth-first order in which the children of each    * {@link AbstractQueue}s in the hierarchy are already ordered.    *     * @return an unordered list containing all the job-queues in the hierarchy.    */
DECL|method|getDescendentJobQueues ()
specifier|abstract
name|List
argument_list|<
name|AbstractQueue
argument_list|>
name|getDescendentJobQueues
parameter_list|()
function_decl|;
comment|/**    * Get a list of all the {@link ContainerQueue}s in the {@link AbstractQueue}    * hierarchy rooted by 'this' {@link AbstractQueue}, excluding this queue.    *     *<p>    * The list is returned in a depth-first order in which the children of each    * {@link AbstractQueue}s in the hierarchy are already ordered.    *     * @return an unordered list containing all the container queues in the    *         hierarchy.    */
DECL|method|getDescendantContainerQueues ()
specifier|abstract
name|List
argument_list|<
name|AbstractQueue
argument_list|>
name|getDescendantContainerQueues
parameter_list|()
function_decl|;
comment|/**    * Sorts all levels below current level.    *    * @param queueComparator    */
DECL|method|sort (Comparator queueComparator)
specifier|public
specifier|abstract
name|void
name|sort
parameter_list|(
name|Comparator
name|queueComparator
parameter_list|)
function_decl|;
comment|/**    * returns list of immediate children.    * null in case of leaf.    *    * @return    */
DECL|method|getChildren ()
specifier|abstract
name|List
argument_list|<
name|AbstractQueue
argument_list|>
name|getChildren
parameter_list|()
function_decl|;
comment|/**    * adds children to the current level.    * There is no support for adding children at leaf level node.    *    * @param queue    */
DECL|method|addChild (AbstractQueue queue)
specifier|public
specifier|abstract
name|void
name|addChild
parameter_list|(
name|AbstractQueue
name|queue
parameter_list|)
function_decl|;
comment|/**    * Distribute the unconfigured capacity % among the queues.    *    */
DECL|method|distributeUnConfiguredCapacity ()
specifier|abstract
name|void
name|distributeUnConfiguredCapacity
parameter_list|()
function_decl|;
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|this
operator|.
name|getName
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|"\n"
operator|+
name|getQueueSchedulingContext
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Comparator to compare {@link AbstractQueue}s by the natural order of the    * corresponding queue names.    */
DECL|class|AbstractQueueComparator
specifier|static
class|class
name|AbstractQueueComparator
implements|implements
name|Comparator
argument_list|<
name|AbstractQueue
argument_list|>
block|{
annotation|@
name|Override
DECL|method|compare (AbstractQueue o1, AbstractQueue o2)
specifier|public
name|int
name|compare
parameter_list|(
name|AbstractQueue
name|o1
parameter_list|,
name|AbstractQueue
name|o2
parameter_list|)
block|{
return|return
name|o1
operator|.
name|getName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
comment|/**    * Returns true, if the other object is an AbstractQueue    * with the same name.    */
DECL|method|equals (Object other)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|other
operator|instanceof
name|AbstractQueue
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|AbstractQueue
name|otherQueue
init|=
operator|(
name|AbstractQueue
operator|)
name|other
decl_stmt|;
return|return
name|otherQueue
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|getName
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|this
operator|.
name|getName
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|/**    * Copy the configuration enclosed via {@link QueueSchedulingContext} of the    * destinationQueue to the sourceQueue recursively.    *     *<p>    * This method assumes that the total hierarchy of the passed queues is the    * same and that the {@link AbstractQueue#getChildren()} on this queue as well    * as the sourceQueue are sorted according to the comparator    * {@link AbstractQueueComparator} .    *     * @param AbstractQueueComparator    * @throws IOException    */
DECL|method|validateAndCopyQueueContexts (AbstractQueue sourceQueue)
name|void
name|validateAndCopyQueueContexts
parameter_list|(
name|AbstractQueue
name|sourceQueue
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Do some validation before copying.
name|QueueSchedulingContext
name|sourceContext
init|=
name|sourceQueue
operator|.
name|getQueueSchedulingContext
argument_list|()
decl_stmt|;
if|if
condition|(
name|qsc
operator|.
name|supportsPriorities
argument_list|()
operator|!=
name|sourceContext
operator|.
name|supportsPriorities
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Changing of priorities is not yet supported. "
operator|+
literal|"Attempt has been made to change priority of the queue "
operator|+
name|this
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
comment|// First update the children queues recursively.
name|List
argument_list|<
name|AbstractQueue
argument_list|>
name|destChildren
init|=
name|getChildren
argument_list|()
decl_stmt|;
if|if
condition|(
name|destChildren
operator|!=
literal|null
condition|)
block|{
name|Iterator
argument_list|<
name|AbstractQueue
argument_list|>
name|itr1
init|=
name|destChildren
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|AbstractQueue
argument_list|>
name|itr2
init|=
name|sourceQueue
operator|.
name|getChildren
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|itr1
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|itr1
operator|.
name|next
argument_list|()
operator|.
name|validateAndCopyQueueContexts
argument_list|(
name|itr2
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Now, copy the configuration for the root-queue itself
name|sourceContext
operator|.
name|setNumJobsByUser
argument_list|(
name|qsc
operator|.
name|getNumJobsByUser
argument_list|()
argument_list|)
expr_stmt|;
name|sourceContext
operator|.
name|setNumOfWaitingJobs
argument_list|(
name|qsc
operator|.
name|getNumOfWaitingJobs
argument_list|()
argument_list|)
expr_stmt|;
name|sourceContext
operator|.
name|setMapTSC
argument_list|(
name|qsc
operator|.
name|getMapTSC
argument_list|()
argument_list|)
expr_stmt|;
name|sourceContext
operator|.
name|setReduceTSC
argument_list|(
name|qsc
operator|.
name|getReduceTSC
argument_list|()
argument_list|)
expr_stmt|;
name|setQueueSchedulingContext
argument_list|(
name|sourceContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"New Queue-Context for "
operator|+
name|sourceQueue
operator|.
name|getName
argument_list|()
operator|+
literal|": "
operator|+
name|sourceQueue
operator|.
name|getQueueSchedulingContext
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

