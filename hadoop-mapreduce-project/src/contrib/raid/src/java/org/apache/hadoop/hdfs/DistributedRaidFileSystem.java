begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ChecksumException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FilterFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|raid
operator|.
name|Decoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|raid
operator|.
name|RaidNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|raid
operator|.
name|ReedSolomonDecoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|raid
operator|.
name|XORDecoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|raid
operator|.
name|protocol
operator|.
name|PolicyInfo
operator|.
name|ErasureCodeType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_comment
comment|/**  * This is an implementation of the Hadoop  RAID Filesystem. This FileSystem   * wraps an instance of the DistributedFileSystem.  * If a file is corrupted, this FileSystem uses the parity blocks to   * regenerate the bad block.  */
end_comment

begin_class
DECL|class|DistributedRaidFileSystem
specifier|public
class|class
name|DistributedRaidFileSystem
extends|extends
name|FilterFileSystem
block|{
comment|// these are alternate locations that can be used for read-only access
DECL|field|alternates
name|DecodeInfo
index|[]
name|alternates
decl_stmt|;
DECL|field|conf
name|Configuration
name|conf
decl_stmt|;
DECL|field|stripeLength
name|int
name|stripeLength
decl_stmt|;
DECL|method|DistributedRaidFileSystem ()
name|DistributedRaidFileSystem
parameter_list|()
throws|throws
name|IOException
block|{   }
DECL|method|DistributedRaidFileSystem (FileSystem fs)
name|DistributedRaidFileSystem
parameter_list|(
name|FileSystem
name|fs
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|alternates
operator|=
literal|null
expr_stmt|;
name|stripeLength
operator|=
literal|0
expr_stmt|;
block|}
comment|// Information required for decoding a source file
DECL|class|DecodeInfo
specifier|static
specifier|private
class|class
name|DecodeInfo
block|{
DECL|field|destPath
specifier|final
name|Path
name|destPath
decl_stmt|;
DECL|field|type
specifier|final
name|ErasureCodeType
name|type
decl_stmt|;
DECL|field|conf
specifier|final
name|Configuration
name|conf
decl_stmt|;
DECL|field|stripeLength
specifier|final
name|int
name|stripeLength
decl_stmt|;
DECL|method|DecodeInfo (Configuration conf, ErasureCodeType type, Path destPath)
specifier|private
name|DecodeInfo
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|ErasureCodeType
name|type
parameter_list|,
name|Path
name|destPath
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|this
operator|.
name|destPath
operator|=
name|destPath
expr_stmt|;
name|this
operator|.
name|stripeLength
operator|=
name|RaidNode
operator|.
name|getStripeLength
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
DECL|method|createDecoder ()
name|Decoder
name|createDecoder
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|type
operator|==
name|ErasureCodeType
operator|.
name|XOR
condition|)
block|{
return|return
operator|new
name|XORDecoder
argument_list|(
name|conf
argument_list|,
name|stripeLength
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|this
operator|.
name|type
operator|==
name|ErasureCodeType
operator|.
name|RS
condition|)
block|{
return|return
operator|new
name|ReedSolomonDecoder
argument_list|(
name|conf
argument_list|,
name|stripeLength
argument_list|,
name|RaidNode
operator|.
name|rsParityLength
argument_list|(
name|conf
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/* Initialize a Raid FileSystem    */
DECL|method|initialize (URI name, Configuration conf)
specifier|public
name|void
name|initialize
parameter_list|(
name|URI
name|name
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|conf
operator|.
name|getClass
argument_list|(
literal|"fs.raid.underlyingfs.impl"
argument_list|,
name|DistributedFileSystem
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|clazz
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No FileSystem for fs.raid.underlyingfs.impl."
argument_list|)
throw|;
block|}
name|this
operator|.
name|fs
operator|=
operator|(
name|FileSystem
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|clazz
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|super
operator|.
name|initialize
argument_list|(
name|name
argument_list|,
name|conf
argument_list|)
expr_stmt|;
comment|// find stripe length configured
name|stripeLength
operator|=
name|RaidNode
operator|.
name|getStripeLength
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|stripeLength
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"dfs.raid.stripeLength is incorrectly defined to be "
operator|+
name|stripeLength
operator|+
literal|" Ignoring..."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Put XOR and RS in alternates
name|alternates
operator|=
operator|new
name|DecodeInfo
index|[
literal|2
index|]
expr_stmt|;
name|Path
name|xorPath
init|=
name|RaidNode
operator|.
name|xorDestinationPath
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|)
decl_stmt|;
name|alternates
index|[
literal|0
index|]
operator|=
operator|new
name|DecodeInfo
argument_list|(
name|conf
argument_list|,
name|ErasureCodeType
operator|.
name|XOR
argument_list|,
name|xorPath
argument_list|)
expr_stmt|;
name|Path
name|rsPath
init|=
name|RaidNode
operator|.
name|rsDestinationPath
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|)
decl_stmt|;
name|alternates
index|[
literal|1
index|]
operator|=
operator|new
name|DecodeInfo
argument_list|(
name|conf
argument_list|,
name|ErasureCodeType
operator|.
name|RS
argument_list|,
name|rsPath
argument_list|)
expr_stmt|;
block|}
comment|/*    * Returns the underlying filesystem    */
DECL|method|getFileSystem ()
specifier|public
name|FileSystem
name|getFileSystem
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|fs
return|;
block|}
annotation|@
name|Override
DECL|method|open (Path f, int bufferSize)
specifier|public
name|FSDataInputStream
name|open
parameter_list|(
name|Path
name|f
parameter_list|,
name|int
name|bufferSize
parameter_list|)
throws|throws
name|IOException
block|{
name|ExtFSDataInputStream
name|fd
init|=
operator|new
name|ExtFSDataInputStream
argument_list|(
name|conf
argument_list|,
name|this
argument_list|,
name|alternates
argument_list|,
name|f
argument_list|,
name|stripeLength
argument_list|,
name|bufferSize
argument_list|)
decl_stmt|;
return|return
name|fd
return|;
block|}
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|fs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
comment|//this might already be closed, ignore
block|}
block|}
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Layered filesystem input stream. This input stream tries reading    * from alternate locations if it encoumters read errors in the primary location.    */
DECL|class|ExtFSDataInputStream
specifier|private
specifier|static
class|class
name|ExtFSDataInputStream
extends|extends
name|FSDataInputStream
block|{
DECL|class|UnderlyingBlock
specifier|private
specifier|static
class|class
name|UnderlyingBlock
block|{
comment|// File that holds this block. Need not be the same as outer file.
DECL|field|path
specifier|public
name|Path
name|path
decl_stmt|;
comment|// Offset within path where this block starts.
DECL|field|actualFileOffset
specifier|public
name|long
name|actualFileOffset
decl_stmt|;
comment|// Offset within the outer file where this block starts.
DECL|field|originalFileOffset
specifier|public
name|long
name|originalFileOffset
decl_stmt|;
comment|// Length of the block (length<= blk sz of outer file).
DECL|field|length
specifier|public
name|long
name|length
decl_stmt|;
DECL|method|UnderlyingBlock (Path path, long actualFileOffset, long originalFileOffset, long length)
specifier|public
name|UnderlyingBlock
parameter_list|(
name|Path
name|path
parameter_list|,
name|long
name|actualFileOffset
parameter_list|,
name|long
name|originalFileOffset
parameter_list|,
name|long
name|length
parameter_list|)
block|{
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|actualFileOffset
operator|=
name|actualFileOffset
expr_stmt|;
name|this
operator|.
name|originalFileOffset
operator|=
name|originalFileOffset
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|length
expr_stmt|;
block|}
block|}
comment|/**      * Create an input stream that wraps all the reads/positions/seeking.      */
DECL|class|ExtFsInputStream
specifier|private
specifier|static
class|class
name|ExtFsInputStream
extends|extends
name|FSInputStream
block|{
comment|// Extents of "good" underlying data that can be read.
DECL|field|underlyingBlocks
specifier|private
name|UnderlyingBlock
index|[]
name|underlyingBlocks
decl_stmt|;
DECL|field|currentOffset
specifier|private
name|long
name|currentOffset
decl_stmt|;
DECL|field|currentStream
specifier|private
name|FSDataInputStream
name|currentStream
decl_stmt|;
DECL|field|currentBlock
specifier|private
name|UnderlyingBlock
name|currentBlock
decl_stmt|;
DECL|field|oneBytebuff
specifier|private
name|byte
index|[]
name|oneBytebuff
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
DECL|field|nextLocation
specifier|private
name|int
name|nextLocation
decl_stmt|;
DECL|field|lfs
specifier|private
name|DistributedRaidFileSystem
name|lfs
decl_stmt|;
DECL|field|path
specifier|private
name|Path
name|path
decl_stmt|;
DECL|field|stat
specifier|private
name|FileStatus
name|stat
decl_stmt|;
DECL|field|alternates
specifier|private
specifier|final
name|DecodeInfo
index|[]
name|alternates
decl_stmt|;
DECL|field|buffersize
specifier|private
specifier|final
name|int
name|buffersize
decl_stmt|;
DECL|field|conf
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
DECL|field|stripeLength
specifier|private
specifier|final
name|int
name|stripeLength
decl_stmt|;
DECL|method|ExtFsInputStream (Configuration conf, DistributedRaidFileSystem lfs, DecodeInfo[] alternates, Path path, int stripeLength, int buffersize)
name|ExtFsInputStream
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|DistributedRaidFileSystem
name|lfs
parameter_list|,
name|DecodeInfo
index|[]
name|alternates
parameter_list|,
name|Path
name|path
parameter_list|,
name|int
name|stripeLength
parameter_list|,
name|int
name|buffersize
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|nextLocation
operator|=
literal|0
expr_stmt|;
comment|// Construct array of blocks in file.
name|this
operator|.
name|stat
operator|=
name|lfs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|long
name|numBlocks
init|=
operator|(
name|this
operator|.
name|stat
operator|.
name|getLen
argument_list|()
operator|%
name|this
operator|.
name|stat
operator|.
name|getBlockSize
argument_list|()
operator|==
literal|0
operator|)
condition|?
name|this
operator|.
name|stat
operator|.
name|getLen
argument_list|()
operator|/
name|this
operator|.
name|stat
operator|.
name|getBlockSize
argument_list|()
else|:
literal|1
operator|+
name|this
operator|.
name|stat
operator|.
name|getLen
argument_list|()
operator|/
name|this
operator|.
name|stat
operator|.
name|getBlockSize
argument_list|()
decl_stmt|;
name|this
operator|.
name|underlyingBlocks
operator|=
operator|new
name|UnderlyingBlock
index|[
operator|(
name|int
operator|)
name|numBlocks
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numBlocks
condition|;
name|i
operator|++
control|)
block|{
name|long
name|actualFileOffset
init|=
name|i
operator|*
name|stat
operator|.
name|getBlockSize
argument_list|()
decl_stmt|;
name|long
name|originalFileOffset
init|=
name|i
operator|*
name|stat
operator|.
name|getBlockSize
argument_list|()
decl_stmt|;
name|long
name|length
init|=
name|Math
operator|.
name|min
argument_list|(
name|stat
operator|.
name|getBlockSize
argument_list|()
argument_list|,
name|stat
operator|.
name|getLen
argument_list|()
operator|-
name|originalFileOffset
argument_list|)
decl_stmt|;
name|this
operator|.
name|underlyingBlocks
index|[
name|i
index|]
operator|=
operator|new
name|UnderlyingBlock
argument_list|(
name|path
argument_list|,
name|actualFileOffset
argument_list|,
name|originalFileOffset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|currentOffset
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|currentBlock
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|alternates
operator|=
name|alternates
expr_stmt|;
name|this
operator|.
name|buffersize
operator|=
name|buffersize
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|lfs
operator|=
name|lfs
expr_stmt|;
name|this
operator|.
name|stripeLength
operator|=
name|stripeLength
expr_stmt|;
comment|// Open a stream to the first block.
name|openCurrentStream
argument_list|()
expr_stmt|;
block|}
DECL|method|closeCurrentStream ()
specifier|private
name|void
name|closeCurrentStream
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentStream
operator|!=
literal|null
condition|)
block|{
name|currentStream
operator|.
name|close
argument_list|()
expr_stmt|;
name|currentStream
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**        * Open a stream to the file containing the current block        * and seek to the appropriate offset        */
DECL|method|openCurrentStream ()
specifier|private
name|void
name|openCurrentStream
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|blockIdx
init|=
call|(
name|int
call|)
argument_list|(
name|currentOffset
operator|/
name|stat
operator|.
name|getBlockSize
argument_list|()
argument_list|)
decl_stmt|;
name|UnderlyingBlock
name|block
init|=
name|underlyingBlocks
index|[
name|blockIdx
index|]
decl_stmt|;
comment|// If the current path is the same as we want.
if|if
condition|(
name|currentBlock
operator|==
name|block
operator|||
name|currentBlock
operator|!=
literal|null
operator|&&
name|currentBlock
operator|.
name|path
operator|==
name|block
operator|.
name|path
condition|)
block|{
comment|// If we have a valid stream, nothing to do.
if|if
condition|(
name|currentStream
operator|!=
literal|null
condition|)
block|{
name|currentBlock
operator|=
name|block
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|closeCurrentStream
argument_list|()
expr_stmt|;
block|}
name|currentBlock
operator|=
name|block
expr_stmt|;
name|currentStream
operator|=
name|lfs
operator|.
name|fs
operator|.
name|open
argument_list|(
name|currentBlock
operator|.
name|path
argument_list|,
name|buffersize
argument_list|)
expr_stmt|;
name|long
name|offset
init|=
name|block
operator|.
name|actualFileOffset
operator|+
operator|(
name|currentOffset
operator|-
name|block
operator|.
name|originalFileOffset
operator|)
decl_stmt|;
name|currentStream
operator|.
name|seek
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/**        * Returns the number of bytes available in the current block.        */
DECL|method|blockAvailable ()
specifier|private
name|int
name|blockAvailable
parameter_list|()
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|currentBlock
operator|.
name|length
operator|-
operator|(
name|currentOffset
operator|-
name|currentBlock
operator|.
name|originalFileOffset
operator|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|available ()
specifier|public
specifier|synchronized
name|int
name|available
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Application should not assume that any bytes are buffered here.
name|nextLocation
operator|=
literal|0
expr_stmt|;
return|return
name|Math
operator|.
name|min
argument_list|(
name|blockAvailable
argument_list|()
argument_list|,
name|currentStream
operator|.
name|available
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|closeCurrentStream
argument_list|()
expr_stmt|;
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|markSupported ()
specifier|public
name|boolean
name|markSupported
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|mark (int readLimit)
specifier|public
name|void
name|mark
parameter_list|(
name|int
name|readLimit
parameter_list|)
block|{
comment|// Mark and reset are not supported.
name|nextLocation
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|reset ()
specifier|public
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Mark and reset are not supported.
name|nextLocation
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|read ()
specifier|public
specifier|synchronized
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|value
init|=
name|read
argument_list|(
name|oneBytebuff
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
return|return
name|value
return|;
block|}
else|else
block|{
return|return
name|oneBytebuff
index|[
literal|0
index|]
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|read (byte[] b)
specifier|public
specifier|synchronized
name|int
name|read
parameter_list|(
name|byte
index|[]
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|value
init|=
name|read
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
decl_stmt|;
name|nextLocation
operator|=
literal|0
expr_stmt|;
return|return
name|value
return|;
block|}
annotation|@
name|Override
DECL|method|read (byte[] b, int offset, int len)
specifier|public
specifier|synchronized
name|int
name|read
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|openCurrentStream
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|limit
init|=
name|Math
operator|.
name|min
argument_list|(
name|blockAvailable
argument_list|()
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|int
name|value
init|=
name|currentStream
operator|.
name|read
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|limit
argument_list|)
decl_stmt|;
name|currentOffset
operator|+=
name|value
expr_stmt|;
name|nextLocation
operator|=
literal|0
expr_stmt|;
return|return
name|value
return|;
block|}
catch|catch
parameter_list|(
name|BlockMissingException
name|e
parameter_list|)
block|{
name|setAlternateLocations
argument_list|(
name|e
argument_list|,
name|currentOffset
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ChecksumException
name|e
parameter_list|)
block|{
name|setAlternateLocations
argument_list|(
name|e
argument_list|,
name|currentOffset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|read (long position, byte[] b, int offset, int len)
specifier|public
specifier|synchronized
name|int
name|read
parameter_list|(
name|long
name|position
parameter_list|,
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|oldPos
init|=
name|currentOffset
decl_stmt|;
name|seek
argument_list|(
name|position
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|read
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
return|;
block|}
finally|finally
block|{
name|seek
argument_list|(
name|oldPos
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|skip (long n)
specifier|public
specifier|synchronized
name|long
name|skip
parameter_list|(
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|skipped
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|skipped
operator|<
name|n
condition|)
block|{
name|int
name|val
init|=
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
break|break;
block|}
name|skipped
operator|++
expr_stmt|;
block|}
name|nextLocation
operator|=
literal|0
expr_stmt|;
return|return
name|skipped
return|;
block|}
annotation|@
name|Override
DECL|method|getPos ()
specifier|public
specifier|synchronized
name|long
name|getPos
parameter_list|()
throws|throws
name|IOException
block|{
name|nextLocation
operator|=
literal|0
expr_stmt|;
return|return
name|currentOffset
return|;
block|}
annotation|@
name|Override
DECL|method|seek (long pos)
specifier|public
specifier|synchronized
name|void
name|seek
parameter_list|(
name|long
name|pos
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pos
operator|!=
name|currentOffset
condition|)
block|{
name|closeCurrentStream
argument_list|()
expr_stmt|;
name|currentOffset
operator|=
name|pos
expr_stmt|;
name|openCurrentStream
argument_list|()
expr_stmt|;
block|}
name|nextLocation
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|seekToNewSource (long targetPos)
specifier|public
name|boolean
name|seekToNewSource
parameter_list|(
name|long
name|targetPos
parameter_list|)
throws|throws
name|IOException
block|{
name|seek
argument_list|(
name|targetPos
argument_list|)
expr_stmt|;
name|boolean
name|value
init|=
name|currentStream
operator|.
name|seekToNewSource
argument_list|(
name|currentStream
operator|.
name|getPos
argument_list|()
argument_list|)
decl_stmt|;
name|nextLocation
operator|=
literal|0
expr_stmt|;
return|return
name|value
return|;
block|}
comment|/**        * position readable again.        */
annotation|@
name|Override
DECL|method|readFully (long pos, byte[] b, int offset, int length)
specifier|public
name|void
name|readFully
parameter_list|(
name|long
name|pos
parameter_list|,
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|oldPos
init|=
name|currentOffset
decl_stmt|;
name|seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
comment|// This loop retries reading until successful. Unrecoverable errors
comment|// cause exceptions.
comment|// currentOffset is changed by read().
try|try
block|{
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|int
name|n
init|=
name|read
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Premature EOF"
argument_list|)
throw|;
block|}
name|offset
operator|+=
name|n
expr_stmt|;
name|length
operator|-=
name|n
expr_stmt|;
block|}
name|nextLocation
operator|=
literal|0
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|BlockMissingException
name|e
parameter_list|)
block|{
name|setAlternateLocations
argument_list|(
name|e
argument_list|,
name|currentOffset
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ChecksumException
name|e
parameter_list|)
block|{
name|setAlternateLocations
argument_list|(
name|e
argument_list|,
name|currentOffset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|seek
argument_list|(
name|oldPos
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|readFully (long pos, byte[] b)
specifier|public
name|void
name|readFully
parameter_list|(
name|long
name|pos
parameter_list|,
name|byte
index|[]
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|readFully
argument_list|(
name|pos
argument_list|,
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|length
argument_list|)
expr_stmt|;
name|nextLocation
operator|=
literal|0
expr_stmt|;
block|}
comment|/**        * Extract good block from RAID        * @throws IOException if all alternate locations are exhausted        */
DECL|method|setAlternateLocations (IOException curexp, long offset)
specifier|private
name|void
name|setAlternateLocations
parameter_list|(
name|IOException
name|curexp
parameter_list|,
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
name|alternates
operator|!=
literal|null
operator|&&
name|nextLocation
operator|<
name|alternates
operator|.
name|length
condition|)
block|{
try|try
block|{
name|int
name|idx
init|=
name|nextLocation
operator|++
decl_stmt|;
comment|// Start offset of block.
name|long
name|corruptOffset
init|=
operator|(
name|offset
operator|/
name|stat
operator|.
name|getBlockSize
argument_list|()
operator|)
operator|*
name|stat
operator|.
name|getBlockSize
argument_list|()
decl_stmt|;
comment|// Make sure we use DFS and not DistributedRaidFileSystem for unRaid.
name|Configuration
name|clientConf
init|=
operator|new
name|Configuration
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|conf
operator|.
name|getClass
argument_list|(
literal|"fs.raid.underlyingfs.impl"
argument_list|,
name|DistributedFileSystem
operator|.
name|class
argument_list|)
decl_stmt|;
name|clientConf
operator|.
name|set
argument_list|(
literal|"fs.hdfs.impl"
argument_list|,
name|clazz
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Disable caching so that a previously cached RaidDfs is not used.
name|clientConf
operator|.
name|setBoolean
argument_list|(
literal|"fs.hdfs.impl.disable.cache"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Path
name|npath
init|=
name|RaidNode
operator|.
name|unRaidCorruptBlock
argument_list|(
name|clientConf
argument_list|,
name|path
argument_list|,
name|alternates
index|[
name|idx
index|]
operator|.
name|destPath
argument_list|,
name|alternates
index|[
name|idx
index|]
operator|.
name|createDecoder
argument_list|()
argument_list|,
name|stripeLength
argument_list|,
name|corruptOffset
argument_list|)
decl_stmt|;
if|if
condition|(
name|npath
operator|==
literal|null
condition|)
continue|continue;
try|try
block|{
name|String
name|outdir
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"fs.raid.recoverylogdir"
argument_list|)
decl_stmt|;
if|if
condition|(
name|outdir
operator|!=
literal|null
condition|)
block|{
name|DateFormat
name|dateFormat
init|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"yyyy-MM-dd-HH-mm-ss"
argument_list|)
decl_stmt|;
name|java
operator|.
name|util
operator|.
name|Date
name|date
init|=
operator|new
name|java
operator|.
name|util
operator|.
name|Date
argument_list|()
decl_stmt|;
name|String
name|fname
init|=
name|path
operator|.
name|getName
argument_list|()
operator|+
name|dateFormat
operator|.
name|format
argument_list|(
name|date
argument_list|)
operator|+
operator|(
operator|new
name|Random
argument_list|()
operator|)
operator|.
name|nextInt
argument_list|()
operator|+
literal|".txt"
decl_stmt|;
name|Path
name|outputunraid
init|=
operator|new
name|Path
argument_list|(
name|outdir
argument_list|,
name|fname
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|outputunraid
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FSDataOutputStream
name|dout
init|=
name|fs
operator|.
name|create
argument_list|(
name|outputunraid
argument_list|)
decl_stmt|;
name|PrintStream
name|ps
init|=
operator|new
name|PrintStream
argument_list|(
name|dout
argument_list|)
decl_stmt|;
name|ps
operator|.
name|println
argument_list|(
literal|"Recovery attempt log"
argument_list|)
expr_stmt|;
name|ps
operator|.
name|println
argument_list|(
literal|"Source path : "
operator|+
name|path
argument_list|)
expr_stmt|;
name|ps
operator|.
name|println
argument_list|(
literal|"Alternate path : "
operator|+
name|alternates
index|[
name|idx
index|]
operator|.
name|destPath
argument_list|)
expr_stmt|;
name|ps
operator|.
name|println
argument_list|(
literal|"Stripe lentgh : "
operator|+
name|stripeLength
argument_list|)
expr_stmt|;
name|ps
operator|.
name|println
argument_list|(
literal|"Corrupt offset : "
operator|+
name|corruptOffset
argument_list|)
expr_stmt|;
name|String
name|output
init|=
operator|(
name|npath
operator|==
literal|null
operator|)
condition|?
literal|"UNSUCCESSFUL"
else|:
name|npath
operator|.
name|toString
argument_list|()
decl_stmt|;
name|ps
operator|.
name|println
argument_list|(
literal|"Output from unRaid : "
operator|+
name|output
argument_list|)
expr_stmt|;
name|ps
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|exc
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Error while creating recovery log: "
operator|+
name|exc
argument_list|)
expr_stmt|;
block|}
name|closeCurrentStream
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Using block at offset "
operator|+
name|corruptOffset
operator|+
literal|" from "
operator|+
name|npath
argument_list|)
expr_stmt|;
name|currentBlock
operator|.
name|path
operator|=
name|npath
expr_stmt|;
name|currentBlock
operator|.
name|actualFileOffset
operator|=
literal|0
expr_stmt|;
comment|// Single block in file.
comment|// Dont change currentOffset, in case the user had done a seek?
name|openCurrentStream
argument_list|()
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Error in using alternate path "
operator|+
name|path
operator|+
literal|". "
operator|+
name|e
operator|+
literal|" Ignoring..."
argument_list|)
expr_stmt|;
block|}
block|}
throw|throw
name|curexp
throw|;
block|}
comment|/**        * The name of the file system that is immediately below the        * DistributedRaidFileSystem. This is specified by the        * configuration parameter called fs.raid.underlyingfs.impl.        * If this parameter is not specified in the configuration, then        * the default class DistributedFileSystem is returned.        * @param conf the configuration object        * @return the filesystem object immediately below DistributedRaidFileSystem        * @throws IOException if all alternate locations are exhausted        */
DECL|method|getUnderlyingFileSystem (Configuration conf)
specifier|private
name|FileSystem
name|getUnderlyingFileSystem
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|conf
operator|.
name|getClass
argument_list|(
literal|"fs.raid.underlyingfs.impl"
argument_list|,
name|DistributedFileSystem
operator|.
name|class
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
operator|(
name|FileSystem
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|clazz
argument_list|,
name|conf
argument_list|)
decl_stmt|;
return|return
name|fs
return|;
block|}
block|}
comment|/**      * constructor for ext input stream.      * @param fs the underlying filesystem      * @param p the path in the underlying file system      * @param buffersize the size of IO      * @throws IOException      */
DECL|method|ExtFSDataInputStream (Configuration conf, DistributedRaidFileSystem lfs, DecodeInfo[] alternates, Path p, int stripeLength, int buffersize)
specifier|public
name|ExtFSDataInputStream
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|DistributedRaidFileSystem
name|lfs
parameter_list|,
name|DecodeInfo
index|[]
name|alternates
parameter_list|,
name|Path
name|p
parameter_list|,
name|int
name|stripeLength
parameter_list|,
name|int
name|buffersize
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
operator|new
name|ExtFsInputStream
argument_list|(
name|conf
argument_list|,
name|lfs
argument_list|,
name|alternates
argument_list|,
name|p
argument_list|,
name|stripeLength
argument_list|,
name|buffersize
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

