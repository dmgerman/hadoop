begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|LimitedPrivate
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
operator|.
name|CreateOpts
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
operator|.
name|Rename
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_comment
comment|/**  * The FileContext class provides an interface to the application writer for  * using the Hadoop filesystem.  * It provides a set of methods for the usual operation: create, open,   * list, etc   *   *<p>  *<b> *** Path Names ***</b>  *<p>  *   * The Hadoop filesystem supports a URI name space and URI names.  * It offers a a forest of filesystems that can be referenced using fully  * qualified URIs.  * Two common Hadoop filesystems implementations are  *<ul>  *<li> the local filesystem: file:///path  *<li> the hdfs filesystem hdfs://nnAddress:nnPort/path  *</ul>    * While URI names are very flexible, it requires knowing the name or address  * of the server. For convenience one often wants to access the default system  * in one's environment without knowing its name/address. This has an  * additional benefit that it allows one to change one's default fs  *  (e.g. admin moves application from cluster1 to cluster2).  *<p>  * To facilitate this, Hadoop supports a notion of a default filesystem.  * The user can set his default filesystem, although this is  * typically set up for you in your environment via your default config.  * A default filesystem implies a default scheme and authority; slash-relative  * names (such as /for/bar) are resolved relative to that default FS.  * Similarly a user can also have working-directory-relative names (i.e. names  * not starting with a slash). While the working directory is generally in the  * same default FS, the wd can be in a different FS.  *<p>  *  Hence Hadoop path names can be one of:  *<ul>  *<li> fully qualified URI:  scheme://authority/path  *<li> slash relative names: /path    - relative to the default filesystem  *<li> wd-relative names:    path        - relative to the working dir  *</ul>     *  Relative paths with scheme (scheme:foo/bar) are illegal.  *<p>  *<b>****The Role of the FileContext and configuration defaults****</b>  *<p>  *  The FileContext provides file namespace context for resolving file names;  *  it also contains the umask for permissions, In that sense it is like the  *  per-process file-related state in Unix system.  *  These two properties  *<ul>   *<li> default file system i.e your slash)  *<li> umask  *</ul>  *   in general, are obtained from the default configuration file  *  in your environment,  (@see {@link Configuration}).  *  No other configuration parameters are obtained from the default config as   *  far as the file context layer is concerned. All filesystem instances  *  (i.e. deployments of filesystems) have default properties; we call these  *  server side (SS) defaults. Operation like create allow one to select many   *  properties: either pass them in as explicit parameters or use  *  the SS properties.  *<p>  *  The filesystem related SS defaults are  *<ul>  *<li> the home directory (default is "/user/userName")  *<li> the initial wd (only for local fs)  *<li> replication factor  *<li> block size  *<li> buffer size  *<li> bytesPerChecksum (if used).  *</ul>  *  *<p>  *<b> *** Usage Model for the FileContext class ***</b>  *<p>  * Example 1: use the default config read from the $HADOOP_CONFIG/core.xml.  *   Unspecified values come from core-defaults.xml in the release jar.  *<ul>    *<li> myFContext = FileContext.getFileContext(); // uses the default config  *                                                // which has your default FS   *<li>  myFContext.create(path, ...);  *<li>  myFContext.setWorkingDir(path)  *<li>  myFContext.open (path, ...);    *</ul>    * Example 2: Get a FileContext with a specific URI as the default FS  *<ul>    *<li> myFContext = FileContext.getFileContext(URI)  *<li> myFContext.create(path, ...);  *   ...  *</ul>   * Example 3: FileContext with local file system as the default  *<ul>   *<li> myFContext = FileContext.getLocalFSFileContext()  *<li> myFContext.create(path, ...);  *<li> ...  *</ul>   * Example 4: Use a specific config, ignoring $HADOOP_CONFIG  *  Generally you should not need use a config unless you are doing  *<ul>   *<li> configX = someConfigSomeOnePassedToYou.  *<li> myFContext = getFileContext(configX); //configX not changed but passeddown  *<li> myFContext.create(path, ...);  *<li>...  *</ul>                                            *      */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
comment|/*Evolving for a release,to be changed to Stable */
DECL|class|FileContext
specifier|public
specifier|final
class|class
name|FileContext
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FileContext
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEFAULT_PERM
specifier|public
specifier|static
specifier|final
name|FsPermission
name|DEFAULT_PERM
init|=
name|FsPermission
operator|.
name|getDefault
argument_list|()
decl_stmt|;
DECL|field|localFsSingleton
specifier|volatile
specifier|private
specifier|static
name|FileContext
name|localFsSingleton
init|=
literal|null
decl_stmt|;
comment|/**    * List of files that should be deleted on JVM shutdown.    */
DECL|field|DELETE_ON_EXIT
specifier|static
specifier|final
name|Map
argument_list|<
name|FileContext
argument_list|,
name|Set
argument_list|<
name|Path
argument_list|>
argument_list|>
name|DELETE_ON_EXIT
init|=
operator|new
name|IdentityHashMap
argument_list|<
name|FileContext
argument_list|,
name|Set
argument_list|<
name|Path
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/** JVM shutdown hook thread. */
DECL|field|FINALIZER
specifier|static
specifier|final
name|FileContextFinalizer
name|FINALIZER
init|=
operator|new
name|FileContextFinalizer
argument_list|()
decl_stmt|;
DECL|field|DEFAULT_FILTER
specifier|private
specifier|static
specifier|final
name|PathFilter
name|DEFAULT_FILTER
init|=
operator|new
name|PathFilter
argument_list|()
block|{
specifier|public
name|boolean
name|accept
parameter_list|(
specifier|final
name|Path
name|file
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
decl_stmt|;
comment|/**    * The FileContext is defined by.    *  1) defaultFS (slash)    *  2) wd    *  3) umask    */
DECL|field|defaultFS
specifier|private
specifier|final
name|AbstractFileSystem
name|defaultFS
decl_stmt|;
comment|//default FS for this FileContext.
DECL|field|workingDir
specifier|private
name|Path
name|workingDir
decl_stmt|;
comment|// Fully qualified
DECL|field|umask
specifier|private
name|FsPermission
name|umask
decl_stmt|;
DECL|field|conf
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
DECL|method|FileContext (final AbstractFileSystem defFs, final FsPermission theUmask, final Configuration aConf)
specifier|private
name|FileContext
parameter_list|(
specifier|final
name|AbstractFileSystem
name|defFs
parameter_list|,
specifier|final
name|FsPermission
name|theUmask
parameter_list|,
specifier|final
name|Configuration
name|aConf
parameter_list|)
block|{
name|defaultFS
operator|=
name|defFs
expr_stmt|;
name|umask
operator|=
name|FsPermission
operator|.
name|getUMask
argument_list|(
name|aConf
argument_list|)
expr_stmt|;
name|conf
operator|=
name|aConf
expr_stmt|;
comment|/*      * Init the wd.      * WorkingDir is implemented at the FileContext layer       * NOT at the AbstractFileSystem layer.       * If the DefaultFS, such as localFilesystem has a notion of      *  builtin WD, we use that as the initial WD.      *  Otherwise the WD is initialized to the home directory.      */
name|workingDir
operator|=
name|defaultFS
operator|.
name|getInitialWorkingDirectory
argument_list|()
expr_stmt|;
if|if
condition|(
name|workingDir
operator|==
literal|null
condition|)
block|{
name|workingDir
operator|=
name|defaultFS
operator|.
name|getHomeDirectory
argument_list|()
expr_stmt|;
block|}
name|util
operator|=
operator|new
name|Util
argument_list|()
expr_stmt|;
comment|// for the inner class
block|}
comment|/*     * Remove relative part - return "absolute":    * If input is relative path ("foo/bar") add wd: ie "/<workingDir>/foo/bar"    * A fully qualified uri ("hdfs://nn:p/foo/bar") or a slash-relative path    * ("/foo/bar") are returned unchanged.    *     * Applications that use FileContext should use #makeQualified() since    * they really want a fully qualified URI.    * Hence this method os not called makeAbsolute() and     * has been deliberately declared private.    */
DECL|method|fixRelativePart (Path f)
specifier|private
name|Path
name|fixRelativePart
parameter_list|(
name|Path
name|f
parameter_list|)
block|{
if|if
condition|(
name|f
operator|.
name|isUriPathAbsolute
argument_list|()
condition|)
block|{
return|return
name|f
return|;
block|}
else|else
block|{
return|return
operator|new
name|Path
argument_list|(
name|workingDir
argument_list|,
name|f
argument_list|)
return|;
block|}
block|}
comment|/**    * Delete all the paths that were marked as delete-on-exit.    */
DECL|method|processDeleteOnExit ()
specifier|static
name|void
name|processDeleteOnExit
parameter_list|()
block|{
synchronized|synchronized
init|(
name|DELETE_ON_EXIT
init|)
block|{
name|Set
argument_list|<
name|Entry
argument_list|<
name|FileContext
argument_list|,
name|Set
argument_list|<
name|Path
argument_list|>
argument_list|>
argument_list|>
name|set
init|=
name|DELETE_ON_EXIT
operator|.
name|entrySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|FileContext
argument_list|,
name|Set
argument_list|<
name|Path
argument_list|>
argument_list|>
name|entry
range|:
name|set
control|)
block|{
name|FileContext
name|fc
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Path
argument_list|>
name|paths
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
for|for
control|(
name|Path
name|path
range|:
name|paths
control|)
block|{
try|try
block|{
name|fc
operator|.
name|delete
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Ignoring failure to deleteOnExit for path "
operator|+
name|path
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|DELETE_ON_EXIT
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Pathnames with scheme and relative path are illegal.    * @param path to be checked    * @throws IllegalArgumentException if of type scheme:foo/bar    */
DECL|method|checkNotSchemeWithRelative (final Path path)
specifier|private
specifier|static
name|void
name|checkNotSchemeWithRelative
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|toUri
argument_list|()
operator|.
name|isAbsolute
argument_list|()
operator|&&
operator|!
name|path
operator|.
name|isUriPathAbsolute
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unsupported name: has scheme but relative path-part"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get the filesystem of supplied path.    * @param absOrFqPath - absolute or fully qualified path    * @return the filesystem of the path    * @throws IOException    */
DECL|method|getFSofPath (final Path absOrFqPath)
specifier|private
name|AbstractFileSystem
name|getFSofPath
parameter_list|(
specifier|final
name|Path
name|absOrFqPath
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotSchemeWithRelative
argument_list|(
name|absOrFqPath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|absOrFqPath
operator|.
name|isAbsolute
argument_list|()
operator|&&
name|absOrFqPath
operator|.
name|toUri
argument_list|()
operator|.
name|getScheme
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"FileContext Bug: path is relative"
argument_list|)
throw|;
block|}
try|try
block|{
comment|// Is it the default FS for this FileContext?
name|defaultFS
operator|.
name|checkPath
argument_list|(
name|absOrFqPath
argument_list|)
expr_stmt|;
return|return
name|defaultFS
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// it is different FileSystem
return|return
name|AbstractFileSystem
operator|.
name|get
argument_list|(
name|absOrFqPath
operator|.
name|toUri
argument_list|()
argument_list|,
name|conf
argument_list|)
return|;
block|}
block|}
comment|/**    * Protected Static Factory methods for getting a FileContexts    * that take a AbstractFileSystem as input. To be used for testing.    */
comment|/**    * Create a FileContext with specified FS as default     * using the specified config.    *     * @param defFS    * @param aConf    * @return new FileContext with specifed FS as default.    * @throws IOException if the filesystem with specified cannot be created    */
DECL|method|getFileContext (final AbstractFileSystem defFS, final Configuration aConf)
specifier|protected
specifier|static
name|FileContext
name|getFileContext
parameter_list|(
specifier|final
name|AbstractFileSystem
name|defFS
parameter_list|,
specifier|final
name|Configuration
name|aConf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|FileContext
argument_list|(
name|defFS
argument_list|,
name|FsPermission
operator|.
name|getUMask
argument_list|(
name|aConf
argument_list|)
argument_list|,
name|aConf
argument_list|)
return|;
block|}
comment|/**    * Create a FileContext for specified filesystem using the default config.    *     * @param defaultFS    * @return a FileContext with the specified AbstractFileSystem    *                 as the default FS.    * @throws IOException if the filesystem with specified cannot be created    */
DECL|method|getFileContext ( final AbstractFileSystem defaultFS)
specifier|protected
specifier|static
name|FileContext
name|getFileContext
parameter_list|(
specifier|final
name|AbstractFileSystem
name|defaultFS
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getFileContext
argument_list|(
name|defaultFS
argument_list|,
operator|new
name|Configuration
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Static Factory methods for getting a FileContext.    * Note new file contexts are created for each call.    * The only singleton is the local FS context using the default config.    *     * Methods that use the default config: the default config read from the    * $HADOOP_CONFIG/core.xml,    * Unspecified key-values for config are defaulted from core-defaults.xml    * in the release jar.    *     * The keys relevant to the FileContext layer are extracted at time of    * construction. Changes to the config after the call are ignore    * by the FileContext layer.     * The conf is passed to lower layers like AbstractFileSystem and HDFS which    * pick up their own config variables.    */
comment|/**    * Create a FileContext using the default config read from the    * $HADOOP_CONFIG/core.xml,    * Unspecified key-values for config are defaulted from core-defaults.xml    * in the release jar.    *     * @throws IOException if default filesystem in the config  cannot be created    */
DECL|method|getFileContext ()
specifier|public
specifier|static
name|FileContext
name|getFileContext
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getFileContext
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|)
return|;
block|}
comment|/**    *     * @return a FileContext for the local filesystem using the default config.    * @throws IOException     */
DECL|method|getLocalFSFileContext ()
specifier|public
specifier|static
name|FileContext
name|getLocalFSFileContext
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|localFsSingleton
operator|==
literal|null
condition|)
block|{
name|localFsSingleton
operator|=
name|getFileContext
argument_list|(
name|FsConstants
operator|.
name|LOCAL_FS_URI
argument_list|)
expr_stmt|;
block|}
return|return
name|localFsSingleton
return|;
block|}
comment|/**    * Create a FileContext for specified URI using the default config.    *     * @param defaultFsUri    * @return a FileContext with the specified URI as the default FS.    * @throws IOException if the filesysem with specified cannot be created    */
DECL|method|getFileContext (final URI defaultFsUri)
specifier|public
specifier|static
name|FileContext
name|getFileContext
parameter_list|(
specifier|final
name|URI
name|defaultFsUri
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getFileContext
argument_list|(
name|defaultFsUri
argument_list|,
operator|new
name|Configuration
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Create a FileContext for specified default URI using the specified config.    *     * @param defaultFsUri    * @param aConf    * @return new FileContext for specified uri    * @throws IOException if the filesysem with specified cannot be created    */
DECL|method|getFileContext (final URI defaultFsUri, final Configuration aConf)
specifier|public
specifier|static
name|FileContext
name|getFileContext
parameter_list|(
specifier|final
name|URI
name|defaultFsUri
parameter_list|,
specifier|final
name|Configuration
name|aConf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getFileContext
argument_list|(
name|AbstractFileSystem
operator|.
name|get
argument_list|(
name|defaultFsUri
argument_list|,
name|aConf
argument_list|)
argument_list|,
name|aConf
argument_list|)
return|;
block|}
comment|/**    * Create a FileContext using the passed config.    * Generally it is better to use {@link #getFileContext(URI, Configuration)}    * instead of this one.    *     *     * @param aConf    * @return new FileContext    * @throws IOException  if default filesystem in the config  cannot be created    */
DECL|method|getFileContext (final Configuration aConf)
specifier|public
specifier|static
name|FileContext
name|getFileContext
parameter_list|(
specifier|final
name|Configuration
name|aConf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getFileContext
argument_list|(
name|URI
operator|.
name|create
argument_list|(
name|FsConfig
operator|.
name|getDefaultFsURI
argument_list|(
name|aConf
argument_list|)
argument_list|)
argument_list|,
name|aConf
argument_list|)
return|;
block|}
comment|/**    * @param aConf - from which the FileContext is configured    * @return a FileContext for the local filesystem using the specified config.    * @throws IOException     */
DECL|method|getLocalFSFileContext (final Configuration aConf)
specifier|public
specifier|static
name|FileContext
name|getLocalFSFileContext
parameter_list|(
specifier|final
name|Configuration
name|aConf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getFileContext
argument_list|(
name|FsConstants
operator|.
name|LOCAL_FS_URI
argument_list|,
name|aConf
argument_list|)
return|;
block|}
comment|/* This method is needed for tests. */
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
comment|/* return type will change to AFS once                                   HADOOP-6223 is completed */
DECL|method|getDefaultFileSystem ()
specifier|protected
name|AbstractFileSystem
name|getDefaultFileSystem
parameter_list|()
block|{
return|return
name|defaultFS
return|;
block|}
comment|/**    * Set the working directory for wd-relative names (such a "foo/bar").    * @param newWDir    * @throws IOException    *     * newWdir can be one of     *     - relative path:  "foo/bar";    *     - absolute without scheme: "/foo/bar"    *     - fully qualified with scheme: "xx://auth/foo/bar"    *  Illegal WDs:    *      - relative with scheme: "xx:foo/bar"     */
DECL|method|setWorkingDirectory (final Path newWDir)
specifier|public
name|void
name|setWorkingDirectory
parameter_list|(
specifier|final
name|Path
name|newWDir
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotSchemeWithRelative
argument_list|(
name|newWDir
argument_list|)
expr_stmt|;
comment|// wd is stored as fully qualified path.
specifier|final
name|Path
name|newWorkingDir
init|=
operator|new
name|Path
argument_list|(
name|workingDir
argument_list|,
name|newWDir
argument_list|)
decl_stmt|;
name|FileStatus
name|status
init|=
name|getFileStatus
argument_list|(
name|newWorkingDir
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|status
operator|.
name|isDir
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|" Cannot setWD to a file"
argument_list|)
throw|;
block|}
name|workingDir
operator|=
name|newWorkingDir
expr_stmt|;
block|}
comment|/**    * Gets the working directory for wd-relative names (such a "foo/bar").    */
DECL|method|getWorkingDirectory ()
specifier|public
name|Path
name|getWorkingDirectory
parameter_list|()
block|{
return|return
name|workingDir
return|;
block|}
comment|/**    *     * @return the umask of this FileContext    */
DECL|method|getUMask ()
specifier|public
name|FsPermission
name|getUMask
parameter_list|()
block|{
return|return
name|umask
return|;
block|}
comment|/**    * Set umask to the supplied parameter.    * @param newUmask  the new umask    */
DECL|method|setUMask (final FsPermission newUmask)
specifier|public
name|void
name|setUMask
parameter_list|(
specifier|final
name|FsPermission
name|newUmask
parameter_list|)
block|{
name|umask
operator|=
name|newUmask
expr_stmt|;
block|}
comment|/**    * Make the path fully qualified if it is isn't.     * A Fully-qualified path has scheme and authority specified and an absolute    * path.    * Use the default filesystem and working dir in this FileContext to qualify.    * @param path    * @return qualified path    */
DECL|method|makeQualified (final Path path)
specifier|public
name|Path
name|makeQualified
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|)
block|{
return|return
name|path
operator|.
name|makeQualified
argument_list|(
name|defaultFS
operator|.
name|getUri
argument_list|()
argument_list|,
name|getWorkingDirectory
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Create or overwrite file on indicated path and returns an output stream    * for writing into the file.    * @param f the file name to open    * @param createFlag gives the semantics  of create: overwrite, append etc.    * @param opts  - varargs of CreateOpt:    *<ul>    *<li>   Progress - to report progress on the operation - default null    *<li>   Permission - umask is applied against permisssion:    *                  default is FsPermissions:getDefault()     *<li>   CreateParent - create missing parent path; default is to not    *                   create parents    *<li> The defaults for the following are  SS defaults of the    *      file server implementing the target path.     *      Not all parameters make sense for all kinds of filesystem    *                - eg. localFS ignores Blocksize, replication, checksum    *<ul>    *<li>  BufferSize - buffersize used in FSDataOutputStream    *<li>  Blocksize - block size for file blocks    *<li>  ReplicationFactor - replication for blocks    *<li>  BytesPerChecksum - bytes per checksum    *</ul>    *</ul>    *                           * @throws IOException    *     * @see #setPermission(Path, FsPermission)    */
DECL|method|create (final Path f, final EnumSet<CreateFlag> createFlag, Options.CreateOpts... opts)
specifier|public
name|FSDataOutputStream
name|create
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|createFlag
parameter_list|,
name|Options
operator|.
name|CreateOpts
modifier|...
name|opts
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|AbstractFileSystem
name|fsOfAbsF
init|=
name|getFSofPath
argument_list|(
name|absF
argument_list|)
decl_stmt|;
comment|// If one of the options is a permission, extract it& apply umask
comment|// If not, add a default Perms and apply umask;
comment|// AbstractFileSystem#create
name|CreateOpts
operator|.
name|Perms
name|permOpt
init|=
operator|(
name|CreateOpts
operator|.
name|Perms
operator|)
name|CreateOpts
operator|.
name|getOpt
argument_list|(
name|CreateOpts
operator|.
name|Perms
operator|.
name|class
argument_list|,
name|opts
argument_list|)
decl_stmt|;
name|FsPermission
name|permission
init|=
operator|(
name|permOpt
operator|!=
literal|null
operator|)
condition|?
name|permOpt
operator|.
name|getValue
argument_list|()
else|:
name|FsPermission
operator|.
name|getDefault
argument_list|()
decl_stmt|;
name|permission
operator|=
name|permission
operator|.
name|applyUMask
argument_list|(
name|umask
argument_list|)
expr_stmt|;
name|CreateOpts
index|[]
name|updatedOpts
init|=
name|CreateOpts
operator|.
name|setOpt
argument_list|(
name|CreateOpts
operator|.
name|perms
argument_list|(
name|permission
argument_list|)
argument_list|,
name|opts
argument_list|)
decl_stmt|;
return|return
name|fsOfAbsF
operator|.
name|create
argument_list|(
name|absF
argument_list|,
name|createFlag
argument_list|,
name|updatedOpts
argument_list|)
return|;
block|}
comment|/**    * Make the given file and all non-existent parents into    * directories.    *     * @param dir - the dir to make    * @param permission - permissions is set permission&~umask    * @param createParent - if true then missing parent dirs are created    *                       if false then parent must exist    * @throws IOException when operation fails not authorized or     *   if parent does not exist and createParent is false.    */
DECL|method|mkdir (final Path dir, final FsPermission permission, final boolean createParent)
specifier|public
name|void
name|mkdir
parameter_list|(
specifier|final
name|Path
name|dir
parameter_list|,
specifier|final
name|FsPermission
name|permission
parameter_list|,
specifier|final
name|boolean
name|createParent
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absDir
init|=
name|fixRelativePart
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|FsPermission
name|absFerms
init|=
operator|(
name|permission
operator|==
literal|null
condition|?
name|FsPermission
operator|.
name|getDefault
argument_list|()
else|:
name|permission
operator|)
operator|.
name|applyUMask
argument_list|(
name|umask
argument_list|)
decl_stmt|;
name|getFSofPath
argument_list|(
name|absDir
argument_list|)
operator|.
name|mkdir
argument_list|(
name|absDir
argument_list|,
name|absFerms
argument_list|,
name|createParent
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete a file.    * @param f the path to delete.    * @param recursive if path is a directory and set to     * true, the directory is deleted else throws an exception. In    * case of a file the recursive can be set to either true or false.     * @return  true if delete is successful else false.     * @throws IOException    */
DECL|method|delete (final Path f, final boolean recursive)
specifier|public
name|boolean
name|delete
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|boolean
name|recursive
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
name|getFSofPath
argument_list|(
name|absF
argument_list|)
operator|.
name|delete
argument_list|(
name|absF
argument_list|,
name|recursive
argument_list|)
return|;
block|}
comment|/**    * Opens an FSDataInputStream at the indicated Path using    * default buffersize.    * @param f the file name to open    */
DECL|method|open (final Path f)
specifier|public
name|FSDataInputStream
name|open
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
name|getFSofPath
argument_list|(
name|absF
argument_list|)
operator|.
name|open
argument_list|(
name|absF
argument_list|)
return|;
block|}
comment|/**    * Opens an FSDataInputStream at the indicated Path.    * @param f the file name to open    * @param bufferSize the size of the buffer to be used.    */
DECL|method|open (final Path f, int bufferSize)
specifier|public
name|FSDataInputStream
name|open
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
name|int
name|bufferSize
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
name|getFSofPath
argument_list|(
name|absF
argument_list|)
operator|.
name|open
argument_list|(
name|absF
argument_list|,
name|bufferSize
argument_list|)
return|;
block|}
comment|/**   * Set replication for an existing file.   *    * @param f file name   * @param replication new replication   * @throws IOException   * @return true if successful;   *         false if file does not exist or is a directory   */
DECL|method|setReplication (final Path f, final short replication)
specifier|public
name|boolean
name|setReplication
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
name|getFSofPath
argument_list|(
name|absF
argument_list|)
operator|.
name|setReplication
argument_list|(
name|absF
argument_list|,
name|replication
argument_list|)
return|;
block|}
comment|/**    * Renames Path src to Path dst    *<ul>    *<li    *<li>Fails if src is a file and dst is a directory.    *<li>Fails if src is a directory and dst is a file.    *<li>Fails if the parent of dst does not exist or is a file.    *</ul>    *<p>    * If OVERWRITE option is not passed as an argument, rename fails    * if the dst already exists.    *<p>    * If OVERWRITE option is passed as an argument, rename overwrites    * the dst if it is a file or an empty directory. Rename fails if dst is    * a non-empty directory.    *<p>    * Note that atomicity of rename is dependent on the file system    * implementation. Please refer to the file system documentation for    * details    *<p>    *     * @param src path to be renamed    * @param dst new path after rename    * @throws IOException on failure    */
DECL|method|rename (final Path src, final Path dst, final Options.Rename... options)
specifier|public
name|void
name|rename
parameter_list|(
specifier|final
name|Path
name|src
parameter_list|,
specifier|final
name|Path
name|dst
parameter_list|,
specifier|final
name|Options
operator|.
name|Rename
modifier|...
name|options
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|absSrc
init|=
name|fixRelativePart
argument_list|(
name|src
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|absDst
init|=
name|fixRelativePart
argument_list|(
name|dst
argument_list|)
decl_stmt|;
name|AbstractFileSystem
name|srcFS
init|=
name|getFSofPath
argument_list|(
name|absSrc
argument_list|)
decl_stmt|;
name|AbstractFileSystem
name|dstFS
init|=
name|getFSofPath
argument_list|(
name|absDst
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|srcFS
operator|.
name|getUri
argument_list|()
operator|.
name|equals
argument_list|(
name|dstFS
operator|.
name|getUri
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Renames across AbstractFileSystems not supported"
argument_list|)
throw|;
block|}
name|srcFS
operator|.
name|rename
argument_list|(
name|absSrc
argument_list|,
name|absDst
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set permission of a path.    * @param f    * @param permission - the new absolute permission (umask is not applied)    */
DECL|method|setPermission (final Path f, final FsPermission permission)
specifier|public
name|void
name|setPermission
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|getFSofPath
argument_list|(
name|absF
argument_list|)
operator|.
name|setPermission
argument_list|(
name|absF
argument_list|,
name|permission
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set owner of a path (i.e. a file or a directory).    * The parameters username and groupname cannot both be null.    * @param f The path    * @param username If it is null, the original username remains unchanged.    * @param groupname If it is null, the original groupname remains unchanged.    */
DECL|method|setOwner (final Path f, final String username, final String groupname)
specifier|public
name|void
name|setOwner
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|String
name|username
parameter_list|,
specifier|final
name|String
name|groupname
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|(
name|username
operator|==
literal|null
operator|)
operator|&&
operator|(
name|groupname
operator|==
literal|null
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"usernme and groupname cannot both be null"
argument_list|)
throw|;
block|}
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|getFSofPath
argument_list|(
name|absF
argument_list|)
operator|.
name|setOwner
argument_list|(
name|absF
argument_list|,
name|username
argument_list|,
name|groupname
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set access time of a file.    * @param f The path    * @param mtime Set the modification time of this file.    *        The number of milliseconds since epoch (Jan 1, 1970).     *        A value of -1 means that this call should not set modification time.    * @param atime Set the access time of this file.    *        The number of milliseconds since Jan 1, 1970.     *        A value of -1 means that this call should not set access time.    */
DECL|method|setTimes (final Path f, final long mtime, final long atime)
specifier|public
name|void
name|setTimes
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|long
name|mtime
parameter_list|,
specifier|final
name|long
name|atime
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|getFSofPath
argument_list|(
name|absF
argument_list|)
operator|.
name|setTimes
argument_list|(
name|absF
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the checksum of a file.    *    * @param f The file path    * @return The file checksum.  The default return value is null,    *  which indicates that no checksum algorithm is implemented    *  in the corresponding FileSystem.    */
DECL|method|getFileChecksum (final Path f)
specifier|public
name|FileChecksum
name|getFileChecksum
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
name|getFSofPath
argument_list|(
name|absF
argument_list|)
operator|.
name|getFileChecksum
argument_list|(
name|absF
argument_list|)
return|;
block|}
comment|/**    * Set the verify checksum flag for the  filesystem denoted by the path.    * This is only applicable if the     * corresponding FileSystem supports checksum. By default doesn't do anything.    * @param verifyChecksum    * @param f - set the verifyChecksum for the Filesystem containing this path    * @throws IOException     */
DECL|method|setVerifyChecksum (final boolean verifyChecksum, final Path f)
specifier|public
name|void
name|setVerifyChecksum
parameter_list|(
specifier|final
name|boolean
name|verifyChecksum
parameter_list|,
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|getFSofPath
argument_list|(
name|absF
argument_list|)
operator|.
name|setVerifyChecksum
argument_list|(
name|verifyChecksum
argument_list|)
expr_stmt|;
comment|//TBD need to be changed when we add symlinks.
block|}
comment|/**    * Return a file status object that represents the path.    * @param f The path we want information from    * @return a FileStatus object    * @throws FileNotFoundException when the path does not exist;    *         IOException see specific implementation    */
DECL|method|getFileStatus (final Path f)
specifier|public
name|FileStatus
name|getFileStatus
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
name|getFSofPath
argument_list|(
name|absF
argument_list|)
operator|.
name|getFileStatus
argument_list|(
name|absF
argument_list|)
return|;
block|}
comment|/**    * Return blockLocation of the given file for the given offset and len.    *  For a nonexistent file or regions, null will be returned.    *    * This call is most helpful with DFS, where it returns     * hostnames of machines that contain the given file.    *     * @param p - get blocklocations of this file    * @param start position (byte offset)    * @param len (in bytes)    * @return block locations for given file at specified offset of len    * @throws IOException    */
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
name|Project
operator|.
name|HDFS
block|,
name|Project
operator|.
name|MAPREDUCE
block|}
argument_list|)
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|getFileBlockLocations (final Path p, final long start, final long len)
specifier|public
name|BlockLocation
index|[]
name|getFileBlockLocations
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|,
specifier|final
name|long
name|start
parameter_list|,
specifier|final
name|long
name|len
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getFSofPath
argument_list|(
name|p
argument_list|)
operator|.
name|getFileBlockLocations
argument_list|(
name|p
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
return|;
block|}
comment|/**    * Returns a status object describing the use and capacity of the    * filesystem denoted by the Parh argument p.    * If the filesystem has multiple partitions, the    * use and capacity of the partition pointed to by the specified    * path is reflected.    *     * @param f Path for which status should be obtained. null means the    * root partition of the default filesystem.     * @return a FsStatus object    * @throws IOException    *           see specific implementation    */
DECL|method|getFsStatus (final Path f)
specifier|public
name|FsStatus
name|getFsStatus
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|f
operator|==
literal|null
condition|)
block|{
return|return
name|defaultFS
operator|.
name|getFsStatus
argument_list|(
literal|null
argument_list|)
return|;
block|}
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
name|getFSofPath
argument_list|(
name|absF
argument_list|)
operator|.
name|getFsStatus
argument_list|(
name|absF
argument_list|)
return|;
block|}
comment|/**    * Does the file exist?    * Note: Avoid using this method if you already have FileStatus in hand.    * Instead reuse the FileStatus     * @param f the  file or dir to be checked    */
DECL|method|exists (final Path f)
specifier|public
name|boolean
name|exists
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|getFileStatus
argument_list|(
name|f
argument_list|)
operator|!=
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Is a directory?    * Note: Avoid using this method if you already have FileStatus in hand.    * Instead reuse the FileStatus     * returned by getFileStatus() or listStatus() methods.    *     * @param f Path to evaluate    * @return True iff the named path is a directory.    * @throws IOException    */
DECL|method|isDirectory (final Path f)
specifier|public
name|boolean
name|isDirectory
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
name|getFileStatus
argument_list|(
name|absF
argument_list|)
operator|.
name|isDir
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
comment|// f does not exist
block|}
block|}
comment|/** True iff the named path is a regular file.    * Note: Avoid using this method  if you already have FileStatus in hand    * Instead reuse the FileStatus     * returned by getFileStatus() or listStatus() methods.    */
DECL|method|isFile (final Path f)
specifier|public
name|boolean
name|isFile
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|!
name|getFileStatus
argument_list|(
name|absF
argument_list|)
operator|.
name|isDir
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
comment|// f does not exist
block|}
block|}
comment|/**    * List the statuses of the files/directories in the given path if the path is    * a directory.    *     * @param f is the path    * @return the statuses of the files/directories in the given path    * @throws IOException    */
DECL|method|listStatus (final Path f)
specifier|public
name|FileStatus
index|[]
name|listStatus
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
name|getFSofPath
argument_list|(
name|absF
argument_list|)
operator|.
name|listStatus
argument_list|(
name|absF
argument_list|)
return|;
block|}
comment|/**    * Mark a path to be deleted on JVM shutdown.    *     * @param f the existing path to delete.    * @return  true if deleteOnExit is successful, otherwise false.    * @throws IOException    */
DECL|method|deleteOnExit (Path f)
specifier|public
name|boolean
name|deleteOnExit
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|exists
argument_list|(
name|f
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
synchronized|synchronized
init|(
name|DELETE_ON_EXIT
init|)
block|{
if|if
condition|(
name|DELETE_ON_EXIT
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|FINALIZER
operator|.
name|isAlive
argument_list|()
condition|)
block|{
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|addShutdownHook
argument_list|(
name|FINALIZER
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|Path
argument_list|>
name|set
init|=
name|DELETE_ON_EXIT
operator|.
name|get
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|==
literal|null
condition|)
block|{
name|set
operator|=
operator|new
name|TreeSet
argument_list|<
name|Path
argument_list|>
argument_list|()
expr_stmt|;
name|DELETE_ON_EXIT
operator|.
name|put
argument_list|(
name|this
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
name|set
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|field|util
specifier|private
specifier|final
name|Util
name|util
decl_stmt|;
DECL|method|util ()
specifier|public
name|Util
name|util
parameter_list|()
block|{
return|return
name|util
return|;
block|}
comment|/**    * Utility/library methods built over the basic FileContext methods.    * Since this are library functions, the oprtation are not atomic    * and some of them may partially complete if other threads are making    * changes to the same part of the name space.    */
DECL|class|Util
specifier|public
class|class
name|Util
block|{
comment|/**      * Return a list of file status objects that corresponds to supplied paths      * excluding those non-existent paths.      *       * @param paths are the list of paths we want information from      * @return a list of FileStatus objects      * @throws IOException      */
DECL|method|getFileStatus (Path[] paths)
specifier|private
name|FileStatus
index|[]
name|getFileStatus
parameter_list|(
name|Path
index|[]
name|paths
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|paths
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
argument_list|(
name|paths
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paths
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|results
operator|.
name|add
argument_list|(
name|FileContext
operator|.
name|this
operator|.
name|getFileStatus
argument_list|(
name|paths
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
comment|// ignoring
block|}
block|}
return|return
name|results
operator|.
name|toArray
argument_list|(
operator|new
name|FileStatus
index|[
name|results
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**      * Return the {@link ContentSummary} of path f.      * @param f      * @return the {@link ContentSummary} of path f.      * @throws IOException      */
DECL|method|getContentSummary (Path f)
specifier|public
name|ContentSummary
name|getContentSummary
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
name|status
init|=
name|FileContext
operator|.
name|this
operator|.
name|getFileStatus
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|status
operator|.
name|isDir
argument_list|()
condition|)
block|{
comment|// f is a file
return|return
operator|new
name|ContentSummary
argument_list|(
name|status
operator|.
name|getLen
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|// f is a directory
name|long
index|[]
name|summary
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
for|for
control|(
name|FileStatus
name|s
range|:
name|FileContext
operator|.
name|this
operator|.
name|listStatus
argument_list|(
name|f
argument_list|)
control|)
block|{
name|ContentSummary
name|c
init|=
name|s
operator|.
name|isDir
argument_list|()
condition|?
name|getContentSummary
argument_list|(
name|s
operator|.
name|getPath
argument_list|()
argument_list|)
else|:
operator|new
name|ContentSummary
argument_list|(
name|s
operator|.
name|getLen
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|summary
index|[
literal|0
index|]
operator|+=
name|c
operator|.
name|getLength
argument_list|()
expr_stmt|;
name|summary
index|[
literal|1
index|]
operator|+=
name|c
operator|.
name|getFileCount
argument_list|()
expr_stmt|;
name|summary
index|[
literal|2
index|]
operator|+=
name|c
operator|.
name|getDirectoryCount
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|ContentSummary
argument_list|(
name|summary
index|[
literal|0
index|]
argument_list|,
name|summary
index|[
literal|1
index|]
argument_list|,
name|summary
index|[
literal|2
index|]
argument_list|)
return|;
block|}
comment|/**      * Filter files/directories in the given list of paths using default      * path filter.      *       * @param files is the list of paths      * @return a list of statuses for the files under the given paths after      *         applying the filter default Path filter      * @exception IOException      */
DECL|method|listStatus (Path[] files)
specifier|public
name|FileStatus
index|[]
name|listStatus
parameter_list|(
name|Path
index|[]
name|files
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|listStatus
argument_list|(
name|files
argument_list|,
name|DEFAULT_FILTER
argument_list|)
return|;
block|}
comment|/**      * Filter files/directories in the given path using the user-supplied path      * filter.      *       * @param f is the path name      * @param filter is the user-supplied path filter      * @return an array of FileStatus objects for the files under the given path      *         after applying the filter      * @throws IOException      *           if encounter any problem while fetching the status      */
DECL|method|listStatus (Path f, PathFilter filter)
specifier|public
name|FileStatus
index|[]
name|listStatus
parameter_list|(
name|Path
name|f
parameter_list|,
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
decl_stmt|;
name|listStatus
argument_list|(
name|results
argument_list|,
name|f
argument_list|,
name|filter
argument_list|)
expr_stmt|;
return|return
name|results
operator|.
name|toArray
argument_list|(
operator|new
name|FileStatus
index|[
name|results
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**      * Filter files/directories in the given list of paths using user-supplied      * path filter.      *       * @param files is a list of paths      * @param filter is the filter      * @return a list of statuses for the files under the given paths after      *         applying the filter      * @exception IOException      */
DECL|method|listStatus (Path[] files, PathFilter filter)
specifier|public
name|FileStatus
index|[]
name|listStatus
parameter_list|(
name|Path
index|[]
name|files
parameter_list|,
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|files
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|listStatus
argument_list|(
name|results
argument_list|,
name|files
index|[
name|i
index|]
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
return|return
name|results
operator|.
name|toArray
argument_list|(
operator|new
name|FileStatus
index|[
name|results
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/*      * Filter files/directories in the given path using the user-supplied path      * filter. Results are added to the given array<code>results</code>.      */
DECL|method|listStatus (ArrayList<FileStatus> results, Path f, PathFilter filter)
specifier|private
name|void
name|listStatus
parameter_list|(
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
name|results
parameter_list|,
name|Path
name|f
parameter_list|,
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
index|[]
name|listing
init|=
name|FileContext
operator|.
name|this
operator|.
name|listStatus
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|listing
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|listing
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|filter
operator|.
name|accept
argument_list|(
name|listing
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|)
condition|)
block|{
name|results
operator|.
name|add
argument_list|(
name|listing
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      *<p>Return all the files that match filePattern and are not checksum      * files. Results are sorted by their names.      *       *<p>      * A filename pattern is composed of<i>regular</i> characters and      *<i>special pattern matching</i> characters, which are:      *      *<dl>      *<dd>      *<dl>      *<p>      *<dt><tt> ?</tt>      *<dd> Matches any single character.      *      *<p>      *<dt><tt> *</tt>      *<dd> Matches zero or more characters.      *      *<p>      *<dt><tt> [<i>abc</i>]</tt>      *<dd> Matches a single character from character set      *<tt>{<i>a,b,c</i>}</tt>.      *      *<p>      *<dt><tt> [<i>a</i>-<i>b</i>]</tt>      *<dd> Matches a single character from the character range      *<tt>{<i>a...b</i>}</tt>. Note: character<tt><i>a</i></tt> must be      *     lexicographically less than or equal to character<tt><i>b</i></tt>.      *      *<p>      *<dt><tt> [^<i>a</i>]</tt>      *<dd> Matches a single char that is not from character set or range      *<tt>{<i>a</i>}</tt>.  Note that the<tt>^</tt> character must occur      *     immediately to the right of the opening bracket.      *      *<p>      *<dt><tt> \<i>c</i></tt>      *<dd> Removes (escapes) any special meaning of character<i>c</i>.      *      *<p>      *<dt><tt> {ab,cd}</tt>      *<dd> Matches a string from the string set<tt>{<i>ab, cd</i>}</tt>      *          *<p>      *<dt><tt> {ab,c{de,fh}}</tt>      *<dd> Matches a string from string set<tt>{<i>ab, cde, cfh</i>}</tt>      *      *</dl>      *</dd>      *</dl>      *      * @param pathPattern a regular expression specifying a pth pattern       * @return an array of paths that match the path pattern      * @throws IOException      */
DECL|method|globStatus (Path pathPattern)
specifier|public
name|FileStatus
index|[]
name|globStatus
parameter_list|(
name|Path
name|pathPattern
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|globStatus
argument_list|(
name|pathPattern
argument_list|,
name|DEFAULT_FILTER
argument_list|)
return|;
block|}
comment|/**      * Return an array of FileStatus objects whose path names match pathPattern      * and is accepted by the user-supplied path filter. Results are sorted by      * their path names.      * Return null if pathPattern has no glob and the path does not exist.      * Return an empty array if pathPattern has a glob and no path matches it.       *       * @param pathPattern      *          a regular expression specifying the path pattern      * @param filter      *          a user-supplied path filter      * @return an array of FileStatus objects      * @throws IOException if any I/O error occurs when fetching file status      */
DECL|method|globStatus (final Path pathPattern, final PathFilter filter)
specifier|public
name|FileStatus
index|[]
name|globStatus
parameter_list|(
specifier|final
name|Path
name|pathPattern
parameter_list|,
specifier|final
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|URI
name|uri
init|=
name|getFSofPath
argument_list|(
name|fixRelativePart
argument_list|(
name|pathPattern
argument_list|)
argument_list|)
operator|.
name|getUri
argument_list|()
decl_stmt|;
name|String
name|filename
init|=
name|pathPattern
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|filePatterns
init|=
name|GlobExpander
operator|.
name|expand
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|filePatterns
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|Path
name|absPathPattern
init|=
name|fixRelativePart
argument_list|(
name|pathPattern
argument_list|)
decl_stmt|;
return|return
name|globStatusInternal
argument_list|(
name|uri
argument_list|,
operator|new
name|Path
argument_list|(
name|absPathPattern
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|,
name|filter
argument_list|)
return|;
block|}
else|else
block|{
name|List
argument_list|<
name|FileStatus
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|iFilePattern
range|:
name|filePatterns
control|)
block|{
name|Path
name|iAbsFilePattern
init|=
name|fixRelativePart
argument_list|(
operator|new
name|Path
argument_list|(
name|iFilePattern
argument_list|)
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|files
init|=
name|globStatusInternal
argument_list|(
name|uri
argument_list|,
name|iAbsFilePattern
argument_list|,
name|filter
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|file
range|:
name|files
control|)
block|{
name|results
operator|.
name|add
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|results
operator|.
name|toArray
argument_list|(
operator|new
name|FileStatus
index|[
name|results
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
block|}
comment|/**      *       * @param uri for all the inPathPattern      * @param inPathPattern - without the scheme& authority (take from uri)      * @param filter      * @return      * @throws IOException      */
DECL|method|globStatusInternal ( final URI uri, final Path inPathPattern, final PathFilter filter)
specifier|private
name|FileStatus
index|[]
name|globStatusInternal
parameter_list|(
specifier|final
name|URI
name|uri
parameter_list|,
specifier|final
name|Path
name|inPathPattern
parameter_list|,
specifier|final
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
index|[]
name|parents
init|=
operator|new
name|Path
index|[
literal|1
index|]
decl_stmt|;
name|int
name|level
init|=
literal|0
decl_stmt|;
assert|assert
operator|(
name|inPathPattern
operator|.
name|toUri
argument_list|()
operator|.
name|getScheme
argument_list|()
operator|==
literal|null
operator|&&
name|inPathPattern
operator|.
name|toUri
argument_list|()
operator|.
name|getAuthority
argument_list|()
operator|==
literal|null
operator|&&
name|inPathPattern
operator|.
name|isUriPathAbsolute
argument_list|()
operator|)
assert|;
name|String
name|filename
init|=
name|inPathPattern
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
comment|// path has only zero component
if|if
condition|(
literal|""
operator|.
name|equals
argument_list|(
name|filename
argument_list|)
operator|||
name|Path
operator|.
name|SEPARATOR
operator|.
name|equals
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|Path
name|p
init|=
name|inPathPattern
operator|.
name|makeQualified
argument_list|(
name|uri
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|getFileStatus
argument_list|(
operator|new
name|Path
index|[]
block|{
name|p
block|}
argument_list|)
return|;
block|}
comment|// path has at least one component
name|String
index|[]
name|components
init|=
name|filename
operator|.
name|split
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
decl_stmt|;
comment|// Path is absolute, first component is "/" hence first component
comment|// is the uri root
name|parents
index|[
literal|0
index|]
operator|=
operator|new
name|Path
argument_list|(
operator|new
name|Path
argument_list|(
name|uri
argument_list|)
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
argument_list|)
expr_stmt|;
name|level
operator|=
literal|1
expr_stmt|;
comment|// glob the paths that match the parent path, ie. [0, components.length-1]
name|boolean
index|[]
name|hasGlob
init|=
operator|new
name|boolean
index|[]
block|{
literal|false
block|}
decl_stmt|;
name|Path
index|[]
name|relParentPaths
init|=
name|globPathsLevel
argument_list|(
name|parents
argument_list|,
name|components
argument_list|,
name|level
argument_list|,
name|hasGlob
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|results
decl_stmt|;
if|if
condition|(
name|relParentPaths
operator|==
literal|null
operator|||
name|relParentPaths
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|results
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
comment|// fix the pathes to be abs
name|Path
index|[]
name|parentPaths
init|=
operator|new
name|Path
index|[
name|relParentPaths
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|relParentPaths
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|parentPaths
index|[
name|i
index|]
operator|=
name|relParentPaths
index|[
name|i
index|]
operator|.
name|makeQualified
argument_list|(
name|uri
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// Now work on the last component of the path
name|GlobFilter
name|fp
init|=
operator|new
name|GlobFilter
argument_list|(
name|components
index|[
name|components
operator|.
name|length
operator|-
literal|1
index|]
argument_list|,
name|filter
argument_list|)
decl_stmt|;
if|if
condition|(
name|fp
operator|.
name|hasPattern
argument_list|()
condition|)
block|{
comment|// last component has a pattern
comment|// list parent directories and then glob the results
name|results
operator|=
name|listStatus
argument_list|(
name|parentPaths
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|hasGlob
index|[
literal|0
index|]
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// last component does not have a pattern
comment|// get all the path names
name|ArrayList
argument_list|<
name|Path
argument_list|>
name|filteredPaths
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|(
name|parentPaths
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parentPaths
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|parentPaths
index|[
name|i
index|]
operator|=
operator|new
name|Path
argument_list|(
name|parentPaths
index|[
name|i
index|]
argument_list|,
name|components
index|[
name|components
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|.
name|accept
argument_list|(
name|parentPaths
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|filteredPaths
operator|.
name|add
argument_list|(
name|parentPaths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|// get all their statuses
name|results
operator|=
name|getFileStatus
argument_list|(
name|filteredPaths
operator|.
name|toArray
argument_list|(
operator|new
name|Path
index|[
name|filteredPaths
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Decide if the pathPattern contains a glob or not
if|if
condition|(
name|results
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|hasGlob
index|[
literal|0
index|]
condition|)
block|{
name|results
operator|=
operator|new
name|FileStatus
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|results
operator|.
name|length
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|hasGlob
index|[
literal|0
index|]
condition|)
block|{
name|results
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|results
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|results
return|;
block|}
comment|/*      * For a path of N components, return a list of paths that match the      * components [<code>level</code>,<code>N-1</code>].      */
DECL|method|globPathsLevel (Path[] parents, String[] filePattern, int level, boolean[] hasGlob)
specifier|private
name|Path
index|[]
name|globPathsLevel
parameter_list|(
name|Path
index|[]
name|parents
parameter_list|,
name|String
index|[]
name|filePattern
parameter_list|,
name|int
name|level
parameter_list|,
name|boolean
index|[]
name|hasGlob
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|level
operator|==
name|filePattern
operator|.
name|length
operator|-
literal|1
condition|)
block|{
return|return
name|parents
return|;
block|}
if|if
condition|(
name|parents
operator|==
literal|null
operator|||
name|parents
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|GlobFilter
name|fp
init|=
operator|new
name|GlobFilter
argument_list|(
name|filePattern
index|[
name|level
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|fp
operator|.
name|hasPattern
argument_list|()
condition|)
block|{
name|parents
operator|=
name|FileUtil
operator|.
name|stat2Paths
argument_list|(
name|listStatus
argument_list|(
name|parents
argument_list|,
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|hasGlob
index|[
literal|0
index|]
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parents
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|parents
index|[
name|i
index|]
operator|=
operator|new
name|Path
argument_list|(
name|parents
index|[
name|i
index|]
argument_list|,
name|filePattern
index|[
name|level
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|globPathsLevel
argument_list|(
name|parents
argument_list|,
name|filePattern
argument_list|,
name|level
operator|+
literal|1
argument_list|,
name|hasGlob
argument_list|)
return|;
block|}
comment|/**      * Copy file from src to dest.      * @param src      * @param dst      * @return true if copy is successful      * @throws IOException      */
DECL|method|copy (final Path src, final Path dst)
specifier|public
name|boolean
name|copy
parameter_list|(
specifier|final
name|Path
name|src
parameter_list|,
specifier|final
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|copy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Copy from src to dst, optionally deleting src and overwriting dst.      * @param src      * @param dst      * @param deleteSource - delete src if true      * @param overwrite  overwrite dst if true; throw IOException if dst exists      *         and overwrite is false.      * @return true if copy is successful      * @throws IOException      */
DECL|method|copy (final Path src, final Path dst, boolean deleteSource, boolean overwrite)
specifier|public
name|boolean
name|copy
parameter_list|(
specifier|final
name|Path
name|src
parameter_list|,
specifier|final
name|Path
name|dst
parameter_list|,
name|boolean
name|deleteSource
parameter_list|,
name|boolean
name|overwrite
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotSchemeWithRelative
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|checkNotSchemeWithRelative
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|Path
name|qSrc
init|=
name|makeQualified
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|Path
name|qDst
init|=
name|makeQualified
argument_list|(
name|dst
argument_list|)
decl_stmt|;
name|checkDest
argument_list|(
name|qSrc
operator|.
name|getName
argument_list|()
argument_list|,
name|qDst
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDirectory
argument_list|(
name|qSrc
argument_list|)
condition|)
block|{
name|checkDependencies
argument_list|(
name|qSrc
argument_list|,
name|qDst
argument_list|)
expr_stmt|;
name|mkdir
argument_list|(
name|qDst
argument_list|,
name|FsPermission
operator|.
name|getDefault
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|contents
init|=
name|FileContext
operator|.
name|this
operator|.
name|listStatus
argument_list|(
name|qSrc
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|content
range|:
name|contents
control|)
block|{
name|copy
argument_list|(
name|content
operator|.
name|getPath
argument_list|()
argument_list|,
operator|new
name|Path
argument_list|(
name|qDst
argument_list|,
name|content
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|,
name|deleteSource
argument_list|,
name|overwrite
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|InputStream
name|in
init|=
literal|null
decl_stmt|;
name|OutputStream
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
name|in
operator|=
name|open
argument_list|(
name|qSrc
argument_list|)
expr_stmt|;
name|out
operator|=
name|create
argument_list|(
name|qDst
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|CreateFlag
operator|.
name|OVERWRITE
argument_list|)
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|copyBytes
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|conf
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|in
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
if|if
condition|(
name|deleteSource
condition|)
block|{
return|return
name|delete
argument_list|(
name|qSrc
argument_list|,
literal|true
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
comment|/* A class that could decide if a string matches the glob or not */
DECL|class|GlobFilter
specifier|private
specifier|static
class|class
name|GlobFilter
implements|implements
name|PathFilter
block|{
DECL|field|userFilter
specifier|private
name|PathFilter
name|userFilter
init|=
name|DEFAULT_FILTER
decl_stmt|;
DECL|field|regex
specifier|private
name|Pattern
name|regex
decl_stmt|;
DECL|field|hasPattern
specifier|private
name|boolean
name|hasPattern
init|=
literal|false
decl_stmt|;
comment|/** Default pattern character: Escape any special meaning. */
DECL|field|PAT_ESCAPE
specifier|private
specifier|static
specifier|final
name|char
name|PAT_ESCAPE
init|=
literal|'\\'
decl_stmt|;
comment|/** Default pattern character: Any single character. */
DECL|field|PAT_ANY
specifier|private
specifier|static
specifier|final
name|char
name|PAT_ANY
init|=
literal|'.'
decl_stmt|;
comment|/** Default pattern character: Character set close. */
DECL|field|PAT_SET_CLOSE
specifier|private
specifier|static
specifier|final
name|char
name|PAT_SET_CLOSE
init|=
literal|']'
decl_stmt|;
DECL|method|GlobFilter ()
name|GlobFilter
parameter_list|()
block|{     }
DECL|method|GlobFilter (final String filePattern)
name|GlobFilter
parameter_list|(
specifier|final
name|String
name|filePattern
parameter_list|)
throws|throws
name|IOException
block|{
name|setRegex
argument_list|(
name|filePattern
argument_list|)
expr_stmt|;
block|}
DECL|method|GlobFilter (final String filePattern, final PathFilter filter)
name|GlobFilter
parameter_list|(
specifier|final
name|String
name|filePattern
parameter_list|,
specifier|final
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|userFilter
operator|=
name|filter
expr_stmt|;
name|setRegex
argument_list|(
name|filePattern
argument_list|)
expr_stmt|;
block|}
DECL|method|isJavaRegexSpecialChar (char pChar)
specifier|private
name|boolean
name|isJavaRegexSpecialChar
parameter_list|(
name|char
name|pChar
parameter_list|)
block|{
return|return
name|pChar
operator|==
literal|'.'
operator|||
name|pChar
operator|==
literal|'$'
operator|||
name|pChar
operator|==
literal|'('
operator|||
name|pChar
operator|==
literal|')'
operator|||
name|pChar
operator|==
literal|'|'
operator|||
name|pChar
operator|==
literal|'+'
return|;
block|}
DECL|method|setRegex (String filePattern)
name|void
name|setRegex
parameter_list|(
name|String
name|filePattern
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|len
decl_stmt|;
name|int
name|setOpen
decl_stmt|;
name|int
name|curlyOpen
decl_stmt|;
name|boolean
name|setRange
decl_stmt|;
name|StringBuilder
name|fileRegex
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
comment|// Validate the pattern
name|len
operator|=
name|filePattern
operator|.
name|length
argument_list|()
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|setOpen
operator|=
literal|0
expr_stmt|;
name|setRange
operator|=
literal|false
expr_stmt|;
name|curlyOpen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|char
name|pCh
decl_stmt|;
comment|// Examine a single pattern character
name|pCh
operator|=
name|filePattern
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|pCh
operator|==
name|PAT_ESCAPE
condition|)
block|{
name|fileRegex
operator|.
name|append
argument_list|(
name|pCh
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|len
condition|)
block|{
name|error
argument_list|(
literal|"An escaped character does not present"
argument_list|,
name|filePattern
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|pCh
operator|=
name|filePattern
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isJavaRegexSpecialChar
argument_list|(
name|pCh
argument_list|)
condition|)
block|{
name|fileRegex
operator|.
name|append
argument_list|(
name|PAT_ESCAPE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pCh
operator|==
literal|'*'
condition|)
block|{
name|fileRegex
operator|.
name|append
argument_list|(
name|PAT_ANY
argument_list|)
expr_stmt|;
name|hasPattern
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pCh
operator|==
literal|'?'
condition|)
block|{
name|pCh
operator|=
name|PAT_ANY
expr_stmt|;
name|hasPattern
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pCh
operator|==
literal|'{'
condition|)
block|{
name|fileRegex
operator|.
name|append
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|pCh
operator|=
literal|'('
expr_stmt|;
name|curlyOpen
operator|++
expr_stmt|;
name|hasPattern
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pCh
operator|==
literal|','
operator|&&
name|curlyOpen
operator|>
literal|0
condition|)
block|{
name|fileRegex
operator|.
name|append
argument_list|(
literal|")|"
argument_list|)
expr_stmt|;
name|pCh
operator|=
literal|'('
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pCh
operator|==
literal|'}'
operator|&&
name|curlyOpen
operator|>
literal|0
condition|)
block|{
comment|// End of a group
name|curlyOpen
operator|--
expr_stmt|;
name|fileRegex
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|pCh
operator|=
literal|')'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pCh
operator|==
literal|'['
operator|&&
name|setOpen
operator|==
literal|0
condition|)
block|{
name|setOpen
operator|++
expr_stmt|;
name|hasPattern
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pCh
operator|==
literal|'^'
operator|&&
name|setOpen
operator|>
literal|0
condition|)
block|{         }
elseif|else
if|if
condition|(
name|pCh
operator|==
literal|'-'
operator|&&
name|setOpen
operator|>
literal|0
condition|)
block|{
comment|// Character set range
name|setRange
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pCh
operator|==
name|PAT_SET_CLOSE
operator|&&
name|setRange
condition|)
block|{
comment|// Incomplete character set range
name|error
argument_list|(
literal|"Incomplete character set range"
argument_list|,
name|filePattern
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pCh
operator|==
name|PAT_SET_CLOSE
operator|&&
name|setOpen
operator|>
literal|0
condition|)
block|{
comment|// End of a character set
if|if
condition|(
name|setOpen
operator|<
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"Unexpected end of set"
argument_list|,
name|filePattern
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|setOpen
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|setOpen
operator|>
literal|0
condition|)
block|{
comment|// Normal character, or the end of a character set range
name|setOpen
operator|++
expr_stmt|;
name|setRange
operator|=
literal|false
expr_stmt|;
block|}
name|fileRegex
operator|.
name|append
argument_list|(
name|pCh
argument_list|)
expr_stmt|;
block|}
comment|// Check for a well-formed pattern
if|if
condition|(
name|setOpen
operator|>
literal|0
operator|||
name|setRange
operator|||
name|curlyOpen
operator|>
literal|0
condition|)
block|{
comment|// Incomplete character set or character range
name|error
argument_list|(
literal|"Expecting set closure character or end of range, or }"
argument_list|,
name|filePattern
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|regex
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
name|fileRegex
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|hasPattern ()
name|boolean
name|hasPattern
parameter_list|()
block|{
return|return
name|hasPattern
return|;
block|}
DECL|method|accept (final Path path)
specifier|public
name|boolean
name|accept
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|)
block|{
return|return
name|regex
operator|.
name|matcher
argument_list|(
name|path
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|matches
argument_list|()
operator|&&
name|userFilter
operator|.
name|accept
argument_list|(
name|path
argument_list|)
return|;
block|}
DECL|method|error (final String s, final String pattern, final int pos)
specifier|private
name|void
name|error
parameter_list|(
specifier|final
name|String
name|s
parameter_list|,
specifier|final
name|String
name|pattern
parameter_list|,
specifier|final
name|int
name|pos
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Illegal file pattern: "
operator|+
name|s
operator|+
literal|" for glob "
operator|+
name|pattern
operator|+
literal|" at "
operator|+
name|pos
argument_list|)
throw|;
block|}
block|}
comment|//
comment|// Check destionation. Throw IOException if destination already exists
comment|// and overwrite is not true
comment|//
DECL|method|checkDest (String srcName, Path dst, boolean overwrite)
specifier|private
name|void
name|checkDest
parameter_list|(
name|String
name|srcName
parameter_list|,
name|Path
name|dst
parameter_list|,
name|boolean
name|overwrite
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|exists
argument_list|(
name|dst
argument_list|)
condition|)
block|{
if|if
condition|(
name|isDirectory
argument_list|(
name|dst
argument_list|)
condition|)
block|{
comment|// TBD not very clear
if|if
condition|(
literal|null
operator|==
name|srcName
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Target "
operator|+
name|dst
operator|+
literal|" is a directory"
argument_list|)
throw|;
block|}
name|checkDest
argument_list|(
literal|null
argument_list|,
operator|new
name|Path
argument_list|(
name|dst
argument_list|,
name|srcName
argument_list|)
argument_list|,
name|overwrite
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|overwrite
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Target "
operator|+
name|dst
operator|+
literal|" already exists"
argument_list|)
throw|;
block|}
block|}
block|}
comment|//
comment|// If the destination is a subdirectory of the source, then
comment|// generate exception
comment|//
DECL|method|checkDependencies (Path qualSrc, Path qualDst)
specifier|private
specifier|static
name|void
name|checkDependencies
parameter_list|(
name|Path
name|qualSrc
parameter_list|,
name|Path
name|qualDst
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isSameFS
argument_list|(
name|qualSrc
argument_list|,
name|qualDst
argument_list|)
condition|)
block|{
name|String
name|srcq
init|=
name|qualSrc
operator|.
name|toString
argument_list|()
operator|+
name|Path
operator|.
name|SEPARATOR
decl_stmt|;
name|String
name|dstq
init|=
name|qualDst
operator|.
name|toString
argument_list|()
operator|+
name|Path
operator|.
name|SEPARATOR
decl_stmt|;
if|if
condition|(
name|dstq
operator|.
name|startsWith
argument_list|(
name|srcq
argument_list|)
condition|)
block|{
if|if
condition|(
name|srcq
operator|.
name|length
argument_list|()
operator|==
name|dstq
operator|.
name|length
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot copy "
operator|+
name|qualSrc
operator|+
literal|" to itself."
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot copy "
operator|+
name|qualSrc
operator|+
literal|" to its subdirectory "
operator|+
name|qualDst
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**    * Are qualSrc and qualDst of the same file system?    * @param qualPath1 - fully qualified path    * @param qualPath2 - fully qualified path    * @return    */
DECL|method|isSameFS (Path qualPath1, Path qualPath2)
specifier|private
specifier|static
name|boolean
name|isSameFS
parameter_list|(
name|Path
name|qualPath1
parameter_list|,
name|Path
name|qualPath2
parameter_list|)
block|{
name|URI
name|srcUri
init|=
name|qualPath1
operator|.
name|toUri
argument_list|()
decl_stmt|;
name|URI
name|dstUri
init|=
name|qualPath2
operator|.
name|toUri
argument_list|()
decl_stmt|;
return|return
operator|(
name|srcUri
operator|.
name|getAuthority
argument_list|()
operator|.
name|equals
argument_list|(
name|dstUri
operator|.
name|getAuthority
argument_list|()
argument_list|)
operator|&&
name|srcUri
operator|.
name|getAuthority
argument_list|()
operator|.
name|equals
argument_list|(
name|dstUri
operator|.
name|getAuthority
argument_list|()
argument_list|)
operator|)
return|;
block|}
comment|/**    * Deletes all the paths in deleteOnExit on JVM shutdown.    */
DECL|class|FileContextFinalizer
specifier|static
class|class
name|FileContextFinalizer
extends|extends
name|Thread
block|{
DECL|method|run ()
specifier|public
specifier|synchronized
name|void
name|run
parameter_list|()
block|{
name|processDeleteOnExit
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

