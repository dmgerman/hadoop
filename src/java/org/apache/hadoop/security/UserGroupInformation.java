begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.security
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
operator|.
name|HADOOP_SECURITY_AUTHENTICATION
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|UndeclaredThrowableException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AccessControlContext
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AccessController
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|Principal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|Subject
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|callback
operator|.
name|CallbackHandler
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|kerberos
operator|.
name|KerberosPrincipal
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|AppConfigurationEntry
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|LoginContext
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|LoginException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|AppConfigurationEntry
operator|.
name|LoginModuleControlFlag
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|spi
operator|.
name|LoginModule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenIdentifier
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|security
operator|.
name|auth
operator|.
name|NTUserPrincipal
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|security
operator|.
name|auth
operator|.
name|UnixPrincipal
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|security
operator|.
name|auth
operator|.
name|module
operator|.
name|Krb5LoginModule
import|;
end_import

begin_comment
comment|/**  * User and group information for Hadoop.  * This class wraps around a JAAS Subject and provides methods to determine the  * user's username and groups. It supports both the Windows, Unix and Kerberos   * login modules.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|,
literal|"MapReduce"
block|}
argument_list|)
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|UserGroupInformation
specifier|public
class|class
name|UserGroupInformation
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|UserGroupInformation
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * A login module that looks at the Kerberos, Unix, or Windows principal and    * adds the corresponding UserName.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|HadoopLoginModule
specifier|public
specifier|static
class|class
name|HadoopLoginModule
implements|implements
name|LoginModule
block|{
DECL|field|subject
specifier|private
name|Subject
name|subject
decl_stmt|;
annotation|@
name|Override
DECL|method|abort ()
specifier|public
name|boolean
name|abort
parameter_list|()
throws|throws
name|LoginException
block|{
return|return
literal|true
return|;
block|}
DECL|method|getCanonicalUser (Class<T> cls)
specifier|private
parameter_list|<
name|T
extends|extends
name|Principal
parameter_list|>
name|T
name|getCanonicalUser
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|cls
parameter_list|)
block|{
for|for
control|(
name|T
name|user
range|:
name|subject
operator|.
name|getPrincipals
argument_list|(
name|cls
argument_list|)
control|)
block|{
return|return
name|user
return|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|commit ()
specifier|public
name|boolean
name|commit
parameter_list|()
throws|throws
name|LoginException
block|{
comment|// if we already have a user, we are done.
if|if
condition|(
operator|!
name|subject
operator|.
name|getPrincipals
argument_list|(
name|User
operator|.
name|class
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|Principal
name|user
init|=
literal|null
decl_stmt|;
comment|// if we are using kerberos, try it out
if|if
condition|(
name|useKerberos
condition|)
block|{
name|user
operator|=
name|getCanonicalUser
argument_list|(
name|KerberosPrincipal
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|// if we don't have a kerberos user, use the OS user
if|if
condition|(
name|user
operator|==
literal|null
condition|)
block|{
name|user
operator|=
name|getCanonicalUser
argument_list|(
name|OS_PRINCIPAL_CLASS
argument_list|)
expr_stmt|;
block|}
comment|// if we found the user, add our principal
if|if
condition|(
name|user
operator|!=
literal|null
condition|)
block|{
name|subject
operator|.
name|getPrincipals
argument_list|()
operator|.
name|add
argument_list|(
operator|new
name|User
argument_list|(
name|user
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|LOG
operator|.
name|error
argument_list|(
literal|"Can't find user in "
operator|+
name|subject
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|LoginException
argument_list|(
literal|"Can't find user name"
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|initialize (Subject subject, CallbackHandler callbackHandler, Map<String, ?> sharedState, Map<String, ?> options)
specifier|public
name|void
name|initialize
parameter_list|(
name|Subject
name|subject
parameter_list|,
name|CallbackHandler
name|callbackHandler
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|sharedState
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|?
argument_list|>
name|options
parameter_list|)
block|{
name|this
operator|.
name|subject
operator|=
name|subject
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|login ()
specifier|public
name|boolean
name|login
parameter_list|()
throws|throws
name|LoginException
block|{
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|logout ()
specifier|public
name|boolean
name|logout
parameter_list|()
throws|throws
name|LoginException
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/** Are the static variables that depend on configuration initialized? */
DECL|field|isInitialized
specifier|private
specifier|static
name|boolean
name|isInitialized
init|=
literal|false
decl_stmt|;
comment|/** Should we use Kerberos configuration? */
DECL|field|useKerberos
specifier|private
specifier|static
name|boolean
name|useKerberos
decl_stmt|;
comment|/** Server-side groups fetching service */
DECL|field|groups
specifier|private
specifier|static
name|Groups
name|groups
decl_stmt|;
DECL|field|MIN_TIME_BEFORE_RELOGIN
specifier|public
specifier|static
specifier|final
name|long
name|MIN_TIME_BEFORE_RELOGIN
init|=
literal|10
operator|*
literal|60
operator|*
literal|1000L
decl_stmt|;
comment|/**Environment variable pointing to the token cache file*/
DECL|field|HADOOP_TOKEN_FILE_LOCATION
specifier|public
specifier|static
specifier|final
name|String
name|HADOOP_TOKEN_FILE_LOCATION
init|=
literal|"HADOOP_TOKEN_FILE_LOCATION"
decl_stmt|;
comment|/** The last relogin attempt */
DECL|field|lastReloginTime
specifier|private
name|long
name|lastReloginTime
init|=
literal|0
decl_stmt|;
comment|/**     * A method to initialize the fields that depend on a configuration.    * Must be called before useKerberos or groups is used.    */
DECL|method|ensureInitialized ()
specifier|private
specifier|static
specifier|synchronized
name|void
name|ensureInitialized
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isInitialized
condition|)
block|{
name|initialize
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set the configuration values for UGI.    * @param conf the configuration to use    */
DECL|method|initialize (Configuration conf)
specifier|private
specifier|static
specifier|synchronized
name|void
name|initialize
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|value
init|=
name|conf
operator|.
name|get
argument_list|(
name|HADOOP_SECURITY_AUTHENTICATION
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
operator|||
literal|"simple"
operator|.
name|equals
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|useKerberos
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"kerberos"
operator|.
name|equals
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|useKerberos
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid attribute value for "
operator|+
name|HADOOP_SECURITY_AUTHENTICATION
operator|+
literal|" of "
operator|+
name|value
argument_list|)
throw|;
block|}
comment|// If we haven't set up testing groups, use the configuration to find it
if|if
condition|(
operator|!
operator|(
name|groups
operator|instanceof
name|TestingGroups
operator|)
condition|)
block|{
name|groups
operator|=
name|Groups
operator|.
name|getUserToGroupsMappingService
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|// Set the configuration for JAAS to be the Hadoop configuration.
comment|// This is done here rather than a static initializer to avoid a
comment|// circular dependence.
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
operator|.
name|setConfiguration
argument_list|(
operator|new
name|HadoopConfiguration
argument_list|()
argument_list|)
expr_stmt|;
comment|// give the configuration on how to translate Kerberos names
try|try
block|{
name|KerberosName
operator|.
name|setConfiguration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Problem with Kerberos auth_to_local name "
operator|+
literal|"configuration"
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
name|isInitialized
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * Set the static configuration for UGI.    * In particular, set the security authentication mechanism and the    * group look up service.    * @param conf the configuration to use    */
DECL|method|setConfiguration (Configuration conf)
specifier|public
specifier|static
name|void
name|setConfiguration
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|initialize
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Determine if UserGroupInformation is using Kerberos to determine    * user identities or is relying on simple authentication    *     * @return true if UGI is working in a secure environment    */
DECL|method|isSecurityEnabled ()
specifier|public
specifier|static
name|boolean
name|isSecurityEnabled
parameter_list|()
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
return|return
name|useKerberos
return|;
block|}
comment|/**    * Information about the logged in user.    */
DECL|field|loginUser
specifier|private
specifier|static
name|UserGroupInformation
name|loginUser
init|=
literal|null
decl_stmt|;
DECL|field|keytabPrincipal
specifier|private
specifier|static
name|String
name|keytabPrincipal
init|=
literal|null
decl_stmt|;
DECL|field|keytabFile
specifier|private
specifier|static
name|String
name|keytabFile
init|=
literal|null
decl_stmt|;
DECL|field|subject
specifier|private
specifier|final
name|Subject
name|subject
decl_stmt|;
DECL|field|OS_LOGIN_MODULE_NAME
specifier|private
specifier|static
specifier|final
name|String
name|OS_LOGIN_MODULE_NAME
decl_stmt|;
DECL|field|OS_PRINCIPAL_CLASS
specifier|private
specifier|static
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|Principal
argument_list|>
name|OS_PRINCIPAL_CLASS
decl_stmt|;
DECL|field|windows
specifier|private
specifier|static
specifier|final
name|boolean
name|windows
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.name"
argument_list|)
operator|.
name|startsWith
argument_list|(
literal|"Windows"
argument_list|)
decl_stmt|;
static|static
block|{
if|if
condition|(
name|windows
condition|)
block|{
name|OS_LOGIN_MODULE_NAME
operator|=
literal|"com.sun.security.auth.module.NTLoginModule"
expr_stmt|;
name|OS_PRINCIPAL_CLASS
operator|=
name|NTUserPrincipal
operator|.
name|class
expr_stmt|;
block|}
else|else
block|{
name|OS_LOGIN_MODULE_NAME
operator|=
literal|"com.sun.security.auth.module.UnixLoginModule"
expr_stmt|;
name|OS_PRINCIPAL_CLASS
operator|=
name|UnixPrincipal
operator|.
name|class
expr_stmt|;
block|}
block|}
DECL|class|RealUser
specifier|private
specifier|static
class|class
name|RealUser
implements|implements
name|Principal
block|{
DECL|field|realUser
specifier|private
specifier|final
name|UserGroupInformation
name|realUser
decl_stmt|;
DECL|method|RealUser (UserGroupInformation realUser)
name|RealUser
parameter_list|(
name|UserGroupInformation
name|realUser
parameter_list|)
block|{
name|this
operator|.
name|realUser
operator|=
name|realUser
expr_stmt|;
block|}
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|realUser
operator|.
name|getUserName
argument_list|()
return|;
block|}
DECL|method|getRealUser ()
specifier|public
name|UserGroupInformation
name|getRealUser
parameter_list|()
block|{
return|return
name|realUser
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|realUser
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|RealUser
operator|)
name|o
operator|)
operator|.
name|realUser
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|realUser
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|realUser
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * A JAAS configuration that defines the login modules that we want    * to use for login.    */
DECL|class|HadoopConfiguration
specifier|private
specifier|static
class|class
name|HadoopConfiguration
extends|extends
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
block|{
DECL|field|SIMPLE_CONFIG_NAME
specifier|private
specifier|static
specifier|final
name|String
name|SIMPLE_CONFIG_NAME
init|=
literal|"hadoop-simple"
decl_stmt|;
DECL|field|USER_KERBEROS_CONFIG_NAME
specifier|private
specifier|static
specifier|final
name|String
name|USER_KERBEROS_CONFIG_NAME
init|=
literal|"hadoop-user-kerberos"
decl_stmt|;
DECL|field|KEYTAB_KERBEROS_CONFIG_NAME
specifier|private
specifier|static
specifier|final
name|String
name|KEYTAB_KERBEROS_CONFIG_NAME
init|=
literal|"hadoop-keytab-kerberos"
decl_stmt|;
DECL|field|OS_SPECIFIC_LOGIN
specifier|private
specifier|static
specifier|final
name|AppConfigurationEntry
name|OS_SPECIFIC_LOGIN
init|=
operator|new
name|AppConfigurationEntry
argument_list|(
name|OS_LOGIN_MODULE_NAME
argument_list|,
name|LoginModuleControlFlag
operator|.
name|REQUIRED
argument_list|,
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|HADOOP_LOGIN
specifier|private
specifier|static
specifier|final
name|AppConfigurationEntry
name|HADOOP_LOGIN
init|=
operator|new
name|AppConfigurationEntry
argument_list|(
name|HadoopLoginModule
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|,
name|LoginModuleControlFlag
operator|.
name|REQUIRED
argument_list|,
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|USER_KERBEROS_OPTIONS
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|USER_KERBEROS_OPTIONS
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|USER_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"doNotPrompt"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|USER_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"useTicketCache"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|USER_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"renewTGT"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|String
name|ticketCache
init|=
name|System
operator|.
name|getenv
argument_list|(
literal|"KRB5CCNAME"
argument_list|)
decl_stmt|;
if|if
condition|(
name|ticketCache
operator|!=
literal|null
condition|)
block|{
name|USER_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"ticketCache"
argument_list|,
name|ticketCache
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|USER_KERBEROS_LOGIN
specifier|private
specifier|static
specifier|final
name|AppConfigurationEntry
name|USER_KERBEROS_LOGIN
init|=
operator|new
name|AppConfigurationEntry
argument_list|(
name|Krb5LoginModule
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|,
name|LoginModuleControlFlag
operator|.
name|OPTIONAL
argument_list|,
name|USER_KERBEROS_OPTIONS
argument_list|)
decl_stmt|;
DECL|field|KEYTAB_KERBEROS_OPTIONS
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|KEYTAB_KERBEROS_OPTIONS
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"doNotPrompt"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"useKeyTab"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"storeKey"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
DECL|field|KEYTAB_KERBEROS_LOGIN
specifier|private
specifier|static
specifier|final
name|AppConfigurationEntry
name|KEYTAB_KERBEROS_LOGIN
init|=
operator|new
name|AppConfigurationEntry
argument_list|(
name|Krb5LoginModule
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|,
name|LoginModuleControlFlag
operator|.
name|REQUIRED
argument_list|,
name|KEYTAB_KERBEROS_OPTIONS
argument_list|)
decl_stmt|;
DECL|field|SIMPLE_CONF
specifier|private
specifier|static
specifier|final
name|AppConfigurationEntry
index|[]
name|SIMPLE_CONF
init|=
operator|new
name|AppConfigurationEntry
index|[]
block|{
name|OS_SPECIFIC_LOGIN
block|,
name|HADOOP_LOGIN
block|}
decl_stmt|;
DECL|field|USER_KERBEROS_CONF
specifier|private
specifier|static
specifier|final
name|AppConfigurationEntry
index|[]
name|USER_KERBEROS_CONF
init|=
operator|new
name|AppConfigurationEntry
index|[]
block|{
name|OS_SPECIFIC_LOGIN
block|,
name|USER_KERBEROS_LOGIN
block|,
name|HADOOP_LOGIN
block|}
decl_stmt|;
DECL|field|KEYTAB_KERBEROS_CONF
specifier|private
specifier|static
specifier|final
name|AppConfigurationEntry
index|[]
name|KEYTAB_KERBEROS_CONF
init|=
operator|new
name|AppConfigurationEntry
index|[]
block|{
name|KEYTAB_KERBEROS_LOGIN
block|,
name|HADOOP_LOGIN
block|}
decl_stmt|;
annotation|@
name|Override
DECL|method|getAppConfigurationEntry (String appName)
specifier|public
name|AppConfigurationEntry
index|[]
name|getAppConfigurationEntry
parameter_list|(
name|String
name|appName
parameter_list|)
block|{
if|if
condition|(
name|SIMPLE_CONFIG_NAME
operator|.
name|equals
argument_list|(
name|appName
argument_list|)
condition|)
block|{
return|return
name|SIMPLE_CONF
return|;
block|}
elseif|else
if|if
condition|(
name|USER_KERBEROS_CONFIG_NAME
operator|.
name|equals
argument_list|(
name|appName
argument_list|)
condition|)
block|{
return|return
name|USER_KERBEROS_CONF
return|;
block|}
elseif|else
if|if
condition|(
name|KEYTAB_KERBEROS_CONFIG_NAME
operator|.
name|equals
argument_list|(
name|appName
argument_list|)
condition|)
block|{
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"keyTab"
argument_list|,
name|keytabFile
argument_list|)
expr_stmt|;
name|KEYTAB_KERBEROS_OPTIONS
operator|.
name|put
argument_list|(
literal|"principal"
argument_list|,
name|keytabPrincipal
argument_list|)
expr_stmt|;
return|return
name|KEYTAB_KERBEROS_CONF
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
DECL|method|getLogin ()
specifier|private
name|LoginContext
name|getLogin
parameter_list|()
block|{
for|for
control|(
name|User
name|p
range|:
name|subject
operator|.
name|getPrincipals
argument_list|(
name|User
operator|.
name|class
argument_list|)
control|)
block|{
return|return
name|p
operator|.
name|getLogin
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|setLogin (LoginContext login)
specifier|private
name|void
name|setLogin
parameter_list|(
name|LoginContext
name|login
parameter_list|)
block|{
for|for
control|(
name|User
name|p
range|:
name|subject
operator|.
name|getPrincipals
argument_list|(
name|User
operator|.
name|class
argument_list|)
control|)
block|{
name|p
operator|.
name|setLogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Create a UserGroupInformation for the given subject.    * This does not change the subject or acquire new credentials.    * @param subject the user's subject    */
DECL|method|UserGroupInformation (Subject subject)
name|UserGroupInformation
parameter_list|(
name|Subject
name|subject
parameter_list|)
block|{
name|this
operator|.
name|subject
operator|=
name|subject
expr_stmt|;
block|}
comment|/**    * Return the current user, including any doAs in the current stack.    * @return the current user    * @throws IOException if login fails    */
DECL|method|getCurrentUser ()
specifier|public
specifier|static
name|UserGroupInformation
name|getCurrentUser
parameter_list|()
throws|throws
name|IOException
block|{
name|AccessControlContext
name|context
init|=
name|AccessController
operator|.
name|getContext
argument_list|()
decl_stmt|;
name|Subject
name|subject
init|=
name|Subject
operator|.
name|getSubject
argument_list|(
name|context
argument_list|)
decl_stmt|;
return|return
name|subject
operator|==
literal|null
condition|?
name|getLoginUser
argument_list|()
else|:
operator|new
name|UserGroupInformation
argument_list|(
name|subject
argument_list|)
return|;
block|}
comment|/**    * Get the currently logged in user.    * @return the logged in user    * @throws IOException if login fails    */
specifier|public
specifier|synchronized
DECL|method|getLoginUser ()
specifier|static
name|UserGroupInformation
name|getLoginUser
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|loginUser
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|Subject
name|subject
init|=
operator|new
name|Subject
argument_list|()
decl_stmt|;
name|loginUser
operator|=
operator|new
name|UserGroupInformation
argument_list|(
name|subject
argument_list|)
expr_stmt|;
name|LoginContext
name|login
decl_stmt|;
if|if
condition|(
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|login
operator|=
operator|new
name|LoginContext
argument_list|(
name|HadoopConfiguration
operator|.
name|USER_KERBEROS_CONFIG_NAME
argument_list|,
name|subject
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|login
operator|=
operator|new
name|LoginContext
argument_list|(
name|HadoopConfiguration
operator|.
name|SIMPLE_CONFIG_NAME
argument_list|,
name|subject
argument_list|)
expr_stmt|;
block|}
name|login
operator|.
name|login
argument_list|()
expr_stmt|;
name|loginUser
operator|.
name|setLogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
name|loginUser
operator|=
operator|new
name|UserGroupInformation
argument_list|(
name|login
operator|.
name|getSubject
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|tokenFile
init|=
name|System
operator|.
name|getenv
argument_list|(
name|HADOOP_TOKEN_FILE_LOCATION
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokenFile
operator|!=
literal|null
operator|&&
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|Credentials
operator|.
name|readTokensAndLoadInUGI
argument_list|(
name|tokenFile
argument_list|,
operator|new
name|Configuration
argument_list|()
argument_list|,
name|loginUser
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|LoginException
name|le
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"failure to login"
argument_list|,
name|le
argument_list|)
throw|;
block|}
block|}
return|return
name|loginUser
return|;
block|}
comment|/**    * Log a user in from a keytab file. Loads a user identity from a keytab    * file and login them in. They become the currently logged-in user.    * @param user the principal name to load from the keytab    * @param path the path to the keytab file    * @throws IOException if the keytab file can't be read    */
specifier|public
specifier|synchronized
DECL|method|loginUserFromKeytab (String user, String path )
specifier|static
name|void
name|loginUserFromKeytab
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isSecurityEnabled
argument_list|()
condition|)
return|return;
name|keytabFile
operator|=
name|path
expr_stmt|;
name|keytabPrincipal
operator|=
name|user
expr_stmt|;
name|Subject
name|subject
init|=
operator|new
name|Subject
argument_list|()
decl_stmt|;
name|LoginContext
name|login
decl_stmt|;
try|try
block|{
name|login
operator|=
operator|new
name|LoginContext
argument_list|(
name|HadoopConfiguration
operator|.
name|KEYTAB_KERBEROS_CONFIG_NAME
argument_list|,
name|subject
argument_list|)
expr_stmt|;
name|login
operator|.
name|login
argument_list|()
expr_stmt|;
name|loginUser
operator|=
operator|new
name|UserGroupInformation
argument_list|(
name|subject
argument_list|)
expr_stmt|;
name|loginUser
operator|.
name|setLogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LoginException
name|le
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Login failure for "
operator|+
name|user
operator|+
literal|" from keytab "
operator|+
name|path
argument_list|,
name|le
argument_list|)
throw|;
block|}
block|}
comment|/**    * Re-Login a user in from a keytab file. Loads a user identity from a keytab    * file and login them in. They become the currently logged-in user. This    * method assumes that {@link #loginUserFromKeytab(String, String)} had     * happened already.    * The Subject field of this UserGroupInformation object is updated to have    * the new credentials.    * @throws IOException on a failure    */
DECL|method|reloginFromKeytab ()
specifier|public
specifier|synchronized
name|void
name|reloginFromKeytab
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isSecurityEnabled
argument_list|()
condition|)
return|return;
name|LoginContext
name|login
init|=
name|getLogin
argument_list|()
decl_stmt|;
if|if
condition|(
name|login
operator|==
literal|null
operator|||
name|keytabFile
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"loginUserFromKeyTab must be done first"
argument_list|)
throw|;
block|}
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|now
operator|-
name|lastReloginTime
operator|<
name|MIN_TIME_BEFORE_RELOGIN
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Not attempting to re-login since the last re-login was "
operator|+
literal|"attempted less than "
operator|+
operator|(
name|MIN_TIME_BEFORE_RELOGIN
operator|/
literal|1000
operator|)
operator|+
literal|" seconds"
operator|+
literal|" before."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// register most recent relogin
name|lastReloginTime
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Initiating logout for "
operator|+
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
comment|//clear up the kerberos state. But the tokens are not cleared! As per
comment|//the Java kerberos login module code, only the kerberos credentials
comment|//are cleared
name|login
operator|.
name|logout
argument_list|()
expr_stmt|;
comment|//login and also update the subject field of this instance to
comment|//have the new credentials (pass it to the LoginContext constructor)
name|login
operator|=
operator|new
name|LoginContext
argument_list|(
name|HadoopConfiguration
operator|.
name|KEYTAB_KERBEROS_CONFIG_NAME
argument_list|,
name|getSubject
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Initiating re-login for "
operator|+
name|keytabPrincipal
argument_list|)
expr_stmt|;
name|login
operator|.
name|login
argument_list|()
expr_stmt|;
name|setLogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LoginException
name|le
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Login failure for "
operator|+
name|keytabPrincipal
operator|+
literal|" from keytab "
operator|+
name|keytabFile
argument_list|,
name|le
argument_list|)
throw|;
block|}
block|}
comment|/**    * Log a user in from a keytab file. Loads a user identity from a keytab    * file and login them in. This new user does not affect the currently    * logged-in user.    * @param user the principal name to load from the keytab    * @param path the path to the keytab file    * @throws IOException if the keytab file can't be read    */
specifier|public
specifier|synchronized
DECL|method|loginUserFromKeytabAndReturnUGI (String user, String path )
specifier|static
name|UserGroupInformation
name|loginUserFromKeytabAndReturnUGI
parameter_list|(
name|String
name|user
parameter_list|,
name|String
name|path
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isSecurityEnabled
argument_list|()
condition|)
return|return
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
return|;
name|String
name|oldKeytabFile
init|=
literal|null
decl_stmt|;
name|String
name|oldKeytabPrincipal
init|=
literal|null
decl_stmt|;
try|try
block|{
name|oldKeytabFile
operator|=
name|keytabFile
expr_stmt|;
name|oldKeytabPrincipal
operator|=
name|keytabPrincipal
expr_stmt|;
name|keytabFile
operator|=
name|path
expr_stmt|;
name|keytabPrincipal
operator|=
name|user
expr_stmt|;
name|Subject
name|subject
init|=
operator|new
name|Subject
argument_list|()
decl_stmt|;
name|LoginContext
name|login
init|=
operator|new
name|LoginContext
argument_list|(
name|HadoopConfiguration
operator|.
name|KEYTAB_KERBEROS_CONFIG_NAME
argument_list|,
name|subject
argument_list|)
decl_stmt|;
name|login
operator|.
name|login
argument_list|()
expr_stmt|;
name|UserGroupInformation
name|newLoginUser
init|=
operator|new
name|UserGroupInformation
argument_list|(
name|subject
argument_list|)
decl_stmt|;
name|newLoginUser
operator|.
name|setLogin
argument_list|(
name|login
argument_list|)
expr_stmt|;
return|return
name|newLoginUser
return|;
block|}
catch|catch
parameter_list|(
name|LoginException
name|le
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Login failure for "
operator|+
name|user
operator|+
literal|" from keytab "
operator|+
name|path
argument_list|,
name|le
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|oldKeytabFile
operator|!=
literal|null
condition|)
name|keytabFile
operator|=
name|oldKeytabFile
expr_stmt|;
if|if
condition|(
name|oldKeytabPrincipal
operator|!=
literal|null
condition|)
name|keytabPrincipal
operator|=
name|oldKeytabPrincipal
expr_stmt|;
block|}
block|}
DECL|method|isLoginKeytabBased ()
specifier|public
specifier|synchronized
specifier|static
name|boolean
name|isLoginKeytabBased
parameter_list|()
block|{
return|return
name|keytabFile
operator|!=
literal|null
return|;
block|}
comment|/**    * Create a user from a login name. It is intended to be used for remote    * users in RPC, since it won't have any credentials.    * @param user the full user principal name, must not be empty or null    * @return the UserGroupInformation for the remote user.    */
DECL|method|createRemoteUser (String user)
specifier|public
specifier|static
name|UserGroupInformation
name|createRemoteUser
parameter_list|(
name|String
name|user
parameter_list|)
block|{
if|if
condition|(
name|user
operator|==
literal|null
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|user
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Null user"
argument_list|)
throw|;
block|}
name|Subject
name|subject
init|=
operator|new
name|Subject
argument_list|()
decl_stmt|;
name|subject
operator|.
name|getPrincipals
argument_list|()
operator|.
name|add
argument_list|(
operator|new
name|User
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|UserGroupInformation
argument_list|(
name|subject
argument_list|)
return|;
block|}
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|enum|AuthenticationMethod
specifier|public
specifier|static
enum|enum
name|AuthenticationMethod
block|{
DECL|enumConstant|SIMPLE
name|SIMPLE
block|,
DECL|enumConstant|KERBEROS
name|KERBEROS
block|,
DECL|enumConstant|TOKEN
name|TOKEN
block|,
DECL|enumConstant|CERTIFICATE
name|CERTIFICATE
block|,
DECL|enumConstant|KERBEROS_SSL
name|KERBEROS_SSL
block|,
DECL|enumConstant|PROXY
name|PROXY
block|;   }
comment|/* Create a proxy user using username of the effective user and the ugi of the    * real user.    *    * @param effective    *          user, UGI for real user.    * @return    */
DECL|method|createProxyUser (String user, UserGroupInformation realUser)
specifier|public
specifier|static
name|UserGroupInformation
name|createProxyUser
parameter_list|(
name|String
name|user
parameter_list|,
name|UserGroupInformation
name|realUser
parameter_list|)
block|{
if|if
condition|(
name|user
operator|==
literal|null
operator|||
literal|""
operator|.
name|equals
argument_list|(
name|user
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Null user"
argument_list|)
throw|;
block|}
if|if
condition|(
name|realUser
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Null real user"
argument_list|)
throw|;
block|}
name|Subject
name|subject
init|=
operator|new
name|Subject
argument_list|()
decl_stmt|;
name|subject
operator|.
name|getPrincipals
argument_list|()
operator|.
name|add
argument_list|(
operator|new
name|User
argument_list|(
name|user
argument_list|)
argument_list|)
expr_stmt|;
name|subject
operator|.
name|getPrincipals
argument_list|()
operator|.
name|add
argument_list|(
operator|new
name|RealUser
argument_list|(
name|realUser
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|UserGroupInformation
argument_list|(
name|subject
argument_list|)
return|;
block|}
DECL|method|getRealUser ()
specifier|public
name|UserGroupInformation
name|getRealUser
parameter_list|()
block|{
for|for
control|(
name|RealUser
name|p
range|:
name|subject
operator|.
name|getPrincipals
argument_list|(
name|RealUser
operator|.
name|class
argument_list|)
control|)
block|{
return|return
name|p
operator|.
name|getRealUser
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * This class is used for storing the groups for testing. It stores a local    * map that has the translation of usernames to groups.    */
DECL|class|TestingGroups
specifier|private
specifier|static
class|class
name|TestingGroups
extends|extends
name|Groups
block|{
DECL|field|userToGroupsMapping
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|userToGroupsMapping
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|TestingGroups ()
specifier|private
name|TestingGroups
parameter_list|()
block|{
name|super
argument_list|(
operator|new
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getGroups (String user)
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getGroups
parameter_list|(
name|String
name|user
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
name|userToGroupsMapping
operator|.
name|get
argument_list|(
name|user
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|result
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|setUserGroups (String user, String[] groups)
specifier|private
name|void
name|setUserGroups
parameter_list|(
name|String
name|user
parameter_list|,
name|String
index|[]
name|groups
parameter_list|)
block|{
name|userToGroupsMapping
operator|.
name|put
argument_list|(
name|user
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|groups
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Create a UGI for testing HDFS and MapReduce    * @param user the full user principal name    * @param userGroups the names of the groups that the user belongs to    * @return a fake user for running unit tests    */
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|,
literal|"MapReduce"
block|}
argument_list|)
DECL|method|createUserForTesting (String user, String[] userGroups)
specifier|public
specifier|static
name|UserGroupInformation
name|createUserForTesting
parameter_list|(
name|String
name|user
parameter_list|,
name|String
index|[]
name|userGroups
parameter_list|)
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
name|UserGroupInformation
name|ugi
init|=
name|createRemoteUser
argument_list|(
name|user
argument_list|)
decl_stmt|;
comment|// make sure that the testing object is setup
if|if
condition|(
operator|!
operator|(
name|groups
operator|instanceof
name|TestingGroups
operator|)
condition|)
block|{
name|groups
operator|=
operator|new
name|TestingGroups
argument_list|()
expr_stmt|;
block|}
comment|// add the user groups
operator|(
operator|(
name|TestingGroups
operator|)
name|groups
operator|)
operator|.
name|setUserGroups
argument_list|(
name|ugi
operator|.
name|getShortUserName
argument_list|()
argument_list|,
name|userGroups
argument_list|)
expr_stmt|;
return|return
name|ugi
return|;
block|}
comment|/**    * Create a proxy user UGI for testing HDFS and MapReduce    *     * @param user    *          the full user principal name for effective user    * @param realUser    *          UGI of the real user    * @param userGroups    *          the names of the groups that the user belongs to    * @return a fake user for running unit tests    */
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|,
literal|"MapReduce"
block|}
argument_list|)
DECL|method|createProxyUserForTesting (String user, UserGroupInformation realUser, String[] userGroups)
specifier|public
specifier|static
name|UserGroupInformation
name|createProxyUserForTesting
parameter_list|(
name|String
name|user
parameter_list|,
name|UserGroupInformation
name|realUser
parameter_list|,
name|String
index|[]
name|userGroups
parameter_list|)
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
name|UserGroupInformation
name|ugi
init|=
name|createProxyUser
argument_list|(
name|user
argument_list|,
name|realUser
argument_list|)
decl_stmt|;
comment|// make sure that the testing object is setup
if|if
condition|(
operator|!
operator|(
name|groups
operator|instanceof
name|TestingGroups
operator|)
condition|)
block|{
name|groups
operator|=
operator|new
name|TestingGroups
argument_list|()
expr_stmt|;
block|}
comment|// add the user groups
operator|(
operator|(
name|TestingGroups
operator|)
name|groups
operator|)
operator|.
name|setUserGroups
argument_list|(
name|ugi
operator|.
name|getShortUserName
argument_list|()
argument_list|,
name|userGroups
argument_list|)
expr_stmt|;
return|return
name|ugi
return|;
block|}
comment|/**    * Get the user's login name.    * @return the user's name up to the first '/' or '@'.    */
DECL|method|getShortUserName ()
specifier|public
name|String
name|getShortUserName
parameter_list|()
block|{
for|for
control|(
name|User
name|p
range|:
name|subject
operator|.
name|getPrincipals
argument_list|(
name|User
operator|.
name|class
argument_list|)
control|)
block|{
return|return
name|p
operator|.
name|getShortName
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Get the user's full principal name.    * @return the user's full principal name.    */
DECL|method|getUserName ()
specifier|public
name|String
name|getUserName
parameter_list|()
block|{
for|for
control|(
name|User
name|p
range|:
name|subject
operator|.
name|getPrincipals
argument_list|(
name|User
operator|.
name|class
argument_list|)
control|)
block|{
return|return
name|p
operator|.
name|getName
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Add a TokenIdentifier to this UGI. The TokenIdentifier has typically been    * authenticated by the RPC layer as belonging to the user represented by this    * UGI.    *     * @param tokenId    *          tokenIdentifier to be added    * @return true on successful add of new tokenIdentifier    */
DECL|method|addTokenIdentifier (TokenIdentifier tokenId)
specifier|public
specifier|synchronized
name|boolean
name|addTokenIdentifier
parameter_list|(
name|TokenIdentifier
name|tokenId
parameter_list|)
block|{
return|return
name|subject
operator|.
name|getPublicCredentials
argument_list|()
operator|.
name|add
argument_list|(
name|tokenId
argument_list|)
return|;
block|}
comment|/**    * Get the set of TokenIdentifiers belonging to this UGI    *     * @return the set of TokenIdentifiers belonging to this UGI    */
DECL|method|getTokenIdentifiers ()
specifier|public
specifier|synchronized
name|Set
argument_list|<
name|TokenIdentifier
argument_list|>
name|getTokenIdentifiers
parameter_list|()
block|{
return|return
name|subject
operator|.
name|getPublicCredentials
argument_list|(
name|TokenIdentifier
operator|.
name|class
argument_list|)
return|;
block|}
comment|/**    * Add a token to this UGI    *     * @param token Token to be added    * @return true on successful add of new token    */
DECL|method|addToken (Token<? extends TokenIdentifier> token)
specifier|public
specifier|synchronized
name|boolean
name|addToken
parameter_list|(
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|token
parameter_list|)
block|{
return|return
name|subject
operator|.
name|getPrivateCredentials
argument_list|()
operator|.
name|add
argument_list|(
name|token
argument_list|)
return|;
block|}
comment|/**    * Obtain the collection of tokens associated with this user.    *     * @return an unmodifiable collection of tokens associated with user    */
specifier|public
specifier|synchronized
DECL|method|getTokens ()
name|Collection
argument_list|<
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
argument_list|>
name|getTokens
parameter_list|()
block|{
name|Set
argument_list|<
name|Object
argument_list|>
name|creds
init|=
name|subject
operator|.
name|getPrivateCredentials
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Token
argument_list|<
name|?
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|Token
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|(
name|creds
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|creds
control|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Token
argument_list|<
name|?
argument_list|>
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
operator|(
name|Token
argument_list|<
name|?
argument_list|>
operator|)
name|o
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|result
argument_list|)
return|;
block|}
comment|/**    * Get the group names for this user.    * @return the list of users with the primary group first. If the command    *    fails, it returns an empty list.    */
DECL|method|getGroupNames ()
specifier|public
specifier|synchronized
name|String
index|[]
name|getGroupNames
parameter_list|()
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
try|try
block|{
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
name|groups
operator|.
name|getGroups
argument_list|(
name|getShortUserName
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|result
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|result
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"No groups available for user "
operator|+
name|getShortUserName
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|String
index|[
literal|0
index|]
return|;
block|}
block|}
comment|/**    * Return the username.    */
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|getRealUser
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|getUserName
argument_list|()
operator|+
literal|" via "
operator|+
name|getRealUser
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|getUserName
argument_list|()
return|;
block|}
block|}
comment|/**    * Sets the authentication method in the subject    *     * @param authMethod    */
specifier|public
specifier|synchronized
DECL|method|setAuthenticationMethod (AuthenticationMethod authMethod)
name|void
name|setAuthenticationMethod
parameter_list|(
name|AuthenticationMethod
name|authMethod
parameter_list|)
block|{
for|for
control|(
name|User
name|p
range|:
name|subject
operator|.
name|getPrincipals
argument_list|(
name|User
operator|.
name|class
argument_list|)
control|)
block|{
name|p
operator|.
name|setAuthenticationMethod
argument_list|(
name|authMethod
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get the authentication method from the subject    *     * @return AuthenticationMethod in the subject, null if not present.    */
DECL|method|getAuthenticationMethod ()
specifier|public
specifier|synchronized
name|AuthenticationMethod
name|getAuthenticationMethod
parameter_list|()
block|{
for|for
control|(
name|User
name|p
range|:
name|subject
operator|.
name|getPrincipals
argument_list|(
name|User
operator|.
name|class
argument_list|)
control|)
block|{
return|return
name|p
operator|.
name|getAuthenticationMethod
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Returns the authentication method of a ugi. If the authentication method is    * PROXY, returns the authentication method of the real user.    *     * @param ugi    * @return AuthenticationMethod    */
DECL|method|getRealAuthenticationMethod ( UserGroupInformation ugi)
specifier|public
specifier|static
name|AuthenticationMethod
name|getRealAuthenticationMethod
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|)
block|{
name|AuthenticationMethod
name|authMethod
init|=
name|ugi
operator|.
name|getAuthenticationMethod
argument_list|()
decl_stmt|;
if|if
condition|(
name|authMethod
operator|==
name|AuthenticationMethod
operator|.
name|PROXY
condition|)
block|{
name|authMethod
operator|=
name|ugi
operator|.
name|getRealUser
argument_list|()
operator|.
name|getAuthenticationMethod
argument_list|()
expr_stmt|;
block|}
return|return
name|authMethod
return|;
block|}
comment|/**    * Compare the subjects to see if they are equal to each other.    */
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|subject
operator|==
operator|(
operator|(
name|UserGroupInformation
operator|)
name|o
operator|)
operator|.
name|subject
return|;
block|}
block|}
comment|/**    * Return the hash of the subject.    */
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|System
operator|.
name|identityHashCode
argument_list|(
name|subject
argument_list|)
return|;
block|}
comment|/**    * Get the underlying subject from this ugi.    * @return the subject that represents this user.    */
DECL|method|getSubject ()
specifier|protected
name|Subject
name|getSubject
parameter_list|()
block|{
return|return
name|subject
return|;
block|}
comment|/**    * Run the given action as the user.    * @param<T> the return type of the run method    * @param action the method to execute    * @return the value from the run method    */
DECL|method|doAs (PrivilegedAction<T> action)
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|doAs
parameter_list|(
name|PrivilegedAction
argument_list|<
name|T
argument_list|>
name|action
parameter_list|)
block|{
return|return
name|Subject
operator|.
name|doAs
argument_list|(
name|subject
argument_list|,
name|action
argument_list|)
return|;
block|}
comment|/**    * Run the given action as the user, potentially throwing an exception.    * @param<T> the return type of the run method    * @param action the method to execute    * @return the value from the run method    * @throws IOException if the action throws an IOException    * @throws Error if the action throws an Error    * @throws RuntimeException if the action throws a RuntimeException    * @throws InterruptedException if the action throws an InterruptedException    * @throws UndeclaredThrowableException if the action throws something else    */
DECL|method|doAs (PrivilegedExceptionAction<T> action )
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|doAs
parameter_list|(
name|PrivilegedExceptionAction
argument_list|<
name|T
argument_list|>
name|action
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
try|try
block|{
return|return
name|Subject
operator|.
name|doAs
argument_list|(
name|subject
argument_list|,
name|action
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|PrivilegedActionException
name|pae
parameter_list|)
block|{
name|Throwable
name|cause
init|=
name|pae
operator|.
name|getCause
argument_list|()
decl_stmt|;
if|if
condition|(
name|cause
operator|instanceof
name|IOException
condition|)
block|{
throw|throw
operator|(
name|IOException
operator|)
name|cause
throw|;
block|}
elseif|else
if|if
condition|(
name|cause
operator|instanceof
name|Error
condition|)
block|{
throw|throw
operator|(
name|Error
operator|)
name|cause
throw|;
block|}
elseif|else
if|if
condition|(
name|cause
operator|instanceof
name|RuntimeException
condition|)
block|{
throw|throw
operator|(
name|RuntimeException
operator|)
name|cause
throw|;
block|}
elseif|else
if|if
condition|(
name|cause
operator|instanceof
name|InterruptedException
condition|)
block|{
throw|throw
operator|(
name|InterruptedException
operator|)
name|cause
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|UndeclaredThrowableException
argument_list|(
name|pae
argument_list|,
literal|"Unknown exception in doAs"
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|print ()
specifier|private
name|void
name|print
parameter_list|()
throws|throws
name|IOException
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"User: "
operator|+
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"Group Ids: "
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
name|String
index|[]
name|groups
init|=
name|getGroupNames
argument_list|()
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"Groups: "
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|groups
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
name|groups
index|[
name|i
index|]
operator|+
literal|" "
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
comment|/**    * A test method to print out the current user's UGI.    * @param args if there are two arguments, read the user from the keytab    * and print it out.    * @throws Exception    */
DECL|method|main (String [] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Getting UGI for current user"
argument_list|)
expr_stmt|;
name|UserGroupInformation
name|ugi
init|=
name|getCurrentUser
argument_list|()
decl_stmt|;
name|ugi
operator|.
name|print
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"UGI: "
operator|+
name|ugi
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"============================================================"
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|length
operator|==
literal|2
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Getting UGI from keytab...."
argument_list|)
expr_stmt|;
name|loginUserFromKeytab
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|getCurrentUser
argument_list|()
operator|.
name|print
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Keytab: "
operator|+
name|ugi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

