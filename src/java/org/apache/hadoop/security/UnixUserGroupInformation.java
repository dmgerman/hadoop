begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.security
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|LoginException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableUtils
import|;
end_import

begin_comment
comment|/** An implementation of UserGroupInformation in the Unix system */
end_comment

begin_class
DECL|class|UnixUserGroupInformation
specifier|public
class|class
name|UnixUserGroupInformation
extends|extends
name|UserGroupInformation
block|{
DECL|field|DEFAULT_USERNAME
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_USERNAME
init|=
literal|"DrWho"
decl_stmt|;
DECL|field|DEFAULT_GROUP
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_GROUP
init|=
literal|"Tardis"
decl_stmt|;
DECL|field|UGI_PROPERTY_NAME
specifier|final
specifier|static
specifier|public
name|String
name|UGI_PROPERTY_NAME
init|=
literal|"hadoop.job.ugi"
decl_stmt|;
DECL|field|user2UGIMap
specifier|final
specifier|static
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|UnixUserGroupInformation
argument_list|>
name|user2UGIMap
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|UnixUserGroupInformation
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Create an immutable {@link UnixUserGroupInformation} object. */
DECL|method|createImmutable (String[] ugi)
specifier|public
specifier|static
name|UnixUserGroupInformation
name|createImmutable
parameter_list|(
name|String
index|[]
name|ugi
parameter_list|)
block|{
return|return
operator|new
name|UnixUserGroupInformation
argument_list|(
name|ugi
argument_list|)
block|{
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
DECL|field|userName
specifier|private
name|String
name|userName
decl_stmt|;
DECL|field|groupNames
specifier|private
name|String
index|[]
name|groupNames
decl_stmt|;
comment|/** Default constructor    */
DECL|method|UnixUserGroupInformation ()
specifier|public
name|UnixUserGroupInformation
parameter_list|()
block|{   }
comment|/** Constructor with parameters user name and its group names.    * The first entry in the groups list is the default  group.    *     * @param userName a user's name    * @param groupNames groups list, first of which is the default group    * @exception IllegalArgumentException if any argument is null    */
DECL|method|UnixUserGroupInformation (String userName, String[] groupNames)
specifier|public
name|UnixUserGroupInformation
parameter_list|(
name|String
name|userName
parameter_list|,
name|String
index|[]
name|groupNames
parameter_list|)
block|{
name|setUserGroupNames
argument_list|(
name|userName
argument_list|,
name|groupNames
argument_list|)
expr_stmt|;
block|}
comment|/** Constructor with parameter user/group names    *     * @param ugi an array containing user/group names, the first    *                     element of which is the user name, the second of    *                     which is the default group name.    * @exception IllegalArgumentException if the array size is less than 2     *                                     or any element is null.    */
DECL|method|UnixUserGroupInformation (String[] ugi)
specifier|public
name|UnixUserGroupInformation
parameter_list|(
name|String
index|[]
name|ugi
parameter_list|)
block|{
if|if
condition|(
name|ugi
operator|==
literal|null
operator|||
name|ugi
operator|.
name|length
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parameter does contain at least "
operator|+
literal|"one user name and one group name"
argument_list|)
throw|;
block|}
name|String
index|[]
name|groupNames
init|=
operator|new
name|String
index|[
name|ugi
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|ugi
argument_list|,
literal|1
argument_list|,
name|groupNames
argument_list|,
literal|0
argument_list|,
name|groupNames
operator|.
name|length
argument_list|)
expr_stmt|;
name|setUserGroupNames
argument_list|(
name|ugi
index|[
literal|0
index|]
argument_list|,
name|groupNames
argument_list|)
expr_stmt|;
block|}
comment|/* Set this object's user name and group names    *     * @param userName a user's name    * @param groupNames groups list, the first of which is the default group    * @exception IllegalArgumentException if any argument is null    */
DECL|method|setUserGroupNames (String userName, String[] groupNames)
specifier|private
name|void
name|setUserGroupNames
parameter_list|(
name|String
name|userName
parameter_list|,
name|String
index|[]
name|groupNames
parameter_list|)
block|{
if|if
condition|(
name|userName
operator|==
literal|null
operator|||
name|userName
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"username should not be null nor empty"
argument_list|)
throw|;
block|}
if|if
condition|(
name|groupNames
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"group names array should not be null"
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|groupNames
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|groupNames
index|[
name|i
index|]
operator|==
literal|null
operator|||
name|groupNames
index|[
name|i
index|]
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"A null group name at index "
operator|+
name|i
argument_list|)
throw|;
block|}
block|}
name|this
operator|.
name|userName
operator|=
name|userName
expr_stmt|;
name|this
operator|.
name|groupNames
operator|=
name|groupNames
expr_stmt|;
block|}
comment|/** Return an array of group names    */
DECL|method|getGroupNames ()
specifier|public
name|String
index|[]
name|getGroupNames
parameter_list|()
block|{
return|return
name|groupNames
return|;
block|}
comment|/** Return the user's name    */
DECL|method|getUserName ()
specifier|public
name|String
name|getUserName
parameter_list|()
block|{
return|return
name|userName
return|;
block|}
comment|/* The following two methods implements Writable interface */
DECL|field|UGI_TECHNOLOGY
specifier|final
specifier|private
specifier|static
name|String
name|UGI_TECHNOLOGY
init|=
literal|"STRING_UGI"
decl_stmt|;
comment|/** Deserialize this object    * First check if this is a UGI in the string format.    * If no, throw an IOException; otherwise    * set this object's fields by reading them from the given data input    *      *  @param in input stream    *  @exception IOException is thrown if encounter any error when reading    */
DECL|method|readFields (DataInput in)
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
comment|// read UGI type first
name|String
name|ugiType
init|=
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|UGI_TECHNOLOGY
operator|.
name|equals
argument_list|(
name|ugiType
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expect UGI prefix: "
operator|+
name|UGI_TECHNOLOGY
operator|+
literal|", but receive a prefix: "
operator|+
name|ugiType
argument_list|)
throw|;
block|}
comment|// read this object
name|userName
operator|=
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|int
name|numOfGroups
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|groupNames
operator|=
operator|new
name|String
index|[
name|numOfGroups
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numOfGroups
condition|;
name|i
operator|++
control|)
block|{
name|groupNames
index|[
name|i
index|]
operator|=
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Serialize this object    * First write a string marking that this is a UGI in the string format,    * then write this object's serialized form to the given data output    *     * @param out output stream    * @exception IOException if encounter any error during writing    */
DECL|method|write (DataOutput out)
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
comment|// write a prefix indicating the type of UGI being written
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|UGI_TECHNOLOGY
argument_list|)
expr_stmt|;
comment|// write this object
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|userName
argument_list|)
expr_stmt|;
name|WritableUtils
operator|.
name|writeVInt
argument_list|(
name|out
argument_list|,
name|groupNames
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|groupName
range|:
name|groupNames
control|)
block|{
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|groupName
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The following two methods deal with transferring UGI through conf.     * In this pass of implementation we store UGI as a string in conf.     * Later we may change it to be a more general approach that stores     * it as a byte array */
comment|/** Store the given<code>ugi</code> as a comma separated string in    *<code>conf</code> as a property<code>attr</code>    *     * The String starts with the user name followed by the default group names,    * and other group names.    *     * @param conf configuration    * @param attr property name    * @param ugi a UnixUserGroupInformation    */
DECL|method|saveToConf (Configuration conf, String attr, UnixUserGroupInformation ugi )
specifier|public
specifier|static
name|void
name|saveToConf
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|attr
parameter_list|,
name|UnixUserGroupInformation
name|ugi
parameter_list|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|attr
argument_list|,
name|ugi
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Read a UGI from the given<code>conf</code>    *     * The object is expected to store with the property name<code>attr</code>    * as a comma separated string that starts    * with the user name followed by group names.    * If the property name is not defined, return null.    * It's assumed that there is only one UGI per user. If this user already    * has a UGI in the ugi map, return the ugi in the map.    * Otherwise, construct a UGI from the configuration, store it in the    * ugi map and return it.    *     * @param conf configuration    * @param attr property name    * @return a UnixUGI    * @throws LoginException if the stored string is ill-formatted.    */
DECL|method|readFromConf ( Configuration conf, String attr)
specifier|public
specifier|static
name|UnixUserGroupInformation
name|readFromConf
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|attr
parameter_list|)
throws|throws
name|LoginException
block|{
name|String
index|[]
name|ugi
init|=
name|conf
operator|.
name|getStrings
argument_list|(
name|attr
argument_list|)
decl_stmt|;
if|if
condition|(
name|ugi
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|UnixUserGroupInformation
name|currentUGI
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ugi
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|currentUGI
operator|=
name|user2UGIMap
operator|.
name|get
argument_list|(
name|ugi
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|currentUGI
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|currentUGI
operator|=
operator|new
name|UnixUserGroupInformation
argument_list|(
name|ugi
argument_list|)
expr_stmt|;
name|user2UGIMap
operator|.
name|put
argument_list|(
name|currentUGI
operator|.
name|getUserName
argument_list|()
argument_list|,
name|currentUGI
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|LoginException
argument_list|(
literal|"Login failed: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
return|return
name|currentUGI
return|;
block|}
comment|/**    * Get current user's name and the names of all its groups from Unix.    * It's assumed that there is only one UGI per user. If this user already    * has a UGI in the ugi map, return the ugi in the map.    * Otherwise get the current user's information from Unix, store it    * in the map, and return it.    *    * If the current user's UNIX username or groups are configured in such a way    * to throw an Exception, for example if the user uses LDAP, then this method    * will use a the {@link #DEFAULT_USERNAME} and {@link #DEFAULT_GROUP}    * constants.    */
DECL|method|login ()
specifier|public
specifier|static
name|UnixUserGroupInformation
name|login
parameter_list|()
throws|throws
name|LoginException
block|{
try|try
block|{
name|String
name|userName
decl_stmt|;
comment|// if an exception occurs, then uses the
comment|// default user
try|try
block|{
name|userName
operator|=
name|getUnixUserName
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Couldn't get unix username, using "
operator|+
name|DEFAULT_USERNAME
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|userName
operator|=
name|DEFAULT_USERNAME
expr_stmt|;
block|}
comment|// check if this user already has a UGI object in the ugi map
name|UnixUserGroupInformation
name|ugi
init|=
name|user2UGIMap
operator|.
name|get
argument_list|(
name|userName
argument_list|)
decl_stmt|;
if|if
condition|(
name|ugi
operator|!=
literal|null
condition|)
block|{
return|return
name|ugi
return|;
block|}
comment|/* get groups list from UNIX.         * It's assumed that the first group is the default group.        */
name|String
index|[]
name|groupNames
decl_stmt|;
comment|// if an exception occurs, then uses the
comment|// default group
try|try
block|{
name|groupNames
operator|=
name|getUnixGroups
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Couldn't get unix groups, using "
operator|+
name|DEFAULT_GROUP
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|groupNames
operator|=
operator|new
name|String
index|[
literal|1
index|]
expr_stmt|;
name|groupNames
index|[
literal|0
index|]
operator|=
name|DEFAULT_GROUP
expr_stmt|;
block|}
comment|// construct a Unix UGI
name|ugi
operator|=
operator|new
name|UnixUserGroupInformation
argument_list|(
name|userName
argument_list|,
name|groupNames
argument_list|)
expr_stmt|;
name|user2UGIMap
operator|.
name|put
argument_list|(
name|ugi
operator|.
name|getUserName
argument_list|()
argument_list|,
name|ugi
argument_list|)
expr_stmt|;
return|return
name|ugi
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|LoginException
argument_list|(
literal|"Login failed: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/** Equivalent to login(conf, false). */
DECL|method|login (Configuration conf)
specifier|public
specifier|static
name|UnixUserGroupInformation
name|login
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|LoginException
block|{
return|return
name|login
argument_list|(
name|conf
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Get a user's name& its group names from the given configuration;     * If it is not defined in the configuration, get the current user's    * information from Unix.    * If the user has a UGI in the ugi map, return the one in    * the UGI map.    *     *  @param conf either a job configuration or client's configuration    *  @param save saving it to conf?    *  @return UnixUserGroupInformation a user/group information    *  @exception LoginException if not able to get the user/group information    */
DECL|method|login (Configuration conf, boolean save )
specifier|public
specifier|static
name|UnixUserGroupInformation
name|login
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|boolean
name|save
parameter_list|)
throws|throws
name|LoginException
block|{
name|UnixUserGroupInformation
name|ugi
init|=
name|readFromConf
argument_list|(
name|conf
argument_list|,
name|UGI_PROPERTY_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|ugi
operator|==
literal|null
condition|)
block|{
name|ugi
operator|=
name|login
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unix Login: "
operator|+
name|ugi
argument_list|)
expr_stmt|;
if|if
condition|(
name|save
condition|)
block|{
name|saveToConf
argument_list|(
name|conf
argument_list|,
name|UGI_PROPERTY_NAME
argument_list|,
name|ugi
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ugi
return|;
block|}
comment|/* Return a string representation of a string array.    * Two strings are separated by a blank.    */
DECL|method|toString (String[] strArray)
specifier|private
specifier|static
name|String
name|toString
parameter_list|(
name|String
index|[]
name|strArray
parameter_list|)
block|{
if|if
condition|(
name|strArray
operator|==
literal|null
operator|||
name|strArray
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|""
return|;
block|}
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
name|strArray
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|strArray
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|strArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** Get current user's name from Unix by running the command whoami.    *     * @return current user's name    * @throws IOException if encounter any error while running the command    */
DECL|method|getUnixUserName ()
specifier|static
name|String
name|getUnixUserName
parameter_list|()
throws|throws
name|IOException
block|{
name|String
index|[]
name|result
init|=
name|executeShellCommand
argument_list|(
operator|new
name|String
index|[]
block|{
name|Shell
operator|.
name|USER_NAME_COMMAND
block|}
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|length
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expect one token as the result of "
operator|+
name|Shell
operator|.
name|USER_NAME_COMMAND
operator|+
literal|": "
operator|+
name|toString
argument_list|(
name|result
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|result
index|[
literal|0
index|]
return|;
block|}
comment|/** Get the current user's group list from Unix by running the command groups    *     * @return the groups list that the current user belongs to    * @throws IOException if encounter any error when running the command    */
DECL|method|getUnixGroups ()
specifier|private
specifier|static
name|String
index|[]
name|getUnixGroups
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|executeShellCommand
argument_list|(
name|Shell
operator|.
name|getGROUPS_COMMAND
argument_list|()
argument_list|)
return|;
block|}
comment|/* Execute a command and return the result as an array of Strings */
DECL|method|executeShellCommand (String[] command)
specifier|private
specifier|static
name|String
index|[]
name|executeShellCommand
parameter_list|(
name|String
index|[]
name|command
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|groups
init|=
name|Shell
operator|.
name|execCommand
argument_list|(
name|command
argument_list|)
decl_stmt|;
name|StringTokenizer
name|tokenizer
init|=
operator|new
name|StringTokenizer
argument_list|(
name|groups
argument_list|)
decl_stmt|;
name|int
name|numOfTokens
init|=
name|tokenizer
operator|.
name|countTokens
argument_list|()
decl_stmt|;
name|String
index|[]
name|tokens
init|=
operator|new
name|String
index|[
name|numOfTokens
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|tokenizer
operator|.
name|hasMoreTokens
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|tokens
index|[
name|i
index|]
operator|=
name|tokenizer
operator|.
name|nextToken
argument_list|()
expr_stmt|;
block|}
return|return
name|tokens
return|;
block|}
comment|/** Decide if two UGIs are the same    *    * @param other other object    * @return true if they are the same; false otherwise.    */
DECL|method|equals (Object other)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|other
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|other
operator|instanceof
name|UnixUserGroupInformation
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|UnixUserGroupInformation
name|otherUGI
init|=
operator|(
name|UnixUserGroupInformation
operator|)
name|other
decl_stmt|;
comment|// check userName
if|if
condition|(
name|userName
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|otherUGI
operator|.
name|getUserName
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|userName
operator|.
name|equals
argument_list|(
name|otherUGI
operator|.
name|getUserName
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// checkGroupNames
if|if
condition|(
name|groupNames
operator|==
name|otherUGI
operator|.
name|groupNames
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|groupNames
operator|.
name|length
operator|!=
name|otherUGI
operator|.
name|groupNames
operator|.
name|length
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// check default group name
if|if
condition|(
name|groupNames
operator|.
name|length
operator|>
literal|0
operator|&&
operator|!
name|groupNames
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
name|otherUGI
operator|.
name|groupNames
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// check all group names, ignoring the order
return|return
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|groupNames
argument_list|)
argument_list|)
operator|.
name|equals
argument_list|(
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|otherUGI
operator|.
name|groupNames
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/** Returns a hash code for this UGI.     * The hash code for a UGI is the hash code of its user name string.    *     * @return  a hash code value for this UGI.    */
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|getUserName
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|/** Convert this object to a string    *     * @return a comma separated string containing the user name and group names    */
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|userName
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|groupName
range|:
name|groupNames
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|groupName
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

