begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.security
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|sun
operator|.
name|security
operator|.
name|krb5
operator|.
name|Config
import|;
end_import

begin_import
import|import
name|sun
operator|.
name|security
operator|.
name|krb5
operator|.
name|KrbException
import|;
end_import

begin_comment
comment|/**  * This class implements parsing and handling of Kerberos principal names. In   * particular, it splits them apart and translates them down into local  * operating system names.  */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"all"
argument_list|)
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|,
literal|"MapReduce"
block|}
argument_list|)
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|KerberosName
specifier|public
class|class
name|KerberosName
block|{
comment|/** The first component of the name */
DECL|field|serviceName
specifier|private
specifier|final
name|String
name|serviceName
decl_stmt|;
comment|/** The second component of the name. It may be null. */
DECL|field|hostName
specifier|private
specifier|final
name|String
name|hostName
decl_stmt|;
comment|/** The realm of the name. */
DECL|field|realm
specifier|private
specifier|final
name|String
name|realm
decl_stmt|;
comment|/**    * A pattern that matches a Kerberos name with at most 2 components.    */
DECL|field|nameParser
specifier|private
specifier|static
specifier|final
name|Pattern
name|nameParser
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"([^/@]*)(/([^/@]*))?@([^/@]*)"
argument_list|)
decl_stmt|;
comment|/**     * A pattern that matches a string with out '$' and then a single    * parameter with $n.    */
DECL|field|parameterPattern
specifier|private
specifier|static
name|Pattern
name|parameterPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"([^$]*)(\\$(\\d*))?"
argument_list|)
decl_stmt|;
comment|/**    * A pattern for parsing a auth_to_local rule.    */
DECL|field|ruleParser
specifier|private
specifier|static
specifier|final
name|Pattern
name|ruleParser
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\s*((DEFAULT)|(RULE:\\[(\\d*):([^\\]]*)](\\(([^)]*)\\))?"
operator|+
literal|"(s/([^/]*)/([^/]*)/(g)?)?))"
argument_list|)
decl_stmt|;
comment|/**    * A pattern that recognizes simple/non-simple names.    */
DECL|field|nonSimplePattern
specifier|private
specifier|static
specifier|final
name|Pattern
name|nonSimplePattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"[/@]"
argument_list|)
decl_stmt|;
comment|/**    * The list of translation rules.    */
DECL|field|rules
specifier|private
specifier|static
name|List
argument_list|<
name|Rule
argument_list|>
name|rules
decl_stmt|;
DECL|field|defaultRealm
specifier|private
specifier|static
name|String
name|defaultRealm
decl_stmt|;
DECL|field|kerbConf
specifier|private
specifier|static
name|Config
name|kerbConf
decl_stmt|;
static|static
block|{
try|try
block|{
name|kerbConf
operator|=
name|Config
operator|.
name|getInstance
argument_list|()
expr_stmt|;
name|defaultRealm
operator|=
name|kerbConf
operator|.
name|getDefaultRealm
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KrbException
name|ke
parameter_list|)
block|{
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Can't get Kerberos configuration"
argument_list|,
name|ke
argument_list|)
throw|;
else|else
name|defaultRealm
operator|=
literal|""
expr_stmt|;
block|}
block|}
comment|/**    * Create a name from the full Kerberos principal name.    * @param name    */
DECL|method|KerberosName (String name)
specifier|public
name|KerberosName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|Matcher
name|match
init|=
name|nameParser
operator|.
name|matcher
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|match
operator|.
name|matches
argument_list|()
condition|)
block|{
if|if
condition|(
name|name
operator|.
name|contains
argument_list|(
literal|"@"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Malformed Kerberos name: "
operator|+
name|name
argument_list|)
throw|;
block|}
else|else
block|{
name|serviceName
operator|=
name|name
expr_stmt|;
name|hostName
operator|=
literal|null
expr_stmt|;
name|realm
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
name|serviceName
operator|=
name|match
operator|.
name|group
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|hostName
operator|=
name|match
operator|.
name|group
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|realm
operator|=
name|match
operator|.
name|group
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get the configured default realm.    * @return the default realm from the krb5.conf    */
DECL|method|getDefaultRealm ()
specifier|public
name|String
name|getDefaultRealm
parameter_list|()
block|{
return|return
name|defaultRealm
return|;
block|}
comment|/**    * Put the name back together from the parts.    */
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|result
operator|.
name|append
argument_list|(
name|serviceName
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostName
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|hostName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|realm
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
literal|'@'
argument_list|)
expr_stmt|;
name|result
operator|.
name|append
argument_list|(
name|realm
argument_list|)
expr_stmt|;
block|}
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Get the first component of the name.    * @return the first section of the Kerberos principal name    */
DECL|method|getServiceName ()
specifier|public
name|String
name|getServiceName
parameter_list|()
block|{
return|return
name|serviceName
return|;
block|}
comment|/**    * Get the second component of the name.    * @return the second section of the Kerberos principal name, and may be null    */
DECL|method|getHostName ()
specifier|public
name|String
name|getHostName
parameter_list|()
block|{
return|return
name|hostName
return|;
block|}
comment|/**    * Get the realm of the name.    * @return the realm of the name, may be null    */
DECL|method|getRealm ()
specifier|public
name|String
name|getRealm
parameter_list|()
block|{
return|return
name|realm
return|;
block|}
comment|/**    * An encoding of a rule for translating kerberos names.    */
DECL|class|Rule
specifier|private
specifier|static
class|class
name|Rule
block|{
DECL|field|isDefault
specifier|private
specifier|final
name|boolean
name|isDefault
decl_stmt|;
DECL|field|numOfComponents
specifier|private
specifier|final
name|int
name|numOfComponents
decl_stmt|;
DECL|field|format
specifier|private
specifier|final
name|String
name|format
decl_stmt|;
DECL|field|match
specifier|private
specifier|final
name|Pattern
name|match
decl_stmt|;
DECL|field|fromPattern
specifier|private
specifier|final
name|Pattern
name|fromPattern
decl_stmt|;
DECL|field|toPattern
specifier|private
specifier|final
name|String
name|toPattern
decl_stmt|;
DECL|field|repeat
specifier|private
specifier|final
name|boolean
name|repeat
decl_stmt|;
DECL|method|Rule ()
name|Rule
parameter_list|()
block|{
name|isDefault
operator|=
literal|true
expr_stmt|;
name|numOfComponents
operator|=
literal|0
expr_stmt|;
name|format
operator|=
literal|null
expr_stmt|;
name|match
operator|=
literal|null
expr_stmt|;
name|fromPattern
operator|=
literal|null
expr_stmt|;
name|toPattern
operator|=
literal|null
expr_stmt|;
name|repeat
operator|=
literal|false
expr_stmt|;
block|}
DECL|method|Rule (int numOfComponents, String format, String match, String fromPattern, String toPattern, boolean repeat)
name|Rule
parameter_list|(
name|int
name|numOfComponents
parameter_list|,
name|String
name|format
parameter_list|,
name|String
name|match
parameter_list|,
name|String
name|fromPattern
parameter_list|,
name|String
name|toPattern
parameter_list|,
name|boolean
name|repeat
parameter_list|)
block|{
name|isDefault
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|numOfComponents
operator|=
name|numOfComponents
expr_stmt|;
name|this
operator|.
name|format
operator|=
name|format
expr_stmt|;
name|this
operator|.
name|match
operator|=
name|match
operator|==
literal|null
condition|?
literal|null
else|:
name|Pattern
operator|.
name|compile
argument_list|(
name|match
argument_list|)
expr_stmt|;
name|this
operator|.
name|fromPattern
operator|=
name|fromPattern
operator|==
literal|null
condition|?
literal|null
else|:
name|Pattern
operator|.
name|compile
argument_list|(
name|fromPattern
argument_list|)
expr_stmt|;
name|this
operator|.
name|toPattern
operator|=
name|toPattern
expr_stmt|;
name|this
operator|.
name|repeat
operator|=
name|repeat
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|isDefault
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"DEFAULT"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"RULE:["
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|numOfComponents
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|match
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fromPattern
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|"s/"
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|fromPattern
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|toPattern
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|repeat
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|'g'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Replace the numbered parameters of the form $n where n is from 1 to       * the length of params. Normal text is copied directly and $n is replaced      * by the corresponding parameter.      * @param format the string to replace parameters again      * @param params the list of parameters      * @return the generated string with the parameter references replaced.      * @throws BadFormatString      */
DECL|method|replaceParameters (String format, String[] params)
specifier|static
name|String
name|replaceParameters
parameter_list|(
name|String
name|format
parameter_list|,
name|String
index|[]
name|params
parameter_list|)
throws|throws
name|BadFormatString
block|{
name|Matcher
name|match
init|=
name|parameterPattern
operator|.
name|matcher
argument_list|(
name|format
argument_list|)
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
name|StringBuilder
name|result
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
name|start
operator|<
name|format
operator|.
name|length
argument_list|()
operator|&&
name|match
operator|.
name|find
argument_list|(
name|start
argument_list|)
condition|)
block|{
name|result
operator|.
name|append
argument_list|(
name|match
operator|.
name|group
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|paramNum
init|=
name|match
operator|.
name|group
argument_list|(
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
name|paramNum
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|int
name|num
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|paramNum
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
argument_list|<
literal|0
operator|||
name|num
argument_list|>
name|params
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|BadFormatString
argument_list|(
literal|"index "
operator|+
name|num
operator|+
literal|" from "
operator|+
name|format
operator|+
literal|" is outside of the valid range 0 to "
operator|+
operator|(
name|params
operator|.
name|length
operator|-
literal|1
operator|)
argument_list|)
throw|;
block|}
name|result
operator|.
name|append
argument_list|(
name|params
index|[
name|num
index|]
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
throw|throw
operator|new
name|BadFormatString
argument_list|(
literal|"bad format in username mapping in "
operator|+
name|paramNum
argument_list|,
name|nfe
argument_list|)
throw|;
block|}
block|}
name|start
operator|=
name|match
operator|.
name|end
argument_list|()
expr_stmt|;
block|}
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Replace the matches of the from pattern in the base string with the value      * of the to string.      * @param base the string to transform      * @param from the pattern to look for in the base string      * @param to the string to replace matches of the pattern with      * @param repeat whether the substitution should be repeated      * @return      */
DECL|method|replaceSubstitution (String base, Pattern from, String to, boolean repeat)
specifier|static
name|String
name|replaceSubstitution
parameter_list|(
name|String
name|base
parameter_list|,
name|Pattern
name|from
parameter_list|,
name|String
name|to
parameter_list|,
name|boolean
name|repeat
parameter_list|)
block|{
name|Matcher
name|match
init|=
name|from
operator|.
name|matcher
argument_list|(
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
name|repeat
condition|)
block|{
return|return
name|match
operator|.
name|replaceAll
argument_list|(
name|to
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|match
operator|.
name|replaceFirst
argument_list|(
name|to
argument_list|)
return|;
block|}
block|}
comment|/**      * Try to apply this rule to the given name represented as a parameter      * array.      * @param params first element is the realm, second and later elements are      *        are the components of the name "a/b@FOO" -> {"FOO", "a", "b"}      * @return the short name if this rule applies or null      * @throws IOException throws if something is wrong with the rules      */
DECL|method|apply (String[] params)
name|String
name|apply
parameter_list|(
name|String
index|[]
name|params
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|result
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isDefault
condition|)
block|{
if|if
condition|(
name|defaultRealm
operator|.
name|equals
argument_list|(
name|params
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|result
operator|=
name|params
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|params
operator|.
name|length
operator|-
literal|1
operator|==
name|numOfComponents
condition|)
block|{
name|String
name|base
init|=
name|replaceParameters
argument_list|(
name|format
argument_list|,
name|params
argument_list|)
decl_stmt|;
if|if
condition|(
name|match
operator|==
literal|null
operator|||
name|match
operator|.
name|matcher
argument_list|(
name|base
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
if|if
condition|(
name|fromPattern
operator|==
literal|null
condition|)
block|{
name|result
operator|=
name|base
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|replaceSubstitution
argument_list|(
name|base
argument_list|,
name|fromPattern
argument_list|,
name|toPattern
argument_list|,
name|repeat
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|result
operator|!=
literal|null
operator|&&
name|nonSimplePattern
operator|.
name|matcher
argument_list|(
name|result
argument_list|)
operator|.
name|find
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoMatchingRule
argument_list|(
literal|"Non-simple name "
operator|+
name|result
operator|+
literal|" after auth_to_local rule "
operator|+
name|this
argument_list|)
throw|;
block|}
return|return
name|result
return|;
block|}
block|}
DECL|method|parseRules (String rules)
specifier|static
name|List
argument_list|<
name|Rule
argument_list|>
name|parseRules
parameter_list|(
name|String
name|rules
parameter_list|)
block|{
name|List
argument_list|<
name|Rule
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|Rule
argument_list|>
argument_list|()
decl_stmt|;
name|String
name|remaining
init|=
name|rules
operator|.
name|trim
argument_list|()
decl_stmt|;
while|while
condition|(
name|remaining
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Matcher
name|matcher
init|=
name|ruleParser
operator|.
name|matcher
argument_list|(
name|remaining
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|matcher
operator|.
name|lookingAt
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid rule: "
operator|+
name|remaining
argument_list|)
throw|;
block|}
if|if
condition|(
name|matcher
operator|.
name|group
argument_list|(
literal|2
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
operator|new
name|Rule
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|add
argument_list|(
operator|new
name|Rule
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|,
name|matcher
operator|.
name|group
argument_list|(
literal|5
argument_list|)
argument_list|,
name|matcher
operator|.
name|group
argument_list|(
literal|7
argument_list|)
argument_list|,
name|matcher
operator|.
name|group
argument_list|(
literal|9
argument_list|)
argument_list|,
name|matcher
operator|.
name|group
argument_list|(
literal|10
argument_list|)
argument_list|,
literal|"g"
operator|.
name|equals
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
literal|11
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|remaining
operator|=
name|remaining
operator|.
name|substring
argument_list|(
name|matcher
operator|.
name|end
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Set the static configuration to get the rules.    * @param conf the new configuration    * @throws IOException    */
DECL|method|setConfiguration (Configuration conf)
specifier|public
specifier|static
name|void
name|setConfiguration
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|ruleString
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"hadoop.security.auth_to_local"
argument_list|,
literal|"DEFAULT"
argument_list|)
decl_stmt|;
name|rules
operator|=
name|parseRules
argument_list|(
name|ruleString
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|BadFormatString
specifier|public
specifier|static
class|class
name|BadFormatString
extends|extends
name|IOException
block|{
DECL|method|BadFormatString (String msg)
name|BadFormatString
parameter_list|(
name|String
name|msg
parameter_list|)
block|{
name|super
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
DECL|method|BadFormatString (String msg, Throwable err)
name|BadFormatString
parameter_list|(
name|String
name|msg
parameter_list|,
name|Throwable
name|err
parameter_list|)
block|{
name|super
argument_list|(
name|msg
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|NoMatchingRule
specifier|public
specifier|static
class|class
name|NoMatchingRule
extends|extends
name|IOException
block|{
DECL|method|NoMatchingRule (String msg)
name|NoMatchingRule
parameter_list|(
name|String
name|msg
parameter_list|)
block|{
name|super
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get the translation of the principal name into an operating system    * user name.    * @return the short name    * @throws IOException    */
DECL|method|getShortName ()
specifier|public
name|String
name|getShortName
parameter_list|()
throws|throws
name|IOException
block|{
name|String
index|[]
name|params
decl_stmt|;
if|if
condition|(
name|hostName
operator|==
literal|null
condition|)
block|{
comment|// if it is already simple, just return it
if|if
condition|(
name|realm
operator|==
literal|null
condition|)
block|{
return|return
name|serviceName
return|;
block|}
name|params
operator|=
operator|new
name|String
index|[]
block|{
name|realm
block|,
name|serviceName
block|}
expr_stmt|;
block|}
else|else
block|{
name|params
operator|=
operator|new
name|String
index|[]
block|{
name|realm
block|,
name|serviceName
block|,
name|hostName
block|}
expr_stmt|;
block|}
for|for
control|(
name|Rule
name|r
range|:
name|rules
control|)
block|{
name|String
name|result
init|=
name|r
operator|.
name|apply
argument_list|(
name|params
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
return|return
name|result
return|;
block|}
block|}
throw|throw
operator|new
name|NoMatchingRule
argument_list|(
literal|"No rules applied to "
operator|+
name|toString
argument_list|()
argument_list|)
throw|;
block|}
DECL|method|printRules ()
specifier|static
name|void
name|printRules
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Rule
name|r
range|:
name|rules
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
operator|++
name|i
operator|+
literal|" "
operator|+
name|r
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
for|for
control|(
name|String
name|arg
range|:
name|args
control|)
block|{
name|KerberosName
name|name
init|=
operator|new
name|KerberosName
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Name: "
operator|+
name|name
operator|+
literal|" to "
operator|+
name|name
operator|.
name|getShortName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

