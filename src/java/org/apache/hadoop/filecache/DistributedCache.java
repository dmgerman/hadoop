begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.filecache
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|filecache
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_comment
comment|/**  * Distribute application-specific large, read-only files efficiently.  *   *<p><code>DistributedCache</code> is a facility provided by the Map-Reduce  * framework to cache files (text, archives, jars etc.) needed by applications.  *</p>  *   *<p>Applications specify the files, via urls (hdfs:// or http://) to be   * cached via the org.apache.hadoop.mapred.JobConf.  * The<code>DistributedCache</code> assumes that the  * files specified via hdfs:// urls are already present on the   * {@link FileSystem} at the path specified by the url.</p>  *   *<p>The framework will copy the necessary files on to the slave node before   * any tasks for the job are executed on that node. Its efficiency stems from   * the fact that the files are only copied once per job and the ability to   * cache archives which are un-archived on the slaves.</p>   *  *<p><code>DistributedCache</code> can be used to distribute simple, read-only  * data/text files and/or more complex types such as archives, jars etc.   * Archives (zip, tar and tgz/tar.gz files) are un-archived at the slave nodes.   * Jars may be optionally added to the classpath of the tasks, a rudimentary   * software distribution mechanism.  Files have execution permissions.  * Optionally users can also direct it to symlink the distributed cache file(s)  * into the working directory of the task.</p>  *   *<p><code>DistributedCache</code> tracks modification timestamps of the cache   * files. Clearly the cache files should not be modified by the application   * or externally while the job is executing.</p>  *   *<p>Here is an illustrative example on how to use the   *<code>DistributedCache</code>:</p>  *<p><blockquote><pre>  *     // Setting up the cache for the application  *       *     1. Copy the requisite files to the<code>FileSystem</code>:  *       *     $ bin/hadoop fs -copyFromLocal lookup.dat /myapp/lookup.dat    *     $ bin/hadoop fs -copyFromLocal map.zip /myapp/map.zip    *     $ bin/hadoop fs -copyFromLocal mylib.jar /myapp/mylib.jar  *     $ bin/hadoop fs -copyFromLocal mytar.tar /myapp/mytar.tar  *     $ bin/hadoop fs -copyFromLocal mytgz.tgz /myapp/mytgz.tgz  *     $ bin/hadoop fs -copyFromLocal mytargz.tar.gz /myapp/mytargz.tar.gz  *       *     2. Setup the application's<code>JobConf</code>:  *       *     JobConf job = new JobConf();  *     DistributedCache.addCacheFile(new URI("/myapp/lookup.dat#lookup.dat"),   *                                   job);  *     DistributedCache.addCacheArchive(new URI("/myapp/map.zip", job);  *     DistributedCache.addFileToClassPath(new Path("/myapp/mylib.jar"), job);  *     DistributedCache.addCacheArchive(new URI("/myapp/mytar.tar", job);  *     DistributedCache.addCacheArchive(new URI("/myapp/mytgz.tgz", job);  *     DistributedCache.addCacheArchive(new URI("/myapp/mytargz.tar.gz", job);  *       *     3. Use the cached files in the org.apache.hadoop.mapred.Mapper  *     or org.apache.hadoop.mapred.Reducer:  *       *     public static class MapClass extends MapReduceBase    *     implements Mapper&lt;K, V, K, V&gt; {  *       *       private Path[] localArchives;  *       private Path[] localFiles;  *         *       public void configure(JobConf job) {  *         // Get the cached archives/files  *         localArchives = DistributedCache.getLocalCacheArchives(job);  *         localFiles = DistributedCache.getLocalCacheFiles(job);  *       }  *         *       public void map(K key, V value,   *                       OutputCollector&lt;K, V&gt; output, Reporter reporter)   *       throws IOException {  *         // Use data from the cached archives/files here  *         // ...  *         // ...  *         output.collect(k, v);  *       }  *     }  *       *</pre></blockquote></p>  *   */
end_comment

begin_class
DECL|class|DistributedCache
specifier|public
class|class
name|DistributedCache
block|{
comment|// cacheID to cacheStatus mapping
DECL|field|cachedArchives
specifier|private
specifier|static
name|TreeMap
argument_list|<
name|String
argument_list|,
name|CacheStatus
argument_list|>
name|cachedArchives
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|CacheStatus
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|baseDirSize
specifier|private
specifier|static
name|TreeMap
argument_list|<
name|Path
argument_list|,
name|Long
argument_list|>
name|baseDirSize
init|=
operator|new
name|TreeMap
argument_list|<
name|Path
argument_list|,
name|Long
argument_list|>
argument_list|()
decl_stmt|;
comment|// default total cache size
DECL|field|DEFAULT_CACHE_SIZE
specifier|private
specifier|static
specifier|final
name|long
name|DEFAULT_CACHE_SIZE
init|=
literal|10737418240L
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|DistributedCache
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Get the locally cached file or archive; it could either be     * previously cached (and valid) or copy it from the {@link FileSystem} now.    *     * @param cache the cache to be localized, this should be specified as     * new URI(hdfs://hostname:port/absolute_path_to_file#LINKNAME). If no schema     * or hostname:port is provided the file is assumed to be in the filesystem    * being used in the Configuration    * @param conf The Confguration file which contains the filesystem    * @param baseDir The base cache Dir where you wnat to localize the files/archives    * @param fileStatus The file status on the dfs.    * @param isArchive if the cache is an archive or a file. In case it is an    *  archive with a .zip or .jar or .tar or .tgz or .tar.gz extension it will    *  be unzipped/unjarred/untarred automatically     *  and the directory where the archive is unzipped/unjarred/untarred is    *  returned as the Path.    *  In case of a file, the path to the file is returned    * @param confFileStamp this is the hdfs file modification timestamp to verify that the     * file to be cached hasn't changed since the job started    * @param currentWorkDir this is the directory where you would want to create symlinks     * for the locally cached files/archives    * @return the path to directory where the archives are unjarred in case of archives,    * the path to the file where the file is copied locally     * @throws IOException    */
DECL|method|getLocalCache (URI cache, Configuration conf, Path baseDir, FileStatus fileStatus, boolean isArchive, long confFileStamp, Path currentWorkDir)
specifier|public
specifier|static
name|Path
name|getLocalCache
parameter_list|(
name|URI
name|cache
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|baseDir
parameter_list|,
name|FileStatus
name|fileStatus
parameter_list|,
name|boolean
name|isArchive
parameter_list|,
name|long
name|confFileStamp
parameter_list|,
name|Path
name|currentWorkDir
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getLocalCache
argument_list|(
name|cache
argument_list|,
name|conf
argument_list|,
name|baseDir
argument_list|,
name|fileStatus
argument_list|,
name|isArchive
argument_list|,
name|confFileStamp
argument_list|,
name|currentWorkDir
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Get the locally cached file or archive; it could either be     * previously cached (and valid) or copy it from the {@link FileSystem} now.    *     * @param cache the cache to be localized, this should be specified as     * new URI(hdfs://hostname:port/absolute_path_to_file#LINKNAME). If no schema     * or hostname:port is provided the file is assumed to be in the filesystem    * being used in the Configuration    * @param conf The Confguration file which contains the filesystem    * @param baseDir The base cache Dir where you wnat to localize the files/archives    * @param fileStatus The file status on the dfs.    * @param isArchive if the cache is an archive or a file. In case it is an    *  archive with a .zip or .jar or .tar or .tgz or .tar.gz extension it will    *  be unzipped/unjarred/untarred automatically     *  and the directory where the archive is unzipped/unjarred/untarred is    *  returned as the Path.    *  In case of a file, the path to the file is returned    * @param confFileStamp this is the hdfs file modification timestamp to verify that the     * file to be cached hasn't changed since the job started    * @param currentWorkDir this is the directory where you would want to create symlinks     * for the locally cached files/archives    * @param honorSymLinkConf if this is false, then the symlinks are not    * created even if conf says so (this is required for an optimization in task    * launches    * @return the path to directory where the archives are unjarred in case of archives,    * the path to the file where the file is copied locally     * @throws IOException    */
DECL|method|getLocalCache (URI cache, Configuration conf, Path baseDir, FileStatus fileStatus, boolean isArchive, long confFileStamp, Path currentWorkDir, boolean honorSymLinkConf)
specifier|public
specifier|static
name|Path
name|getLocalCache
parameter_list|(
name|URI
name|cache
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|baseDir
parameter_list|,
name|FileStatus
name|fileStatus
parameter_list|,
name|boolean
name|isArchive
parameter_list|,
name|long
name|confFileStamp
parameter_list|,
name|Path
name|currentWorkDir
parameter_list|,
name|boolean
name|honorSymLinkConf
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|cacheId
init|=
name|makeRelative
argument_list|(
name|cache
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|CacheStatus
name|lcacheStatus
decl_stmt|;
name|Path
name|localizedPath
decl_stmt|;
synchronized|synchronized
init|(
name|cachedArchives
init|)
block|{
name|lcacheStatus
operator|=
name|cachedArchives
operator|.
name|get
argument_list|(
name|cacheId
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcacheStatus
operator|==
literal|null
condition|)
block|{
comment|// was never localized
name|lcacheStatus
operator|=
operator|new
name|CacheStatus
argument_list|(
name|baseDir
argument_list|,
operator|new
name|Path
argument_list|(
name|baseDir
argument_list|,
operator|new
name|Path
argument_list|(
name|cacheId
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cachedArchives
operator|.
name|put
argument_list|(
name|cacheId
argument_list|,
name|lcacheStatus
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|lcacheStatus
init|)
block|{
name|localizedPath
operator|=
name|localizeCache
argument_list|(
name|conf
argument_list|,
name|cache
argument_list|,
name|confFileStamp
argument_list|,
name|lcacheStatus
argument_list|,
name|fileStatus
argument_list|,
name|isArchive
argument_list|,
name|currentWorkDir
argument_list|,
name|honorSymLinkConf
argument_list|)
expr_stmt|;
name|lcacheStatus
operator|.
name|refcount
operator|++
expr_stmt|;
block|}
block|}
comment|// try deleting stuff if you can
name|long
name|size
init|=
literal|0
decl_stmt|;
synchronized|synchronized
init|(
name|baseDirSize
init|)
block|{
name|Long
name|get
init|=
name|baseDirSize
operator|.
name|get
argument_list|(
name|baseDir
argument_list|)
decl_stmt|;
if|if
condition|(
name|get
operator|!=
literal|null
condition|)
block|{
name|size
operator|=
name|get
operator|.
name|longValue
argument_list|()
expr_stmt|;
block|}
block|}
comment|// setting the cache size to a default of 10GB
name|long
name|allowedSize
init|=
name|conf
operator|.
name|getLong
argument_list|(
literal|"local.cache.size"
argument_list|,
name|DEFAULT_CACHE_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|allowedSize
operator|<
name|size
condition|)
block|{
comment|// try some cache deletions
name|deleteCache
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
return|return
name|localizedPath
return|;
block|}
comment|/**    * Get the locally cached file or archive; it could either be     * previously cached (and valid) or copy it from the {@link FileSystem} now.    *     * @param cache the cache to be localized, this should be specified as     * new URI(hdfs://hostname:port/absolute_path_to_file#LINKNAME). If no schema     * or hostname:port is provided the file is assumed to be in the filesystem    * being used in the Configuration    * @param conf The Confguration file which contains the filesystem    * @param baseDir The base cache Dir where you wnat to localize the files/archives    * @param isArchive if the cache is an archive or a file. In case it is an     *  archive with a .zip or .jar or .tar or .tgz or .tar.gz extension it will     *  be unzipped/unjarred/untarred automatically     *  and the directory where the archive is unzipped/unjarred/untarred     *  is returned as the Path.    *  In case of a file, the path to the file is returned    * @param confFileStamp this is the hdfs file modification timestamp to verify that the     * file to be cached hasn't changed since the job started    * @param currentWorkDir this is the directory where you would want to create symlinks     * for the locally cached files/archives    * @return the path to directory where the archives are unjarred in case of archives,    * the path to the file where the file is copied locally     * @throws IOException     */
DECL|method|getLocalCache (URI cache, Configuration conf, Path baseDir, boolean isArchive, long confFileStamp, Path currentWorkDir)
specifier|public
specifier|static
name|Path
name|getLocalCache
parameter_list|(
name|URI
name|cache
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|baseDir
parameter_list|,
name|boolean
name|isArchive
parameter_list|,
name|long
name|confFileStamp
parameter_list|,
name|Path
name|currentWorkDir
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getLocalCache
argument_list|(
name|cache
argument_list|,
name|conf
argument_list|,
name|baseDir
argument_list|,
literal|null
argument_list|,
name|isArchive
argument_list|,
name|confFileStamp
argument_list|,
name|currentWorkDir
argument_list|)
return|;
block|}
comment|/**    * This is the opposite of getlocalcache. When you are done with    * using the cache, you need to release the cache    * @param cache The cache URI to be released    * @param conf configuration which contains the filesystem the cache     * is contained in.    * @throws IOException    */
DECL|method|releaseCache (URI cache, Configuration conf)
specifier|public
specifier|static
name|void
name|releaseCache
parameter_list|(
name|URI
name|cache
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|cacheId
init|=
name|makeRelative
argument_list|(
name|cache
argument_list|,
name|conf
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|cachedArchives
init|)
block|{
name|CacheStatus
name|lcacheStatus
init|=
name|cachedArchives
operator|.
name|get
argument_list|(
name|cacheId
argument_list|)
decl_stmt|;
if|if
condition|(
name|lcacheStatus
operator|==
literal|null
condition|)
return|return;
synchronized|synchronized
init|(
name|lcacheStatus
init|)
block|{
name|lcacheStatus
operator|.
name|refcount
operator|--
expr_stmt|;
block|}
block|}
block|}
comment|// To delete the caches which have a refcount of zero
DECL|method|deleteCache (Configuration conf)
specifier|private
specifier|static
name|void
name|deleteCache
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// try deleting cache Status with refcount of zero
synchronized|synchronized
init|(
name|cachedArchives
init|)
block|{
for|for
control|(
name|Iterator
name|it
init|=
name|cachedArchives
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|String
name|cacheId
init|=
operator|(
name|String
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|CacheStatus
name|lcacheStatus
init|=
name|cachedArchives
operator|.
name|get
argument_list|(
name|cacheId
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|lcacheStatus
init|)
block|{
if|if
condition|(
name|lcacheStatus
operator|.
name|refcount
operator|==
literal|0
condition|)
block|{
comment|// delete this cache entry
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
operator|.
name|delete
argument_list|(
name|lcacheStatus
operator|.
name|localLoadPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|baseDirSize
init|)
block|{
name|Long
name|dirSize
init|=
name|baseDirSize
operator|.
name|get
argument_list|(
name|lcacheStatus
operator|.
name|baseDir
argument_list|)
decl_stmt|;
if|if
condition|(
name|dirSize
operator|!=
literal|null
condition|)
block|{
name|dirSize
operator|-=
name|lcacheStatus
operator|.
name|size
expr_stmt|;
name|baseDirSize
operator|.
name|put
argument_list|(
name|lcacheStatus
operator|.
name|baseDir
argument_list|,
name|dirSize
argument_list|)
expr_stmt|;
block|}
block|}
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/*    * Returns the relative path of the dir this cache will be localized in    * relative path that this cache will be localized in. For    * hdfs://hostname:port/absolute_path -- the relative path is    * hostname/absolute path -- if it is just /absolute_path -- then the    * relative path is hostname of DFS this mapred cluster is running    * on/absolute_path    */
DECL|method|makeRelative (URI cache, Configuration conf)
specifier|public
specifier|static
name|String
name|makeRelative
parameter_list|(
name|URI
name|cache
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|host
init|=
name|cache
operator|.
name|getHost
argument_list|()
decl_stmt|;
if|if
condition|(
name|host
operator|==
literal|null
condition|)
block|{
name|host
operator|=
name|cache
operator|.
name|getScheme
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|host
operator|==
literal|null
condition|)
block|{
name|URI
name|defaultUri
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
operator|.
name|getUri
argument_list|()
decl_stmt|;
name|host
operator|=
name|defaultUri
operator|.
name|getHost
argument_list|()
expr_stmt|;
if|if
condition|(
name|host
operator|==
literal|null
condition|)
block|{
name|host
operator|=
name|defaultUri
operator|.
name|getScheme
argument_list|()
expr_stmt|;
block|}
block|}
name|String
name|path
init|=
name|host
operator|+
name|cache
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|path
operator|=
name|path
operator|.
name|replace
argument_list|(
literal|":/"
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
comment|// remove windows device colon
return|return
name|path
return|;
block|}
DECL|method|cacheFilePath (Path p)
specifier|private
specifier|static
name|Path
name|cacheFilePath
parameter_list|(
name|Path
name|p
parameter_list|)
block|{
return|return
operator|new
name|Path
argument_list|(
name|p
argument_list|,
name|p
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
comment|// the method which actually copies the caches locally and unjars/unzips them
comment|// and does chmod for the files
DECL|method|localizeCache (Configuration conf, URI cache, long confFileStamp, CacheStatus cacheStatus, FileStatus fileStatus, boolean isArchive, Path currentWorkDir,boolean honorSymLinkConf)
specifier|private
specifier|static
name|Path
name|localizeCache
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|URI
name|cache
parameter_list|,
name|long
name|confFileStamp
parameter_list|,
name|CacheStatus
name|cacheStatus
parameter_list|,
name|FileStatus
name|fileStatus
parameter_list|,
name|boolean
name|isArchive
parameter_list|,
name|Path
name|currentWorkDir
parameter_list|,
name|boolean
name|honorSymLinkConf
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|doSymlink
init|=
name|honorSymLinkConf
operator|&&
name|getSymlink
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|cache
operator|.
name|getFragment
argument_list|()
operator|==
literal|null
condition|)
block|{
name|doSymlink
operator|=
literal|false
expr_stmt|;
block|}
name|FileSystem
name|fs
init|=
name|getFileSystem
argument_list|(
name|cache
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|String
name|link
init|=
name|currentWorkDir
operator|.
name|toString
argument_list|()
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
name|cache
operator|.
name|getFragment
argument_list|()
decl_stmt|;
name|File
name|flink
init|=
operator|new
name|File
argument_list|(
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
name|ifExistsAndFresh
argument_list|(
name|conf
argument_list|,
name|fs
argument_list|,
name|cache
argument_list|,
name|confFileStamp
argument_list|,
name|cacheStatus
argument_list|,
name|fileStatus
argument_list|)
condition|)
block|{
if|if
condition|(
name|isArchive
condition|)
block|{
if|if
condition|(
name|doSymlink
condition|)
block|{
if|if
condition|(
operator|!
name|flink
operator|.
name|exists
argument_list|()
condition|)
name|FileUtil
operator|.
name|symLink
argument_list|(
name|cacheStatus
operator|.
name|localLoadPath
operator|.
name|toString
argument_list|()
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
return|return
name|cacheStatus
operator|.
name|localLoadPath
return|;
block|}
else|else
block|{
if|if
condition|(
name|doSymlink
condition|)
block|{
if|if
condition|(
operator|!
name|flink
operator|.
name|exists
argument_list|()
condition|)
name|FileUtil
operator|.
name|symLink
argument_list|(
name|cacheFilePath
argument_list|(
name|cacheStatus
operator|.
name|localLoadPath
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
return|return
name|cacheFilePath
argument_list|(
name|cacheStatus
operator|.
name|localLoadPath
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|// remove the old archive
comment|// if the old archive cannot be removed since it is being used by another
comment|// job
comment|// return null
if|if
condition|(
name|cacheStatus
operator|.
name|refcount
operator|>
literal|1
operator|&&
operator|(
name|cacheStatus
operator|.
name|currentStatus
operator|==
literal|true
operator|)
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cache "
operator|+
name|cacheStatus
operator|.
name|localLoadPath
operator|.
name|toString
argument_list|()
operator|+
literal|" is in use and cannot be refreshed"
argument_list|)
throw|;
name|FileSystem
name|localFs
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|localFs
operator|.
name|delete
argument_list|(
name|cacheStatus
operator|.
name|localLoadPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|baseDirSize
init|)
block|{
name|Long
name|dirSize
init|=
name|baseDirSize
operator|.
name|get
argument_list|(
name|cacheStatus
operator|.
name|baseDir
argument_list|)
decl_stmt|;
if|if
condition|(
name|dirSize
operator|!=
literal|null
condition|)
block|{
name|dirSize
operator|-=
name|cacheStatus
operator|.
name|size
expr_stmt|;
name|baseDirSize
operator|.
name|put
argument_list|(
name|cacheStatus
operator|.
name|baseDir
argument_list|,
name|dirSize
argument_list|)
expr_stmt|;
block|}
block|}
name|Path
name|parchive
init|=
operator|new
name|Path
argument_list|(
name|cacheStatus
operator|.
name|localLoadPath
argument_list|,
operator|new
name|Path
argument_list|(
name|cacheStatus
operator|.
name|localLoadPath
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|localFs
operator|.
name|mkdirs
argument_list|(
name|cacheStatus
operator|.
name|localLoadPath
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mkdirs failed to create directory "
operator|+
name|cacheStatus
operator|.
name|localLoadPath
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|String
name|cacheId
init|=
name|cache
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|fs
operator|.
name|copyToLocalFile
argument_list|(
operator|new
name|Path
argument_list|(
name|cacheId
argument_list|)
argument_list|,
name|parchive
argument_list|)
expr_stmt|;
if|if
condition|(
name|isArchive
condition|)
block|{
name|String
name|tmpArchive
init|=
name|parchive
operator|.
name|toString
argument_list|()
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|File
name|srcFile
init|=
operator|new
name|File
argument_list|(
name|parchive
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|File
name|destDir
init|=
operator|new
name|File
argument_list|(
name|parchive
operator|.
name|getParent
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmpArchive
operator|.
name|endsWith
argument_list|(
literal|".jar"
argument_list|)
condition|)
block|{
name|RunJar
operator|.
name|unJar
argument_list|(
name|srcFile
argument_list|,
name|destDir
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tmpArchive
operator|.
name|endsWith
argument_list|(
literal|".zip"
argument_list|)
condition|)
block|{
name|FileUtil
operator|.
name|unZip
argument_list|(
name|srcFile
argument_list|,
name|destDir
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isTarFile
argument_list|(
name|tmpArchive
argument_list|)
condition|)
block|{
name|FileUtil
operator|.
name|unTar
argument_list|(
name|srcFile
argument_list|,
name|destDir
argument_list|)
expr_stmt|;
block|}
comment|// else will not do anyhting
comment|// and copy the file into the dir as it is
block|}
name|long
name|cacheSize
init|=
name|FileUtil
operator|.
name|getDU
argument_list|(
operator|new
name|File
argument_list|(
name|parchive
operator|.
name|getParent
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|cacheStatus
operator|.
name|size
operator|=
name|cacheSize
expr_stmt|;
synchronized|synchronized
init|(
name|baseDirSize
init|)
block|{
name|Long
name|dirSize
init|=
name|baseDirSize
operator|.
name|get
argument_list|(
name|cacheStatus
operator|.
name|baseDir
argument_list|)
decl_stmt|;
if|if
condition|(
name|dirSize
operator|==
literal|null
condition|)
block|{
name|dirSize
operator|=
name|Long
operator|.
name|valueOf
argument_list|(
name|cacheSize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dirSize
operator|+=
name|cacheSize
expr_stmt|;
block|}
name|baseDirSize
operator|.
name|put
argument_list|(
name|cacheStatus
operator|.
name|baseDir
argument_list|,
name|dirSize
argument_list|)
expr_stmt|;
block|}
comment|// do chmod here
try|try
block|{
comment|//Setting recursive permission to grant everyone read and execute
name|FileUtil
operator|.
name|chmod
argument_list|(
name|cacheStatus
operator|.
name|baseDir
operator|.
name|toString
argument_list|()
argument_list|,
literal|"ugo+rx"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception in chmod"
operator|+
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// update cacheStatus to reflect the newly cached file
name|cacheStatus
operator|.
name|currentStatus
operator|=
literal|true
expr_stmt|;
name|cacheStatus
operator|.
name|mtime
operator|=
name|getTimestamp
argument_list|(
name|conf
argument_list|,
name|cache
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isArchive
condition|)
block|{
if|if
condition|(
name|doSymlink
condition|)
block|{
if|if
condition|(
operator|!
name|flink
operator|.
name|exists
argument_list|()
condition|)
name|FileUtil
operator|.
name|symLink
argument_list|(
name|cacheStatus
operator|.
name|localLoadPath
operator|.
name|toString
argument_list|()
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
return|return
name|cacheStatus
operator|.
name|localLoadPath
return|;
block|}
else|else
block|{
if|if
condition|(
name|doSymlink
condition|)
block|{
if|if
condition|(
operator|!
name|flink
operator|.
name|exists
argument_list|()
condition|)
name|FileUtil
operator|.
name|symLink
argument_list|(
name|cacheFilePath
argument_list|(
name|cacheStatus
operator|.
name|localLoadPath
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
return|return
name|cacheFilePath
argument_list|(
name|cacheStatus
operator|.
name|localLoadPath
argument_list|)
return|;
block|}
block|}
DECL|method|isTarFile (String filename)
specifier|private
specifier|static
name|boolean
name|isTarFile
parameter_list|(
name|String
name|filename
parameter_list|)
block|{
return|return
operator|(
name|filename
operator|.
name|endsWith
argument_list|(
literal|".tgz"
argument_list|)
operator|||
name|filename
operator|.
name|endsWith
argument_list|(
literal|".tar.gz"
argument_list|)
operator|||
name|filename
operator|.
name|endsWith
argument_list|(
literal|".tar"
argument_list|)
operator|)
return|;
block|}
comment|// Checks if the cache has already been localized and is fresh
DECL|method|ifExistsAndFresh (Configuration conf, FileSystem fs, URI cache, long confFileStamp, CacheStatus lcacheStatus, FileStatus fileStatus)
specifier|private
specifier|static
name|boolean
name|ifExistsAndFresh
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FileSystem
name|fs
parameter_list|,
name|URI
name|cache
parameter_list|,
name|long
name|confFileStamp
parameter_list|,
name|CacheStatus
name|lcacheStatus
parameter_list|,
name|FileStatus
name|fileStatus
parameter_list|)
throws|throws
name|IOException
block|{
comment|// check for existence of the cache
if|if
condition|(
name|lcacheStatus
operator|.
name|currentStatus
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
name|long
name|dfsFileStamp
decl_stmt|;
if|if
condition|(
name|fileStatus
operator|!=
literal|null
condition|)
block|{
name|dfsFileStamp
operator|=
name|fileStatus
operator|.
name|getModificationTime
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|dfsFileStamp
operator|=
name|getTimestamp
argument_list|(
name|conf
argument_list|,
name|cache
argument_list|)
expr_stmt|;
block|}
comment|// ensure that the file on hdfs hasn't been modified since the job started
if|if
condition|(
name|dfsFileStamp
operator|!=
name|confFileStamp
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"File: "
operator|+
name|cache
operator|+
literal|" has changed on HDFS since job started"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"File: "
operator|+
name|cache
operator|+
literal|" has changed on HDFS since job started"
argument_list|)
throw|;
block|}
if|if
condition|(
name|dfsFileStamp
operator|!=
name|lcacheStatus
operator|.
name|mtime
condition|)
block|{
comment|// needs refreshing
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Returns mtime of a given cache file on hdfs.    * @param conf configuration    * @param cache cache file     * @return mtime of a given cache file on hdfs    * @throws IOException    */
DECL|method|getTimestamp (Configuration conf, URI cache)
specifier|public
specifier|static
name|long
name|getTimestamp
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|URI
name|cache
parameter_list|)
throws|throws
name|IOException
block|{
name|FileSystem
name|fileSystem
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|cache
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|Path
name|filePath
init|=
operator|new
name|Path
argument_list|(
name|cache
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|fileSystem
operator|.
name|getFileStatus
argument_list|(
name|filePath
argument_list|)
operator|.
name|getModificationTime
argument_list|()
return|;
block|}
comment|/**    * This method create symlinks for all files in a given dir in another directory    * @param conf the configuration    * @param jobCacheDir the target directory for creating symlinks    * @param workDir the directory in which the symlinks are created    * @throws IOException    */
DECL|method|createAllSymlink (Configuration conf, File jobCacheDir, File workDir)
specifier|public
specifier|static
name|void
name|createAllSymlink
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|File
name|jobCacheDir
parameter_list|,
name|File
name|workDir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|(
name|jobCacheDir
operator|==
literal|null
operator|||
operator|!
name|jobCacheDir
operator|.
name|isDirectory
argument_list|()
operator|)
operator|||
name|workDir
operator|==
literal|null
operator|||
operator|(
operator|!
name|workDir
operator|.
name|isDirectory
argument_list|()
operator|)
condition|)
block|{
return|return;
block|}
name|boolean
name|createSymlink
init|=
name|getSymlink
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|createSymlink
condition|)
block|{
name|File
index|[]
name|list
init|=
name|jobCacheDir
operator|.
name|listFiles
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|FileUtil
operator|.
name|symLink
argument_list|(
name|list
index|[
name|i
index|]
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
operator|new
name|File
argument_list|(
name|workDir
argument_list|,
name|list
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getFileSystem (URI cache, Configuration conf)
specifier|private
specifier|static
name|FileSystem
name|getFileSystem
parameter_list|(
name|URI
name|cache
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
literal|"hdfs"
operator|.
name|equals
argument_list|(
name|cache
operator|.
name|getScheme
argument_list|()
argument_list|)
condition|)
return|return
name|FileSystem
operator|.
name|get
argument_list|(
name|cache
argument_list|,
name|conf
argument_list|)
return|;
else|else
return|return
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
return|;
block|}
comment|/**    * Set the configuration with the given set of archives    * @param archives The list of archives that need to be localized    * @param conf Configuration which will be changed    */
DECL|method|setCacheArchives (URI[] archives, Configuration conf)
specifier|public
specifier|static
name|void
name|setCacheArchives
parameter_list|(
name|URI
index|[]
name|archives
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|sarchives
init|=
name|StringUtils
operator|.
name|uriToString
argument_list|(
name|archives
argument_list|)
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
literal|"mapred.cache.archives"
argument_list|,
name|sarchives
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the configuration with the given set of files    * @param files The list of files that need to be localized    * @param conf Configuration which will be changed    */
DECL|method|setCacheFiles (URI[] files, Configuration conf)
specifier|public
specifier|static
name|void
name|setCacheFiles
parameter_list|(
name|URI
index|[]
name|files
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|sfiles
init|=
name|StringUtils
operator|.
name|uriToString
argument_list|(
name|files
argument_list|)
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
literal|"mapred.cache.files"
argument_list|,
name|sfiles
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get cache archives set in the Configuration    * @param conf The configuration which contains the archives    * @return A URI array of the caches set in the Configuration    * @throws IOException    */
DECL|method|getCacheArchives (Configuration conf)
specifier|public
specifier|static
name|URI
index|[]
name|getCacheArchives
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|StringUtils
operator|.
name|stringToURI
argument_list|(
name|conf
operator|.
name|getStrings
argument_list|(
literal|"mapred.cache.archives"
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get cache files set in the Configuration    * @param conf The configuration which contains the files    * @return A URI array of the files set in the Configuration    * @throws IOException    */
DECL|method|getCacheFiles (Configuration conf)
specifier|public
specifier|static
name|URI
index|[]
name|getCacheFiles
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|StringUtils
operator|.
name|stringToURI
argument_list|(
name|conf
operator|.
name|getStrings
argument_list|(
literal|"mapred.cache.files"
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Return the path array of the localized caches    * @param conf Configuration that contains the localized archives    * @return A path array of localized caches    * @throws IOException    */
DECL|method|getLocalCacheArchives (Configuration conf)
specifier|public
specifier|static
name|Path
index|[]
name|getLocalCacheArchives
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|StringUtils
operator|.
name|stringToPath
argument_list|(
name|conf
operator|.
name|getStrings
argument_list|(
literal|"mapred.cache.localArchives"
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Return the path array of the localized files    * @param conf Configuration that contains the localized files    * @return A path array of localized files    * @throws IOException    */
DECL|method|getLocalCacheFiles (Configuration conf)
specifier|public
specifier|static
name|Path
index|[]
name|getLocalCacheFiles
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|StringUtils
operator|.
name|stringToPath
argument_list|(
name|conf
operator|.
name|getStrings
argument_list|(
literal|"mapred.cache.localFiles"
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get the timestamps of the archives    * @param conf The configuration which stored the timestamps    * @return a string array of timestamps     * @throws IOException    */
DECL|method|getArchiveTimestamps (Configuration conf)
specifier|public
specifier|static
name|String
index|[]
name|getArchiveTimestamps
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getStrings
argument_list|(
literal|"mapred.cache.archives.timestamps"
argument_list|)
return|;
block|}
comment|/**    * Get the timestamps of the files    * @param conf The configuration which stored the timestamps    * @return a string array of timestamps     * @throws IOException    */
DECL|method|getFileTimestamps (Configuration conf)
specifier|public
specifier|static
name|String
index|[]
name|getFileTimestamps
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getStrings
argument_list|(
literal|"mapred.cache.files.timestamps"
argument_list|)
return|;
block|}
comment|/**    * This is to check the timestamp of the archives to be localized    * @param conf Configuration which stores the timestamp's    * @param timestamps comma separated list of timestamps of archives.    * The order should be the same as the order in which the archives are added.    */
DECL|method|setArchiveTimestamps (Configuration conf, String timestamps)
specifier|public
specifier|static
name|void
name|setArchiveTimestamps
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|timestamps
parameter_list|)
block|{
name|conf
operator|.
name|set
argument_list|(
literal|"mapred.cache.archives.timestamps"
argument_list|,
name|timestamps
argument_list|)
expr_stmt|;
block|}
comment|/**    * This is to check the timestamp of the files to be localized    * @param conf Configuration which stores the timestamp's    * @param timestamps comma separated list of timestamps of files.    * The order should be the same as the order in which the files are added.    */
DECL|method|setFileTimestamps (Configuration conf, String timestamps)
specifier|public
specifier|static
name|void
name|setFileTimestamps
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|timestamps
parameter_list|)
block|{
name|conf
operator|.
name|set
argument_list|(
literal|"mapred.cache.files.timestamps"
argument_list|,
name|timestamps
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the conf to contain the location for localized archives     * @param conf The conf to modify to contain the localized caches    * @param str a comma separated list of local archives    */
DECL|method|setLocalArchives (Configuration conf, String str)
specifier|public
specifier|static
name|void
name|setLocalArchives
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|str
parameter_list|)
block|{
name|conf
operator|.
name|set
argument_list|(
literal|"mapred.cache.localArchives"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the conf to contain the location for localized files     * @param conf The conf to modify to contain the localized caches    * @param str a comma separated list of local files    */
DECL|method|setLocalFiles (Configuration conf, String str)
specifier|public
specifier|static
name|void
name|setLocalFiles
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|str
parameter_list|)
block|{
name|conf
operator|.
name|set
argument_list|(
literal|"mapred.cache.localFiles"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a archives to be localized to the conf    * @param uri The uri of the cache to be localized    * @param conf Configuration to add the cache to    */
DECL|method|addCacheArchive (URI uri, Configuration conf)
specifier|public
specifier|static
name|void
name|addCacheArchive
parameter_list|(
name|URI
name|uri
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|archives
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"mapred.cache.archives"
argument_list|)
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
literal|"mapred.cache.archives"
argument_list|,
name|archives
operator|==
literal|null
condition|?
name|uri
operator|.
name|toString
argument_list|()
else|:
name|archives
operator|+
literal|","
operator|+
name|uri
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add a file to be localized to the conf    * @param uri The uri of the cache to be localized    * @param conf Configuration to add the cache to    */
DECL|method|addCacheFile (URI uri, Configuration conf)
specifier|public
specifier|static
name|void
name|addCacheFile
parameter_list|(
name|URI
name|uri
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|files
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"mapred.cache.files"
argument_list|)
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
literal|"mapred.cache.files"
argument_list|,
name|files
operator|==
literal|null
condition|?
name|uri
operator|.
name|toString
argument_list|()
else|:
name|files
operator|+
literal|","
operator|+
name|uri
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Add an file path to the current set of classpath entries It adds the file    * to cache as well.    *     * @param file Path of the file to be added    * @param conf Configuration that contains the classpath setting    */
DECL|method|addFileToClassPath (Path file, Configuration conf)
specifier|public
specifier|static
name|void
name|addFileToClassPath
parameter_list|(
name|Path
name|file
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|classpath
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"mapred.job.classpath.files"
argument_list|)
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
literal|"mapred.job.classpath.files"
argument_list|,
name|classpath
operator|==
literal|null
condition|?
name|file
operator|.
name|toString
argument_list|()
else|:
name|classpath
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"path.separator"
argument_list|)
operator|+
name|file
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|URI
name|uri
init|=
name|fs
operator|.
name|makeQualified
argument_list|(
name|file
argument_list|)
operator|.
name|toUri
argument_list|()
decl_stmt|;
name|addCacheFile
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the file entries in classpath as an array of Path    *     * @param conf Configuration that contains the classpath setting    */
DECL|method|getFileClassPaths (Configuration conf)
specifier|public
specifier|static
name|Path
index|[]
name|getFileClassPaths
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|classpath
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"mapred.job.classpath.files"
argument_list|)
decl_stmt|;
if|if
condition|(
name|classpath
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|ArrayList
name|list
init|=
name|Collections
operator|.
name|list
argument_list|(
operator|new
name|StringTokenizer
argument_list|(
name|classpath
argument_list|,
name|System
operator|.
name|getProperty
argument_list|(
literal|"path.separator"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|Path
index|[]
name|paths
init|=
operator|new
name|Path
index|[
name|list
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|paths
index|[
name|i
index|]
operator|=
operator|new
name|Path
argument_list|(
operator|(
name|String
operator|)
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|paths
return|;
block|}
comment|/**    * Add an archive path to the current set of classpath entries. It adds the    * archive to cache as well.    *     * @param archive Path of the archive to be added    * @param conf Configuration that contains the classpath setting    */
DECL|method|addArchiveToClassPath (Path archive, Configuration conf)
specifier|public
specifier|static
name|void
name|addArchiveToClassPath
parameter_list|(
name|Path
name|archive
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|classpath
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"mapred.job.classpath.archives"
argument_list|)
decl_stmt|;
name|conf
operator|.
name|set
argument_list|(
literal|"mapred.job.classpath.archives"
argument_list|,
name|classpath
operator|==
literal|null
condition|?
name|archive
operator|.
name|toString
argument_list|()
else|:
name|classpath
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"path.separator"
argument_list|)
operator|+
name|archive
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|URI
name|uri
init|=
name|fs
operator|.
name|makeQualified
argument_list|(
name|archive
argument_list|)
operator|.
name|toUri
argument_list|()
decl_stmt|;
name|addCacheArchive
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the archive entries in classpath as an array of Path    *     * @param conf Configuration that contains the classpath setting    */
DECL|method|getArchiveClassPaths (Configuration conf)
specifier|public
specifier|static
name|Path
index|[]
name|getArchiveClassPaths
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|classpath
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"mapred.job.classpath.archives"
argument_list|)
decl_stmt|;
if|if
condition|(
name|classpath
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|ArrayList
name|list
init|=
name|Collections
operator|.
name|list
argument_list|(
operator|new
name|StringTokenizer
argument_list|(
name|classpath
argument_list|,
name|System
operator|.
name|getProperty
argument_list|(
literal|"path.separator"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|Path
index|[]
name|paths
init|=
operator|new
name|Path
index|[
name|list
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|paths
index|[
name|i
index|]
operator|=
operator|new
name|Path
argument_list|(
operator|(
name|String
operator|)
name|list
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|paths
return|;
block|}
comment|/**    * This method allows you to create symlinks in the current working directory    * of the task to all the cache files/archives    * @param conf the jobconf     */
DECL|method|createSymlink (Configuration conf)
specifier|public
specifier|static
name|void
name|createSymlink
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|conf
operator|.
name|set
argument_list|(
literal|"mapred.create.symlink"
argument_list|,
literal|"yes"
argument_list|)
expr_stmt|;
block|}
comment|/**    * This method checks to see if symlinks are to be create for the     * localized cache files in the current working directory     * @param conf the jobconf    * @return true if symlinks are to be created- else return false    */
DECL|method|getSymlink (Configuration conf)
specifier|public
specifier|static
name|boolean
name|getSymlink
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|String
name|result
init|=
name|conf
operator|.
name|get
argument_list|(
literal|"mapred.create.symlink"
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"yes"
operator|.
name|equals
argument_list|(
name|result
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * This method checks if there is a conflict in the fragment names     * of the uris. Also makes sure that each uri has a fragment. It     * is only to be called if you want to create symlinks for     * the various archives and files.    * @param uriFiles The uri array of urifiles    * @param uriArchives the uri array of uri archives    */
DECL|method|checkURIs (URI[] uriFiles, URI[] uriArchives)
specifier|public
specifier|static
name|boolean
name|checkURIs
parameter_list|(
name|URI
index|[]
name|uriFiles
parameter_list|,
name|URI
index|[]
name|uriArchives
parameter_list|)
block|{
if|if
condition|(
operator|(
name|uriFiles
operator|==
literal|null
operator|)
operator|&&
operator|(
name|uriArchives
operator|==
literal|null
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|uriFiles
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|uriFiles
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|frag1
init|=
name|uriFiles
index|[
name|i
index|]
operator|.
name|getFragment
argument_list|()
decl_stmt|;
if|if
condition|(
name|frag1
operator|==
literal|null
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|j
init|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|uriFiles
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|String
name|frag2
init|=
name|uriFiles
index|[
name|j
index|]
operator|.
name|getFragment
argument_list|()
decl_stmt|;
if|if
condition|(
name|frag2
operator|==
literal|null
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|frag1
operator|.
name|equalsIgnoreCase
argument_list|(
name|frag2
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
if|if
condition|(
name|uriArchives
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|uriArchives
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|String
name|frag2
init|=
name|uriArchives
index|[
name|j
index|]
operator|.
name|getFragment
argument_list|()
decl_stmt|;
if|if
condition|(
name|frag2
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|frag1
operator|.
name|equalsIgnoreCase
argument_list|(
name|frag2
argument_list|)
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|k
init|=
name|j
operator|+
literal|1
init|;
name|k
operator|<
name|uriArchives
operator|.
name|length
condition|;
name|k
operator|++
control|)
block|{
name|String
name|frag3
init|=
name|uriArchives
index|[
name|k
index|]
operator|.
name|getFragment
argument_list|()
decl_stmt|;
if|if
condition|(
name|frag3
operator|==
literal|null
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|frag2
operator|.
name|equalsIgnoreCase
argument_list|(
name|frag3
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
block|}
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|class|CacheStatus
specifier|private
specifier|static
class|class
name|CacheStatus
block|{
comment|// false, not loaded yet, true is loaded
DECL|field|currentStatus
name|boolean
name|currentStatus
decl_stmt|;
comment|// the local load path of this cache
DECL|field|localLoadPath
name|Path
name|localLoadPath
decl_stmt|;
comment|//the base dir where the cache lies
DECL|field|baseDir
name|Path
name|baseDir
decl_stmt|;
comment|//the size of this cache
DECL|field|size
name|long
name|size
decl_stmt|;
comment|// number of instances using this cache
DECL|field|refcount
name|int
name|refcount
decl_stmt|;
comment|// the cache-file modification time
DECL|field|mtime
name|long
name|mtime
decl_stmt|;
DECL|method|CacheStatus (Path baseDir, Path localLoadPath)
specifier|public
name|CacheStatus
parameter_list|(
name|Path
name|baseDir
parameter_list|,
name|Path
name|localLoadPath
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|currentStatus
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|localLoadPath
operator|=
name|localLoadPath
expr_stmt|;
name|this
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|mtime
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|baseDir
operator|=
name|baseDir
expr_stmt|;
name|this
operator|.
name|size
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/**    * Clear the entire contents of the cache and delete the backing files. This    * should only be used when the server is reinitializing, because the users    * are going to lose their files.    */
DECL|method|purgeCache (Configuration conf)
specifier|public
specifier|static
name|void
name|purgeCache
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|cachedArchives
init|)
block|{
name|FileSystem
name|localFs
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|CacheStatus
argument_list|>
name|f
range|:
name|cachedArchives
operator|.
name|entrySet
argument_list|()
control|)
block|{
try|try
block|{
name|localFs
operator|.
name|delete
argument_list|(
name|f
operator|.
name|getValue
argument_list|()
operator|.
name|localLoadPath
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Error cleaning up cache"
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
name|cachedArchives
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

