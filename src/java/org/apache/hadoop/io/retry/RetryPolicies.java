begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.io.retry
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_comment
comment|/**  *<p>  * A collection of useful implementations of {@link RetryPolicy}.  *</p>  */
end_comment

begin_class
DECL|class|RetryPolicies
specifier|public
class|class
name|RetryPolicies
block|{
comment|/**    *<p>    * Try once, and fail by re-throwing the exception.    * This corresponds to having no retry mechanism in place.    *</p>    */
DECL|field|TRY_ONCE_THEN_FAIL
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|TRY_ONCE_THEN_FAIL
init|=
operator|new
name|TryOnceThenFail
argument_list|()
decl_stmt|;
comment|/**    *<p>    * Try once, and fail silently for<code>void</code> methods, or by    * re-throwing the exception for non-<code>void</code> methods.    *</p>    */
DECL|field|TRY_ONCE_DONT_FAIL
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|TRY_ONCE_DONT_FAIL
init|=
operator|new
name|TryOnceDontFail
argument_list|()
decl_stmt|;
comment|/**    *<p>    * Keep trying forever.    *</p>    */
DECL|field|RETRY_FOREVER
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|RETRY_FOREVER
init|=
operator|new
name|RetryForever
argument_list|()
decl_stmt|;
comment|/**    *<p>    * Keep trying a limited number of times, waiting a fixed time between attempts,    * and then fail by re-throwing the exception.    *</p>    */
DECL|method|retryUpToMaximumCountWithFixedSleep (int maxRetries, long sleepTime, TimeUnit timeUnit)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|retryUpToMaximumCountWithFixedSleep
parameter_list|(
name|int
name|maxRetries
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
return|return
operator|new
name|RetryUpToMaximumCountWithFixedSleep
argument_list|(
name|maxRetries
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
return|;
block|}
comment|/**    *<p>    * Keep trying for a maximum time, waiting a fixed time between attempts,    * and then fail by re-throwing the exception.    *</p>    */
DECL|method|retryUpToMaximumTimeWithFixedSleep (long maxTime, long sleepTime, TimeUnit timeUnit)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|retryUpToMaximumTimeWithFixedSleep
parameter_list|(
name|long
name|maxTime
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
return|return
operator|new
name|RetryUpToMaximumTimeWithFixedSleep
argument_list|(
name|maxTime
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
return|;
block|}
comment|/**    *<p>    * Keep trying a limited number of times, waiting a growing amount of time between attempts,    * and then fail by re-throwing the exception.    * The time between attempts is<code>sleepTime</code> mutliplied by the number of tries so far.    *</p>    */
DECL|method|retryUpToMaximumCountWithProportionalSleep (int maxRetries, long sleepTime, TimeUnit timeUnit)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|retryUpToMaximumCountWithProportionalSleep
parameter_list|(
name|int
name|maxRetries
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
return|return
operator|new
name|RetryUpToMaximumCountWithProportionalSleep
argument_list|(
name|maxRetries
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
return|;
block|}
comment|/**    *<p>    * Keep trying a limited number of times, waiting a growing amount of time between attempts,    * and then fail by re-throwing the exception.    * The time between attempts is<code>sleepTime</code> mutliplied by a random    * number in the range of [0, 2 to the number of retries)    *</p>    */
DECL|method|exponentialBackoffRetry ( int maxRetries, long sleepTime, TimeUnit timeUnit)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|exponentialBackoffRetry
parameter_list|(
name|int
name|maxRetries
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
return|return
operator|new
name|ExponentialBackoffRetry
argument_list|(
name|maxRetries
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
return|;
block|}
comment|/**    *<p>    * Set a default policy with some explicit handlers for specific exceptions.    *</p>    */
DECL|method|retryByException (RetryPolicy defaultPolicy, Map<Class<? extends Exception>, RetryPolicy> exceptionToPolicyMap)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|retryByException
parameter_list|(
name|RetryPolicy
name|defaultPolicy
parameter_list|,
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
argument_list|,
name|RetryPolicy
argument_list|>
name|exceptionToPolicyMap
parameter_list|)
block|{
return|return
operator|new
name|ExceptionDependentRetry
argument_list|(
name|defaultPolicy
argument_list|,
name|exceptionToPolicyMap
argument_list|)
return|;
block|}
comment|/**    *<p>    * A retry policy for RemoteException    * Set a default policy with some explicit handlers for specific exceptions.    *</p>    */
DECL|method|retryByRemoteException ( RetryPolicy defaultPolicy, Map<Class<? extends Exception>, RetryPolicy> exceptionToPolicyMap)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|retryByRemoteException
parameter_list|(
name|RetryPolicy
name|defaultPolicy
parameter_list|,
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
argument_list|,
name|RetryPolicy
argument_list|>
name|exceptionToPolicyMap
parameter_list|)
block|{
return|return
operator|new
name|RemoteExceptionDependentRetry
argument_list|(
name|defaultPolicy
argument_list|,
name|exceptionToPolicyMap
argument_list|)
return|;
block|}
DECL|class|TryOnceThenFail
specifier|static
class|class
name|TryOnceThenFail
implements|implements
name|RetryPolicy
block|{
DECL|method|shouldRetry (Exception e, int retries)
specifier|public
name|boolean
name|shouldRetry
parameter_list|(
name|Exception
name|e
parameter_list|,
name|int
name|retries
parameter_list|)
throws|throws
name|Exception
block|{
throw|throw
name|e
throw|;
block|}
block|}
DECL|class|TryOnceDontFail
specifier|static
class|class
name|TryOnceDontFail
implements|implements
name|RetryPolicy
block|{
DECL|method|shouldRetry (Exception e, int retries)
specifier|public
name|boolean
name|shouldRetry
parameter_list|(
name|Exception
name|e
parameter_list|,
name|int
name|retries
parameter_list|)
throws|throws
name|Exception
block|{
return|return
literal|false
return|;
block|}
block|}
DECL|class|RetryForever
specifier|static
class|class
name|RetryForever
implements|implements
name|RetryPolicy
block|{
DECL|method|shouldRetry (Exception e, int retries)
specifier|public
name|boolean
name|shouldRetry
parameter_list|(
name|Exception
name|e
parameter_list|,
name|int
name|retries
parameter_list|)
throws|throws
name|Exception
block|{
return|return
literal|true
return|;
block|}
block|}
DECL|class|RetryLimited
specifier|static
specifier|abstract
class|class
name|RetryLimited
implements|implements
name|RetryPolicy
block|{
DECL|field|maxRetries
name|int
name|maxRetries
decl_stmt|;
DECL|field|sleepTime
name|long
name|sleepTime
decl_stmt|;
DECL|field|timeUnit
name|TimeUnit
name|timeUnit
decl_stmt|;
DECL|method|RetryLimited (int maxRetries, long sleepTime, TimeUnit timeUnit)
specifier|public
name|RetryLimited
parameter_list|(
name|int
name|maxRetries
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
name|this
operator|.
name|maxRetries
operator|=
name|maxRetries
expr_stmt|;
name|this
operator|.
name|sleepTime
operator|=
name|sleepTime
expr_stmt|;
name|this
operator|.
name|timeUnit
operator|=
name|timeUnit
expr_stmt|;
block|}
DECL|method|shouldRetry (Exception e, int retries)
specifier|public
name|boolean
name|shouldRetry
parameter_list|(
name|Exception
name|e
parameter_list|,
name|int
name|retries
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|retries
operator|>=
name|maxRetries
condition|)
block|{
throw|throw
name|e
throw|;
block|}
try|try
block|{
name|timeUnit
operator|.
name|sleep
argument_list|(
name|calculateSleepTime
argument_list|(
name|retries
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// retry
block|}
return|return
literal|true
return|;
block|}
DECL|method|calculateSleepTime (int retries)
specifier|protected
specifier|abstract
name|long
name|calculateSleepTime
parameter_list|(
name|int
name|retries
parameter_list|)
function_decl|;
block|}
DECL|class|RetryUpToMaximumCountWithFixedSleep
specifier|static
class|class
name|RetryUpToMaximumCountWithFixedSleep
extends|extends
name|RetryLimited
block|{
DECL|method|RetryUpToMaximumCountWithFixedSleep (int maxRetries, long sleepTime, TimeUnit timeUnit)
specifier|public
name|RetryUpToMaximumCountWithFixedSleep
parameter_list|(
name|int
name|maxRetries
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
name|super
argument_list|(
name|maxRetries
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|calculateSleepTime (int retries)
specifier|protected
name|long
name|calculateSleepTime
parameter_list|(
name|int
name|retries
parameter_list|)
block|{
return|return
name|sleepTime
return|;
block|}
block|}
DECL|class|RetryUpToMaximumTimeWithFixedSleep
specifier|static
class|class
name|RetryUpToMaximumTimeWithFixedSleep
extends|extends
name|RetryUpToMaximumCountWithFixedSleep
block|{
DECL|method|RetryUpToMaximumTimeWithFixedSleep (long maxTime, long sleepTime, TimeUnit timeUnit)
specifier|public
name|RetryUpToMaximumTimeWithFixedSleep
parameter_list|(
name|long
name|maxTime
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
name|super
argument_list|(
call|(
name|int
call|)
argument_list|(
name|maxTime
operator|/
name|sleepTime
argument_list|)
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|RetryUpToMaximumCountWithProportionalSleep
specifier|static
class|class
name|RetryUpToMaximumCountWithProportionalSleep
extends|extends
name|RetryLimited
block|{
DECL|method|RetryUpToMaximumCountWithProportionalSleep (int maxRetries, long sleepTime, TimeUnit timeUnit)
specifier|public
name|RetryUpToMaximumCountWithProportionalSleep
parameter_list|(
name|int
name|maxRetries
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
name|super
argument_list|(
name|maxRetries
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|calculateSleepTime (int retries)
specifier|protected
name|long
name|calculateSleepTime
parameter_list|(
name|int
name|retries
parameter_list|)
block|{
return|return
name|sleepTime
operator|*
operator|(
name|retries
operator|+
literal|1
operator|)
return|;
block|}
block|}
DECL|class|ExceptionDependentRetry
specifier|static
class|class
name|ExceptionDependentRetry
implements|implements
name|RetryPolicy
block|{
DECL|field|defaultPolicy
name|RetryPolicy
name|defaultPolicy
decl_stmt|;
DECL|field|exceptionToPolicyMap
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
argument_list|,
name|RetryPolicy
argument_list|>
name|exceptionToPolicyMap
decl_stmt|;
DECL|method|ExceptionDependentRetry (RetryPolicy defaultPolicy, Map<Class<? extends Exception>, RetryPolicy> exceptionToPolicyMap)
specifier|public
name|ExceptionDependentRetry
parameter_list|(
name|RetryPolicy
name|defaultPolicy
parameter_list|,
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
argument_list|,
name|RetryPolicy
argument_list|>
name|exceptionToPolicyMap
parameter_list|)
block|{
name|this
operator|.
name|defaultPolicy
operator|=
name|defaultPolicy
expr_stmt|;
name|this
operator|.
name|exceptionToPolicyMap
operator|=
name|exceptionToPolicyMap
expr_stmt|;
block|}
DECL|method|shouldRetry (Exception e, int retries)
specifier|public
name|boolean
name|shouldRetry
parameter_list|(
name|Exception
name|e
parameter_list|,
name|int
name|retries
parameter_list|)
throws|throws
name|Exception
block|{
name|RetryPolicy
name|policy
init|=
name|exceptionToPolicyMap
operator|.
name|get
argument_list|(
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|policy
operator|==
literal|null
condition|)
block|{
name|policy
operator|=
name|defaultPolicy
expr_stmt|;
block|}
return|return
name|policy
operator|.
name|shouldRetry
argument_list|(
name|e
argument_list|,
name|retries
argument_list|)
return|;
block|}
block|}
DECL|class|RemoteExceptionDependentRetry
specifier|static
class|class
name|RemoteExceptionDependentRetry
implements|implements
name|RetryPolicy
block|{
DECL|field|defaultPolicy
name|RetryPolicy
name|defaultPolicy
decl_stmt|;
DECL|field|exceptionNameToPolicyMap
name|Map
argument_list|<
name|String
argument_list|,
name|RetryPolicy
argument_list|>
name|exceptionNameToPolicyMap
decl_stmt|;
DECL|method|RemoteExceptionDependentRetry (RetryPolicy defaultPolicy, Map<Class<? extends Exception>, RetryPolicy> exceptionToPolicyMap)
specifier|public
name|RemoteExceptionDependentRetry
parameter_list|(
name|RetryPolicy
name|defaultPolicy
parameter_list|,
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
argument_list|,
name|RetryPolicy
argument_list|>
name|exceptionToPolicyMap
parameter_list|)
block|{
name|this
operator|.
name|defaultPolicy
operator|=
name|defaultPolicy
expr_stmt|;
name|this
operator|.
name|exceptionNameToPolicyMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|RetryPolicy
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
argument_list|,
name|RetryPolicy
argument_list|>
name|e
range|:
name|exceptionToPolicyMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|exceptionNameToPolicyMap
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|shouldRetry (Exception e, int retries)
specifier|public
name|boolean
name|shouldRetry
parameter_list|(
name|Exception
name|e
parameter_list|,
name|int
name|retries
parameter_list|)
throws|throws
name|Exception
block|{
name|RetryPolicy
name|policy
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
name|policy
operator|=
name|exceptionNameToPolicyMap
operator|.
name|get
argument_list|(
operator|(
operator|(
name|RemoteException
operator|)
name|e
operator|)
operator|.
name|getClassName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|policy
operator|==
literal|null
condition|)
block|{
name|policy
operator|=
name|defaultPolicy
expr_stmt|;
block|}
return|return
name|policy
operator|.
name|shouldRetry
argument_list|(
name|e
argument_list|,
name|retries
argument_list|)
return|;
block|}
block|}
DECL|class|ExponentialBackoffRetry
specifier|static
class|class
name|ExponentialBackoffRetry
extends|extends
name|RetryLimited
block|{
DECL|field|r
specifier|private
name|Random
name|r
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
DECL|method|ExponentialBackoffRetry ( int maxRetries, long sleepTime, TimeUnit timeUnit)
specifier|public
name|ExponentialBackoffRetry
parameter_list|(
name|int
name|maxRetries
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
name|super
argument_list|(
name|maxRetries
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|calculateSleepTime (int retries)
specifier|protected
name|long
name|calculateSleepTime
parameter_list|(
name|int
name|retries
parameter_list|)
block|{
return|return
name|sleepTime
operator|*
name|r
operator|.
name|nextInt
argument_list|(
literal|1
operator|<<
operator|(
name|retries
operator|+
literal|1
operator|)
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

