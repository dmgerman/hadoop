begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
operator|.
name|CreateOpts
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
operator|.
name|Rename
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CreateFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_comment
comment|/**  * Test symbolic links using FileContext.  */
end_comment

begin_class
DECL|class|FileContextSymlinkBaseTest
specifier|public
specifier|abstract
class|class
name|FileContextSymlinkBaseTest
block|{
DECL|field|seed
specifier|static
specifier|final
name|long
name|seed
init|=
literal|0xDEADBEEFL
decl_stmt|;
DECL|field|blockSize
specifier|static
specifier|final
name|int
name|blockSize
init|=
literal|8192
decl_stmt|;
DECL|field|fileSize
specifier|static
specifier|final
name|int
name|fileSize
init|=
literal|16384
decl_stmt|;
DECL|field|fc
specifier|protected
specifier|static
name|FileContext
name|fc
decl_stmt|;
DECL|method|getScheme ()
specifier|abstract
specifier|protected
name|String
name|getScheme
parameter_list|()
function_decl|;
DECL|method|testBaseDir1 ()
specifier|abstract
specifier|protected
name|String
name|testBaseDir1
parameter_list|()
function_decl|;
DECL|method|testBaseDir2 ()
specifier|abstract
specifier|protected
name|String
name|testBaseDir2
parameter_list|()
function_decl|;
DECL|method|testURI ()
specifier|abstract
specifier|protected
name|URI
name|testURI
parameter_list|()
function_decl|;
DECL|method|createAndWriteFile (FileContext fc, Path p)
specifier|protected
specifier|static
name|void
name|createAndWriteFile
parameter_list|(
name|FileContext
name|fc
parameter_list|,
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|FSDataOutputStream
name|out
decl_stmt|;
name|out
operator|=
name|fc
operator|.
name|create
argument_list|(
name|p
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|CreateFlag
operator|.
name|CREATE
argument_list|)
argument_list|,
name|CreateOpts
operator|.
name|createParent
argument_list|()
argument_list|,
name|CreateOpts
operator|.
name|repFac
argument_list|(
operator|(
name|short
operator|)
literal|1
argument_list|)
argument_list|,
name|CreateOpts
operator|.
name|blockSize
argument_list|(
name|blockSize
argument_list|)
argument_list|)
expr_stmt|;
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|fileSize
index|]
decl_stmt|;
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|(
name|seed
argument_list|)
decl_stmt|;
name|rand
operator|.
name|nextBytes
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|createAndWriteFile (Path p)
specifier|protected
specifier|static
name|void
name|createAndWriteFile
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|createAndWriteFile
argument_list|(
name|fc
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
DECL|method|readFile (Path p)
specifier|protected
name|void
name|readFile
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|FSDataInputStream
name|out
init|=
name|fc
operator|.
name|open
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|byte
index|[]
name|actual
init|=
operator|new
name|byte
index|[
name|fileSize
index|]
decl_stmt|;
name|out
operator|.
name|readFully
argument_list|(
name|actual
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|readFile (FileContext fc, Path p)
specifier|protected
name|void
name|readFile
parameter_list|(
name|FileContext
name|fc
parameter_list|,
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|FSDataInputStream
name|out
init|=
name|fc
operator|.
name|open
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|byte
index|[]
name|actual
init|=
operator|new
name|byte
index|[
name|fileSize
index|]
decl_stmt|;
name|out
operator|.
name|readFully
argument_list|(
name|actual
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|appendToFile (Path p)
specifier|protected
name|void
name|appendToFile
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|FSDataOutputStream
name|out
decl_stmt|;
name|out
operator|=
name|fc
operator|.
name|create
argument_list|(
name|p
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|CreateFlag
operator|.
name|APPEND
argument_list|)
argument_list|)
expr_stmt|;
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|fileSize
index|]
decl_stmt|;
name|Random
name|rand
init|=
operator|new
name|Random
argument_list|(
name|seed
argument_list|)
decl_stmt|;
name|rand
operator|.
name|nextBytes
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Before
DECL|method|setUp ()
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|fc
operator|.
name|mkdir
argument_list|(
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
argument_list|,
name|FileContext
operator|.
name|DEFAULT_PERM
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|fc
operator|.
name|mkdir
argument_list|(
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|)
argument_list|,
name|FileContext
operator|.
name|DEFAULT_PERM
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|After
DECL|method|tearDown ()
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
name|fc
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|fc
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** The root is not a symlink */
DECL|method|testStatRoot ()
specifier|public
name|void
name|testStatRoot
parameter_list|()
throws|throws
name|IOException
block|{
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test setWorkingDirectory resolves symlinks */
DECL|method|testSetWDResolvesLinks ()
specifier|public
name|void
name|testSetWDResolvesLinks
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/link"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|dir
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|setWorkingDirectory
argument_list|(
name|linkToDir
argument_list|)
expr_stmt|;
comment|// Local file system does not resolve symlinks, others do.
if|if
condition|(
literal|"file"
operator|.
name|equals
argument_list|(
name|getScheme
argument_list|()
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
name|linkToDir
operator|.
name|getName
argument_list|()
argument_list|,
name|fc
operator|.
name|getWorkingDirectory
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertEquals
argument_list|(
name|dir
operator|.
name|getName
argument_list|()
argument_list|,
name|fc
operator|.
name|getWorkingDirectory
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
comment|/** Test create a dangling link */
DECL|method|testCreateDanglingLink ()
specifier|public
name|void
name|testCreateDanglingLink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
literal|"/noSuchFile"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/link"
argument_list|)
decl_stmt|;
try|try
block|{
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
name|fail
argument_list|(
literal|"failed to create dangling symlink"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|fc
operator|.
name|getFileStatus
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Got file status of non-existant file"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|f
parameter_list|)
block|{
comment|// Expected
block|}
name|fc
operator|.
name|delete
argument_list|(
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test create a link to null and empty path */
DECL|method|testCreateLinkToNullEmpty ()
specifier|public
name|void
name|testCreateLinkToNullEmpty
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/link"
argument_list|)
decl_stmt|;
try|try
block|{
name|fc
operator|.
name|createSymlink
argument_list|(
literal|null
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Can't create symlink to null"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|lang
operator|.
name|NullPointerException
name|e
parameter_list|)
block|{
comment|// Expected, create* with null yields NPEs
block|}
try|try
block|{
name|fc
operator|.
name|createSymlink
argument_list|(
operator|new
name|Path
argument_list|(
literal|""
argument_list|)
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Can't create symlink to empty string"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|lang
operator|.
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// Expected, Path("") is invalid
block|}
block|}
annotation|@
name|Test
comment|/** Create a link with createParent set */
DECL|method|testCreateLinkCanCreateParent ()
specifier|public
name|void
name|testCreateLinkCanCreateParent
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/file"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
operator|+
literal|"/linkToFile"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Created link without first creating parent dir"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
comment|// Expected. Need to create testBaseDir2() first.
block|}
name|assertFalse
argument_list|(
name|fc
operator|.
name|exists
argument_list|(
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|link
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Delete a link */
DECL|method|testDeleteLink ()
specifier|public
name|void
name|testDeleteLink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/file"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/linkToFile"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|fc
operator|.
name|delete
argument_list|(
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|readFile
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Symlink should have been deleted"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
comment|// Expected
block|}
comment|// If we deleted the link we can put it back
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Ensure open resolves symlinks */
DECL|method|testOpenResolvesLinks ()
specifier|public
name|void
name|testOpenResolvesLinks
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/noSuchFile"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/link"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|open
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"link target does not exist"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|x
parameter_list|)
block|{
comment|// Expected
block|}
name|fc
operator|.
name|delete
argument_list|(
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Stat a link to a file */
DECL|method|testStatLinkToFile ()
specifier|public
name|void
name|testStatLinkToFile
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/file"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/linkToFile"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|link
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|link
argument_list|)
operator|.
name|isDir
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|link
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|link
argument_list|)
operator|.
name|isDir
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|isFile
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|isDirectory
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|link
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Stat a link to a directory */
DECL|method|testStatLinkToDir ()
specifier|public
name|void
name|testStatLinkToDir
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/linkToDir"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|dir
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|link
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|link
argument_list|)
operator|.
name|isDir
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|link
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|link
argument_list|)
operator|.
name|isDir
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|isFile
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|isDirectory
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|dir
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|link
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** lstat a non-existant file */
DECL|method|testStatNonExistantFiles ()
specifier|public
name|void
name|testStatNonExistantFiles
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|fileAbs
init|=
operator|new
name|Path
argument_list|(
literal|"/doesNotExist"
argument_list|)
decl_stmt|;
try|try
block|{
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|fileAbs
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Got FileStatus for non-existant file"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|f
parameter_list|)
block|{
comment|// Expected
block|}
try|try
block|{
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|fileAbs
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Got link target for non-existant file"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|f
parameter_list|)
block|{
comment|// Expected
block|}
block|}
annotation|@
name|Test
comment|/** Test stat'ing a regular file and directory */
DECL|method|testStatNonLinks ()
specifier|public
name|void
name|testStatNonLinks
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/file"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Lstat'd a non-symlink"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
try|try
block|{
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Lstat'd a non-symlink"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
annotation|@
name|Test
comment|/** Test links that link to each other */
DECL|method|testRecursiveLinks ()
specifier|public
name|void
name|testRecursiveLinks
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|link1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/link1"
argument_list|)
decl_stmt|;
name|Path
name|link2
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/link2"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|link1
argument_list|,
name|link2
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|link2
argument_list|,
name|link1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|readFile
argument_list|(
name|link1
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Read recursive link"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|f
parameter_list|)
block|{
comment|// LocalFs throws sub class of IOException, since File.exists
comment|// returns false for a link to link.
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
name|assertEquals
argument_list|(
literal|"Possible cyclic loop while following symbolic link "
operator|+
name|link1
operator|.
name|toString
argument_list|()
argument_list|,
name|x
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|checkLink (Path linkAbs, Path expectedTarget, Path targetQual)
specifier|private
name|void
name|checkLink
parameter_list|(
name|Path
name|linkAbs
parameter_list|,
name|Path
name|expectedTarget
parameter_list|,
name|Path
name|targetQual
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
comment|// isFile/Directory
name|assertTrue
argument_list|(
name|fc
operator|.
name|isFile
argument_list|(
name|linkAbs
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|isDirectory
argument_list|(
name|linkAbs
argument_list|)
argument_list|)
expr_stmt|;
comment|// Check getFileStatus
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|linkAbs
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|linkAbs
argument_list|)
operator|.
name|isDir
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileSize
argument_list|,
name|fc
operator|.
name|getFileStatus
argument_list|(
name|linkAbs
argument_list|)
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
comment|// Check getFileLinkStatus
name|assertTrue
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkAbs
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkAbs
argument_list|)
operator|.
name|isDir
argument_list|()
argument_list|)
expr_stmt|;
comment|// Check getSymlink always returns a qualified target, except
comment|// when partially qualified paths are used (see tests below).
name|assertEquals
argument_list|(
name|targetQual
operator|.
name|toString
argument_list|()
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkAbs
argument_list|)
operator|.
name|getSymlink
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|targetQual
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkAbs
argument_list|)
operator|.
name|getSymlink
argument_list|()
argument_list|)
expr_stmt|;
comment|// Check that the target is qualified using the file system of the
comment|// path used to access the link (if the link target was not specified
comment|// fully qualified, in that case we use the link target verbatim).
if|if
condition|(
operator|!
literal|"file"
operator|.
name|equals
argument_list|(
name|getScheme
argument_list|()
argument_list|)
condition|)
block|{
name|FileContext
name|localFc
init|=
name|FileContext
operator|.
name|getLocalFSFileContext
argument_list|()
decl_stmt|;
name|Path
name|linkQual
init|=
operator|new
name|Path
argument_list|(
name|testURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|linkAbs
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|targetQual
argument_list|,
name|localFc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkQual
argument_list|)
operator|.
name|getSymlink
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Check getLinkTarget
name|assertEquals
argument_list|(
name|expectedTarget
argument_list|,
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|linkAbs
argument_list|)
argument_list|)
expr_stmt|;
comment|// Now read using all path types..
name|fc
operator|.
name|setWorkingDirectory
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
operator|new
name|Path
argument_list|(
literal|"linkToFile"
argument_list|)
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|linkAbs
argument_list|)
expr_stmt|;
comment|// And fully qualified.. (NB: for local fs this is partially qualified)
name|readFile
argument_list|(
operator|new
name|Path
argument_list|(
name|testURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|linkAbs
argument_list|)
argument_list|)
expr_stmt|;
comment|// And partially qualified..
name|boolean
name|failureExpected
init|=
literal|"file"
operator|.
name|equals
argument_list|(
name|getScheme
argument_list|()
argument_list|)
condition|?
literal|false
else|:
literal|true
decl_stmt|;
try|try
block|{
name|readFile
argument_list|(
operator|new
name|Path
argument_list|(
name|getScheme
argument_list|()
operator|+
literal|"://"
operator|+
name|testBaseDir1
argument_list|()
operator|+
literal|"/linkToFile"
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|failureExpected
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|failureExpected
argument_list|)
expr_stmt|;
block|}
comment|// Now read using a different file context (for HDFS at least)
if|if
condition|(
operator|!
literal|"file"
operator|.
name|equals
argument_list|(
name|getScheme
argument_list|()
argument_list|)
condition|)
block|{
name|FileContext
name|localFc
init|=
name|FileContext
operator|.
name|getLocalFSFileContext
argument_list|()
decl_stmt|;
name|readFile
argument_list|(
name|localFc
argument_list|,
operator|new
name|Path
argument_list|(
name|testURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|linkAbs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
comment|/** Test creating a symlink using relative paths */
DECL|method|testCreateLinkUsingRelPaths ()
specifier|public
name|void
name|testCreateLinkUsingRelPaths
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|fileAbs
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|linkAbs
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|Path
name|schemeAuth
init|=
operator|new
name|Path
argument_list|(
name|testURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|fileQual
init|=
operator|new
name|Path
argument_list|(
name|schemeAuth
argument_list|,
name|testBaseDir1
argument_list|()
operator|+
literal|"/file"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|fileAbs
argument_list|)
expr_stmt|;
name|fc
operator|.
name|setWorkingDirectory
argument_list|(
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
operator|new
name|Path
argument_list|(
literal|"file"
argument_list|)
argument_list|,
operator|new
name|Path
argument_list|(
literal|"linkToFile"
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|checkLink
argument_list|(
name|linkAbs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"file"
argument_list|)
argument_list|,
name|fileQual
argument_list|)
expr_stmt|;
comment|// Now rename the link's parent. Because the target was specified
comment|// with a relative path the link should still resolve.
name|Path
name|dir1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|dir2
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|linkViaDir2
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|Path
name|fileViaDir2
init|=
operator|new
name|Path
argument_list|(
name|schemeAuth
argument_list|,
name|testBaseDir2
argument_list|()
operator|+
literal|"/file"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|rename
argument_list|(
name|dir1
argument_list|,
name|dir2
argument_list|,
name|Rename
operator|.
name|OVERWRITE
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileViaDir2
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkViaDir2
argument_list|)
operator|.
name|getSymlink
argument_list|()
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|linkViaDir2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test creating a symlink using absolute paths */
DECL|method|testCreateLinkUsingAbsPaths ()
specifier|public
name|void
name|testCreateLinkUsingAbsPaths
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|fileAbs
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/file"
argument_list|)
decl_stmt|;
name|Path
name|linkAbs
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/linkToFile"
argument_list|)
decl_stmt|;
name|Path
name|schemeAuth
init|=
operator|new
name|Path
argument_list|(
name|testURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|fileQual
init|=
operator|new
name|Path
argument_list|(
name|schemeAuth
argument_list|,
name|testBaseDir1
argument_list|()
operator|+
literal|"/file"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|fileAbs
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|fileAbs
argument_list|,
name|linkAbs
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|checkLink
argument_list|(
name|linkAbs
argument_list|,
name|fileAbs
argument_list|,
name|fileQual
argument_list|)
expr_stmt|;
comment|// Now rename the link's parent. The target doesn't change and
comment|// now no longer exists so accessing the link should fail.
name|Path
name|dir1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|dir2
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|linkViaDir2
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|rename
argument_list|(
name|dir1
argument_list|,
name|dir2
argument_list|,
name|Rename
operator|.
name|OVERWRITE
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileQual
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkViaDir2
argument_list|)
operator|.
name|getSymlink
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|readFile
argument_list|(
name|linkViaDir2
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"The target should not exist"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|x
parameter_list|)
block|{
comment|// Expected
block|}
block|}
annotation|@
name|Test
comment|/**     * Test creating a symlink using fully and partially qualified paths.    * NB: For local fs this actually tests partially qualified paths,    * as they don't support fully qualified paths.    */
DECL|method|testCreateLinkUsingFullyQualPaths ()
specifier|public
name|void
name|testCreateLinkUsingFullyQualPaths
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|fileAbs
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|linkAbs
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|Path
name|fileQual
init|=
operator|new
name|Path
argument_list|(
name|testURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|fileAbs
argument_list|)
decl_stmt|;
name|Path
name|linkQual
init|=
operator|new
name|Path
argument_list|(
name|testURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|linkAbs
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|fileAbs
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|fileQual
argument_list|,
name|linkQual
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|checkLink
argument_list|(
name|linkAbs
argument_list|,
literal|"file"
operator|.
name|equals
argument_list|(
name|getScheme
argument_list|()
argument_list|)
condition|?
name|fileAbs
else|:
name|fileQual
argument_list|,
name|fileQual
argument_list|)
expr_stmt|;
comment|// Now rename the link's parent. The target doesn't change and
comment|// now no longer exists so accessing the link should fail.
name|Path
name|dir1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|dir2
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|linkViaDir2
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|rename
argument_list|(
name|dir1
argument_list|,
name|dir2
argument_list|,
name|Rename
operator|.
name|OVERWRITE
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileQual
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkViaDir2
argument_list|)
operator|.
name|getSymlink
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|readFile
argument_list|(
name|linkViaDir2
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"The target should not exist"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|x
parameter_list|)
block|{
comment|// Expected
block|}
block|}
annotation|@
name|Test
comment|/**     * Test creating a symlink using partially qualified paths, ie a scheme     * but no authority and vice versa. We just test link targets here since    * creating using a partially qualified path is file system specific.    */
DECL|method|testCreateLinkUsingPartQualPath1 ()
specifier|public
name|void
name|testCreateLinkUsingPartQualPath1
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|schemeAuth
init|=
operator|new
name|Path
argument_list|(
name|testURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|fileWoHost
init|=
operator|new
name|Path
argument_list|(
name|getScheme
argument_list|()
operator|+
literal|"://"
operator|+
name|testBaseDir1
argument_list|()
operator|+
literal|"/file"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/linkToFile"
argument_list|)
decl_stmt|;
name|Path
name|linkQual
init|=
operator|new
name|Path
argument_list|(
name|schemeAuth
argument_list|,
name|testBaseDir1
argument_list|()
operator|+
literal|"/linkToFile"
argument_list|)
decl_stmt|;
comment|// Partially qualified paths are covered for local file systems
comment|// in the previous test.
if|if
condition|(
literal|"file"
operator|.
name|equals
argument_list|(
name|getScheme
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
name|FileContext
name|localFc
init|=
name|FileContext
operator|.
name|getLocalFSFileContext
argument_list|()
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|fileWoHost
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Partially qualified path is stored
name|assertEquals
argument_list|(
name|fileWoHost
argument_list|,
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|linkQual
argument_list|)
argument_list|)
expr_stmt|;
comment|// NB: We do not add an authority
name|assertEquals
argument_list|(
name|fileWoHost
operator|.
name|toString
argument_list|()
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|link
argument_list|)
operator|.
name|getSymlink
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileWoHost
operator|.
name|toString
argument_list|()
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkQual
argument_list|)
operator|.
name|getSymlink
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Ditto even from another file system
name|assertEquals
argument_list|(
name|fileWoHost
operator|.
name|toString
argument_list|()
argument_list|,
name|localFc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkQual
argument_list|)
operator|.
name|getSymlink
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Same as if we accessed a partially qualified path directly
try|try
block|{
name|readFile
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"DFS requires URIs with schemes have an authority"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|lang
operator|.
name|RuntimeException
name|e
parameter_list|)
block|{
comment|// Expected
block|}
block|}
annotation|@
name|Test
comment|/** Same as above but vice versa (authority but no scheme) */
DECL|method|testCreateLinkUsingPartQualPath2 ()
specifier|public
name|void
name|testCreateLinkUsingPartQualPath2
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|Path
name|fileWoScheme
init|=
operator|new
name|Path
argument_list|(
literal|"//"
operator|+
name|testURI
argument_list|()
operator|.
name|getAuthority
argument_list|()
operator|+
name|testBaseDir1
argument_list|()
operator|+
literal|"/file"
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"file"
operator|.
name|equals
argument_list|(
name|getScheme
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
name|fc
operator|.
name|createSymlink
argument_list|(
name|fileWoScheme
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileWoScheme
argument_list|,
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileWoScheme
operator|.
name|toString
argument_list|()
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|link
argument_list|)
operator|.
name|getSymlink
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|readFile
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Accessed a file with w/o scheme"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Expected
name|assertEquals
argument_list|(
literal|"No AbstractFileSystem for scheme: null"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
comment|/** Lstat and readlink on a normal file and directory */
DECL|method|testLinkStatusAndTargetWithNonLink ()
specifier|public
name|void
name|testLinkStatusAndTargetWithNonLink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|schemeAuth
init|=
operator|new
name|Path
argument_list|(
name|testURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|dirQual
init|=
operator|new
name|Path
argument_list|(
name|schemeAuth
argument_list|,
name|dir
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|fileQual
init|=
operator|new
name|Path
argument_list|(
name|schemeAuth
argument_list|,
name|file
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|file
argument_list|)
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|dir
argument_list|)
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Get link target on non-link should throw an IOException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
name|assertEquals
argument_list|(
literal|"Path "
operator|+
name|fileQual
operator|+
literal|" is not a symbolic link"
argument_list|,
name|x
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Get link target on non-link should throw an IOException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
name|assertEquals
argument_list|(
literal|"Path "
operator|+
name|dirQual
operator|+
literal|" is not a symbolic link"
argument_list|,
name|x
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
comment|/** Test create symlink to a directory */
DECL|method|testCreateLinkToDirectory ()
specifier|public
name|void
name|testCreateLinkToDirectory
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|dir1
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|isFile
argument_list|(
name|linkToDir
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|isDirectory
argument_list|(
name|linkToDir
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|linkToDir
argument_list|)
operator|.
name|isDir
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkToDir
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test create and remove a file through a symlink */
DECL|method|testCreateFileViaSymlink ()
specifier|public
name|void
name|testCreateFileViaSymlink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|Path
name|fileViaLink
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|dir
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|createAndWriteFile
argument_list|(
name|fileViaLink
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|isFile
argument_list|(
name|fileViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|isDirectory
argument_list|(
name|fileViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|fileViaLink
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|fileViaLink
argument_list|)
operator|.
name|isDir
argument_list|()
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|fileViaLink
argument_list|)
expr_stmt|;
name|fc
operator|.
name|delete
argument_list|(
name|fileViaLink
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|exists
argument_list|(
name|fileViaLink
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test make and delete directory through a symlink */
DECL|method|testCreateDirViaSymlink ()
specifier|public
name|void
name|testCreateDirViaSymlink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|subDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"subDir"
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|Path
name|subDirViaLink
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"subDir"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|dir1
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|mkdir
argument_list|(
name|subDirViaLink
argument_list|,
name|FileContext
operator|.
name|DEFAULT_PERM
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|subDirViaLink
argument_list|)
operator|.
name|isDir
argument_list|()
argument_list|)
expr_stmt|;
name|fc
operator|.
name|delete
argument_list|(
name|subDirViaLink
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|exists
argument_list|(
name|subDirViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|exists
argument_list|(
name|subDir
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Create symlink through a symlink */
DECL|method|testCreateLinkViaLink ()
specifier|public
name|void
name|testCreateLinkViaLink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|Path
name|fileViaLink
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|linkToFile
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
comment|/*      * /b2/linkToDir            -> /b1      * /b2/linkToDir/linkToFile -> /b2/linkToDir/file      */
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|dir1
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|fileViaLink
argument_list|,
name|linkToFile
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|isFile
argument_list|(
name|linkToFile
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkToFile
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|linkToFile
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileSize
argument_list|,
name|fc
operator|.
name|getFileStatus
argument_list|(
name|linkToFile
argument_list|)
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileViaLink
argument_list|,
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|linkToFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test create symlink to a directory */
DECL|method|testListStatusUsingLink ()
specifier|public
name|void
name|testListStatusUsingLink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"link"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// The size of the result is file system dependent, Hdfs is 2 (file
comment|// and link) and LocalFs is 3 (file, link, file crc).
name|FileStatus
index|[]
name|stats
init|=
name|fc
operator|.
name|util
argument_list|()
operator|.
name|listStatus
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|stats
operator|.
name|length
operator|==
literal|2
operator|||
name|stats
operator|.
name|length
operator|==
literal|3
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|FileStatus
argument_list|>
name|statsItor
init|=
name|fc
operator|.
name|listStatus
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|int
name|dirLen
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|statsItor
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|statsItor
operator|.
name|next
argument_list|()
expr_stmt|;
name|dirLen
operator|++
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|dirLen
operator|==
literal|2
operator|||
name|dirLen
operator|==
literal|3
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test create symlink using the same path */
DECL|method|testCreateLinkTwice ()
specifier|public
name|void
name|testCreateLinkTwice
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"link already exists"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
comment|// Expected
block|}
block|}
annotation|@
name|Test
comment|/** Test access via a symlink to a symlink */
DECL|method|testCreateLinkToLink ()
specifier|public
name|void
name|testCreateLinkToLink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|Path
name|linkToLink
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToLink"
argument_list|)
decl_stmt|;
name|Path
name|fileViaLink
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToLink/file"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|dir1
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|linkToDir
argument_list|,
name|linkToLink
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|isFile
argument_list|(
name|fileViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|isDirectory
argument_list|(
name|fileViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|fileViaLink
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|fileViaLink
argument_list|)
operator|.
name|isDir
argument_list|()
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|fileViaLink
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Can not create a file with path that refers to a symlink */
DECL|method|testCreateFileDirExistingLink ()
specifier|public
name|void
name|testCreateFileDirExistingLink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|createAndWriteFile
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"link already exists"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
comment|// Expected
block|}
try|try
block|{
name|fc
operator|.
name|mkdir
argument_list|(
name|link
argument_list|,
name|FsPermission
operator|.
name|getDefault
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"link already exists"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
comment|// Expected
block|}
block|}
annotation|@
name|Test
comment|/** Test deleting and recreating a symlink */
DECL|method|testUseLinkAferDeleteLink ()
specifier|public
name|void
name|testUseLinkAferDeleteLink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|delete
argument_list|(
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|readFile
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"link was deleted"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
comment|// Expected
block|}
name|readFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|link
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test create symlink to . */
DECL|method|testCreateLinkToDot ()
specifier|public
name|void
name|testCreateLinkToDot
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToDot"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|setWorkingDirectory
argument_list|(
name|dir
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|createSymlink
argument_list|(
operator|new
name|Path
argument_list|(
literal|"."
argument_list|)
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Created symlink to dot"
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToDot/file"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
comment|// Expected. Path(".") resolves to "" because URI normalizes
comment|// the dot away and AbstractFileSystem considers "" invalid.
block|}
block|}
annotation|@
name|Test
comment|/** Test create symlink to .. */
DECL|method|testCreateLinkToDotDot ()
specifier|public
name|void
name|testCreateLinkToDotDot
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"test/file"
argument_list|)
decl_stmt|;
name|Path
name|dotDot
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"test/.."
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|Path
name|fileViaLink
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"test/file"
argument_list|)
decl_stmt|;
comment|// Symlink to .. is not a problem since the .. is squashed early
name|assertEquals
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
name|dotDot
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|dotDot
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|fileViaLink
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileSize
argument_list|,
name|fc
operator|.
name|getFileStatus
argument_list|(
name|fileViaLink
argument_list|)
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test create symlink to ../foo */
DECL|method|testCreateLinkToDotDotPrefix ()
specifier|public
name|void
name|testCreateLinkToDotDotPrefix
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"test"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"test/link"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|mkdir
argument_list|(
name|dir
argument_list|,
name|FsPermission
operator|.
name|getDefault
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|setWorkingDirectory
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
operator|new
name|Path
argument_list|(
literal|"../file"
argument_list|)
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|new
name|Path
argument_list|(
literal|"../file"
argument_list|)
argument_list|,
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Append data to a file specified using a symlink */
DECL|method|testAppendFileViaSymlink ()
specifier|public
name|void
name|testAppendFileViaSymlink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileSize
argument_list|,
name|fc
operator|.
name|getFileStatus
argument_list|(
name|link
argument_list|)
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
name|appendToFile
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileSize
operator|*
literal|2
argument_list|,
name|fc
operator|.
name|getFileStatus
argument_list|(
name|link
argument_list|)
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test rename file through a symlink */
DECL|method|testRenameFileViaSymlink ()
specifier|public
name|void
name|testRenameFileViaSymlink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|Path
name|fileViaLink
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|fileNewViaLink
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"fileNew"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|dir1
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|rename
argument_list|(
name|fileViaLink
argument_list|,
name|fileNewViaLink
argument_list|,
name|Rename
operator|.
name|OVERWRITE
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|exists
argument_list|(
name|fileViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|exists
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|exists
argument_list|(
name|fileNewViaLink
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Rename a symlink */
DECL|method|testRenameSymlink ()
specifier|public
name|void
name|testRenameSymlink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|link1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile1"
argument_list|)
decl_stmt|;
name|Path
name|link2
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile2"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|rename
argument_list|(
name|link1
argument_list|,
name|link2
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|link2
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|link2
argument_list|)
operator|.
name|isDir
argument_list|()
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|link2
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
try|try
block|{
name|createAndWriteFile
argument_list|(
name|link2
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"link was not renamed"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
comment|// Expected
block|}
block|}
annotation|@
name|Test
comment|/** Test renaming symlink target */
DECL|method|testMoveLinkTarget ()
specifier|public
name|void
name|testMoveLinkTarget
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|fileNew
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"fileNew"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|rename
argument_list|(
name|file
argument_list|,
name|fileNew
argument_list|,
name|Rename
operator|.
name|OVERWRITE
argument_list|)
expr_stmt|;
try|try
block|{
name|readFile
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"link target was renamed"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
comment|// Expected
block|}
name|fc
operator|.
name|rename
argument_list|(
name|fileNew
argument_list|,
name|file
argument_list|,
name|Rename
operator|.
name|OVERWRITE
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|link
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** setTimes affects the target not the link */
DECL|method|testSetTimes ()
specifier|public
name|void
name|testSetTimes
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|long
name|at
init|=
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|link
argument_list|)
operator|.
name|getAccessTime
argument_list|()
decl_stmt|;
name|fc
operator|.
name|setTimes
argument_list|(
name|link
argument_list|,
literal|2L
argument_list|,
literal|3L
argument_list|)
expr_stmt|;
comment|// NB: local file systems don't implement setTimes
if|if
condition|(
operator|!
literal|"file"
operator|.
name|equals
argument_list|(
name|getScheme
argument_list|()
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
name|at
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|link
argument_list|)
operator|.
name|getAccessTime
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|fc
operator|.
name|getFileStatus
argument_list|(
name|file
argument_list|)
operator|.
name|getAccessTime
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|fc
operator|.
name|getFileStatus
argument_list|(
name|file
argument_list|)
operator|.
name|getModificationTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

