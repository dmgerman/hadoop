begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.contrib.failmon
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|contrib
operator|.
name|failmon
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_comment
comment|/**********************************************************  * Objects of this class parse the output of system command-line  * utilities that can give information about the state of    * various hardware components in the system. Typically, each such  * object either invokes a command and reads its output or reads the   * output of one such command from a file on the disk. Currently   * supported utilities include ifconfig, smartmontools, lm-sensors,  * /proc/cpuinfo.  *  **********************************************************/
end_comment

begin_class
DECL|class|ShellParser
specifier|public
specifier|abstract
class|class
name|ShellParser
implements|implements
name|Monitored
block|{
comment|/**    * Find the first occurence ofa pattern in a piece of text     * and return a specific group.    *     *  @param strPattern the regular expression to match    *  @param text the text to search    *  @param grp the number of the matching group to return    *      *  @return a String containing the matched group of the regular expression    */
DECL|method|findPattern (String strPattern, String text, int grp)
specifier|protected
name|String
name|findPattern
parameter_list|(
name|String
name|strPattern
parameter_list|,
name|String
name|text
parameter_list|,
name|int
name|grp
parameter_list|)
block|{
name|Pattern
name|pattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|strPattern
argument_list|,
name|Pattern
operator|.
name|MULTILINE
argument_list|)
decl_stmt|;
name|Matcher
name|matcher
init|=
name|pattern
operator|.
name|matcher
argument_list|(
name|text
argument_list|)
decl_stmt|;
if|if
condition|(
name|matcher
operator|.
name|find
argument_list|(
literal|0
argument_list|)
condition|)
return|return
name|matcher
operator|.
name|group
argument_list|(
name|grp
argument_list|)
return|;
return|return
literal|null
return|;
block|}
comment|/**    * Finds all occurences of a pattern in a piece of text and returns     * the matching groups.    *     *  @param strPattern the regular expression to match    *  @param text the text to search    *  @param grp the number of the matching group to return    *  @param separator the string that separates occurences in the returned value    *      *  @return a String that contains all occurences of strPattern in text,     *  separated by separator    */
DECL|method|findAll (String strPattern, String text, int grp, String separator)
specifier|protected
name|String
name|findAll
parameter_list|(
name|String
name|strPattern
parameter_list|,
name|String
name|text
parameter_list|,
name|int
name|grp
parameter_list|,
name|String
name|separator
parameter_list|)
block|{
name|String
name|retval
init|=
literal|""
decl_stmt|;
name|boolean
name|firstTime
init|=
literal|true
decl_stmt|;
name|Pattern
name|pattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|strPattern
argument_list|)
decl_stmt|;
name|Matcher
name|matcher
init|=
name|pattern
operator|.
name|matcher
argument_list|(
name|text
argument_list|)
decl_stmt|;
while|while
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
name|retval
operator|+=
operator|(
name|firstTime
condition|?
literal|""
else|:
name|separator
operator|)
operator|+
name|matcher
operator|.
name|group
argument_list|(
name|grp
argument_list|)
expr_stmt|;
name|firstTime
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
comment|/**    * Insert all EventRecords that can be extracted for    * the represented hardware component into a LocalStore.    *     * @param ls the LocalStore into which the EventRecords     * are to be stored.    */
DECL|method|monitor (LocalStore ls)
specifier|public
name|void
name|monitor
parameter_list|(
name|LocalStore
name|ls
parameter_list|)
block|{
name|ls
operator|.
name|insert
argument_list|(
name|monitor
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|monitor ()
specifier|abstract
specifier|public
name|EventRecord
index|[]
name|monitor
parameter_list|()
function_decl|;
DECL|method|query (String s)
specifier|abstract
specifier|public
name|EventRecord
name|query
parameter_list|(
name|String
name|s
parameter_list|)
throws|throws
name|Exception
function_decl|;
block|}
end_class

end_unit

