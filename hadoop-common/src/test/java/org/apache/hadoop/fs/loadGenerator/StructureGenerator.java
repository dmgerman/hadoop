begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.loadGenerator
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|loadGenerator
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_comment
comment|/**  * This program generates a random namespace structure with the following  * constraints:  * 1. The number of subdirectories is a random number in [minWidth, maxWidth].  * 2. The maximum depth of each subdirectory is a random number   *    [2*maxDepth/3, maxDepth].  * 3. Files are randomly placed in the empty directories. The size of each  *    file follows Gaussian distribution.  * The generated namespace structure is described by two files in the output  * directory. Each line of the first file   * contains the full name of a leaf directory.    * Each line of the second file contains  * the full name of a file and its size, separated by a blank.  *   * The synopsis of the command is  * java StructureGenerator     -maxDepth<maxDepth> : maximum depth of the directory tree; default is 5.     -minWidth<minWidth> : minimum number of subdirectories per directories; default is 1     -maxWidth<maxWidth> : maximum number of subdirectories per directories; default is 5     -numOfFiles<#OfFiles> : the total number of files; default is 10.     -avgFileSize<avgFileSizeInBlocks>: average size of blocks; default is 1.     -outDir<outDir>: output directory; default is the current directory.     -seed<seed>: random number generator seed; default is the current time.  */
end_comment

begin_class
DECL|class|StructureGenerator
specifier|public
class|class
name|StructureGenerator
block|{
DECL|field|maxDepth
specifier|private
name|int
name|maxDepth
init|=
literal|5
decl_stmt|;
DECL|field|minWidth
specifier|private
name|int
name|minWidth
init|=
literal|1
decl_stmt|;
DECL|field|maxWidth
specifier|private
name|int
name|maxWidth
init|=
literal|5
decl_stmt|;
DECL|field|numOfFiles
specifier|private
name|int
name|numOfFiles
init|=
literal|10
decl_stmt|;
DECL|field|avgFileSize
specifier|private
name|double
name|avgFileSize
init|=
literal|1
decl_stmt|;
DECL|field|outDir
specifier|private
name|File
name|outDir
init|=
name|DEFAULT_STRUCTURE_DIRECTORY
decl_stmt|;
DECL|field|USAGE
specifier|final
specifier|static
specifier|private
name|String
name|USAGE
init|=
literal|"java StructureGenerator\n"
operator|+
literal|"-maxDepth<maxDepth>\n"
operator|+
literal|"-minWidth<minWidth>\n"
operator|+
literal|"-maxWidth<maxWidth>\n"
operator|+
literal|"-numOfFiles<#OfFiles>\n"
operator|+
literal|"-avgFileSize<avgFileSizeInBlocks>\n"
operator|+
literal|"-outDir<outDir>\n"
operator|+
literal|"-seed<seed>"
decl_stmt|;
DECL|field|r
specifier|private
name|Random
name|r
init|=
literal|null
decl_stmt|;
comment|/** Default directory for storing file/directory structure */
DECL|field|DEFAULT_STRUCTURE_DIRECTORY
specifier|final
specifier|static
name|File
name|DEFAULT_STRUCTURE_DIRECTORY
init|=
operator|new
name|File
argument_list|(
literal|"."
argument_list|)
decl_stmt|;
comment|/** The name of the file for storing directory structure */
DECL|field|DIR_STRUCTURE_FILE_NAME
specifier|final
specifier|static
name|String
name|DIR_STRUCTURE_FILE_NAME
init|=
literal|"dirStructure"
decl_stmt|;
comment|/** The name of the file for storing file structure */
DECL|field|FILE_STRUCTURE_FILE_NAME
specifier|final
specifier|static
name|String
name|FILE_STRUCTURE_FILE_NAME
init|=
literal|"fileStructure"
decl_stmt|;
comment|/** The name prefix for the files created by this program */
DECL|field|FILE_NAME_PREFIX
specifier|final
specifier|static
name|String
name|FILE_NAME_PREFIX
init|=
literal|"_file_"
decl_stmt|;
comment|/**    * The main function first parses the command line arguments,    * then generates in-memory directory structure and outputs to a file,    * last generates in-memory files and outputs them to a file.    */
DECL|method|run (String[] args)
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|exitCode
init|=
literal|0
decl_stmt|;
name|exitCode
operator|=
name|init
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|exitCode
operator|!=
literal|0
condition|)
block|{
return|return
name|exitCode
return|;
block|}
name|genDirStructure
argument_list|()
expr_stmt|;
name|output
argument_list|(
operator|new
name|File
argument_list|(
name|outDir
argument_list|,
name|DIR_STRUCTURE_FILE_NAME
argument_list|)
argument_list|)
expr_stmt|;
name|genFileStructure
argument_list|()
expr_stmt|;
name|outputFiles
argument_list|(
operator|new
name|File
argument_list|(
name|outDir
argument_list|,
name|FILE_STRUCTURE_FILE_NAME
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|exitCode
return|;
block|}
comment|/** Parse the command line arguments and initialize the data */
DECL|method|init (String[] args)
specifier|private
name|int
name|init
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// parse command line
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-maxDepth"
argument_list|)
condition|)
block|{
name|maxDepth
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxDepth
operator|<
literal|1
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"maxDepth must be positive: "
operator|+
name|maxDepth
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-minWidth"
argument_list|)
condition|)
block|{
name|minWidth
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|minWidth
operator|<
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"minWidth must be positive: "
operator|+
name|minWidth
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-maxWidth"
argument_list|)
condition|)
block|{
name|maxWidth
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-numOfFiles"
argument_list|)
condition|)
block|{
name|numOfFiles
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|numOfFiles
operator|<
literal|1
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"NumOfFiles must be positive: "
operator|+
name|numOfFiles
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-avgFileSize"
argument_list|)
condition|)
block|{
name|avgFileSize
operator|=
name|Double
operator|.
name|parseDouble
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|avgFileSize
operator|<=
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"AvgFileSize must be positive: "
operator|+
name|avgFileSize
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-outDir"
argument_list|)
condition|)
block|{
name|outDir
operator|=
operator|new
name|File
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-seed"
argument_list|)
condition|)
block|{
name|r
operator|=
operator|new
name|Random
argument_list|(
name|Long
operator|.
name|parseLong
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|USAGE
argument_list|)
expr_stmt|;
name|ToolRunner
operator|.
name|printGenericCommandUsage
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Illegal parameter: "
operator|+
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|USAGE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|maxWidth
operator|<
name|minWidth
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"maxWidth must be bigger than minWidth: "
operator|+
name|maxWidth
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|r
operator|==
literal|null
condition|)
block|{
name|r
operator|=
operator|new
name|Random
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/** In memory representation of a directory */
DECL|class|INode
specifier|private
specifier|static
class|class
name|INode
block|{
DECL|field|name
specifier|private
name|String
name|name
decl_stmt|;
DECL|field|children
specifier|private
name|List
argument_list|<
name|INode
argument_list|>
name|children
init|=
operator|new
name|ArrayList
argument_list|<
name|INode
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Constructor */
DECL|method|INode (String name)
specifier|private
name|INode
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
comment|/** Add a child (subdir/file) */
DECL|method|addChild (INode child)
specifier|private
name|void
name|addChild
parameter_list|(
name|INode
name|child
parameter_list|)
block|{
name|children
operator|.
name|add
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
comment|/** Output the subtree rooted at the current node.       * Only the leaves are printed.      */
DECL|method|output (PrintStream out, String prefix)
specifier|private
name|void
name|output
parameter_list|(
name|PrintStream
name|out
parameter_list|,
name|String
name|prefix
parameter_list|)
block|{
name|prefix
operator|=
name|prefix
operator|==
literal|null
condition|?
name|name
else|:
name|prefix
operator|+
literal|"/"
operator|+
name|name
expr_stmt|;
if|if
condition|(
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|INode
name|child
range|:
name|children
control|)
block|{
name|child
operator|.
name|output
argument_list|(
name|out
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Output the files in the subtree rooted at this node */
DECL|method|outputFiles (PrintStream out, String prefix)
specifier|protected
name|void
name|outputFiles
parameter_list|(
name|PrintStream
name|out
parameter_list|,
name|String
name|prefix
parameter_list|)
block|{
name|prefix
operator|=
name|prefix
operator|==
literal|null
condition|?
name|name
else|:
name|prefix
operator|+
literal|"/"
operator|+
name|name
expr_stmt|;
for|for
control|(
name|INode
name|child
range|:
name|children
control|)
block|{
name|child
operator|.
name|outputFiles
argument_list|(
name|out
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Add all the leaves in the subtree to the input list */
DECL|method|getLeaves (List<INode> leaves)
specifier|private
name|void
name|getLeaves
parameter_list|(
name|List
argument_list|<
name|INode
argument_list|>
name|leaves
parameter_list|)
block|{
if|if
condition|(
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|leaves
operator|.
name|add
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|INode
name|child
range|:
name|children
control|)
block|{
name|child
operator|.
name|getLeaves
argument_list|(
name|leaves
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** In memory representation of a file */
DECL|class|FileINode
specifier|private
specifier|static
class|class
name|FileINode
extends|extends
name|INode
block|{
DECL|field|numOfBlocks
specifier|private
name|double
name|numOfBlocks
decl_stmt|;
comment|/** constructor */
DECL|method|FileINode (String name, double numOfBlocks)
specifier|private
name|FileINode
parameter_list|(
name|String
name|name
parameter_list|,
name|double
name|numOfBlocks
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|this
operator|.
name|numOfBlocks
operator|=
name|numOfBlocks
expr_stmt|;
block|}
comment|/** Output a file attribute */
DECL|method|outputFiles (PrintStream out, String prefix)
specifier|protected
name|void
name|outputFiles
parameter_list|(
name|PrintStream
name|out
parameter_list|,
name|String
name|prefix
parameter_list|)
block|{
name|prefix
operator|=
operator|(
name|prefix
operator|==
literal|null
operator|)
condition|?
name|super
operator|.
name|name
else|:
name|prefix
operator|+
literal|"/"
operator|+
name|super
operator|.
name|name
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
name|prefix
operator|+
literal|" "
operator|+
name|numOfBlocks
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|root
specifier|private
name|INode
name|root
decl_stmt|;
comment|/** Generates a directory tree with a max depth of<code>maxDepth</code> */
DECL|method|genDirStructure ()
specifier|private
name|void
name|genDirStructure
parameter_list|()
block|{
name|root
operator|=
name|genDirStructure
argument_list|(
literal|""
argument_list|,
name|maxDepth
argument_list|)
expr_stmt|;
block|}
comment|/** Generate a directory tree rooted at<code>rootName</code>    * The number of subtree is in the range of [minWidth, maxWidth].    * The maximum depth of each subtree is in the range of    * [2*maxDepth/3, maxDepth].    */
DECL|method|genDirStructure (String rootName, int maxDepth)
specifier|private
name|INode
name|genDirStructure
parameter_list|(
name|String
name|rootName
parameter_list|,
name|int
name|maxDepth
parameter_list|)
block|{
name|INode
name|root
init|=
operator|new
name|INode
argument_list|(
name|rootName
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxDepth
operator|>
literal|0
condition|)
block|{
name|maxDepth
operator|--
expr_stmt|;
name|int
name|minDepth
init|=
name|maxDepth
operator|*
literal|2
operator|/
literal|3
decl_stmt|;
comment|// Figure out the number of subdirectories to generate
name|int
name|numOfSubDirs
init|=
name|minWidth
operator|+
name|r
operator|.
name|nextInt
argument_list|(
name|maxWidth
operator|-
name|minWidth
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|// Expand the tree
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numOfSubDirs
condition|;
name|i
operator|++
control|)
block|{
name|int
name|childDepth
init|=
operator|(
name|maxDepth
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|r
operator|.
name|nextInt
argument_list|(
name|maxDepth
operator|-
name|minDepth
operator|+
literal|1
argument_list|)
operator|+
name|minDepth
operator|)
decl_stmt|;
name|INode
name|child
init|=
name|genDirStructure
argument_list|(
literal|"dir"
operator|+
name|i
argument_list|,
name|childDepth
argument_list|)
decl_stmt|;
name|root
operator|.
name|addChild
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|root
return|;
block|}
comment|/** Collects leaf nodes in the tree */
DECL|method|getLeaves ()
specifier|private
name|List
argument_list|<
name|INode
argument_list|>
name|getLeaves
parameter_list|()
block|{
name|List
argument_list|<
name|INode
argument_list|>
name|leaveDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|INode
argument_list|>
argument_list|()
decl_stmt|;
name|root
operator|.
name|getLeaves
argument_list|(
name|leaveDirs
argument_list|)
expr_stmt|;
return|return
name|leaveDirs
return|;
block|}
comment|/** Decides where to place all the files and its length.    * It first collects all empty directories in the tree.    * For each file, it randomly chooses an empty directory to place the file.    * The file's length is generated using Gaussian distribution.    */
DECL|method|genFileStructure ()
specifier|private
name|void
name|genFileStructure
parameter_list|()
block|{
name|List
argument_list|<
name|INode
argument_list|>
name|leaves
init|=
name|getLeaves
argument_list|()
decl_stmt|;
name|int
name|totalLeaves
init|=
name|leaves
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numOfFiles
condition|;
name|i
operator|++
control|)
block|{
name|int
name|leaveNum
init|=
name|r
operator|.
name|nextInt
argument_list|(
name|totalLeaves
argument_list|)
decl_stmt|;
name|double
name|fileSize
decl_stmt|;
do|do
block|{
name|fileSize
operator|=
name|r
operator|.
name|nextGaussian
argument_list|()
operator|+
name|avgFileSize
expr_stmt|;
block|}
do|while
condition|(
name|fileSize
operator|<
literal|0
condition|)
do|;
name|leaves
operator|.
name|get
argument_list|(
name|leaveNum
argument_list|)
operator|.
name|addChild
argument_list|(
operator|new
name|FileINode
argument_list|(
name|FILE_NAME_PREFIX
operator|+
name|i
argument_list|,
name|fileSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Output directory structure to a file, each line of the file    * contains the directory name. Only empty directory names are printed. */
DECL|method|output (File outFile)
specifier|private
name|void
name|output
parameter_list|(
name|File
name|outFile
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Printing to "
operator|+
name|outFile
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|PrintStream
name|out
init|=
operator|new
name|PrintStream
argument_list|(
name|outFile
argument_list|)
decl_stmt|;
name|root
operator|.
name|output
argument_list|(
name|out
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** Output all files' attributes to a file, each line of the output file    * contains a file name and its length. */
DECL|method|outputFiles (File outFile)
specifier|private
name|void
name|outputFiles
parameter_list|(
name|File
name|outFile
parameter_list|)
throws|throws
name|FileNotFoundException
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Printing to "
operator|+
name|outFile
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|PrintStream
name|out
init|=
operator|new
name|PrintStream
argument_list|(
name|outFile
argument_list|)
decl_stmt|;
name|root
operator|.
name|outputFiles
argument_list|(
name|out
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Main program    * @param args Command line arguments    * @throws Exception    */
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|StructureGenerator
name|sg
init|=
operator|new
name|StructureGenerator
argument_list|()
decl_stmt|;
name|System
operator|.
name|exit
argument_list|(
name|sg
operator|.
name|run
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

