begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|Status
operator|.
name|ERROR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|Status
operator|.
name|ERROR_ACCESS_TOKEN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|Status
operator|.
name|SUCCESS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Util
operator|.
name|now
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|DataNode
operator|.
name|DN_CLIENTTRACE_FORMAT
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InterruptedIOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ClosedChannelException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsProtoUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|BlockConstructionStage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|Op
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|Receiver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|Sender
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|BlockOpResponseProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|ClientReadStatusProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|OpBlockChecksumResponseProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|Status
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenSecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|FSDatasetInterface
operator|.
name|MetaDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|MD5Hash
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|SecretManager
operator|.
name|InvalidToken
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|protobuf
operator|.
name|ByteString
import|;
end_import

begin_comment
comment|/**  * Thread for processing incoming/outgoing data stream.  */
end_comment

begin_class
DECL|class|DataXceiver
class|class
name|DataXceiver
extends|extends
name|Receiver
implements|implements
name|Runnable
implements|,
name|FSConstants
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|DataNode
operator|.
name|LOG
decl_stmt|;
DECL|field|ClientTraceLog
specifier|static
specifier|final
name|Log
name|ClientTraceLog
init|=
name|DataNode
operator|.
name|ClientTraceLog
decl_stmt|;
DECL|field|s
specifier|private
specifier|final
name|Socket
name|s
decl_stmt|;
DECL|field|isLocal
specifier|private
specifier|final
name|boolean
name|isLocal
decl_stmt|;
comment|//is a local connection?
DECL|field|remoteAddress
specifier|private
specifier|final
name|String
name|remoteAddress
decl_stmt|;
comment|// address of remote side
DECL|field|localAddress
specifier|private
specifier|final
name|String
name|localAddress
decl_stmt|;
comment|// local address of this daemon
DECL|field|datanode
specifier|private
specifier|final
name|DataNode
name|datanode
decl_stmt|;
DECL|field|dataXceiverServer
specifier|private
specifier|final
name|DataXceiverServer
name|dataXceiverServer
decl_stmt|;
DECL|field|socketKeepaliveTimeout
specifier|private
name|int
name|socketKeepaliveTimeout
decl_stmt|;
DECL|field|opStartTime
specifier|private
name|long
name|opStartTime
decl_stmt|;
comment|//the start time of receiving an Op
DECL|method|DataXceiver (Socket s, DataNode datanode, DataXceiverServer dataXceiverServer)
specifier|public
name|DataXceiver
parameter_list|(
name|Socket
name|s
parameter_list|,
name|DataNode
name|datanode
parameter_list|,
name|DataXceiverServer
name|dataXceiverServer
parameter_list|)
block|{
name|this
operator|.
name|s
operator|=
name|s
expr_stmt|;
name|this
operator|.
name|isLocal
operator|=
name|s
operator|.
name|getInetAddress
argument_list|()
operator|.
name|equals
argument_list|(
name|s
operator|.
name|getLocalAddress
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
name|this
operator|.
name|dataXceiverServer
operator|=
name|dataXceiverServer
expr_stmt|;
name|dataXceiverServer
operator|.
name|childSockets
operator|.
name|put
argument_list|(
name|s
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|remoteAddress
operator|=
name|s
operator|.
name|getRemoteSocketAddress
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
name|localAddress
operator|=
name|s
operator|.
name|getLocalSocketAddress
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
name|socketKeepaliveTimeout
operator|=
name|datanode
operator|.
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_SOCKET_REUSE_KEEPALIVE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_SOCKET_REUSE_KEEPALIVE_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Number of active connections is: "
operator|+
name|datanode
operator|.
name|getXceiverCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Update the current thread's name to contain the current status.    * Use this only after this receiver has started on its thread, i.e.,    * outside the constructor.    */
DECL|method|updateCurrentThreadName (String status)
specifier|private
name|void
name|updateCurrentThreadName
parameter_list|(
name|String
name|status
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"DataXceiver for client "
argument_list|)
operator|.
name|append
argument_list|(
name|remoteAddress
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" ["
argument_list|)
operator|.
name|append
argument_list|(
name|status
argument_list|)
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
block|}
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setName
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Return the datanode object. */
DECL|method|getDataNode ()
name|DataNode
name|getDataNode
parameter_list|()
block|{
return|return
name|datanode
return|;
block|}
comment|/**    * Read/write data from/to the DataXceiveServer.    */
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|updateCurrentThreadName
argument_list|(
literal|"Waiting for operation"
argument_list|)
expr_stmt|;
name|DataInputStream
name|in
init|=
literal|null
decl_stmt|;
name|int
name|opsProcessed
init|=
literal|0
decl_stmt|;
try|try
block|{
name|in
operator|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
name|NetUtils
operator|.
name|getInputStream
argument_list|(
name|s
argument_list|)
argument_list|,
name|SMALL_BUFFER_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|stdTimeout
init|=
name|s
operator|.
name|getSoTimeout
argument_list|()
decl_stmt|;
comment|// We process requests in a loop, and stay around for a short timeout.
comment|// This optimistic behaviour allows the other end to reuse connections.
comment|// Setting keepalive timeout to 0 disable this behavior.
do|do
block|{
name|Op
name|op
decl_stmt|;
try|try
block|{
if|if
condition|(
name|opsProcessed
operator|!=
literal|0
condition|)
block|{
assert|assert
name|socketKeepaliveTimeout
operator|>
literal|0
assert|;
name|s
operator|.
name|setSoTimeout
argument_list|(
name|socketKeepaliveTimeout
argument_list|)
expr_stmt|;
block|}
name|op
operator|=
name|readOp
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedIOException
name|ignored
parameter_list|)
block|{
comment|// Time out while we wait for client rpc
break|break;
block|}
catch|catch
parameter_list|(
name|IOException
name|err
parameter_list|)
block|{
comment|// Since we optimistically expect the next op, it's quite normal to get EOF here.
if|if
condition|(
name|opsProcessed
operator|>
literal|0
operator|&&
operator|(
name|err
operator|instanceof
name|EOFException
operator|||
name|err
operator|instanceof
name|ClosedChannelException
operator|)
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Cached "
operator|+
name|s
operator|.
name|toString
argument_list|()
operator|+
literal|" closing after "
operator|+
name|opsProcessed
operator|+
literal|" ops"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
name|err
throw|;
block|}
break|break;
block|}
comment|// restore normal timeout
if|if
condition|(
name|opsProcessed
operator|!=
literal|0
condition|)
block|{
name|s
operator|.
name|setSoTimeout
argument_list|(
name|stdTimeout
argument_list|)
expr_stmt|;
block|}
comment|// Make sure the xceiver count is not exceeded
name|int
name|curXceiverCount
init|=
name|datanode
operator|.
name|getXceiverCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|curXceiverCount
operator|>
name|dataXceiverServer
operator|.
name|maxXceiverCount
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"xceiverCount "
operator|+
name|curXceiverCount
operator|+
literal|" exceeds the limit of concurrent xcievers "
operator|+
name|dataXceiverServer
operator|.
name|maxXceiverCount
argument_list|)
throw|;
block|}
name|opStartTime
operator|=
name|now
argument_list|()
expr_stmt|;
name|processOp
argument_list|(
name|op
argument_list|,
name|in
argument_list|)
expr_stmt|;
operator|++
name|opsProcessed
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|s
operator|.
name|isClosed
argument_list|()
operator|&&
name|socketKeepaliveTimeout
operator|>
literal|0
condition|)
do|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|datanode
operator|.
name|getMachineName
argument_list|()
operator|+
literal|":DataXceiver, at "
operator|+
name|s
operator|.
name|toString
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|datanode
operator|.
name|getMachineName
argument_list|()
operator|+
literal|":Number of active connections is: "
operator|+
name|datanode
operator|.
name|getXceiverCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|updateCurrentThreadName
argument_list|(
literal|"Cleaning up"
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeSocket
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|dataXceiverServer
operator|.
name|childSockets
operator|.
name|remove
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Read a block from the disk.    */
annotation|@
name|Override
DECL|method|opReadBlock (DataInputStream in, ExtendedBlock block, long startOffset, long length, String clientName, Token<BlockTokenIdentifier> blockToken)
specifier|protected
name|void
name|opReadBlock
parameter_list|(
name|DataInputStream
name|in
parameter_list|,
name|ExtendedBlock
name|block
parameter_list|,
name|long
name|startOffset
parameter_list|,
name|long
name|length
parameter_list|,
name|String
name|clientName
parameter_list|,
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|blockToken
parameter_list|)
throws|throws
name|IOException
block|{
name|OutputStream
name|baseStream
init|=
name|NetUtils
operator|.
name|getOutputStream
argument_list|(
name|s
argument_list|,
name|datanode
operator|.
name|socketWriteTimeout
argument_list|)
decl_stmt|;
name|DataOutputStream
name|out
init|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|baseStream
argument_list|,
name|SMALL_BUFFER_SIZE
argument_list|)
argument_list|)
decl_stmt|;
name|checkAccess
argument_list|(
name|out
argument_list|,
literal|true
argument_list|,
name|block
argument_list|,
name|blockToken
argument_list|,
name|Op
operator|.
name|READ_BLOCK
argument_list|,
name|BlockTokenSecretManager
operator|.
name|AccessMode
operator|.
name|READ
argument_list|)
expr_stmt|;
comment|// send the block
name|BlockSender
name|blockSender
init|=
literal|null
decl_stmt|;
name|DatanodeRegistration
name|dnR
init|=
name|datanode
operator|.
name|getDNRegistrationForBP
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|String
name|clientTraceFmt
init|=
name|clientName
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|ClientTraceLog
operator|.
name|isInfoEnabled
argument_list|()
condition|?
name|String
operator|.
name|format
argument_list|(
name|DN_CLIENTTRACE_FORMAT
argument_list|,
name|localAddress
argument_list|,
name|remoteAddress
argument_list|,
literal|"%d"
argument_list|,
literal|"HDFS_READ"
argument_list|,
name|clientName
argument_list|,
literal|"%d"
argument_list|,
name|dnR
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|block
argument_list|,
literal|"%d"
argument_list|)
else|:
name|dnR
operator|+
literal|" Served block "
operator|+
name|block
operator|+
literal|" to "
operator|+
name|s
operator|.
name|getInetAddress
argument_list|()
decl_stmt|;
name|updateCurrentThreadName
argument_list|(
literal|"Sending block "
operator|+
name|block
argument_list|)
expr_stmt|;
try|try
block|{
try|try
block|{
name|blockSender
operator|=
operator|new
name|BlockSender
argument_list|(
name|block
argument_list|,
name|startOffset
argument_list|,
name|length
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
name|datanode
argument_list|,
name|clientTraceFmt
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|sendResponse
argument_list|(
name|s
argument_list|,
name|ERROR
argument_list|,
name|datanode
operator|.
name|socketWriteTimeout
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
comment|// send op status
name|sendResponse
argument_list|(
name|s
argument_list|,
name|SUCCESS
argument_list|,
name|datanode
operator|.
name|socketWriteTimeout
argument_list|)
expr_stmt|;
name|long
name|read
init|=
name|blockSender
operator|.
name|sendBlock
argument_list|(
name|out
argument_list|,
name|baseStream
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// send data
if|if
condition|(
name|blockSender
operator|.
name|didSendEntireByteRange
argument_list|()
condition|)
block|{
comment|// If we sent the entire range, then we should expect the client
comment|// to respond with a Status enum.
try|try
block|{
name|ClientReadStatusProto
name|stat
init|=
name|ClientReadStatusProto
operator|.
name|parseFrom
argument_list|(
name|HdfsProtoUtil
operator|.
name|vintPrefixed
argument_list|(
name|in
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|stat
operator|.
name|hasStatus
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Client "
operator|+
name|s
operator|.
name|getInetAddress
argument_list|()
operator|+
literal|" did not send a valid status "
operator|+
literal|"code after reading. Will close connection."
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Error reading client status response. Will close connection."
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
name|datanode
operator|.
name|metrics
operator|.
name|incrBytesRead
argument_list|(
operator|(
name|int
operator|)
name|read
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|metrics
operator|.
name|incrBlocksRead
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SocketException
name|ignored
parameter_list|)
block|{
comment|// Its ok for remote side to close the connection anytime.
name|datanode
operator|.
name|metrics
operator|.
name|incrBlocksRead
argument_list|()
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|/* What exactly should we do here?        * Earlier version shutdown() datanode if there is disk error.        */
name|LOG
operator|.
name|warn
argument_list|(
name|dnR
operator|+
literal|":Got exception while serving "
operator|+
name|block
operator|+
literal|" to "
operator|+
name|s
operator|.
name|getInetAddress
argument_list|()
operator|+
literal|":\n"
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ioe
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|blockSender
argument_list|)
expr_stmt|;
block|}
comment|//update metrics
name|datanode
operator|.
name|metrics
operator|.
name|addReadBlockOp
argument_list|(
name|elapsed
argument_list|()
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|metrics
operator|.
name|incrReadsFromClient
argument_list|(
name|isLocal
argument_list|)
expr_stmt|;
block|}
comment|/**    * Write a block to disk.    */
annotation|@
name|Override
DECL|method|opWriteBlock (final DataInputStream in, final ExtendedBlock block, final int pipelineSize, final BlockConstructionStage stage, final long newGs, final long minBytesRcvd, final long maxBytesRcvd, final String clientname, final DatanodeInfo srcDataNode, final DatanodeInfo[] targets, final Token<BlockTokenIdentifier> blockToken )
specifier|protected
name|void
name|opWriteBlock
parameter_list|(
specifier|final
name|DataInputStream
name|in
parameter_list|,
specifier|final
name|ExtendedBlock
name|block
parameter_list|,
specifier|final
name|int
name|pipelineSize
parameter_list|,
specifier|final
name|BlockConstructionStage
name|stage
parameter_list|,
specifier|final
name|long
name|newGs
parameter_list|,
specifier|final
name|long
name|minBytesRcvd
parameter_list|,
specifier|final
name|long
name|maxBytesRcvd
parameter_list|,
specifier|final
name|String
name|clientname
parameter_list|,
specifier|final
name|DatanodeInfo
name|srcDataNode
parameter_list|,
specifier|final
name|DatanodeInfo
index|[]
name|targets
parameter_list|,
specifier|final
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|blockToken
parameter_list|)
throws|throws
name|IOException
block|{
name|updateCurrentThreadName
argument_list|(
literal|"Receiving block "
operator|+
name|block
operator|+
literal|" client="
operator|+
name|clientname
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|isDatanode
init|=
name|clientname
operator|.
name|length
argument_list|()
operator|==
literal|0
decl_stmt|;
specifier|final
name|boolean
name|isClient
init|=
operator|!
name|isDatanode
decl_stmt|;
specifier|final
name|boolean
name|isTransfer
init|=
name|stage
operator|==
name|BlockConstructionStage
operator|.
name|TRANSFER_RBW
operator|||
name|stage
operator|==
name|BlockConstructionStage
operator|.
name|TRANSFER_FINALIZED
decl_stmt|;
comment|// check single target for transfer-RBW/Finalized
if|if
condition|(
name|isTransfer
operator|&&
name|targets
operator|.
name|length
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|stage
operator|+
literal|" does not support multiple targets "
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|targets
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"opWriteBlock: stage="
operator|+
name|stage
operator|+
literal|", clientname="
operator|+
name|clientname
operator|+
literal|"\n  block  ="
operator|+
name|block
operator|+
literal|", newGs="
operator|+
name|newGs
operator|+
literal|", bytesRcvd=["
operator|+
name|minBytesRcvd
operator|+
literal|", "
operator|+
name|maxBytesRcvd
operator|+
literal|"]"
operator|+
literal|"\n  targets="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|targets
argument_list|)
operator|+
literal|"; pipelineSize="
operator|+
name|pipelineSize
operator|+
literal|", srcDataNode="
operator|+
name|srcDataNode
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"isDatanode="
operator|+
name|isDatanode
operator|+
literal|", isClient="
operator|+
name|isClient
operator|+
literal|", isTransfer="
operator|+
name|isTransfer
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"writeBlock receive buf size "
operator|+
name|s
operator|.
name|getReceiveBufferSize
argument_list|()
operator|+
literal|" tcp no delay "
operator|+
name|s
operator|.
name|getTcpNoDelay
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// We later mutate block's generation stamp and length, but we need to
comment|// forward the original version of the block to downstream mirrors, so
comment|// make a copy here.
specifier|final
name|ExtendedBlock
name|originalBlock
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|block
argument_list|)
decl_stmt|;
name|block
operator|.
name|setNumBytes
argument_list|(
name|dataXceiverServer
operator|.
name|estimateBlockSize
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Receiving block "
operator|+
name|block
operator|+
literal|" src: "
operator|+
name|remoteAddress
operator|+
literal|" dest: "
operator|+
name|localAddress
argument_list|)
expr_stmt|;
comment|// reply to upstream datanode or client
specifier|final
name|DataOutputStream
name|replyOut
init|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|NetUtils
operator|.
name|getOutputStream
argument_list|(
name|s
argument_list|,
name|datanode
operator|.
name|socketWriteTimeout
argument_list|)
argument_list|,
name|SMALL_BUFFER_SIZE
argument_list|)
argument_list|)
decl_stmt|;
name|checkAccess
argument_list|(
name|replyOut
argument_list|,
name|isClient
argument_list|,
name|block
argument_list|,
name|blockToken
argument_list|,
name|Op
operator|.
name|WRITE_BLOCK
argument_list|,
name|BlockTokenSecretManager
operator|.
name|AccessMode
operator|.
name|WRITE
argument_list|)
expr_stmt|;
name|DataOutputStream
name|mirrorOut
init|=
literal|null
decl_stmt|;
comment|// stream to next target
name|DataInputStream
name|mirrorIn
init|=
literal|null
decl_stmt|;
comment|// reply from next target
name|Socket
name|mirrorSock
init|=
literal|null
decl_stmt|;
comment|// socket to next target
name|BlockReceiver
name|blockReceiver
init|=
literal|null
decl_stmt|;
comment|// responsible for data handling
name|String
name|mirrorNode
init|=
literal|null
decl_stmt|;
comment|// the name:port of next target
name|String
name|firstBadLink
init|=
literal|""
decl_stmt|;
comment|// first datanode that failed in connection setup
name|Status
name|mirrorInStatus
init|=
name|SUCCESS
decl_stmt|;
try|try
block|{
if|if
condition|(
name|isDatanode
operator|||
name|stage
operator|!=
name|BlockConstructionStage
operator|.
name|PIPELINE_CLOSE_RECOVERY
condition|)
block|{
comment|// open a block receiver
name|blockReceiver
operator|=
operator|new
name|BlockReceiver
argument_list|(
name|block
argument_list|,
name|in
argument_list|,
name|s
operator|.
name|getRemoteSocketAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|s
operator|.
name|getLocalSocketAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|stage
argument_list|,
name|newGs
argument_list|,
name|minBytesRcvd
argument_list|,
name|maxBytesRcvd
argument_list|,
name|clientname
argument_list|,
name|srcDataNode
argument_list|,
name|datanode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|datanode
operator|.
name|data
operator|.
name|recoverClose
argument_list|(
name|block
argument_list|,
name|newGs
argument_list|,
name|minBytesRcvd
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Connect to downstream machine, if appropriate
comment|//
if|if
condition|(
name|targets
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|InetSocketAddress
name|mirrorTarget
init|=
literal|null
decl_stmt|;
comment|// Connect to backup machine
name|mirrorNode
operator|=
name|targets
index|[
literal|0
index|]
operator|.
name|getName
argument_list|()
expr_stmt|;
name|mirrorTarget
operator|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|mirrorNode
argument_list|)
expr_stmt|;
name|mirrorSock
operator|=
name|datanode
operator|.
name|newSocket
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|timeoutValue
init|=
name|datanode
operator|.
name|socketTimeout
operator|+
operator|(
name|HdfsConstants
operator|.
name|READ_TIMEOUT_EXTENSION
operator|*
name|targets
operator|.
name|length
operator|)
decl_stmt|;
name|int
name|writeTimeout
init|=
name|datanode
operator|.
name|socketWriteTimeout
operator|+
operator|(
name|HdfsConstants
operator|.
name|WRITE_TIMEOUT_EXTENSION
operator|*
name|targets
operator|.
name|length
operator|)
decl_stmt|;
name|NetUtils
operator|.
name|connect
argument_list|(
name|mirrorSock
argument_list|,
name|mirrorTarget
argument_list|,
name|timeoutValue
argument_list|)
expr_stmt|;
name|mirrorSock
operator|.
name|setSoTimeout
argument_list|(
name|timeoutValue
argument_list|)
expr_stmt|;
name|mirrorSock
operator|.
name|setSendBufferSize
argument_list|(
name|DEFAULT_DATA_SOCKET_SIZE
argument_list|)
expr_stmt|;
name|mirrorOut
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|NetUtils
operator|.
name|getOutputStream
argument_list|(
name|mirrorSock
argument_list|,
name|writeTimeout
argument_list|)
argument_list|,
name|SMALL_BUFFER_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|mirrorIn
operator|=
operator|new
name|DataInputStream
argument_list|(
name|NetUtils
operator|.
name|getInputStream
argument_list|(
name|mirrorSock
argument_list|)
argument_list|)
expr_stmt|;
name|Sender
operator|.
name|opWriteBlock
argument_list|(
name|mirrorOut
argument_list|,
name|originalBlock
argument_list|,
name|pipelineSize
argument_list|,
name|stage
argument_list|,
name|newGs
argument_list|,
name|minBytesRcvd
argument_list|,
name|maxBytesRcvd
argument_list|,
name|clientname
argument_list|,
name|srcDataNode
argument_list|,
name|targets
argument_list|,
name|blockToken
argument_list|)
expr_stmt|;
if|if
condition|(
name|blockReceiver
operator|!=
literal|null
condition|)
block|{
comment|// send checksum header
name|blockReceiver
operator|.
name|writeChecksumHeader
argument_list|(
name|mirrorOut
argument_list|)
expr_stmt|;
block|}
name|mirrorOut
operator|.
name|flush
argument_list|()
expr_stmt|;
comment|// read connect ack (only for clients, not for replication req)
if|if
condition|(
name|isClient
condition|)
block|{
name|BlockOpResponseProto
name|connectAck
init|=
name|BlockOpResponseProto
operator|.
name|parseFrom
argument_list|(
name|HdfsProtoUtil
operator|.
name|vintPrefixed
argument_list|(
name|mirrorIn
argument_list|)
argument_list|)
decl_stmt|;
name|mirrorInStatus
operator|=
name|connectAck
operator|.
name|getStatus
argument_list|()
expr_stmt|;
name|firstBadLink
operator|=
name|connectAck
operator|.
name|getFirstBadLink
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|||
name|mirrorInStatus
operator|!=
name|SUCCESS
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Datanode "
operator|+
name|targets
operator|.
name|length
operator|+
literal|" got response for connect ack "
operator|+
literal|" from downstream datanode with firstbadlink as "
operator|+
name|firstBadLink
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isClient
condition|)
block|{
name|BlockOpResponseProto
operator|.
name|newBuilder
argument_list|()
operator|.
name|setStatus
argument_list|(
name|ERROR
argument_list|)
operator|.
name|setFirstBadLink
argument_list|(
name|mirrorNode
argument_list|)
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|replyOut
argument_list|)
expr_stmt|;
name|replyOut
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|mirrorOut
argument_list|)
expr_stmt|;
name|mirrorOut
operator|=
literal|null
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|mirrorIn
argument_list|)
expr_stmt|;
name|mirrorIn
operator|=
literal|null
expr_stmt|;
name|IOUtils
operator|.
name|closeSocket
argument_list|(
name|mirrorSock
argument_list|)
expr_stmt|;
name|mirrorSock
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|isClient
condition|)
block|{
throw|throw
name|e
throw|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
name|datanode
operator|+
literal|":Exception transfering block "
operator|+
name|block
operator|+
literal|" to mirror "
operator|+
name|mirrorNode
operator|+
literal|". continuing without the mirror.\n"
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// send connect-ack to source for clients and not transfer-RBW/Finalized
if|if
condition|(
name|isClient
operator|&&
operator|!
name|isTransfer
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
operator|||
name|mirrorInStatus
operator|!=
name|SUCCESS
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Datanode "
operator|+
name|targets
operator|.
name|length
operator|+
literal|" forwarding connect ack to upstream firstbadlink is "
operator|+
name|firstBadLink
argument_list|)
expr_stmt|;
block|}
name|BlockOpResponseProto
operator|.
name|newBuilder
argument_list|()
operator|.
name|setStatus
argument_list|(
name|mirrorInStatus
argument_list|)
operator|.
name|setFirstBadLink
argument_list|(
name|firstBadLink
argument_list|)
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|replyOut
argument_list|)
expr_stmt|;
name|replyOut
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|// receive the block and mirror to the next target
if|if
condition|(
name|blockReceiver
operator|!=
literal|null
condition|)
block|{
name|String
name|mirrorAddr
init|=
operator|(
name|mirrorSock
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|mirrorNode
decl_stmt|;
name|blockReceiver
operator|.
name|receiveBlock
argument_list|(
name|mirrorOut
argument_list|,
name|mirrorIn
argument_list|,
name|replyOut
argument_list|,
name|mirrorAddr
argument_list|,
literal|null
argument_list|,
name|targets
argument_list|)
expr_stmt|;
comment|// send close-ack for transfer-RBW/Finalized
if|if
condition|(
name|isTransfer
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"TRANSFER: send close-ack"
argument_list|)
expr_stmt|;
block|}
name|writeResponse
argument_list|(
name|SUCCESS
argument_list|,
name|replyOut
argument_list|)
expr_stmt|;
block|}
block|}
comment|// update its generation stamp
if|if
condition|(
name|isClient
operator|&&
name|stage
operator|==
name|BlockConstructionStage
operator|.
name|PIPELINE_CLOSE_RECOVERY
condition|)
block|{
name|block
operator|.
name|setGenerationStamp
argument_list|(
name|newGs
argument_list|)
expr_stmt|;
name|block
operator|.
name|setNumBytes
argument_list|(
name|minBytesRcvd
argument_list|)
expr_stmt|;
block|}
comment|// if this write is for a replication request or recovering
comment|// a failed close for client, then confirm block. For other client-writes,
comment|// the block is finalized in the PacketResponder.
if|if
condition|(
name|isDatanode
operator|||
name|stage
operator|==
name|BlockConstructionStage
operator|.
name|PIPELINE_CLOSE_RECOVERY
condition|)
block|{
name|datanode
operator|.
name|closeBlock
argument_list|(
name|block
argument_list|,
name|DataNode
operator|.
name|EMPTY_DEL_HINT
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Received block "
operator|+
name|block
operator|+
literal|" src: "
operator|+
name|remoteAddress
operator|+
literal|" dest: "
operator|+
name|localAddress
operator|+
literal|" of size "
operator|+
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"writeBlock "
operator|+
name|block
operator|+
literal|" received exception "
operator|+
name|ioe
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
finally|finally
block|{
comment|// close all opened streams
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|mirrorOut
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|mirrorIn
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|replyOut
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeSocket
argument_list|(
name|mirrorSock
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|blockReceiver
argument_list|)
expr_stmt|;
block|}
comment|//update metrics
name|datanode
operator|.
name|metrics
operator|.
name|addWriteBlockOp
argument_list|(
name|elapsed
argument_list|()
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|metrics
operator|.
name|incrWritesFromClient
argument_list|(
name|isLocal
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|opTransferBlock (final DataInputStream in, final ExtendedBlock blk, final String client, final DatanodeInfo[] targets, final Token<BlockTokenIdentifier> blockToken)
specifier|protected
name|void
name|opTransferBlock
parameter_list|(
specifier|final
name|DataInputStream
name|in
parameter_list|,
specifier|final
name|ExtendedBlock
name|blk
parameter_list|,
specifier|final
name|String
name|client
parameter_list|,
specifier|final
name|DatanodeInfo
index|[]
name|targets
parameter_list|,
specifier|final
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|blockToken
parameter_list|)
throws|throws
name|IOException
block|{
name|checkAccess
argument_list|(
literal|null
argument_list|,
literal|true
argument_list|,
name|blk
argument_list|,
name|blockToken
argument_list|,
name|Op
operator|.
name|TRANSFER_BLOCK
argument_list|,
name|BlockTokenSecretManager
operator|.
name|AccessMode
operator|.
name|COPY
argument_list|)
expr_stmt|;
name|updateCurrentThreadName
argument_list|(
name|Op
operator|.
name|TRANSFER_BLOCK
operator|+
literal|" "
operator|+
name|blk
argument_list|)
expr_stmt|;
specifier|final
name|DataOutputStream
name|out
init|=
operator|new
name|DataOutputStream
argument_list|(
name|NetUtils
operator|.
name|getOutputStream
argument_list|(
name|s
argument_list|,
name|datanode
operator|.
name|socketWriteTimeout
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|datanode
operator|.
name|transferReplicaForPipelineRecovery
argument_list|(
name|blk
argument_list|,
name|targets
argument_list|,
name|client
argument_list|)
expr_stmt|;
name|writeResponse
argument_list|(
name|Status
operator|.
name|SUCCESS
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get block checksum (MD5 of CRC32).    */
annotation|@
name|Override
DECL|method|opBlockChecksum (DataInputStream in, ExtendedBlock block, Token<BlockTokenIdentifier> blockToken)
specifier|protected
name|void
name|opBlockChecksum
parameter_list|(
name|DataInputStream
name|in
parameter_list|,
name|ExtendedBlock
name|block
parameter_list|,
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|blockToken
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DataOutputStream
name|out
init|=
operator|new
name|DataOutputStream
argument_list|(
name|NetUtils
operator|.
name|getOutputStream
argument_list|(
name|s
argument_list|,
name|datanode
operator|.
name|socketWriteTimeout
argument_list|)
argument_list|)
decl_stmt|;
name|checkAccess
argument_list|(
name|out
argument_list|,
literal|true
argument_list|,
name|block
argument_list|,
name|blockToken
argument_list|,
name|Op
operator|.
name|BLOCK_CHECKSUM
argument_list|,
name|BlockTokenSecretManager
operator|.
name|AccessMode
operator|.
name|READ
argument_list|)
expr_stmt|;
name|updateCurrentThreadName
argument_list|(
literal|"Reading metadata for block "
operator|+
name|block
argument_list|)
expr_stmt|;
specifier|final
name|MetaDataInputStream
name|metadataIn
init|=
name|datanode
operator|.
name|data
operator|.
name|getMetaDataInputStream
argument_list|(
name|block
argument_list|)
decl_stmt|;
specifier|final
name|DataInputStream
name|checksumIn
init|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
name|metadataIn
argument_list|,
name|BUFFER_SIZE
argument_list|)
argument_list|)
decl_stmt|;
name|updateCurrentThreadName
argument_list|(
literal|"Getting checksum for block "
operator|+
name|block
argument_list|)
expr_stmt|;
try|try
block|{
comment|//read metadata file
specifier|final
name|BlockMetadataHeader
name|header
init|=
name|BlockMetadataHeader
operator|.
name|readHeader
argument_list|(
name|checksumIn
argument_list|)
decl_stmt|;
specifier|final
name|DataChecksum
name|checksum
init|=
name|header
operator|.
name|getChecksum
argument_list|()
decl_stmt|;
specifier|final
name|int
name|bytesPerCRC
init|=
name|checksum
operator|.
name|getBytesPerChecksum
argument_list|()
decl_stmt|;
specifier|final
name|long
name|crcPerBlock
init|=
operator|(
name|metadataIn
operator|.
name|getLength
argument_list|()
operator|-
name|BlockMetadataHeader
operator|.
name|getHeaderSize
argument_list|()
operator|)
operator|/
name|checksum
operator|.
name|getChecksumSize
argument_list|()
decl_stmt|;
comment|//compute block checksum
specifier|final
name|MD5Hash
name|md5
init|=
name|MD5Hash
operator|.
name|digest
argument_list|(
name|checksumIn
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"block="
operator|+
name|block
operator|+
literal|", bytesPerCRC="
operator|+
name|bytesPerCRC
operator|+
literal|", crcPerBlock="
operator|+
name|crcPerBlock
operator|+
literal|", md5="
operator|+
name|md5
argument_list|)
expr_stmt|;
block|}
comment|//write reply
name|BlockOpResponseProto
operator|.
name|newBuilder
argument_list|()
operator|.
name|setStatus
argument_list|(
name|SUCCESS
argument_list|)
operator|.
name|setChecksumResponse
argument_list|(
name|OpBlockChecksumResponseProto
operator|.
name|newBuilder
argument_list|()
operator|.
name|setBytesPerCrc
argument_list|(
name|bytesPerCRC
argument_list|)
operator|.
name|setCrcPerBlock
argument_list|(
name|crcPerBlock
argument_list|)
operator|.
name|setMd5
argument_list|(
name|ByteString
operator|.
name|copyFrom
argument_list|(
name|md5
operator|.
name|getDigest
argument_list|()
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|checksumIn
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|metadataIn
argument_list|)
expr_stmt|;
block|}
comment|//update metrics
name|datanode
operator|.
name|metrics
operator|.
name|addBlockChecksumOp
argument_list|(
name|elapsed
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Read a block from the disk and then sends it to a destination.    */
annotation|@
name|Override
DECL|method|opCopyBlock (DataInputStream in, ExtendedBlock block, Token<BlockTokenIdentifier> blockToken)
specifier|protected
name|void
name|opCopyBlock
parameter_list|(
name|DataInputStream
name|in
parameter_list|,
name|ExtendedBlock
name|block
parameter_list|,
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|blockToken
parameter_list|)
throws|throws
name|IOException
block|{
name|updateCurrentThreadName
argument_list|(
literal|"Copying block "
operator|+
name|block
argument_list|)
expr_stmt|;
comment|// Read in the header
if|if
condition|(
name|datanode
operator|.
name|isBlockTokenEnabled
condition|)
block|{
try|try
block|{
name|datanode
operator|.
name|blockPoolTokenSecretManager
operator|.
name|checkAccess
argument_list|(
name|blockToken
argument_list|,
literal|null
argument_list|,
name|block
argument_list|,
name|BlockTokenSecretManager
operator|.
name|AccessMode
operator|.
name|COPY
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidToken
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Invalid access token in request from "
operator|+
name|remoteAddress
operator|+
literal|" for OP_COPY_BLOCK for block "
operator|+
name|block
operator|+
literal|" : "
operator|+
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
name|sendResponse
argument_list|(
name|s
argument_list|,
name|ERROR_ACCESS_TOKEN
argument_list|,
name|datanode
operator|.
name|socketWriteTimeout
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|dataXceiverServer
operator|.
name|balanceThrottler
operator|.
name|acquire
argument_list|()
condition|)
block|{
comment|// not able to start
name|LOG
operator|.
name|info
argument_list|(
literal|"Not able to copy block "
operator|+
name|block
operator|.
name|getBlockId
argument_list|()
operator|+
literal|" to "
operator|+
name|s
operator|.
name|getRemoteSocketAddress
argument_list|()
operator|+
literal|" because threads quota is exceeded."
argument_list|)
expr_stmt|;
name|sendResponse
argument_list|(
name|s
argument_list|,
name|ERROR
argument_list|,
name|datanode
operator|.
name|socketWriteTimeout
argument_list|)
expr_stmt|;
return|return;
block|}
name|BlockSender
name|blockSender
init|=
literal|null
decl_stmt|;
name|DataOutputStream
name|reply
init|=
literal|null
decl_stmt|;
name|boolean
name|isOpSuccess
init|=
literal|true
decl_stmt|;
try|try
block|{
comment|// check if the block exists or not
name|blockSender
operator|=
operator|new
name|BlockSender
argument_list|(
name|block
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|datanode
argument_list|)
expr_stmt|;
comment|// set up response stream
name|OutputStream
name|baseStream
init|=
name|NetUtils
operator|.
name|getOutputStream
argument_list|(
name|s
argument_list|,
name|datanode
operator|.
name|socketWriteTimeout
argument_list|)
decl_stmt|;
name|reply
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|baseStream
argument_list|,
name|SMALL_BUFFER_SIZE
argument_list|)
argument_list|)
expr_stmt|;
comment|// send status first
name|writeResponse
argument_list|(
name|SUCCESS
argument_list|,
name|reply
argument_list|)
expr_stmt|;
comment|// send block content to the target
name|long
name|read
init|=
name|blockSender
operator|.
name|sendBlock
argument_list|(
name|reply
argument_list|,
name|baseStream
argument_list|,
name|dataXceiverServer
operator|.
name|balanceThrottler
argument_list|)
decl_stmt|;
name|datanode
operator|.
name|metrics
operator|.
name|incrBytesRead
argument_list|(
operator|(
name|int
operator|)
name|read
argument_list|)
expr_stmt|;
name|datanode
operator|.
name|metrics
operator|.
name|incrBlocksRead
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Copied block "
operator|+
name|block
operator|+
literal|" to "
operator|+
name|s
operator|.
name|getRemoteSocketAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|isOpSuccess
operator|=
literal|false
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
finally|finally
block|{
name|dataXceiverServer
operator|.
name|balanceThrottler
operator|.
name|release
argument_list|()
expr_stmt|;
if|if
condition|(
name|isOpSuccess
condition|)
block|{
try|try
block|{
comment|// send one last byte to indicate that the resource is cleaned.
name|reply
operator|.
name|writeChar
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ignored
parameter_list|)
block|{         }
block|}
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|blockSender
argument_list|)
expr_stmt|;
block|}
comment|//update metrics
name|datanode
operator|.
name|metrics
operator|.
name|addCopyBlockOp
argument_list|(
name|elapsed
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Receive a block and write it to disk, it then notifies the namenode to    * remove the copy from the source.    */
annotation|@
name|Override
DECL|method|opReplaceBlock (DataInputStream in, ExtendedBlock block, String sourceID, DatanodeInfo proxySource, Token<BlockTokenIdentifier> blockToken)
specifier|protected
name|void
name|opReplaceBlock
parameter_list|(
name|DataInputStream
name|in
parameter_list|,
name|ExtendedBlock
name|block
parameter_list|,
name|String
name|sourceID
parameter_list|,
name|DatanodeInfo
name|proxySource
parameter_list|,
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|blockToken
parameter_list|)
throws|throws
name|IOException
block|{
name|updateCurrentThreadName
argument_list|(
literal|"Replacing block "
operator|+
name|block
operator|+
literal|" from "
operator|+
name|sourceID
argument_list|)
expr_stmt|;
comment|/* read header */
name|block
operator|.
name|setNumBytes
argument_list|(
name|dataXceiverServer
operator|.
name|estimateBlockSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|datanode
operator|.
name|isBlockTokenEnabled
condition|)
block|{
try|try
block|{
name|datanode
operator|.
name|blockPoolTokenSecretManager
operator|.
name|checkAccess
argument_list|(
name|blockToken
argument_list|,
literal|null
argument_list|,
name|block
argument_list|,
name|BlockTokenSecretManager
operator|.
name|AccessMode
operator|.
name|REPLACE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidToken
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Invalid access token in request from "
operator|+
name|remoteAddress
operator|+
literal|" for OP_REPLACE_BLOCK for block "
operator|+
name|block
operator|+
literal|" : "
operator|+
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
name|sendResponse
argument_list|(
name|s
argument_list|,
name|ERROR_ACCESS_TOKEN
argument_list|,
name|datanode
operator|.
name|socketWriteTimeout
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|dataXceiverServer
operator|.
name|balanceThrottler
operator|.
name|acquire
argument_list|()
condition|)
block|{
comment|// not able to start
name|LOG
operator|.
name|warn
argument_list|(
literal|"Not able to receive block "
operator|+
name|block
operator|.
name|getBlockId
argument_list|()
operator|+
literal|" from "
operator|+
name|s
operator|.
name|getRemoteSocketAddress
argument_list|()
operator|+
literal|" because threads quota is exceeded."
argument_list|)
expr_stmt|;
name|sendResponse
argument_list|(
name|s
argument_list|,
name|ERROR
argument_list|,
name|datanode
operator|.
name|socketWriteTimeout
argument_list|)
expr_stmt|;
return|return;
block|}
name|Socket
name|proxySock
init|=
literal|null
decl_stmt|;
name|DataOutputStream
name|proxyOut
init|=
literal|null
decl_stmt|;
name|Status
name|opStatus
init|=
name|SUCCESS
decl_stmt|;
name|BlockReceiver
name|blockReceiver
init|=
literal|null
decl_stmt|;
name|DataInputStream
name|proxyReply
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// get the output stream to the proxy
name|InetSocketAddress
name|proxyAddr
init|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|proxySource
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|proxySock
operator|=
name|datanode
operator|.
name|newSocket
argument_list|()
expr_stmt|;
name|NetUtils
operator|.
name|connect
argument_list|(
name|proxySock
argument_list|,
name|proxyAddr
argument_list|,
name|datanode
operator|.
name|socketTimeout
argument_list|)
expr_stmt|;
name|proxySock
operator|.
name|setSoTimeout
argument_list|(
name|datanode
operator|.
name|socketTimeout
argument_list|)
expr_stmt|;
name|OutputStream
name|baseStream
init|=
name|NetUtils
operator|.
name|getOutputStream
argument_list|(
name|proxySock
argument_list|,
name|datanode
operator|.
name|socketWriteTimeout
argument_list|)
decl_stmt|;
name|proxyOut
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|baseStream
argument_list|,
name|SMALL_BUFFER_SIZE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* send request to the proxy */
name|Sender
operator|.
name|opCopyBlock
argument_list|(
name|proxyOut
argument_list|,
name|block
argument_list|,
name|blockToken
argument_list|)
expr_stmt|;
comment|// receive the response from the proxy
name|proxyReply
operator|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
name|NetUtils
operator|.
name|getInputStream
argument_list|(
name|proxySock
argument_list|)
argument_list|,
name|BUFFER_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|BlockOpResponseProto
name|copyResponse
init|=
name|BlockOpResponseProto
operator|.
name|parseFrom
argument_list|(
name|HdfsProtoUtil
operator|.
name|vintPrefixed
argument_list|(
name|proxyReply
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|copyResponse
operator|.
name|getStatus
argument_list|()
operator|!=
name|SUCCESS
condition|)
block|{
if|if
condition|(
name|copyResponse
operator|.
name|getStatus
argument_list|()
operator|==
name|ERROR_ACCESS_TOKEN
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Copy block "
operator|+
name|block
operator|+
literal|" from "
operator|+
name|proxySock
operator|.
name|getRemoteSocketAddress
argument_list|()
operator|+
literal|" failed due to access token error"
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Copy block "
operator|+
name|block
operator|+
literal|" from "
operator|+
name|proxySock
operator|.
name|getRemoteSocketAddress
argument_list|()
operator|+
literal|" failed"
argument_list|)
throw|;
block|}
comment|// open a block receiver and check if the block does not exist
name|blockReceiver
operator|=
operator|new
name|BlockReceiver
argument_list|(
name|block
argument_list|,
name|proxyReply
argument_list|,
name|proxySock
operator|.
name|getRemoteSocketAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|proxySock
operator|.
name|getLocalSocketAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|null
argument_list|,
name|datanode
argument_list|)
expr_stmt|;
comment|// receive a block
name|blockReceiver
operator|.
name|receiveBlock
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|dataXceiverServer
operator|.
name|balanceThrottler
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// notify name node
name|datanode
operator|.
name|notifyNamenodeReceivedBlock
argument_list|(
name|block
argument_list|,
name|sourceID
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Moved block "
operator|+
name|block
operator|+
literal|" from "
operator|+
name|s
operator|.
name|getRemoteSocketAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|opStatus
operator|=
name|ERROR
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
finally|finally
block|{
comment|// receive the last byte that indicates the proxy released its thread resource
if|if
condition|(
name|opStatus
operator|==
name|SUCCESS
condition|)
block|{
try|try
block|{
name|proxyReply
operator|.
name|readChar
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ignored
parameter_list|)
block|{         }
block|}
comment|// now release the thread resource
name|dataXceiverServer
operator|.
name|balanceThrottler
operator|.
name|release
argument_list|()
expr_stmt|;
comment|// send response back
try|try
block|{
name|sendResponse
argument_list|(
name|s
argument_list|,
name|opStatus
argument_list|,
name|datanode
operator|.
name|socketWriteTimeout
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error writing reply back to "
operator|+
name|s
operator|.
name|getRemoteSocketAddress
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|proxyOut
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|blockReceiver
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|proxyReply
argument_list|)
expr_stmt|;
block|}
comment|//update metrics
name|datanode
operator|.
name|metrics
operator|.
name|addReplaceBlockOp
argument_list|(
name|elapsed
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|elapsed ()
specifier|private
name|long
name|elapsed
parameter_list|()
block|{
return|return
name|now
argument_list|()
operator|-
name|opStartTime
return|;
block|}
comment|/**    * Utility function for sending a response.    * @param s socket to write to    * @param opStatus status message to write    * @param timeout send timeout    **/
DECL|method|sendResponse (Socket s, Status status, long timeout)
specifier|private
name|void
name|sendResponse
parameter_list|(
name|Socket
name|s
parameter_list|,
name|Status
name|status
parameter_list|,
name|long
name|timeout
parameter_list|)
throws|throws
name|IOException
block|{
name|DataOutputStream
name|reply
init|=
operator|new
name|DataOutputStream
argument_list|(
name|NetUtils
operator|.
name|getOutputStream
argument_list|(
name|s
argument_list|,
name|timeout
argument_list|)
argument_list|)
decl_stmt|;
name|writeResponse
argument_list|(
name|status
argument_list|,
name|reply
argument_list|)
expr_stmt|;
block|}
DECL|method|writeResponse (Status status, OutputStream out)
specifier|private
name|void
name|writeResponse
parameter_list|(
name|Status
name|status
parameter_list|,
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockOpResponseProto
name|response
init|=
name|BlockOpResponseProto
operator|.
name|newBuilder
argument_list|()
operator|.
name|setStatus
argument_list|(
name|status
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|response
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
DECL|method|checkAccess (DataOutputStream out, final boolean reply, final ExtendedBlock blk, final Token<BlockTokenIdentifier> t, final Op op, final BlockTokenSecretManager.AccessMode mode)
specifier|private
name|void
name|checkAccess
parameter_list|(
name|DataOutputStream
name|out
parameter_list|,
specifier|final
name|boolean
name|reply
parameter_list|,
specifier|final
name|ExtendedBlock
name|blk
parameter_list|,
specifier|final
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|t
parameter_list|,
specifier|final
name|Op
name|op
parameter_list|,
specifier|final
name|BlockTokenSecretManager
operator|.
name|AccessMode
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|datanode
operator|.
name|isBlockTokenEnabled
condition|)
block|{
try|try
block|{
name|datanode
operator|.
name|blockPoolTokenSecretManager
operator|.
name|checkAccess
argument_list|(
name|t
argument_list|,
literal|null
argument_list|,
name|blk
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InvalidToken
name|e
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|reply
condition|)
block|{
if|if
condition|(
name|out
operator|==
literal|null
condition|)
block|{
name|out
operator|=
operator|new
name|DataOutputStream
argument_list|(
name|NetUtils
operator|.
name|getOutputStream
argument_list|(
name|s
argument_list|,
name|datanode
operator|.
name|socketWriteTimeout
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|BlockOpResponseProto
operator|.
name|Builder
name|resp
init|=
name|BlockOpResponseProto
operator|.
name|newBuilder
argument_list|()
operator|.
name|setStatus
argument_list|(
name|ERROR_ACCESS_TOKEN
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|BlockTokenSecretManager
operator|.
name|AccessMode
operator|.
name|WRITE
condition|)
block|{
name|DatanodeRegistration
name|dnR
init|=
name|datanode
operator|.
name|getDNRegistrationForBP
argument_list|(
name|blk
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
name|resp
operator|.
name|setFirstBadLink
argument_list|(
name|dnR
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|resp
operator|.
name|build
argument_list|()
operator|.
name|writeDelimitedTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"Block token verification failed: op="
operator|+
name|op
operator|+
literal|", remoteAddress="
operator|+
name|remoteAddress
operator|+
literal|", message="
operator|+
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

