begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.balancer
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|balancer
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsProtoUtil
operator|.
name|vintPrefixed
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|DateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Formatter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configured
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSConstants
operator|.
name|DatanodeReportType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|Sender
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|BlockOpResponseProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|Status
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockPlacementPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|BlockPlacementPolicyDefault
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|UnsupportedActionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlocksWithLocations
operator|.
name|BlockWithLocations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetworkTopology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Tool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_comment
comment|/**<p>The balancer is a tool that balances disk space usage on an HDFS cluster  * when some datanodes become full or when new empty nodes join the cluster.  * The tool is deployed as an application program that can be run by the   * cluster administrator on a live HDFS cluster while applications  * adding and deleting files.  *   *<p>SYNOPSIS  *<pre>  * To start:  *      bin/start-balancer.sh [-threshold<threshold>]  *      Example: bin/ start-balancer.sh   *                     start the balancer with a default threshold of 10%  *               bin/ start-balancer.sh -threshold 5  *                     start the balancer with a threshold of 5%  * To stop:  *      bin/ stop-balancer.sh  *</pre>  *   *<p>DESCRIPTION  *<p>The threshold parameter is a fraction in the range of (0%, 100%) with a   * default value of 10%. The threshold sets a target for whether the cluster   * is balanced. A cluster is balanced if for each datanode, the utilization   * of the node (ratio of used space at the node to total capacity of the node)   * differs from the utilization of the (ratio of used space in the cluster   * to total capacity of the cluster) by no more than the threshold value.   * The smaller the threshold, the more balanced a cluster will become.   * It takes more time to run the balancer for small threshold values.   * Also for a very small threshold the cluster may not be able to reach the   * balanced state when applications write and delete files concurrently.  *   *<p>The tool moves blocks from highly utilized datanodes to poorly   * utilized datanodes iteratively. In each iteration a datanode moves or   * receives no more than the lesser of 10G bytes or the threshold fraction   * of its capacity. Each iteration runs no more than 20 minutes.  * At the end of each iteration, the balancer obtains updated datanodes  * information from the namenode.  *   *<p>A system property that limits the balancer's use of bandwidth is   * defined in the default configuration file:  *<pre>  *<property>  *<name>dfs.balance.bandwidthPerSec</name>  *<value>1048576</value>  *<description>  Specifies the maximum bandwidth that each datanode   * can utilize for the balancing purpose in term of the number of bytes   * per second.</description>  *</property>  *</pre>  *   *<p>This property determines the maximum speed at which a block will be   * moved from one datanode to another. The default value is 1MB/s. The higher   * the bandwidth, the faster a cluster can reach the balanced state,   * but with greater competition with application processes. If an   * administrator changes the value of this property in the configuration   * file, the change is observed when HDFS is next restarted.  *   *<p>MONITERING BALANCER PROGRESS  *<p>After the balancer is started, an output file name where the balancer   * progress will be recorded is printed on the screen.  The administrator   * can monitor the running of the balancer by reading the output file.   * The output shows the balancer's status iteration by iteration. In each   * iteration it prints the starting time, the iteration number, the total   * number of bytes that have been moved in the previous iterations,   * the total number of bytes that are left to move in order for the cluster   * to be balanced, and the number of bytes that are being moved in this   * iteration. Normally "Bytes Already Moved" is increasing while "Bytes Left   * To Move" is decreasing.  *   *<p>Running multiple instances of the balancer in an HDFS cluster is   * prohibited by the tool.  *   *<p>The balancer automatically exits when any of the following five   * conditions is satisfied:  *<ol>  *<li>The cluster is balanced;  *<li>No block can be moved;  *<li>No block has been moved for five consecutive iterations;  *<li>An IOException occurs while communicating with the namenode;  *<li>Another balancer is running.  *</ol>  *   *<p>Upon exit, a balancer returns an exit code and prints one of the   * following messages to the output file in corresponding to the above exit   * reasons:  *<ol>  *<li>The cluster is balanced. Exiting  *<li>No block can be moved. Exiting...  *<li>No block has been moved for 3 iterations. Exiting...  *<li>Received an IO exception: failure reason. Exiting...  *<li>Another balancer is running. Exiting...  *</ol>  *   *<p>The administrator can interrupt the execution of the balancer at any   * time by running the command "stop-balancer.sh" on the machine where the   * balancer is running.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|Balancer
specifier|public
class|class
name|Balancer
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|Balancer
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|MAX_BLOCKS_SIZE_TO_FETCH
specifier|final
specifier|private
specifier|static
name|long
name|MAX_BLOCKS_SIZE_TO_FETCH
init|=
literal|2
operator|*
literal|1024
operator|*
literal|1024
operator|*
literal|1024L
decl_stmt|;
comment|//2GB
DECL|field|WIN_WIDTH
specifier|private
specifier|static
name|long
name|WIN_WIDTH
init|=
literal|5400
operator|*
literal|1000L
decl_stmt|;
comment|// 1.5 hour
comment|/** The maximum number of concurrent blocks moves for     * balancing purpose at a datanode    */
DECL|field|MAX_NUM_CONCURRENT_MOVES
specifier|public
specifier|static
specifier|final
name|int
name|MAX_NUM_CONCURRENT_MOVES
init|=
literal|5
decl_stmt|;
DECL|field|nnc
specifier|private
specifier|final
name|NameNodeConnector
name|nnc
decl_stmt|;
DECL|field|policy
specifier|private
specifier|final
name|BalancingPolicy
name|policy
decl_stmt|;
DECL|field|threshold
specifier|private
specifier|final
name|double
name|threshold
decl_stmt|;
comment|// all data node lists
DECL|field|overUtilizedDatanodes
specifier|private
name|Collection
argument_list|<
name|Source
argument_list|>
name|overUtilizedDatanodes
init|=
operator|new
name|LinkedList
argument_list|<
name|Source
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|aboveAvgUtilizedDatanodes
specifier|private
name|Collection
argument_list|<
name|Source
argument_list|>
name|aboveAvgUtilizedDatanodes
init|=
operator|new
name|LinkedList
argument_list|<
name|Source
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|belowAvgUtilizedDatanodes
specifier|private
name|Collection
argument_list|<
name|BalancerDatanode
argument_list|>
name|belowAvgUtilizedDatanodes
init|=
operator|new
name|LinkedList
argument_list|<
name|BalancerDatanode
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|underUtilizedDatanodes
specifier|private
name|Collection
argument_list|<
name|BalancerDatanode
argument_list|>
name|underUtilizedDatanodes
init|=
operator|new
name|LinkedList
argument_list|<
name|BalancerDatanode
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|sources
specifier|private
name|Collection
argument_list|<
name|Source
argument_list|>
name|sources
init|=
operator|new
name|HashSet
argument_list|<
name|Source
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|targets
specifier|private
name|Collection
argument_list|<
name|BalancerDatanode
argument_list|>
name|targets
init|=
operator|new
name|HashSet
argument_list|<
name|BalancerDatanode
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|globalBlockList
specifier|private
name|Map
argument_list|<
name|Block
argument_list|,
name|BalancerBlock
argument_list|>
name|globalBlockList
init|=
operator|new
name|HashMap
argument_list|<
name|Block
argument_list|,
name|BalancerBlock
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|movedBlocks
specifier|private
name|MovedBlocks
name|movedBlocks
init|=
operator|new
name|MovedBlocks
argument_list|()
decl_stmt|;
DECL|field|datanodes
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|BalancerDatanode
argument_list|>
name|datanodes
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BalancerDatanode
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|cluster
specifier|private
name|NetworkTopology
name|cluster
init|=
operator|new
name|NetworkTopology
argument_list|()
decl_stmt|;
DECL|field|MOVER_THREAD_POOL_SIZE
specifier|final
specifier|static
specifier|private
name|int
name|MOVER_THREAD_POOL_SIZE
init|=
literal|1000
decl_stmt|;
DECL|field|moverExecutor
specifier|final
specifier|private
name|ExecutorService
name|moverExecutor
init|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
name|MOVER_THREAD_POOL_SIZE
argument_list|)
decl_stmt|;
DECL|field|DISPATCHER_THREAD_POOL_SIZE
specifier|final
specifier|static
specifier|private
name|int
name|DISPATCHER_THREAD_POOL_SIZE
init|=
literal|200
decl_stmt|;
DECL|field|dispatcherExecutor
specifier|final
specifier|private
name|ExecutorService
name|dispatcherExecutor
init|=
name|Executors
operator|.
name|newFixedThreadPool
argument_list|(
name|DISPATCHER_THREAD_POOL_SIZE
argument_list|)
decl_stmt|;
comment|/* This class keeps track of a scheduled block move */
DECL|class|PendingBlockMove
specifier|private
class|class
name|PendingBlockMove
block|{
DECL|field|block
specifier|private
name|BalancerBlock
name|block
decl_stmt|;
DECL|field|source
specifier|private
name|Source
name|source
decl_stmt|;
DECL|field|proxySource
specifier|private
name|BalancerDatanode
name|proxySource
decl_stmt|;
DECL|field|target
specifier|private
name|BalancerDatanode
name|target
decl_stmt|;
comment|/** constructor */
DECL|method|PendingBlockMove ()
specifier|private
name|PendingBlockMove
parameter_list|()
block|{     }
comment|/* choose a block& a proxy source for this pendingMove       * whose source& target have already been chosen.      *       * Return true if a block and its proxy are chosen; false otherwise      */
DECL|method|chooseBlockAndProxy ()
specifier|private
name|boolean
name|chooseBlockAndProxy
parameter_list|()
block|{
comment|// iterate all source's blocks until find a good one
for|for
control|(
name|Iterator
argument_list|<
name|BalancerBlock
argument_list|>
name|blocks
init|=
name|source
operator|.
name|getBlockIterator
argument_list|()
init|;
name|blocks
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|markMovedIfGoodBlock
argument_list|(
name|blocks
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|blocks
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/* Return true if the given block is good for the tentative move;      * If it is good, add it to the moved list to marked as "Moved".      * A block is good if      * 1. it is a good candidate; see isGoodBlockCandidate      * 2. can find a proxy source that's not busy for this move      */
DECL|method|markMovedIfGoodBlock (BalancerBlock block)
specifier|private
name|boolean
name|markMovedIfGoodBlock
parameter_list|(
name|BalancerBlock
name|block
parameter_list|)
block|{
synchronized|synchronized
init|(
name|block
init|)
block|{
synchronized|synchronized
init|(
name|movedBlocks
init|)
block|{
if|if
condition|(
name|isGoodBlockCandidate
argument_list|(
name|source
argument_list|,
name|target
argument_list|,
name|block
argument_list|)
condition|)
block|{
name|this
operator|.
name|block
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|chooseProxySource
argument_list|()
condition|)
block|{
name|movedBlocks
operator|.
name|add
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Decided to move block "
operator|+
name|block
operator|.
name|getBlockId
argument_list|()
operator|+
literal|" with a length of "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|)
operator|+
literal|" bytes from "
operator|+
name|source
operator|.
name|getName
argument_list|()
operator|+
literal|" to "
operator|+
name|target
operator|.
name|getName
argument_list|()
operator|+
literal|" using proxy source "
operator|+
name|proxySource
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/* Now we find out source, target, and block, we need to find a proxy      *       * @return true if a proxy is found; otherwise false      */
DECL|method|chooseProxySource ()
specifier|private
name|boolean
name|chooseProxySource
parameter_list|()
block|{
comment|// check if there is replica which is on the same rack with the target
for|for
control|(
name|BalancerDatanode
name|loc
range|:
name|block
operator|.
name|getLocations
argument_list|()
control|)
block|{
if|if
condition|(
name|cluster
operator|.
name|isOnSameRack
argument_list|(
name|loc
operator|.
name|getDatanode
argument_list|()
argument_list|,
name|target
operator|.
name|getDatanode
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|loc
operator|.
name|addPendingBlock
argument_list|(
name|this
argument_list|)
condition|)
block|{
name|proxySource
operator|=
name|loc
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
comment|// find out a non-busy replica
for|for
control|(
name|BalancerDatanode
name|loc
range|:
name|block
operator|.
name|getLocations
argument_list|()
control|)
block|{
if|if
condition|(
name|loc
operator|.
name|addPendingBlock
argument_list|(
name|this
argument_list|)
condition|)
block|{
name|proxySource
operator|=
name|loc
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/* Dispatch the block move task to the proxy source& wait for the response      */
DECL|method|dispatch ()
specifier|private
name|void
name|dispatch
parameter_list|()
block|{
name|Socket
name|sock
init|=
operator|new
name|Socket
argument_list|()
decl_stmt|;
name|DataOutputStream
name|out
init|=
literal|null
decl_stmt|;
name|DataInputStream
name|in
init|=
literal|null
decl_stmt|;
try|try
block|{
name|sock
operator|.
name|connect
argument_list|(
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|target
operator|.
name|datanode
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|HdfsConstants
operator|.
name|READ_TIMEOUT
argument_list|)
expr_stmt|;
name|sock
operator|.
name|setKeepAlive
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|out
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|sock
operator|.
name|getOutputStream
argument_list|()
argument_list|,
name|FSConstants
operator|.
name|BUFFER_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|sendRequest
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|in
operator|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
name|sock
operator|.
name|getInputStream
argument_list|()
argument_list|,
name|FSConstants
operator|.
name|BUFFER_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|receiveResponse
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|bytesMoved
operator|.
name|inc
argument_list|(
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Moving block "
operator|+
name|block
operator|.
name|getBlock
argument_list|()
operator|.
name|getBlockId
argument_list|()
operator|+
literal|" from "
operator|+
name|source
operator|.
name|getName
argument_list|()
operator|+
literal|" to "
operator|+
name|target
operator|.
name|getName
argument_list|()
operator|+
literal|" through "
operator|+
name|proxySource
operator|.
name|getName
argument_list|()
operator|+
literal|" is succeeded."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error moving block "
operator|+
name|block
operator|.
name|getBlockId
argument_list|()
operator|+
literal|" from "
operator|+
name|source
operator|.
name|getName
argument_list|()
operator|+
literal|" to "
operator|+
name|target
operator|.
name|getName
argument_list|()
operator|+
literal|" through "
operator|+
name|proxySource
operator|.
name|getName
argument_list|()
operator|+
literal|": "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeSocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|proxySource
operator|.
name|removePendingBlock
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|target
operator|.
name|removePendingBlock
argument_list|(
name|this
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|reset
argument_list|()
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|Balancer
operator|.
name|this
init|)
block|{
name|Balancer
operator|.
name|this
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/* Send a block replace request to the output stream*/
DECL|method|sendRequest (DataOutputStream out)
specifier|private
name|void
name|sendRequest
parameter_list|(
name|DataOutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ExtendedBlock
name|eb
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|nnc
operator|.
name|blockpoolID
argument_list|,
name|block
operator|.
name|getBlock
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|accessToken
init|=
name|nnc
operator|.
name|getAccessToken
argument_list|(
name|eb
argument_list|)
decl_stmt|;
operator|new
name|Sender
argument_list|(
name|out
argument_list|)
operator|.
name|replaceBlock
argument_list|(
name|eb
argument_list|,
name|accessToken
argument_list|,
name|source
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|proxySource
operator|.
name|getDatanode
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* Receive a block copy response from the input stream */
DECL|method|receiveResponse (DataInputStream in)
specifier|private
name|void
name|receiveResponse
parameter_list|(
name|DataInputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockOpResponseProto
name|response
init|=
name|BlockOpResponseProto
operator|.
name|parseFrom
argument_list|(
name|vintPrefixed
argument_list|(
name|in
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|response
operator|.
name|getStatus
argument_list|()
operator|!=
name|Status
operator|.
name|SUCCESS
condition|)
block|{
if|if
condition|(
name|response
operator|.
name|getStatus
argument_list|()
operator|==
name|Status
operator|.
name|ERROR_ACCESS_TOKEN
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"block move failed due to access token error"
argument_list|)
throw|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"block move is failed"
argument_list|)
throw|;
block|}
block|}
comment|/* reset the object */
DECL|method|reset ()
specifier|private
name|void
name|reset
parameter_list|()
block|{
name|block
operator|=
literal|null
expr_stmt|;
name|source
operator|=
literal|null
expr_stmt|;
name|proxySource
operator|=
literal|null
expr_stmt|;
name|target
operator|=
literal|null
expr_stmt|;
block|}
comment|/* start a thread to dispatch the block move */
DECL|method|scheduleBlockMove ()
specifier|private
name|void
name|scheduleBlockMove
parameter_list|()
block|{
name|moverExecutor
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Starting moving "
operator|+
name|block
operator|.
name|getBlockId
argument_list|()
operator|+
literal|" from "
operator|+
name|proxySource
operator|.
name|getName
argument_list|()
operator|+
literal|" to "
operator|+
name|target
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|dispatch
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* A class for keeping track of blocks in the Balancer */
DECL|class|BalancerBlock
specifier|static
specifier|private
class|class
name|BalancerBlock
block|{
DECL|field|block
specifier|private
name|Block
name|block
decl_stmt|;
comment|// the block
DECL|field|locations
specifier|private
name|List
argument_list|<
name|BalancerDatanode
argument_list|>
name|locations
init|=
operator|new
name|ArrayList
argument_list|<
name|BalancerDatanode
argument_list|>
argument_list|(
literal|3
argument_list|)
decl_stmt|;
comment|// its locations
comment|/* Constructor */
DECL|method|BalancerBlock (Block block)
specifier|private
name|BalancerBlock
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
name|this
operator|.
name|block
operator|=
name|block
expr_stmt|;
block|}
comment|/* clean block locations */
DECL|method|clearLocations ()
specifier|private
specifier|synchronized
name|void
name|clearLocations
parameter_list|()
block|{
name|locations
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/* add a location */
DECL|method|addLocation (BalancerDatanode datanode)
specifier|private
specifier|synchronized
name|void
name|addLocation
parameter_list|(
name|BalancerDatanode
name|datanode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|locations
operator|.
name|contains
argument_list|(
name|datanode
argument_list|)
condition|)
block|{
name|locations
operator|.
name|add
argument_list|(
name|datanode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Return if the block is located on<code>datanode</code> */
DECL|method|isLocatedOnDatanode ( BalancerDatanode datanode)
specifier|private
specifier|synchronized
name|boolean
name|isLocatedOnDatanode
parameter_list|(
name|BalancerDatanode
name|datanode
parameter_list|)
block|{
return|return
name|locations
operator|.
name|contains
argument_list|(
name|datanode
argument_list|)
return|;
block|}
comment|/* Return its locations */
DECL|method|getLocations ()
specifier|private
specifier|synchronized
name|List
argument_list|<
name|BalancerDatanode
argument_list|>
name|getLocations
parameter_list|()
block|{
return|return
name|locations
return|;
block|}
comment|/* Return the block */
DECL|method|getBlock ()
specifier|private
name|Block
name|getBlock
parameter_list|()
block|{
return|return
name|block
return|;
block|}
comment|/* Return the block id */
DECL|method|getBlockId ()
specifier|private
name|long
name|getBlockId
parameter_list|()
block|{
return|return
name|block
operator|.
name|getBlockId
argument_list|()
return|;
block|}
comment|/* Return the length of the block */
DECL|method|getNumBytes ()
specifier|private
name|long
name|getNumBytes
parameter_list|()
block|{
return|return
name|block
operator|.
name|getNumBytes
argument_list|()
return|;
block|}
block|}
comment|/* The class represents a desired move of bytes between two nodes     * and the target.    * An object of this class is stored in a source node.     */
DECL|class|NodeTask
specifier|static
specifier|private
class|class
name|NodeTask
block|{
DECL|field|datanode
specifier|private
name|BalancerDatanode
name|datanode
decl_stmt|;
comment|//target node
DECL|field|size
specifier|private
name|long
name|size
decl_stmt|;
comment|//bytes scheduled to move
comment|/* constructor */
DECL|method|NodeTask (BalancerDatanode datanode, long size)
specifier|private
name|NodeTask
parameter_list|(
name|BalancerDatanode
name|datanode
parameter_list|,
name|long
name|size
parameter_list|)
block|{
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
block|}
comment|/* Get the node */
DECL|method|getDatanode ()
specifier|private
name|BalancerDatanode
name|getDatanode
parameter_list|()
block|{
return|return
name|datanode
return|;
block|}
comment|/* Get the number of bytes that need to be moved */
DECL|method|getSize ()
specifier|private
name|long
name|getSize
parameter_list|()
block|{
return|return
name|size
return|;
block|}
block|}
comment|/* A class that keeps track of a datanode in Balancer */
DECL|class|BalancerDatanode
specifier|private
specifier|static
class|class
name|BalancerDatanode
block|{
DECL|field|MAX_SIZE_TO_MOVE
specifier|final
specifier|private
specifier|static
name|long
name|MAX_SIZE_TO_MOVE
init|=
literal|10
operator|*
literal|1024
operator|*
literal|1024
operator|*
literal|1024L
decl_stmt|;
comment|//10GB
DECL|field|datanode
specifier|final
name|DatanodeInfo
name|datanode
decl_stmt|;
DECL|field|utilization
specifier|final
name|double
name|utilization
decl_stmt|;
DECL|field|maxSize2Move
specifier|final
name|long
name|maxSize2Move
decl_stmt|;
DECL|field|scheduledSize
specifier|protected
name|long
name|scheduledSize
init|=
literal|0L
decl_stmt|;
comment|//  blocks being moved but not confirmed yet
DECL|field|pendingBlocks
specifier|private
name|List
argument_list|<
name|PendingBlockMove
argument_list|>
name|pendingBlocks
init|=
operator|new
name|ArrayList
argument_list|<
name|PendingBlockMove
argument_list|>
argument_list|(
name|MAX_NUM_CONCURRENT_MOVES
argument_list|)
decl_stmt|;
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"["
operator|+
name|getName
argument_list|()
operator|+
literal|", utilization="
operator|+
name|utilization
operator|+
literal|"]"
return|;
block|}
comment|/* Constructor       * Depending on avgutil& threshold, calculate maximum bytes to move       */
DECL|method|BalancerDatanode (DatanodeInfo node, BalancingPolicy policy, double threshold)
specifier|private
name|BalancerDatanode
parameter_list|(
name|DatanodeInfo
name|node
parameter_list|,
name|BalancingPolicy
name|policy
parameter_list|,
name|double
name|threshold
parameter_list|)
block|{
name|datanode
operator|=
name|node
expr_stmt|;
name|utilization
operator|=
name|policy
operator|.
name|getUtilization
argument_list|(
name|node
argument_list|)
expr_stmt|;
specifier|final
name|double
name|avgUtil
init|=
name|policy
operator|.
name|getAvgUtilization
argument_list|()
decl_stmt|;
name|long
name|maxSizeToMove
decl_stmt|;
if|if
condition|(
name|utilization
operator|>=
name|avgUtil
operator|+
name|threshold
operator|||
name|utilization
operator|<=
name|avgUtil
operator|-
name|threshold
condition|)
block|{
name|maxSizeToMove
operator|=
call|(
name|long
call|)
argument_list|(
name|threshold
operator|*
name|datanode
operator|.
name|getCapacity
argument_list|()
operator|/
literal|100
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|maxSizeToMove
operator|=
call|(
name|long
call|)
argument_list|(
name|Math
operator|.
name|abs
argument_list|(
name|avgUtil
operator|-
name|utilization
argument_list|)
operator|*
name|datanode
operator|.
name|getCapacity
argument_list|()
operator|/
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|utilization
operator|<
name|avgUtil
condition|)
block|{
name|maxSizeToMove
operator|=
name|Math
operator|.
name|min
argument_list|(
name|datanode
operator|.
name|getRemaining
argument_list|()
argument_list|,
name|maxSizeToMove
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|maxSize2Move
operator|=
name|Math
operator|.
name|min
argument_list|(
name|MAX_SIZE_TO_MOVE
argument_list|,
name|maxSizeToMove
argument_list|)
expr_stmt|;
block|}
comment|/** Get the datanode */
DECL|method|getDatanode ()
specifier|protected
name|DatanodeInfo
name|getDatanode
parameter_list|()
block|{
return|return
name|datanode
return|;
block|}
comment|/** Get the name of the datanode */
DECL|method|getName ()
specifier|protected
name|String
name|getName
parameter_list|()
block|{
return|return
name|datanode
operator|.
name|getName
argument_list|()
return|;
block|}
comment|/* Get the storage id of the datanode */
DECL|method|getStorageID ()
specifier|protected
name|String
name|getStorageID
parameter_list|()
block|{
return|return
name|datanode
operator|.
name|getStorageID
argument_list|()
return|;
block|}
comment|/** Decide if still need to move more bytes */
DECL|method|isMoveQuotaFull ()
specifier|protected
name|boolean
name|isMoveQuotaFull
parameter_list|()
block|{
return|return
name|scheduledSize
operator|<
name|maxSize2Move
return|;
block|}
comment|/** Return the total number of bytes that need to be moved */
DECL|method|availableSizeToMove ()
specifier|protected
name|long
name|availableSizeToMove
parameter_list|()
block|{
return|return
name|maxSize2Move
operator|-
name|scheduledSize
return|;
block|}
comment|/* increment scheduled size */
DECL|method|incScheduledSize (long size)
specifier|protected
name|void
name|incScheduledSize
parameter_list|(
name|long
name|size
parameter_list|)
block|{
name|scheduledSize
operator|+=
name|size
expr_stmt|;
block|}
comment|/* Check if the node can schedule more blocks to move */
DECL|method|isPendingQNotFull ()
specifier|synchronized
specifier|private
name|boolean
name|isPendingQNotFull
parameter_list|()
block|{
if|if
condition|(
name|pendingBlocks
operator|.
name|size
argument_list|()
operator|<
name|MAX_NUM_CONCURRENT_MOVES
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/* Check if all the dispatched moves are done */
DECL|method|isPendingQEmpty ()
specifier|synchronized
specifier|private
name|boolean
name|isPendingQEmpty
parameter_list|()
block|{
return|return
name|pendingBlocks
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/* Add a scheduled block move to the node */
DECL|method|addPendingBlock ( PendingBlockMove pendingBlock)
specifier|private
specifier|synchronized
name|boolean
name|addPendingBlock
parameter_list|(
name|PendingBlockMove
name|pendingBlock
parameter_list|)
block|{
if|if
condition|(
name|isPendingQNotFull
argument_list|()
condition|)
block|{
return|return
name|pendingBlocks
operator|.
name|add
argument_list|(
name|pendingBlock
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/* Remove a scheduled block move from the node */
DECL|method|removePendingBlock ( PendingBlockMove pendingBlock)
specifier|private
specifier|synchronized
name|boolean
name|removePendingBlock
parameter_list|(
name|PendingBlockMove
name|pendingBlock
parameter_list|)
block|{
return|return
name|pendingBlocks
operator|.
name|remove
argument_list|(
name|pendingBlock
argument_list|)
return|;
block|}
block|}
comment|/** A node that can be the sources of a block move */
DECL|class|Source
specifier|private
class|class
name|Source
extends|extends
name|BalancerDatanode
block|{
comment|/* A thread that initiates a block move       * and waits for block move to complete */
DECL|class|BlockMoveDispatcher
specifier|private
class|class
name|BlockMoveDispatcher
implements|implements
name|Runnable
block|{
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|dispatchBlocks
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|nodeTasks
specifier|private
name|ArrayList
argument_list|<
name|NodeTask
argument_list|>
name|nodeTasks
init|=
operator|new
name|ArrayList
argument_list|<
name|NodeTask
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
DECL|field|blocksToReceive
specifier|private
name|long
name|blocksToReceive
init|=
literal|0L
decl_stmt|;
comment|/* source blocks point to balancerBlocks in the global list because      * we want to keep one copy of a block in balancer and be aware that      * the locations are changing over time.      */
DECL|field|srcBlockList
specifier|private
name|List
argument_list|<
name|BalancerBlock
argument_list|>
name|srcBlockList
init|=
operator|new
name|ArrayList
argument_list|<
name|BalancerBlock
argument_list|>
argument_list|()
decl_stmt|;
comment|/* constructor */
DECL|method|Source (DatanodeInfo node, BalancingPolicy policy, double threshold)
specifier|private
name|Source
parameter_list|(
name|DatanodeInfo
name|node
parameter_list|,
name|BalancingPolicy
name|policy
parameter_list|,
name|double
name|threshold
parameter_list|)
block|{
name|super
argument_list|(
name|node
argument_list|,
name|policy
argument_list|,
name|threshold
argument_list|)
expr_stmt|;
block|}
comment|/** Add a node task */
DECL|method|addNodeTask (NodeTask task)
specifier|private
name|void
name|addNodeTask
parameter_list|(
name|NodeTask
name|task
parameter_list|)
block|{
assert|assert
operator|(
name|task
operator|.
name|datanode
operator|!=
name|this
operator|)
operator|:
literal|"Source and target are the same "
operator|+
name|datanode
operator|.
name|getName
argument_list|()
assert|;
name|incScheduledSize
argument_list|(
name|task
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
name|nodeTasks
operator|.
name|add
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
comment|/* Return an iterator to this source's blocks */
DECL|method|getBlockIterator ()
specifier|private
name|Iterator
argument_list|<
name|BalancerBlock
argument_list|>
name|getBlockIterator
parameter_list|()
block|{
return|return
name|srcBlockList
operator|.
name|iterator
argument_list|()
return|;
block|}
comment|/* fetch new blocks of this source from namenode and      * update this source's block list& the global block list      * Return the total size of the received blocks in the number of bytes.      */
DECL|method|getBlockList ()
specifier|private
name|long
name|getBlockList
parameter_list|()
throws|throws
name|IOException
block|{
name|BlockWithLocations
index|[]
name|newBlocks
init|=
name|nnc
operator|.
name|namenode
operator|.
name|getBlocks
argument_list|(
name|datanode
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|MAX_BLOCKS_SIZE_TO_FETCH
argument_list|,
name|blocksToReceive
argument_list|)
argument_list|)
operator|.
name|getBlocks
argument_list|()
decl_stmt|;
name|long
name|bytesReceived
init|=
literal|0
decl_stmt|;
for|for
control|(
name|BlockWithLocations
name|blk
range|:
name|newBlocks
control|)
block|{
name|bytesReceived
operator|+=
name|blk
operator|.
name|getBlock
argument_list|()
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
name|BalancerBlock
name|block
decl_stmt|;
synchronized|synchronized
init|(
name|globalBlockList
init|)
block|{
name|block
operator|=
name|globalBlockList
operator|.
name|get
argument_list|(
name|blk
operator|.
name|getBlock
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|==
literal|null
condition|)
block|{
name|block
operator|=
operator|new
name|BalancerBlock
argument_list|(
name|blk
operator|.
name|getBlock
argument_list|()
argument_list|)
expr_stmt|;
name|globalBlockList
operator|.
name|put
argument_list|(
name|blk
operator|.
name|getBlock
argument_list|()
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|block
operator|.
name|clearLocations
argument_list|()
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|block
init|)
block|{
comment|// update locations
for|for
control|(
name|String
name|location
range|:
name|blk
operator|.
name|getDatanodes
argument_list|()
control|)
block|{
name|BalancerDatanode
name|datanode
init|=
name|datanodes
operator|.
name|get
argument_list|(
name|location
argument_list|)
decl_stmt|;
if|if
condition|(
name|datanode
operator|!=
literal|null
condition|)
block|{
comment|// not an unknown datanode
name|block
operator|.
name|addLocation
argument_list|(
name|datanode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|srcBlockList
operator|.
name|contains
argument_list|(
name|block
argument_list|)
operator|&&
name|isGoodBlockCandidate
argument_list|(
name|block
argument_list|)
condition|)
block|{
comment|// filter bad candidates
name|srcBlockList
operator|.
name|add
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|bytesReceived
return|;
block|}
comment|/* Decide if the given block is a good candidate to move or not */
DECL|method|isGoodBlockCandidate (BalancerBlock block)
specifier|private
name|boolean
name|isGoodBlockCandidate
parameter_list|(
name|BalancerBlock
name|block
parameter_list|)
block|{
for|for
control|(
name|NodeTask
name|nodeTask
range|:
name|nodeTasks
control|)
block|{
if|if
condition|(
name|Balancer
operator|.
name|this
operator|.
name|isGoodBlockCandidate
argument_list|(
name|this
argument_list|,
name|nodeTask
operator|.
name|datanode
argument_list|,
name|block
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/* Return a block that's good for the source thread to dispatch immediately      * The block's source, target, and proxy source are determined too.      * When choosing proxy and target, source& target throttling      * has been considered. They are chosen only when they have the capacity      * to support this block move.      * The block should be dispatched immediately after this method is returned.      */
DECL|method|chooseNextBlockToMove ()
specifier|private
name|PendingBlockMove
name|chooseNextBlockToMove
parameter_list|()
block|{
for|for
control|(
name|Iterator
argument_list|<
name|NodeTask
argument_list|>
name|tasks
init|=
name|nodeTasks
operator|.
name|iterator
argument_list|()
init|;
name|tasks
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|NodeTask
name|task
init|=
name|tasks
operator|.
name|next
argument_list|()
decl_stmt|;
name|BalancerDatanode
name|target
init|=
name|task
operator|.
name|getDatanode
argument_list|()
decl_stmt|;
name|PendingBlockMove
name|pendingBlock
init|=
operator|new
name|PendingBlockMove
argument_list|()
decl_stmt|;
if|if
condition|(
name|target
operator|.
name|addPendingBlock
argument_list|(
name|pendingBlock
argument_list|)
condition|)
block|{
comment|// target is not busy, so do a tentative block allocation
name|pendingBlock
operator|.
name|source
operator|=
name|this
expr_stmt|;
name|pendingBlock
operator|.
name|target
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|pendingBlock
operator|.
name|chooseBlockAndProxy
argument_list|()
condition|)
block|{
name|long
name|blockSize
init|=
name|pendingBlock
operator|.
name|block
operator|.
name|getNumBytes
argument_list|()
decl_stmt|;
name|scheduledSize
operator|-=
name|blockSize
expr_stmt|;
name|task
operator|.
name|size
operator|-=
name|blockSize
expr_stmt|;
if|if
condition|(
name|task
operator|.
name|size
operator|==
literal|0
condition|)
block|{
name|tasks
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
return|return
name|pendingBlock
return|;
block|}
else|else
block|{
comment|// cancel the tentative move
name|target
operator|.
name|removePendingBlock
argument_list|(
name|pendingBlock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/* iterate all source's blocks to remove moved ones */
DECL|method|filterMovedBlocks ()
specifier|private
name|void
name|filterMovedBlocks
parameter_list|()
block|{
for|for
control|(
name|Iterator
argument_list|<
name|BalancerBlock
argument_list|>
name|blocks
init|=
name|getBlockIterator
argument_list|()
init|;
name|blocks
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|movedBlocks
operator|.
name|contains
argument_list|(
name|blocks
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|blocks
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|field|SOURCE_BLOCK_LIST_MIN_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|SOURCE_BLOCK_LIST_MIN_SIZE
init|=
literal|5
decl_stmt|;
comment|/* Return if should fetch more blocks from namenode */
DECL|method|shouldFetchMoreBlocks ()
specifier|private
name|boolean
name|shouldFetchMoreBlocks
parameter_list|()
block|{
return|return
name|srcBlockList
operator|.
name|size
argument_list|()
operator|<
name|SOURCE_BLOCK_LIST_MIN_SIZE
operator|&&
name|blocksToReceive
operator|>
literal|0
return|;
block|}
comment|/* This method iteratively does the following:      * it first selects a block to move,      * then sends a request to the proxy source to start the block move      * when the source's block list falls below a threshold, it asks      * the namenode for more blocks.      * It terminates when it has dispatch enough block move tasks or      * it has received enough blocks from the namenode, or       * the elapsed time of the iteration has exceeded the max time limit.      */
DECL|field|MAX_ITERATION_TIME
specifier|private
specifier|static
specifier|final
name|long
name|MAX_ITERATION_TIME
init|=
literal|20
operator|*
literal|60
operator|*
literal|1000L
decl_stmt|;
comment|//20 mins
DECL|method|dispatchBlocks ()
specifier|private
name|void
name|dispatchBlocks
parameter_list|()
block|{
name|long
name|startTime
init|=
name|Util
operator|.
name|now
argument_list|()
decl_stmt|;
name|this
operator|.
name|blocksToReceive
operator|=
literal|2
operator|*
name|scheduledSize
expr_stmt|;
name|boolean
name|isTimeUp
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|isTimeUp
operator|&&
name|scheduledSize
operator|>
literal|0
operator|&&
operator|(
operator|!
name|srcBlockList
operator|.
name|isEmpty
argument_list|()
operator|||
name|blocksToReceive
operator|>
literal|0
operator|)
condition|)
block|{
name|PendingBlockMove
name|pendingBlock
init|=
name|chooseNextBlockToMove
argument_list|()
decl_stmt|;
if|if
condition|(
name|pendingBlock
operator|!=
literal|null
condition|)
block|{
comment|// move the block
name|pendingBlock
operator|.
name|scheduleBlockMove
argument_list|()
expr_stmt|;
continue|continue;
block|}
comment|/* Since we can not schedule any block to move,          * filter any moved blocks from the source block list and          * check if we should fetch more blocks from the namenode          */
name|filterMovedBlocks
argument_list|()
expr_stmt|;
comment|// filter already moved blocks
if|if
condition|(
name|shouldFetchMoreBlocks
argument_list|()
condition|)
block|{
comment|// fetch new blocks
try|try
block|{
name|blocksToReceive
operator|-=
name|getBlockList
argument_list|()
expr_stmt|;
continue|continue;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while getting block list"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// check if time is up or not
if|if
condition|(
name|Util
operator|.
name|now
argument_list|()
operator|-
name|startTime
operator|>
name|MAX_ITERATION_TIME
condition|)
block|{
name|isTimeUp
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
comment|/* Now we can not schedule any block to move and there are          * no new blocks added to the source block list, so we wait.           */
try|try
block|{
synchronized|synchronized
init|(
name|Balancer
operator|.
name|this
init|)
block|{
name|Balancer
operator|.
name|this
operator|.
name|wait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|// wait for targets/sources to be idle
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{         }
block|}
block|}
block|}
comment|/* Check that this Balancer is compatible with the Block Placement Policy    * used by the Namenode.    */
DECL|method|checkReplicationPolicyCompatibility (Configuration conf )
specifier|private
specifier|static
name|void
name|checkReplicationPolicyCompatibility
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|UnsupportedActionException
block|{
if|if
condition|(
name|BlockPlacementPolicy
operator|.
name|getInstance
argument_list|(
name|conf
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
operator|.
name|getClass
argument_list|()
operator|!=
name|BlockPlacementPolicyDefault
operator|.
name|class
condition|)
block|{
throw|throw
operator|new
name|UnsupportedActionException
argument_list|(
literal|"Balancer without BlockPlacementPolicyDefault"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Construct a balancer.    * Initialize balancer. It sets the value of the threshold, and     * builds the communication proxies to    * namenode as a client and a secondary namenode and retry proxies    * when connection fails.    */
DECL|method|Balancer (NameNodeConnector theblockpool, Parameters p, Configuration conf)
name|Balancer
parameter_list|(
name|NameNodeConnector
name|theblockpool
parameter_list|,
name|Parameters
name|p
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|threshold
operator|=
name|p
operator|.
name|threshold
expr_stmt|;
name|this
operator|.
name|policy
operator|=
name|p
operator|.
name|policy
expr_stmt|;
name|this
operator|.
name|nnc
operator|=
name|theblockpool
expr_stmt|;
block|}
comment|/* Shuffle datanode array */
DECL|method|shuffleArray (DatanodeInfo[] datanodes)
specifier|static
specifier|private
name|void
name|shuffleArray
parameter_list|(
name|DatanodeInfo
index|[]
name|datanodes
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|datanodes
operator|.
name|length
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|--
control|)
block|{
name|int
name|randomIndex
init|=
name|DFSUtil
operator|.
name|getRandom
argument_list|()
operator|.
name|nextInt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|DatanodeInfo
name|tmp
init|=
name|datanodes
index|[
name|randomIndex
index|]
decl_stmt|;
name|datanodes
index|[
name|randomIndex
index|]
operator|=
name|datanodes
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|datanodes
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
comment|/* Given a data node set, build a network topology and decide    * over-utilized datanodes, above average utilized datanodes,     * below average utilized datanodes, and underutilized datanodes.     * The input data node set is shuffled before the datanodes     * are put into the over-utilized datanodes, above average utilized    * datanodes, below average utilized datanodes, and    * underutilized datanodes lists. This will add some randomness    * to the node matching later on.    *     * @return the total number of bytes that are     *                needed to move to make the cluster balanced.    * @param datanodes a set of datanodes    */
DECL|method|initNodes (DatanodeInfo[] datanodes)
specifier|private
name|long
name|initNodes
parameter_list|(
name|DatanodeInfo
index|[]
name|datanodes
parameter_list|)
block|{
comment|// compute average utilization
for|for
control|(
name|DatanodeInfo
name|datanode
range|:
name|datanodes
control|)
block|{
if|if
condition|(
name|datanode
operator|.
name|isDecommissioned
argument_list|()
operator|||
name|datanode
operator|.
name|isDecommissionInProgress
argument_list|()
condition|)
block|{
continue|continue;
comment|// ignore decommissioning or decommissioned nodes
block|}
name|policy
operator|.
name|accumulateSpaces
argument_list|(
name|datanode
argument_list|)
expr_stmt|;
block|}
name|policy
operator|.
name|initAvgUtilization
argument_list|()
expr_stmt|;
comment|/*create network topology and all data node lists:       * overloaded, above-average, below-average, and underloaded      * we alternates the accessing of the given datanodes array either by      * an increasing order or a decreasing order.      */
name|long
name|overLoadedBytes
init|=
literal|0L
decl_stmt|,
name|underLoadedBytes
init|=
literal|0L
decl_stmt|;
name|shuffleArray
argument_list|(
name|datanodes
argument_list|)
expr_stmt|;
for|for
control|(
name|DatanodeInfo
name|datanode
range|:
name|datanodes
control|)
block|{
if|if
condition|(
name|datanode
operator|.
name|isDecommissioned
argument_list|()
operator|||
name|datanode
operator|.
name|isDecommissionInProgress
argument_list|()
condition|)
block|{
continue|continue;
comment|// ignore decommissioning or decommissioned nodes
block|}
name|cluster
operator|.
name|add
argument_list|(
name|datanode
argument_list|)
expr_stmt|;
name|BalancerDatanode
name|datanodeS
decl_stmt|;
specifier|final
name|double
name|avg
init|=
name|policy
operator|.
name|getAvgUtilization
argument_list|()
decl_stmt|;
if|if
condition|(
name|policy
operator|.
name|getUtilization
argument_list|(
name|datanode
argument_list|)
operator|>
name|avg
condition|)
block|{
name|datanodeS
operator|=
operator|new
name|Source
argument_list|(
name|datanode
argument_list|,
name|policy
argument_list|,
name|threshold
argument_list|)
expr_stmt|;
if|if
condition|(
name|isAboveAvgUtilized
argument_list|(
name|datanodeS
argument_list|)
condition|)
block|{
name|this
operator|.
name|aboveAvgUtilizedDatanodes
operator|.
name|add
argument_list|(
operator|(
name|Source
operator|)
name|datanodeS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
operator|(
name|isOverUtilized
argument_list|(
name|datanodeS
argument_list|)
operator|)
operator|:
name|datanodeS
operator|.
name|getName
argument_list|()
operator|+
literal|"is not an overUtilized node"
assert|;
name|this
operator|.
name|overUtilizedDatanodes
operator|.
name|add
argument_list|(
operator|(
name|Source
operator|)
name|datanodeS
argument_list|)
expr_stmt|;
name|overLoadedBytes
operator|+=
call|(
name|long
call|)
argument_list|(
operator|(
name|datanodeS
operator|.
name|utilization
operator|-
name|avg
operator|-
name|threshold
operator|)
operator|*
name|datanodeS
operator|.
name|datanode
operator|.
name|getCapacity
argument_list|()
operator|/
literal|100.0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|datanodeS
operator|=
operator|new
name|BalancerDatanode
argument_list|(
name|datanode
argument_list|,
name|policy
argument_list|,
name|threshold
argument_list|)
expr_stmt|;
if|if
condition|(
name|isBelowOrEqualAvgUtilized
argument_list|(
name|datanodeS
argument_list|)
condition|)
block|{
name|this
operator|.
name|belowAvgUtilizedDatanodes
operator|.
name|add
argument_list|(
name|datanodeS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|isUnderUtilized
argument_list|(
name|datanodeS
argument_list|)
operator|:
literal|"isUnderUtilized("
operator|+
name|datanodeS
operator|.
name|getName
argument_list|()
operator|+
literal|")="
operator|+
name|isUnderUtilized
argument_list|(
name|datanodeS
argument_list|)
operator|+
literal|", utilization="
operator|+
name|datanodeS
operator|.
name|utilization
assert|;
name|this
operator|.
name|underUtilizedDatanodes
operator|.
name|add
argument_list|(
name|datanodeS
argument_list|)
expr_stmt|;
name|underLoadedBytes
operator|+=
call|(
name|long
call|)
argument_list|(
operator|(
name|avg
operator|-
name|threshold
operator|-
name|datanodeS
operator|.
name|utilization
operator|)
operator|*
name|datanodeS
operator|.
name|datanode
operator|.
name|getCapacity
argument_list|()
operator|/
literal|100.0
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|datanodes
operator|.
name|put
argument_list|(
name|datanode
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|datanodeS
argument_list|)
expr_stmt|;
block|}
comment|//logging
name|logNodes
argument_list|()
expr_stmt|;
assert|assert
operator|(
name|this
operator|.
name|datanodes
operator|.
name|size
argument_list|()
operator|==
name|overUtilizedDatanodes
operator|.
name|size
argument_list|()
operator|+
name|underUtilizedDatanodes
operator|.
name|size
argument_list|()
operator|+
name|aboveAvgUtilizedDatanodes
operator|.
name|size
argument_list|()
operator|+
name|belowAvgUtilizedDatanodes
operator|.
name|size
argument_list|()
operator|)
operator|:
literal|"Mismatched number of datanodes"
assert|;
comment|// return number of bytes to be moved in order to make the cluster balanced
return|return
name|Math
operator|.
name|max
argument_list|(
name|overLoadedBytes
argument_list|,
name|underLoadedBytes
argument_list|)
return|;
block|}
comment|/* log the over utilized& under utilized nodes */
DECL|method|logNodes ()
specifier|private
name|void
name|logNodes
parameter_list|()
block|{
name|logNodes
argument_list|(
literal|"over-utilized"
argument_list|,
name|overUtilizedDatanodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logNodes
argument_list|(
literal|"above-average"
argument_list|,
name|aboveAvgUtilizedDatanodes
argument_list|)
expr_stmt|;
name|logNodes
argument_list|(
literal|"below-average"
argument_list|,
name|belowAvgUtilizedDatanodes
argument_list|)
expr_stmt|;
block|}
name|logNodes
argument_list|(
literal|"underutilized"
argument_list|,
name|underUtilizedDatanodes
argument_list|)
expr_stmt|;
block|}
DECL|method|logNodes ( String name, Collection<T> nodes)
specifier|private
specifier|static
parameter_list|<
name|T
extends|extends
name|BalancerDatanode
parameter_list|>
name|void
name|logNodes
parameter_list|(
name|String
name|name
parameter_list|,
name|Collection
argument_list|<
name|T
argument_list|>
name|nodes
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|nodes
operator|.
name|size
argument_list|()
operator|+
literal|" "
operator|+
name|name
operator|+
literal|": "
operator|+
name|nodes
argument_list|)
expr_stmt|;
block|}
comment|/* Decide all<source, target> pairs and    * the number of bytes to move from a source to a target    * Maximum bytes to be moved per node is    * Min(1 Band worth of bytes,  MAX_SIZE_TO_MOVE).    * Return total number of bytes to move in this iteration    */
DECL|method|chooseNodes ()
specifier|private
name|long
name|chooseNodes
parameter_list|()
block|{
comment|// Match nodes on the same rack first
name|chooseNodes
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// Then match nodes on different racks
name|chooseNodes
argument_list|(
literal|false
argument_list|)
expr_stmt|;
assert|assert
operator|(
name|datanodes
operator|.
name|size
argument_list|()
operator|>=
name|sources
operator|.
name|size
argument_list|()
operator|+
name|targets
operator|.
name|size
argument_list|()
operator|)
operator|:
literal|"Mismatched number of datanodes ("
operator|+
name|datanodes
operator|.
name|size
argument_list|()
operator|+
literal|" total, "
operator|+
name|sources
operator|.
name|size
argument_list|()
operator|+
literal|" sources, "
operator|+
name|targets
operator|.
name|size
argument_list|()
operator|+
literal|" targets)"
assert|;
name|long
name|bytesToMove
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|Source
name|src
range|:
name|sources
control|)
block|{
name|bytesToMove
operator|+=
name|src
operator|.
name|scheduledSize
expr_stmt|;
block|}
return|return
name|bytesToMove
return|;
block|}
comment|/* if onRack is true, decide all<source, target> pairs    * where source and target are on the same rack; Otherwise    * decide all<source, target> pairs where source and target are    * on different racks    */
DECL|method|chooseNodes (boolean onRack)
specifier|private
name|void
name|chooseNodes
parameter_list|(
name|boolean
name|onRack
parameter_list|)
block|{
comment|/* first step: match each overUtilized datanode (source) to      * one or more underUtilized datanodes (targets).      */
name|chooseTargets
argument_list|(
name|underUtilizedDatanodes
operator|.
name|iterator
argument_list|()
argument_list|,
name|onRack
argument_list|)
expr_stmt|;
comment|/* match each remaining overutilized datanode (source) to       * below average utilized datanodes (targets).      * Note only overutilized datanodes that haven't had that max bytes to move      * satisfied in step 1 are selected      */
name|chooseTargets
argument_list|(
name|belowAvgUtilizedDatanodes
operator|.
name|iterator
argument_list|()
argument_list|,
name|onRack
argument_list|)
expr_stmt|;
comment|/* match each remaining underutilized datanode to       * above average utilized datanodes.      * Note only underutilized datanodes that have not had that max bytes to      * move satisfied in step 1 are selected.      */
name|chooseSources
argument_list|(
name|aboveAvgUtilizedDatanodes
operator|.
name|iterator
argument_list|()
argument_list|,
name|onRack
argument_list|)
expr_stmt|;
block|}
comment|/* choose targets from the target candidate list for each over utilized    * source datanode. OnRackTarget determines if the chosen target     * should be on the same rack as the source    */
DECL|method|chooseTargets ( Iterator<BalancerDatanode> targetCandidates, boolean onRackTarget )
specifier|private
name|void
name|chooseTargets
parameter_list|(
name|Iterator
argument_list|<
name|BalancerDatanode
argument_list|>
name|targetCandidates
parameter_list|,
name|boolean
name|onRackTarget
parameter_list|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Source
argument_list|>
name|srcIterator
init|=
name|overUtilizedDatanodes
operator|.
name|iterator
argument_list|()
init|;
name|srcIterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Source
name|source
init|=
name|srcIterator
operator|.
name|next
argument_list|()
decl_stmt|;
while|while
condition|(
name|chooseTarget
argument_list|(
name|source
argument_list|,
name|targetCandidates
argument_list|,
name|onRackTarget
argument_list|)
condition|)
block|{       }
if|if
condition|(
operator|!
name|source
operator|.
name|isMoveQuotaFull
argument_list|()
condition|)
block|{
name|srcIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/* choose sources from the source candidate list for each under utilized    * target datanode. onRackSource determines if the chosen source     * should be on the same rack as the target    */
DECL|method|chooseSources ( Iterator<Source> sourceCandidates, boolean onRackSource)
specifier|private
name|void
name|chooseSources
parameter_list|(
name|Iterator
argument_list|<
name|Source
argument_list|>
name|sourceCandidates
parameter_list|,
name|boolean
name|onRackSource
parameter_list|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|BalancerDatanode
argument_list|>
name|targetIterator
init|=
name|underUtilizedDatanodes
operator|.
name|iterator
argument_list|()
init|;
name|targetIterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|BalancerDatanode
name|target
init|=
name|targetIterator
operator|.
name|next
argument_list|()
decl_stmt|;
while|while
condition|(
name|chooseSource
argument_list|(
name|target
argument_list|,
name|sourceCandidates
argument_list|,
name|onRackSource
argument_list|)
condition|)
block|{       }
if|if
condition|(
operator|!
name|target
operator|.
name|isMoveQuotaFull
argument_list|()
condition|)
block|{
name|targetIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/* For the given source, choose targets from the target candidate list.    * OnRackTarget determines if the chosen target     * should be on the same rack as the source    */
DECL|method|chooseTarget (Source source, Iterator<BalancerDatanode> targetCandidates, boolean onRackTarget)
specifier|private
name|boolean
name|chooseTarget
parameter_list|(
name|Source
name|source
parameter_list|,
name|Iterator
argument_list|<
name|BalancerDatanode
argument_list|>
name|targetCandidates
parameter_list|,
name|boolean
name|onRackTarget
parameter_list|)
block|{
if|if
condition|(
operator|!
name|source
operator|.
name|isMoveQuotaFull
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|foundTarget
init|=
literal|false
decl_stmt|;
name|BalancerDatanode
name|target
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|!
name|foundTarget
operator|&&
name|targetCandidates
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|target
operator|=
name|targetCandidates
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|.
name|isMoveQuotaFull
argument_list|()
condition|)
block|{
name|targetCandidates
operator|.
name|remove
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|onRackTarget
condition|)
block|{
comment|// choose from on-rack nodes
if|if
condition|(
name|cluster
operator|.
name|isOnSameRack
argument_list|(
name|source
operator|.
name|datanode
argument_list|,
name|target
operator|.
name|datanode
argument_list|)
condition|)
block|{
name|foundTarget
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// choose from off-rack nodes
if|if
condition|(
operator|!
name|cluster
operator|.
name|isOnSameRack
argument_list|(
name|source
operator|.
name|datanode
argument_list|,
name|target
operator|.
name|datanode
argument_list|)
condition|)
block|{
name|foundTarget
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|foundTarget
condition|)
block|{
assert|assert
operator|(
name|target
operator|!=
literal|null
operator|)
operator|:
literal|"Choose a null target"
assert|;
name|long
name|size
init|=
name|Math
operator|.
name|min
argument_list|(
name|source
operator|.
name|availableSizeToMove
argument_list|()
argument_list|,
name|target
operator|.
name|availableSizeToMove
argument_list|()
argument_list|)
decl_stmt|;
name|NodeTask
name|nodeTask
init|=
operator|new
name|NodeTask
argument_list|(
name|target
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|source
operator|.
name|addNodeTask
argument_list|(
name|nodeTask
argument_list|)
expr_stmt|;
name|target
operator|.
name|incScheduledSize
argument_list|(
name|nodeTask
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
name|sources
operator|.
name|add
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|targets
operator|.
name|add
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|.
name|isMoveQuotaFull
argument_list|()
condition|)
block|{
name|targetCandidates
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Decided to move "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|size
argument_list|)
operator|+
literal|" bytes from "
operator|+
name|source
operator|.
name|datanode
operator|.
name|getName
argument_list|()
operator|+
literal|" to "
operator|+
name|target
operator|.
name|datanode
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/* For the given target, choose sources from the source candidate list.    * OnRackSource determines if the chosen source     * should be on the same rack as the target    */
DECL|method|chooseSource (BalancerDatanode target, Iterator<Source> sourceCandidates, boolean onRackSource)
specifier|private
name|boolean
name|chooseSource
parameter_list|(
name|BalancerDatanode
name|target
parameter_list|,
name|Iterator
argument_list|<
name|Source
argument_list|>
name|sourceCandidates
parameter_list|,
name|boolean
name|onRackSource
parameter_list|)
block|{
if|if
condition|(
operator|!
name|target
operator|.
name|isMoveQuotaFull
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|foundSource
init|=
literal|false
decl_stmt|;
name|Source
name|source
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|!
name|foundSource
operator|&&
name|sourceCandidates
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|source
operator|=
name|sourceCandidates
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|source
operator|.
name|isMoveQuotaFull
argument_list|()
condition|)
block|{
name|sourceCandidates
operator|.
name|remove
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|onRackSource
condition|)
block|{
comment|// choose from on-rack nodes
if|if
condition|(
name|cluster
operator|.
name|isOnSameRack
argument_list|(
name|source
operator|.
name|getDatanode
argument_list|()
argument_list|,
name|target
operator|.
name|getDatanode
argument_list|()
argument_list|)
condition|)
block|{
name|foundSource
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// choose from off-rack nodes
if|if
condition|(
operator|!
name|cluster
operator|.
name|isOnSameRack
argument_list|(
name|source
operator|.
name|datanode
argument_list|,
name|target
operator|.
name|datanode
argument_list|)
condition|)
block|{
name|foundSource
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|foundSource
condition|)
block|{
assert|assert
operator|(
name|source
operator|!=
literal|null
operator|)
operator|:
literal|"Choose a null source"
assert|;
name|long
name|size
init|=
name|Math
operator|.
name|min
argument_list|(
name|source
operator|.
name|availableSizeToMove
argument_list|()
argument_list|,
name|target
operator|.
name|availableSizeToMove
argument_list|()
argument_list|)
decl_stmt|;
name|NodeTask
name|nodeTask
init|=
operator|new
name|NodeTask
argument_list|(
name|target
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|source
operator|.
name|addNodeTask
argument_list|(
name|nodeTask
argument_list|)
expr_stmt|;
name|target
operator|.
name|incScheduledSize
argument_list|(
name|nodeTask
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
name|sources
operator|.
name|add
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|targets
operator|.
name|add
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|source
operator|.
name|isMoveQuotaFull
argument_list|()
condition|)
block|{
name|sourceCandidates
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Decided to move "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|size
argument_list|)
operator|+
literal|" bytes from "
operator|+
name|source
operator|.
name|datanode
operator|.
name|getName
argument_list|()
operator|+
literal|" to "
operator|+
name|target
operator|.
name|datanode
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|class|BytesMoved
specifier|private
specifier|static
class|class
name|BytesMoved
block|{
DECL|field|bytesMoved
specifier|private
name|long
name|bytesMoved
init|=
literal|0L
decl_stmt|;
empty_stmt|;
DECL|method|inc ( long bytes )
specifier|private
specifier|synchronized
name|void
name|inc
parameter_list|(
name|long
name|bytes
parameter_list|)
block|{
name|bytesMoved
operator|+=
name|bytes
expr_stmt|;
block|}
DECL|method|get ()
specifier|private
name|long
name|get
parameter_list|()
block|{
return|return
name|bytesMoved
return|;
block|}
block|}
empty_stmt|;
DECL|field|bytesMoved
specifier|private
name|BytesMoved
name|bytesMoved
init|=
operator|new
name|BytesMoved
argument_list|()
decl_stmt|;
DECL|field|notChangedIterations
specifier|private
name|int
name|notChangedIterations
init|=
literal|0
decl_stmt|;
comment|/* Start a thread to dispatch block moves for each source.     * The thread selects blocks to move& sends request to proxy source to    * initiate block move. The process is flow controlled. Block selection is    * blocked if there are too many un-confirmed block moves.    * Return the total number of bytes successfully moved in this iteration.    */
DECL|method|dispatchBlockMoves ()
specifier|private
name|long
name|dispatchBlockMoves
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|long
name|bytesLastMoved
init|=
name|bytesMoved
operator|.
name|get
argument_list|()
decl_stmt|;
name|Future
argument_list|<
name|?
argument_list|>
index|[]
name|futures
init|=
operator|new
name|Future
argument_list|<
name|?
argument_list|>
index|[
name|sources
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Source
name|source
range|:
name|sources
control|)
block|{
name|futures
index|[
name|i
operator|++
index|]
operator|=
name|dispatcherExecutor
operator|.
name|submit
argument_list|(
name|source
operator|.
expr|new
name|BlockMoveDispatcher
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// wait for all dispatcher threads to finish
for|for
control|(
name|Future
argument_list|<
name|?
argument_list|>
name|future
range|:
name|futures
control|)
block|{
try|try
block|{
name|future
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Dispatcher thread failed"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// wait for all block moving to be done
name|waitForMoveCompletion
argument_list|()
expr_stmt|;
return|return
name|bytesMoved
operator|.
name|get
argument_list|()
operator|-
name|bytesLastMoved
return|;
block|}
comment|// The sleeping period before checking if block move is completed again
DECL|field|blockMoveWaitTime
specifier|static
specifier|private
name|long
name|blockMoveWaitTime
init|=
literal|30000L
decl_stmt|;
comment|/** set the sleeping period for block move completion check */
DECL|method|setBlockMoveWaitTime (long time)
specifier|static
name|void
name|setBlockMoveWaitTime
parameter_list|(
name|long
name|time
parameter_list|)
block|{
name|blockMoveWaitTime
operator|=
name|time
expr_stmt|;
block|}
comment|/* wait for all block move confirmations     * by checking each target's pendingMove queue     */
DECL|method|waitForMoveCompletion ()
specifier|private
name|void
name|waitForMoveCompletion
parameter_list|()
block|{
name|boolean
name|shouldWait
decl_stmt|;
do|do
block|{
name|shouldWait
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|BalancerDatanode
name|target
range|:
name|targets
control|)
block|{
if|if
condition|(
operator|!
name|target
operator|.
name|isPendingQEmpty
argument_list|()
condition|)
block|{
name|shouldWait
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|shouldWait
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|blockMoveWaitTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ignored
parameter_list|)
block|{         }
block|}
block|}
do|while
condition|(
name|shouldWait
condition|)
do|;
block|}
comment|/** This window makes sure to keep blocks that have been moved within 1.5 hour.    * Old window has blocks that are older;    * Current window has blocks that are more recent;    * Cleanup method triggers the check if blocks in the old window are    * more than 1.5 hour old. If yes, purge the old window and then    * move blocks in current window to old window.    */
DECL|class|MovedBlocks
specifier|private
specifier|static
class|class
name|MovedBlocks
block|{
DECL|field|lastCleanupTime
specifier|private
name|long
name|lastCleanupTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
DECL|field|CUR_WIN
specifier|final
specifier|private
specifier|static
name|int
name|CUR_WIN
init|=
literal|0
decl_stmt|;
DECL|field|OLD_WIN
specifier|final
specifier|private
specifier|static
name|int
name|OLD_WIN
init|=
literal|1
decl_stmt|;
DECL|field|NUM_WINS
specifier|final
specifier|private
specifier|static
name|int
name|NUM_WINS
init|=
literal|2
decl_stmt|;
DECL|field|movedBlocks
specifier|final
specifier|private
name|List
argument_list|<
name|HashMap
argument_list|<
name|Block
argument_list|,
name|BalancerBlock
argument_list|>
argument_list|>
name|movedBlocks
init|=
operator|new
name|ArrayList
argument_list|<
name|HashMap
argument_list|<
name|Block
argument_list|,
name|BalancerBlock
argument_list|>
argument_list|>
argument_list|(
name|NUM_WINS
argument_list|)
decl_stmt|;
comment|/* initialize the moved blocks collection */
DECL|method|MovedBlocks ()
specifier|private
name|MovedBlocks
parameter_list|()
block|{
name|movedBlocks
operator|.
name|add
argument_list|(
operator|new
name|HashMap
argument_list|<
name|Block
argument_list|,
name|BalancerBlock
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|movedBlocks
operator|.
name|add
argument_list|(
operator|new
name|HashMap
argument_list|<
name|Block
argument_list|,
name|BalancerBlock
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* add a block thus marking a block to be moved */
DECL|method|add (BalancerBlock block)
specifier|synchronized
specifier|private
name|void
name|add
parameter_list|(
name|BalancerBlock
name|block
parameter_list|)
block|{
name|movedBlocks
operator|.
name|get
argument_list|(
name|CUR_WIN
argument_list|)
operator|.
name|put
argument_list|(
name|block
operator|.
name|getBlock
argument_list|()
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
comment|/* check if a block is marked as moved */
DECL|method|contains (BalancerBlock block)
specifier|synchronized
specifier|private
name|boolean
name|contains
parameter_list|(
name|BalancerBlock
name|block
parameter_list|)
block|{
return|return
name|contains
argument_list|(
name|block
operator|.
name|getBlock
argument_list|()
argument_list|)
return|;
block|}
comment|/* check if a block is marked as moved */
DECL|method|contains (Block block)
specifier|synchronized
specifier|private
name|boolean
name|contains
parameter_list|(
name|Block
name|block
parameter_list|)
block|{
return|return
name|movedBlocks
operator|.
name|get
argument_list|(
name|CUR_WIN
argument_list|)
operator|.
name|containsKey
argument_list|(
name|block
argument_list|)
operator|||
name|movedBlocks
operator|.
name|get
argument_list|(
name|OLD_WIN
argument_list|)
operator|.
name|containsKey
argument_list|(
name|block
argument_list|)
return|;
block|}
comment|/* remove old blocks */
DECL|method|cleanup ()
specifier|synchronized
specifier|private
name|void
name|cleanup
parameter_list|()
block|{
name|long
name|curTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
comment|// check if old win is older than winWidth
if|if
condition|(
name|lastCleanupTime
operator|+
name|WIN_WIDTH
operator|<=
name|curTime
condition|)
block|{
comment|// purge the old window
name|movedBlocks
operator|.
name|set
argument_list|(
name|OLD_WIN
argument_list|,
name|movedBlocks
operator|.
name|get
argument_list|(
name|CUR_WIN
argument_list|)
argument_list|)
expr_stmt|;
name|movedBlocks
operator|.
name|set
argument_list|(
name|CUR_WIN
argument_list|,
operator|new
name|HashMap
argument_list|<
name|Block
argument_list|,
name|BalancerBlock
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
name|lastCleanupTime
operator|=
name|curTime
expr_stmt|;
block|}
block|}
block|}
comment|/* Decide if it is OK to move the given block from source to target    * A block is a good candidate if    * 1. the block is not in the process of being moved/has not been moved;    * 2. the block does not have a replica on the target;    * 3. doing the move does not reduce the number of racks that the block has    */
DECL|method|isGoodBlockCandidate (Source source, BalancerDatanode target, BalancerBlock block)
specifier|private
name|boolean
name|isGoodBlockCandidate
parameter_list|(
name|Source
name|source
parameter_list|,
name|BalancerDatanode
name|target
parameter_list|,
name|BalancerBlock
name|block
parameter_list|)
block|{
comment|// check if the block is moved or not
if|if
condition|(
name|movedBlocks
operator|.
name|contains
argument_list|(
name|block
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|block
operator|.
name|isLocatedOnDatanode
argument_list|(
name|target
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|goodBlock
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|cluster
operator|.
name|isOnSameRack
argument_list|(
name|source
operator|.
name|getDatanode
argument_list|()
argument_list|,
name|target
operator|.
name|getDatanode
argument_list|()
argument_list|)
condition|)
block|{
comment|// good if source and target are on the same rack
name|goodBlock
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|boolean
name|notOnSameRack
init|=
literal|true
decl_stmt|;
synchronized|synchronized
init|(
name|block
init|)
block|{
for|for
control|(
name|BalancerDatanode
name|loc
range|:
name|block
operator|.
name|locations
control|)
block|{
if|if
condition|(
name|cluster
operator|.
name|isOnSameRack
argument_list|(
name|loc
operator|.
name|datanode
argument_list|,
name|target
operator|.
name|datanode
argument_list|)
condition|)
block|{
name|notOnSameRack
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|notOnSameRack
condition|)
block|{
comment|// good if target is target is not on the same rack as any replica
name|goodBlock
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// good if source is on the same rack as on of the replicas
for|for
control|(
name|BalancerDatanode
name|loc
range|:
name|block
operator|.
name|locations
control|)
block|{
if|if
condition|(
name|loc
operator|!=
name|source
operator|&&
name|cluster
operator|.
name|isOnSameRack
argument_list|(
name|loc
operator|.
name|datanode
argument_list|,
name|source
operator|.
name|datanode
argument_list|)
condition|)
block|{
name|goodBlock
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
return|return
name|goodBlock
return|;
block|}
comment|/* reset all fields in a balancer preparing for the next iteration */
DECL|method|resetData ()
specifier|private
name|void
name|resetData
parameter_list|()
block|{
name|this
operator|.
name|cluster
operator|=
operator|new
name|NetworkTopology
argument_list|()
expr_stmt|;
name|this
operator|.
name|overUtilizedDatanodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|aboveAvgUtilizedDatanodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|belowAvgUtilizedDatanodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|underUtilizedDatanodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|datanodes
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|sources
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|targets
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|policy
operator|.
name|reset
argument_list|()
expr_stmt|;
name|cleanGlobalBlockList
argument_list|()
expr_stmt|;
name|this
operator|.
name|movedBlocks
operator|.
name|cleanup
argument_list|()
expr_stmt|;
block|}
comment|/* Remove all blocks from the global block list except for the ones in the    * moved list.    */
DECL|method|cleanGlobalBlockList ()
specifier|private
name|void
name|cleanGlobalBlockList
parameter_list|()
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Block
argument_list|>
name|globalBlockListIterator
init|=
name|globalBlockList
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|globalBlockListIterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Block
name|block
init|=
name|globalBlockListIterator
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|movedBlocks
operator|.
name|contains
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|globalBlockListIterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/* Return true if the given datanode is overUtilized */
DECL|method|isOverUtilized (BalancerDatanode datanode)
specifier|private
name|boolean
name|isOverUtilized
parameter_list|(
name|BalancerDatanode
name|datanode
parameter_list|)
block|{
return|return
name|datanode
operator|.
name|utilization
operator|>
operator|(
name|policy
operator|.
name|getAvgUtilization
argument_list|()
operator|+
name|threshold
operator|)
return|;
block|}
comment|/* Return true if the given datanode is above average utilized    * but not overUtilized */
DECL|method|isAboveAvgUtilized (BalancerDatanode datanode)
specifier|private
name|boolean
name|isAboveAvgUtilized
parameter_list|(
name|BalancerDatanode
name|datanode
parameter_list|)
block|{
specifier|final
name|double
name|avg
init|=
name|policy
operator|.
name|getAvgUtilization
argument_list|()
decl_stmt|;
return|return
operator|(
name|datanode
operator|.
name|utilization
operator|<=
operator|(
name|avg
operator|+
name|threshold
operator|)
operator|)
operator|&&
operator|(
name|datanode
operator|.
name|utilization
operator|>
name|avg
operator|)
return|;
block|}
comment|/* Return true if the given datanode is underUtilized */
DECL|method|isUnderUtilized (BalancerDatanode datanode)
specifier|private
name|boolean
name|isUnderUtilized
parameter_list|(
name|BalancerDatanode
name|datanode
parameter_list|)
block|{
return|return
name|datanode
operator|.
name|utilization
operator|<
operator|(
name|policy
operator|.
name|getAvgUtilization
argument_list|()
operator|-
name|threshold
operator|)
return|;
block|}
comment|/* Return true if the given datanode is below average utilized     * but not underUtilized */
DECL|method|isBelowOrEqualAvgUtilized (BalancerDatanode datanode)
specifier|private
name|boolean
name|isBelowOrEqualAvgUtilized
parameter_list|(
name|BalancerDatanode
name|datanode
parameter_list|)
block|{
specifier|final
name|double
name|avg
init|=
name|policy
operator|.
name|getAvgUtilization
argument_list|()
decl_stmt|;
return|return
operator|(
name|datanode
operator|.
name|utilization
operator|>=
operator|(
name|avg
operator|-
name|threshold
operator|)
operator|)
operator|&&
operator|(
name|datanode
operator|.
name|utilization
operator|<=
name|avg
operator|)
return|;
block|}
comment|// Exit status
DECL|enum|ReturnStatus
enum|enum
name|ReturnStatus
block|{
DECL|enumConstant|SUCCESS
name|SUCCESS
argument_list|(
literal|1
argument_list|)
block|,
DECL|enumConstant|IN_PROGRESS
name|IN_PROGRESS
argument_list|(
literal|0
argument_list|)
block|,
DECL|enumConstant|ALREADY_RUNNING
name|ALREADY_RUNNING
argument_list|(
operator|-
literal|1
argument_list|)
block|,
DECL|enumConstant|NO_MOVE_BLOCK
name|NO_MOVE_BLOCK
argument_list|(
operator|-
literal|2
argument_list|)
block|,
DECL|enumConstant|NO_MOVE_PROGRESS
name|NO_MOVE_PROGRESS
argument_list|(
operator|-
literal|3
argument_list|)
block|,
DECL|enumConstant|IO_EXCEPTION
name|IO_EXCEPTION
argument_list|(
operator|-
literal|4
argument_list|)
block|,
DECL|enumConstant|ILLEGAL_ARGS
name|ILLEGAL_ARGS
argument_list|(
operator|-
literal|5
argument_list|)
block|,
DECL|enumConstant|INTERRUPTED
name|INTERRUPTED
argument_list|(
operator|-
literal|6
argument_list|)
block|;
DECL|field|code
specifier|final
name|int
name|code
decl_stmt|;
DECL|method|ReturnStatus (int code)
name|ReturnStatus
parameter_list|(
name|int
name|code
parameter_list|)
block|{
name|this
operator|.
name|code
operator|=
name|code
expr_stmt|;
block|}
block|}
comment|/** Run an iteration for all datanodes. */
DECL|method|run (int iteration, Formatter formatter)
specifier|private
name|ReturnStatus
name|run
parameter_list|(
name|int
name|iteration
parameter_list|,
name|Formatter
name|formatter
parameter_list|)
block|{
try|try
block|{
comment|/* get all live datanodes of a cluster and their disk usage        * decide the number of bytes need to be moved        */
specifier|final
name|long
name|bytesLeftToMove
init|=
name|initNodes
argument_list|(
name|nnc
operator|.
name|client
operator|.
name|getDatanodeReport
argument_list|(
name|DatanodeReportType
operator|.
name|LIVE
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytesLeftToMove
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"The cluster is balanced. Exiting..."
argument_list|)
expr_stmt|;
return|return
name|ReturnStatus
operator|.
name|SUCCESS
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Need to move "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesLeftToMove
argument_list|)
operator|+
literal|" to make the cluster balanced."
argument_list|)
expr_stmt|;
block|}
comment|/* Decide all the nodes that will participate in the block move and        * the number of bytes that need to be moved from one node to another        * in this iteration. Maximum bytes to be moved per node is        * Min(1 Band worth of bytes,  MAX_SIZE_TO_MOVE).        */
specifier|final
name|long
name|bytesToMove
init|=
name|chooseNodes
argument_list|()
decl_stmt|;
if|if
condition|(
name|bytesToMove
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"No block can be moved. Exiting..."
argument_list|)
expr_stmt|;
return|return
name|ReturnStatus
operator|.
name|NO_MOVE_BLOCK
return|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Will move "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesToMove
argument_list|)
operator|+
literal|" in this iteration"
argument_list|)
expr_stmt|;
block|}
name|formatter
operator|.
name|format
argument_list|(
literal|"%-24s %10d  %19s  %18s  %17s\n"
argument_list|,
name|DateFormat
operator|.
name|getDateTimeInstance
argument_list|()
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|()
argument_list|)
argument_list|,
name|iteration
argument_list|,
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesMoved
operator|.
name|get
argument_list|()
argument_list|)
argument_list|,
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesLeftToMove
argument_list|)
argument_list|,
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|bytesToMove
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For each pair of<source, target>, start a thread that repeatedly         * decide a block to be moved and its proxy source,         * then initiates the move until all bytes are moved or no more block        * available to move.        * Exit no byte has been moved for 5 consecutive iterations.        */
if|if
condition|(
name|dispatchBlockMoves
argument_list|()
operator|>
literal|0
condition|)
block|{
name|notChangedIterations
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|notChangedIterations
operator|++
expr_stmt|;
if|if
condition|(
name|notChangedIterations
operator|>=
literal|5
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"No block has been moved for 5 iterations. Exiting..."
argument_list|)
expr_stmt|;
return|return
name|ReturnStatus
operator|.
name|NO_MOVE_PROGRESS
return|;
block|}
block|}
comment|// clean all lists
name|resetData
argument_list|()
expr_stmt|;
return|return
name|ReturnStatus
operator|.
name|IN_PROGRESS
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|e
operator|+
literal|".  Exiting ..."
argument_list|)
expr_stmt|;
return|return
name|ReturnStatus
operator|.
name|ILLEGAL_ARGS
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|e
operator|+
literal|".  Exiting ..."
argument_list|)
expr_stmt|;
return|return
name|ReturnStatus
operator|.
name|IO_EXCEPTION
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|e
operator|+
literal|".  Exiting ..."
argument_list|)
expr_stmt|;
return|return
name|ReturnStatus
operator|.
name|INTERRUPTED
return|;
block|}
finally|finally
block|{
comment|// shutdown thread pools
name|dispatcherExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|moverExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Balance all namenodes.    * For each iteration,    * for each namenode,    * execute a {@link Balancer} to work through all datanodes once.      */
DECL|method|run (List<InetSocketAddress> namenodes, final Parameters p, Configuration conf)
specifier|static
name|int
name|run
parameter_list|(
name|List
argument_list|<
name|InetSocketAddress
argument_list|>
name|namenodes
parameter_list|,
specifier|final
name|Parameters
name|p
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
specifier|final
name|long
name|sleeptime
init|=
literal|2000
operator|*
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HEARTBEAT_INTERVAL_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_HEARTBEAT_INTERVAL_DEFAULT
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"namenodes = "
operator|+
name|namenodes
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"p         = "
operator|+
name|p
argument_list|)
expr_stmt|;
specifier|final
name|Formatter
name|formatter
init|=
operator|new
name|Formatter
argument_list|(
name|System
operator|.
name|out
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Time Stamp               Iteration#  Bytes Already Moved  Bytes Left To Move  Bytes Being Moved"
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|NameNodeConnector
argument_list|>
name|connectors
init|=
operator|new
name|ArrayList
argument_list|<
name|NameNodeConnector
argument_list|>
argument_list|(
name|namenodes
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
for|for
control|(
name|InetSocketAddress
name|isa
range|:
name|namenodes
control|)
block|{
name|connectors
operator|.
name|add
argument_list|(
operator|new
name|NameNodeConnector
argument_list|(
name|isa
argument_list|,
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|boolean
name|done
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|iteration
init|=
literal|0
init|;
operator|!
name|done
condition|;
name|iteration
operator|++
control|)
block|{
name|done
operator|=
literal|true
expr_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|connectors
argument_list|)
expr_stmt|;
for|for
control|(
name|NameNodeConnector
name|nnc
range|:
name|connectors
control|)
block|{
specifier|final
name|Balancer
name|b
init|=
operator|new
name|Balancer
argument_list|(
name|nnc
argument_list|,
name|p
argument_list|,
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|ReturnStatus
name|r
init|=
name|b
operator|.
name|run
argument_list|(
name|iteration
argument_list|,
name|formatter
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|ReturnStatus
operator|.
name|IN_PROGRESS
condition|)
block|{
name|done
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|!=
name|ReturnStatus
operator|.
name|SUCCESS
condition|)
block|{
comment|//must be an error statue, return.
return|return
name|r
operator|.
name|code
return|;
block|}
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleeptime
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
for|for
control|(
name|NameNodeConnector
name|nnc
range|:
name|connectors
control|)
block|{
name|nnc
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|ReturnStatus
operator|.
name|SUCCESS
operator|.
name|code
return|;
block|}
comment|/* Given elaspedTime in ms, return a printable string */
DECL|method|time2Str (long elapsedTime)
specifier|private
specifier|static
name|String
name|time2Str
parameter_list|(
name|long
name|elapsedTime
parameter_list|)
block|{
name|String
name|unit
decl_stmt|;
name|double
name|time
init|=
name|elapsedTime
decl_stmt|;
if|if
condition|(
name|elapsedTime
operator|<
literal|1000
condition|)
block|{
name|unit
operator|=
literal|"milliseconds"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elapsedTime
operator|<
literal|60
operator|*
literal|1000
condition|)
block|{
name|unit
operator|=
literal|"seconds"
expr_stmt|;
name|time
operator|=
name|time
operator|/
literal|1000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elapsedTime
operator|<
literal|3600
operator|*
literal|1000
condition|)
block|{
name|unit
operator|=
literal|"minutes"
expr_stmt|;
name|time
operator|=
name|time
operator|/
operator|(
literal|60
operator|*
literal|1000
operator|)
expr_stmt|;
block|}
else|else
block|{
name|unit
operator|=
literal|"hours"
expr_stmt|;
name|time
operator|=
name|time
operator|/
operator|(
literal|3600
operator|*
literal|1000
operator|)
expr_stmt|;
block|}
return|return
name|time
operator|+
literal|" "
operator|+
name|unit
return|;
block|}
DECL|class|Parameters
specifier|static
class|class
name|Parameters
block|{
DECL|field|DEFALUT
specifier|static
specifier|final
name|Parameters
name|DEFALUT
init|=
operator|new
name|Parameters
argument_list|(
name|BalancingPolicy
operator|.
name|Node
operator|.
name|INSTANCE
argument_list|,
literal|10.0
argument_list|)
decl_stmt|;
DECL|field|policy
specifier|final
name|BalancingPolicy
name|policy
decl_stmt|;
DECL|field|threshold
specifier|final
name|double
name|threshold
decl_stmt|;
DECL|method|Parameters (BalancingPolicy policy, double threshold)
name|Parameters
parameter_list|(
name|BalancingPolicy
name|policy
parameter_list|,
name|double
name|threshold
parameter_list|)
block|{
name|this
operator|.
name|policy
operator|=
name|policy
expr_stmt|;
name|this
operator|.
name|threshold
operator|=
name|threshold
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|Balancer
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"."
operator|+
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"["
operator|+
name|policy
operator|+
literal|", threshold="
operator|+
name|threshold
operator|+
literal|"]"
return|;
block|}
block|}
DECL|class|Cli
specifier|static
class|class
name|Cli
extends|extends
name|Configured
implements|implements
name|Tool
block|{
comment|/** Parse arguments and then run Balancer */
annotation|@
name|Override
DECL|method|run (String[] args)
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
specifier|final
name|long
name|startTime
init|=
name|Util
operator|.
name|now
argument_list|()
decl_stmt|;
specifier|final
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|WIN_WIDTH
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_MOVEDWINWIDTH_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BALANCER_MOVEDWINWIDTH_DEFAULT
argument_list|)
expr_stmt|;
try|try
block|{
name|checkReplicationPolicyCompatibility
argument_list|(
name|conf
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|InetSocketAddress
argument_list|>
name|namenodes
init|=
name|DFSUtil
operator|.
name|getNNServiceRpcAddresses
argument_list|(
name|conf
argument_list|)
decl_stmt|;
return|return
name|Balancer
operator|.
name|run
argument_list|(
name|namenodes
argument_list|,
name|parse
argument_list|(
name|args
argument_list|)
argument_list|,
name|conf
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|e
operator|+
literal|".  Exiting ..."
argument_list|)
expr_stmt|;
return|return
name|ReturnStatus
operator|.
name|IO_EXCEPTION
operator|.
name|code
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|e
operator|+
literal|".  Exiting ..."
argument_list|)
expr_stmt|;
return|return
name|ReturnStatus
operator|.
name|INTERRUPTED
operator|.
name|code
return|;
block|}
finally|finally
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Balancing took "
operator|+
name|time2Str
argument_list|(
name|Util
operator|.
name|now
argument_list|()
operator|-
name|startTime
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** parse command line arguments */
DECL|method|parse (String[] args)
specifier|static
name|Parameters
name|parse
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|BalancingPolicy
name|policy
init|=
name|Parameters
operator|.
name|DEFALUT
operator|.
name|policy
decl_stmt|;
name|double
name|threshold
init|=
name|Parameters
operator|.
name|DEFALUT
operator|.
name|threshold
decl_stmt|;
if|if
condition|(
name|args
operator|!=
literal|null
condition|)
block|{
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
literal|"-threshold"
operator|.
name|equalsIgnoreCase
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
try|try
block|{
name|threshold
operator|=
name|Double
operator|.
name|parseDouble
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|threshold
argument_list|<
literal|0
operator|||
name|threshold
argument_list|>
literal|100
condition|)
block|{
throw|throw
operator|new
name|NumberFormatException
argument_list|(
literal|"Number out of range: threshold = "
operator|+
name|threshold
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Using a threshold of "
operator|+
name|threshold
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Expecting a number in the range of [0.0, 100.0]: "
operator|+
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"-policy"
operator|.
name|equalsIgnoreCase
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
try|try
block|{
name|policy
operator|=
name|BalancingPolicy
operator|.
name|parse
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Illegal policy name: "
operator|+
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"args = "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|args
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
name|printUsage
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
return|return
operator|new
name|Parameters
argument_list|(
name|policy
argument_list|,
name|threshold
argument_list|)
return|;
block|}
DECL|method|printUsage ()
specifier|private
specifier|static
name|void
name|printUsage
parameter_list|()
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Usage: java "
operator|+
name|Balancer
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    [-policy<policy>]\tthe balancing policy: "
operator|+
name|BalancingPolicy
operator|.
name|Node
operator|.
name|INSTANCE
operator|.
name|getName
argument_list|()
operator|+
literal|" or "
operator|+
name|BalancingPolicy
operator|.
name|Pool
operator|.
name|INSTANCE
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"    [-threshold<threshold>]\tPercentage of disk capacity"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Run a balancer    * @param args Command line arguments    */
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
try|try
block|{
name|System
operator|.
name|exit
argument_list|(
name|ToolRunner
operator|.
name|run
argument_list|(
literal|null
argument_list|,
operator|new
name|Cli
argument_list|()
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exiting balancer due an exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

