begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.datanode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_ADMIN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_BLOCKREPORT_INITIAL_DELAY_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_BLOCKREPORT_INTERVAL_MSEC_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_HTTPS_NEED_AUTH_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_SOCKET_TIMEOUT_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_WRITE_PACKET_SIZE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_CLIENT_WRITE_PACKET_SIZE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_DATA_DIR_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_DATA_DIR_PERMISSION_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_DATA_DIR_PERMISSION_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_DIRECTORYSCAN_INTERVAL_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_DIRECTORYSCAN_INTERVAL_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_HANDLER_COUNT_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_HANDLER_COUNT_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_HOST_NAME_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_KEYTAB_FILE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_SCAN_PERIOD_HOURS_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_SCAN_PERIOD_HOURS_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_SOCKET_WRITE_TIMEOUT_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_STORAGEID_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_SYNCONCLOSE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_SYNCONCLOSE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_DATANODE_USER_NAME_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_FEDERATION_NAMESERVICES
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|DFS_HEARTBEAT_INTERVAL_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Util
operator|.
name|now
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|ServerSocket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketTimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ServerSocketChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|SocketChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|SecureRandom
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configured
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocalFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HDFSPolicyProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|BlockListAsLongs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ClientDatanodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsProtoUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|RecoveryInProgressException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|UnregisteredNodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|BlockConstructionStage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|DataTransferProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|Sender
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|DNTransferAckProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|Status
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockPoolTokenSecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenSecretManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|ExportedBlockKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|InvalidBlockTokenException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsConstants
operator|.
name|ReplicaState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsConstants
operator|.
name|StartupOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|IncorrectVersionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|JspHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|FSDataset
operator|.
name|VolumeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|SecureDataNodeStarter
operator|.
name|SecureResources
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|metrics
operator|.
name|DataNodeMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSNamesystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FileChecksumServlets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|StreamFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockRecoveryCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockRecoveryCommand
operator|.
name|RecoveringBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DisallowedDatanodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|InterDatanodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|KeyUpdateCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamespaceInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|ReplicaRecoveryInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|UpgradeCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|http
operator|.
name|HttpServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|ProtocolSignature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|DefaultMetricsSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|util
operator|.
name|MBeans
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|DNS
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SecurityUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|AccessControlList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DiskChecker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DiskChecker
operator|.
name|DiskErrorException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DiskChecker
operator|.
name|DiskOutOfSpaceException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|GenericOptionsParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ServicePlugin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|VersionInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mortbay
operator|.
name|util
operator|.
name|ajax
operator|.
name|JSON
import|;
end_import

begin_comment
comment|/**********************************************************  * DataNode is a class (and program) that stores a set of  * blocks for a DFS deployment.  A single deployment can  * have one or many DataNodes.  Each DataNode communicates  * regularly with a single NameNode.  It also communicates  * with client code and other DataNodes from time to time.  *  * DataNodes store a series of named blocks.  The DataNode  * allows client code to read these blocks, or to write new  * block data.  The DataNode may also, in response to instructions  * from its NameNode, delete blocks or copy blocks to/from other  * DataNodes.  *  * The DataNode maintains just one critical table:  *   block-> stream of bytes (of BLOCK_SIZE or less)  *  * This info is stored on a local disk.  The DataNode  * reports the table's contents to the NameNode upon startup  * and every so often afterwards.  *  * DataNodes spend their lives in an endless loop of asking  * the NameNode for something to do.  A NameNode cannot connect  * to a DataNode directly; a NameNode simply returns values from  * functions invoked by a DataNode.  *  * DataNodes maintain an open server socket so that client code   * or other DataNodes can read/write data.  The host/port for  * this server is reported to the NameNode, which then sends that  * information to clients or other DataNodes that might be interested.  *  **********************************************************/
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|DataNode
specifier|public
class|class
name|DataNode
extends|extends
name|Configured
implements|implements
name|InterDatanodeProtocol
implements|,
name|ClientDatanodeProtocol
implements|,
name|FSConstants
implements|,
name|DataNodeMXBean
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|DataNode
operator|.
name|class
argument_list|)
decl_stmt|;
static|static
block|{
name|HdfsConfiguration
operator|.
name|init
argument_list|()
expr_stmt|;
block|}
DECL|field|DN_CLIENTTRACE_FORMAT
specifier|public
specifier|static
specifier|final
name|String
name|DN_CLIENTTRACE_FORMAT
init|=
literal|"src: %s"
operator|+
comment|// src IP
literal|", dest: %s"
operator|+
comment|// dst IP
literal|", bytes: %s"
operator|+
comment|// byte count
literal|", op: %s"
operator|+
comment|// operation
literal|", cliID: %s"
operator|+
comment|// DFSClient id
literal|", offset: %s"
operator|+
comment|// offset
literal|", srvID: %s"
operator|+
comment|// DatanodeRegistration
literal|", blockid: %s"
operator|+
comment|// block id
literal|", duration: %s"
decl_stmt|;
comment|// duration time
DECL|field|ClientTraceLog
specifier|static
specifier|final
name|Log
name|ClientTraceLog
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|DataNode
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|".clienttrace"
argument_list|)
decl_stmt|;
comment|/**    * Use {@link NetUtils#createSocketAddr(String)} instead.    */
annotation|@
name|Deprecated
DECL|method|createSocketAddr (String target )
specifier|public
specifier|static
name|InetSocketAddress
name|createSocketAddr
parameter_list|(
name|String
name|target
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|target
argument_list|)
return|;
block|}
comment|/**    * Manages he BPOfferService objects for the data node.    * Creation, removal, starting, stopping, shutdown on BPOfferService    * objects must be done via APIs in this class.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|BlockPoolManager
class|class
name|BlockPoolManager
block|{
DECL|field|bpMapping
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|BPOfferService
argument_list|>
name|bpMapping
decl_stmt|;
DECL|field|nameNodeThreads
specifier|private
specifier|final
name|Map
argument_list|<
name|InetSocketAddress
argument_list|,
name|BPOfferService
argument_list|>
name|nameNodeThreads
decl_stmt|;
comment|//This lock is used only to ensure exclusion of refreshNamenodes
DECL|field|refreshNamenodesLock
specifier|private
specifier|final
name|Object
name|refreshNamenodesLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|method|BlockPoolManager (Configuration conf)
name|BlockPoolManager
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|bpMapping
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|BPOfferService
argument_list|>
argument_list|()
expr_stmt|;
name|nameNodeThreads
operator|=
operator|new
name|HashMap
argument_list|<
name|InetSocketAddress
argument_list|,
name|BPOfferService
argument_list|>
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|InetSocketAddress
argument_list|>
name|isas
init|=
name|DFSUtil
operator|.
name|getNNServiceRpcAddresses
argument_list|(
name|conf
argument_list|)
decl_stmt|;
for|for
control|(
name|InetSocketAddress
name|isa
range|:
name|isas
control|)
block|{
name|BPOfferService
name|bpos
init|=
operator|new
name|BPOfferService
argument_list|(
name|isa
argument_list|)
decl_stmt|;
name|nameNodeThreads
operator|.
name|put
argument_list|(
name|bpos
operator|.
name|getNNSocketAddress
argument_list|()
argument_list|,
name|bpos
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addBlockPool (BPOfferService t)
specifier|synchronized
name|void
name|addBlockPool
parameter_list|(
name|BPOfferService
name|t
parameter_list|)
block|{
if|if
condition|(
name|nameNodeThreads
operator|.
name|get
argument_list|(
name|t
operator|.
name|getNNSocketAddress
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown BPOfferService thread for namenode address:"
operator|+
name|t
operator|.
name|getNNSocketAddress
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|t
operator|.
name|getBlockPoolId
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Null blockpool id"
argument_list|)
throw|;
block|}
name|bpMapping
operator|.
name|put
argument_list|(
name|t
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the array of BPOfferService objects.       * Caution: The BPOfferService returned could be shutdown any time.      */
DECL|method|getAllNamenodeThreads ()
specifier|synchronized
name|BPOfferService
index|[]
name|getAllNamenodeThreads
parameter_list|()
block|{
name|BPOfferService
index|[]
name|bposArray
init|=
operator|new
name|BPOfferService
index|[
name|nameNodeThreads
operator|.
name|values
argument_list|()
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
return|return
name|nameNodeThreads
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
name|bposArray
argument_list|)
return|;
block|}
DECL|method|get (InetSocketAddress addr)
specifier|synchronized
name|BPOfferService
name|get
parameter_list|(
name|InetSocketAddress
name|addr
parameter_list|)
block|{
return|return
name|nameNodeThreads
operator|.
name|get
argument_list|(
name|addr
argument_list|)
return|;
block|}
DECL|method|get (String bpid)
specifier|synchronized
name|BPOfferService
name|get
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
return|return
name|bpMapping
operator|.
name|get
argument_list|(
name|bpid
argument_list|)
return|;
block|}
DECL|method|remove (BPOfferService t)
specifier|synchronized
name|void
name|remove
parameter_list|(
name|BPOfferService
name|t
parameter_list|)
block|{
name|nameNodeThreads
operator|.
name|remove
argument_list|(
name|t
operator|.
name|getNNSocketAddress
argument_list|()
argument_list|)
expr_stmt|;
name|bpMapping
operator|.
name|remove
argument_list|(
name|t
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|shutDownAll ()
name|void
name|shutDownAll
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|BPOfferService
index|[]
name|bposArray
init|=
name|this
operator|.
name|getAllNamenodeThreads
argument_list|()
decl_stmt|;
for|for
control|(
name|BPOfferService
name|bpos
range|:
name|bposArray
control|)
block|{
name|bpos
operator|.
name|stop
argument_list|()
expr_stmt|;
comment|//interrupts the threads
block|}
comment|//now join
for|for
control|(
name|BPOfferService
name|bpos
range|:
name|bposArray
control|)
block|{
name|bpos
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|startAll ()
specifier|synchronized
name|void
name|startAll
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
specifier|public
name|Object
name|run
parameter_list|()
throws|throws
name|Exception
block|{
for|for
control|(
name|BPOfferService
name|bpos
range|:
name|nameNodeThreads
operator|.
name|values
argument_list|()
control|)
block|{
name|bpos
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|IOException
name|ioe
init|=
operator|new
name|IOException
argument_list|()
decl_stmt|;
name|ioe
operator|.
name|initCause
argument_list|(
name|ex
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
block|}
DECL|method|joinAll ()
name|void
name|joinAll
parameter_list|()
throws|throws
name|InterruptedException
block|{
for|for
control|(
name|BPOfferService
name|bpos
range|:
name|this
operator|.
name|getAllNamenodeThreads
argument_list|()
control|)
block|{
name|bpos
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|refreshNamenodes (Configuration conf)
name|void
name|refreshNamenodes
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Refresh request received for nameservices: "
operator|+
name|conf
operator|.
name|get
argument_list|(
name|DFS_FEDERATION_NAMESERVICES
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|InetSocketAddress
argument_list|>
name|newAddresses
init|=
name|DFSUtil
operator|.
name|getNNServiceRpcAddresses
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|BPOfferService
argument_list|>
name|toShutdown
init|=
operator|new
name|ArrayList
argument_list|<
name|BPOfferService
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|InetSocketAddress
argument_list|>
name|toStart
init|=
operator|new
name|ArrayList
argument_list|<
name|InetSocketAddress
argument_list|>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|refreshNamenodesLock
init|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
for|for
control|(
name|InetSocketAddress
name|nnaddr
range|:
name|nameNodeThreads
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|newAddresses
operator|.
name|contains
argument_list|(
name|nnaddr
argument_list|)
operator|)
condition|)
block|{
name|toShutdown
operator|.
name|add
argument_list|(
name|nameNodeThreads
operator|.
name|get
argument_list|(
name|nnaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|InetSocketAddress
name|nnaddr
range|:
name|newAddresses
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|nameNodeThreads
operator|.
name|containsKey
argument_list|(
name|nnaddr
argument_list|)
operator|)
condition|)
block|{
name|toStart
operator|.
name|add
argument_list|(
name|nnaddr
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|InetSocketAddress
name|nnaddr
range|:
name|toStart
control|)
block|{
name|BPOfferService
name|bpos
init|=
operator|new
name|BPOfferService
argument_list|(
name|nnaddr
argument_list|)
decl_stmt|;
name|nameNodeThreads
operator|.
name|put
argument_list|(
name|bpos
operator|.
name|getNNSocketAddress
argument_list|()
argument_list|,
name|bpos
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|BPOfferService
name|bpos
range|:
name|toShutdown
control|)
block|{
name|remove
argument_list|(
name|bpos
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|BPOfferService
name|bpos
range|:
name|toShutdown
control|)
block|{
name|bpos
operator|.
name|stop
argument_list|()
expr_stmt|;
name|bpos
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
comment|// Now start the threads that are not already running.
name|startAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|field|shouldRun
specifier|volatile
name|boolean
name|shouldRun
init|=
literal|true
decl_stmt|;
DECL|field|blockPoolManager
specifier|private
name|BlockPoolManager
name|blockPoolManager
decl_stmt|;
DECL|field|data
specifier|public
specifier|volatile
name|FSDatasetInterface
name|data
init|=
literal|null
decl_stmt|;
DECL|field|clusterId
specifier|private
name|String
name|clusterId
init|=
literal|null
decl_stmt|;
DECL|field|EMPTY_DEL_HINT
specifier|public
specifier|final
specifier|static
name|String
name|EMPTY_DEL_HINT
init|=
literal|""
decl_stmt|;
DECL|field|xmitsInProgress
name|AtomicInteger
name|xmitsInProgress
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|field|dataXceiverServer
name|Daemon
name|dataXceiverServer
init|=
literal|null
decl_stmt|;
DECL|field|threadGroup
name|ThreadGroup
name|threadGroup
init|=
literal|null
decl_stmt|;
DECL|field|blockReportInterval
name|long
name|blockReportInterval
decl_stmt|;
DECL|field|resetBlockReportTime
name|boolean
name|resetBlockReportTime
init|=
literal|true
decl_stmt|;
DECL|field|initialBlockReportDelay
name|long
name|initialBlockReportDelay
init|=
name|BLOCKREPORT_INITIAL_DELAY
operator|*
literal|1000L
decl_stmt|;
DECL|field|heartBeatInterval
name|long
name|heartBeatInterval
decl_stmt|;
DECL|field|heartbeatsDisabledForTests
specifier|private
name|boolean
name|heartbeatsDisabledForTests
init|=
literal|false
decl_stmt|;
DECL|field|storage
specifier|private
name|DataStorage
name|storage
init|=
literal|null
decl_stmt|;
DECL|field|infoServer
specifier|private
name|HttpServer
name|infoServer
init|=
literal|null
decl_stmt|;
DECL|field|metrics
name|DataNodeMetrics
name|metrics
decl_stmt|;
DECL|field|selfAddr
specifier|private
name|InetSocketAddress
name|selfAddr
decl_stmt|;
DECL|field|hostName
specifier|private
specifier|volatile
name|String
name|hostName
decl_stmt|;
comment|// Host name of this datanode
DECL|field|dnThreadName
specifier|private
specifier|static
name|String
name|dnThreadName
decl_stmt|;
DECL|field|socketTimeout
name|int
name|socketTimeout
decl_stmt|;
DECL|field|socketWriteTimeout
name|int
name|socketWriteTimeout
init|=
literal|0
decl_stmt|;
DECL|field|transferToAllowed
name|boolean
name|transferToAllowed
init|=
literal|true
decl_stmt|;
DECL|field|writePacketSize
name|int
name|writePacketSize
init|=
literal|0
decl_stmt|;
DECL|field|isBlockTokenEnabled
name|boolean
name|isBlockTokenEnabled
decl_stmt|;
DECL|field|blockPoolTokenSecretManager
name|BlockPoolTokenSecretManager
name|blockPoolTokenSecretManager
decl_stmt|;
DECL|field|syncOnClose
name|boolean
name|syncOnClose
decl_stmt|;
DECL|field|blockScanner
specifier|public
name|DataBlockScanner
name|blockScanner
init|=
literal|null
decl_stmt|;
DECL|field|directoryScanner
specifier|private
name|DirectoryScanner
name|directoryScanner
init|=
literal|null
decl_stmt|;
comment|/** Activated plug-ins. */
DECL|field|plugins
specifier|private
name|List
argument_list|<
name|ServicePlugin
argument_list|>
name|plugins
decl_stmt|;
DECL|field|R
specifier|private
specifier|static
specifier|final
name|Random
name|R
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
comment|// For InterDataNodeProtocol
DECL|field|ipcServer
specifier|public
name|Server
name|ipcServer
decl_stmt|;
DECL|field|secureResources
specifier|private
name|SecureResources
name|secureResources
init|=
literal|null
decl_stmt|;
DECL|field|dataDirs
specifier|private
name|AbstractList
argument_list|<
name|File
argument_list|>
name|dataDirs
decl_stmt|;
DECL|field|conf
specifier|private
name|Configuration
name|conf
decl_stmt|;
comment|/**    * Create the DataNode given a configuration and an array of dataDirs.    * 'dataDirs' is where the blocks are stored.    */
DECL|method|DataNode (final Configuration conf, final AbstractList<File> dataDirs)
name|DataNode
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|AbstractList
argument_list|<
name|File
argument_list|>
name|dataDirs
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|dataDirs
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create the DataNode given a configuration, an array of dataDirs,    * and a namenode proxy    */
DECL|method|DataNode (final Configuration conf, final AbstractList<File> dataDirs, final SecureResources resources)
name|DataNode
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|AbstractList
argument_list|<
name|File
argument_list|>
name|dataDirs
parameter_list|,
specifier|final
name|SecureResources
name|resources
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
try|try
block|{
name|hostName
operator|=
name|getHostName
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|startDataNode
argument_list|(
name|conf
argument_list|,
name|dataDirs
argument_list|,
name|resources
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|shutdown
argument_list|()
expr_stmt|;
throw|throw
name|ie
throw|;
block|}
block|}
DECL|method|setClusterId (String cid)
specifier|private
specifier|synchronized
name|void
name|setClusterId
parameter_list|(
name|String
name|cid
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|clusterId
operator|!=
literal|null
operator|&&
operator|!
name|clusterId
operator|.
name|equals
argument_list|(
name|cid
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"cluster id doesn't match. old cid="
operator|+
name|clusterId
operator|+
literal|" new cid="
operator|+
name|cid
argument_list|)
throw|;
block|}
comment|// else
name|clusterId
operator|=
name|cid
expr_stmt|;
block|}
DECL|method|getHostName (Configuration config)
specifier|private
specifier|static
name|String
name|getHostName
parameter_list|(
name|Configuration
name|config
parameter_list|)
throws|throws
name|UnknownHostException
block|{
name|String
name|name
init|=
literal|null
decl_stmt|;
comment|// use configured nameserver& interface to get local hostname
if|if
condition|(
name|config
operator|.
name|get
argument_list|(
name|DFS_DATANODE_HOST_NAME_KEY
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|name
operator|=
name|config
operator|.
name|get
argument_list|(
name|DFS_DATANODE_HOST_NAME_KEY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
name|name
operator|=
name|DNS
operator|.
name|getDefaultHost
argument_list|(
name|config
operator|.
name|get
argument_list|(
literal|"dfs.datanode.dns.interface"
argument_list|,
literal|"default"
argument_list|)
argument_list|,
name|config
operator|.
name|get
argument_list|(
literal|"dfs.datanode.dns.nameserver"
argument_list|,
literal|"default"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
DECL|method|initConfig (Configuration conf)
specifier|private
name|void
name|initConfig
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|socketTimeout
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_CLIENT_SOCKET_TIMEOUT_KEY
argument_list|,
name|HdfsConstants
operator|.
name|READ_TIMEOUT
argument_list|)
expr_stmt|;
name|this
operator|.
name|socketWriteTimeout
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_DATANODE_SOCKET_WRITE_TIMEOUT_KEY
argument_list|,
name|HdfsConstants
operator|.
name|WRITE_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* Based on results on different platforms, we might need set the default       * to false on some of them. */
name|this
operator|.
name|transferToAllowed
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"dfs.datanode.transferTo.allowed"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|writePacketSize
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_CLIENT_WRITE_PACKET_SIZE_KEY
argument_list|,
name|DFS_CLIENT_WRITE_PACKET_SIZE_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|blockReportInterval
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_BLOCKREPORT_INTERVAL_MSEC_KEY
argument_list|,
name|BLOCKREPORT_INTERVAL
argument_list|)
expr_stmt|;
name|this
operator|.
name|initialBlockReportDelay
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_BLOCKREPORT_INITIAL_DELAY_KEY
argument_list|,
name|BLOCKREPORT_INITIAL_DELAY
argument_list|)
operator|*
literal|1000L
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|initialBlockReportDelay
operator|>=
name|blockReportInterval
condition|)
block|{
name|this
operator|.
name|initialBlockReportDelay
operator|=
literal|0
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"dfs.blockreport.initialDelay is greater than "
operator|+
literal|"dfs.blockreport.intervalMsec."
operator|+
literal|" Setting initial delay to 0 msec:"
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|heartBeatInterval
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_HEARTBEAT_INTERVAL_KEY
argument_list|,
name|HEARTBEAT_INTERVAL
argument_list|)
operator|*
literal|1000L
expr_stmt|;
comment|// do we need to sync block file contents to disk when blockfile is closed?
name|this
operator|.
name|syncOnClose
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_DATANODE_SYNCONCLOSE_KEY
argument_list|,
name|DFS_DATANODE_SYNCONCLOSE_DEFAULT
argument_list|)
expr_stmt|;
block|}
DECL|method|startInfoServer (Configuration conf)
specifier|private
name|void
name|startInfoServer
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// create a servlet to serve full-file content
name|InetSocketAddress
name|infoSocAddr
init|=
name|DataNode
operator|.
name|getInfoAddr
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|String
name|infoHost
init|=
name|infoSocAddr
operator|.
name|getHostName
argument_list|()
decl_stmt|;
name|int
name|tmpInfoPort
init|=
name|infoSocAddr
operator|.
name|getPort
argument_list|()
decl_stmt|;
name|this
operator|.
name|infoServer
operator|=
operator|(
name|secureResources
operator|==
literal|null
operator|)
condition|?
operator|new
name|HttpServer
argument_list|(
literal|"datanode"
argument_list|,
name|infoHost
argument_list|,
name|tmpInfoPort
argument_list|,
name|tmpInfoPort
operator|==
literal|0
argument_list|,
name|conf
argument_list|,
operator|new
name|AccessControlList
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_ADMIN
argument_list|,
literal|" "
argument_list|)
argument_list|)
argument_list|)
else|:
operator|new
name|HttpServer
argument_list|(
literal|"datanode"
argument_list|,
name|infoHost
argument_list|,
name|tmpInfoPort
argument_list|,
name|tmpInfoPort
operator|==
literal|0
argument_list|,
name|conf
argument_list|,
operator|new
name|AccessControlList
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_ADMIN
argument_list|,
literal|" "
argument_list|)
argument_list|)
argument_list|,
name|secureResources
operator|.
name|getListener
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Datanode listening on "
operator|+
name|infoHost
operator|+
literal|":"
operator|+
name|tmpInfoPort
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"dfs.https.enable"
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|boolean
name|needClientAuth
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFS_CLIENT_HTTPS_NEED_AUTH_KEY
argument_list|,
name|DFS_CLIENT_HTTPS_NEED_AUTH_DEFAULT
argument_list|)
decl_stmt|;
name|InetSocketAddress
name|secInfoSocAddr
init|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|conf
operator|.
name|get
argument_list|(
literal|"dfs.datanode.https.address"
argument_list|,
name|infoHost
operator|+
literal|":"
operator|+
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|Configuration
name|sslConf
init|=
operator|new
name|HdfsConfiguration
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|sslConf
operator|.
name|addResource
argument_list|(
name|conf
operator|.
name|get
argument_list|(
literal|"dfs.https.server.keystore.resource"
argument_list|,
literal|"ssl-server.xml"
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|addSslListener
argument_list|(
name|secInfoSocAddr
argument_list|,
name|sslConf
argument_list|,
name|needClientAuth
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Datanode listening for SSL on "
operator|+
name|secInfoSocAddr
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|infoServer
operator|.
name|addInternalServlet
argument_list|(
literal|null
argument_list|,
literal|"/streamFile/*"
argument_list|,
name|StreamFile
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|addInternalServlet
argument_list|(
literal|null
argument_list|,
literal|"/getFileChecksum/*"
argument_list|,
name|FileChecksumServlets
operator|.
name|GetServlet
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|setAttribute
argument_list|(
literal|"datanode"
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|setAttribute
argument_list|(
name|JspHelper
operator|.
name|CURRENT_CONF
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|addServlet
argument_list|(
literal|null
argument_list|,
literal|"/blockScannerReport"
argument_list|,
name|DataBlockScanner
operator|.
name|Servlet
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|infoServer
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|startPlugins (Configuration conf)
specifier|private
name|void
name|startPlugins
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|plugins
operator|=
name|conf
operator|.
name|getInstances
argument_list|(
literal|"dfs.datanode.plugins"
argument_list|,
name|ServicePlugin
operator|.
name|class
argument_list|)
expr_stmt|;
for|for
control|(
name|ServicePlugin
name|p
range|:
name|plugins
control|)
block|{
try|try
block|{
name|p
operator|.
name|start
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Started plug-in "
operator|+
name|p
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ServicePlugin "
operator|+
name|p
operator|+
literal|" could not be started"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|initIpcServer (Configuration conf)
specifier|private
name|void
name|initIpcServer
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|InetSocketAddress
name|ipcAddr
init|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|conf
operator|.
name|get
argument_list|(
literal|"dfs.datanode.ipc.address"
argument_list|)
argument_list|)
decl_stmt|;
name|ipcServer
operator|=
name|RPC
operator|.
name|getServer
argument_list|(
name|DataNode
operator|.
name|class
argument_list|,
name|this
argument_list|,
name|ipcAddr
operator|.
name|getHostName
argument_list|()
argument_list|,
name|ipcAddr
operator|.
name|getPort
argument_list|()
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_DATANODE_HANDLER_COUNT_KEY
argument_list|,
name|DFS_DATANODE_HANDLER_COUNT_DEFAULT
argument_list|)
argument_list|,
literal|false
argument_list|,
name|conf
argument_list|,
name|blockPoolTokenSecretManager
argument_list|)
expr_stmt|;
comment|// set service-level authorization security policy
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|CommonConfigurationKeys
operator|.
name|HADOOP_SECURITY_AUTHORIZATION
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|ipcServer
operator|.
name|refreshServiceAcl
argument_list|(
name|conf
argument_list|,
operator|new
name|HDFSPolicyProvider
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**  * Initialize the datanode's periodic scanners:  *     {@link DataBlockScanner}  *     {@link DirectoryScanner}  * They report results on a per-blockpool basis but do their scanning   * on a per-Volume basis to minimize competition for disk iops.  *   * @param conf - Configuration has the run intervals and other   *               parameters for these periodic scanners  */
DECL|method|initPeriodicScanners (Configuration conf)
specifier|private
name|void
name|initPeriodicScanners
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|initDataBlockScanner
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|initDirectoryScanner
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
DECL|method|shutdownPeriodicScanners ()
specifier|private
name|void
name|shutdownPeriodicScanners
parameter_list|()
block|{
name|shutdownDirectoryScanner
argument_list|()
expr_stmt|;
name|shutdownDataBlockScanner
argument_list|()
expr_stmt|;
block|}
comment|/**    * See {@link DataBlockScanner}    */
DECL|method|initDataBlockScanner (Configuration conf)
specifier|private
specifier|synchronized
name|void
name|initDataBlockScanner
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
if|if
condition|(
name|blockScanner
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
name|String
name|reason
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_DATANODE_SCAN_PERIOD_HOURS_KEY
argument_list|,
name|DFS_DATANODE_SCAN_PERIOD_HOURS_DEFAULT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|reason
operator|=
literal|"verification is turned off by configuration"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|data
operator|instanceof
name|FSDataset
operator|)
condition|)
block|{
name|reason
operator|=
literal|"verifcation is supported only with FSDataset"
expr_stmt|;
block|}
if|if
condition|(
name|reason
operator|==
literal|null
condition|)
block|{
name|blockScanner
operator|=
operator|new
name|DataBlockScanner
argument_list|(
name|this
argument_list|,
operator|(
name|FSDataset
operator|)
name|data
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|blockScanner
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Periodic Block Verification scan is disabled because "
operator|+
name|reason
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|shutdownDataBlockScanner ()
specifier|private
name|void
name|shutdownDataBlockScanner
parameter_list|()
block|{
if|if
condition|(
name|blockScanner
operator|!=
literal|null
condition|)
block|{
name|blockScanner
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * See {@link DirectoryScanner}    */
DECL|method|initDirectoryScanner (Configuration conf)
specifier|private
specifier|synchronized
name|void
name|initDirectoryScanner
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
if|if
condition|(
name|directoryScanner
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
name|String
name|reason
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|conf
operator|.
name|getInt
argument_list|(
name|DFS_DATANODE_DIRECTORYSCAN_INTERVAL_KEY
argument_list|,
name|DFS_DATANODE_DIRECTORYSCAN_INTERVAL_DEFAULT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|reason
operator|=
literal|"verification is turned off by configuration"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|data
operator|instanceof
name|FSDataset
operator|)
condition|)
block|{
name|reason
operator|=
literal|"verification is supported only with FSDataset"
expr_stmt|;
block|}
if|if
condition|(
name|reason
operator|==
literal|null
condition|)
block|{
name|directoryScanner
operator|=
operator|new
name|DirectoryScanner
argument_list|(
name|this
argument_list|,
operator|(
name|FSDataset
operator|)
name|data
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|directoryScanner
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Periodic Directory Tree Verification scan is disabled because "
operator|+
name|reason
operator|+
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|shutdownDirectoryScanner ()
specifier|private
specifier|synchronized
name|void
name|shutdownDirectoryScanner
parameter_list|()
block|{
if|if
condition|(
name|directoryScanner
operator|!=
literal|null
condition|)
block|{
name|directoryScanner
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|initDataXceiver (Configuration conf)
specifier|private
name|void
name|initDataXceiver
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|InetSocketAddress
name|socAddr
init|=
name|DataNode
operator|.
name|getStreamingAddr
argument_list|(
name|conf
argument_list|)
decl_stmt|;
comment|// find free port or use privileged port provided
name|ServerSocket
name|ss
decl_stmt|;
if|if
condition|(
name|secureResources
operator|==
literal|null
condition|)
block|{
name|ss
operator|=
operator|(
name|socketWriteTimeout
operator|>
literal|0
operator|)
condition|?
name|ServerSocketChannel
operator|.
name|open
argument_list|()
operator|.
name|socket
argument_list|()
else|:
operator|new
name|ServerSocket
argument_list|()
expr_stmt|;
name|Server
operator|.
name|bind
argument_list|(
name|ss
argument_list|,
name|socAddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ss
operator|=
name|secureResources
operator|.
name|getStreamingSocket
argument_list|()
expr_stmt|;
block|}
name|ss
operator|.
name|setReceiveBufferSize
argument_list|(
name|DEFAULT_DATA_SOCKET_SIZE
argument_list|)
expr_stmt|;
comment|// adjust machine name with the actual port
name|int
name|tmpPort
init|=
name|ss
operator|.
name|getLocalPort
argument_list|()
decl_stmt|;
name|selfAddr
operator|=
operator|new
name|InetSocketAddress
argument_list|(
name|ss
operator|.
name|getInetAddress
argument_list|()
operator|.
name|getHostAddress
argument_list|()
argument_list|,
name|tmpPort
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Opened info server at "
operator|+
name|tmpPort
argument_list|)
expr_stmt|;
name|this
operator|.
name|threadGroup
operator|=
operator|new
name|ThreadGroup
argument_list|(
literal|"dataXceiverServer"
argument_list|)
expr_stmt|;
name|this
operator|.
name|dataXceiverServer
operator|=
operator|new
name|Daemon
argument_list|(
name|threadGroup
argument_list|,
operator|new
name|DataXceiverServer
argument_list|(
name|ss
argument_list|,
name|conf
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|threadGroup
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// auto destroy when empty
block|}
comment|// calls specific to BP
DECL|method|notifyNamenodeReceivedBlock (ExtendedBlock block, String delHint)
specifier|protected
name|void
name|notifyNamenodeReceivedBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|String
name|delHint
parameter_list|)
block|{
name|BPOfferService
name|bpos
init|=
name|blockPoolManager
operator|.
name|get
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|bpos
operator|!=
literal|null
condition|)
block|{
name|bpos
operator|.
name|notifyNamenodeReceivedBlock
argument_list|(
name|block
argument_list|,
name|delHint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot find BPOfferService for reporting block received for bpid="
operator|+
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|reportBadBlocks (ExtendedBlock block)
specifier|public
name|void
name|reportBadBlocks
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|BPOfferService
name|bpos
init|=
name|blockPoolManager
operator|.
name|get
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|bpos
operator|==
literal|null
operator|||
name|bpos
operator|.
name|bpNamenode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"cannot locate OfferService thread for bp="
operator|+
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
throw|;
block|}
name|bpos
operator|.
name|reportBadBlocks
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
comment|// used only for testing
DECL|method|setHeartbeatsDisabledForTests ( boolean heartbeatsDisabledForTests)
name|void
name|setHeartbeatsDisabledForTests
parameter_list|(
name|boolean
name|heartbeatsDisabledForTests
parameter_list|)
block|{
name|this
operator|.
name|heartbeatsDisabledForTests
operator|=
name|heartbeatsDisabledForTests
expr_stmt|;
block|}
comment|/**    * A thread per namenode to perform:    *<ul>    *<li> Pre-registration handshake with namenode</li>    *<li> Registration with namenode</li>    *<li> Send periodic heartbeats to the namenode</li>    *<li> Handle commands received from the datanode</li>    *</ul>    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|BPOfferService
class|class
name|BPOfferService
implements|implements
name|Runnable
block|{
DECL|field|nnAddr
specifier|final
name|InetSocketAddress
name|nnAddr
decl_stmt|;
DECL|field|bpRegistration
name|DatanodeRegistration
name|bpRegistration
decl_stmt|;
DECL|field|bpNSInfo
name|NamespaceInfo
name|bpNSInfo
decl_stmt|;
DECL|field|lastBlockReport
name|long
name|lastBlockReport
init|=
literal|0
decl_stmt|;
DECL|field|bpThread
specifier|private
name|Thread
name|bpThread
decl_stmt|;
DECL|field|bpNamenode
specifier|private
name|DatanodeProtocol
name|bpNamenode
decl_stmt|;
DECL|field|blockPoolId
specifier|private
name|String
name|blockPoolId
decl_stmt|;
DECL|field|lastHeartbeat
specifier|private
name|long
name|lastHeartbeat
init|=
literal|0
decl_stmt|;
DECL|field|initialized
specifier|private
specifier|volatile
name|boolean
name|initialized
init|=
literal|false
decl_stmt|;
DECL|field|receivedBlockList
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|Block
argument_list|>
name|receivedBlockList
init|=
operator|new
name|LinkedList
argument_list|<
name|Block
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|delHints
specifier|private
specifier|final
name|LinkedList
argument_list|<
name|String
argument_list|>
name|delHints
init|=
operator|new
name|LinkedList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|shouldServiceRun
specifier|private
specifier|volatile
name|boolean
name|shouldServiceRun
init|=
literal|true
decl_stmt|;
DECL|field|isBlockTokenInitialized
specifier|private
name|boolean
name|isBlockTokenInitialized
init|=
literal|false
decl_stmt|;
DECL|field|upgradeManager
name|UpgradeManagerDatanode
name|upgradeManager
init|=
literal|null
decl_stmt|;
DECL|method|BPOfferService (InetSocketAddress isa)
name|BPOfferService
parameter_list|(
name|InetSocketAddress
name|isa
parameter_list|)
block|{
name|this
operator|.
name|bpRegistration
operator|=
operator|new
name|DatanodeRegistration
argument_list|(
name|getMachineName
argument_list|()
argument_list|)
expr_stmt|;
name|bpRegistration
operator|.
name|setInfoPort
argument_list|(
name|infoServer
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
name|bpRegistration
operator|.
name|setIpcPort
argument_list|(
name|getIpcPort
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|nnAddr
operator|=
name|isa
expr_stmt|;
block|}
comment|/**      * returns true if BP thread has completed initialization of storage      * and has registered with the corresponding namenode      * @return true if initialized      */
DECL|method|initialized ()
specifier|public
name|boolean
name|initialized
parameter_list|()
block|{
return|return
name|initialized
return|;
block|}
DECL|method|isAlive ()
specifier|public
name|boolean
name|isAlive
parameter_list|()
block|{
return|return
name|shouldServiceRun
operator|&&
name|bpThread
operator|.
name|isAlive
argument_list|()
return|;
block|}
DECL|method|getBlockPoolId ()
specifier|public
name|String
name|getBlockPoolId
parameter_list|()
block|{
return|return
name|blockPoolId
return|;
block|}
DECL|method|getNNSocketAddress ()
specifier|private
name|InetSocketAddress
name|getNNSocketAddress
parameter_list|()
block|{
return|return
name|nnAddr
return|;
block|}
DECL|method|setNamespaceInfo (NamespaceInfo nsinfo)
name|void
name|setNamespaceInfo
parameter_list|(
name|NamespaceInfo
name|nsinfo
parameter_list|)
block|{
name|bpNSInfo
operator|=
name|nsinfo
expr_stmt|;
name|this
operator|.
name|blockPoolId
operator|=
name|nsinfo
operator|.
name|getBlockPoolID
argument_list|()
expr_stmt|;
name|blockPoolManager
operator|.
name|addBlockPool
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|setNameNode (DatanodeProtocol dnProtocol)
name|void
name|setNameNode
parameter_list|(
name|DatanodeProtocol
name|dnProtocol
parameter_list|)
block|{
name|bpNamenode
operator|=
name|dnProtocol
expr_stmt|;
block|}
DECL|method|handshake ()
specifier|private
name|NamespaceInfo
name|handshake
parameter_list|()
throws|throws
name|IOException
block|{
name|NamespaceInfo
name|nsInfo
init|=
operator|new
name|NamespaceInfo
argument_list|()
decl_stmt|;
while|while
condition|(
name|shouldRun
operator|&&
name|shouldServiceRun
condition|)
block|{
try|try
block|{
name|nsInfo
operator|=
name|bpNamenode
operator|.
name|versionRequest
argument_list|()
expr_stmt|;
comment|// verify build version
name|String
name|nsVer
init|=
name|nsInfo
operator|.
name|getBuildVersion
argument_list|()
decl_stmt|;
name|String
name|stVer
init|=
name|Storage
operator|.
name|getBuildVersion
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"handshake: namespace info = "
operator|+
name|nsInfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nsVer
operator|.
name|equals
argument_list|(
name|stVer
argument_list|)
condition|)
block|{
name|String
name|errorMsg
init|=
literal|"Incompatible build versions: bp = "
operator|+
name|blockPoolId
operator|+
literal|"namenode BV = "
operator|+
name|nsVer
operator|+
literal|"; datanode BV = "
operator|+
name|stVer
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|errorMsg
argument_list|)
expr_stmt|;
name|bpNamenode
operator|.
name|errorReport
argument_list|(
name|bpRegistration
argument_list|,
name|DatanodeProtocol
operator|.
name|NOTIFY
argument_list|,
name|errorMsg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|SocketTimeoutException
name|e
parameter_list|)
block|{
comment|// namenode is busy
name|LOG
operator|.
name|warn
argument_list|(
literal|"Problem connecting to server: "
operator|+
name|nnAddr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// namenode is not available
name|LOG
operator|.
name|warn
argument_list|(
literal|"Problem connecting to server: "
operator|+
name|nnAddr
argument_list|)
expr_stmt|;
block|}
comment|// try again in a second
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{}
block|}
assert|assert
name|FSConstants
operator|.
name|LAYOUT_VERSION
operator|==
name|nsInfo
operator|.
name|getLayoutVersion
argument_list|()
operator|:
literal|"Data-node and name-node layout versions must be the same."
operator|+
literal|"Expected: "
operator|+
name|FSConstants
operator|.
name|LAYOUT_VERSION
operator|+
literal|" actual "
operator|+
name|nsInfo
operator|.
name|getLayoutVersion
argument_list|()
assert|;
return|return
name|nsInfo
return|;
block|}
DECL|method|setupBP (Configuration conf, AbstractList<File> dataDirs)
name|void
name|setupBP
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|AbstractList
argument_list|<
name|File
argument_list|>
name|dataDirs
parameter_list|)
throws|throws
name|IOException
block|{
comment|// get NN proxy
name|DatanodeProtocol
name|dnp
init|=
operator|(
name|DatanodeProtocol
operator|)
name|RPC
operator|.
name|waitForProxy
argument_list|(
name|DatanodeProtocol
operator|.
name|class
argument_list|,
name|DatanodeProtocol
operator|.
name|versionID
argument_list|,
name|nnAddr
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|setNameNode
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
comment|// handshake with NN
name|NamespaceInfo
name|nsInfo
init|=
name|handshake
argument_list|()
decl_stmt|;
name|setNamespaceInfo
argument_list|(
name|nsInfo
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|DataNode
operator|.
name|this
init|)
block|{
comment|// we do not allow namenode from different cluster to register
if|if
condition|(
name|clusterId
operator|!=
literal|null
operator|&&
operator|!
name|clusterId
operator|.
name|equals
argument_list|(
name|nsInfo
operator|.
name|clusterID
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"cannot register with the namenode because clusterid do not match:"
operator|+
literal|" nn="
operator|+
name|nsInfo
operator|.
name|getBlockPoolID
argument_list|()
operator|+
literal|"; nn cid="
operator|+
name|nsInfo
operator|.
name|clusterID
operator|+
literal|";dn cid="
operator|+
name|clusterId
argument_list|)
throw|;
block|}
name|setupBPStorage
argument_list|()
expr_stmt|;
name|setClusterId
argument_list|(
name|nsInfo
operator|.
name|clusterID
argument_list|)
expr_stmt|;
block|}
name|initPeriodicScanners
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
DECL|method|setupBPStorage ()
name|void
name|setupBPStorage
parameter_list|()
throws|throws
name|IOException
block|{
name|StartupOption
name|startOpt
init|=
name|getStartupOption
argument_list|(
name|conf
argument_list|)
decl_stmt|;
assert|assert
name|startOpt
operator|!=
literal|null
operator|:
literal|"Startup option must be set."
assert|;
name|boolean
name|simulatedFSDataset
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"dfs.datanode.simulateddatastorage"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|simulatedFSDataset
condition|)
block|{
name|initFsDataSet
argument_list|(
name|conf
argument_list|,
name|dataDirs
argument_list|)
expr_stmt|;
name|bpRegistration
operator|.
name|setStorageID
argument_list|(
name|getStorageId
argument_list|()
argument_list|)
expr_stmt|;
comment|//same as DN
name|bpRegistration
operator|.
name|storageInfo
operator|.
name|layoutVersion
operator|=
name|FSConstants
operator|.
name|LAYOUT_VERSION
expr_stmt|;
name|bpRegistration
operator|.
name|storageInfo
operator|.
name|namespaceID
operator|=
name|bpNSInfo
operator|.
name|namespaceID
expr_stmt|;
name|bpRegistration
operator|.
name|storageInfo
operator|.
name|clusterID
operator|=
name|bpNSInfo
operator|.
name|clusterID
expr_stmt|;
block|}
else|else
block|{
comment|// read storage info, lock data dirs and transition fs state if necessary
name|storage
operator|.
name|recoverTransitionRead
argument_list|(
name|DataNode
operator|.
name|this
argument_list|,
name|blockPoolId
argument_list|,
name|bpNSInfo
argument_list|,
name|dataDirs
argument_list|,
name|startOpt
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"setting up storage: nsid="
operator|+
name|storage
operator|.
name|namespaceID
operator|+
literal|";bpid="
operator|+
name|blockPoolId
operator|+
literal|";lv="
operator|+
name|storage
operator|.
name|layoutVersion
operator|+
literal|";nsInfo="
operator|+
name|bpNSInfo
argument_list|)
expr_stmt|;
name|bpRegistration
operator|.
name|setStorageID
argument_list|(
name|getStorageId
argument_list|()
argument_list|)
expr_stmt|;
name|bpRegistration
operator|.
name|setStorageInfo
argument_list|(
name|storage
operator|.
name|getBPStorage
argument_list|(
name|blockPoolId
argument_list|)
argument_list|)
expr_stmt|;
name|initFsDataSet
argument_list|(
name|conf
argument_list|,
name|dataDirs
argument_list|)
expr_stmt|;
block|}
name|data
operator|.
name|addBlockPool
argument_list|(
name|blockPoolId
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**      * This methods  arranges for the data node to send the block report at       * the next heartbeat.      */
DECL|method|scheduleBlockReport (long delay)
name|void
name|scheduleBlockReport
parameter_list|(
name|long
name|delay
parameter_list|)
block|{
if|if
condition|(
name|delay
operator|>
literal|0
condition|)
block|{
comment|// send BR after random delay
name|lastBlockReport
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
operator|(
name|blockReportInterval
operator|-
name|R
operator|.
name|nextInt
argument_list|(
call|(
name|int
call|)
argument_list|(
name|delay
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// send at next heartbeat
name|lastBlockReport
operator|=
name|lastHeartbeat
operator|-
name|blockReportInterval
expr_stmt|;
block|}
name|resetBlockReportTime
operator|=
literal|true
expr_stmt|;
comment|// reset future BRs for randomness
block|}
DECL|method|reportBadBlocks (ExtendedBlock block)
specifier|private
name|void
name|reportBadBlocks
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|)
block|{
name|DatanodeInfo
index|[]
name|dnArr
init|=
block|{
operator|new
name|DatanodeInfo
argument_list|(
name|bpRegistration
argument_list|)
block|}
decl_stmt|;
name|LocatedBlock
index|[]
name|blocks
init|=
block|{
operator|new
name|LocatedBlock
argument_list|(
name|block
argument_list|,
name|dnArr
argument_list|)
block|}
decl_stmt|;
try|try
block|{
name|bpNamenode
operator|.
name|reportBadBlocks
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|/* One common reason is that NameNode could be in safe mode.          * Should we keep on retrying in that case?          */
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to report bad block "
operator|+
name|block
operator|+
literal|" to namenode : "
operator|+
literal|" Exception : "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Report received blocks and delete hints to the Namenode      * @throws IOException      */
DECL|method|reportReceivedBlocks ()
specifier|private
name|void
name|reportReceivedBlocks
parameter_list|()
throws|throws
name|IOException
block|{
comment|//check if there are newly received blocks
name|Block
index|[]
name|blockArray
init|=
literal|null
decl_stmt|;
name|String
index|[]
name|delHintArray
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|receivedBlockList
init|)
block|{
synchronized|synchronized
init|(
name|delHints
init|)
block|{
name|int
name|numBlocks
init|=
name|receivedBlockList
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|numBlocks
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|numBlocks
operator|!=
name|delHints
operator|.
name|size
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Panic: receiveBlockList and delHints are not of "
operator|+
literal|"the same length"
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Send newly-received blockids to namenode
comment|//
name|blockArray
operator|=
name|receivedBlockList
operator|.
name|toArray
argument_list|(
operator|new
name|Block
index|[
name|numBlocks
index|]
argument_list|)
expr_stmt|;
name|delHintArray
operator|=
name|delHints
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|numBlocks
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|blockArray
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|delHintArray
operator|==
literal|null
operator|||
name|delHintArray
operator|.
name|length
operator|!=
name|blockArray
operator|.
name|length
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Panic: block array& delHintArray are not the same"
argument_list|)
expr_stmt|;
block|}
name|bpNamenode
operator|.
name|blockReceived
argument_list|(
name|bpRegistration
argument_list|,
name|blockPoolId
argument_list|,
name|blockArray
argument_list|,
name|delHintArray
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|receivedBlockList
init|)
block|{
synchronized|synchronized
init|(
name|delHints
init|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blockArray
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|receivedBlockList
operator|.
name|remove
argument_list|(
name|blockArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|delHints
operator|.
name|remove
argument_list|(
name|delHintArray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/*      * Informing the name node could take a long long time! Should we wait      * till namenode is informed before responding with success to the      * client? For now we don't.      */
DECL|method|notifyNamenodeReceivedBlock (ExtendedBlock block, String delHint)
name|void
name|notifyNamenodeReceivedBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|String
name|delHint
parameter_list|)
block|{
if|if
condition|(
name|block
operator|==
literal|null
operator|||
name|delHint
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|block
operator|==
literal|null
condition|?
literal|"Block is null"
else|:
literal|"delHint is null"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|block
operator|.
name|getBlockPoolId
argument_list|()
operator|.
name|equals
argument_list|(
name|blockPoolId
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"BlockPool mismatch "
operator|+
name|block
operator|.
name|getBlockPoolId
argument_list|()
operator|+
literal|" vs. "
operator|+
name|blockPoolId
argument_list|)
expr_stmt|;
return|return;
block|}
synchronized|synchronized
init|(
name|receivedBlockList
init|)
block|{
synchronized|synchronized
init|(
name|delHints
init|)
block|{
name|receivedBlockList
operator|.
name|add
argument_list|(
name|block
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
expr_stmt|;
name|delHints
operator|.
name|add
argument_list|(
name|delHint
argument_list|)
expr_stmt|;
name|receivedBlockList
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Report the list blocks to the Namenode      * @throws IOException      */
DECL|method|blockReport ()
name|DatanodeCommand
name|blockReport
parameter_list|()
throws|throws
name|IOException
block|{
comment|// send block report if timer has expired.
name|DatanodeCommand
name|cmd
init|=
literal|null
decl_stmt|;
name|long
name|startTime
init|=
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
name|startTime
operator|-
name|lastBlockReport
operator|>
name|blockReportInterval
condition|)
block|{
comment|// Create block report
name|long
name|brCreateStartTime
init|=
name|now
argument_list|()
decl_stmt|;
name|BlockListAsLongs
name|bReport
init|=
name|data
operator|.
name|getBlockReport
argument_list|(
name|blockPoolId
argument_list|)
decl_stmt|;
comment|// Send block report
name|long
name|brSendStartTime
init|=
name|now
argument_list|()
decl_stmt|;
name|cmd
operator|=
name|bpNamenode
operator|.
name|blockReport
argument_list|(
name|bpRegistration
argument_list|,
name|blockPoolId
argument_list|,
name|bReport
operator|.
name|getBlockListAsLongs
argument_list|()
argument_list|)
expr_stmt|;
comment|// Log the block report processing stats from Datanode perspective
name|long
name|brSendCost
init|=
name|now
argument_list|()
operator|-
name|brSendStartTime
decl_stmt|;
name|long
name|brCreateCost
init|=
name|brSendStartTime
operator|-
name|brCreateStartTime
decl_stmt|;
name|metrics
operator|.
name|addBlockReport
argument_list|(
name|brSendCost
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"BlockReport of "
operator|+
name|bReport
operator|.
name|getNumberOfBlocks
argument_list|()
operator|+
literal|" blocks took "
operator|+
name|brCreateCost
operator|+
literal|" msec to generate and "
operator|+
name|brSendCost
operator|+
literal|" msecs for RPC and NN processing"
argument_list|)
expr_stmt|;
comment|// If we have sent the first block report, then wait a random
comment|// time before we start the periodic block reports.
if|if
condition|(
name|resetBlockReportTime
condition|)
block|{
name|lastBlockReport
operator|=
name|startTime
operator|-
name|R
operator|.
name|nextInt
argument_list|(
call|(
name|int
call|)
argument_list|(
name|blockReportInterval
argument_list|)
argument_list|)
expr_stmt|;
name|resetBlockReportTime
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|/* say the last block report was at 8:20:14. The current report            * should have started around 9:20:14 (default 1 hour interval).            * If current time is :            *   1) normal like 9:20:18, next report should be at 10:20:14            *   2) unexpected like 11:35:43, next report should be at 12:20:14            */
name|lastBlockReport
operator|+=
operator|(
name|now
argument_list|()
operator|-
name|lastBlockReport
operator|)
operator|/
name|blockReportInterval
operator|*
name|blockReportInterval
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"sent block report, processed command:"
operator|+
name|cmd
argument_list|)
expr_stmt|;
block|}
return|return
name|cmd
return|;
block|}
DECL|method|sendHeartBeat ()
name|DatanodeCommand
index|[]
name|sendHeartBeat
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|bpNamenode
operator|.
name|sendHeartbeat
argument_list|(
name|bpRegistration
argument_list|,
name|data
operator|.
name|getCapacity
argument_list|()
argument_list|,
name|data
operator|.
name|getDfsUsed
argument_list|()
argument_list|,
name|data
operator|.
name|getRemaining
argument_list|()
argument_list|,
name|data
operator|.
name|getBlockPoolUsed
argument_list|(
name|blockPoolId
argument_list|)
argument_list|,
name|xmitsInProgress
operator|.
name|get
argument_list|()
argument_list|,
name|getXceiverCount
argument_list|()
argument_list|,
name|data
operator|.
name|getNumFailedVolumes
argument_list|()
argument_list|)
return|;
block|}
comment|//This must be called only by blockPoolManager
DECL|method|start ()
name|void
name|start
parameter_list|()
block|{
if|if
condition|(
operator|(
name|bpThread
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|bpThread
operator|.
name|isAlive
argument_list|()
operator|)
condition|)
block|{
comment|//Thread is started already
return|return;
block|}
name|bpThread
operator|=
operator|new
name|Thread
argument_list|(
name|this
argument_list|,
name|dnThreadName
argument_list|)
expr_stmt|;
name|bpThread
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// needed for JUnit testing
name|bpThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|//This must be called only by blockPoolManager.
DECL|method|stop ()
name|void
name|stop
parameter_list|()
block|{
name|shouldServiceRun
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|bpThread
operator|!=
literal|null
condition|)
block|{
name|bpThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
comment|//This must be called only by blockPoolManager
DECL|method|join ()
name|void
name|join
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|bpThread
operator|!=
literal|null
condition|)
block|{
name|bpThread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{ }
block|}
comment|//Cleanup method to be called by current thread before exiting.
DECL|method|cleanUp ()
specifier|private
specifier|synchronized
name|void
name|cleanUp
parameter_list|()
block|{
if|if
condition|(
name|upgradeManager
operator|!=
literal|null
condition|)
name|upgradeManager
operator|.
name|shutdownUpgrade
argument_list|()
expr_stmt|;
name|blockPoolManager
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|shouldServiceRun
operator|=
literal|false
expr_stmt|;
name|RPC
operator|.
name|stopProxy
argument_list|(
name|bpNamenode
argument_list|)
expr_stmt|;
if|if
condition|(
name|blockScanner
operator|!=
literal|null
condition|)
block|{
name|blockScanner
operator|.
name|removeBlockPool
argument_list|(
name|this
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
name|data
operator|.
name|shutdownBlockPool
argument_list|(
name|this
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|storage
operator|!=
literal|null
condition|)
block|{
name|storage
operator|.
name|removeBlockPoolStorage
argument_list|(
name|this
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Main loop for each BP thread. Run until shutdown,      * forever calling remote NameNode functions.      */
DECL|method|offerService ()
specifier|private
name|void
name|offerService
parameter_list|()
throws|throws
name|Exception
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"For namenode "
operator|+
name|nnAddr
operator|+
literal|" using BLOCKREPORT_INTERVAL of "
operator|+
name|blockReportInterval
operator|+
literal|"msec"
operator|+
literal|" Initial delay: "
operator|+
name|initialBlockReportDelay
operator|+
literal|"msec"
operator|+
literal|"; heartBeatInterval="
operator|+
name|heartBeatInterval
argument_list|)
expr_stmt|;
comment|//
comment|// Now loop for a long time....
comment|//
while|while
condition|(
name|shouldRun
operator|&&
name|shouldServiceRun
condition|)
block|{
try|try
block|{
name|long
name|startTime
init|=
name|now
argument_list|()
decl_stmt|;
comment|//
comment|// Every so often, send heartbeat or block-report
comment|//
if|if
condition|(
name|startTime
operator|-
name|lastHeartbeat
operator|>
name|heartBeatInterval
condition|)
block|{
comment|//
comment|// All heartbeat messages include following info:
comment|// -- Datanode name
comment|// -- data transfer port
comment|// -- Total capacity
comment|// -- Bytes remaining
comment|//
name|lastHeartbeat
operator|=
name|startTime
expr_stmt|;
if|if
condition|(
operator|!
name|heartbeatsDisabledForTests
condition|)
block|{
name|DatanodeCommand
index|[]
name|cmds
init|=
name|sendHeartBeat
argument_list|()
decl_stmt|;
name|metrics
operator|.
name|addHeartbeat
argument_list|(
name|now
argument_list|()
operator|-
name|startTime
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|processCommand
argument_list|(
name|cmds
argument_list|)
condition|)
continue|continue;
block|}
block|}
name|reportReceivedBlocks
argument_list|()
expr_stmt|;
name|DatanodeCommand
name|cmd
init|=
name|blockReport
argument_list|()
decl_stmt|;
name|processCommand
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|// Now safe to start scanning the block pool
if|if
condition|(
name|blockScanner
operator|!=
literal|null
condition|)
block|{
name|blockScanner
operator|.
name|addBlockPool
argument_list|(
name|this
operator|.
name|blockPoolId
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// There is no work to do;  sleep until hearbeat timer elapses,
comment|// or work arrives, and then iterate again.
comment|//
name|long
name|waitTime
init|=
name|heartBeatInterval
operator|-
operator|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|lastHeartbeat
operator|)
decl_stmt|;
synchronized|synchronized
init|(
name|receivedBlockList
init|)
block|{
if|if
condition|(
name|waitTime
operator|>
literal|0
operator|&&
name|receivedBlockList
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
try|try
block|{
name|receivedBlockList
operator|.
name|wait
argument_list|(
name|waitTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"BPOfferService for block pool="
operator|+
name|this
operator|.
name|getBlockPoolId
argument_list|()
operator|+
literal|" received exception:"
operator|+
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// synchronized
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
name|String
name|reClass
init|=
name|re
operator|.
name|getClassName
argument_list|()
decl_stmt|;
if|if
condition|(
name|UnregisteredNodeException
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|reClass
argument_list|)
operator|||
name|DisallowedDatanodeException
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|reClass
argument_list|)
operator|||
name|IncorrectVersionException
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|reClass
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"blockpool "
operator|+
name|blockPoolId
operator|+
literal|" is shutting down: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|re
argument_list|)
argument_list|)
expr_stmt|;
name|shouldServiceRun
operator|=
literal|false
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|warn
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|re
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|long
name|sleepTime
init|=
name|Math
operator|.
name|min
argument_list|(
literal|1000
argument_list|,
name|heartBeatInterval
argument_list|)
decl_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// while (shouldRun&& shouldServiceRun)
block|}
comment|// offerService
comment|/**      * Register one bp with the corresponding NameNode      *<p>      * The bpDatanode needs to register with the namenode on startup in order      * 1) to report which storage it is serving now and       * 2) to receive a registrationID      *        * issued by the namenode to recognize registered datanodes.      *       * @see FSNamesystem#registerDatanode(DatanodeRegistration)      * @throws IOException      */
DECL|method|register ()
name|void
name|register
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"in register: sid="
operator|+
name|bpRegistration
operator|.
name|getStorageID
argument_list|()
operator|+
literal|";SI="
operator|+
name|bpRegistration
operator|.
name|storageInfo
argument_list|)
expr_stmt|;
while|while
condition|(
name|shouldRun
operator|&&
name|shouldServiceRun
condition|)
block|{
try|try
block|{
comment|// Use returned registration from namenode with updated machine name.
name|bpRegistration
operator|=
name|bpNamenode
operator|.
name|registerDatanode
argument_list|(
name|bpRegistration
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"bpReg after ="
operator|+
name|bpRegistration
operator|.
name|storageInfo
operator|+
literal|";sid="
operator|+
name|bpRegistration
operator|.
name|storageID
operator|+
literal|";name="
operator|+
name|bpRegistration
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|NetUtils
operator|.
name|getHostname
argument_list|()
expr_stmt|;
name|hostName
operator|=
name|bpRegistration
operator|.
name|getHost
argument_list|()
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|SocketTimeoutException
name|e
parameter_list|)
block|{
comment|// namenode is busy
name|LOG
operator|.
name|info
argument_list|(
literal|"Problem connecting to server: "
operator|+
name|nnAddr
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{}
block|}
block|}
if|if
condition|(
name|storage
operator|.
name|getStorageID
argument_list|()
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
name|storage
operator|.
name|setStorageID
argument_list|(
name|bpRegistration
operator|.
name|getStorageID
argument_list|()
argument_list|)
expr_stmt|;
name|storage
operator|.
name|writeAll
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"New storage id "
operator|+
name|bpRegistration
operator|.
name|getStorageID
argument_list|()
operator|+
literal|" is assigned to data-node "
operator|+
name|bpRegistration
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|storage
operator|.
name|getStorageID
argument_list|()
operator|.
name|equals
argument_list|(
name|bpRegistration
operator|.
name|getStorageID
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Inconsistent storage IDs. Name-node returned "
operator|+
name|bpRegistration
operator|.
name|getStorageID
argument_list|()
operator|+
literal|". Expecting "
operator|+
name|storage
operator|.
name|getStorageID
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|isBlockTokenInitialized
condition|)
block|{
comment|/* first time registering with NN */
name|ExportedBlockKeys
name|keys
init|=
name|bpRegistration
operator|.
name|exportedKeys
decl_stmt|;
name|isBlockTokenEnabled
operator|=
name|keys
operator|.
name|isBlockTokenEnabled
argument_list|()
expr_stmt|;
if|if
condition|(
name|isBlockTokenEnabled
condition|)
block|{
name|long
name|blockKeyUpdateInterval
init|=
name|keys
operator|.
name|getKeyUpdateInterval
argument_list|()
decl_stmt|;
name|long
name|blockTokenLifetime
init|=
name|keys
operator|.
name|getTokenLifetime
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Block token params received from NN: for block pool "
operator|+
name|blockPoolId
operator|+
literal|" keyUpdateInterval="
operator|+
name|blockKeyUpdateInterval
operator|/
operator|(
literal|60
operator|*
literal|1000
operator|)
operator|+
literal|" min(s), tokenLifetime="
operator|+
name|blockTokenLifetime
operator|/
operator|(
literal|60
operator|*
literal|1000
operator|)
operator|+
literal|" min(s)"
argument_list|)
expr_stmt|;
specifier|final
name|BlockTokenSecretManager
name|secretMgr
init|=
operator|new
name|BlockTokenSecretManager
argument_list|(
literal|false
argument_list|,
literal|0
argument_list|,
name|blockTokenLifetime
argument_list|)
decl_stmt|;
name|blockPoolTokenSecretManager
operator|.
name|addBlockPool
argument_list|(
name|blockPoolId
argument_list|,
name|secretMgr
argument_list|)
expr_stmt|;
block|}
name|isBlockTokenInitialized
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|isBlockTokenEnabled
condition|)
block|{
name|blockPoolTokenSecretManager
operator|.
name|setKeys
argument_list|(
name|blockPoolId
argument_list|,
name|bpRegistration
operator|.
name|exportedKeys
argument_list|)
expr_stmt|;
name|bpRegistration
operator|.
name|exportedKeys
operator|=
name|ExportedBlockKeys
operator|.
name|DUMMY_KEYS
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"in register:"
operator|+
literal|";bpDNR="
operator|+
name|bpRegistration
operator|.
name|storageInfo
argument_list|)
expr_stmt|;
comment|// random short delay - helps scatter the BR from all DNs
name|scheduleBlockReport
argument_list|(
name|initialBlockReportDelay
argument_list|)
expr_stmt|;
block|}
comment|/**      * No matter what kind of exception we get, keep retrying to offerService().      * That's the loop that connects to the NameNode and provides basic DataNode      * functionality.      *      * Only stop when "shouldRun" or "shouldServiceRun" is turned off, which can      * happen either at shutdown or due to refreshNamenodes.      */
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
name|bpRegistration
operator|+
literal|"In BPOfferService.run, data = "
operator|+
name|data
operator|+
literal|";bp="
operator|+
name|blockPoolId
argument_list|)
expr_stmt|;
try|try
block|{
comment|// init stuff
try|try
block|{
comment|// setup storage
name|setupBP
argument_list|(
name|conf
argument_list|,
name|dataDirs
argument_list|)
expr_stmt|;
name|register
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// Initial handshake, storage recovery or registration failed
comment|// End BPOfferService thread
name|LOG
operator|.
name|fatal
argument_list|(
name|bpRegistration
operator|+
literal|" initialization failed for block pool "
operator|+
name|blockPoolId
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
return|return;
block|}
name|initialized
operator|=
literal|true
expr_stmt|;
comment|// bp is initialized;
while|while
condition|(
name|shouldRun
operator|&&
name|shouldServiceRun
condition|)
block|{
try|try
block|{
name|startDistributedUpgradeIfNeeded
argument_list|()
expr_stmt|;
name|offerService
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldRun
operator|&&
name|shouldServiceRun
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received exception: "
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected exception "
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|bpRegistration
operator|+
literal|" ending block pool service for: "
operator|+
name|blockPoolId
argument_list|)
expr_stmt|;
name|cleanUp
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Process an array of datanode commands      *       * @param cmds an array of datanode commands      * @return true if further processing may be required or false otherwise.       */
DECL|method|processCommand (DatanodeCommand[] cmds)
specifier|private
name|boolean
name|processCommand
parameter_list|(
name|DatanodeCommand
index|[]
name|cmds
parameter_list|)
block|{
if|if
condition|(
name|cmds
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|DatanodeCommand
name|cmd
range|:
name|cmds
control|)
block|{
try|try
block|{
if|if
condition|(
name|processCommand
argument_list|(
name|cmd
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error processing datanode Command"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      *       * @param cmd      * @return true if further processing may be required or false otherwise.       * @throws IOException      */
DECL|method|processCommand (DatanodeCommand cmd)
specifier|private
name|boolean
name|processCommand
parameter_list|(
name|DatanodeCommand
name|cmd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|cmd
operator|==
literal|null
condition|)
return|return
literal|true
return|;
specifier|final
name|BlockCommand
name|bcmd
init|=
name|cmd
operator|instanceof
name|BlockCommand
condition|?
operator|(
name|BlockCommand
operator|)
name|cmd
else|:
literal|null
decl_stmt|;
switch|switch
condition|(
name|cmd
operator|.
name|getAction
argument_list|()
condition|)
block|{
case|case
name|DatanodeProtocol
operator|.
name|DNA_TRANSFER
case|:
comment|// Send a copy of a block to another datanode
name|transferBlocks
argument_list|(
name|bcmd
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|bcmd
operator|.
name|getBlocks
argument_list|()
argument_list|,
name|bcmd
operator|.
name|getTargets
argument_list|()
argument_list|)
expr_stmt|;
name|metrics
operator|.
name|incrBlocksReplicated
argument_list|(
name|bcmd
operator|.
name|getBlocks
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|DatanodeProtocol
operator|.
name|DNA_INVALIDATE
case|:
comment|//
comment|// Some local block(s) are obsolete and can be
comment|// safely garbage-collected.
comment|//
name|Block
name|toDelete
index|[]
init|=
name|bcmd
operator|.
name|getBlocks
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|blockScanner
operator|!=
literal|null
condition|)
block|{
name|blockScanner
operator|.
name|deleteBlocks
argument_list|(
name|bcmd
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|toDelete
argument_list|)
expr_stmt|;
block|}
comment|// using global fsdataset
name|data
operator|.
name|invalidate
argument_list|(
name|bcmd
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|toDelete
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|checkDiskError
argument_list|()
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|metrics
operator|.
name|incrBlocksRemoved
argument_list|(
name|toDelete
operator|.
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|DatanodeProtocol
operator|.
name|DNA_SHUTDOWN
case|:
comment|// shut down the data node
name|shouldServiceRun
operator|=
literal|false
expr_stmt|;
return|return
literal|false
return|;
case|case
name|DatanodeProtocol
operator|.
name|DNA_REGISTER
case|:
comment|// namenode requested a registration - at start or if NN lost contact
name|LOG
operator|.
name|info
argument_list|(
literal|"DatanodeCommand action: DNA_REGISTER"
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldRun
operator|&&
name|shouldServiceRun
condition|)
block|{
name|register
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|DatanodeProtocol
operator|.
name|DNA_FINALIZE
case|:
name|storage
operator|.
name|finalizeUpgrade
argument_list|(
operator|(
operator|(
name|DatanodeCommand
operator|.
name|Finalize
operator|)
name|cmd
operator|)
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|UpgradeCommand
operator|.
name|UC_ACTION_START_UPGRADE
case|:
comment|// start distributed upgrade here
name|processDistributedUpgradeCommand
argument_list|(
operator|(
name|UpgradeCommand
operator|)
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|DatanodeProtocol
operator|.
name|DNA_RECOVERBLOCK
case|:
name|recoverBlocks
argument_list|(
operator|(
operator|(
name|BlockRecoveryCommand
operator|)
name|cmd
operator|)
operator|.
name|getRecoveringBlocks
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|DatanodeProtocol
operator|.
name|DNA_ACCESSKEYUPDATE
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"DatanodeCommand action: DNA_ACCESSKEYUPDATE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isBlockTokenEnabled
condition|)
block|{
name|blockPoolTokenSecretManager
operator|.
name|setKeys
argument_list|(
name|blockPoolId
argument_list|,
operator|(
operator|(
name|KeyUpdateCommand
operator|)
name|cmd
operator|)
operator|.
name|getExportedKeys
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unknown DatanodeCommand action: "
operator|+
name|cmd
operator|.
name|getAction
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|processDistributedUpgradeCommand (UpgradeCommand comm)
specifier|private
name|void
name|processDistributedUpgradeCommand
parameter_list|(
name|UpgradeCommand
name|comm
parameter_list|)
throws|throws
name|IOException
block|{
name|UpgradeManagerDatanode
name|upgradeManager
init|=
name|getUpgradeManager
argument_list|()
decl_stmt|;
name|upgradeManager
operator|.
name|processUpgradeCommand
argument_list|(
name|comm
argument_list|)
expr_stmt|;
block|}
DECL|method|getUpgradeManager ()
specifier|synchronized
name|UpgradeManagerDatanode
name|getUpgradeManager
parameter_list|()
block|{
if|if
condition|(
name|upgradeManager
operator|==
literal|null
condition|)
name|upgradeManager
operator|=
operator|new
name|UpgradeManagerDatanode
argument_list|(
name|DataNode
operator|.
name|this
argument_list|,
name|blockPoolId
argument_list|)
expr_stmt|;
return|return
name|upgradeManager
return|;
block|}
comment|/**      * Start distributed upgrade if it should be initiated by the data-node.      */
DECL|method|startDistributedUpgradeIfNeeded ()
specifier|private
name|void
name|startDistributedUpgradeIfNeeded
parameter_list|()
throws|throws
name|IOException
block|{
name|UpgradeManagerDatanode
name|um
init|=
name|getUpgradeManager
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|um
operator|.
name|getUpgradeState
argument_list|()
condition|)
return|return;
name|um
operator|.
name|setUpgradeState
argument_list|(
literal|false
argument_list|,
name|um
operator|.
name|getUpgradeVersion
argument_list|()
argument_list|)
expr_stmt|;
name|um
operator|.
name|startUpgrade
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|/**    * This method starts the data node with the specified conf.    *     * @param conf - the configuration    *  if conf's CONFIG_PROPERTY_SIMULATED property is set    *  then a simulated storage based data node is created.    *     * @param dataDirs - only for a non-simulated storage data node    * @throws IOException    */
DECL|method|startDataNode (Configuration conf, AbstractList<File> dataDirs, SecureResources resources )
name|void
name|startDataNode
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|AbstractList
argument_list|<
name|File
argument_list|>
name|dataDirs
parameter_list|,
comment|// DatanodeProtocol namenode,
name|SecureResources
name|resources
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
operator|&&
name|resources
operator|==
literal|null
condition|)
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Cannot start secure cluster without "
operator|+
literal|"privileged resources."
argument_list|)
throw|;
comment|// settings global for all BPs in the Data Node
name|this
operator|.
name|secureResources
operator|=
name|resources
expr_stmt|;
name|this
operator|.
name|dataDirs
operator|=
name|dataDirs
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|storage
operator|=
operator|new
name|DataStorage
argument_list|()
expr_stmt|;
comment|// global DN settings
name|initConfig
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|registerMXBean
argument_list|()
expr_stmt|;
name|initDataXceiver
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|startInfoServer
argument_list|(
name|conf
argument_list|)
expr_stmt|;
comment|// BlockPoolTokenSecretManager is required to create ipc server.
name|this
operator|.
name|blockPoolTokenSecretManager
operator|=
operator|new
name|BlockPoolTokenSecretManager
argument_list|()
expr_stmt|;
name|initIpcServer
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|metrics
operator|=
name|DataNodeMetrics
operator|.
name|create
argument_list|(
name|conf
argument_list|,
name|getMachineName
argument_list|()
argument_list|)
expr_stmt|;
name|blockPoolManager
operator|=
operator|new
name|BlockPoolManager
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
DECL|method|getAllBpOs ()
name|BPOfferService
index|[]
name|getAllBpOs
parameter_list|()
block|{
return|return
name|blockPoolManager
operator|.
name|getAllNamenodeThreads
argument_list|()
return|;
block|}
comment|/**    * Initializes the {@link #data}. The initialization is done only once, when    * handshake with the the first namenode is completed.    */
DECL|method|initFsDataSet (Configuration conf, AbstractList<File> dataDirs)
specifier|private
specifier|synchronized
name|void
name|initFsDataSet
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|AbstractList
argument_list|<
name|File
argument_list|>
name|dataDirs
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
comment|// Already initialized
return|return;
block|}
comment|// get version and id info from the name-node
name|boolean
name|simulatedFSDataset
init|=
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"dfs.datanode.simulateddatastorage"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|simulatedFSDataset
condition|)
block|{
name|storage
operator|.
name|createStorageID
argument_list|(
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
comment|// it would have been better to pass storage as a parameter to
comment|// constructor below - need to augment ReflectionUtils used below.
name|conf
operator|.
name|set
argument_list|(
name|DFS_DATANODE_STORAGEID_KEY
argument_list|,
name|getStorageId
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|data
operator|=
operator|(
name|FSDatasetInterface
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|Class
operator|.
name|forName
argument_list|(
literal|"org.apache.hadoop.hdfs.server.datanode.SimulatedFSDataset"
argument_list|)
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|data
operator|=
operator|new
name|FSDataset
argument_list|(
name|this
argument_list|,
name|storage
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Determine the http server's effective addr    */
DECL|method|getInfoAddr (Configuration conf)
specifier|public
specifier|static
name|InetSocketAddress
name|getInfoAddr
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|conf
operator|.
name|get
argument_list|(
literal|"dfs.datanode.http.address"
argument_list|,
literal|"0.0.0.0:50075"
argument_list|)
argument_list|)
return|;
block|}
DECL|method|registerMXBean ()
specifier|private
name|void
name|registerMXBean
parameter_list|()
block|{
name|MBeans
operator|.
name|register
argument_list|(
literal|"DataNode"
argument_list|,
literal|"DataNodeInfo"
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|getPort ()
name|int
name|getPort
parameter_list|()
block|{
return|return
name|selfAddr
operator|.
name|getPort
argument_list|()
return|;
block|}
DECL|method|getStorageId ()
name|String
name|getStorageId
parameter_list|()
block|{
return|return
name|storage
operator|.
name|getStorageID
argument_list|()
return|;
block|}
comment|/**     * Get host:port with host set to Datanode host and port set to the    * port {@link DataXceiver} is serving.    * @return host:port string    */
DECL|method|getMachineName ()
specifier|public
name|String
name|getMachineName
parameter_list|()
block|{
return|return
name|hostName
operator|+
literal|":"
operator|+
name|getPort
argument_list|()
return|;
block|}
DECL|method|getIpcPort ()
specifier|public
name|int
name|getIpcPort
parameter_list|()
block|{
return|return
name|ipcServer
operator|.
name|getListenerAddress
argument_list|()
operator|.
name|getPort
argument_list|()
return|;
block|}
comment|/**    * get BP registration by blockPool id    * @param bpid    * @return BP registration object    * @throws IOException    */
DECL|method|getDNRegistrationForBP (String bpid)
name|DatanodeRegistration
name|getDNRegistrationForBP
parameter_list|(
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
name|BPOfferService
name|bpos
init|=
name|blockPoolManager
operator|.
name|get
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
if|if
condition|(
name|bpos
operator|==
literal|null
operator|||
name|bpos
operator|.
name|bpRegistration
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"cannot find BPOfferService for bpid="
operator|+
name|bpid
argument_list|)
throw|;
block|}
return|return
name|bpos
operator|.
name|bpRegistration
return|;
block|}
comment|/**    * get BP registration by machine and port name (host:port)    * @param mName    * @return BP registration     * @throws IOException     */
DECL|method|getDNRegistrationByMachineName (String mName)
name|DatanodeRegistration
name|getDNRegistrationByMachineName
parameter_list|(
name|String
name|mName
parameter_list|)
block|{
name|BPOfferService
index|[]
name|bposArray
init|=
name|blockPoolManager
operator|.
name|getAllNamenodeThreads
argument_list|()
decl_stmt|;
for|for
control|(
name|BPOfferService
name|bpos
range|:
name|bposArray
control|)
block|{
if|if
condition|(
name|bpos
operator|.
name|bpRegistration
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|mName
argument_list|)
condition|)
return|return
name|bpos
operator|.
name|bpRegistration
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Creates either NIO or regular depending on socketWriteTimeout.    */
DECL|method|newSocket ()
specifier|protected
name|Socket
name|newSocket
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|(
name|socketWriteTimeout
operator|>
literal|0
operator|)
condition|?
name|SocketChannel
operator|.
name|open
argument_list|()
operator|.
name|socket
argument_list|()
else|:
operator|new
name|Socket
argument_list|()
return|;
block|}
DECL|method|createInterDataNodeProtocolProxy ( DatanodeID datanodeid, final Configuration conf, final int socketTimeout)
specifier|public
specifier|static
name|InterDatanodeProtocol
name|createInterDataNodeProtocolProxy
parameter_list|(
name|DatanodeID
name|datanodeid
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|int
name|socketTimeout
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|InetSocketAddress
name|addr
init|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|datanodeid
operator|.
name|getHost
argument_list|()
operator|+
literal|":"
operator|+
name|datanodeid
operator|.
name|getIpcPort
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|InterDatanodeProtocol
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|InterDatanodeProtocol
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"InterDatanodeProtocol addr="
operator|+
name|addr
argument_list|)
expr_stmt|;
block|}
name|UserGroupInformation
name|loginUgi
init|=
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|loginUgi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|InterDatanodeProtocol
argument_list|>
argument_list|()
block|{
specifier|public
name|InterDatanodeProtocol
name|run
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|(
name|InterDatanodeProtocol
operator|)
name|RPC
operator|.
name|getProxy
argument_list|(
name|InterDatanodeProtocol
operator|.
name|class
argument_list|,
name|InterDatanodeProtocol
operator|.
name|versionID
argument_list|,
name|addr
argument_list|,
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
argument_list|,
name|conf
argument_list|,
name|NetUtils
operator|.
name|getDefaultSocketFactory
argument_list|(
name|conf
argument_list|)
argument_list|,
name|socketTimeout
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ie
operator|.
name|getMessage
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * get the name node address based on the block pool id    * @param bpid block pool ID    * @return namenode address corresponding to the bpid    */
DECL|method|getNameNodeAddr (String bpid)
specifier|public
name|InetSocketAddress
name|getNameNodeAddr
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|BPOfferService
name|bp
init|=
name|blockPoolManager
operator|.
name|get
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
if|if
condition|(
name|bp
operator|!=
literal|null
condition|)
block|{
return|return
name|bp
operator|.
name|getNNSocketAddress
argument_list|()
return|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"No name node address found for block pool ID "
operator|+
name|bpid
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
DECL|method|getSelfAddr ()
specifier|public
name|InetSocketAddress
name|getSelfAddr
parameter_list|()
block|{
return|return
name|selfAddr
return|;
block|}
DECL|method|getMetrics ()
name|DataNodeMetrics
name|getMetrics
parameter_list|()
block|{
return|return
name|metrics
return|;
block|}
DECL|method|setNewStorageID (DatanodeID dnId)
specifier|public
specifier|static
name|void
name|setNewStorageID
parameter_list|(
name|DatanodeID
name|dnId
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Datanode is "
operator|+
name|dnId
argument_list|)
expr_stmt|;
name|dnId
operator|.
name|storageID
operator|=
name|createNewStorageId
argument_list|(
name|dnId
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|createNewStorageId (int port)
specifier|static
name|String
name|createNewStorageId
parameter_list|(
name|int
name|port
parameter_list|)
block|{
comment|/* Return       * "DS-randInt-ipaddr-currentTimeMillis"      * It is considered extermely rare for all these numbers to match      * on a different machine accidentally for the following       * a) SecureRandom(INT_MAX) is pretty much random (1 in 2 billion), and      * b) Good chance ip address would be different, and      * c) Even on the same machine, Datanode is designed to use different ports.      * d) Good chance that these are started at different times.      * For a confict to occur all the 4 above have to match!.      * The format of this string can be changed anytime in future without      * affecting its functionality.      */
name|String
name|ip
init|=
literal|"unknownIP"
decl_stmt|;
try|try
block|{
name|ip
operator|=
name|DNS
operator|.
name|getDefaultIP
argument_list|(
literal|"default"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownHostException
name|ignored
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not find ip address of \"default\" inteface."
argument_list|)
expr_stmt|;
block|}
name|int
name|rand
init|=
operator|new
name|SecureRandom
argument_list|()
operator|.
name|nextInt
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
return|return
literal|"DS-"
operator|+
name|rand
operator|+
literal|"-"
operator|+
name|ip
operator|+
literal|"-"
operator|+
name|port
operator|+
literal|"-"
operator|+
name|System
operator|.
name|currentTimeMillis
argument_list|()
return|;
block|}
comment|/**    * Shut down this instance of the datanode.    * Returns only after shutdown is complete.    * This method can only be called by the offerService thread.    * Otherwise, deadlock might occur.    */
DECL|method|shutdown ()
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
if|if
condition|(
name|plugins
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ServicePlugin
name|p
range|:
name|plugins
control|)
block|{
try|try
block|{
name|p
operator|.
name|stop
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Stopped plug-in "
operator|+
name|p
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"ServicePlugin "
operator|+
name|p
operator|+
literal|" could not be stopped"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|shutdownPeriodicScanners
argument_list|()
expr_stmt|;
if|if
condition|(
name|infoServer
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|infoServer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception shutting down DataNode"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ipcServer
operator|!=
literal|null
condition|)
block|{
name|ipcServer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|shouldRun
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|dataXceiverServer
operator|!=
literal|null
condition|)
block|{
operator|(
operator|(
name|DataXceiverServer
operator|)
name|this
operator|.
name|dataXceiverServer
operator|.
name|getRunnable
argument_list|()
operator|)
operator|.
name|kill
argument_list|()
expr_stmt|;
name|this
operator|.
name|dataXceiverServer
operator|.
name|interrupt
argument_list|()
expr_stmt|;
comment|// wait for all data receiver threads to exit
if|if
condition|(
name|this
operator|.
name|threadGroup
operator|!=
literal|null
condition|)
block|{
name|int
name|sleepMs
init|=
literal|2
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|this
operator|.
name|threadGroup
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Waiting for threadgroup to exit, active threads is "
operator|+
name|this
operator|.
name|threadGroup
operator|.
name|activeCount
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|threadGroup
operator|.
name|activeCount
argument_list|()
operator|==
literal|0
condition|)
block|{
break|break;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepMs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{}
name|sleepMs
operator|=
name|sleepMs
operator|*
literal|3
operator|/
literal|2
expr_stmt|;
comment|// exponential backoff
if|if
condition|(
name|sleepMs
operator|>
literal|1000
condition|)
block|{
name|sleepMs
operator|=
literal|1000
expr_stmt|;
block|}
block|}
block|}
comment|// wait for dataXceiveServer to terminate
try|try
block|{
name|this
operator|.
name|dataXceiverServer
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{       }
block|}
if|if
condition|(
name|blockPoolManager
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|this
operator|.
name|blockPoolManager
operator|.
name|shutDownAll
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received exception in BlockPoolManager#shutDownAll: "
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|storage
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|this
operator|.
name|storage
operator|.
name|unlockAll
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception when unlocking storage: "
operator|+
name|ie
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|data
operator|!=
literal|null
condition|)
block|{
name|data
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
name|metrics
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Check if there is no space in disk     *  @param e that caused this checkDiskError call    **/
DECL|method|checkDiskError (Exception e )
specifier|protected
name|void
name|checkDiskError
parameter_list|(
name|Exception
name|e
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"checkDiskError: exception: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|getMessage
argument_list|()
operator|!=
literal|null
operator|&&
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"No space left on device"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|DiskOutOfSpaceException
argument_list|(
literal|"No space left on device"
argument_list|)
throw|;
block|}
else|else
block|{
name|checkDiskError
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    *  Check if there is a disk failure and if so, handle the error    *    **/
DECL|method|checkDiskError ( )
specifier|protected
name|void
name|checkDiskError
parameter_list|( )
block|{
try|try
block|{
name|data
operator|.
name|checkDataDir
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DiskErrorException
name|de
parameter_list|)
block|{
name|handleDiskError
argument_list|(
name|de
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|handleDiskError (String errMsgr)
specifier|private
name|void
name|handleDiskError
parameter_list|(
name|String
name|errMsgr
parameter_list|)
block|{
specifier|final
name|boolean
name|hasEnoughResources
init|=
name|data
operator|.
name|hasEnoughResource
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"DataNode.handleDiskError: Keep Running: "
operator|+
name|hasEnoughResources
argument_list|)
expr_stmt|;
comment|// If we have enough active valid volumes then we do not want to
comment|// shutdown the DN completely.
name|int
name|dpError
init|=
name|hasEnoughResources
condition|?
name|DatanodeProtocol
operator|.
name|DISK_ERROR
else|:
name|DatanodeProtocol
operator|.
name|FATAL_DISK_ERROR
decl_stmt|;
name|metrics
operator|.
name|incrVolumeFailures
argument_list|()
expr_stmt|;
comment|//inform NameNodes
for|for
control|(
name|BPOfferService
name|bpos
range|:
name|blockPoolManager
operator|.
name|getAllNamenodeThreads
argument_list|()
control|)
block|{
name|DatanodeProtocol
name|nn
init|=
name|bpos
operator|.
name|bpNamenode
decl_stmt|;
try|try
block|{
name|nn
operator|.
name|errorReport
argument_list|(
name|bpos
operator|.
name|bpRegistration
argument_list|,
name|dpError
argument_list|,
name|errMsgr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error reporting disk failure to NameNode: "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hasEnoughResources
condition|)
block|{
name|scheduleAllBlockReport
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
comment|// do not shutdown
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"DataNode is shutting down: "
operator|+
name|errMsgr
argument_list|)
expr_stmt|;
name|shouldRun
operator|=
literal|false
expr_stmt|;
block|}
comment|/** Number of concurrent xceivers per node. */
DECL|method|getXceiverCount ()
name|int
name|getXceiverCount
parameter_list|()
block|{
return|return
name|threadGroup
operator|==
literal|null
condition|?
literal|0
else|:
name|threadGroup
operator|.
name|activeCount
argument_list|()
return|;
block|}
DECL|method|getUpgradeManagerDatanode (String bpid)
name|UpgradeManagerDatanode
name|getUpgradeManagerDatanode
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|BPOfferService
name|bpos
init|=
name|blockPoolManager
operator|.
name|get
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
if|if
condition|(
name|bpos
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|bpos
operator|.
name|getUpgradeManager
argument_list|()
return|;
block|}
DECL|method|transferBlock ( ExtendedBlock block, DatanodeInfo xferTargets[] )
specifier|private
name|void
name|transferBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|DatanodeInfo
name|xferTargets
index|[]
parameter_list|)
throws|throws
name|IOException
block|{
name|DatanodeProtocol
name|nn
init|=
name|getBPNamenode
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
name|DatanodeRegistration
name|bpReg
init|=
name|getDNRegistrationForBP
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|data
operator|.
name|isValidBlock
argument_list|(
name|block
argument_list|)
condition|)
block|{
comment|// block does not exist or is under-construction
name|String
name|errStr
init|=
literal|"Can't send invalid block "
operator|+
name|block
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|errStr
argument_list|)
expr_stmt|;
name|nn
operator|.
name|errorReport
argument_list|(
name|bpReg
argument_list|,
name|DatanodeProtocol
operator|.
name|INVALID_BLOCK
argument_list|,
name|errStr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Check if NN recorded length matches on-disk length
name|long
name|onDiskLength
init|=
name|data
operator|.
name|getLength
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|block
operator|.
name|getNumBytes
argument_list|()
operator|>
name|onDiskLength
condition|)
block|{
comment|// Shorter on-disk len indicates corruption so report NN the corrupt block
name|nn
operator|.
name|reportBadBlocks
argument_list|(
operator|new
name|LocatedBlock
index|[]
block|{
operator|new
name|LocatedBlock
argument_list|(
name|block
argument_list|,
operator|new
name|DatanodeInfo
index|[]
block|{
operator|new
name|DatanodeInfo
argument_list|(
name|bpReg
argument_list|)
block|}
argument_list|)
block|}
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Can't replicate block "
operator|+
name|block
operator|+
literal|" because on-disk length "
operator|+
name|onDiskLength
operator|+
literal|" is shorter than NameNode recorded length "
operator|+
name|block
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|numTargets
init|=
name|xferTargets
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|numTargets
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|StringBuilder
name|xfersBuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTargets
condition|;
name|i
operator|++
control|)
block|{
name|xfersBuilder
operator|.
name|append
argument_list|(
name|xferTargets
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|xfersBuilder
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|bpReg
operator|+
literal|" Starting thread to transfer block "
operator|+
name|block
operator|+
literal|" to "
operator|+
name|xfersBuilder
argument_list|)
expr_stmt|;
block|}
operator|new
name|Daemon
argument_list|(
operator|new
name|DataTransfer
argument_list|(
name|xferTargets
argument_list|,
name|block
argument_list|,
name|BlockConstructionStage
operator|.
name|PIPELINE_SETUP_CREATE
argument_list|,
literal|""
argument_list|)
argument_list|)
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|transferBlocks (String poolId, Block blocks[], DatanodeInfo xferTargets[][])
specifier|private
name|void
name|transferBlocks
parameter_list|(
name|String
name|poolId
parameter_list|,
name|Block
name|blocks
index|[]
parameter_list|,
name|DatanodeInfo
name|xferTargets
index|[]
index|[]
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|blocks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|transferBlock
argument_list|(
operator|new
name|ExtendedBlock
argument_list|(
name|poolId
argument_list|,
name|blocks
index|[
name|i
index|]
argument_list|)
argument_list|,
name|xferTargets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to transfer block "
operator|+
name|blocks
index|[
name|i
index|]
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* ********************************************************************   Protocol when a client reads data from Datanode (Cur Ver: 9):      Client's Request :   =================          Processed in DataXceiver:      +----------------------------------------------+      | Common Header   | 1 byte OP == OP_READ_BLOCK |      +----------------------------------------------+            Processed in readBlock() :      +-------------------------------------------------------------------------+      | 8 byte Block ID | 8 byte genstamp | 8 byte start offset | 8 byte length |      +-------------------------------------------------------------------------+      |   vInt length   |<DFSClient id> |      +-----------------------------------+            Client sends optional response only at the end of receiving data.           DataNode Response :   ===================         In readBlock() :     If there is an error while initializing BlockSender :        +---------------------------+        | 2 byte OP_STATUS_ERROR    | and connection will be closed.        +---------------------------+     Otherwise        +---------------------------+        | 2 byte OP_STATUS_SUCCESS  |        +---------------------------+             Actual data, sent by BlockSender.sendBlock() :            ChecksumHeader :       +--------------------------------------------------+       | 1 byte CHECKSUM_TYPE | 4 byte BYTES_PER_CHECKSUM |       +--------------------------------------------------+       Followed by actual data in the form of PACKETS:        +------------------------------------+       | Sequence of data PACKETs ....      |       +------------------------------------+          A "PACKET" is defined further below.          The client reads data until it receives a packet with      "LastPacketInBlock" set to true or with a zero length. It then replies     to DataNode with one of the status codes:     - CHECKSUM_OK:    All the chunk checksums have been verified     - SUCCESS:        Data received; checksums not verified     - ERROR_CHECKSUM: (Currently not used) Detected invalid checksums        +---------------+       | 2 byte Status |       +---------------+          The DataNode expects all well behaved clients to send the 2 byte     status code. And if the the client doesn't, the DN will close the     connection. So the status code is optional in the sense that it     does not affect the correctness of the data. (And the client can     always reconnect.)          PACKET : Contains a packet header, checksum and data. Amount of data     ======== carried is set by BUFFER_SIZE.            +-----------------------------------------------------+       | 4 byte packet length (excluding packet header)      |       +-----------------------------------------------------+       | 8 byte offset in the block | 8 byte sequence number |       +-----------------------------------------------------+       | 1 byte isLastPacketInBlock                          |       +-----------------------------------------------------+       | 4 byte Length of actual data                        |       +-----------------------------------------------------+       | x byte checksum data. x is defined below            |       +-----------------------------------------------------+       | actual data ......                                  |       +-----------------------------------------------------+              x = (length of data + BYTE_PER_CHECKSUM - 1)/BYTES_PER_CHECKSUM *           CHECKSUM_SIZE                  CHECKSUM_SIZE depends on CHECKSUM_TYPE (usually, 4 for CRC32)              The above packet format is used while writing data to DFS also.       Not all the fields might be used while reading.         ************************************************************************ */
comment|/**    * Used for transferring a block of data.  This class    * sends a piece of data to another DataNode.    */
DECL|class|DataTransfer
specifier|private
class|class
name|DataTransfer
implements|implements
name|Runnable
block|{
DECL|field|targets
specifier|final
name|DatanodeInfo
index|[]
name|targets
decl_stmt|;
DECL|field|b
specifier|final
name|ExtendedBlock
name|b
decl_stmt|;
DECL|field|stage
specifier|final
name|BlockConstructionStage
name|stage
decl_stmt|;
DECL|field|bpReg
specifier|final
specifier|private
name|DatanodeRegistration
name|bpReg
decl_stmt|;
DECL|field|clientname
specifier|final
name|String
name|clientname
decl_stmt|;
comment|/**      * Connect to the first item in the target list.  Pass along the       * entire target list, the block, and the data.      */
DECL|method|DataTransfer (DatanodeInfo targets[], ExtendedBlock b, BlockConstructionStage stage, final String clientname)
name|DataTransfer
parameter_list|(
name|DatanodeInfo
name|targets
index|[]
parameter_list|,
name|ExtendedBlock
name|b
parameter_list|,
name|BlockConstructionStage
name|stage
parameter_list|,
specifier|final
name|String
name|clientname
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|DataTransferProtocol
operator|.
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|DataTransferProtocol
operator|.
name|LOG
operator|.
name|debug
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|": "
operator|+
name|b
operator|+
literal|" (numBytes="
operator|+
name|b
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|")"
operator|+
literal|", stage="
operator|+
name|stage
operator|+
literal|", clientname="
operator|+
name|clientname
operator|+
literal|", targests="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|targets
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|targets
operator|=
name|targets
expr_stmt|;
name|this
operator|.
name|b
operator|=
name|b
expr_stmt|;
name|this
operator|.
name|stage
operator|=
name|stage
expr_stmt|;
name|BPOfferService
name|bpos
init|=
name|blockPoolManager
operator|.
name|get
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
name|bpReg
operator|=
name|bpos
operator|.
name|bpRegistration
expr_stmt|;
name|this
operator|.
name|clientname
operator|=
name|clientname
expr_stmt|;
block|}
comment|/**      * Do the deed, write the bytes      */
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|xmitsInProgress
operator|.
name|getAndIncrement
argument_list|()
expr_stmt|;
name|Socket
name|sock
init|=
literal|null
decl_stmt|;
name|DataOutputStream
name|out
init|=
literal|null
decl_stmt|;
name|DataInputStream
name|in
init|=
literal|null
decl_stmt|;
name|BlockSender
name|blockSender
init|=
literal|null
decl_stmt|;
specifier|final
name|boolean
name|isClient
init|=
name|clientname
operator|.
name|length
argument_list|()
operator|>
literal|0
decl_stmt|;
try|try
block|{
name|InetSocketAddress
name|curTarget
init|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|targets
index|[
literal|0
index|]
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|sock
operator|=
name|newSocket
argument_list|()
expr_stmt|;
name|NetUtils
operator|.
name|connect
argument_list|(
name|sock
argument_list|,
name|curTarget
argument_list|,
name|socketTimeout
argument_list|)
expr_stmt|;
name|sock
operator|.
name|setSoTimeout
argument_list|(
name|targets
operator|.
name|length
operator|*
name|socketTimeout
argument_list|)
expr_stmt|;
name|long
name|writeTimeout
init|=
name|socketWriteTimeout
operator|+
name|HdfsConstants
operator|.
name|WRITE_TIMEOUT_EXTENSION
operator|*
operator|(
name|targets
operator|.
name|length
operator|-
literal|1
operator|)
decl_stmt|;
name|OutputStream
name|baseStream
init|=
name|NetUtils
operator|.
name|getOutputStream
argument_list|(
name|sock
argument_list|,
name|writeTimeout
argument_list|)
decl_stmt|;
name|out
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|baseStream
argument_list|,
name|SMALL_BUFFER_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|blockSender
operator|=
operator|new
name|BlockSender
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
name|b
operator|.
name|getNumBytes
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|DataNode
operator|.
name|this
argument_list|)
expr_stmt|;
name|DatanodeInfo
name|srcNode
init|=
operator|new
name|DatanodeInfo
argument_list|(
name|bpReg
argument_list|)
decl_stmt|;
comment|//
comment|// Header info
comment|//
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|accessToken
init|=
name|BlockTokenSecretManager
operator|.
name|DUMMY_TOKEN
decl_stmt|;
if|if
condition|(
name|isBlockTokenEnabled
condition|)
block|{
name|accessToken
operator|=
name|blockPoolTokenSecretManager
operator|.
name|generateToken
argument_list|(
name|b
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|BlockTokenSecretManager
operator|.
name|AccessMode
operator|.
name|WRITE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Sender
operator|.
name|opWriteBlock
argument_list|(
name|out
argument_list|,
name|b
argument_list|,
literal|0
argument_list|,
name|stage
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|clientname
argument_list|,
name|srcNode
argument_list|,
name|targets
argument_list|,
name|accessToken
argument_list|)
expr_stmt|;
comment|// send data& checksum
name|blockSender
operator|.
name|sendBlock
argument_list|(
name|out
argument_list|,
name|baseStream
argument_list|,
literal|null
argument_list|)
expr_stmt|;
comment|// no response necessary
name|LOG
operator|.
name|info
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|": Transmitted "
operator|+
name|b
operator|+
literal|" (numBytes="
operator|+
name|b
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|") to "
operator|+
name|curTarget
argument_list|)
expr_stmt|;
comment|// read ack
if|if
condition|(
name|isClient
condition|)
block|{
name|in
operator|=
operator|new
name|DataInputStream
argument_list|(
name|NetUtils
operator|.
name|getInputStream
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|DNTransferAckProto
name|closeAck
init|=
name|DNTransferAckProto
operator|.
name|parseFrom
argument_list|(
name|HdfsProtoUtil
operator|.
name|vintPrefixed
argument_list|(
name|in
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|": close-ack="
operator|+
name|closeAck
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|closeAck
operator|.
name|getStatus
argument_list|()
operator|!=
name|Status
operator|.
name|SUCCESS
condition|)
block|{
if|if
condition|(
name|closeAck
operator|.
name|getStatus
argument_list|()
operator|==
name|Status
operator|.
name|ERROR_ACCESS_TOKEN
condition|)
block|{
throw|throw
operator|new
name|InvalidBlockTokenException
argument_list|(
literal|"Got access token error for connect ack, targets="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|targets
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Bad connect ack, targets="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|targets
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|bpReg
operator|+
literal|":Failed to transfer "
operator|+
name|b
operator|+
literal|" to "
operator|+
name|targets
index|[
literal|0
index|]
operator|.
name|getName
argument_list|()
operator|+
literal|" got "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|ie
argument_list|)
argument_list|)
expr_stmt|;
comment|// check if there are any disk problem
name|checkDiskError
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|xmitsInProgress
operator|.
name|getAndDecrement
argument_list|()
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|blockSender
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeSocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * After a block becomes finalized, a datanode increases metric counter,    * notifies namenode, and adds it to the block scanner    * @param block    * @param delHint    */
DECL|method|closeBlock (ExtendedBlock block, String delHint)
name|void
name|closeBlock
parameter_list|(
name|ExtendedBlock
name|block
parameter_list|,
name|String
name|delHint
parameter_list|)
block|{
name|metrics
operator|.
name|incrBlocksWritten
argument_list|()
expr_stmt|;
name|BPOfferService
name|bpos
init|=
name|blockPoolManager
operator|.
name|get
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|bpos
operator|!=
literal|null
condition|)
block|{
name|bpos
operator|.
name|notifyNamenodeReceivedBlock
argument_list|(
name|block
argument_list|,
name|delHint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot find BPOfferService for reporting block received for bpid="
operator|+
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|blockScanner
operator|!=
literal|null
condition|)
block|{
name|blockScanner
operator|.
name|addBlock
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Start a single datanode daemon and wait for it to finish.    *  If this thread is specifically interrupted, it will stop waiting.    */
DECL|method|runDatanodeDaemon ()
specifier|public
name|void
name|runDatanodeDaemon
parameter_list|()
throws|throws
name|IOException
block|{
name|blockPoolManager
operator|.
name|startAll
argument_list|()
expr_stmt|;
comment|// start dataXceiveServer
name|dataXceiverServer
operator|.
name|start
argument_list|()
expr_stmt|;
name|ipcServer
operator|.
name|start
argument_list|()
expr_stmt|;
name|startPlugins
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * A data node is considered to be up if one of the bp services is up    */
DECL|method|isDatanodeUp ()
specifier|public
name|boolean
name|isDatanodeUp
parameter_list|()
block|{
for|for
control|(
name|BPOfferService
name|bp
range|:
name|blockPoolManager
operator|.
name|getAllNamenodeThreads
argument_list|()
control|)
block|{
if|if
condition|(
name|bp
operator|.
name|isAlive
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Instantiate a single datanode object. This must be run by invoking    *  {@link DataNode#runDatanodeDaemon()} subsequently.     */
DECL|method|instantiateDataNode (String args[], Configuration conf)
specifier|public
specifier|static
name|DataNode
name|instantiateDataNode
parameter_list|(
name|String
name|args
index|[]
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|instantiateDataNode
argument_list|(
name|args
argument_list|,
name|conf
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Instantiate a single datanode object, along with its secure resources.     * This must be run by invoking{@link DataNode#runDatanodeDaemon()}     * subsequently.     */
DECL|method|instantiateDataNode (String args [], Configuration conf, SecureResources resources)
specifier|public
specifier|static
name|DataNode
name|instantiateDataNode
parameter_list|(
name|String
name|args
index|[]
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|SecureResources
name|resources
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|conf
operator|==
literal|null
condition|)
name|conf
operator|=
operator|new
name|HdfsConfiguration
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|!=
literal|null
condition|)
block|{
comment|// parse generic hadoop options
name|GenericOptionsParser
name|hParser
init|=
operator|new
name|GenericOptionsParser
argument_list|(
name|conf
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|args
operator|=
name|hParser
operator|.
name|getRemainingArgs
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|parseArguments
argument_list|(
name|args
argument_list|,
name|conf
argument_list|)
condition|)
block|{
name|printUsage
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|conf
operator|.
name|get
argument_list|(
literal|"dfs.network.script"
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"This configuration for rack identification is not supported"
operator|+
literal|" anymore. RackID resolution is handled by the NameNode."
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|Collection
argument_list|<
name|URI
argument_list|>
name|dataDirs
init|=
name|getStorageDirs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|dnThreadName
operator|=
literal|"DataNode: ["
operator|+
name|StringUtils
operator|.
name|uriToString
argument_list|(
name|dataDirs
operator|.
name|toArray
argument_list|(
operator|new
name|URI
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|+
literal|"]"
expr_stmt|;
name|UserGroupInformation
operator|.
name|setConfiguration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|SecurityUtil
operator|.
name|login
argument_list|(
name|conf
argument_list|,
name|DFS_DATANODE_KEYTAB_FILE_KEY
argument_list|,
name|DFS_DATANODE_USER_NAME_KEY
argument_list|)
expr_stmt|;
return|return
name|makeInstance
argument_list|(
name|dataDirs
argument_list|,
name|conf
argument_list|,
name|resources
argument_list|)
return|;
block|}
DECL|method|getStorageDirs (Configuration conf)
specifier|static
name|Collection
argument_list|<
name|URI
argument_list|>
name|getStorageDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|dirNames
init|=
name|conf
operator|.
name|getTrimmedStringCollection
argument_list|(
name|DFS_DATANODE_DATA_DIR_KEY
argument_list|)
decl_stmt|;
return|return
name|Util
operator|.
name|stringCollectionAsURIs
argument_list|(
name|dirNames
argument_list|)
return|;
block|}
comment|/** Instantiate& Start a single datanode daemon and wait for it to finish.    *  If this thread is specifically interrupted, it will stop waiting.    */
DECL|method|createDataNode (String args[], Configuration conf)
specifier|public
specifier|static
name|DataNode
name|createDataNode
parameter_list|(
name|String
name|args
index|[]
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createDataNode
argument_list|(
name|args
argument_list|,
name|conf
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/** Instantiate& Start a single datanode daemon and wait for it to finish.    *  If this thread is specifically interrupted, it will stop waiting.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|method|createDataNode (String args[], Configuration conf, SecureResources resources)
specifier|public
specifier|static
name|DataNode
name|createDataNode
parameter_list|(
name|String
name|args
index|[]
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|SecureResources
name|resources
parameter_list|)
throws|throws
name|IOException
block|{
name|DataNode
name|dn
init|=
name|instantiateDataNode
argument_list|(
name|args
argument_list|,
name|conf
argument_list|,
name|resources
argument_list|)
decl_stmt|;
if|if
condition|(
name|dn
operator|!=
literal|null
condition|)
block|{
name|dn
operator|.
name|runDatanodeDaemon
argument_list|()
expr_stmt|;
block|}
return|return
name|dn
return|;
block|}
DECL|method|join ()
name|void
name|join
parameter_list|()
block|{
while|while
condition|(
name|shouldRun
condition|)
block|{
try|try
block|{
name|blockPoolManager
operator|.
name|joinAll
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Received exception in Datanode#join: "
operator|+
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Make an instance of DataNode after ensuring that at least one of the    * given data directories (and their parent directories, if necessary)    * can be created.    * @param dataDirs List of directories, where the new DataNode instance should    * keep its files.    * @param conf Configuration instance to use.    * @param resources Secure resources needed to run under Kerberos    * @return DataNode instance for given list of data dirs and conf, or null if    * no directory from this directory list can be created.    * @throws IOException    */
DECL|method|makeInstance (Collection<URI> dataDirs, Configuration conf, SecureResources resources)
specifier|static
name|DataNode
name|makeInstance
parameter_list|(
name|Collection
argument_list|<
name|URI
argument_list|>
name|dataDirs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|SecureResources
name|resources
parameter_list|)
throws|throws
name|IOException
block|{
name|LocalFileSystem
name|localFS
init|=
name|FileSystem
operator|.
name|getLocal
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|FsPermission
name|permission
init|=
operator|new
name|FsPermission
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_DATANODE_DATA_DIR_PERMISSION_KEY
argument_list|,
name|DFS_DATANODE_DATA_DIR_PERMISSION_DEFAULT
argument_list|)
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|File
argument_list|>
name|dirs
init|=
name|getDataDirsFromURIs
argument_list|(
name|dataDirs
argument_list|,
name|localFS
argument_list|,
name|permission
argument_list|)
decl_stmt|;
name|DefaultMetricsSystem
operator|.
name|initialize
argument_list|(
literal|"DataNode"
argument_list|)
expr_stmt|;
assert|assert
name|dirs
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|:
literal|"number of data directories should be> 0"
assert|;
return|return
operator|new
name|DataNode
argument_list|(
name|conf
argument_list|,
name|dirs
argument_list|,
name|resources
argument_list|)
return|;
block|}
comment|// DataNode ctor expects AbstractList instead of List or Collection...
DECL|method|getDataDirsFromURIs (Collection<URI> dataDirs, LocalFileSystem localFS, FsPermission permission)
specifier|static
name|ArrayList
argument_list|<
name|File
argument_list|>
name|getDataDirsFromURIs
parameter_list|(
name|Collection
argument_list|<
name|URI
argument_list|>
name|dataDirs
parameter_list|,
name|LocalFileSystem
name|localFS
parameter_list|,
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|File
argument_list|>
name|dirs
init|=
operator|new
name|ArrayList
argument_list|<
name|File
argument_list|>
argument_list|()
decl_stmt|;
name|StringBuilder
name|invalidDirs
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|URI
name|dirURI
range|:
name|dataDirs
control|)
block|{
if|if
condition|(
operator|!
literal|"file"
operator|.
name|equalsIgnoreCase
argument_list|(
name|dirURI
operator|.
name|getScheme
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unsupported URI schema in "
operator|+
name|dirURI
operator|+
literal|". Ignoring ..."
argument_list|)
expr_stmt|;
name|invalidDirs
operator|.
name|append
argument_list|(
literal|"\""
argument_list|)
operator|.
name|append
argument_list|(
name|dirURI
argument_list|)
operator|.
name|append
argument_list|(
literal|"\" "
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// drop any (illegal) authority in the URI for backwards compatibility
name|File
name|data
init|=
operator|new
name|File
argument_list|(
name|dirURI
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|DiskChecker
operator|.
name|checkDir
argument_list|(
name|localFS
argument_list|,
operator|new
name|Path
argument_list|(
name|data
operator|.
name|toURI
argument_list|()
argument_list|)
argument_list|,
name|permission
argument_list|)
expr_stmt|;
name|dirs
operator|.
name|add
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Invalid directory in: "
operator|+
name|DFS_DATANODE_DATA_DIR_KEY
operator|+
literal|": "
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|invalidDirs
operator|.
name|append
argument_list|(
literal|"\""
argument_list|)
operator|.
name|append
argument_list|(
name|data
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\" "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dirs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"All directories in "
operator|+
name|DFS_DATANODE_DATA_DIR_KEY
operator|+
literal|" are invalid: "
operator|+
name|invalidDirs
argument_list|)
throw|;
return|return
name|dirs
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"DataNode{data="
operator|+
name|data
operator|+
literal|", localName='"
operator|+
name|getMachineName
argument_list|()
operator|+
literal|"', storageID='"
operator|+
name|getStorageId
argument_list|()
operator|+
literal|"', xmitsInProgress="
operator|+
name|xmitsInProgress
operator|.
name|get
argument_list|()
operator|+
literal|"}"
return|;
block|}
DECL|method|printUsage ()
specifier|private
specifier|static
name|void
name|printUsage
parameter_list|()
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: java DataNode"
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"           [-rollback]"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Parse and verify command line arguments and set configuration parameters.    *    * @return false if passed argements are incorrect    */
DECL|method|parseArguments (String args[], Configuration conf)
specifier|private
specifier|static
name|boolean
name|parseArguments
parameter_list|(
name|String
name|args
index|[]
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|int
name|argsLen
init|=
operator|(
name|args
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|args
operator|.
name|length
decl_stmt|;
name|StartupOption
name|startOpt
init|=
name|StartupOption
operator|.
name|REGULAR
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|argsLen
condition|;
name|i
operator|++
control|)
block|{
name|String
name|cmd
init|=
name|args
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
literal|"-r"
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
operator|||
literal|"--rack"
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"-r, --rack arguments are not supported anymore. RackID "
operator|+
literal|"resolution is handled by the NameNode."
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"-rollback"
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|ROLLBACK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"-regular"
operator|.
name|equalsIgnoreCase
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|startOpt
operator|=
name|StartupOption
operator|.
name|REGULAR
expr_stmt|;
block|}
else|else
return|return
literal|false
return|;
block|}
name|setStartupOption
argument_list|(
name|conf
argument_list|,
name|startOpt
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|setStartupOption (Configuration conf, StartupOption opt)
specifier|private
specifier|static
name|void
name|setStartupOption
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|StartupOption
name|opt
parameter_list|)
block|{
name|conf
operator|.
name|set
argument_list|(
literal|"dfs.datanode.startup"
argument_list|,
name|opt
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|getStartupOption (Configuration conf)
specifier|static
name|StartupOption
name|getStartupOption
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|StartupOption
operator|.
name|valueOf
argument_list|(
name|conf
operator|.
name|get
argument_list|(
literal|"dfs.datanode.startup"
argument_list|,
name|StartupOption
operator|.
name|REGULAR
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * This methods  arranges for the data node to send     * the block report at the next heartbeat.    */
DECL|method|scheduleAllBlockReport (long delay)
specifier|public
name|void
name|scheduleAllBlockReport
parameter_list|(
name|long
name|delay
parameter_list|)
block|{
for|for
control|(
name|BPOfferService
name|bpos
range|:
name|blockPoolManager
operator|.
name|getAllNamenodeThreads
argument_list|()
control|)
block|{
name|bpos
operator|.
name|scheduleBlockReport
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This method is used for testing.     * Examples are adding and deleting blocks directly.    * The most common usage will be when the data node's storage is similated.    *     * @return the fsdataset that stores the blocks    */
DECL|method|getFSDataset ()
specifier|public
name|FSDatasetInterface
name|getFSDataset
parameter_list|()
block|{
return|return
name|data
return|;
block|}
DECL|method|secureMain (String args[], SecureResources resources)
specifier|public
specifier|static
name|void
name|secureMain
parameter_list|(
name|String
name|args
index|[]
parameter_list|,
name|SecureResources
name|resources
parameter_list|)
block|{
try|try
block|{
name|StringUtils
operator|.
name|startupShutdownMessage
argument_list|(
name|DataNode
operator|.
name|class
argument_list|,
name|args
argument_list|,
name|LOG
argument_list|)
expr_stmt|;
name|DataNode
name|datanode
init|=
name|createDataNode
argument_list|(
name|args
argument_list|,
literal|null
argument_list|,
name|resources
argument_list|)
decl_stmt|;
if|if
condition|(
name|datanode
operator|!=
literal|null
condition|)
name|datanode
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|main (String args[])
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
name|args
index|[]
parameter_list|)
block|{
name|secureMain
argument_list|(
name|args
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|recoverBlocks (final Collection<RecoveringBlock> blocks)
specifier|public
name|Daemon
name|recoverBlocks
parameter_list|(
specifier|final
name|Collection
argument_list|<
name|RecoveringBlock
argument_list|>
name|blocks
parameter_list|)
block|{
name|Daemon
name|d
init|=
operator|new
name|Daemon
argument_list|(
name|threadGroup
argument_list|,
operator|new
name|Runnable
argument_list|()
block|{
comment|/** Recover a list of blocks. It is run by the primary datanode. */
specifier|public
name|void
name|run
parameter_list|()
block|{
for|for
control|(
name|RecoveringBlock
name|b
range|:
name|blocks
control|)
block|{
try|try
block|{
name|logRecoverBlock
argument_list|(
literal|"NameNode"
argument_list|,
name|b
operator|.
name|getBlock
argument_list|()
argument_list|,
name|b
operator|.
name|getLocations
argument_list|()
argument_list|)
expr_stmt|;
name|recoverBlock
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"recoverBlocks FAILED: "
operator|+
name|b
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
argument_list|)
decl_stmt|;
name|d
operator|.
name|start
argument_list|()
expr_stmt|;
return|return
name|d
return|;
block|}
comment|// InterDataNodeProtocol implementation
annotation|@
name|Override
comment|// InterDatanodeProtocol
DECL|method|initReplicaRecovery (RecoveringBlock rBlock)
specifier|public
name|ReplicaRecoveryInfo
name|initReplicaRecovery
parameter_list|(
name|RecoveringBlock
name|rBlock
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|data
operator|.
name|initReplicaRecovery
argument_list|(
name|rBlock
argument_list|)
return|;
block|}
comment|/**    * Convenience method, which unwraps RemoteException.    * @throws IOException not a RemoteException.    */
DECL|method|callInitReplicaRecovery ( InterDatanodeProtocol datanode, RecoveringBlock rBlock)
specifier|private
specifier|static
name|ReplicaRecoveryInfo
name|callInitReplicaRecovery
parameter_list|(
name|InterDatanodeProtocol
name|datanode
parameter_list|,
name|RecoveringBlock
name|rBlock
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|datanode
operator|.
name|initReplicaRecovery
argument_list|(
name|rBlock
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|RemoteException
name|re
parameter_list|)
block|{
throw|throw
name|re
operator|.
name|unwrapRemoteException
argument_list|()
throw|;
block|}
block|}
comment|/**    * Update replica with the new generation stamp and length.      */
annotation|@
name|Override
comment|// InterDatanodeProtocol
DECL|method|updateReplicaUnderRecovery (ExtendedBlock oldBlock, long recoveryId, long newLength)
specifier|public
name|ExtendedBlock
name|updateReplicaUnderRecovery
parameter_list|(
name|ExtendedBlock
name|oldBlock
parameter_list|,
name|long
name|recoveryId
parameter_list|,
name|long
name|newLength
parameter_list|)
throws|throws
name|IOException
block|{
name|ReplicaInfo
name|r
init|=
name|data
operator|.
name|updateReplicaUnderRecovery
argument_list|(
name|oldBlock
argument_list|,
name|recoveryId
argument_list|,
name|newLength
argument_list|)
decl_stmt|;
return|return
operator|new
name|ExtendedBlock
argument_list|(
name|oldBlock
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|r
argument_list|)
return|;
block|}
comment|/** {@inheritDoc} */
DECL|method|getProtocolVersion (String protocol, long clientVersion )
specifier|public
name|long
name|getProtocolVersion
parameter_list|(
name|String
name|protocol
parameter_list|,
name|long
name|clientVersion
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|InterDatanodeProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|InterDatanodeProtocol
operator|.
name|versionID
return|;
block|}
elseif|else
if|if
condition|(
name|protocol
operator|.
name|equals
argument_list|(
name|ClientDatanodeProtocol
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|ClientDatanodeProtocol
operator|.
name|versionID
return|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown protocol to "
operator|+
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|": "
operator|+
name|protocol
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|getProtocolSignature (String protocol, long clientVersion, int clientMethodsHash)
specifier|public
name|ProtocolSignature
name|getProtocolSignature
parameter_list|(
name|String
name|protocol
parameter_list|,
name|long
name|clientVersion
parameter_list|,
name|int
name|clientMethodsHash
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|ProtocolSignature
operator|.
name|getProtocolSignature
argument_list|(
name|this
argument_list|,
name|protocol
argument_list|,
name|clientVersion
argument_list|,
name|clientMethodsHash
argument_list|)
return|;
block|}
comment|/** A convenient class used in block recovery */
DECL|class|BlockRecord
specifier|static
class|class
name|BlockRecord
block|{
DECL|field|id
specifier|final
name|DatanodeID
name|id
decl_stmt|;
DECL|field|datanode
specifier|final
name|InterDatanodeProtocol
name|datanode
decl_stmt|;
DECL|field|rInfo
specifier|final
name|ReplicaRecoveryInfo
name|rInfo
decl_stmt|;
DECL|method|BlockRecord (DatanodeID id, InterDatanodeProtocol datanode, ReplicaRecoveryInfo rInfo)
name|BlockRecord
parameter_list|(
name|DatanodeID
name|id
parameter_list|,
name|InterDatanodeProtocol
name|datanode
parameter_list|,
name|ReplicaRecoveryInfo
name|rInfo
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|this
operator|.
name|datanode
operator|=
name|datanode
expr_stmt|;
name|this
operator|.
name|rInfo
operator|=
name|rInfo
expr_stmt|;
block|}
comment|/** {@inheritDoc} */
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"block:"
operator|+
name|rInfo
operator|+
literal|" node:"
operator|+
name|id
return|;
block|}
block|}
comment|/** Recover a block */
DECL|method|recoverBlock (RecoveringBlock rBlock)
specifier|private
name|void
name|recoverBlock
parameter_list|(
name|RecoveringBlock
name|rBlock
parameter_list|)
throws|throws
name|IOException
block|{
name|ExtendedBlock
name|block
init|=
name|rBlock
operator|.
name|getBlock
argument_list|()
decl_stmt|;
name|String
name|blookPoolId
init|=
name|block
operator|.
name|getBlockPoolId
argument_list|()
decl_stmt|;
name|DatanodeInfo
index|[]
name|targets
init|=
name|rBlock
operator|.
name|getLocations
argument_list|()
decl_stmt|;
name|DatanodeID
index|[]
name|datanodeids
init|=
operator|(
name|DatanodeID
index|[]
operator|)
name|targets
decl_stmt|;
name|List
argument_list|<
name|BlockRecord
argument_list|>
name|syncList
init|=
operator|new
name|ArrayList
argument_list|<
name|BlockRecord
argument_list|>
argument_list|(
name|datanodeids
operator|.
name|length
argument_list|)
decl_stmt|;
name|int
name|errorCount
init|=
literal|0
decl_stmt|;
comment|//check generation stamps
for|for
control|(
name|DatanodeID
name|id
range|:
name|datanodeids
control|)
block|{
try|try
block|{
name|BPOfferService
name|bpos
init|=
name|blockPoolManager
operator|.
name|get
argument_list|(
name|blookPoolId
argument_list|)
decl_stmt|;
name|DatanodeRegistration
name|bpReg
init|=
name|bpos
operator|.
name|bpRegistration
decl_stmt|;
name|InterDatanodeProtocol
name|datanode
init|=
name|bpReg
operator|.
name|equals
argument_list|(
name|id
argument_list|)
condition|?
name|this
else|:
name|DataNode
operator|.
name|createInterDataNodeProtocolProxy
argument_list|(
name|id
argument_list|,
name|getConf
argument_list|()
argument_list|,
name|socketTimeout
argument_list|)
decl_stmt|;
name|ReplicaRecoveryInfo
name|info
init|=
name|callInitReplicaRecovery
argument_list|(
name|datanode
argument_list|,
name|rBlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|!=
literal|null
operator|&&
name|info
operator|.
name|getGenerationStamp
argument_list|()
operator|>=
name|block
operator|.
name|getGenerationStamp
argument_list|()
operator|&&
name|info
operator|.
name|getNumBytes
argument_list|()
operator|>
literal|0
condition|)
block|{
name|syncList
operator|.
name|add
argument_list|(
operator|new
name|BlockRecord
argument_list|(
name|id
argument_list|,
name|datanode
argument_list|,
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RecoveryInProgressException
name|ripE
parameter_list|)
block|{
name|InterDatanodeProtocol
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Recovery for replica "
operator|+
name|block
operator|+
literal|" on data-node "
operator|+
name|id
operator|+
literal|" is already in progress. Recovery id = "
operator|+
name|rBlock
operator|.
name|getNewGenerationStamp
argument_list|()
operator|+
literal|" is aborted."
argument_list|,
name|ripE
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
operator|++
name|errorCount
expr_stmt|;
name|InterDatanodeProtocol
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to obtain replica info for block (="
operator|+
name|block
operator|+
literal|") from datanode (="
operator|+
name|id
operator|+
literal|")"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errorCount
operator|==
name|datanodeids
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"All datanodes failed: block="
operator|+
name|block
operator|+
literal|", datanodeids="
operator|+
name|Arrays
operator|.
name|asList
argument_list|(
name|datanodeids
argument_list|)
argument_list|)
throw|;
block|}
name|syncBlock
argument_list|(
name|rBlock
argument_list|,
name|syncList
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get namenode corresponding to a block pool    * @param bpid Block pool Id    * @return Namenode corresponding to the bpid    * @throws IOException    */
DECL|method|getBPNamenode (String bpid)
specifier|public
name|DatanodeProtocol
name|getBPNamenode
parameter_list|(
name|String
name|bpid
parameter_list|)
throws|throws
name|IOException
block|{
name|BPOfferService
name|bpos
init|=
name|blockPoolManager
operator|.
name|get
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
if|if
condition|(
name|bpos
operator|==
literal|null
operator|||
name|bpos
operator|.
name|bpNamenode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"cannot find a namnode proxy for bpid="
operator|+
name|bpid
argument_list|)
throw|;
block|}
return|return
name|bpos
operator|.
name|bpNamenode
return|;
block|}
comment|/**    * To be used by tests only to set a mock namenode in BPOfferService    */
DECL|method|setBPNamenode (String bpid, DatanodeProtocol namenode)
name|void
name|setBPNamenode
parameter_list|(
name|String
name|bpid
parameter_list|,
name|DatanodeProtocol
name|namenode
parameter_list|)
block|{
name|BPOfferService
name|bp
init|=
name|blockPoolManager
operator|.
name|get
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
if|if
condition|(
name|bp
operator|!=
literal|null
condition|)
block|{
name|bp
operator|.
name|setNameNode
argument_list|(
name|namenode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Block synchronization */
DECL|method|syncBlock (RecoveringBlock rBlock, List<BlockRecord> syncList)
name|void
name|syncBlock
parameter_list|(
name|RecoveringBlock
name|rBlock
parameter_list|,
name|List
argument_list|<
name|BlockRecord
argument_list|>
name|syncList
parameter_list|)
throws|throws
name|IOException
block|{
name|ExtendedBlock
name|block
init|=
name|rBlock
operator|.
name|getBlock
argument_list|()
decl_stmt|;
name|DatanodeProtocol
name|nn
init|=
name|getBPNamenode
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|)
decl_stmt|;
name|long
name|recoveryId
init|=
name|rBlock
operator|.
name|getNewGenerationStamp
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"block="
operator|+
name|block
operator|+
literal|", (length="
operator|+
name|block
operator|.
name|getNumBytes
argument_list|()
operator|+
literal|"), syncList="
operator|+
name|syncList
argument_list|)
expr_stmt|;
block|}
comment|// syncList.isEmpty() means that all data-nodes do not have the block
comment|// or their replicas have 0 length.
comment|// The block can be deleted.
if|if
condition|(
name|syncList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|nn
operator|.
name|commitBlockSynchronization
argument_list|(
name|block
argument_list|,
name|recoveryId
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|DatanodeID
operator|.
name|EMPTY_ARRAY
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Calculate the best available replica state.
name|ReplicaState
name|bestState
init|=
name|ReplicaState
operator|.
name|RWR
decl_stmt|;
name|long
name|finalizedLength
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|BlockRecord
name|r
range|:
name|syncList
control|)
block|{
assert|assert
name|r
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
operator|>
literal|0
operator|:
literal|"zero length replica"
assert|;
name|ReplicaState
name|rState
init|=
name|r
operator|.
name|rInfo
operator|.
name|getOriginalReplicaState
argument_list|()
decl_stmt|;
if|if
condition|(
name|rState
operator|.
name|getValue
argument_list|()
operator|<
name|bestState
operator|.
name|getValue
argument_list|()
condition|)
name|bestState
operator|=
name|rState
expr_stmt|;
if|if
condition|(
name|rState
operator|==
name|ReplicaState
operator|.
name|FINALIZED
condition|)
block|{
if|if
condition|(
name|finalizedLength
operator|>
literal|0
operator|&&
name|finalizedLength
operator|!=
name|r
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Inconsistent size of finalized replicas. "
operator|+
literal|"Replica "
operator|+
name|r
operator|.
name|rInfo
operator|+
literal|" expected size: "
operator|+
name|finalizedLength
argument_list|)
throw|;
name|finalizedLength
operator|=
name|r
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Calculate list of nodes that will participate in the recovery
comment|// and the new block size
name|List
argument_list|<
name|BlockRecord
argument_list|>
name|participatingList
init|=
operator|new
name|ArrayList
argument_list|<
name|BlockRecord
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|ExtendedBlock
name|newBlock
init|=
operator|new
name|ExtendedBlock
argument_list|(
name|block
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|block
operator|.
name|getBlockId
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
name|recoveryId
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|bestState
condition|)
block|{
case|case
name|FINALIZED
case|:
assert|assert
name|finalizedLength
operator|>
literal|0
operator|:
literal|"finalizedLength is not positive"
assert|;
for|for
control|(
name|BlockRecord
name|r
range|:
name|syncList
control|)
block|{
name|ReplicaState
name|rState
init|=
name|r
operator|.
name|rInfo
operator|.
name|getOriginalReplicaState
argument_list|()
decl_stmt|;
if|if
condition|(
name|rState
operator|==
name|ReplicaState
operator|.
name|FINALIZED
operator|||
name|rState
operator|==
name|ReplicaState
operator|.
name|RBW
operator|&&
name|r
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
operator|==
name|finalizedLength
condition|)
name|participatingList
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|newBlock
operator|.
name|setNumBytes
argument_list|(
name|finalizedLength
argument_list|)
expr_stmt|;
break|break;
case|case
name|RBW
case|:
case|case
name|RWR
case|:
name|long
name|minLength
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
name|BlockRecord
name|r
range|:
name|syncList
control|)
block|{
name|ReplicaState
name|rState
init|=
name|r
operator|.
name|rInfo
operator|.
name|getOriginalReplicaState
argument_list|()
decl_stmt|;
if|if
condition|(
name|rState
operator|==
name|bestState
condition|)
block|{
name|minLength
operator|=
name|Math
operator|.
name|min
argument_list|(
name|minLength
argument_list|,
name|r
operator|.
name|rInfo
operator|.
name|getNumBytes
argument_list|()
argument_list|)
expr_stmt|;
name|participatingList
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
name|newBlock
operator|.
name|setNumBytes
argument_list|(
name|minLength
argument_list|)
expr_stmt|;
break|break;
case|case
name|RUR
case|:
case|case
name|TEMPORARY
case|:
assert|assert
literal|false
operator|:
literal|"bad replica state: "
operator|+
name|bestState
assert|;
block|}
name|List
argument_list|<
name|DatanodeID
argument_list|>
name|failedList
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeID
argument_list|>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|DatanodeID
argument_list|>
name|successList
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeID
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|BlockRecord
name|r
range|:
name|participatingList
control|)
block|{
try|try
block|{
name|ExtendedBlock
name|reply
init|=
name|r
operator|.
name|datanode
operator|.
name|updateReplicaUnderRecovery
argument_list|(
operator|new
name|ExtendedBlock
argument_list|(
name|newBlock
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|r
operator|.
name|rInfo
argument_list|)
argument_list|,
name|recoveryId
argument_list|,
name|newBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|reply
operator|.
name|equals
argument_list|(
name|newBlock
argument_list|)
operator|&&
name|reply
operator|.
name|getNumBytes
argument_list|()
operator|==
name|newBlock
operator|.
name|getNumBytes
argument_list|()
operator|:
literal|"Updated replica must be the same as the new block."
assert|;
name|successList
operator|.
name|add
argument_list|(
name|r
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|InterDatanodeProtocol
operator|.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to updateBlock (newblock="
operator|+
name|newBlock
operator|+
literal|", datanode="
operator|+
name|r
operator|.
name|id
operator|+
literal|")"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|failedList
operator|.
name|add
argument_list|(
name|r
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If any of the data-nodes failed, the recovery fails, because
comment|// we never know the actual state of the replica on failed data-nodes.
comment|// The recovery should be started over.
if|if
condition|(
operator|!
name|failedList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|DatanodeID
name|id
range|:
name|failedList
control|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|"\n  "
operator|+
name|id
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot recover "
operator|+
name|block
operator|+
literal|", the following "
operator|+
name|failedList
operator|.
name|size
argument_list|()
operator|+
literal|" data-nodes failed {"
operator|+
name|b
operator|+
literal|"\n}"
argument_list|)
throw|;
block|}
comment|// Notify the name-node about successfully recovered replicas.
name|DatanodeID
index|[]
name|nlist
init|=
name|successList
operator|.
name|toArray
argument_list|(
operator|new
name|DatanodeID
index|[
name|successList
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
name|nn
operator|.
name|commitBlockSynchronization
argument_list|(
name|block
argument_list|,
name|newBlock
operator|.
name|getGenerationStamp
argument_list|()
argument_list|,
name|newBlock
operator|.
name|getNumBytes
argument_list|()
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
name|nlist
argument_list|)
expr_stmt|;
block|}
DECL|method|logRecoverBlock (String who, ExtendedBlock block, DatanodeID[] targets)
specifier|private
specifier|static
name|void
name|logRecoverBlock
parameter_list|(
name|String
name|who
parameter_list|,
name|ExtendedBlock
name|block
parameter_list|,
name|DatanodeID
index|[]
name|targets
parameter_list|)
block|{
name|StringBuilder
name|msg
init|=
operator|new
name|StringBuilder
argument_list|(
name|targets
index|[
literal|0
index|]
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|targets
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|msg
operator|.
name|append
argument_list|(
literal|", "
operator|+
name|targets
index|[
name|i
index|]
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|who
operator|+
literal|" calls recoverBlock(block="
operator|+
name|block
operator|+
literal|", targets=["
operator|+
name|msg
operator|+
literal|"])"
argument_list|)
expr_stmt|;
block|}
comment|// ClientDataNodeProtocol implementation
comment|/** {@inheritDoc} */
annotation|@
name|Override
comment|// ClientDataNodeProtocol
DECL|method|getReplicaVisibleLength (final ExtendedBlock block)
specifier|public
name|long
name|getReplicaVisibleLength
parameter_list|(
specifier|final
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
name|checkWriteAccess
argument_list|(
name|block
argument_list|)
expr_stmt|;
return|return
name|data
operator|.
name|getReplicaVisibleLength
argument_list|(
name|block
argument_list|)
return|;
block|}
DECL|method|checkWriteAccess (final ExtendedBlock block)
specifier|private
name|void
name|checkWriteAccess
parameter_list|(
specifier|final
name|ExtendedBlock
name|block
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isBlockTokenEnabled
condition|)
block|{
name|Set
argument_list|<
name|TokenIdentifier
argument_list|>
name|tokenIds
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getTokenIdentifiers
argument_list|()
decl_stmt|;
if|if
condition|(
name|tokenIds
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Can't continue since none or more than one "
operator|+
literal|"BlockTokenIdentifier is found."
argument_list|)
throw|;
block|}
for|for
control|(
name|TokenIdentifier
name|tokenId
range|:
name|tokenIds
control|)
block|{
name|BlockTokenIdentifier
name|id
init|=
operator|(
name|BlockTokenIdentifier
operator|)
name|tokenId
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got: "
operator|+
name|id
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|blockPoolTokenSecretManager
operator|.
name|checkAccess
argument_list|(
name|id
argument_list|,
literal|null
argument_list|,
name|block
argument_list|,
name|BlockTokenSecretManager
operator|.
name|AccessMode
operator|.
name|READ
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Transfer a replica to the datanode targets.    * @param b the block to transfer.    *          The corresponding replica must be an RBW or a Finalized.    *          Its GS and numBytes will be set to    *          the stored GS and the visible length.     * @param targets    * @param client    */
DECL|method|transferReplicaForPipelineRecovery (final ExtendedBlock b, final DatanodeInfo[] targets, final String client)
name|void
name|transferReplicaForPipelineRecovery
parameter_list|(
specifier|final
name|ExtendedBlock
name|b
parameter_list|,
specifier|final
name|DatanodeInfo
index|[]
name|targets
parameter_list|,
specifier|final
name|String
name|client
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|storedGS
decl_stmt|;
specifier|final
name|long
name|visible
decl_stmt|;
specifier|final
name|BlockConstructionStage
name|stage
decl_stmt|;
comment|//get replica information
synchronized|synchronized
init|(
name|data
init|)
block|{
if|if
condition|(
name|data
operator|.
name|isValidRbw
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|stage
operator|=
name|BlockConstructionStage
operator|.
name|TRANSFER_RBW
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data
operator|.
name|isValidBlock
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|stage
operator|=
name|BlockConstructionStage
operator|.
name|TRANSFER_FINALIZED
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|String
name|r
init|=
name|data
operator|.
name|getReplicaString
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|b
operator|+
literal|" is neither a RBW nor a Finalized, r="
operator|+
name|r
argument_list|)
throw|;
block|}
name|storedGS
operator|=
name|data
operator|.
name|getStoredBlock
argument_list|(
name|b
operator|.
name|getBlockPoolId
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockId
argument_list|()
argument_list|)
operator|.
name|getGenerationStamp
argument_list|()
expr_stmt|;
if|if
condition|(
name|storedGS
operator|<
name|b
operator|.
name|getGenerationStamp
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|storedGS
operator|+
literal|" = storedGS< b.getGenerationStamp(), b="
operator|+
name|b
argument_list|)
throw|;
block|}
name|visible
operator|=
name|data
operator|.
name|getReplicaVisibleLength
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
comment|//set storedGS and visible length
name|b
operator|.
name|setGenerationStamp
argument_list|(
name|storedGS
argument_list|)
expr_stmt|;
name|b
operator|.
name|setNumBytes
argument_list|(
name|visible
argument_list|)
expr_stmt|;
if|if
condition|(
name|targets
operator|.
name|length
operator|>
literal|0
condition|)
block|{
operator|new
name|DataTransfer
argument_list|(
name|targets
argument_list|,
name|b
argument_list|,
name|stage
argument_list|,
name|client
argument_list|)
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Determine a Datanode's streaming address
DECL|method|getStreamingAddr (Configuration conf)
specifier|public
specifier|static
name|InetSocketAddress
name|getStreamingAddr
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|conf
operator|.
name|get
argument_list|(
literal|"dfs.datanode.address"
argument_list|,
literal|"0.0.0.0:50010"
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// DataNodeMXBean
DECL|method|getVersion ()
specifier|public
name|String
name|getVersion
parameter_list|()
block|{
return|return
name|VersionInfo
operator|.
name|getVersion
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|// DataNodeMXBean
DECL|method|getRpcPort ()
specifier|public
name|String
name|getRpcPort
parameter_list|()
block|{
name|InetSocketAddress
name|ipcAddr
init|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|this
operator|.
name|getConf
argument_list|()
operator|.
name|get
argument_list|(
literal|"dfs.datanode.ipc.address"
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|Integer
operator|.
name|toString
argument_list|(
name|ipcAddr
operator|.
name|getPort
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// DataNodeMXBean
DECL|method|getHttpPort ()
specifier|public
name|String
name|getHttpPort
parameter_list|()
block|{
return|return
name|this
operator|.
name|getConf
argument_list|()
operator|.
name|get
argument_list|(
literal|"dfs.datanode.info.port"
argument_list|)
return|;
block|}
DECL|method|getInfoPort ()
specifier|public
name|int
name|getInfoPort
parameter_list|()
block|{
return|return
name|this
operator|.
name|infoServer
operator|.
name|getPort
argument_list|()
return|;
block|}
comment|/**    * Returned information is a JSON representation of a map with     * name node host name as the key and block pool Id as the value    */
annotation|@
name|Override
comment|// DataNodeMXBean
DECL|method|getNamenodeAddresses ()
specifier|public
name|String
name|getNamenodeAddresses
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|info
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|BPOfferService
name|bpos
range|:
name|blockPoolManager
operator|.
name|getAllNamenodeThreads
argument_list|()
control|)
block|{
if|if
condition|(
name|bpos
operator|!=
literal|null
operator|&&
name|bpos
operator|.
name|bpThread
operator|!=
literal|null
condition|)
block|{
name|info
operator|.
name|put
argument_list|(
name|bpos
operator|.
name|getNNSocketAddress
argument_list|()
operator|.
name|getHostName
argument_list|()
argument_list|,
name|bpos
operator|.
name|blockPoolId
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|info
argument_list|)
return|;
block|}
comment|/**    * Returned information is a JSON representation of a map with     * volume name as the key and value is a map of volume attribute     * keys to its values    */
annotation|@
name|Override
comment|// DataNodeMXBean
DECL|method|getVolumeInfo ()
specifier|public
name|String
name|getVolumeInfo
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|info
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|VolumeInfo
argument_list|>
name|volumes
init|=
operator|(
operator|(
name|FSDataset
operator|)
name|this
operator|.
name|data
operator|)
operator|.
name|getVolumeInfo
argument_list|()
decl_stmt|;
for|for
control|(
name|VolumeInfo
name|v
range|:
name|volumes
control|)
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|innerInfo
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|innerInfo
operator|.
name|put
argument_list|(
literal|"usedSpace"
argument_list|,
name|v
operator|.
name|usedSpace
argument_list|)
expr_stmt|;
name|innerInfo
operator|.
name|put
argument_list|(
literal|"freeSpace"
argument_list|,
name|v
operator|.
name|freeSpace
argument_list|)
expr_stmt|;
name|innerInfo
operator|.
name|put
argument_list|(
literal|"reservedSpace"
argument_list|,
name|v
operator|.
name|reservedSpace
argument_list|)
expr_stmt|;
name|info
operator|.
name|put
argument_list|(
name|v
operator|.
name|directory
argument_list|,
name|innerInfo
argument_list|)
expr_stmt|;
block|}
return|return
name|JSON
operator|.
name|toString
argument_list|(
name|info
argument_list|)
return|;
block|}
annotation|@
name|Override
comment|// DataNodeMXBean
DECL|method|getClusterId ()
specifier|public
specifier|synchronized
name|String
name|getClusterId
parameter_list|()
block|{
return|return
name|clusterId
return|;
block|}
DECL|method|refreshNamenodes (Configuration conf)
specifier|public
name|void
name|refreshNamenodes
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|blockPoolManager
operator|.
name|refreshNamenodes
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|IOException
name|eio
init|=
operator|new
name|IOException
argument_list|()
decl_stmt|;
name|eio
operator|.
name|initCause
argument_list|(
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|eio
throw|;
block|}
block|}
annotation|@
name|Override
comment|//ClientDatanodeProtocol
DECL|method|refreshNamenodes ()
specifier|public
name|void
name|refreshNamenodes
parameter_list|()
throws|throws
name|IOException
block|{
name|conf
operator|=
operator|new
name|Configuration
argument_list|()
expr_stmt|;
name|refreshNamenodes
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
comment|// ClientDatanodeProtocol
DECL|method|deleteBlockPool (String blockPoolId, boolean force)
specifier|public
name|void
name|deleteBlockPool
parameter_list|(
name|String
name|blockPoolId
parameter_list|,
name|boolean
name|force
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"deleteBlockPool command received for block pool "
operator|+
name|blockPoolId
operator|+
literal|", force="
operator|+
name|force
argument_list|)
expr_stmt|;
if|if
condition|(
name|blockPoolManager
operator|.
name|get
argument_list|(
name|blockPoolId
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The block pool "
operator|+
name|blockPoolId
operator|+
literal|" is still running, cannot be deleted."
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The block pool is still running. First do a refreshNamenodes to "
operator|+
literal|"shutdown the block pool service"
argument_list|)
throw|;
block|}
name|data
operator|.
name|deleteBlockPool
argument_list|(
name|blockPoolId
argument_list|,
name|force
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param addr rpc address of the namenode    * @return true - if BPOfferService corresponding to the namenode is alive    */
DECL|method|isBPServiceAlive (InetSocketAddress addr)
specifier|public
name|boolean
name|isBPServiceAlive
parameter_list|(
name|InetSocketAddress
name|addr
parameter_list|)
block|{
name|BPOfferService
name|bp
init|=
name|blockPoolManager
operator|.
name|get
argument_list|(
name|addr
argument_list|)
decl_stmt|;
return|return
name|bp
operator|!=
literal|null
condition|?
name|bp
operator|.
name|isAlive
argument_list|()
else|:
literal|false
return|;
block|}
comment|/**    * @param bpid block pool Id    * @return true - if BPOfferService thread is alive    */
DECL|method|isBPServiceAlive (String bpid)
specifier|public
name|boolean
name|isBPServiceAlive
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|BPOfferService
name|bp
init|=
name|blockPoolManager
operator|.
name|get
argument_list|(
name|bpid
argument_list|)
decl_stmt|;
return|return
name|bp
operator|!=
literal|null
condition|?
name|bp
operator|.
name|isAlive
argument_list|()
else|:
literal|false
return|;
block|}
comment|/**    * A datanode is considered to be fully started if all the BP threads are    * alive and all the block pools are initialized.    *     * @return true - if the data node is fully started    */
DECL|method|isDatanodeFullyStarted ()
specifier|public
name|boolean
name|isDatanodeFullyStarted
parameter_list|()
block|{
for|for
control|(
name|BPOfferService
name|bp
range|:
name|blockPoolManager
operator|.
name|getAllNamenodeThreads
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|bp
operator|.
name|initialized
argument_list|()
operator|||
operator|!
name|bp
operator|.
name|isAlive
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/** Methods used by fault injection tests */
DECL|method|getDatanodeId ()
specifier|public
name|DatanodeID
name|getDatanodeId
parameter_list|()
block|{
return|return
operator|new
name|DatanodeID
argument_list|(
name|getMachineName
argument_list|()
argument_list|,
name|getStorageId
argument_list|()
argument_list|,
name|infoServer
operator|.
name|getPort
argument_list|()
argument_list|,
name|getIpcPort
argument_list|()
argument_list|)
return|;
block|}
block|}
end_class

end_unit

