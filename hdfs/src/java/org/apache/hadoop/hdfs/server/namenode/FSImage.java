begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|SimpleDateFormat
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LayoutVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LayoutVersion
operator|.
name|Feature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|InconsistentFSStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|StorageDirectory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|StorageState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|StorageInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Util
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Util
operator|.
name|now
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsConstants
operator|.
name|NamenodeRole
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsConstants
operator|.
name|StartupOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorage
operator|.
name|NameNodeDirType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorage
operator|.
name|NameNodeFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorage
operator|.
name|NNStorageListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|CheckpointCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|MD5Hash
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_comment
comment|/**  * FSImage handles checkpointing and logging of the namespace edits.  *   */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|FSImage
specifier|public
class|class
name|FSImage
implements|implements
name|NNStorageListener
implements|,
name|Closeable
block|{
DECL|field|LOG
specifier|protected
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FSImage
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|DATE_FORM
specifier|private
specifier|static
specifier|final
name|SimpleDateFormat
name|DATE_FORM
init|=
operator|new
name|SimpleDateFormat
argument_list|(
literal|"yyyy-MM-dd HH:mm:ss"
argument_list|)
decl_stmt|;
comment|// checkpoint states
DECL|enum|CheckpointStates
DECL|enumConstant|START
DECL|enumConstant|ROLLED_EDITS
DECL|enumConstant|UPLOAD_START
DECL|enumConstant|UPLOAD_DONE
enum|enum
name|CheckpointStates
block|{
name|START
block|,
name|ROLLED_EDITS
block|,
name|UPLOAD_START
block|,
name|UPLOAD_DONE
block|; }
DECL|field|namesystem
specifier|protected
name|FSNamesystem
name|namesystem
init|=
literal|null
decl_stmt|;
DECL|field|editLog
specifier|protected
name|FSEditLog
name|editLog
init|=
literal|null
decl_stmt|;
DECL|field|isUpgradeFinalized
specifier|private
name|boolean
name|isUpgradeFinalized
init|=
literal|false
decl_stmt|;
DECL|field|newImageDigest
specifier|protected
name|MD5Hash
name|newImageDigest
init|=
literal|null
decl_stmt|;
DECL|field|storage
specifier|protected
name|NNStorage
name|storage
init|=
literal|null
decl_stmt|;
comment|/**    * URIs for importing an image from a checkpoint. In the default case,    * URIs will represent directories.     */
DECL|field|checkpointDirs
specifier|private
name|Collection
argument_list|<
name|URI
argument_list|>
name|checkpointDirs
decl_stmt|;
DECL|field|checkpointEditsDirs
specifier|private
name|Collection
argument_list|<
name|URI
argument_list|>
name|checkpointEditsDirs
decl_stmt|;
DECL|field|conf
specifier|private
name|Configuration
name|conf
decl_stmt|;
comment|/**    * Can fs-image be rolled?    */
DECL|field|ckptState
specifier|volatile
specifier|protected
name|CheckpointStates
name|ckptState
init|=
name|FSImage
operator|.
name|CheckpointStates
operator|.
name|START
decl_stmt|;
comment|/**    */
DECL|method|FSImage ()
name|FSImage
parameter_list|()
block|{
name|this
argument_list|(
operator|(
name|FSNamesystem
operator|)
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Constructor    * @param conf Configuration    */
DECL|method|FSImage (Configuration conf)
name|FSImage
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|()
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
comment|// TODO we have too many constructors, this is a mess
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_NAME_DIR_RESTORE_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_NAME_DIR_RESTORE_DEFAULT
argument_list|)
condition|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"set FSImage.restoreFailedStorage"
argument_list|)
expr_stmt|;
name|storage
operator|.
name|setRestoreFailedStorage
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|setCheckpointDirectories
argument_list|(
name|FSImage
operator|.
name|getCheckpointDirs
argument_list|(
name|conf
argument_list|,
literal|null
argument_list|)
argument_list|,
name|FSImage
operator|.
name|getCheckpointEditsDirs
argument_list|(
name|conf
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|FSImage (FSNamesystem ns)
specifier|private
name|FSImage
parameter_list|(
name|FSNamesystem
name|ns
parameter_list|)
block|{
name|this
operator|.
name|conf
operator|=
operator|new
name|Configuration
argument_list|()
expr_stmt|;
name|storage
operator|=
operator|new
name|NNStorage
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns
operator|!=
literal|null
condition|)
block|{
name|storage
operator|.
name|setUpgradeManager
argument_list|(
name|ns
operator|.
name|upgradeManager
argument_list|)
expr_stmt|;
block|}
name|storage
operator|.
name|registerListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|editLog
operator|=
operator|new
name|FSEditLog
argument_list|(
name|storage
argument_list|)
expr_stmt|;
name|setFSNamesystem
argument_list|(
name|ns
argument_list|)
expr_stmt|;
block|}
comment|/**    * @throws IOException     */
DECL|method|FSImage (Collection<URI> fsDirs, Collection<URI> fsEditsDirs)
name|FSImage
parameter_list|(
name|Collection
argument_list|<
name|URI
argument_list|>
name|fsDirs
parameter_list|,
name|Collection
argument_list|<
name|URI
argument_list|>
name|fsEditsDirs
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|()
expr_stmt|;
name|storage
operator|.
name|setStorageDirectories
argument_list|(
name|fsDirs
argument_list|,
name|fsEditsDirs
argument_list|)
expr_stmt|;
block|}
DECL|method|FSImage (StorageInfo storageInfo, String bpid)
specifier|public
name|FSImage
parameter_list|(
name|StorageInfo
name|storageInfo
parameter_list|,
name|String
name|bpid
parameter_list|)
block|{
name|storage
operator|=
operator|new
name|NNStorage
argument_list|(
name|storageInfo
argument_list|,
name|bpid
argument_list|)
expr_stmt|;
block|}
comment|/**    * Represents an Image (image and edit file).    * @throws IOException     */
DECL|method|FSImage (URI imageDir)
name|FSImage
parameter_list|(
name|URI
name|imageDir
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|()
expr_stmt|;
name|ArrayList
argument_list|<
name|URI
argument_list|>
name|dirs
init|=
operator|new
name|ArrayList
argument_list|<
name|URI
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|URI
argument_list|>
name|editsDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|URI
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|dirs
operator|.
name|add
argument_list|(
name|imageDir
argument_list|)
expr_stmt|;
name|editsDirs
operator|.
name|add
argument_list|(
name|imageDir
argument_list|)
expr_stmt|;
name|storage
operator|.
name|setStorageDirectories
argument_list|(
name|dirs
argument_list|,
name|editsDirs
argument_list|)
expr_stmt|;
block|}
DECL|method|getFSNamesystem ()
specifier|protected
name|FSNamesystem
name|getFSNamesystem
parameter_list|()
block|{
return|return
name|namesystem
return|;
block|}
DECL|method|setFSNamesystem (FSNamesystem ns)
name|void
name|setFSNamesystem
parameter_list|(
name|FSNamesystem
name|ns
parameter_list|)
block|{
name|namesystem
operator|=
name|ns
expr_stmt|;
if|if
condition|(
name|ns
operator|!=
literal|null
condition|)
block|{
name|storage
operator|.
name|setUpgradeManager
argument_list|(
name|ns
operator|.
name|upgradeManager
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|setCheckpointDirectories (Collection<URI> dirs, Collection<URI> editsDirs)
name|void
name|setCheckpointDirectories
parameter_list|(
name|Collection
argument_list|<
name|URI
argument_list|>
name|dirs
parameter_list|,
name|Collection
argument_list|<
name|URI
argument_list|>
name|editsDirs
parameter_list|)
block|{
name|checkpointDirs
operator|=
name|dirs
expr_stmt|;
name|checkpointEditsDirs
operator|=
name|editsDirs
expr_stmt|;
block|}
comment|/**    * Analyze storage directories.    * Recover from previous transitions if required.     * Perform fs state transition if necessary depending on the namespace info.    * Read storage info.     *     * @param dataDirs    * @param startOpt startup option    * @throws IOException    * @return true if the image needs to be saved or false otherwise    */
DECL|method|recoverTransitionRead (Collection<URI> dataDirs, Collection<URI> editsDirs, StartupOption startOpt)
name|boolean
name|recoverTransitionRead
parameter_list|(
name|Collection
argument_list|<
name|URI
argument_list|>
name|dataDirs
parameter_list|,
name|Collection
argument_list|<
name|URI
argument_list|>
name|editsDirs
parameter_list|,
name|StartupOption
name|startOpt
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|startOpt
operator|!=
name|StartupOption
operator|.
name|FORMAT
operator|:
literal|"NameNode formatting should be performed before reading the image"
assert|;
comment|// none of the data dirs exist
if|if
condition|(
operator|(
name|dataDirs
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|||
name|editsDirs
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
operator|&&
name|startOpt
operator|!=
name|StartupOption
operator|.
name|IMPORT
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"All specified directories are not accessible or do not exist."
argument_list|)
throw|;
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|IMPORT
operator|&&
operator|(
name|checkpointDirs
operator|==
literal|null
operator|||
name|checkpointDirs
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot import image from a checkpoint. "
operator|+
literal|"\"dfs.namenode.checkpoint.dir\" is not set."
argument_list|)
throw|;
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|IMPORT
operator|&&
operator|(
name|checkpointEditsDirs
operator|==
literal|null
operator|||
name|checkpointEditsDirs
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot import image from a checkpoint. "
operator|+
literal|"\"dfs.namenode.checkpoint.dir\" is not set."
argument_list|)
throw|;
name|storage
operator|.
name|setStorageDirectories
argument_list|(
name|dataDirs
argument_list|,
name|editsDirs
argument_list|)
expr_stmt|;
comment|// 1. For each data directory calculate its state and
comment|// check whether all is consistent before transitioning.
name|Map
argument_list|<
name|StorageDirectory
argument_list|,
name|StorageState
argument_list|>
name|dataDirStates
init|=
operator|new
name|HashMap
argument_list|<
name|StorageDirectory
argument_list|,
name|StorageState
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|isFormatted
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|StorageState
name|curState
decl_stmt|;
try|try
block|{
name|curState
operator|=
name|sd
operator|.
name|analyzeStorage
argument_list|(
name|startOpt
argument_list|)
expr_stmt|;
comment|// sd is locked but not opened
switch|switch
condition|(
name|curState
condition|)
block|{
case|case
name|NON_EXISTENT
case|:
comment|// name-node fails if any of the configured storage dirs are missing
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
literal|"storage directory does not exist or is not accessible."
argument_list|)
throw|;
case|case
name|NOT_FORMATTED
case|:
break|break;
case|case
name|NORMAL
case|:
break|break;
default|default:
comment|// recovery is possible
name|sd
operator|.
name|doRecover
argument_list|(
name|curState
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curState
operator|!=
name|StorageState
operator|.
name|NOT_FORMATTED
operator|&&
name|startOpt
operator|!=
name|StartupOption
operator|.
name|ROLLBACK
condition|)
block|{
name|sd
operator|.
name|read
argument_list|()
expr_stmt|;
comment|// read and verify consistency with other directories
name|isFormatted
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|IMPORT
operator|&&
name|isFormatted
condition|)
comment|// import of a checkpoint is allowed only into empty image directories
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot import image from a checkpoint. "
operator|+
literal|" NameNode already contains an image in "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|sd
operator|.
name|unlock
argument_list|()
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
name|dataDirStates
operator|.
name|put
argument_list|(
name|sd
argument_list|,
name|curState
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isFormatted
operator|&&
name|startOpt
operator|!=
name|StartupOption
operator|.
name|ROLLBACK
operator|&&
name|startOpt
operator|!=
name|StartupOption
operator|.
name|IMPORT
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"NameNode is not formatted."
argument_list|)
throw|;
name|int
name|layoutVersion
init|=
name|storage
operator|.
name|getLayoutVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|layoutVersion
operator|<
name|Storage
operator|.
name|LAST_PRE_UPGRADE_LAYOUT_VERSION
condition|)
block|{
name|NNStorage
operator|.
name|checkVersionUpgradable
argument_list|(
name|storage
operator|.
name|getLayoutVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|startOpt
operator|!=
name|StartupOption
operator|.
name|UPGRADE
operator|&&
name|layoutVersion
operator|<
name|Storage
operator|.
name|LAST_PRE_UPGRADE_LAYOUT_VERSION
operator|&&
name|layoutVersion
operator|!=
name|FSConstants
operator|.
name|LAYOUT_VERSION
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"\nFile system image contains an old layout version "
operator|+
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|".\nAn upgrade to version "
operator|+
name|FSConstants
operator|.
name|LAYOUT_VERSION
operator|+
literal|" is required.\n"
operator|+
literal|"Please restart NameNode with -upgrade option."
argument_list|)
throw|;
block|}
name|storage
operator|.
name|processStartupOptionsForUpgrade
argument_list|(
name|startOpt
argument_list|,
name|layoutVersion
argument_list|)
expr_stmt|;
comment|// check whether distributed upgrade is required and/or should be continued
name|storage
operator|.
name|verifyDistributedUpgradeProgress
argument_list|(
name|startOpt
argument_list|)
expr_stmt|;
comment|// 2. Format unformatted dirs.
name|storage
operator|.
name|setCheckpointTime
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|StorageState
name|curState
init|=
name|dataDirStates
operator|.
name|get
argument_list|(
name|sd
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|curState
condition|)
block|{
case|case
name|NON_EXISTENT
case|:
throw|throw
operator|new
name|IOException
argument_list|(
name|StorageState
operator|.
name|NON_EXISTENT
operator|+
literal|" state cannot be here"
argument_list|)
throw|;
case|case
name|NOT_FORMATTED
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Storage directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|" is not formatted."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Formatting ..."
argument_list|)
expr_stmt|;
name|sd
operator|.
name|clearDirectory
argument_list|()
expr_stmt|;
comment|// create empty currrent dir
break|break;
default|default:
break|break;
block|}
block|}
comment|// 3. Do transitions
switch|switch
condition|(
name|startOpt
condition|)
block|{
case|case
name|UPGRADE
case|:
name|doUpgrade
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
comment|// upgrade saved image already
case|case
name|IMPORT
case|:
name|doImportCheckpoint
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
comment|// import checkpoint saved image already
case|case
name|ROLLBACK
case|:
name|doRollback
argument_list|()
expr_stmt|;
break|break;
case|case
name|REGULAR
case|:
comment|// just load the image
block|}
name|boolean
name|needToSave
init|=
name|loadFSImage
argument_list|()
decl_stmt|;
assert|assert
name|editLog
operator|!=
literal|null
operator|:
literal|"editLog must be initialized"
assert|;
if|if
condition|(
operator|!
name|editLog
operator|.
name|isOpen
argument_list|()
condition|)
name|editLog
operator|.
name|open
argument_list|()
expr_stmt|;
return|return
name|needToSave
return|;
block|}
DECL|method|doUpgrade ()
specifier|private
name|void
name|doUpgrade
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|storage
operator|.
name|getDistributedUpgradeState
argument_list|()
condition|)
block|{
comment|// only distributed upgrade need to continue
comment|// don't do version upgrade
name|this
operator|.
name|loadFSImage
argument_list|()
expr_stmt|;
name|storage
operator|.
name|initializeDistributedUpgrade
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// Upgrade is allowed only if there are
comment|// no previous fs states in any of the directories
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|sd
operator|.
name|getPreviousDir
argument_list|()
operator|.
name|exists
argument_list|()
condition|)
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
literal|"previous fs state should not exist during upgrade. "
operator|+
literal|"Finalize or rollback first."
argument_list|)
throw|;
block|}
comment|// load the latest image
name|this
operator|.
name|loadFSImage
argument_list|()
expr_stmt|;
comment|// Do upgrade for each directory
name|long
name|oldCTime
init|=
name|storage
operator|.
name|getCTime
argument_list|()
decl_stmt|;
name|storage
operator|.
name|cTime
operator|=
name|now
argument_list|()
expr_stmt|;
comment|// generate new cTime for the state
name|int
name|oldLV
init|=
name|storage
operator|.
name|getLayoutVersion
argument_list|()
decl_stmt|;
name|storage
operator|.
name|layoutVersion
operator|=
name|FSConstants
operator|.
name|LAYOUT_VERSION
expr_stmt|;
name|storage
operator|.
name|setCheckpointTime
argument_list|(
name|now
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|errorSDs
init|=
name|Collections
operator|.
name|synchronizedList
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|StorageDirectory
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Thread
argument_list|>
name|saveThreads
init|=
operator|new
name|ArrayList
argument_list|<
name|Thread
argument_list|>
argument_list|()
decl_stmt|;
name|File
name|curDir
decl_stmt|,
name|prevDir
decl_stmt|,
name|tmpDir
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting upgrade of image directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|".\n   old LV = "
operator|+
name|oldLV
operator|+
literal|"; old CTime = "
operator|+
name|oldCTime
operator|+
literal|".\n   new LV = "
operator|+
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|"; new CTime = "
operator|+
name|storage
operator|.
name|getCTime
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|curDir
operator|=
name|sd
operator|.
name|getCurrentDir
argument_list|()
expr_stmt|;
name|prevDir
operator|=
name|sd
operator|.
name|getPreviousDir
argument_list|()
expr_stmt|;
name|tmpDir
operator|=
name|sd
operator|.
name|getPreviousTmp
argument_list|()
expr_stmt|;
assert|assert
name|curDir
operator|.
name|exists
argument_list|()
operator|:
literal|"Current directory must exist."
assert|;
assert|assert
operator|!
name|prevDir
operator|.
name|exists
argument_list|()
operator|:
literal|"prvious directory must not exist."
assert|;
assert|assert
operator|!
name|tmpDir
operator|.
name|exists
argument_list|()
operator|:
literal|"prvious.tmp directory must not exist."
assert|;
assert|assert
operator|!
name|editLog
operator|.
name|isOpen
argument_list|()
operator|:
literal|"Edits log must not be open."
assert|;
comment|// rename current to tmp
name|NNStorage
operator|.
name|rename
argument_list|(
name|curDir
argument_list|,
name|tmpDir
argument_list|)
expr_stmt|;
comment|// launch thread to save new image
name|FSImageSaver
name|saver
init|=
operator|new
name|FSImageSaver
argument_list|(
name|sd
argument_list|,
name|errorSDs
argument_list|)
decl_stmt|;
name|Thread
name|saveThread
init|=
operator|new
name|Thread
argument_list|(
name|saver
argument_list|,
name|saver
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|saveThreads
operator|.
name|add
argument_list|(
name|saveThread
argument_list|)
expr_stmt|;
name|saveThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed upgrade of image directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|errorSDs
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|waitForThreads
argument_list|(
name|saveThreads
argument_list|)
expr_stmt|;
name|saveThreads
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|errorSDs
operator|.
name|contains
argument_list|(
name|sd
argument_list|)
condition|)
continue|continue;
try|try
block|{
name|prevDir
operator|=
name|sd
operator|.
name|getPreviousDir
argument_list|()
expr_stmt|;
name|tmpDir
operator|=
name|sd
operator|.
name|getPreviousTmp
argument_list|()
expr_stmt|;
comment|// rename tmp to previous
name|NNStorage
operator|.
name|rename
argument_list|(
name|tmpDir
argument_list|,
name|prevDir
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to rename temp to previous for "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
name|errorSDs
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Upgrade of "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|" is complete."
argument_list|)
expr_stmt|;
block|}
name|isUpgradeFinalized
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|errorSDs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|storage
operator|.
name|reportErrorsOnDirectories
argument_list|(
name|errorSDs
argument_list|)
expr_stmt|;
comment|//during upgrade, it's a fatal error to fail any storage directory
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Upgrade failed in "
operator|+
name|errorSDs
operator|.
name|size
argument_list|()
operator|+
literal|" storage directory(ies), previously logged."
argument_list|)
throw|;
block|}
name|storage
operator|.
name|initializeDistributedUpgrade
argument_list|()
expr_stmt|;
name|editLog
operator|.
name|open
argument_list|()
expr_stmt|;
block|}
DECL|method|doRollback ()
specifier|private
name|void
name|doRollback
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Rollback is allowed only if there is
comment|// a previous fs states in at least one of the storage directories.
comment|// Directories that don't have previous state do not rollback
name|boolean
name|canRollback
init|=
literal|false
decl_stmt|;
name|FSImage
name|prevState
init|=
operator|new
name|FSImage
argument_list|(
name|getFSNamesystem
argument_list|()
argument_list|)
decl_stmt|;
name|prevState
operator|.
name|getStorage
argument_list|()
operator|.
name|layoutVersion
operator|=
name|FSConstants
operator|.
name|LAYOUT_VERSION
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|File
name|prevDir
init|=
name|sd
operator|.
name|getPreviousDir
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|prevDir
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|// use current directory then
name|LOG
operator|.
name|info
argument_list|(
literal|"Storage directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|" does not contain previous fs state."
argument_list|)
expr_stmt|;
name|sd
operator|.
name|read
argument_list|()
expr_stmt|;
comment|// read and verify consistency with other directories
continue|continue;
block|}
name|StorageDirectory
name|sdPrev
init|=
name|prevState
operator|.
name|getStorage
argument_list|()
operator|.
operator|new
name|StorageDirectory
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|)
decl_stmt|;
comment|// read and verify consistency of the prev dir
name|sdPrev
operator|.
name|read
argument_list|(
name|sdPrev
operator|.
name|getPreviousVersionFile
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|prevState
operator|.
name|getLayoutVersion
argument_list|()
operator|!=
name|FSConstants
operator|.
name|LAYOUT_VERSION
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot rollback to storage version "
operator|+
name|prevState
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|" using this version of the NameNode, which uses storage version "
operator|+
name|FSConstants
operator|.
name|LAYOUT_VERSION
operator|+
literal|". "
operator|+
literal|"Please use the previous version of HDFS to perform the rollback."
argument_list|)
throw|;
block|}
name|canRollback
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|canRollback
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot rollback. None of the storage "
operator|+
literal|"directories contain previous fs state."
argument_list|)
throw|;
comment|// Now that we know all directories are going to be consistent
comment|// Do rollback for each directory containing previous state
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|File
name|prevDir
init|=
name|sd
operator|.
name|getPreviousDir
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|prevDir
operator|.
name|exists
argument_list|()
condition|)
continue|continue;
name|LOG
operator|.
name|info
argument_list|(
literal|"Rolling back storage directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|".\n   new LV = "
operator|+
name|prevState
operator|.
name|getStorage
argument_list|()
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|"; new CTime = "
operator|+
name|prevState
operator|.
name|getStorage
argument_list|()
operator|.
name|getCTime
argument_list|()
argument_list|)
expr_stmt|;
name|File
name|tmpDir
init|=
name|sd
operator|.
name|getRemovedTmp
argument_list|()
decl_stmt|;
assert|assert
operator|!
name|tmpDir
operator|.
name|exists
argument_list|()
operator|:
literal|"removed.tmp directory must not exist."
assert|;
comment|// rename current to tmp
name|File
name|curDir
init|=
name|sd
operator|.
name|getCurrentDir
argument_list|()
decl_stmt|;
assert|assert
name|curDir
operator|.
name|exists
argument_list|()
operator|:
literal|"Current directory must exist."
assert|;
name|NNStorage
operator|.
name|rename
argument_list|(
name|curDir
argument_list|,
name|tmpDir
argument_list|)
expr_stmt|;
comment|// rename previous to current
name|NNStorage
operator|.
name|rename
argument_list|(
name|prevDir
argument_list|,
name|curDir
argument_list|)
expr_stmt|;
comment|// delete tmp dir
name|NNStorage
operator|.
name|deleteDir
argument_list|(
name|tmpDir
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Rollback of "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|" is complete."
argument_list|)
expr_stmt|;
block|}
name|isUpgradeFinalized
operator|=
literal|true
expr_stmt|;
comment|// check whether name-node can start in regular mode
name|storage
operator|.
name|verifyDistributedUpgradeProgress
argument_list|(
name|StartupOption
operator|.
name|REGULAR
argument_list|)
expr_stmt|;
block|}
DECL|method|doFinalize (StorageDirectory sd)
specifier|private
name|void
name|doFinalize
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|prevDir
init|=
name|sd
operator|.
name|getPreviousDir
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|prevDir
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|// already discarded
name|LOG
operator|.
name|info
argument_list|(
literal|"Directory "
operator|+
name|prevDir
operator|+
literal|" does not exist."
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Finalize upgrade for "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|" is not required."
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Finalizing upgrade for storage directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|"."
operator|+
operator|(
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|==
literal|0
condition|?
literal|""
else|:
literal|"\n   cur LV = "
operator|+
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|"; cur CTime = "
operator|+
name|storage
operator|.
name|getCTime
argument_list|()
operator|)
argument_list|)
expr_stmt|;
assert|assert
name|sd
operator|.
name|getCurrentDir
argument_list|()
operator|.
name|exists
argument_list|()
operator|:
literal|"Current directory must exist."
assert|;
specifier|final
name|File
name|tmpDir
init|=
name|sd
operator|.
name|getFinalizedTmp
argument_list|()
decl_stmt|;
comment|// rename previous to tmp and remove
name|NNStorage
operator|.
name|rename
argument_list|(
name|prevDir
argument_list|,
name|tmpDir
argument_list|)
expr_stmt|;
name|NNStorage
operator|.
name|deleteDir
argument_list|(
name|tmpDir
argument_list|)
expr_stmt|;
name|isUpgradeFinalized
operator|=
literal|true
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Finalize upgrade for "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|" is complete."
argument_list|)
expr_stmt|;
block|}
comment|/**    * Load image from a checkpoint directory and save it into the current one.    * @throws IOException    */
DECL|method|doImportCheckpoint ()
name|void
name|doImportCheckpoint
parameter_list|()
throws|throws
name|IOException
block|{
name|FSNamesystem
name|fsNamesys
init|=
name|getFSNamesystem
argument_list|()
decl_stmt|;
name|FSImage
name|ckptImage
init|=
operator|new
name|FSImage
argument_list|(
name|fsNamesys
argument_list|)
decl_stmt|;
comment|// replace real image with the checkpoint image
name|FSImage
name|realImage
init|=
name|fsNamesys
operator|.
name|getFSImage
argument_list|()
decl_stmt|;
assert|assert
name|realImage
operator|==
name|this
assert|;
name|fsNamesys
operator|.
name|dir
operator|.
name|fsImage
operator|=
name|ckptImage
expr_stmt|;
comment|// load from the checkpoint dirs
try|try
block|{
name|ckptImage
operator|.
name|recoverTransitionRead
argument_list|(
name|checkpointDirs
argument_list|,
name|checkpointEditsDirs
argument_list|,
name|StartupOption
operator|.
name|REGULAR
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|ckptImage
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// return back the real image
name|realImage
operator|.
name|getStorage
argument_list|()
operator|.
name|setStorageInfo
argument_list|(
name|ckptImage
operator|.
name|getStorage
argument_list|()
argument_list|)
expr_stmt|;
name|storage
operator|.
name|setCheckpointTime
argument_list|(
name|ckptImage
operator|.
name|getStorage
argument_list|()
operator|.
name|getCheckpointTime
argument_list|()
argument_list|)
expr_stmt|;
name|fsNamesys
operator|.
name|dir
operator|.
name|fsImage
operator|=
name|realImage
expr_stmt|;
name|realImage
operator|.
name|getStorage
argument_list|()
operator|.
name|setBlockPoolID
argument_list|(
name|ckptImage
operator|.
name|getBlockPoolID
argument_list|()
argument_list|)
expr_stmt|;
comment|// and save it but keep the same checkpointTime
name|saveNamespace
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|finalizeUpgrade ()
name|void
name|finalizeUpgrade
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|doFinalize
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|isUpgradeFinalized ()
name|boolean
name|isUpgradeFinalized
parameter_list|()
block|{
return|return
name|isUpgradeFinalized
return|;
block|}
DECL|method|getEditLog ()
specifier|public
name|FSEditLog
name|getEditLog
parameter_list|()
block|{
return|return
name|editLog
return|;
block|}
comment|//
comment|// Atomic move sequence, to recover from interrupted checkpoint
comment|//
DECL|method|recoverInterruptedCheckpoint (StorageDirectory nameSD, StorageDirectory editsSD)
name|boolean
name|recoverInterruptedCheckpoint
parameter_list|(
name|StorageDirectory
name|nameSD
parameter_list|,
name|StorageDirectory
name|editsSD
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|needToSave
init|=
literal|false
decl_stmt|;
name|File
name|curFile
init|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|nameSD
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE
argument_list|)
decl_stmt|;
name|File
name|ckptFile
init|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|nameSD
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE_NEW
argument_list|)
decl_stmt|;
comment|//
comment|// If we were in the midst of a checkpoint
comment|//
if|if
condition|(
name|ckptFile
operator|.
name|exists
argument_list|()
condition|)
block|{
name|needToSave
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|editsSD
argument_list|,
name|NameNodeFile
operator|.
name|EDITS_NEW
argument_list|)
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|//
comment|// checkpointing migth have uploaded a new
comment|// merged image, but we discard it here because we are
comment|// not sure whether the entire merged image was uploaded
comment|// before the namenode crashed.
comment|//
if|if
condition|(
operator|!
name|ckptFile
operator|.
name|delete
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to delete "
operator|+
name|ckptFile
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|//
comment|// checkpointing was in progress when the namenode
comment|// shutdown. The fsimage.ckpt was created and the edits.new
comment|// file was moved to edits. We complete that checkpoint by
comment|// moving fsimage.new to fsimage. There is no need to
comment|// update the fstime file here. renameTo fails on Windows
comment|// if the destination file already exists.
comment|//
if|if
condition|(
operator|!
name|ckptFile
operator|.
name|renameTo
argument_list|(
name|curFile
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|curFile
operator|.
name|delete
argument_list|()
condition|)
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to delete dir "
operator|+
name|curFile
operator|+
literal|" before rename"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ckptFile
operator|.
name|renameTo
argument_list|(
name|curFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to rename "
operator|+
name|ckptFile
operator|+
literal|" to "
operator|+
name|curFile
argument_list|)
throw|;
block|}
block|}
block|}
block|}
return|return
name|needToSave
return|;
block|}
comment|/**    * Choose latest image from one of the directories,    * load it and merge with the edits from that directory.    *     * Saving and loading fsimage should never trigger symlink resolution.     * The paths that are persisted do not have *intermediate* symlinks     * because intermediate symlinks are resolved at the time files,     * directories, and symlinks are created. All paths accessed while     * loading or saving fsimage should therefore only see symlinks as     * the final path component, and the functions called below do not    * resolve symlinks that are the final path component.    *    * @return whether the image should be saved    * @throws IOException    */
DECL|method|loadFSImage ()
name|boolean
name|loadFSImage
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|latestNameCheckpointTime
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
name|long
name|latestEditsCheckpointTime
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
name|boolean
name|needToSave
init|=
literal|false
decl_stmt|;
name|isUpgradeFinalized
operator|=
literal|true
expr_stmt|;
name|StorageDirectory
name|latestNameSD
init|=
literal|null
decl_stmt|;
name|StorageDirectory
name|latestEditsSD
init|=
literal|null
decl_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|imageDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|editsDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// Set to determine if all of storageDirectories share the same checkpoint
name|Set
argument_list|<
name|Long
argument_list|>
name|checkpointTimes
init|=
operator|new
name|HashSet
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
comment|// Process each of the storage directories to find the pair of
comment|// newest image file and edit file
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// Was the file just formatted?
if|if
condition|(
operator|!
name|sd
operator|.
name|getVersionFile
argument_list|()
operator|.
name|exists
argument_list|()
condition|)
block|{
name|needToSave
operator||=
literal|true
expr_stmt|;
continue|continue;
block|}
name|boolean
name|imageExists
init|=
literal|false
decl_stmt|;
name|boolean
name|editsExists
init|=
literal|false
decl_stmt|;
comment|// Determine if sd is image, edits or both
if|if
condition|(
name|sd
operator|.
name|getStorageDirType
argument_list|()
operator|.
name|isOfType
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
condition|)
block|{
name|imageExists
operator|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE
argument_list|)
operator|.
name|exists
argument_list|()
expr_stmt|;
name|imageDirs
operator|.
name|add
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sd
operator|.
name|getStorageDirType
argument_list|()
operator|.
name|isOfType
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
condition|)
block|{
name|editsExists
operator|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|EDITS
argument_list|)
operator|.
name|exists
argument_list|()
expr_stmt|;
name|editsDirs
operator|.
name|add
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|long
name|checkpointTime
init|=
name|storage
operator|.
name|readCheckpointTime
argument_list|(
name|sd
argument_list|)
decl_stmt|;
name|checkpointTimes
operator|.
name|add
argument_list|(
name|checkpointTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|.
name|getStorageDirType
argument_list|()
operator|.
name|isOfType
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
operator|&&
operator|(
name|latestNameCheckpointTime
operator|<
name|checkpointTime
operator|)
operator|&&
name|imageExists
condition|)
block|{
name|latestNameCheckpointTime
operator|=
name|checkpointTime
expr_stmt|;
name|latestNameSD
operator|=
name|sd
expr_stmt|;
block|}
if|if
condition|(
name|sd
operator|.
name|getStorageDirType
argument_list|()
operator|.
name|isOfType
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
operator|&&
operator|(
name|latestEditsCheckpointTime
operator|<
name|checkpointTime
operator|)
operator|&&
name|editsExists
condition|)
block|{
name|latestEditsCheckpointTime
operator|=
name|checkpointTime
expr_stmt|;
name|latestEditsSD
operator|=
name|sd
expr_stmt|;
block|}
comment|// check that we have a valid, non-default checkpointTime
if|if
condition|(
name|checkpointTime
operator|<=
literal|0L
condition|)
name|needToSave
operator||=
literal|true
expr_stmt|;
comment|// set finalized flag
name|isUpgradeFinalized
operator|=
name|isUpgradeFinalized
operator|&&
operator|!
name|sd
operator|.
name|getPreviousDir
argument_list|()
operator|.
name|exists
argument_list|()
expr_stmt|;
block|}
comment|// We should have at least one image and one edits dirs
if|if
condition|(
name|latestNameSD
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Image file is not found in "
operator|+
name|imageDirs
argument_list|)
throw|;
if|if
condition|(
name|latestEditsSD
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Edits file is not found in "
operator|+
name|editsDirs
argument_list|)
throw|;
comment|// Make sure we are loading image and edits from same checkpoint
if|if
condition|(
name|latestNameCheckpointTime
operator|>
name|latestEditsCheckpointTime
operator|&&
name|latestNameSD
operator|!=
name|latestEditsSD
operator|&&
name|latestNameSD
operator|.
name|getStorageDirType
argument_list|()
operator|==
name|NameNodeDirType
operator|.
name|IMAGE
operator|&&
name|latestEditsSD
operator|.
name|getStorageDirType
argument_list|()
operator|==
name|NameNodeDirType
operator|.
name|EDITS
condition|)
block|{
comment|// This is a rare failure when NN has image-only and edits-only
comment|// storage directories, and fails right after saving images,
comment|// in some of the storage directories, but before purging edits.
comment|// See -NOTE- in saveNamespace().
name|LOG
operator|.
name|error
argument_list|(
literal|"This is a rare failure scenario!!!"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Image checkpoint time "
operator|+
name|latestNameCheckpointTime
operator|+
literal|"> edits checkpoint time "
operator|+
name|latestEditsCheckpointTime
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
literal|"Name-node will treat the image as the latest state of "
operator|+
literal|"the namespace. Old edits will be discarded."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|latestNameCheckpointTime
operator|!=
name|latestEditsCheckpointTime
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Inconsistent storage detected, "
operator|+
literal|"image and edits checkpoint times do not match. "
operator|+
literal|"image checkpoint time = "
operator|+
name|latestNameCheckpointTime
operator|+
literal|"edits checkpoint time = "
operator|+
name|latestEditsCheckpointTime
argument_list|)
throw|;
comment|// If there was more than one checkpointTime recorded we should save
name|needToSave
operator||=
name|checkpointTimes
operator|.
name|size
argument_list|()
operator|!=
literal|1
expr_stmt|;
comment|// Recover from previous interrupted checkpoint, if any
name|needToSave
operator||=
name|recoverInterruptedCheckpoint
argument_list|(
name|latestNameSD
argument_list|,
name|latestEditsSD
argument_list|)
expr_stmt|;
comment|//
comment|// Load in bits
comment|//
name|latestNameSD
operator|.
name|read
argument_list|()
expr_stmt|;
name|needToSave
operator||=
name|loadFSImage
argument_list|(
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|latestNameSD
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE
argument_list|)
argument_list|)
expr_stmt|;
comment|// Load latest edits
if|if
condition|(
name|latestNameCheckpointTime
operator|>
name|latestEditsCheckpointTime
condition|)
comment|// the image is already current, discard edits
name|needToSave
operator||=
literal|true
expr_stmt|;
else|else
comment|// latestNameCheckpointTime == latestEditsCheckpointTime
name|needToSave
operator||=
operator|(
name|loadFSEdits
argument_list|(
name|latestEditsSD
argument_list|)
operator|>
literal|0
operator|)
expr_stmt|;
return|return
name|needToSave
return|;
block|}
comment|/**    * Load in the filesystem image from file. It's a big list of    * filenames and blocks.  Return whether we should    * "re-save" and consolidate the edit-logs    */
DECL|method|loadFSImage (File curFile)
name|boolean
name|loadFSImage
parameter_list|(
name|File
name|curFile
parameter_list|)
throws|throws
name|IOException
block|{
name|FSImageFormat
operator|.
name|Loader
name|loader
init|=
operator|new
name|FSImageFormat
operator|.
name|Loader
argument_list|(
name|conf
argument_list|,
name|getFSNamesystem
argument_list|()
argument_list|)
decl_stmt|;
name|loader
operator|.
name|load
argument_list|(
name|curFile
argument_list|)
expr_stmt|;
name|namesystem
operator|.
name|setBlockPoolId
argument_list|(
name|this
operator|.
name|getBlockPoolID
argument_list|()
argument_list|)
expr_stmt|;
comment|// Check that the image digest we loaded matches up with what
comment|// we expected
name|MD5Hash
name|readImageMd5
init|=
name|loader
operator|.
name|getLoadedImageMd5
argument_list|()
decl_stmt|;
if|if
condition|(
name|storage
operator|.
name|getImageDigest
argument_list|()
operator|==
literal|null
condition|)
block|{
name|storage
operator|.
name|setImageDigest
argument_list|(
name|readImageMd5
argument_list|)
expr_stmt|;
comment|// set this fsimage's checksum
block|}
elseif|else
if|if
condition|(
operator|!
name|storage
operator|.
name|getImageDigest
argument_list|()
operator|.
name|equals
argument_list|(
name|readImageMd5
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Image file "
operator|+
name|curFile
operator|+
literal|" is corrupt with MD5 checksum of "
operator|+
name|readImageMd5
operator|+
literal|" but expecting "
operator|+
name|storage
operator|.
name|getImageDigest
argument_list|()
argument_list|)
throw|;
block|}
name|storage
operator|.
name|namespaceID
operator|=
name|loader
operator|.
name|getLoadedNamespaceID
argument_list|()
expr_stmt|;
name|storage
operator|.
name|layoutVersion
operator|=
name|loader
operator|.
name|getLoadedImageVersion
argument_list|()
expr_stmt|;
name|boolean
name|needToSave
init|=
name|loader
operator|.
name|getLoadedImageVersion
argument_list|()
operator|!=
name|FSConstants
operator|.
name|LAYOUT_VERSION
decl_stmt|;
return|return
name|needToSave
return|;
block|}
comment|/**    * Load and merge edits from two edits files    *     * @param sd storage directory    * @return number of edits loaded    * @throws IOException    */
DECL|method|loadFSEdits (StorageDirectory sd)
name|int
name|loadFSEdits
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|FSEditLogLoader
name|loader
init|=
operator|new
name|FSEditLogLoader
argument_list|(
name|namesystem
argument_list|)
decl_stmt|;
name|int
name|numEdits
init|=
literal|0
decl_stmt|;
name|EditLogFileInputStream
name|edits
init|=
operator|new
name|EditLogFileInputStream
argument_list|(
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|EDITS
argument_list|)
argument_list|)
decl_stmt|;
name|numEdits
operator|=
name|loader
operator|.
name|loadFSEdits
argument_list|(
name|edits
argument_list|)
expr_stmt|;
name|edits
operator|.
name|close
argument_list|()
expr_stmt|;
name|File
name|editsNew
init|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|EDITS_NEW
argument_list|)
decl_stmt|;
if|if
condition|(
name|editsNew
operator|.
name|exists
argument_list|()
operator|&&
name|editsNew
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|edits
operator|=
operator|new
name|EditLogFileInputStream
argument_list|(
name|editsNew
argument_list|)
expr_stmt|;
name|numEdits
operator|+=
name|loader
operator|.
name|loadFSEdits
argument_list|(
name|edits
argument_list|)
expr_stmt|;
name|edits
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// update the counts.
name|getFSNamesystem
argument_list|()
operator|.
name|dir
operator|.
name|updateCountForINodeWithQuota
argument_list|()
expr_stmt|;
return|return
name|numEdits
return|;
block|}
comment|/**    * Save the contents of the FS image to the file.    */
DECL|method|saveFSImage (File newFile)
name|void
name|saveFSImage
parameter_list|(
name|File
name|newFile
parameter_list|)
throws|throws
name|IOException
block|{
name|FSImageFormat
operator|.
name|Saver
name|saver
init|=
operator|new
name|FSImageFormat
operator|.
name|Saver
argument_list|()
decl_stmt|;
name|FSImageCompression
name|compression
init|=
name|FSImageCompression
operator|.
name|createCompression
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|saver
operator|.
name|save
argument_list|(
name|newFile
argument_list|,
name|getFSNamesystem
argument_list|()
argument_list|,
name|compression
argument_list|)
expr_stmt|;
name|storage
operator|.
name|setImageDigest
argument_list|(
name|saver
operator|.
name|getSavedDigest
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * FSImageSaver is being run in a separate thread when saving    * FSImage. There is one thread per each copy of the image.    *    * FSImageSaver assumes that it was launched from a thread that holds    * FSNamesystem lock and waits for the execution of FSImageSaver thread    * to finish.    * This way we are guraranteed that the namespace is not being updated    * while multiple instances of FSImageSaver are traversing it    * and writing it out.    */
DECL|class|FSImageSaver
specifier|private
class|class
name|FSImageSaver
implements|implements
name|Runnable
block|{
DECL|field|sd
specifier|private
name|StorageDirectory
name|sd
decl_stmt|;
DECL|field|errorSDs
specifier|private
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|errorSDs
decl_stmt|;
DECL|method|FSImageSaver (StorageDirectory sd, List<StorageDirectory> errorSDs)
name|FSImageSaver
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|,
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|errorSDs
parameter_list|)
block|{
name|this
operator|.
name|sd
operator|=
name|sd
expr_stmt|;
name|this
operator|.
name|errorSDs
operator|=
name|errorSDs
expr_stmt|;
block|}
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|saveCurrent
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to save image for "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|errorSDs
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"FSImageSaver for "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|" of type "
operator|+
name|sd
operator|.
name|getStorageDirType
argument_list|()
return|;
block|}
block|}
DECL|method|waitForThreads (List<Thread> threads)
specifier|private
name|void
name|waitForThreads
parameter_list|(
name|List
argument_list|<
name|Thread
argument_list|>
name|threads
parameter_list|)
block|{
for|for
control|(
name|Thread
name|thread
range|:
name|threads
control|)
block|{
while|while
condition|(
name|thread
operator|.
name|isAlive
argument_list|()
condition|)
block|{
try|try
block|{
name|thread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|iex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Caught exception while waiting for thread "
operator|+
name|thread
operator|.
name|getName
argument_list|()
operator|+
literal|" to finish. Retrying join"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Save the contents of the FS image and create empty edits.    *     * In order to minimize the recovery effort in case of failure during    * saveNamespace the algorithm reduces discrepancy between directory states    * by performing updates in the following order:    *<ol>    *<li> rename current to lastcheckpoint.tmp for all of them,</li>    *<li> save image and recreate edits for all of them,</li>    *<li> rename lastcheckpoint.tmp to previous.checkpoint.</li>    *</ol>    * On stage (2) we first save all images, then recreate edits.    * Otherwise the name-node may purge all edits and fail,    * in which case the journal will be lost.    */
DECL|method|saveNamespace (boolean renewCheckpointTime)
name|void
name|saveNamespace
parameter_list|(
name|boolean
name|renewCheckpointTime
parameter_list|)
throws|throws
name|IOException
block|{
comment|// try to restore all failed edit logs here
assert|assert
name|editLog
operator|!=
literal|null
operator|:
literal|"editLog must be initialized"
assert|;
name|storage
operator|.
name|attemptRestoreRemovedStorage
argument_list|()
expr_stmt|;
name|editLog
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|renewCheckpointTime
condition|)
name|storage
operator|.
name|setCheckpointTime
argument_list|(
name|now
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|errorSDs
init|=
name|Collections
operator|.
name|synchronizedList
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|StorageDirectory
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|// mv current -> lastcheckpoint.tmp
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|storage
operator|.
name|moveCurrent
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to move current for "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|errorSDs
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|Thread
argument_list|>
name|saveThreads
init|=
operator|new
name|ArrayList
argument_list|<
name|Thread
argument_list|>
argument_list|()
decl_stmt|;
comment|// save images into current
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|errorSDs
operator|.
name|contains
argument_list|(
name|sd
argument_list|)
condition|)
block|{
continue|continue;
block|}
try|try
block|{
name|FSImageSaver
name|saver
init|=
operator|new
name|FSImageSaver
argument_list|(
name|sd
argument_list|,
name|errorSDs
argument_list|)
decl_stmt|;
name|Thread
name|saveThread
init|=
operator|new
name|Thread
argument_list|(
name|saver
argument_list|,
name|saver
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|saveThreads
operator|.
name|add
argument_list|(
name|saveThread
argument_list|)
expr_stmt|;
name|saveThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed save to image directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|errorSDs
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|waitForThreads
argument_list|(
name|saveThreads
argument_list|)
expr_stmt|;
name|saveThreads
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// -NOTE-
comment|// If NN has image-only and edits-only storage directories and fails here
comment|// the image will have the latest namespace state.
comment|// During startup the image-only directories will recover by discarding
comment|// lastcheckpoint.tmp, while
comment|// the edits-only directories will recover by falling back
comment|// to the old state contained in their lastcheckpoint.tmp.
comment|// The edits directories should be discarded during startup because their
comment|// checkpointTime is older than that of image directories.
comment|// recreate edits in current
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|errorSDs
operator|.
name|contains
argument_list|(
name|sd
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// if this directory already stores the image and edits, then it was
comment|// already processed in the earlier loop.
if|if
condition|(
name|sd
operator|.
name|getStorageDirType
argument_list|()
operator|==
name|NameNodeDirType
operator|.
name|IMAGE_AND_EDITS
condition|)
block|{
continue|continue;
block|}
try|try
block|{
name|FSImageSaver
name|saver
init|=
operator|new
name|FSImageSaver
argument_list|(
name|sd
argument_list|,
name|errorSDs
argument_list|)
decl_stmt|;
name|Thread
name|saveThread
init|=
operator|new
name|Thread
argument_list|(
name|saver
argument_list|,
name|saver
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|saveThreads
operator|.
name|add
argument_list|(
name|saveThread
argument_list|)
expr_stmt|;
name|saveThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed save to edits directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|errorSDs
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|waitForThreads
argument_list|(
name|saveThreads
argument_list|)
expr_stmt|;
comment|// mv lastcheckpoint.tmp -> previous.checkpoint
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|errorSDs
operator|.
name|contains
argument_list|(
name|sd
argument_list|)
condition|)
block|{
continue|continue;
block|}
try|try
block|{
name|storage
operator|.
name|moveLastCheckpoint
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to move last checkpoint for "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|errorSDs
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
try|try
block|{
name|storage
operator|.
name|reportErrorsOnDirectories
argument_list|(
name|errorSDs
argument_list|)
expr_stmt|;
comment|// If there was an error in every storage dir, each one will have been
comment|// removed from the list of storage directories.
if|if
condition|(
name|storage
operator|.
name|getNumStorageDirs
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
operator|==
literal|0
operator|||
name|storage
operator|.
name|getNumStorageDirs
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to save any storage directories while saving namespace"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|editLog
operator|.
name|isOpen
argument_list|()
condition|)
name|editLog
operator|.
name|open
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|ckptState
operator|=
name|CheckpointStates
operator|.
name|UPLOAD_DONE
expr_stmt|;
block|}
block|}
comment|/**    * Save current image and empty journal into {@code current} directory.    */
DECL|method|saveCurrent (StorageDirectory sd)
specifier|protected
name|void
name|saveCurrent
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|!=
name|FSConstants
operator|.
name|LAYOUT_VERSION
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"NN with storage version "
operator|+
name|FSConstants
operator|.
name|LAYOUT_VERSION
operator|+
literal|"cannot save an image with version "
operator|+
name|storage
operator|.
name|getLayoutVersion
argument_list|()
argument_list|)
throw|;
block|}
name|File
name|curDir
init|=
name|sd
operator|.
name|getCurrentDir
argument_list|()
decl_stmt|;
name|NameNodeDirType
name|dirType
init|=
operator|(
name|NameNodeDirType
operator|)
name|sd
operator|.
name|getStorageDirType
argument_list|()
decl_stmt|;
comment|// save new image or new edits
if|if
condition|(
operator|!
name|curDir
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|curDir
operator|.
name|mkdir
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot create directory "
operator|+
name|curDir
argument_list|)
throw|;
if|if
condition|(
name|dirType
operator|.
name|isOfType
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
condition|)
name|saveFSImage
argument_list|(
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirType
operator|.
name|isOfType
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
condition|)
name|editLog
operator|.
name|createEditLogFile
argument_list|(
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|EDITS
argument_list|)
argument_list|)
expr_stmt|;
comment|// write version and time files
name|sd
operator|.
name|write
argument_list|()
expr_stmt|;
block|}
comment|/**    * Moves fsimage.ckpt to fsImage and edits.new to edits    * Reopens the new edits file.    */
DECL|method|rollFSImage (CheckpointSignature sig, boolean renewCheckpointTime)
name|void
name|rollFSImage
parameter_list|(
name|CheckpointSignature
name|sig
parameter_list|,
name|boolean
name|renewCheckpointTime
parameter_list|)
throws|throws
name|IOException
block|{
name|sig
operator|.
name|validateStorageInfo
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|rollFSImage
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|rollFSImage (boolean renewCheckpointTime)
specifier|private
name|void
name|rollFSImage
parameter_list|(
name|boolean
name|renewCheckpointTime
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|ckptState
operator|!=
name|CheckpointStates
operator|.
name|UPLOAD_DONE
operator|&&
operator|!
operator|(
name|ckptState
operator|==
name|CheckpointStates
operator|.
name|ROLLED_EDITS
operator|&&
name|storage
operator|.
name|getNumStorageDirs
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot roll fsImage before rolling edits log."
argument_list|)
throw|;
block|}
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|File
name|ckpt
init|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE_NEW
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ckpt
operator|.
name|exists
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Checkpoint file "
operator|+
name|ckpt
operator|+
literal|" does not exist"
argument_list|)
throw|;
block|}
block|}
name|editLog
operator|.
name|purgeEditLog
argument_list|()
expr_stmt|;
comment|// renamed edits.new to edits
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"rollFSImage after purgeEditLog: storageList="
operator|+
name|storage
operator|.
name|listStorageDirectories
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//
comment|// Renames new image
comment|//
name|renameCheckpoint
argument_list|()
expr_stmt|;
name|resetVersion
argument_list|(
name|renewCheckpointTime
argument_list|,
name|newImageDigest
argument_list|)
expr_stmt|;
block|}
comment|/**    * Renames new image    */
DECL|method|renameCheckpoint ()
name|void
name|renameCheckpoint
parameter_list|()
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|StorageDirectory
argument_list|>
name|al
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|File
name|ckpt
init|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE_NEW
argument_list|)
decl_stmt|;
name|File
name|curFile
init|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE
argument_list|)
decl_stmt|;
comment|// renameTo fails on Windows if the destination file
comment|// already exists.
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"renaming  "
operator|+
name|ckpt
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" to "
operator|+
name|curFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ckpt
operator|.
name|renameTo
argument_list|(
name|curFile
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|curFile
operator|.
name|delete
argument_list|()
operator|||
operator|!
name|ckpt
operator|.
name|renameTo
argument_list|(
name|curFile
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"renaming  "
operator|+
name|ckpt
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" to "
operator|+
name|curFile
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|" FAILED"
argument_list|)
expr_stmt|;
if|if
condition|(
name|al
operator|==
literal|null
condition|)
name|al
operator|=
operator|new
name|ArrayList
argument_list|<
name|StorageDirectory
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|al
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|al
operator|!=
literal|null
condition|)
name|storage
operator|.
name|reportErrorsOnDirectories
argument_list|(
name|al
argument_list|)
expr_stmt|;
block|}
comment|/**    * Updates version and fstime files in all directories (fsimage and edits).    */
DECL|method|resetVersion (boolean renewCheckpointTime, MD5Hash newImageDigest)
name|void
name|resetVersion
parameter_list|(
name|boolean
name|renewCheckpointTime
parameter_list|,
name|MD5Hash
name|newImageDigest
parameter_list|)
throws|throws
name|IOException
block|{
name|storage
operator|.
name|layoutVersion
operator|=
name|FSConstants
operator|.
name|LAYOUT_VERSION
expr_stmt|;
if|if
condition|(
name|renewCheckpointTime
condition|)
name|storage
operator|.
name|setCheckpointTime
argument_list|(
name|now
argument_list|()
argument_list|)
expr_stmt|;
name|storage
operator|.
name|setImageDigest
argument_list|(
name|newImageDigest
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|StorageDirectory
argument_list|>
name|al
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// delete old edits if sd is the image only the directory
if|if
condition|(
operator|!
name|sd
operator|.
name|getStorageDirType
argument_list|()
operator|.
name|isOfType
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
condition|)
block|{
name|File
name|editsFile
init|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|EDITS
argument_list|)
decl_stmt|;
if|if
condition|(
name|editsFile
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|editsFile
operator|.
name|delete
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot delete edits file "
operator|+
name|editsFile
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
throw|;
block|}
comment|// delete old fsimage if sd is the edits only the directory
if|if
condition|(
operator|!
name|sd
operator|.
name|getStorageDirType
argument_list|()
operator|.
name|isOfType
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
condition|)
block|{
name|File
name|imageFile
init|=
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE
argument_list|)
decl_stmt|;
if|if
condition|(
name|imageFile
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|imageFile
operator|.
name|delete
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot delete image file "
operator|+
name|imageFile
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
throw|;
block|}
try|try
block|{
name|sd
operator|.
name|write
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot write file "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|al
operator|==
literal|null
condition|)
name|al
operator|=
operator|new
name|ArrayList
argument_list|<
name|StorageDirectory
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|al
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|al
operator|!=
literal|null
condition|)
name|storage
operator|.
name|reportErrorsOnDirectories
argument_list|(
name|al
argument_list|)
expr_stmt|;
name|ckptState
operator|=
name|FSImage
operator|.
name|CheckpointStates
operator|.
name|START
expr_stmt|;
block|}
DECL|method|rollEditLog ()
name|CheckpointSignature
name|rollEditLog
parameter_list|()
throws|throws
name|IOException
block|{
name|getEditLog
argument_list|()
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
name|ckptState
operator|=
name|CheckpointStates
operator|.
name|ROLLED_EDITS
expr_stmt|;
comment|// If checkpoint fails this should be the most recent image, therefore
name|storage
operator|.
name|incrementCheckpointTime
argument_list|()
expr_stmt|;
return|return
operator|new
name|CheckpointSignature
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**    * This is called just before a new checkpoint is uploaded to the    * namenode.    */
DECL|method|validateCheckpointUpload (CheckpointSignature sig)
name|void
name|validateCheckpointUpload
parameter_list|(
name|CheckpointSignature
name|sig
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|ckptState
operator|!=
name|CheckpointStates
operator|.
name|ROLLED_EDITS
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Namenode is not expecting an new image "
operator|+
name|ckptState
argument_list|)
throw|;
block|}
comment|// verify token
name|long
name|modtime
init|=
name|getEditLog
argument_list|()
operator|.
name|getFsEditTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|sig
operator|.
name|editsTime
operator|!=
name|modtime
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Namenode has an edit log with timestamp of "
operator|+
name|DATE_FORM
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|(
name|modtime
argument_list|)
argument_list|)
operator|+
literal|" but new checkpoint was created using editlog "
operator|+
literal|" with timestamp "
operator|+
name|DATE_FORM
operator|.
name|format
argument_list|(
operator|new
name|Date
argument_list|(
name|sig
operator|.
name|editsTime
argument_list|)
argument_list|)
operator|+
literal|". Checkpoint Aborted."
argument_list|)
throw|;
block|}
name|sig
operator|.
name|validateStorageInfo
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|ckptState
operator|=
name|FSImage
operator|.
name|CheckpointStates
operator|.
name|UPLOAD_START
expr_stmt|;
block|}
comment|/**    * Start checkpoint.    *<p>    * If backup storage contains image that is newer than or incompatible with     * what the active name-node has, then the backup node should shutdown.<br>    * If the backup image is older than the active one then it should     * be discarded and downloaded from the active node.<br>    * If the images are the same then the backup image will be used as current.    *     * @param bnReg the backup node registration.    * @param nnReg this (active) name-node registration.    * @return {@link NamenodeCommand} if backup node should shutdown or    * {@link CheckpointCommand} prescribing what backup node should     *         do with its image.    * @throws IOException    */
DECL|method|startCheckpoint (NamenodeRegistration bnReg, NamenodeRegistration nnReg)
name|NamenodeCommand
name|startCheckpoint
parameter_list|(
name|NamenodeRegistration
name|bnReg
parameter_list|,
comment|// backup node
name|NamenodeRegistration
name|nnReg
parameter_list|)
comment|// active name-node
throws|throws
name|IOException
block|{
name|String
name|msg
init|=
literal|null
decl_stmt|;
comment|// Verify that checkpoint is allowed
if|if
condition|(
name|bnReg
operator|.
name|getNamespaceID
argument_list|()
operator|!=
name|storage
operator|.
name|getNamespaceID
argument_list|()
condition|)
name|msg
operator|=
literal|"Name node "
operator|+
name|bnReg
operator|.
name|getAddress
argument_list|()
operator|+
literal|" has incompatible namespace id: "
operator|+
name|bnReg
operator|.
name|getNamespaceID
argument_list|()
operator|+
literal|" expected: "
operator|+
name|storage
operator|.
name|getNamespaceID
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|bnReg
operator|.
name|isRole
argument_list|(
name|NamenodeRole
operator|.
name|ACTIVE
argument_list|)
condition|)
name|msg
operator|=
literal|"Name node "
operator|+
name|bnReg
operator|.
name|getAddress
argument_list|()
operator|+
literal|" role "
operator|+
name|bnReg
operator|.
name|getRole
argument_list|()
operator|+
literal|": checkpoint is not allowed."
expr_stmt|;
elseif|else
if|if
condition|(
name|bnReg
operator|.
name|getLayoutVersion
argument_list|()
operator|<
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|||
operator|(
name|bnReg
operator|.
name|getLayoutVersion
argument_list|()
operator|==
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|&&
name|bnReg
operator|.
name|getCTime
argument_list|()
operator|>
name|storage
operator|.
name|getCTime
argument_list|()
operator|)
operator|||
operator|(
name|bnReg
operator|.
name|getLayoutVersion
argument_list|()
operator|==
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|&&
name|bnReg
operator|.
name|getCTime
argument_list|()
operator|==
name|storage
operator|.
name|getCTime
argument_list|()
operator|&&
name|bnReg
operator|.
name|getCheckpointTime
argument_list|()
operator|>
name|storage
operator|.
name|getCheckpointTime
argument_list|()
operator|)
condition|)
comment|// remote node has newer image age
name|msg
operator|=
literal|"Name node "
operator|+
name|bnReg
operator|.
name|getAddress
argument_list|()
operator|+
literal|" has newer image layout version: LV = "
operator|+
name|bnReg
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|" cTime = "
operator|+
name|bnReg
operator|.
name|getCTime
argument_list|()
operator|+
literal|" checkpointTime = "
operator|+
name|bnReg
operator|.
name|getCheckpointTime
argument_list|()
operator|+
literal|". Current version: LV = "
operator|+
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|+
literal|" cTime = "
operator|+
name|storage
operator|.
name|getCTime
argument_list|()
operator|+
literal|" checkpointTime = "
operator|+
name|storage
operator|.
name|getCheckpointTime
argument_list|()
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|new
name|NamenodeCommand
argument_list|(
name|NamenodeProtocol
operator|.
name|ACT_SHUTDOWN
argument_list|)
return|;
block|}
name|boolean
name|isImgObsolete
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|bnReg
operator|.
name|getLayoutVersion
argument_list|()
operator|==
name|storage
operator|.
name|getLayoutVersion
argument_list|()
operator|&&
name|bnReg
operator|.
name|getCTime
argument_list|()
operator|==
name|storage
operator|.
name|getCTime
argument_list|()
operator|&&
name|bnReg
operator|.
name|getCheckpointTime
argument_list|()
operator|==
name|storage
operator|.
name|getCheckpointTime
argument_list|()
condition|)
name|isImgObsolete
operator|=
literal|false
expr_stmt|;
name|boolean
name|needToReturnImg
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|storage
operator|.
name|getNumStorageDirs
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
operator|==
literal|0
condition|)
comment|// do not return image if there are no image directories
name|needToReturnImg
operator|=
literal|false
expr_stmt|;
name|CheckpointSignature
name|sig
init|=
name|rollEditLog
argument_list|()
decl_stmt|;
name|getEditLog
argument_list|()
operator|.
name|logJSpoolStart
argument_list|(
name|bnReg
argument_list|,
name|nnReg
argument_list|)
expr_stmt|;
return|return
operator|new
name|CheckpointCommand
argument_list|(
name|sig
argument_list|,
name|isImgObsolete
argument_list|,
name|needToReturnImg
argument_list|)
return|;
block|}
comment|/**    * End checkpoint.    *<p>    * Rename uploaded checkpoint to the new image;    * purge old edits file;    * rename edits.new to edits;    * redirect edit log streams to the new edits;    * update checkpoint time if the remote node is a checkpoint only node.    *     * @param sig    * @param remoteNNRole    * @throws IOException    */
DECL|method|endCheckpoint (CheckpointSignature sig, NamenodeRole remoteNNRole)
name|void
name|endCheckpoint
parameter_list|(
name|CheckpointSignature
name|sig
parameter_list|,
name|NamenodeRole
name|remoteNNRole
parameter_list|)
throws|throws
name|IOException
block|{
name|sig
operator|.
name|validateStorageInfo
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Renew checkpoint time for the active if the other is a checkpoint-node.
comment|// The checkpoint-node should have older image for the next checkpoint
comment|// to take effect.
comment|// The backup-node always has up-to-date image and will have the same
comment|// checkpoint time as the active node.
name|boolean
name|renewCheckpointTime
init|=
name|remoteNNRole
operator|.
name|equals
argument_list|(
name|NamenodeRole
operator|.
name|CHECKPOINT
argument_list|)
decl_stmt|;
name|rollFSImage
argument_list|(
name|sig
argument_list|,
name|renewCheckpointTime
argument_list|)
expr_stmt|;
block|}
DECL|method|getCheckpointState ()
name|CheckpointStates
name|getCheckpointState
parameter_list|()
block|{
return|return
name|ckptState
return|;
block|}
DECL|method|setCheckpointState (CheckpointStates cs)
name|void
name|setCheckpointState
parameter_list|(
name|CheckpointStates
name|cs
parameter_list|)
block|{
name|ckptState
operator|=
name|cs
expr_stmt|;
block|}
comment|/**    * This is called when a checkpoint upload finishes successfully.    */
DECL|method|checkpointUploadDone ()
specifier|synchronized
name|void
name|checkpointUploadDone
parameter_list|()
block|{
name|ckptState
operator|=
name|CheckpointStates
operator|.
name|UPLOAD_DONE
expr_stmt|;
block|}
DECL|method|close ()
specifier|synchronized
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|getEditLog
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
name|storage
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Retrieve checkpoint dirs from configuration.    *    * @param conf the Configuration    * @param defaultValue a default value for the attribute, if null    * @return a Collection of URIs representing the values in     * dfs.namenode.checkpoint.dir configuration property    */
DECL|method|getCheckpointDirs (Configuration conf, String defaultValue)
specifier|static
name|Collection
argument_list|<
name|URI
argument_list|>
name|getCheckpointDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|defaultValue
parameter_list|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|dirNames
init|=
name|conf
operator|.
name|getStringCollection
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_DIR_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|dirNames
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|defaultValue
operator|!=
literal|null
condition|)
block|{
name|dirNames
operator|.
name|add
argument_list|(
name|defaultValue
argument_list|)
expr_stmt|;
block|}
return|return
name|Util
operator|.
name|stringCollectionAsURIs
argument_list|(
name|dirNames
argument_list|)
return|;
block|}
DECL|method|getCheckpointEditsDirs (Configuration conf, String defaultName)
specifier|static
name|Collection
argument_list|<
name|URI
argument_list|>
name|getCheckpointEditsDirs
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|defaultName
parameter_list|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|dirNames
init|=
name|conf
operator|.
name|getStringCollection
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_EDITS_DIR_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|dirNames
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|defaultName
operator|!=
literal|null
condition|)
block|{
name|dirNames
operator|.
name|add
argument_list|(
name|defaultName
argument_list|)
expr_stmt|;
block|}
return|return
name|Util
operator|.
name|stringCollectionAsURIs
argument_list|(
name|dirNames
argument_list|)
return|;
block|}
DECL|method|getStorage ()
specifier|public
name|NNStorage
name|getStorage
parameter_list|()
block|{
return|return
name|storage
return|;
block|}
annotation|@
name|Override
comment|// NNStorageListener
DECL|method|errorOccurred (StorageDirectory sd)
specifier|public
name|void
name|errorOccurred
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
comment|// do nothing,
block|}
annotation|@
name|Override
comment|// NNStorageListener
DECL|method|formatOccurred (StorageDirectory sd)
specifier|public
name|void
name|formatOccurred
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|sd
operator|.
name|getStorageDirType
argument_list|()
operator|.
name|isOfType
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
condition|)
block|{
name|sd
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|saveCurrent
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|sd
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Storage directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|" has been successfully formatted."
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
annotation|@
name|Override
comment|// NNStorageListener
DECL|method|directoryAvailable (StorageDirectory sd)
specifier|public
name|void
name|directoryAvailable
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
comment|// do nothing
block|}
DECL|method|getLayoutVersion ()
specifier|public
name|int
name|getLayoutVersion
parameter_list|()
block|{
return|return
name|storage
operator|.
name|getLayoutVersion
argument_list|()
return|;
block|}
DECL|method|getNamespaceID ()
specifier|public
name|int
name|getNamespaceID
parameter_list|()
block|{
return|return
name|storage
operator|.
name|getNamespaceID
argument_list|()
return|;
block|}
DECL|method|getClusterID ()
specifier|public
name|String
name|getClusterID
parameter_list|()
block|{
return|return
name|storage
operator|.
name|getClusterID
argument_list|()
return|;
block|}
DECL|method|getBlockPoolID ()
specifier|public
name|String
name|getBlockPoolID
parameter_list|()
block|{
return|return
name|storage
operator|.
name|getBlockPoolID
argument_list|()
return|;
block|}
block|}
end_class

end_unit

