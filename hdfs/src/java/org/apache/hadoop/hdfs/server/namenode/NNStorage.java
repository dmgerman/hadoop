begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Util
operator|.
name|now
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchAlgorithmException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|SecureRandom
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|RandomAccessFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LayoutVersion
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LayoutVersion
operator|.
name|Feature
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|StorageInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|UpgradeManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsConstants
operator|.
name|NodeType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsConstants
operator|.
name|StartupOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|InconsistentFSStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|JournalStream
operator|.
name|JournalType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|MD5Hash
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|DNS
import|;
end_import

begin_comment
comment|/**  * NNStorage is responsible for management of the StorageDirectories used by  * the NameNode.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|NNStorage
specifier|public
class|class
name|NNStorage
extends|extends
name|Storage
implements|implements
name|Closeable
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|NNStorage
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|MESSAGE_DIGEST_PROPERTY
specifier|static
specifier|final
name|String
name|MESSAGE_DIGEST_PROPERTY
init|=
literal|"imageMD5Digest"
decl_stmt|;
comment|//
comment|// The filenames used for storing the images
comment|//
DECL|enum|NameNodeFile
enum|enum
name|NameNodeFile
block|{
DECL|enumConstant|IMAGE
name|IMAGE
argument_list|(
literal|"fsimage"
argument_list|)
block|,
DECL|enumConstant|TIME
name|TIME
argument_list|(
literal|"fstime"
argument_list|)
block|,
DECL|enumConstant|EDITS
name|EDITS
argument_list|(
literal|"edits"
argument_list|)
block|,
DECL|enumConstant|IMAGE_NEW
name|IMAGE_NEW
argument_list|(
literal|"fsimage.ckpt"
argument_list|)
block|,
DECL|enumConstant|EDITS_NEW
name|EDITS_NEW
argument_list|(
literal|"edits.new"
argument_list|)
block|;
DECL|field|fileName
specifier|private
name|String
name|fileName
init|=
literal|null
decl_stmt|;
DECL|method|NameNodeFile (String name)
specifier|private
name|NameNodeFile
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|this
operator|.
name|fileName
operator|=
name|name
expr_stmt|;
block|}
DECL|method|getName ()
name|String
name|getName
parameter_list|()
block|{
return|return
name|fileName
return|;
block|}
block|}
comment|/**    * Implementation of StorageDirType specific to namenode storage    * A Storage directory could be of type IMAGE which stores only fsimage,    * or of type EDITS which stores edits or of type IMAGE_AND_EDITS which    * stores both fsimage and edits.    */
DECL|enum|NameNodeDirType
specifier|static
enum|enum
name|NameNodeDirType
implements|implements
name|StorageDirType
block|{
DECL|enumConstant|UNDEFINED
name|UNDEFINED
block|,
DECL|enumConstant|IMAGE
name|IMAGE
block|,
DECL|enumConstant|EDITS
name|EDITS
block|,
DECL|enumConstant|IMAGE_AND_EDITS
name|IMAGE_AND_EDITS
block|;
DECL|method|getStorageDirType ()
specifier|public
name|StorageDirType
name|getStorageDirType
parameter_list|()
block|{
return|return
name|this
return|;
block|}
DECL|method|isOfType (StorageDirType type)
specifier|public
name|boolean
name|isOfType
parameter_list|(
name|StorageDirType
name|type
parameter_list|)
block|{
if|if
condition|(
operator|(
name|this
operator|==
name|IMAGE_AND_EDITS
operator|)
operator|&&
operator|(
name|type
operator|==
name|IMAGE
operator|||
name|type
operator|==
name|EDITS
operator|)
condition|)
return|return
literal|true
return|;
return|return
name|this
operator|==
name|type
return|;
block|}
block|}
comment|/**    * Interface to be implemented by classes which make use of storage    * directories. They are  notified when a StorageDirectory is causing errors,    * becoming available or being formatted.    *    * This allows the implementors of the interface take their own specific    * action on the StorageDirectory when this occurs.    */
DECL|interface|NNStorageListener
interface|interface
name|NNStorageListener
block|{
comment|/**      * An error has occurred with a StorageDirectory.      * @param sd The storage directory causing the error.      * @throws IOException      */
DECL|method|errorOccurred (StorageDirectory sd)
name|void
name|errorOccurred
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * A storage directory has been formatted.      * @param sd The storage directory being formatted.      * @throws IOException      */
DECL|method|formatOccurred (StorageDirectory sd)
name|void
name|formatOccurred
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * A storage directory is now available use.      * @param sd The storage directory which has become available.      * @throws IOException      */
DECL|method|directoryAvailable (StorageDirectory sd)
name|void
name|directoryAvailable
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
DECL|field|listeners
specifier|final
specifier|private
name|List
argument_list|<
name|NNStorageListener
argument_list|>
name|listeners
decl_stmt|;
DECL|field|upgradeManager
specifier|private
name|UpgradeManager
name|upgradeManager
init|=
literal|null
decl_stmt|;
DECL|field|imageDigest
specifier|protected
name|MD5Hash
name|imageDigest
init|=
literal|null
decl_stmt|;
DECL|field|blockpoolID
specifier|protected
name|String
name|blockpoolID
init|=
literal|""
decl_stmt|;
comment|// id of the block pool
comment|/**    * flag that controls if we try to restore failed storages    */
DECL|field|restoreFailedStorage
specifier|private
name|boolean
name|restoreFailedStorage
init|=
literal|false
decl_stmt|;
DECL|field|restorationLock
specifier|private
name|Object
name|restorationLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|disablePreUpgradableLayoutCheck
specifier|private
name|boolean
name|disablePreUpgradableLayoutCheck
init|=
literal|false
decl_stmt|;
DECL|field|checkpointTime
specifier|private
name|long
name|checkpointTime
init|=
operator|-
literal|1L
decl_stmt|;
comment|// The age of the image
comment|/**    * list of failed (and thus removed) storages    */
DECL|field|removedStorageDirs
specifier|final
specifier|protected
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|removedStorageDirs
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<
name|StorageDirectory
argument_list|>
argument_list|()
decl_stmt|;
comment|/**    * Construct the NNStorage.    * @param conf Namenode configuration.    */
DECL|method|NNStorage (Configuration conf)
specifier|public
name|NNStorage
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|super
argument_list|(
name|NodeType
operator|.
name|NAME_NODE
argument_list|)
expr_stmt|;
name|storageDirs
operator|=
operator|new
name|CopyOnWriteArrayList
argument_list|<
name|StorageDirectory
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|listeners
operator|=
operator|new
name|CopyOnWriteArrayList
argument_list|<
name|NNStorageListener
argument_list|>
argument_list|()
expr_stmt|;
block|}
comment|/**    * Construct the NNStorage.    * @param storageInfo storage information    * @param bpid block pool Id    */
DECL|method|NNStorage (StorageInfo storageInfo, String bpid)
specifier|public
name|NNStorage
parameter_list|(
name|StorageInfo
name|storageInfo
parameter_list|,
name|String
name|bpid
parameter_list|)
block|{
name|super
argument_list|(
name|NodeType
operator|.
name|NAME_NODE
argument_list|,
name|storageInfo
argument_list|)
expr_stmt|;
name|storageDirs
operator|=
operator|new
name|CopyOnWriteArrayList
argument_list|<
name|StorageDirectory
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|listeners
operator|=
operator|new
name|CopyOnWriteArrayList
argument_list|<
name|NNStorageListener
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|blockpoolID
operator|=
name|bpid
expr_stmt|;
block|}
annotation|@
name|Override
comment|// Storage
DECL|method|isPreUpgradableLayout (StorageDirectory sd)
specifier|public
name|boolean
name|isPreUpgradableLayout
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|disablePreUpgradableLayoutCheck
condition|)
block|{
return|return
literal|false
return|;
block|}
name|File
name|oldImageDir
init|=
operator|new
name|File
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
literal|"image"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|oldImageDir
operator|.
name|exists
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// check the layout version inside the image file
name|File
name|oldF
init|=
operator|new
name|File
argument_list|(
name|oldImageDir
argument_list|,
literal|"fsimage"
argument_list|)
decl_stmt|;
name|RandomAccessFile
name|oldFile
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|oldF
argument_list|,
literal|"rws"
argument_list|)
decl_stmt|;
try|try
block|{
name|oldFile
operator|.
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|int
name|oldVersion
init|=
name|oldFile
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|oldVersion
operator|<
name|LAST_PRE_UPGRADE_LAYOUT_VERSION
condition|)
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|oldFile
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
comment|// Closeable
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|listeners
operator|.
name|clear
argument_list|()
expr_stmt|;
name|unlockAll
argument_list|()
expr_stmt|;
name|storageDirs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Set flag whether an attempt should be made to restore failed storage    * directories at the next available oppurtuinity.    *    * @param val Whether restoration attempt should be made.    */
DECL|method|setRestoreFailedStorage (boolean val)
name|void
name|setRestoreFailedStorage
parameter_list|(
name|boolean
name|val
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"set restore failed storage to "
operator|+
name|val
argument_list|)
expr_stmt|;
name|restoreFailedStorage
operator|=
name|val
expr_stmt|;
block|}
comment|/**    * @return Whether failed storage directories are to be restored.    */
DECL|method|getRestoreFailedStorage ()
name|boolean
name|getRestoreFailedStorage
parameter_list|()
block|{
return|return
name|restoreFailedStorage
return|;
block|}
comment|/**    * See if any of removed storages is "writable" again, and can be returned    * into service. If saveNamespace is set, then this method is being    * called from saveNamespace.    *    * @param saveNamespace Whether method is being called from saveNamespace()    */
DECL|method|attemptRestoreRemovedStorage ()
name|void
name|attemptRestoreRemovedStorage
parameter_list|()
block|{
comment|// if directory is "alive" - copy the images there...
if|if
condition|(
operator|!
name|restoreFailedStorage
operator|||
name|removedStorageDirs
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return;
comment|//nothing to restore
comment|/* We don't want more than one thread trying to restore at a time */
synchronized|synchronized
init|(
name|this
operator|.
name|restorationLock
init|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"NNStorage.attemptRestoreRemovedStorage: check removed(failed) "
operator|+
literal|"storarge. removedStorages size = "
operator|+
name|removedStorageDirs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|this
operator|.
name|removedStorageDirs
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|File
name|root
init|=
name|sd
operator|.
name|getRoot
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"currently disabled dir "
operator|+
name|root
operator|.
name|getAbsolutePath
argument_list|()
operator|+
literal|"; type="
operator|+
name|sd
operator|.
name|getStorageDirType
argument_list|()
operator|+
literal|";canwrite="
operator|+
name|root
operator|.
name|canWrite
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|root
operator|.
name|exists
argument_list|()
operator|&&
name|root
operator|.
name|canWrite
argument_list|()
condition|)
block|{
comment|// when we try to restore we just need to remove all the data
comment|// without saving current in-memory state (which could've changed).
name|sd
operator|.
name|clearDirectory
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"restoring dir "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|NNStorageListener
name|listener
range|:
name|listeners
control|)
block|{
name|listener
operator|.
name|directoryAvailable
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|addStorageDir
argument_list|(
name|sd
argument_list|)
expr_stmt|;
comment|// restore
name|this
operator|.
name|removedStorageDirs
operator|.
name|remove
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"failed to restore "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * @return A list of storage directories which are in the errored state.    */
DECL|method|getRemovedStorageDirs ()
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|getRemovedStorageDirs
parameter_list|()
block|{
return|return
name|this
operator|.
name|removedStorageDirs
return|;
block|}
comment|/**    * Set the storage directories which will be used. NNStorage.close() should    * be called before this to ensure any previous storage directories have been    * freed.    *    * Synchronized due to initialization of storageDirs and removedStorageDirs.    *    * @param fsNameDirs Locations to store images.    * @param fsEditsDirs Locations to store edit logs.    * @throws IOException    */
DECL|method|setStorageDirectories (Collection<URI> fsNameDirs, Collection<URI> fsEditsDirs)
specifier|synchronized
name|void
name|setStorageDirectories
parameter_list|(
name|Collection
argument_list|<
name|URI
argument_list|>
name|fsNameDirs
parameter_list|,
name|Collection
argument_list|<
name|URI
argument_list|>
name|fsEditsDirs
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|storageDirs
operator|.
name|clear
argument_list|()
expr_stmt|;
name|this
operator|.
name|removedStorageDirs
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Add all name dirs with appropriate NameNodeDirType
for|for
control|(
name|URI
name|dirName
range|:
name|fsNameDirs
control|)
block|{
name|checkSchemeConsistency
argument_list|(
name|dirName
argument_list|)
expr_stmt|;
name|boolean
name|isAlsoEdits
init|=
literal|false
decl_stmt|;
for|for
control|(
name|URI
name|editsDirName
range|:
name|fsEditsDirs
control|)
block|{
if|if
condition|(
name|editsDirName
operator|.
name|compareTo
argument_list|(
name|dirName
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isAlsoEdits
operator|=
literal|true
expr_stmt|;
name|fsEditsDirs
operator|.
name|remove
argument_list|(
name|editsDirName
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|NameNodeDirType
name|dirType
init|=
operator|(
name|isAlsoEdits
operator|)
condition|?
name|NameNodeDirType
operator|.
name|IMAGE_AND_EDITS
else|:
name|NameNodeDirType
operator|.
name|IMAGE
decl_stmt|;
comment|// Add to the list of storage directories, only if the
comment|// URI is of type file://
if|if
condition|(
name|dirName
operator|.
name|getScheme
argument_list|()
operator|.
name|compareTo
argument_list|(
name|JournalType
operator|.
name|FILE
operator|.
name|name
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|addStorageDir
argument_list|(
operator|new
name|StorageDirectory
argument_list|(
operator|new
name|File
argument_list|(
name|dirName
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|,
name|dirType
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Add edits dirs if they are different from name dirs
for|for
control|(
name|URI
name|dirName
range|:
name|fsEditsDirs
control|)
block|{
name|checkSchemeConsistency
argument_list|(
name|dirName
argument_list|)
expr_stmt|;
comment|// Add to the list of storage directories, only if the
comment|// URI is of type file://
if|if
condition|(
name|dirName
operator|.
name|getScheme
argument_list|()
operator|.
name|compareTo
argument_list|(
name|JournalType
operator|.
name|FILE
operator|.
name|name
argument_list|()
operator|.
name|toLowerCase
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
name|this
operator|.
name|addStorageDir
argument_list|(
operator|new
name|StorageDirectory
argument_list|(
operator|new
name|File
argument_list|(
name|dirName
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|,
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Checks the consistency of a URI, in particular if the scheme    * is specified and is supported by a concrete implementation    * @param u URI whose consistency is being checked.    */
DECL|method|checkSchemeConsistency (URI u)
specifier|private
specifier|static
name|void
name|checkSchemeConsistency
parameter_list|(
name|URI
name|u
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|scheme
init|=
name|u
operator|.
name|getScheme
argument_list|()
decl_stmt|;
comment|// the URI should have a proper scheme
if|if
condition|(
name|scheme
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Undefined scheme for "
operator|+
name|u
argument_list|)
throw|;
else|else
block|{
try|try
block|{
comment|// the scheme should be enumerated as JournalType
name|JournalType
operator|.
name|valueOf
argument_list|(
name|scheme
operator|.
name|toUpperCase
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|iae
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unknown scheme "
operator|+
name|scheme
operator|+
literal|". It should correspond to a JournalType enumeration value"
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Retrieve current directories of type IMAGE    * @return Collection of URI representing image directories    * @throws IOException in case of URI processing error    */
DECL|method|getImageDirectories ()
name|Collection
argument_list|<
name|URI
argument_list|>
name|getImageDirectories
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getDirectories
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
return|;
block|}
comment|/**    * Retrieve current directories of type EDITS    * @return Collection of URI representing edits directories    * @throws IOException in case of URI processing error    */
DECL|method|getEditsDirectories ()
name|Collection
argument_list|<
name|URI
argument_list|>
name|getEditsDirectories
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getDirectories
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
return|;
block|}
comment|/**    * Return number of storage directories of the given type.    * @param dirType directory type    * @return number of storage directories of type dirType    */
DECL|method|getNumStorageDirs (NameNodeDirType dirType)
name|int
name|getNumStorageDirs
parameter_list|(
name|NameNodeDirType
name|dirType
parameter_list|)
block|{
if|if
condition|(
name|dirType
operator|==
literal|null
condition|)
return|return
name|getNumStorageDirs
argument_list|()
return|;
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|dirIterator
argument_list|(
name|dirType
argument_list|)
decl_stmt|;
name|int
name|numDirs
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
name|it
operator|.
name|next
argument_list|()
control|)
name|numDirs
operator|++
expr_stmt|;
return|return
name|numDirs
return|;
block|}
comment|/**    * Return the list of locations being used for a specific purpose.    * i.e. Image or edit log storage.    *    * @param dirType Purpose of locations requested.    * @throws IOException    */
DECL|method|getDirectories (NameNodeDirType dirType)
name|Collection
argument_list|<
name|URI
argument_list|>
name|getDirectories
parameter_list|(
name|NameNodeDirType
name|dirType
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|URI
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|URI
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
operator|(
name|dirType
operator|==
literal|null
operator|)
condition|?
name|dirIterator
argument_list|()
else|:
name|dirIterator
argument_list|(
name|dirType
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|list
operator|.
name|add
argument_list|(
name|Util
operator|.
name|fileAsURI
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Exception while processing "
operator|+
literal|"StorageDirectory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|list
return|;
block|}
comment|/**    * Determine the checkpoint time of the specified StorageDirectory    *    * @param sd StorageDirectory to check    * @return If file exists and can be read, last checkpoint time. If not, 0L.    * @throws IOException On errors processing file pointed to by sd    */
DECL|method|readCheckpointTime (StorageDirectory sd)
name|long
name|readCheckpointTime
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|timeFile
init|=
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|TIME
argument_list|)
decl_stmt|;
name|long
name|timeStamp
init|=
literal|0L
decl_stmt|;
if|if
condition|(
name|timeFile
operator|.
name|exists
argument_list|()
operator|&&
name|timeFile
operator|.
name|canRead
argument_list|()
condition|)
block|{
name|DataInputStream
name|in
init|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|timeFile
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|timeStamp
operator|=
name|in
operator|.
name|readLong
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|timeStamp
return|;
block|}
comment|/**    * Write last checkpoint time into a separate file.    *    * @param sd    * @throws IOException    */
DECL|method|writeCheckpointTime (StorageDirectory sd)
specifier|public
name|void
name|writeCheckpointTime
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|checkpointTime
operator|<
literal|0L
condition|)
return|return;
comment|// do not write negative time
name|File
name|timeFile
init|=
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|TIME
argument_list|)
decl_stmt|;
if|if
condition|(
name|timeFile
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|timeFile
operator|.
name|delete
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Cannot delete chekpoint time file: "
operator|+
name|timeFile
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|FileOutputStream
name|fos
init|=
operator|new
name|FileOutputStream
argument_list|(
name|timeFile
argument_list|)
decl_stmt|;
name|DataOutputStream
name|out
init|=
operator|new
name|DataOutputStream
argument_list|(
name|fos
argument_list|)
decl_stmt|;
try|try
block|{
name|out
operator|.
name|writeLong
argument_list|(
name|checkpointTime
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|fos
operator|.
name|getChannel
argument_list|()
operator|.
name|force
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Record new checkpoint time in order to    * distinguish healthy directories from the removed ones.    * If there is an error writing new checkpoint time, the corresponding    * storage directory is removed from the list.    */
DECL|method|incrementCheckpointTime ()
specifier|public
name|void
name|incrementCheckpointTime
parameter_list|()
block|{
name|setCheckpointTimeInStorage
argument_list|(
name|checkpointTime
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**    * The age of the namespace state.<p>    * Reflects the latest time the image was saved.    * Modified with every save or a checkpoint.    * Persisted in VERSION file.    *    * @return the current checkpoint time.    */
DECL|method|getCheckpointTime ()
specifier|public
name|long
name|getCheckpointTime
parameter_list|()
block|{
return|return
name|checkpointTime
return|;
block|}
comment|/**    * Set the checkpoint time.    *    * This method does not persist the checkpoint time to storage immediately.    *     * @see #setCheckpointTimeInStorage    * @param newCpT the new checkpoint time.    */
DECL|method|setCheckpointTime (long newCpT)
specifier|public
name|void
name|setCheckpointTime
parameter_list|(
name|long
name|newCpT
parameter_list|)
block|{
name|checkpointTime
operator|=
name|newCpT
expr_stmt|;
block|}
comment|/**    * Set the current checkpoint time. Writes the new checkpoint    * time to all available storage directories.    * @param newCpT The new checkpoint time.    */
DECL|method|setCheckpointTimeInStorage (long newCpT)
specifier|public
name|void
name|setCheckpointTimeInStorage
parameter_list|(
name|long
name|newCpT
parameter_list|)
block|{
name|checkpointTime
operator|=
name|newCpT
expr_stmt|;
comment|// Write new checkpoint time in all storage directories
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|writeCheckpointTime
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Close any edits stream associated with this dir and remove directory
name|LOG
operator|.
name|warn
argument_list|(
literal|"incrementCheckpointTime failed on "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getPath
argument_list|()
operator|+
literal|";type="
operator|+
name|sd
operator|.
name|getStorageDirType
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|reportErrorsOnDirectory
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Failed to report and remove NN storage directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Return the name of the image file that is uploaded by periodic    * checkpointing    *    * @return List of filenames to save checkpoints to.    */
DECL|method|getFsImageNameCheckpoint ()
specifier|public
name|File
index|[]
name|getFsImageNameCheckpoint
parameter_list|()
block|{
name|ArrayList
argument_list|<
name|File
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|File
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|getStorageFile
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE_NEW
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|list
operator|.
name|toArray
argument_list|(
operator|new
name|File
index|[
name|list
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * Return the name of the image file.    * @return The name of the first image file.    */
DECL|method|getFsImageName ()
specifier|public
name|File
name|getFsImageName
parameter_list|()
block|{
name|StorageDirectory
name|sd
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|sd
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
name|File
name|fsImage
init|=
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE
argument_list|)
decl_stmt|;
if|if
condition|(
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|canRead
argument_list|()
operator|&&
name|fsImage
operator|.
name|exists
argument_list|()
condition|)
return|return
name|fsImage
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * @return The name of the first editlog file.    */
DECL|method|getFsEditName ()
specifier|public
name|File
name|getFsEditName
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|canRead
argument_list|()
condition|)
return|return
name|getEditFile
argument_list|(
name|sd
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * @return The name of the first time file.    */
DECL|method|getFsTimeName ()
specifier|public
name|File
name|getFsTimeName
parameter_list|()
block|{
name|StorageDirectory
name|sd
init|=
literal|null
decl_stmt|;
comment|// NameNodeFile.TIME shoul be same on all directories
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
name|sd
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
return|return
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|TIME
argument_list|)
return|;
block|}
comment|/** Create new dfs name directory.  Caution: this destroys all files    * in this filesystem. */
DECL|method|format (StorageDirectory sd)
specifier|private
name|void
name|format
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|sd
operator|.
name|clearDirectory
argument_list|()
expr_stmt|;
comment|// create currrent dir
for|for
control|(
name|NNStorageListener
name|listener
range|:
name|listeners
control|)
block|{
name|listener
operator|.
name|formatOccurred
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
name|sd
operator|.
name|write
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Storage directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|" has been successfully formatted."
argument_list|)
expr_stmt|;
block|}
comment|/**    * Format all available storage directories.    */
DECL|method|format (String clusterId)
specifier|public
name|void
name|format
parameter_list|(
name|String
name|clusterId
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|layoutVersion
operator|=
name|FSConstants
operator|.
name|LAYOUT_VERSION
expr_stmt|;
name|this
operator|.
name|namespaceID
operator|=
name|newNamespaceID
argument_list|()
expr_stmt|;
name|this
operator|.
name|clusterID
operator|=
name|clusterId
expr_stmt|;
name|this
operator|.
name|blockpoolID
operator|=
name|newBlockPoolID
argument_list|()
expr_stmt|;
name|this
operator|.
name|cTime
operator|=
literal|0L
expr_stmt|;
name|this
operator|.
name|setCheckpointTime
argument_list|(
name|now
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|format
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Generate new namespaceID.    *    * namespaceID is a persistent attribute of the namespace.    * It is generated when the namenode is formatted and remains the same    * during the life cycle of the namenode.    * When a datanodes register they receive it as the registrationID,    * which is checked every time the datanode is communicating with the    * namenode. Datanodes that do not 'know' the namespaceID are rejected.    *    * @return new namespaceID    */
DECL|method|newNamespaceID ()
specifier|private
name|int
name|newNamespaceID
parameter_list|()
block|{
name|Random
name|r
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
name|r
operator|.
name|setSeed
argument_list|(
name|now
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|newID
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|newID
operator|==
literal|0
condition|)
name|newID
operator|=
name|r
operator|.
name|nextInt
argument_list|(
literal|0x7FFFFFFF
argument_list|)
expr_stmt|;
comment|// use 31 bits only
return|return
name|newID
return|;
block|}
comment|/**    * Move {@code current} to {@code lastcheckpoint.tmp} and    * recreate empty {@code current}.    * {@code current} is moved only if it is well formatted,    * that is contains VERSION file.    *    * @see org.apache.hadoop.hdfs.server.common.Storage.StorageDirectory#getLastCheckpointTmp()    * @see org.apache.hadoop.hdfs.server.common.Storage.StorageDirectory#getPreviousCheckpoint()    */
DECL|method|moveCurrent (StorageDirectory sd)
specifier|protected
name|void
name|moveCurrent
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|curDir
init|=
name|sd
operator|.
name|getCurrentDir
argument_list|()
decl_stmt|;
name|File
name|tmpCkptDir
init|=
name|sd
operator|.
name|getLastCheckpointTmp
argument_list|()
decl_stmt|;
comment|// mv current -> lastcheckpoint.tmp
comment|// only if current is formatted - has VERSION file
if|if
condition|(
name|sd
operator|.
name|getVersionFile
argument_list|()
operator|.
name|exists
argument_list|()
condition|)
block|{
assert|assert
name|curDir
operator|.
name|exists
argument_list|()
operator|:
name|curDir
operator|+
literal|" directory must exist."
assert|;
assert|assert
operator|!
name|tmpCkptDir
operator|.
name|exists
argument_list|()
operator|:
name|tmpCkptDir
operator|+
literal|" directory must not exist."
assert|;
name|rename
argument_list|(
name|curDir
argument_list|,
name|tmpCkptDir
argument_list|)
expr_stmt|;
block|}
comment|// recreate current
if|if
condition|(
operator|!
name|curDir
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|curDir
operator|.
name|mkdir
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot create directory "
operator|+
name|curDir
argument_list|)
throw|;
block|}
comment|/**    * Move {@code lastcheckpoint.tmp} to {@code previous.checkpoint}    *    * @see org.apache.hadoop.hdfs.server.common.Storage.StorageDirectory#getPreviousCheckpoint()    * @see org.apache.hadoop.hdfs.server.common.Storage.StorageDirectory#getLastCheckpointTmp()    */
DECL|method|moveLastCheckpoint (StorageDirectory sd)
specifier|protected
name|void
name|moveLastCheckpoint
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|tmpCkptDir
init|=
name|sd
operator|.
name|getLastCheckpointTmp
argument_list|()
decl_stmt|;
name|File
name|prevCkptDir
init|=
name|sd
operator|.
name|getPreviousCheckpoint
argument_list|()
decl_stmt|;
comment|// remove previous.checkpoint
if|if
condition|(
name|prevCkptDir
operator|.
name|exists
argument_list|()
condition|)
name|deleteDir
argument_list|(
name|prevCkptDir
argument_list|)
expr_stmt|;
comment|// mv lastcheckpoint.tmp -> previous.checkpoint
if|if
condition|(
name|tmpCkptDir
operator|.
name|exists
argument_list|()
condition|)
name|rename
argument_list|(
name|tmpCkptDir
argument_list|,
name|prevCkptDir
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
comment|// Storage
DECL|method|getFields (Properties props, StorageDirectory sd )
specifier|protected
name|void
name|getFields
parameter_list|(
name|Properties
name|props
parameter_list|,
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|getFields
argument_list|(
name|props
argument_list|,
name|sd
argument_list|)
expr_stmt|;
if|if
condition|(
name|layoutVersion
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"NameNode directory "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|+
literal|" is not formatted."
argument_list|)
throw|;
block|}
comment|// Set Block pool ID in version with federation support
if|if
condition|(
name|LayoutVersion
operator|.
name|supports
argument_list|(
name|Feature
operator|.
name|FEDERATION
argument_list|,
name|layoutVersion
argument_list|)
condition|)
block|{
name|String
name|sbpid
init|=
name|props
operator|.
name|getProperty
argument_list|(
literal|"blockpoolID"
argument_list|)
decl_stmt|;
name|setBlockPoolID
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
name|sbpid
argument_list|)
expr_stmt|;
block|}
name|String
name|sDUS
decl_stmt|,
name|sDUV
decl_stmt|;
name|sDUS
operator|=
name|props
operator|.
name|getProperty
argument_list|(
literal|"distributedUpgradeState"
argument_list|)
expr_stmt|;
name|sDUV
operator|=
name|props
operator|.
name|getProperty
argument_list|(
literal|"distributedUpgradeVersion"
argument_list|)
expr_stmt|;
name|setDistributedUpgradeState
argument_list|(
name|sDUS
operator|==
literal|null
condition|?
literal|false
else|:
name|Boolean
operator|.
name|parseBoolean
argument_list|(
name|sDUS
argument_list|)
argument_list|,
name|sDUV
operator|==
literal|null
condition|?
name|getLayoutVersion
argument_list|()
else|:
name|Integer
operator|.
name|parseInt
argument_list|(
name|sDUV
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|sMd5
init|=
name|props
operator|.
name|getProperty
argument_list|(
name|MESSAGE_DIGEST_PROPERTY
argument_list|)
decl_stmt|;
if|if
condition|(
name|LayoutVersion
operator|.
name|supports
argument_list|(
name|Feature
operator|.
name|FSIMAGE_CHECKSUM
argument_list|,
name|layoutVersion
argument_list|)
condition|)
block|{
if|if
condition|(
name|sMd5
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
literal|"file "
operator|+
name|STORAGE_FILE_VERSION
operator|+
literal|" does not have MD5 image digest."
argument_list|)
throw|;
block|}
name|this
operator|.
name|imageDigest
operator|=
operator|new
name|MD5Hash
argument_list|(
name|sMd5
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sMd5
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
literal|"file "
operator|+
name|STORAGE_FILE_VERSION
operator|+
literal|" has image MD5 digest when version is "
operator|+
name|layoutVersion
argument_list|)
throw|;
block|}
name|this
operator|.
name|setCheckpointTime
argument_list|(
name|readCheckpointTime
argument_list|(
name|sd
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Write last checkpoint time and version file into the storage directory.    *    * The version file should always be written last.    * Missing or corrupted version file indicates that    * the checkpoint is not valid.    *    * @param sd storage directory    * @throws IOException    */
annotation|@
name|Override
comment|// Storage
DECL|method|setFields (Properties props, StorageDirectory sd )
specifier|protected
name|void
name|setFields
parameter_list|(
name|Properties
name|props
parameter_list|,
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|setFields
argument_list|(
name|props
argument_list|,
name|sd
argument_list|)
expr_stmt|;
comment|// Set blockpoolID in version with federation support
if|if
condition|(
name|LayoutVersion
operator|.
name|supports
argument_list|(
name|Feature
operator|.
name|FEDERATION
argument_list|,
name|layoutVersion
argument_list|)
condition|)
block|{
name|props
operator|.
name|setProperty
argument_list|(
literal|"blockpoolID"
argument_list|,
name|blockpoolID
argument_list|)
expr_stmt|;
block|}
name|boolean
name|uState
init|=
name|getDistributedUpgradeState
argument_list|()
decl_stmt|;
name|int
name|uVersion
init|=
name|getDistributedUpgradeVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|uState
operator|&&
name|uVersion
operator|!=
name|getLayoutVersion
argument_list|()
condition|)
block|{
name|props
operator|.
name|setProperty
argument_list|(
literal|"distributedUpgradeState"
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|uState
argument_list|)
argument_list|)
expr_stmt|;
name|props
operator|.
name|setProperty
argument_list|(
literal|"distributedUpgradeVersion"
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|uVersion
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LayoutVersion
operator|.
name|supports
argument_list|(
name|Feature
operator|.
name|FSIMAGE_CHECKSUM
argument_list|,
name|layoutVersion
argument_list|)
condition|)
block|{
comment|// Though the current NN supports this feature, this function
comment|// is called with old layoutVersions from the upgrade tests.
if|if
condition|(
name|imageDigest
operator|==
literal|null
condition|)
block|{
comment|// May be null on the first save after an upgrade.
name|imageDigest
operator|=
name|MD5Hash
operator|.
name|digest
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|props
operator|.
name|setProperty
argument_list|(
name|MESSAGE_DIGEST_PROPERTY
argument_list|,
name|imageDigest
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|writeCheckpointTime
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return A File of 'type' in storage directory 'sd'.    */
DECL|method|getStorageFile (StorageDirectory sd, NameNodeFile type)
specifier|static
name|File
name|getStorageFile
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|,
name|NameNodeFile
name|type
parameter_list|)
block|{
return|return
operator|new
name|File
argument_list|(
name|sd
operator|.
name|getCurrentDir
argument_list|()
argument_list|,
name|type
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return A editlog File in storage directory 'sd'.    */
DECL|method|getEditFile (StorageDirectory sd)
name|File
name|getEditFile
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
block|{
return|return
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|EDITS
argument_list|)
return|;
block|}
comment|/**    * @return A temporary editlog File in storage directory 'sd'.    */
DECL|method|getEditNewFile (StorageDirectory sd)
name|File
name|getEditNewFile
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
block|{
return|return
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|EDITS_NEW
argument_list|)
return|;
block|}
comment|/**    * @return A list of all Files of 'type' in available storage directories.    */
DECL|method|getFiles (NameNodeFile type, NameNodeDirType dirType)
name|Collection
argument_list|<
name|File
argument_list|>
name|getFiles
parameter_list|(
name|NameNodeFile
name|type
parameter_list|,
name|NameNodeDirType
name|dirType
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|File
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|File
argument_list|>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
operator|(
name|dirType
operator|==
literal|null
operator|)
condition|?
name|dirIterator
argument_list|()
else|:
name|dirIterator
argument_list|(
name|dirType
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|getStorageFile
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
comment|/**    * Set the upgrade manager for use in a distributed upgrade.    * @param um The upgrade manager    */
DECL|method|setUpgradeManager (UpgradeManager um)
name|void
name|setUpgradeManager
parameter_list|(
name|UpgradeManager
name|um
parameter_list|)
block|{
name|upgradeManager
operator|=
name|um
expr_stmt|;
block|}
comment|/**    * @return The current distribued upgrade state.    */
DECL|method|getDistributedUpgradeState ()
name|boolean
name|getDistributedUpgradeState
parameter_list|()
block|{
return|return
name|upgradeManager
operator|==
literal|null
condition|?
literal|false
else|:
name|upgradeManager
operator|.
name|getUpgradeState
argument_list|()
return|;
block|}
comment|/**    * @return The current upgrade version.    */
DECL|method|getDistributedUpgradeVersion ()
name|int
name|getDistributedUpgradeVersion
parameter_list|()
block|{
return|return
name|upgradeManager
operator|==
literal|null
condition|?
literal|0
else|:
name|upgradeManager
operator|.
name|getUpgradeVersion
argument_list|()
return|;
block|}
comment|/**    * Set the upgrade state and version.    * @param uState the new state.    * @param uVersion the new version.    */
DECL|method|setDistributedUpgradeState (boolean uState, int uVersion)
specifier|private
name|void
name|setDistributedUpgradeState
parameter_list|(
name|boolean
name|uState
parameter_list|,
name|int
name|uVersion
parameter_list|)
block|{
name|upgradeManager
operator|.
name|setUpgradeState
argument_list|(
name|uState
argument_list|,
name|uVersion
argument_list|)
expr_stmt|;
block|}
comment|/**    * Verify that the distributed upgrade state is valid.    * @param startOpt the option the namenode was started with.    */
DECL|method|verifyDistributedUpgradeProgress (StartupOption startOpt )
name|void
name|verifyDistributedUpgradeProgress
parameter_list|(
name|StartupOption
name|startOpt
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|ROLLBACK
operator|||
name|startOpt
operator|==
name|StartupOption
operator|.
name|IMPORT
condition|)
return|return;
assert|assert
name|upgradeManager
operator|!=
literal|null
operator|:
literal|"FSNameSystem.upgradeManager is null."
assert|;
if|if
condition|(
name|startOpt
operator|!=
name|StartupOption
operator|.
name|UPGRADE
condition|)
block|{
if|if
condition|(
name|upgradeManager
operator|.
name|getUpgradeState
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"\n   Previous distributed upgrade was not completed. "
operator|+
literal|"\n   Please restart NameNode with -upgrade option."
argument_list|)
throw|;
if|if
condition|(
name|upgradeManager
operator|.
name|getDistributedUpgrades
argument_list|()
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"\n   Distributed upgrade for NameNode version "
operator|+
name|upgradeManager
operator|.
name|getUpgradeVersion
argument_list|()
operator|+
literal|" to current LV "
operator|+
name|FSConstants
operator|.
name|LAYOUT_VERSION
operator|+
literal|" is required.\n   Please restart NameNode"
operator|+
literal|" with -upgrade option."
argument_list|)
throw|;
block|}
block|}
comment|/**    * Initialize a distributed upgrade.    */
DECL|method|initializeDistributedUpgrade ()
name|void
name|initializeDistributedUpgrade
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|upgradeManager
operator|.
name|initializeUpgrade
argument_list|()
condition|)
return|return;
comment|// write new upgrade state into disk
name|writeAll
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"\n   Distributed upgrade for NameNode version "
operator|+
name|upgradeManager
operator|.
name|getUpgradeVersion
argument_list|()
operator|+
literal|" to current LV "
operator|+
name|FSConstants
operator|.
name|LAYOUT_VERSION
operator|+
literal|" is initialized."
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the digest for the latest image stored by NNStorage.    * @param digest The digest for the image.    */
DECL|method|setImageDigest (MD5Hash digest)
name|void
name|setImageDigest
parameter_list|(
name|MD5Hash
name|digest
parameter_list|)
block|{
name|this
operator|.
name|imageDigest
operator|=
name|digest
expr_stmt|;
block|}
comment|/**    * Get the digest for the latest image storage by NNStorage.    * @return The digest for the latest image.    */
DECL|method|getImageDigest ()
name|MD5Hash
name|getImageDigest
parameter_list|()
block|{
return|return
name|imageDigest
return|;
block|}
comment|/**    * Register a listener. The listener will be notified of changes to the list    * of available storage directories.    *    * @see NNStorageListener    * @param sel A storage listener.    */
DECL|method|registerListener (NNStorageListener sel)
name|void
name|registerListener
parameter_list|(
name|NNStorageListener
name|sel
parameter_list|)
block|{
name|listeners
operator|.
name|add
argument_list|(
name|sel
argument_list|)
expr_stmt|;
block|}
comment|/**    * Disable the check for pre-upgradable layouts. Needed for BackupImage.    * @param val Whether to disable the preupgradeable layout check.    */
DECL|method|setDisablePreUpgradableLayoutCheck (boolean val)
name|void
name|setDisablePreUpgradableLayoutCheck
parameter_list|(
name|boolean
name|val
parameter_list|)
block|{
name|disablePreUpgradableLayoutCheck
operator|=
name|val
expr_stmt|;
block|}
comment|/**    * Marks a list of directories as having experienced an error.    *    * @param sds A list of storage directories to mark as errored.    * @throws IOException    */
DECL|method|reportErrorsOnDirectories (List<StorageDirectory> sds)
name|void
name|reportErrorsOnDirectories
parameter_list|(
name|List
argument_list|<
name|StorageDirectory
argument_list|>
name|sds
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|sds
control|)
block|{
name|reportErrorsOnDirectory
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Reports that a directory has experienced an error.    * Notifies listeners that the directory is no longer    * available.    *    * @param sd A storage directory to mark as errored.    * @throws IOException    */
DECL|method|reportErrorsOnDirectory (StorageDirectory sd)
name|void
name|reportErrorsOnDirectory
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error reported on storage directory "
operator|+
name|sd
argument_list|)
expr_stmt|;
name|String
name|lsd
init|=
name|listStorageDirectories
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"current list of storage dirs:"
operator|+
name|lsd
argument_list|)
expr_stmt|;
for|for
control|(
name|NNStorageListener
name|listener
range|:
name|listeners
control|)
block|{
name|listener
operator|.
name|errorOccurred
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"About to remove corresponding storage: "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|sd
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to unlock bad storage directory: "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|this
operator|.
name|storageDirs
operator|.
name|remove
argument_list|(
name|sd
argument_list|)
condition|)
block|{
name|this
operator|.
name|removedStorageDirs
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
name|incrementCheckpointTime
argument_list|()
expr_stmt|;
name|lsd
operator|=
name|listStorageDirectories
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"at the end current list of storage dirs:"
operator|+
name|lsd
argument_list|)
expr_stmt|;
block|}
comment|/**     * Processes the startup options for the clusterid and blockpoolid     * for the upgrade.     * @param startOpt Startup options     * @param layoutVersion Layout version for the upgrade     * @throws IOException    */
DECL|method|processStartupOptionsForUpgrade (StartupOption startOpt, int layoutVersion)
name|void
name|processStartupOptionsForUpgrade
parameter_list|(
name|StartupOption
name|startOpt
parameter_list|,
name|int
name|layoutVersion
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|startOpt
operator|==
name|StartupOption
operator|.
name|UPGRADE
condition|)
block|{
comment|// If upgrade from a release that does not support federation,
comment|// if clusterId is provided in the startupOptions use it.
comment|// Else generate a new cluster ID
if|if
condition|(
operator|!
name|LayoutVersion
operator|.
name|supports
argument_list|(
name|Feature
operator|.
name|FEDERATION
argument_list|,
name|layoutVersion
argument_list|)
condition|)
block|{
if|if
condition|(
name|startOpt
operator|.
name|getClusterId
argument_list|()
operator|==
literal|null
condition|)
block|{
name|startOpt
operator|.
name|setClusterId
argument_list|(
name|newClusterID
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|setClusterID
argument_list|(
name|startOpt
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
name|setBlockPoolID
argument_list|(
name|newBlockPoolID
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Upgrade from one version of federation to another supported
comment|// version of federation doesn't require clusterID.
comment|// Warn the user if the current clusterid didn't match with the input
comment|// clusterid.
if|if
condition|(
name|startOpt
operator|.
name|getClusterId
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|startOpt
operator|.
name|getClusterId
argument_list|()
operator|.
name|equals
argument_list|(
name|getClusterID
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Clusterid mismatch - current clusterid: "
operator|+
name|getClusterID
argument_list|()
operator|+
literal|", Ignoring given clusterid: "
operator|+
name|startOpt
operator|.
name|getClusterId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Using clusterid: "
operator|+
name|getClusterID
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Generate new clusterID.    *     * clusterID is a persistent attribute of the cluster.    * It is generated when the cluster is created and remains the same    * during the life cycle of the cluster.  When a new name node is formated, if     * this is a new cluster, a new clusterID is geneated and stored.  Subsequent     * name node must be given the same ClusterID during its format to be in the     * same cluster.    * When a datanode register it receive the clusterID and stick with it.    * If at any point, name node or data node tries to join another cluster, it     * will be rejected.    *     * @return new clusterID    */
DECL|method|newClusterID ()
specifier|public
specifier|static
name|String
name|newClusterID
parameter_list|()
block|{
return|return
literal|"CID-"
operator|+
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|setClusterID (String cid)
name|void
name|setClusterID
parameter_list|(
name|String
name|cid
parameter_list|)
block|{
name|clusterID
operator|=
name|cid
expr_stmt|;
block|}
comment|/**    * try to find current cluster id in the VERSION files    * returns first cluster id found in any VERSION file    * null in case none found    * @return clusterId or null in case no cluster id found    */
DECL|method|determineClusterId ()
specifier|public
name|String
name|determineClusterId
parameter_list|()
block|{
name|String
name|cid
init|=
literal|null
decl_stmt|;
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|sdit
init|=
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
decl_stmt|;
while|while
condition|(
name|sdit
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|StorageDirectory
name|sd
init|=
name|sdit
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|Properties
name|props
init|=
name|sd
operator|.
name|readFrom
argument_list|(
name|sd
operator|.
name|getVersionFile
argument_list|()
argument_list|)
decl_stmt|;
name|cid
operator|=
name|props
operator|.
name|getProperty
argument_list|(
literal|"clusterID"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"current cluster id for sd="
operator|+
name|sd
operator|.
name|getCurrentDir
argument_list|()
operator|+
literal|";lv="
operator|+
name|layoutVersion
operator|+
literal|";cid="
operator|+
name|cid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cid
operator|!=
literal|null
operator|&&
operator|!
name|cid
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
return|return
name|cid
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"this sd not available: "
operator|+
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//ignore
block|}
name|LOG
operator|.
name|warn
argument_list|(
literal|"couldn't find any VERSION file containing valid ClusterId"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/**    * Generate new blockpoolID.    *     * @return new blockpoolID    */
DECL|method|newBlockPoolID ()
name|String
name|newBlockPoolID
parameter_list|()
throws|throws
name|UnknownHostException
block|{
name|String
name|ip
init|=
literal|"unknownIP"
decl_stmt|;
try|try
block|{
name|ip
operator|=
name|DNS
operator|.
name|getDefaultIP
argument_list|(
literal|"default"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownHostException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not find ip address of \"default\" inteface."
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|int
name|rand
init|=
literal|0
decl_stmt|;
try|try
block|{
name|rand
operator|=
name|SecureRandom
operator|.
name|getInstance
argument_list|(
literal|"SHA1PRNG"
argument_list|)
operator|.
name|nextInt
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchAlgorithmException
name|e
parameter_list|)
block|{
specifier|final
name|Random
name|R
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Could not use SecureRandom"
argument_list|)
expr_stmt|;
name|rand
operator|=
name|R
operator|.
name|nextInt
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
block|}
name|String
name|bpid
init|=
literal|"BP-"
operator|+
name|rand
operator|+
literal|"-"
operator|+
name|ip
operator|+
literal|"-"
operator|+
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
return|return
name|bpid
return|;
block|}
comment|/** Validate and set block pool ID */
DECL|method|setBlockPoolID (String bpid)
name|void
name|setBlockPoolID
parameter_list|(
name|String
name|bpid
parameter_list|)
block|{
name|blockpoolID
operator|=
name|bpid
expr_stmt|;
block|}
comment|/** Validate and set block pool ID */
DECL|method|setBlockPoolID (File storage, String bpid)
specifier|private
name|void
name|setBlockPoolID
parameter_list|(
name|File
name|storage
parameter_list|,
name|String
name|bpid
parameter_list|)
throws|throws
name|InconsistentFSStateException
block|{
if|if
condition|(
name|bpid
operator|==
literal|null
operator|||
name|bpid
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|storage
argument_list|,
literal|"file "
operator|+
name|Storage
operator|.
name|STORAGE_FILE_VERSION
operator|+
literal|" has no block pool Id."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|blockpoolID
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
operator|&&
operator|!
name|blockpoolID
operator|.
name|equals
argument_list|(
name|bpid
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|storage
argument_list|,
literal|"Unexepcted blockpoolID "
operator|+
name|bpid
operator|+
literal|" . Expected "
operator|+
name|blockpoolID
argument_list|)
throw|;
block|}
name|setBlockPoolID
argument_list|(
name|bpid
argument_list|)
expr_stmt|;
block|}
DECL|method|getBlockPoolID ()
specifier|public
name|String
name|getBlockPoolID
parameter_list|()
block|{
return|return
name|blockpoolID
return|;
block|}
block|}
end_class

end_unit

