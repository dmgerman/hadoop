begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.blockmanagement
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Util
operator|.
name|now
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NavigableMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|HadoopIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSConstants
operator|.
name|DatanodeReportType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|UnregisteredNodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeDescriptor
operator|.
name|BlockTargetPair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Util
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSNamesystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BalancerBandwidthCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockRecoveryCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|BlockRecoveryCommand
operator|.
name|RecoveringBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeCommand
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DisallowedDatanodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|CachedDNSToSwitchMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|DNSToSwitchMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetworkTopology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|ScriptBasedMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|CyclicIteration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|HostsFileReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_comment
comment|/**  * Manage datanodes, include decommission and other activities.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|DatanodeManager
specifier|public
class|class
name|DatanodeManager
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|DatanodeManager
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|namesystem
specifier|private
specifier|final
name|FSNamesystem
name|namesystem
decl_stmt|;
DECL|field|blockManager
specifier|private
specifier|final
name|BlockManager
name|blockManager
decl_stmt|;
DECL|field|heartbeatManager
specifier|private
specifier|final
name|HeartbeatManager
name|heartbeatManager
decl_stmt|;
comment|/**    * Stores the datanode -> block map.      *<p>    * Done by storing a set of {@link DatanodeDescriptor} objects, sorted by     * storage id. In order to keep the storage map consistent it tracks     * all storages ever registered with the namenode.    * A descriptor corresponding to a specific storage id can be    *<ul>     *<li>added to the map if it is a new storage id;</li>    *<li>updated with a new datanode started as a replacement for the old one     * with the same storage id; and</li>    *<li>removed if and only if an existing datanode is restarted to serve a    * different storage id.</li>    *</ul><br>    * The list of the {@link DatanodeDescriptor}s in the map is checkpointed    * in the namespace image file. Only the {@link DatanodeInfo} part is     * persistent, the list of blocks is restored from the datanode block    * reports.     *<p>    * Mapping: StorageID -> DatanodeDescriptor    */
DECL|field|datanodeMap
specifier|private
specifier|final
name|NavigableMap
argument_list|<
name|String
argument_list|,
name|DatanodeDescriptor
argument_list|>
name|datanodeMap
init|=
operator|new
name|TreeMap
argument_list|<
name|String
argument_list|,
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Cluster network topology */
DECL|field|networktopology
specifier|private
specifier|final
name|NetworkTopology
name|networktopology
init|=
operator|new
name|NetworkTopology
argument_list|()
decl_stmt|;
comment|/** Host names to datanode descriptors mapping. */
DECL|field|host2DatanodeMap
specifier|private
specifier|final
name|Host2NodesMap
name|host2DatanodeMap
init|=
operator|new
name|Host2NodesMap
argument_list|()
decl_stmt|;
DECL|field|dnsToSwitchMapping
specifier|private
specifier|final
name|DNSToSwitchMapping
name|dnsToSwitchMapping
decl_stmt|;
comment|/** Read include/exclude files*/
DECL|field|hostsReader
specifier|private
specifier|final
name|HostsFileReader
name|hostsReader
decl_stmt|;
comment|/** The period to wait for datanode heartbeat.*/
DECL|field|heartbeatExpireInterval
specifier|private
specifier|final
name|long
name|heartbeatExpireInterval
decl_stmt|;
comment|/** Ask Datanode only up to this many blocks to delete. */
DECL|field|blockInvalidateLimit
specifier|final
name|int
name|blockInvalidateLimit
decl_stmt|;
DECL|method|DatanodeManager (final BlockManager blockManager, final FSNamesystem namesystem, final Configuration conf )
name|DatanodeManager
parameter_list|(
specifier|final
name|BlockManager
name|blockManager
parameter_list|,
specifier|final
name|FSNamesystem
name|namesystem
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|namesystem
operator|=
name|namesystem
expr_stmt|;
name|this
operator|.
name|blockManager
operator|=
name|blockManager
expr_stmt|;
name|this
operator|.
name|heartbeatManager
operator|=
operator|new
name|HeartbeatManager
argument_list|(
name|namesystem
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|hostsReader
operator|=
operator|new
name|HostsFileReader
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HOSTS
argument_list|,
literal|""
argument_list|)
argument_list|,
name|conf
operator|.
name|get
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HOSTS_EXCLUDE
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|dnsToSwitchMapping
operator|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|conf
operator|.
name|getClass
argument_list|(
name|DFSConfigKeys
operator|.
name|NET_TOPOLOGY_NODE_SWITCH_MAPPING_IMPL_KEY
argument_list|,
name|ScriptBasedMapping
operator|.
name|class
argument_list|,
name|DNSToSwitchMapping
operator|.
name|class
argument_list|)
argument_list|,
name|conf
argument_list|)
expr_stmt|;
comment|// If the dns to switch mapping supports cache, resolve network
comment|// locations of those hosts in the include list and store the mapping
comment|// in the cache; so future calls to resolve will be fast.
if|if
condition|(
name|dnsToSwitchMapping
operator|instanceof
name|CachedDNSToSwitchMapping
condition|)
block|{
name|dnsToSwitchMapping
operator|.
name|resolve
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|hostsReader
operator|.
name|getHosts
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|heartbeatIntervalSeconds
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HEARTBEAT_INTERVAL_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_HEARTBEAT_INTERVAL_DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|int
name|heartbeatRecheckInterval
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_DEFAULT
argument_list|)
decl_stmt|;
comment|// 5 minutes
name|this
operator|.
name|heartbeatExpireInterval
operator|=
literal|2
operator|*
name|heartbeatRecheckInterval
operator|+
literal|10
operator|*
literal|1000
operator|*
name|heartbeatIntervalSeconds
expr_stmt|;
name|this
operator|.
name|blockInvalidateLimit
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|20
operator|*
call|(
name|int
call|)
argument_list|(
name|heartbeatIntervalSeconds
argument_list|)
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_INVALIDATE_LIMIT_DEFAULT
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_BLOCK_INVALIDATE_LIMIT_KEY
operator|+
literal|"="
operator|+
name|this
operator|.
name|blockInvalidateLimit
argument_list|)
expr_stmt|;
block|}
DECL|field|decommissionthread
specifier|private
name|Daemon
name|decommissionthread
init|=
literal|null
decl_stmt|;
DECL|method|activate (final Configuration conf)
name|void
name|activate
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|decommissionthread
operator|=
operator|new
name|Daemon
argument_list|(
operator|new
name|DecommissionManager
argument_list|(
name|namesystem
argument_list|)
operator|.
operator|new
name|Monitor
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DECOMMISSION_INTERVAL_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DECOMMISSION_INTERVAL_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DECOMMISSION_NODES_PER_INTERVAL_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DECOMMISSION_NODES_PER_INTERVAL_DEFAULT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|decommissionthread
operator|.
name|start
argument_list|()
expr_stmt|;
name|heartbeatManager
operator|.
name|activate
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
DECL|method|close ()
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|decommissionthread
operator|!=
literal|null
condition|)
name|decommissionthread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|heartbeatManager
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** @return the network topology. */
DECL|method|getNetworkTopology ()
specifier|public
name|NetworkTopology
name|getNetworkTopology
parameter_list|()
block|{
return|return
name|networktopology
return|;
block|}
comment|/** @return the heartbeat manager. */
DECL|method|getHeartbeatManager ()
name|HeartbeatManager
name|getHeartbeatManager
parameter_list|()
block|{
return|return
name|heartbeatManager
return|;
block|}
comment|/** @return the datanode statistics. */
DECL|method|getDatanodeStatistics ()
specifier|public
name|DatanodeStatistics
name|getDatanodeStatistics
parameter_list|()
block|{
return|return
name|heartbeatManager
return|;
block|}
comment|/** Sort the located blocks by the distance to the target host. */
DECL|method|sortLocatedBlocks (final String targethost, final List<LocatedBlock> locatedblocks)
specifier|public
name|void
name|sortLocatedBlocks
parameter_list|(
specifier|final
name|String
name|targethost
parameter_list|,
specifier|final
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|locatedblocks
parameter_list|)
block|{
comment|//sort the blocks
specifier|final
name|DatanodeDescriptor
name|client
init|=
name|getDatanodeByHost
argument_list|(
name|targethost
argument_list|)
decl_stmt|;
for|for
control|(
name|LocatedBlock
name|b
range|:
name|locatedblocks
control|)
block|{
name|networktopology
operator|.
name|pseudoSortByDistance
argument_list|(
name|client
argument_list|,
name|b
operator|.
name|getLocations
argument_list|()
argument_list|)
expr_stmt|;
comment|// Move decommissioned datanodes to the bottom
name|Arrays
operator|.
name|sort
argument_list|(
name|b
operator|.
name|getLocations
argument_list|()
argument_list|,
name|DFSUtil
operator|.
name|DECOM_COMPARATOR
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getDatanodeCyclicIteration ( final String firstkey)
name|CyclicIteration
argument_list|<
name|String
argument_list|,
name|DatanodeDescriptor
argument_list|>
name|getDatanodeCyclicIteration
parameter_list|(
specifier|final
name|String
name|firstkey
parameter_list|)
block|{
return|return
operator|new
name|CyclicIteration
argument_list|<
name|String
argument_list|,
name|DatanodeDescriptor
argument_list|>
argument_list|(
name|datanodeMap
argument_list|,
name|firstkey
argument_list|)
return|;
block|}
comment|/** @return the datanode descriptor for the host. */
DECL|method|getDatanodeByHost (final String host)
specifier|public
name|DatanodeDescriptor
name|getDatanodeByHost
parameter_list|(
specifier|final
name|String
name|host
parameter_list|)
block|{
return|return
name|host2DatanodeMap
operator|.
name|getDatanodeByHost
argument_list|(
name|host
argument_list|)
return|;
block|}
comment|/** Get a datanode descriptor given corresponding storageID */
DECL|method|getDatanode (final String storageID)
name|DatanodeDescriptor
name|getDatanode
parameter_list|(
specifier|final
name|String
name|storageID
parameter_list|)
block|{
return|return
name|datanodeMap
operator|.
name|get
argument_list|(
name|storageID
argument_list|)
return|;
block|}
comment|/**    * Get data node by storage ID.    *     * @param nodeID    * @return DatanodeDescriptor or null if the node is not found.    * @throws UnregisteredNodeException    */
DECL|method|getDatanode (DatanodeID nodeID )
specifier|public
name|DatanodeDescriptor
name|getDatanode
parameter_list|(
name|DatanodeID
name|nodeID
parameter_list|)
throws|throws
name|UnregisteredNodeException
block|{
specifier|final
name|DatanodeDescriptor
name|node
init|=
name|getDatanode
argument_list|(
name|nodeID
operator|.
name|getStorageID
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
operator|!
name|node
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|nodeID
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
specifier|final
name|UnregisteredNodeException
name|e
init|=
operator|new
name|UnregisteredNodeException
argument_list|(
name|nodeID
argument_list|,
name|node
argument_list|)
decl_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|fatal
argument_list|(
literal|"BLOCK* NameSystem.getDatanode: "
operator|+
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
name|node
return|;
block|}
comment|/** Prints information about all datanodes. */
DECL|method|datanodeDump (final PrintWriter out)
name|void
name|datanodeDump
parameter_list|(
specifier|final
name|PrintWriter
name|out
parameter_list|)
block|{
synchronized|synchronized
init|(
name|datanodeMap
init|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"Metasave: Number of datanodes: "
operator|+
name|datanodeMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|it
init|=
name|datanodeMap
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DatanodeDescriptor
name|node
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|out
operator|.
name|println
argument_list|(
name|node
operator|.
name|dumpDatanode
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Remove a datanode descriptor.    * @param nodeInfo datanode descriptor.    */
DECL|method|removeDatanode (DatanodeDescriptor nodeInfo)
specifier|private
name|void
name|removeDatanode
parameter_list|(
name|DatanodeDescriptor
name|nodeInfo
parameter_list|)
block|{
assert|assert
name|namesystem
operator|.
name|hasWriteLock
argument_list|()
assert|;
name|heartbeatManager
operator|.
name|removeDatanode
argument_list|(
name|nodeInfo
argument_list|)
expr_stmt|;
name|blockManager
operator|.
name|removeBlocksAssociatedTo
argument_list|(
name|nodeInfo
argument_list|)
expr_stmt|;
name|networktopology
operator|.
name|remove
argument_list|(
name|nodeInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"remove datanode "
operator|+
name|nodeInfo
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|namesystem
operator|.
name|checkSafeMode
argument_list|()
expr_stmt|;
block|}
comment|/**    * Remove a datanode    * @throws UnregisteredNodeException     */
DECL|method|removeDatanode (final DatanodeID node )
specifier|public
name|void
name|removeDatanode
parameter_list|(
specifier|final
name|DatanodeID
name|node
parameter_list|)
throws|throws
name|UnregisteredNodeException
block|{
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|DatanodeDescriptor
name|descriptor
init|=
name|getDatanode
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|descriptor
operator|!=
literal|null
condition|)
block|{
name|removeDatanode
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|warn
argument_list|(
literal|"BLOCK* removeDatanode: "
operator|+
name|node
operator|.
name|getName
argument_list|()
operator|+
literal|" does not exist"
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Remove a dead datanode. */
DECL|method|removeDeadDatanode (final DatanodeID nodeID)
name|void
name|removeDeadDatanode
parameter_list|(
specifier|final
name|DatanodeID
name|nodeID
parameter_list|)
block|{
synchronized|synchronized
init|(
name|datanodeMap
init|)
block|{
name|DatanodeDescriptor
name|d
decl_stmt|;
try|try
block|{
name|d
operator|=
name|getDatanode
argument_list|(
name|nodeID
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|d
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|!=
literal|null
operator|&&
name|isDatanodeDead
argument_list|(
name|d
argument_list|)
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* removeDeadDatanode: lost heartbeat from "
operator|+
name|d
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|removeDatanode
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Is the datanode dead? */
DECL|method|isDatanodeDead (DatanodeDescriptor node)
name|boolean
name|isDatanodeDead
parameter_list|(
name|DatanodeDescriptor
name|node
parameter_list|)
block|{
return|return
operator|(
name|node
operator|.
name|getLastUpdate
argument_list|()
operator|<
operator|(
name|Util
operator|.
name|now
argument_list|()
operator|-
name|heartbeatExpireInterval
operator|)
operator|)
return|;
block|}
comment|/** Add a datanode. */
DECL|method|addDatanode (final DatanodeDescriptor node)
specifier|private
name|void
name|addDatanode
parameter_list|(
specifier|final
name|DatanodeDescriptor
name|node
parameter_list|)
block|{
comment|// To keep host2DatanodeMap consistent with datanodeMap,
comment|// remove  from host2DatanodeMap the datanodeDescriptor removed
comment|// from datanodeMap before adding node to host2DatanodeMap.
synchronized|synchronized
init|(
name|datanodeMap
init|)
block|{
name|host2DatanodeMap
operator|.
name|remove
argument_list|(
name|datanodeMap
operator|.
name|put
argument_list|(
name|node
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|host2DatanodeMap
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|networktopology
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|".addDatanode: "
operator|+
literal|"node "
operator|+
name|node
operator|.
name|getName
argument_list|()
operator|+
literal|" is added to datanodeMap."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Physically remove node from datanodeMap. */
DECL|method|wipeDatanode (final DatanodeID node)
specifier|private
name|void
name|wipeDatanode
parameter_list|(
specifier|final
name|DatanodeID
name|node
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|key
init|=
name|node
operator|.
name|getStorageID
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|datanodeMap
init|)
block|{
name|host2DatanodeMap
operator|.
name|remove
argument_list|(
name|datanodeMap
operator|.
name|remove
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|".wipeDatanode("
operator|+
name|node
operator|.
name|getName
argument_list|()
operator|+
literal|"): storage "
operator|+
name|key
operator|+
literal|" is removed from datanodeMap."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Resolve a node's network location */
DECL|method|resolveNetworkLocation (DatanodeDescriptor node)
specifier|private
name|void
name|resolveNetworkLocation
parameter_list|(
name|DatanodeDescriptor
name|node
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|dnsToSwitchMapping
operator|instanceof
name|CachedDNSToSwitchMapping
condition|)
block|{
comment|// get the node's IP address
name|names
operator|.
name|add
argument_list|(
name|node
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// get the node's host name
name|String
name|hostName
init|=
name|node
operator|.
name|getHostName
argument_list|()
decl_stmt|;
name|int
name|colon
init|=
name|hostName
operator|.
name|indexOf
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
name|hostName
operator|=
operator|(
name|colon
operator|==
operator|-
literal|1
operator|)
condition|?
name|hostName
else|:
name|hostName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|colon
argument_list|)
expr_stmt|;
name|names
operator|.
name|add
argument_list|(
name|hostName
argument_list|)
expr_stmt|;
block|}
comment|// resolve its network location
name|List
argument_list|<
name|String
argument_list|>
name|rName
init|=
name|dnsToSwitchMapping
operator|.
name|resolve
argument_list|(
name|names
argument_list|)
decl_stmt|;
name|String
name|networkLocation
decl_stmt|;
if|if
condition|(
name|rName
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"The resolve call returned null! Using "
operator|+
name|NetworkTopology
operator|.
name|DEFAULT_RACK
operator|+
literal|" for host "
operator|+
name|names
argument_list|)
expr_stmt|;
name|networkLocation
operator|=
name|NetworkTopology
operator|.
name|DEFAULT_RACK
expr_stmt|;
block|}
else|else
block|{
name|networkLocation
operator|=
name|rName
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|setNetworkLocation
argument_list|(
name|networkLocation
argument_list|)
expr_stmt|;
block|}
DECL|method|inHostsList (DatanodeID node, String ipAddr)
specifier|private
name|boolean
name|inHostsList
parameter_list|(
name|DatanodeID
name|node
parameter_list|,
name|String
name|ipAddr
parameter_list|)
block|{
return|return
name|checkInList
argument_list|(
name|node
argument_list|,
name|ipAddr
argument_list|,
name|hostsReader
operator|.
name|getHosts
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|inExcludedHostsList (DatanodeID node, String ipAddr)
specifier|private
name|boolean
name|inExcludedHostsList
parameter_list|(
name|DatanodeID
name|node
parameter_list|,
name|String
name|ipAddr
parameter_list|)
block|{
return|return
name|checkInList
argument_list|(
name|node
argument_list|,
name|ipAddr
argument_list|,
name|hostsReader
operator|.
name|getExcludedHosts
argument_list|()
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Remove an already decommissioned data node who is neither in include nor    * exclude hosts lists from the the list of live or dead nodes.  This is used    * to not display an already decommssioned data node to the operators.    * The operation procedure of making a already decommissioned data node not    * to be displayed is as following:    *<ol>    *<li>     *   Host must have been in the include hosts list and the include hosts list    *   must not be empty.    *</li>    *<li>    *   Host is decommissioned by remaining in the include hosts list and added    *   into the exclude hosts list. Name node is updated with the new     *   information by issuing dfsadmin -refreshNodes command.    *</li>    *<li>    *   Host is removed from both include hosts and exclude hosts lists.  Name     *   node is updated with the new informationby issuing dfsamin -refreshNodes     *   command.    *<li>    *</ol>    *     * @param nodeList    *          , array list of live or dead nodes.    */
DECL|method|removeDecomNodeFromList (final List<DatanodeDescriptor> nodeList)
specifier|private
name|void
name|removeDecomNodeFromList
parameter_list|(
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodeList
parameter_list|)
block|{
comment|// If the include list is empty, any nodes are welcomed and it does not
comment|// make sense to exclude any nodes from the cluster. Therefore, no remove.
if|if
condition|(
name|hostsReader
operator|.
name|getHosts
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
for|for
control|(
name|Iterator
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|it
init|=
name|nodeList
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DatanodeDescriptor
name|node
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|inHostsList
argument_list|(
name|node
argument_list|,
literal|null
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|inExcludedHostsList
argument_list|(
name|node
argument_list|,
literal|null
argument_list|)
operator|)
operator|&&
name|node
operator|.
name|isDecommissioned
argument_list|()
condition|)
block|{
comment|// Include list is not empty, an existing datanode does not appear
comment|// in both include or exclude lists and it has been decommissioned.
comment|// Remove it from the node list.
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Check if the given node (of DatanodeID or ipAddress) is in the (include or    * exclude) list.  If ipAddress in null, check only based upon the given     * DatanodeID.  If ipAddress is not null, the ipAddress should refers to the    * same host that given DatanodeID refers to.    *     * @param node, the host DatanodeID    * @param ipAddress, if not null, should refers to the same host    *                   that DatanodeID refers to    * @param hostsList, the list of hosts in the include/exclude file    * @param isExcludeList, boolean, true if this is the exclude list    * @return boolean, if in the list    */
DECL|method|checkInList (final DatanodeID node, final String ipAddress, final Set<String> hostsList, final boolean isExcludeList)
specifier|private
specifier|static
name|boolean
name|checkInList
parameter_list|(
specifier|final
name|DatanodeID
name|node
parameter_list|,
specifier|final
name|String
name|ipAddress
parameter_list|,
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|hostsList
parameter_list|,
specifier|final
name|boolean
name|isExcludeList
parameter_list|)
block|{
specifier|final
name|InetAddress
name|iaddr
decl_stmt|;
if|if
condition|(
name|ipAddress
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|iaddr
operator|=
name|InetAddress
operator|.
name|getByName
argument_list|(
name|ipAddress
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownHostException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unknown ip address: "
operator|+
name|ipAddress
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|isExcludeList
return|;
block|}
block|}
else|else
block|{
try|try
block|{
name|iaddr
operator|=
name|InetAddress
operator|.
name|getByName
argument_list|(
name|node
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownHostException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unknown host: "
operator|+
name|node
operator|.
name|getHost
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|isExcludeList
return|;
block|}
block|}
comment|// if include list is empty, host is in include list
if|if
condition|(
operator|(
operator|!
name|isExcludeList
operator|)
operator|&&
operator|(
name|hostsList
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
comment|// compare ipaddress(:port)
operator|(
name|hostsList
operator|.
name|contains
argument_list|(
name|iaddr
operator|.
name|getHostAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
operator|)
operator|||
operator|(
name|hostsList
operator|.
name|contains
argument_list|(
name|iaddr
operator|.
name|getHostAddress
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|":"
operator|+
name|node
operator|.
name|getPort
argument_list|()
argument_list|)
operator|)
comment|// compare hostname(:port)
operator|||
operator|(
name|hostsList
operator|.
name|contains
argument_list|(
name|iaddr
operator|.
name|getHostName
argument_list|()
argument_list|)
operator|)
operator|||
operator|(
name|hostsList
operator|.
name|contains
argument_list|(
name|iaddr
operator|.
name|getHostName
argument_list|()
operator|+
literal|":"
operator|+
name|node
operator|.
name|getPort
argument_list|()
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|node
operator|instanceof
name|DatanodeInfo
operator|)
operator|&&
name|hostsList
operator|.
name|contains
argument_list|(
operator|(
operator|(
name|DatanodeInfo
operator|)
name|node
operator|)
operator|.
name|getHostName
argument_list|()
argument_list|)
operator|)
return|;
block|}
comment|/**    * Decommission the node if it is in exclude list.    */
DECL|method|checkDecommissioning (DatanodeDescriptor nodeReg, String ipAddr)
specifier|private
name|void
name|checkDecommissioning
parameter_list|(
name|DatanodeDescriptor
name|nodeReg
parameter_list|,
name|String
name|ipAddr
parameter_list|)
throws|throws
name|IOException
block|{
comment|// If the registered node is in exclude list, then decommission it
if|if
condition|(
name|inExcludedHostsList
argument_list|(
name|nodeReg
argument_list|,
name|ipAddr
argument_list|)
condition|)
block|{
name|startDecommission
argument_list|(
name|nodeReg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Change, if appropriate, the admin state of a datanode to     * decommission completed. Return true if decommission is complete.    */
DECL|method|checkDecommissionState (DatanodeDescriptor node)
name|boolean
name|checkDecommissionState
parameter_list|(
name|DatanodeDescriptor
name|node
parameter_list|)
block|{
comment|// Check to see if all blocks in this decommissioned
comment|// node has reached their target replication factor.
if|if
condition|(
name|node
operator|.
name|isDecommissionInProgress
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|blockManager
operator|.
name|isReplicationInProgress
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|node
operator|.
name|setDecommissioned
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Decommission complete for node "
operator|+
name|node
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|node
operator|.
name|isDecommissioned
argument_list|()
return|;
block|}
comment|/** Start decommissioning the specified datanode. */
DECL|method|startDecommission (DatanodeDescriptor node)
specifier|private
name|void
name|startDecommission
parameter_list|(
name|DatanodeDescriptor
name|node
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|node
operator|.
name|isDecommissionInProgress
argument_list|()
operator|&&
operator|!
name|node
operator|.
name|isDecommissioned
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Start Decommissioning node "
operator|+
name|node
operator|.
name|getName
argument_list|()
operator|+
literal|" with "
operator|+
name|node
operator|.
name|numBlocks
argument_list|()
operator|+
literal|" blocks."
argument_list|)
expr_stmt|;
name|heartbeatManager
operator|.
name|startDecommission
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|.
name|decommissioningStatus
operator|.
name|setStartTime
argument_list|(
name|now
argument_list|()
argument_list|)
expr_stmt|;
comment|// all the blocks that reside on this node have to be replicated.
name|checkDecommissionState
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Stop decommissioning the specified datanodes. */
DECL|method|stopDecommission (DatanodeDescriptor node)
name|void
name|stopDecommission
parameter_list|(
name|DatanodeDescriptor
name|node
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|node
operator|.
name|isDecommissionInProgress
argument_list|()
operator|||
name|node
operator|.
name|isDecommissioned
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Stop Decommissioning node "
operator|+
name|node
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|heartbeatManager
operator|.
name|stopDecommission
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|blockManager
operator|.
name|processOverReplicatedBlocksOnReCommission
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Generate new storage ID.    *     * @return unique storage ID    *     * Note: that collisions are still possible if somebody will try     * to bring in a data storage from a different cluster.    */
DECL|method|newStorageID ()
specifier|private
name|String
name|newStorageID
parameter_list|()
block|{
name|String
name|newID
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|newID
operator|==
literal|null
condition|)
block|{
name|newID
operator|=
literal|"DS"
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|DFSUtil
operator|.
name|getRandom
argument_list|()
operator|.
name|nextInt
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|datanodeMap
operator|.
name|get
argument_list|(
name|newID
argument_list|)
operator|!=
literal|null
condition|)
name|newID
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|newID
return|;
block|}
DECL|method|registerDatanode (DatanodeRegistration nodeReg )
specifier|public
name|void
name|registerDatanode
parameter_list|(
name|DatanodeRegistration
name|nodeReg
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|dnAddress
init|=
name|Server
operator|.
name|getRemoteAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|dnAddress
operator|==
literal|null
condition|)
block|{
comment|// Mostly called inside an RPC.
comment|// But if not, use address passed by the data-node.
name|dnAddress
operator|=
name|nodeReg
operator|.
name|getHost
argument_list|()
expr_stmt|;
block|}
comment|// Checks if the node is not on the hosts list.  If it is not, then
comment|// it will be disallowed from registering.
if|if
condition|(
operator|!
name|inHostsList
argument_list|(
name|nodeReg
argument_list|,
name|dnAddress
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|DisallowedDatanodeException
argument_list|(
name|nodeReg
argument_list|)
throw|;
block|}
name|String
name|hostName
init|=
name|nodeReg
operator|.
name|getHost
argument_list|()
decl_stmt|;
comment|// update the datanode's name with ip:port
name|DatanodeID
name|dnReg
init|=
operator|new
name|DatanodeID
argument_list|(
name|dnAddress
operator|+
literal|":"
operator|+
name|nodeReg
operator|.
name|getPort
argument_list|()
argument_list|,
name|nodeReg
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|nodeReg
operator|.
name|getInfoPort
argument_list|()
argument_list|,
name|nodeReg
operator|.
name|getIpcPort
argument_list|()
argument_list|)
decl_stmt|;
name|nodeReg
operator|.
name|updateRegInfo
argument_list|(
name|dnReg
argument_list|)
expr_stmt|;
name|nodeReg
operator|.
name|exportedKeys
operator|=
name|blockManager
operator|.
name|getBlockKeys
argument_list|()
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* NameSystem.registerDatanode: "
operator|+
literal|"node registration from "
operator|+
name|nodeReg
operator|.
name|getName
argument_list|()
operator|+
literal|" storage "
operator|+
name|nodeReg
operator|.
name|getStorageID
argument_list|()
argument_list|)
expr_stmt|;
name|DatanodeDescriptor
name|nodeS
init|=
name|datanodeMap
operator|.
name|get
argument_list|(
name|nodeReg
operator|.
name|getStorageID
argument_list|()
argument_list|)
decl_stmt|;
name|DatanodeDescriptor
name|nodeN
init|=
name|getDatanodeByHost
argument_list|(
name|nodeReg
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeN
operator|!=
literal|null
operator|&&
name|nodeN
operator|!=
name|nodeS
condition|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"BLOCK* NameSystem.registerDatanode: "
operator|+
literal|"node from name: "
operator|+
name|nodeN
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// nodeN previously served a different data storage,
comment|// which is not served by anybody anymore.
name|removeDatanode
argument_list|(
name|nodeN
argument_list|)
expr_stmt|;
comment|// physically remove node from datanodeMap
name|wipeDatanode
argument_list|(
name|nodeN
argument_list|)
expr_stmt|;
name|nodeN
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|nodeS
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|nodeN
operator|==
name|nodeS
condition|)
block|{
comment|// The same datanode has been just restarted to serve the same data
comment|// storage. We do not need to remove old data blocks, the delta will
comment|// be calculated on the next block report from the datanode
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* NameSystem.registerDatanode: "
operator|+
literal|"node restarted."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// nodeS is found
comment|/* The registering datanode is a replacement node for the existing            data storage, which from now on will be served by a new node.           If this message repeats, both nodes might have same storageID            by (insanely rare) random chance. User needs to restart one of the           nodes with its data cleared (or user can just remove the StorageID           value in "VERSION" file under the data directory of the datanode,           but this is might not work if VERSION file format has changed         */
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* NameSystem.registerDatanode: "
operator|+
literal|"node "
operator|+
name|nodeS
operator|.
name|getName
argument_list|()
operator|+
literal|" is replaced by "
operator|+
name|nodeReg
operator|.
name|getName
argument_list|()
operator|+
literal|" with the same storageID "
operator|+
name|nodeReg
operator|.
name|getStorageID
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// update cluster map
name|getNetworkTopology
argument_list|()
operator|.
name|remove
argument_list|(
name|nodeS
argument_list|)
expr_stmt|;
name|nodeS
operator|.
name|updateRegInfo
argument_list|(
name|nodeReg
argument_list|)
expr_stmt|;
name|nodeS
operator|.
name|setHostName
argument_list|(
name|hostName
argument_list|)
expr_stmt|;
name|nodeS
operator|.
name|setDisallowed
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Node is in the include list
comment|// resolve network location
name|resolveNetworkLocation
argument_list|(
name|nodeS
argument_list|)
expr_stmt|;
name|getNetworkTopology
argument_list|()
operator|.
name|add
argument_list|(
name|nodeS
argument_list|)
expr_stmt|;
comment|// also treat the registration message as a heartbeat
name|heartbeatManager
operator|.
name|register
argument_list|(
name|nodeS
argument_list|)
expr_stmt|;
name|checkDecommissioning
argument_list|(
name|nodeS
argument_list|,
name|dnAddress
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// this is a new datanode serving a new data storage
if|if
condition|(
name|nodeReg
operator|.
name|getStorageID
argument_list|()
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
comment|// this data storage has never been registered
comment|// it is either empty or was created by pre-storageID version of DFS
name|nodeReg
operator|.
name|storageID
operator|=
name|newStorageID
argument_list|()
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* NameSystem.registerDatanode: "
operator|+
literal|"new storageID "
operator|+
name|nodeReg
operator|.
name|getStorageID
argument_list|()
operator|+
literal|" assigned."
argument_list|)
expr_stmt|;
block|}
block|}
comment|// register new datanode
name|DatanodeDescriptor
name|nodeDescr
init|=
operator|new
name|DatanodeDescriptor
argument_list|(
name|nodeReg
argument_list|,
name|NetworkTopology
operator|.
name|DEFAULT_RACK
argument_list|,
name|hostName
argument_list|)
decl_stmt|;
name|resolveNetworkLocation
argument_list|(
name|nodeDescr
argument_list|)
expr_stmt|;
name|addDatanode
argument_list|(
name|nodeDescr
argument_list|)
expr_stmt|;
name|checkDecommissioning
argument_list|(
name|nodeDescr
argument_list|,
name|dnAddress
argument_list|)
expr_stmt|;
comment|// also treat the registration message as a heartbeat
comment|// no need to update its timestamp
comment|// because its is done when the descriptor is created
name|heartbeatManager
operator|.
name|addDatanode
argument_list|(
name|nodeDescr
argument_list|)
expr_stmt|;
block|}
comment|/**    * Rereads conf to get hosts and exclude list file names.    * Rereads the files to update the hosts and exclude lists.  It    * checks if any of the hosts have changed states:    */
DECL|method|refreshNodes (final Configuration conf)
specifier|public
name|void
name|refreshNodes
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|namesystem
operator|.
name|checkSuperuserPrivilege
argument_list|()
expr_stmt|;
name|refreshHostsReader
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|namesystem
operator|.
name|writeLock
argument_list|()
expr_stmt|;
try|try
block|{
name|refreshDatanodes
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|namesystem
operator|.
name|writeUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Reread include/exclude files. */
DECL|method|refreshHostsReader (Configuration conf)
specifier|private
name|void
name|refreshHostsReader
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Reread the conf to get dfs.hosts and dfs.hosts.exclude filenames.
comment|// Update the file names and refresh internal includes and excludes list.
if|if
condition|(
name|conf
operator|==
literal|null
condition|)
block|{
name|conf
operator|=
operator|new
name|HdfsConfiguration
argument_list|()
expr_stmt|;
block|}
name|hostsReader
operator|.
name|updateFileNames
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HOSTS
argument_list|,
literal|""
argument_list|)
argument_list|,
name|conf
operator|.
name|get
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HOSTS_EXCLUDE
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|hostsReader
operator|.
name|refresh
argument_list|()
expr_stmt|;
block|}
comment|/**    * 1. Added to hosts  --> no further work needed here.    * 2. Removed from hosts --> mark AdminState as decommissioned.     * 3. Added to exclude --> start decommission.    * 4. Removed from exclude --> stop decommission.    */
DECL|method|refreshDatanodes ()
specifier|private
name|void
name|refreshDatanodes
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|datanodeMap
operator|.
name|values
argument_list|()
control|)
block|{
comment|// Check if not include.
if|if
condition|(
operator|!
name|inHostsList
argument_list|(
name|node
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|node
operator|.
name|setDisallowed
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// case 2.
block|}
else|else
block|{
if|if
condition|(
name|inExcludedHostsList
argument_list|(
name|node
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|startDecommission
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// case 3.
block|}
else|else
block|{
name|stopDecommission
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// case 4.
block|}
block|}
block|}
block|}
comment|/** @return the number of live datanodes. */
DECL|method|getNumLiveDataNodes ()
specifier|public
name|int
name|getNumLiveDataNodes
parameter_list|()
block|{
name|int
name|numLive
init|=
literal|0
decl_stmt|;
synchronized|synchronized
init|(
name|datanodeMap
init|)
block|{
for|for
control|(
name|DatanodeDescriptor
name|dn
range|:
name|datanodeMap
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|isDatanodeDead
argument_list|(
name|dn
argument_list|)
condition|)
block|{
name|numLive
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|numLive
return|;
block|}
comment|/** @return the number of dead datanodes. */
DECL|method|getNumDeadDataNodes ()
specifier|public
name|int
name|getNumDeadDataNodes
parameter_list|()
block|{
name|int
name|numDead
init|=
literal|0
decl_stmt|;
synchronized|synchronized
init|(
name|datanodeMap
init|)
block|{
for|for
control|(
name|DatanodeDescriptor
name|dn
range|:
name|datanodeMap
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|isDatanodeDead
argument_list|(
name|dn
argument_list|)
condition|)
block|{
name|numDead
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|numDead
return|;
block|}
comment|/** @return list of datanodes where decommissioning is in progress. */
DECL|method|getDecommissioningNodes ()
specifier|public
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|getDecommissioningNodes
parameter_list|()
block|{
name|namesystem
operator|.
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|decommissioningNodes
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|results
init|=
name|getDatanodeListForReport
argument_list|(
name|DatanodeReportType
operator|.
name|LIVE
argument_list|)
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|results
control|)
block|{
if|if
condition|(
name|node
operator|.
name|isDecommissionInProgress
argument_list|()
condition|)
block|{
name|decommissioningNodes
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|decommissioningNodes
return|;
block|}
finally|finally
block|{
name|namesystem
operator|.
name|readUnlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Fetch live and dead datanodes. */
DECL|method|fetchDatanodes (final List<DatanodeDescriptor> live, final List<DatanodeDescriptor> dead, final boolean removeDecommissionNode)
specifier|public
name|void
name|fetchDatanodes
parameter_list|(
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|live
parameter_list|,
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|dead
parameter_list|,
specifier|final
name|boolean
name|removeDecommissionNode
parameter_list|)
block|{
if|if
condition|(
name|live
operator|==
literal|null
operator|&&
name|dead
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Both live and dead lists are null"
argument_list|)
throw|;
block|}
name|namesystem
operator|.
name|readLock
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|results
init|=
name|getDatanodeListForReport
argument_list|(
name|DatanodeReportType
operator|.
name|ALL
argument_list|)
decl_stmt|;
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|results
control|)
block|{
if|if
condition|(
name|isDatanodeDead
argument_list|(
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|dead
operator|!=
literal|null
condition|)
block|{
name|dead
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|live
operator|!=
literal|null
condition|)
block|{
name|live
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|namesystem
operator|.
name|readUnlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|removeDecommissionNode
condition|)
block|{
if|if
condition|(
name|live
operator|!=
literal|null
condition|)
block|{
name|removeDecomNodeFromList
argument_list|(
name|live
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dead
operator|!=
literal|null
condition|)
block|{
name|removeDecomNodeFromList
argument_list|(
name|dead
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** For generating datanode reports */
DECL|method|getDatanodeListForReport ( final DatanodeReportType type)
specifier|public
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|getDatanodeListForReport
parameter_list|(
specifier|final
name|DatanodeReportType
name|type
parameter_list|)
block|{
name|boolean
name|listLiveNodes
init|=
name|type
operator|==
name|DatanodeReportType
operator|.
name|ALL
operator|||
name|type
operator|==
name|DatanodeReportType
operator|.
name|LIVE
decl_stmt|;
name|boolean
name|listDeadNodes
init|=
name|type
operator|==
name|DatanodeReportType
operator|.
name|ALL
operator|||
name|type
operator|==
name|DatanodeReportType
operator|.
name|DEAD
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mustList
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|listDeadNodes
condition|)
block|{
comment|//first load all the nodes listed in include and exclude files.
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|hostsReader
operator|.
name|getHosts
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|mustList
operator|.
name|put
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|it
operator|=
name|hostsReader
operator|.
name|getExcludedHosts
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|mustList
operator|.
name|put
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodes
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|datanodeMap
init|)
block|{
name|nodes
operator|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|(
name|datanodeMap
operator|.
name|size
argument_list|()
operator|+
name|mustList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|it
init|=
name|datanodeMap
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|DatanodeDescriptor
name|dn
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|isDead
init|=
name|isDatanodeDead
argument_list|(
name|dn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|isDead
operator|&&
name|listDeadNodes
operator|)
operator|||
operator|(
operator|!
name|isDead
operator|&&
name|listLiveNodes
operator|)
condition|)
block|{
name|nodes
operator|.
name|add
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
comment|//Remove any form of the this datanode in include/exclude lists.
try|try
block|{
name|InetAddress
name|inet
init|=
name|InetAddress
operator|.
name|getByName
argument_list|(
name|dn
operator|.
name|getHost
argument_list|()
argument_list|)
decl_stmt|;
comment|// compare hostname(:port)
name|mustList
operator|.
name|remove
argument_list|(
name|inet
operator|.
name|getHostName
argument_list|()
argument_list|)
expr_stmt|;
name|mustList
operator|.
name|remove
argument_list|(
name|inet
operator|.
name|getHostName
argument_list|()
operator|+
literal|":"
operator|+
name|dn
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
comment|// compare ipaddress(:port)
name|mustList
operator|.
name|remove
argument_list|(
name|inet
operator|.
name|getHostAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|mustList
operator|.
name|remove
argument_list|(
name|inet
operator|.
name|getHostAddress
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|":"
operator|+
name|dn
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownHostException
name|e
parameter_list|)
block|{
name|mustList
operator|.
name|remove
argument_list|(
name|dn
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|mustList
operator|.
name|remove
argument_list|(
name|dn
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|listDeadNodes
condition|)
block|{
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|mustList
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|DatanodeDescriptor
name|dn
init|=
operator|new
name|DatanodeDescriptor
argument_list|(
operator|new
name|DatanodeID
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|dn
operator|.
name|setLastUpdate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|nodes
operator|.
name|add
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|nodes
return|;
block|}
DECL|method|setDatanodeDead (DatanodeDescriptor node)
specifier|private
name|void
name|setDatanodeDead
parameter_list|(
name|DatanodeDescriptor
name|node
parameter_list|)
throws|throws
name|IOException
block|{
name|node
operator|.
name|setLastUpdate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/** Handle heartbeat from datanodes. */
DECL|method|handleHeartbeat (DatanodeRegistration nodeReg, final String blockPoolId, long capacity, long dfsUsed, long remaining, long blockPoolUsed, int xceiverCount, int maxTransfers, int failedVolumes )
specifier|public
name|DatanodeCommand
index|[]
name|handleHeartbeat
parameter_list|(
name|DatanodeRegistration
name|nodeReg
parameter_list|,
specifier|final
name|String
name|blockPoolId
parameter_list|,
name|long
name|capacity
parameter_list|,
name|long
name|dfsUsed
parameter_list|,
name|long
name|remaining
parameter_list|,
name|long
name|blockPoolUsed
parameter_list|,
name|int
name|xceiverCount
parameter_list|,
name|int
name|maxTransfers
parameter_list|,
name|int
name|failedVolumes
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|heartbeatManager
init|)
block|{
synchronized|synchronized
init|(
name|datanodeMap
init|)
block|{
name|DatanodeDescriptor
name|nodeinfo
init|=
literal|null
decl_stmt|;
try|try
block|{
name|nodeinfo
operator|=
name|getDatanode
argument_list|(
name|nodeReg
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnregisteredNodeException
name|e
parameter_list|)
block|{
return|return
operator|new
name|DatanodeCommand
index|[]
block|{
name|DatanodeCommand
operator|.
name|REGISTER
block|}
return|;
block|}
comment|// Check if this datanode should actually be shutdown instead.
if|if
condition|(
name|nodeinfo
operator|!=
literal|null
operator|&&
name|nodeinfo
operator|.
name|isDisallowed
argument_list|()
condition|)
block|{
name|setDatanodeDead
argument_list|(
name|nodeinfo
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|DisallowedDatanodeException
argument_list|(
name|nodeinfo
argument_list|)
throw|;
block|}
if|if
condition|(
name|nodeinfo
operator|==
literal|null
operator|||
operator|!
name|nodeinfo
operator|.
name|isAlive
condition|)
block|{
return|return
operator|new
name|DatanodeCommand
index|[]
block|{
name|DatanodeCommand
operator|.
name|REGISTER
block|}
return|;
block|}
name|heartbeatManager
operator|.
name|updateHeartbeat
argument_list|(
name|nodeinfo
argument_list|,
name|capacity
argument_list|,
name|dfsUsed
argument_list|,
name|remaining
argument_list|,
name|blockPoolUsed
argument_list|,
name|xceiverCount
argument_list|,
name|failedVolumes
argument_list|)
expr_stmt|;
comment|//check lease recovery
name|BlockInfoUnderConstruction
index|[]
name|blocks
init|=
name|nodeinfo
operator|.
name|getLeaseRecoveryCommand
argument_list|(
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|blocks
operator|!=
literal|null
condition|)
block|{
name|BlockRecoveryCommand
name|brCommand
init|=
operator|new
name|BlockRecoveryCommand
argument_list|(
name|blocks
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|BlockInfoUnderConstruction
name|b
range|:
name|blocks
control|)
block|{
name|brCommand
operator|.
name|add
argument_list|(
operator|new
name|RecoveringBlock
argument_list|(
operator|new
name|ExtendedBlock
argument_list|(
name|blockPoolId
argument_list|,
name|b
argument_list|)
argument_list|,
name|b
operator|.
name|getExpectedLocations
argument_list|()
argument_list|,
name|b
operator|.
name|getBlockRecoveryId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|DatanodeCommand
index|[]
block|{
name|brCommand
block|}
return|;
block|}
specifier|final
name|List
argument_list|<
name|DatanodeCommand
argument_list|>
name|cmds
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeCommand
argument_list|>
argument_list|()
decl_stmt|;
comment|//check pending replication
name|List
argument_list|<
name|BlockTargetPair
argument_list|>
name|pendingList
init|=
name|nodeinfo
operator|.
name|getReplicationCommand
argument_list|(
name|maxTransfers
argument_list|)
decl_stmt|;
if|if
condition|(
name|pendingList
operator|!=
literal|null
condition|)
block|{
name|cmds
operator|.
name|add
argument_list|(
operator|new
name|BlockCommand
argument_list|(
name|DatanodeProtocol
operator|.
name|DNA_TRANSFER
argument_list|,
name|blockPoolId
argument_list|,
name|pendingList
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//check block invalidation
name|Block
index|[]
name|blks
init|=
name|nodeinfo
operator|.
name|getInvalidateBlocks
argument_list|(
name|blockInvalidateLimit
argument_list|)
decl_stmt|;
if|if
condition|(
name|blks
operator|!=
literal|null
condition|)
block|{
name|cmds
operator|.
name|add
argument_list|(
operator|new
name|BlockCommand
argument_list|(
name|DatanodeProtocol
operator|.
name|DNA_INVALIDATE
argument_list|,
name|blockPoolId
argument_list|,
name|blks
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|blockManager
operator|.
name|addKeyUpdateCommand
argument_list|(
name|cmds
argument_list|,
name|nodeinfo
argument_list|)
expr_stmt|;
comment|// check for balancer bandwidth update
if|if
condition|(
name|nodeinfo
operator|.
name|getBalancerBandwidth
argument_list|()
operator|>
literal|0
condition|)
block|{
name|cmds
operator|.
name|add
argument_list|(
operator|new
name|BalancerBandwidthCommand
argument_list|(
name|nodeinfo
operator|.
name|getBalancerBandwidth
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// set back to 0 to indicate that datanode has been sent the new value
name|nodeinfo
operator|.
name|setBalancerBandwidth
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cmds
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|cmds
operator|.
name|toArray
argument_list|(
operator|new
name|DatanodeCommand
index|[
name|cmds
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Tell all datanodes to use a new, non-persistent bandwidth value for    * dfs.balance.bandwidthPerSec.    *    * A system administrator can tune the balancer bandwidth parameter    * (dfs.datanode.balance.bandwidthPerSec) dynamically by calling    * "dfsadmin -setBalanacerBandwidth newbandwidth", at which point the    * following 'bandwidth' variable gets updated with the new value for each    * node. Once the heartbeat command is issued to update the value on the    * specified datanode, this value will be set back to 0.    *    * @param bandwidth Blanacer bandwidth in bytes per second for all datanodes.    * @throws IOException    */
DECL|method|setBalancerBandwidth (long bandwidth)
specifier|public
name|void
name|setBalancerBandwidth
parameter_list|(
name|long
name|bandwidth
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|datanodeMap
init|)
block|{
for|for
control|(
name|DatanodeDescriptor
name|nodeInfo
range|:
name|datanodeMap
operator|.
name|values
argument_list|()
control|)
block|{
name|nodeInfo
operator|.
name|setBalancerBandwidth
argument_list|(
name|bandwidth
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

