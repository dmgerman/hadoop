begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.blockmanagement
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSConstants
operator|.
name|DatanodeReportType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSNamesystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DatanodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|DisallowedDatanodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|Server
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|CachedDNSToSwitchMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|DNSToSwitchMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetworkTopology
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|ScriptBasedMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|HostsFileReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_comment
comment|/**  * Manage datanodes, include decommission and other activities.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|DatanodeManager
specifier|public
class|class
name|DatanodeManager
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|DatanodeManager
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|namesystem
specifier|final
name|FSNamesystem
name|namesystem
decl_stmt|;
comment|/** Cluster network topology */
DECL|field|networktopology
specifier|private
specifier|final
name|NetworkTopology
name|networktopology
init|=
operator|new
name|NetworkTopology
argument_list|()
decl_stmt|;
comment|/** Host names to datanode descriptors mapping. */
DECL|field|host2DatanodeMap
specifier|private
specifier|final
name|Host2NodesMap
name|host2DatanodeMap
init|=
operator|new
name|Host2NodesMap
argument_list|()
decl_stmt|;
DECL|field|dnsToSwitchMapping
specifier|private
specifier|final
name|DNSToSwitchMapping
name|dnsToSwitchMapping
decl_stmt|;
comment|/** Read include/exclude files*/
DECL|field|hostsReader
specifier|private
specifier|final
name|HostsFileReader
name|hostsReader
decl_stmt|;
DECL|method|DatanodeManager (final FSNamesystem namesystem, final Configuration conf )
name|DatanodeManager
parameter_list|(
specifier|final
name|FSNamesystem
name|namesystem
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|namesystem
operator|=
name|namesystem
expr_stmt|;
name|this
operator|.
name|hostsReader
operator|=
operator|new
name|HostsFileReader
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HOSTS
argument_list|,
literal|""
argument_list|)
argument_list|,
name|conf
operator|.
name|get
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HOSTS_EXCLUDE
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|dnsToSwitchMapping
operator|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|conf
operator|.
name|getClass
argument_list|(
name|DFSConfigKeys
operator|.
name|NET_TOPOLOGY_NODE_SWITCH_MAPPING_IMPL_KEY
argument_list|,
name|ScriptBasedMapping
operator|.
name|class
argument_list|,
name|DNSToSwitchMapping
operator|.
name|class
argument_list|)
argument_list|,
name|conf
argument_list|)
expr_stmt|;
comment|// If the dns to switch mapping supports cache, resolve network
comment|// locations of those hosts in the include list and store the mapping
comment|// in the cache; so future calls to resolve will be fast.
if|if
condition|(
name|dnsToSwitchMapping
operator|instanceof
name|CachedDNSToSwitchMapping
condition|)
block|{
name|dnsToSwitchMapping
operator|.
name|resolve
argument_list|(
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|hostsReader
operator|.
name|getHosts
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|decommissionthread
specifier|private
name|Daemon
name|decommissionthread
init|=
literal|null
decl_stmt|;
DECL|method|activate (final Configuration conf)
name|void
name|activate
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|decommissionthread
operator|=
operator|new
name|Daemon
argument_list|(
operator|new
name|DecommissionManager
argument_list|(
name|namesystem
argument_list|)
operator|.
operator|new
name|Monitor
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DECOMMISSION_INTERVAL_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DECOMMISSION_INTERVAL_DEFAULT
argument_list|)
argument_list|,
name|conf
operator|.
name|getInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DECOMMISSION_NODES_PER_INTERVAL_KEY
argument_list|,
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_DECOMMISSION_NODES_PER_INTERVAL_DEFAULT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|decommissionthread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|close ()
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|decommissionthread
operator|!=
literal|null
condition|)
name|decommissionthread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
comment|/** @return the network topology. */
DECL|method|getNetworkTopology ()
specifier|public
name|NetworkTopology
name|getNetworkTopology
parameter_list|()
block|{
return|return
name|networktopology
return|;
block|}
comment|/** Sort the located blocks by the distance to the target host. */
DECL|method|sortLocatedBlocks (final String targethost, final List<LocatedBlock> locatedblocks)
specifier|public
name|void
name|sortLocatedBlocks
parameter_list|(
specifier|final
name|String
name|targethost
parameter_list|,
specifier|final
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|locatedblocks
parameter_list|)
block|{
comment|//sort the blocks
specifier|final
name|DatanodeDescriptor
name|client
init|=
name|getDatanodeByHost
argument_list|(
name|targethost
argument_list|)
decl_stmt|;
for|for
control|(
name|LocatedBlock
name|b
range|:
name|locatedblocks
control|)
block|{
name|networktopology
operator|.
name|pseudoSortByDistance
argument_list|(
name|client
argument_list|,
name|b
operator|.
name|getLocations
argument_list|()
argument_list|)
expr_stmt|;
comment|// Move decommissioned datanodes to the bottom
name|Arrays
operator|.
name|sort
argument_list|(
name|b
operator|.
name|getLocations
argument_list|()
argument_list|,
name|DFSUtil
operator|.
name|DECOM_COMPARATOR
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** @return the datanode descriptor for the host. */
DECL|method|getDatanodeByHost (final String host)
specifier|public
name|DatanodeDescriptor
name|getDatanodeByHost
parameter_list|(
specifier|final
name|String
name|host
parameter_list|)
block|{
return|return
name|host2DatanodeMap
operator|.
name|getDatanodeByHost
argument_list|(
name|host
argument_list|)
return|;
block|}
comment|/** Add a datanode. */
DECL|method|addDatanode (final DatanodeDescriptor node)
specifier|private
name|void
name|addDatanode
parameter_list|(
specifier|final
name|DatanodeDescriptor
name|node
parameter_list|)
block|{
comment|// To keep host2DatanodeMap consistent with datanodeMap,
comment|// remove  from host2DatanodeMap the datanodeDescriptor removed
comment|// from datanodeMap before adding node to host2DatanodeMap.
synchronized|synchronized
init|(
name|namesystem
operator|.
name|datanodeMap
init|)
block|{
name|host2DatanodeMap
operator|.
name|remove
argument_list|(
name|namesystem
operator|.
name|datanodeMap
operator|.
name|put
argument_list|(
name|node
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|host2DatanodeMap
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|networktopology
operator|.
name|add
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|".addDatanode: "
operator|+
literal|"node "
operator|+
name|node
operator|.
name|getName
argument_list|()
operator|+
literal|" is added to datanodeMap."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Physically remove node from datanodeMap. */
DECL|method|wipeDatanode (final DatanodeID node)
specifier|private
name|void
name|wipeDatanode
parameter_list|(
specifier|final
name|DatanodeID
name|node
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|key
init|=
name|node
operator|.
name|getStorageID
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|namesystem
operator|.
name|datanodeMap
init|)
block|{
name|host2DatanodeMap
operator|.
name|remove
argument_list|(
name|namesystem
operator|.
name|datanodeMap
operator|.
name|remove
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|".wipeDatanode("
operator|+
name|node
operator|.
name|getName
argument_list|()
operator|+
literal|"): storage "
operator|+
name|key
operator|+
literal|" is removed from datanodeMap."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Resolve a node's network location */
DECL|method|resolveNetworkLocation (DatanodeDescriptor node)
specifier|private
name|void
name|resolveNetworkLocation
parameter_list|(
name|DatanodeDescriptor
name|node
parameter_list|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|names
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|dnsToSwitchMapping
operator|instanceof
name|CachedDNSToSwitchMapping
condition|)
block|{
comment|// get the node's IP address
name|names
operator|.
name|add
argument_list|(
name|node
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// get the node's host name
name|String
name|hostName
init|=
name|node
operator|.
name|getHostName
argument_list|()
decl_stmt|;
name|int
name|colon
init|=
name|hostName
operator|.
name|indexOf
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
name|hostName
operator|=
operator|(
name|colon
operator|==
operator|-
literal|1
operator|)
condition|?
name|hostName
else|:
name|hostName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|colon
argument_list|)
expr_stmt|;
name|names
operator|.
name|add
argument_list|(
name|hostName
argument_list|)
expr_stmt|;
block|}
comment|// resolve its network location
name|List
argument_list|<
name|String
argument_list|>
name|rName
init|=
name|dnsToSwitchMapping
operator|.
name|resolve
argument_list|(
name|names
argument_list|)
decl_stmt|;
name|String
name|networkLocation
decl_stmt|;
if|if
condition|(
name|rName
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"The resolve call returned null! Using "
operator|+
name|NetworkTopology
operator|.
name|DEFAULT_RACK
operator|+
literal|" for host "
operator|+
name|names
argument_list|)
expr_stmt|;
name|networkLocation
operator|=
name|NetworkTopology
operator|.
name|DEFAULT_RACK
expr_stmt|;
block|}
else|else
block|{
name|networkLocation
operator|=
name|rName
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|node
operator|.
name|setNetworkLocation
argument_list|(
name|networkLocation
argument_list|)
expr_stmt|;
block|}
DECL|method|inHostsList (DatanodeID node, String ipAddr)
specifier|private
name|boolean
name|inHostsList
parameter_list|(
name|DatanodeID
name|node
parameter_list|,
name|String
name|ipAddr
parameter_list|)
block|{
return|return
name|checkInList
argument_list|(
name|node
argument_list|,
name|ipAddr
argument_list|,
name|hostsReader
operator|.
name|getHosts
argument_list|()
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|inExcludedHostsList (DatanodeID node, String ipAddr)
specifier|private
name|boolean
name|inExcludedHostsList
parameter_list|(
name|DatanodeID
name|node
parameter_list|,
name|String
name|ipAddr
parameter_list|)
block|{
return|return
name|checkInList
argument_list|(
name|node
argument_list|,
name|ipAddr
argument_list|,
name|hostsReader
operator|.
name|getExcludedHosts
argument_list|()
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Remove an already decommissioned data node who is neither in include nor    * exclude hosts lists from the the list of live or dead nodes.  This is used    * to not display an already decommssioned data node to the operators.    * The operation procedure of making a already decommissioned data node not    * to be displayed is as following:    *<ol>    *<li>     *   Host must have been in the include hosts list and the include hosts list    *   must not be empty.    *</li>    *<li>    *   Host is decommissioned by remaining in the include hosts list and added    *   into the exclude hosts list. Name node is updated with the new     *   information by issuing dfsadmin -refreshNodes command.    *</li>    *<li>    *   Host is removed from both include hosts and exclude hosts lists.  Name     *   node is updated with the new informationby issuing dfsamin -refreshNodes     *   command.    *<li>    *</ol>    *     * @param nodeList    *          , array list of live or dead nodes.    */
DECL|method|removeDecomNodeFromList (final List<DatanodeDescriptor> nodeList)
specifier|public
name|void
name|removeDecomNodeFromList
parameter_list|(
specifier|final
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodeList
parameter_list|)
block|{
comment|// If the include list is empty, any nodes are welcomed and it does not
comment|// make sense to exclude any nodes from the cluster. Therefore, no remove.
if|if
condition|(
name|hostsReader
operator|.
name|getHosts
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
for|for
control|(
name|Iterator
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|it
init|=
name|nodeList
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|DatanodeDescriptor
name|node
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|inHostsList
argument_list|(
name|node
argument_list|,
literal|null
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|inExcludedHostsList
argument_list|(
name|node
argument_list|,
literal|null
argument_list|)
operator|)
operator|&&
name|node
operator|.
name|isDecommissioned
argument_list|()
condition|)
block|{
comment|// Include list is not empty, an existing datanode does not appear
comment|// in both include or exclude lists and it has been decommissioned.
comment|// Remove it from the node list.
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Check if the given node (of DatanodeID or ipAddress) is in the (include or    * exclude) list.  If ipAddress in null, check only based upon the given     * DatanodeID.  If ipAddress is not null, the ipAddress should refers to the    * same host that given DatanodeID refers to.    *     * @param node, the host DatanodeID    * @param ipAddress, if not null, should refers to the same host    *                   that DatanodeID refers to    * @param hostsList, the list of hosts in the include/exclude file    * @param isExcludeList, boolean, true if this is the exclude list    * @return boolean, if in the list    */
DECL|method|checkInList (final DatanodeID node, final String ipAddress, final Set<String> hostsList, final boolean isExcludeList)
specifier|private
specifier|static
name|boolean
name|checkInList
parameter_list|(
specifier|final
name|DatanodeID
name|node
parameter_list|,
specifier|final
name|String
name|ipAddress
parameter_list|,
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|hostsList
parameter_list|,
specifier|final
name|boolean
name|isExcludeList
parameter_list|)
block|{
specifier|final
name|InetAddress
name|iaddr
decl_stmt|;
if|if
condition|(
name|ipAddress
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|iaddr
operator|=
name|InetAddress
operator|.
name|getByName
argument_list|(
name|ipAddress
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownHostException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unknown ip address: "
operator|+
name|ipAddress
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|isExcludeList
return|;
block|}
block|}
else|else
block|{
try|try
block|{
name|iaddr
operator|=
name|InetAddress
operator|.
name|getByName
argument_list|(
name|node
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownHostException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unknown host: "
operator|+
name|node
operator|.
name|getHost
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|isExcludeList
return|;
block|}
block|}
comment|// if include list is empty, host is in include list
if|if
condition|(
operator|(
operator|!
name|isExcludeList
operator|)
operator|&&
operator|(
name|hostsList
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
comment|// compare ipaddress(:port)
operator|(
name|hostsList
operator|.
name|contains
argument_list|(
name|iaddr
operator|.
name|getHostAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
operator|)
operator|||
operator|(
name|hostsList
operator|.
name|contains
argument_list|(
name|iaddr
operator|.
name|getHostAddress
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|":"
operator|+
name|node
operator|.
name|getPort
argument_list|()
argument_list|)
operator|)
comment|// compare hostname(:port)
operator|||
operator|(
name|hostsList
operator|.
name|contains
argument_list|(
name|iaddr
operator|.
name|getHostName
argument_list|()
argument_list|)
operator|)
operator|||
operator|(
name|hostsList
operator|.
name|contains
argument_list|(
name|iaddr
operator|.
name|getHostName
argument_list|()
operator|+
literal|":"
operator|+
name|node
operator|.
name|getPort
argument_list|()
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|node
operator|instanceof
name|DatanodeInfo
operator|)
operator|&&
name|hostsList
operator|.
name|contains
argument_list|(
operator|(
operator|(
name|DatanodeInfo
operator|)
name|node
operator|)
operator|.
name|getHostName
argument_list|()
argument_list|)
operator|)
return|;
block|}
comment|/**    * Decommission the node if it is in exclude list.    */
DECL|method|checkDecommissioning (DatanodeDescriptor nodeReg, String ipAddr)
specifier|private
name|void
name|checkDecommissioning
parameter_list|(
name|DatanodeDescriptor
name|nodeReg
parameter_list|,
name|String
name|ipAddr
parameter_list|)
throws|throws
name|IOException
block|{
comment|// If the registered node is in exclude list, then decommission it
if|if
condition|(
name|inExcludedHostsList
argument_list|(
name|nodeReg
argument_list|,
name|ipAddr
argument_list|)
condition|)
block|{
name|namesystem
operator|.
name|getBlockManager
argument_list|()
operator|.
name|startDecommission
argument_list|(
name|nodeReg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Generate new storage ID.    *     * @return unique storage ID    *     * Note: that collisions are still possible if somebody will try     * to bring in a data storage from a different cluster.    */
DECL|method|newStorageID ()
specifier|private
name|String
name|newStorageID
parameter_list|()
block|{
name|String
name|newID
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|newID
operator|==
literal|null
condition|)
block|{
name|newID
operator|=
literal|"DS"
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|DFSUtil
operator|.
name|getRandom
argument_list|()
operator|.
name|nextInt
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|namesystem
operator|.
name|datanodeMap
operator|.
name|get
argument_list|(
name|newID
argument_list|)
operator|!=
literal|null
condition|)
name|newID
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|newID
return|;
block|}
DECL|method|registerDatanode (DatanodeRegistration nodeReg )
specifier|public
name|void
name|registerDatanode
parameter_list|(
name|DatanodeRegistration
name|nodeReg
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|dnAddress
init|=
name|Server
operator|.
name|getRemoteAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|dnAddress
operator|==
literal|null
condition|)
block|{
comment|// Mostly called inside an RPC.
comment|// But if not, use address passed by the data-node.
name|dnAddress
operator|=
name|nodeReg
operator|.
name|getHost
argument_list|()
expr_stmt|;
block|}
comment|// Checks if the node is not on the hosts list.  If it is not, then
comment|// it will be disallowed from registering.
if|if
condition|(
operator|!
name|inHostsList
argument_list|(
name|nodeReg
argument_list|,
name|dnAddress
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|DisallowedDatanodeException
argument_list|(
name|nodeReg
argument_list|)
throw|;
block|}
name|String
name|hostName
init|=
name|nodeReg
operator|.
name|getHost
argument_list|()
decl_stmt|;
comment|// update the datanode's name with ip:port
name|DatanodeID
name|dnReg
init|=
operator|new
name|DatanodeID
argument_list|(
name|dnAddress
operator|+
literal|":"
operator|+
name|nodeReg
operator|.
name|getPort
argument_list|()
argument_list|,
name|nodeReg
operator|.
name|getStorageID
argument_list|()
argument_list|,
name|nodeReg
operator|.
name|getInfoPort
argument_list|()
argument_list|,
name|nodeReg
operator|.
name|getIpcPort
argument_list|()
argument_list|)
decl_stmt|;
name|nodeReg
operator|.
name|updateRegInfo
argument_list|(
name|dnReg
argument_list|)
expr_stmt|;
name|nodeReg
operator|.
name|exportedKeys
operator|=
name|namesystem
operator|.
name|getBlockKeys
argument_list|()
expr_stmt|;
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* NameSystem.registerDatanode: "
operator|+
literal|"node registration from "
operator|+
name|nodeReg
operator|.
name|getName
argument_list|()
operator|+
literal|" storage "
operator|+
name|nodeReg
operator|.
name|getStorageID
argument_list|()
argument_list|)
expr_stmt|;
name|DatanodeDescriptor
name|nodeS
init|=
name|namesystem
operator|.
name|datanodeMap
operator|.
name|get
argument_list|(
name|nodeReg
operator|.
name|getStorageID
argument_list|()
argument_list|)
decl_stmt|;
name|DatanodeDescriptor
name|nodeN
init|=
name|getDatanodeByHost
argument_list|(
name|nodeReg
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeN
operator|!=
literal|null
operator|&&
name|nodeN
operator|!=
name|nodeS
condition|)
block|{
name|NameNode
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"BLOCK* NameSystem.registerDatanode: "
operator|+
literal|"node from name: "
operator|+
name|nodeN
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// nodeN previously served a different data storage,
comment|// which is not served by anybody anymore.
name|namesystem
operator|.
name|removeDatanode
argument_list|(
name|nodeN
argument_list|)
expr_stmt|;
comment|// physically remove node from datanodeMap
name|wipeDatanode
argument_list|(
name|nodeN
argument_list|)
expr_stmt|;
name|nodeN
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|nodeS
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|nodeN
operator|==
name|nodeS
condition|)
block|{
comment|// The same datanode has been just restarted to serve the same data
comment|// storage. We do not need to remove old data blocks, the delta will
comment|// be calculated on the next block report from the datanode
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* NameSystem.registerDatanode: "
operator|+
literal|"node restarted."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// nodeS is found
comment|/* The registering datanode is a replacement node for the existing            data storage, which from now on will be served by a new node.           If this message repeats, both nodes might have same storageID            by (insanely rare) random chance. User needs to restart one of the           nodes with its data cleared (or user can just remove the StorageID           value in "VERSION" file under the data directory of the datanode,           but this is might not work if VERSION file format has changed         */
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|info
argument_list|(
literal|"BLOCK* NameSystem.registerDatanode: "
operator|+
literal|"node "
operator|+
name|nodeS
operator|.
name|getName
argument_list|()
operator|+
literal|" is replaced by "
operator|+
name|nodeReg
operator|.
name|getName
argument_list|()
operator|+
literal|" with the same storageID "
operator|+
name|nodeReg
operator|.
name|getStorageID
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// update cluster map
name|getNetworkTopology
argument_list|()
operator|.
name|remove
argument_list|(
name|nodeS
argument_list|)
expr_stmt|;
name|nodeS
operator|.
name|updateRegInfo
argument_list|(
name|nodeReg
argument_list|)
expr_stmt|;
name|nodeS
operator|.
name|setHostName
argument_list|(
name|hostName
argument_list|)
expr_stmt|;
name|nodeS
operator|.
name|setDisallowed
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Node is in the include list
comment|// resolve network location
name|resolveNetworkLocation
argument_list|(
name|nodeS
argument_list|)
expr_stmt|;
name|getNetworkTopology
argument_list|()
operator|.
name|add
argument_list|(
name|nodeS
argument_list|)
expr_stmt|;
comment|// also treat the registration message as a heartbeat
synchronized|synchronized
init|(
name|namesystem
operator|.
name|heartbeats
init|)
block|{
if|if
condition|(
operator|!
name|namesystem
operator|.
name|heartbeats
operator|.
name|contains
argument_list|(
name|nodeS
argument_list|)
condition|)
block|{
name|namesystem
operator|.
name|heartbeats
operator|.
name|add
argument_list|(
name|nodeS
argument_list|)
expr_stmt|;
comment|//update its timestamp
name|nodeS
operator|.
name|updateHeartbeat
argument_list|(
literal|0L
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nodeS
operator|.
name|isAlive
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|checkDecommissioning
argument_list|(
name|nodeS
argument_list|,
name|dnAddress
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// this is a new datanode serving a new data storage
if|if
condition|(
name|nodeReg
operator|.
name|getStorageID
argument_list|()
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
comment|// this data storage has never been registered
comment|// it is either empty or was created by pre-storageID version of DFS
name|nodeReg
operator|.
name|storageID
operator|=
name|newStorageID
argument_list|()
expr_stmt|;
if|if
condition|(
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|NameNode
operator|.
name|stateChangeLog
operator|.
name|debug
argument_list|(
literal|"BLOCK* NameSystem.registerDatanode: "
operator|+
literal|"new storageID "
operator|+
name|nodeReg
operator|.
name|getStorageID
argument_list|()
operator|+
literal|" assigned."
argument_list|)
expr_stmt|;
block|}
block|}
comment|// register new datanode
name|DatanodeDescriptor
name|nodeDescr
init|=
operator|new
name|DatanodeDescriptor
argument_list|(
name|nodeReg
argument_list|,
name|NetworkTopology
operator|.
name|DEFAULT_RACK
argument_list|,
name|hostName
argument_list|)
decl_stmt|;
name|resolveNetworkLocation
argument_list|(
name|nodeDescr
argument_list|)
expr_stmt|;
name|addDatanode
argument_list|(
name|nodeDescr
argument_list|)
expr_stmt|;
name|checkDecommissioning
argument_list|(
name|nodeDescr
argument_list|,
name|dnAddress
argument_list|)
expr_stmt|;
comment|// also treat the registration message as a heartbeat
synchronized|synchronized
init|(
name|namesystem
operator|.
name|heartbeats
init|)
block|{
name|namesystem
operator|.
name|heartbeats
operator|.
name|add
argument_list|(
name|nodeDescr
argument_list|)
expr_stmt|;
name|nodeDescr
operator|.
name|isAlive
operator|=
literal|true
expr_stmt|;
comment|// no need to update its timestamp
comment|// because its is done when the descriptor is created
block|}
block|}
comment|/** Reread include/exclude files. */
DECL|method|refreshHostsReader (Configuration conf)
specifier|public
name|void
name|refreshHostsReader
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Reread the conf to get dfs.hosts and dfs.hosts.exclude filenames.
comment|// Update the file names and refresh internal includes and excludes list.
if|if
condition|(
name|conf
operator|==
literal|null
condition|)
block|{
name|conf
operator|=
operator|new
name|HdfsConfiguration
argument_list|()
expr_stmt|;
block|}
name|hostsReader
operator|.
name|updateFileNames
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HOSTS
argument_list|,
literal|""
argument_list|)
argument_list|,
name|conf
operator|.
name|get
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_HOSTS_EXCLUDE
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|hostsReader
operator|.
name|refresh
argument_list|()
expr_stmt|;
block|}
comment|/**    * Rereads the config to get hosts and exclude list file names.    * Rereads the files to update the hosts and exclude lists.  It    * checks if any of the hosts have changed states:    * 1. Added to hosts  --> no further work needed here.    * 2. Removed from hosts --> mark AdminState as decommissioned.     * 3. Added to exclude --> start decommission.    * 4. Removed from exclude --> stop decommission.    */
DECL|method|refreshDatanodes ()
specifier|public
name|void
name|refreshDatanodes
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|DatanodeDescriptor
name|node
range|:
name|namesystem
operator|.
name|datanodeMap
operator|.
name|values
argument_list|()
control|)
block|{
comment|// Check if not include.
if|if
condition|(
operator|!
name|inHostsList
argument_list|(
name|node
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|node
operator|.
name|setDisallowed
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// case 2.
block|}
else|else
block|{
if|if
condition|(
name|inExcludedHostsList
argument_list|(
name|node
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|namesystem
operator|.
name|getBlockManager
argument_list|()
operator|.
name|startDecommission
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// case 3.
block|}
else|else
block|{
name|namesystem
operator|.
name|getBlockManager
argument_list|()
operator|.
name|stopDecommission
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// case 4.
block|}
block|}
block|}
block|}
comment|/** For generating datanode reports */
DECL|method|getDatanodeListForReport ( final DatanodeReportType type)
specifier|public
name|List
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|getDatanodeListForReport
parameter_list|(
specifier|final
name|DatanodeReportType
name|type
parameter_list|)
block|{
name|boolean
name|listLiveNodes
init|=
name|type
operator|==
name|DatanodeReportType
operator|.
name|ALL
operator|||
name|type
operator|==
name|DatanodeReportType
operator|.
name|LIVE
decl_stmt|;
name|boolean
name|listDeadNodes
init|=
name|type
operator|==
name|DatanodeReportType
operator|.
name|ALL
operator|||
name|type
operator|==
name|DatanodeReportType
operator|.
name|DEAD
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|mustList
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|listDeadNodes
condition|)
block|{
comment|//first load all the nodes listed in include and exclude files.
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|hostsReader
operator|.
name|getHosts
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|mustList
operator|.
name|put
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|it
operator|=
name|hostsReader
operator|.
name|getExcludedHosts
argument_list|()
operator|.
name|iterator
argument_list|()
expr_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|mustList
operator|.
name|put
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|nodes
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|namesystem
operator|.
name|datanodeMap
init|)
block|{
name|nodes
operator|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|(
name|namesystem
operator|.
name|datanodeMap
operator|.
name|size
argument_list|()
operator|+
name|mustList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|it
init|=
name|namesystem
operator|.
name|datanodeMap
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|DatanodeDescriptor
name|dn
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|boolean
name|isDead
init|=
name|namesystem
operator|.
name|isDatanodeDead
argument_list|(
name|dn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|isDead
operator|&&
name|listDeadNodes
operator|)
operator|||
operator|(
operator|!
name|isDead
operator|&&
name|listLiveNodes
operator|)
condition|)
block|{
name|nodes
operator|.
name|add
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
comment|//Remove any form of the this datanode in include/exclude lists.
try|try
block|{
name|InetAddress
name|inet
init|=
name|InetAddress
operator|.
name|getByName
argument_list|(
name|dn
operator|.
name|getHost
argument_list|()
argument_list|)
decl_stmt|;
comment|// compare hostname(:port)
name|mustList
operator|.
name|remove
argument_list|(
name|inet
operator|.
name|getHostName
argument_list|()
argument_list|)
expr_stmt|;
name|mustList
operator|.
name|remove
argument_list|(
name|inet
operator|.
name|getHostName
argument_list|()
operator|+
literal|":"
operator|+
name|dn
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
comment|// compare ipaddress(:port)
name|mustList
operator|.
name|remove
argument_list|(
name|inet
operator|.
name|getHostAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|mustList
operator|.
name|remove
argument_list|(
name|inet
operator|.
name|getHostAddress
argument_list|()
operator|.
name|toString
argument_list|()
operator|+
literal|":"
operator|+
name|dn
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownHostException
name|e
parameter_list|)
block|{
name|mustList
operator|.
name|remove
argument_list|(
name|dn
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|mustList
operator|.
name|remove
argument_list|(
name|dn
operator|.
name|getHost
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|listDeadNodes
condition|)
block|{
name|Iterator
argument_list|<
name|String
argument_list|>
name|it
init|=
name|mustList
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|DatanodeDescriptor
name|dn
init|=
operator|new
name|DatanodeDescriptor
argument_list|(
operator|new
name|DatanodeID
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|dn
operator|.
name|setLastUpdate
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|nodes
operator|.
name|add
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|nodes
return|;
block|}
block|}
end_class

end_unit

