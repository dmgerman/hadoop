begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|Checksum
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|CheckedOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsConstants
operator|.
name|NamenodeRole
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|StorageDirectory
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Util
operator|.
name|now
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorage
operator|.
name|NameNodeDirType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorageRetentionManager
operator|.
name|StoragePurger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|metrics
operator|.
name|NameNodeMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|RemoteEditLogManifest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|BytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|PureJavaCrc32
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOpCodes
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOp
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * FSEditLog maintains a log of the namespace modifications.  *   */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|FSEditLog
specifier|public
class|class
name|FSEditLog
block|{
DECL|field|NO_JOURNAL_STREAMS_WARNING
specifier|static
specifier|final
name|String
name|NO_JOURNAL_STREAMS_WARNING
init|=
literal|"!!! WARNING !!!"
operator|+
literal|" File system changes are not persistent. No journal streams."
decl_stmt|;
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FSEditLog
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * State machine for edit log.    * The log starts in UNITIALIZED state upon construction. Once it's    * initialized, it is usually in IN_SEGMENT state, indicating that edits    * may be written. In the middle of a roll, or while saving the namespace,    * it briefly enters the BETWEEN_LOG_SEGMENTS state, indicating that the    * previous segment has been closed, but the new one has not yet been opened.    */
DECL|enum|State
specifier|private
enum|enum
name|State
block|{
DECL|enumConstant|UNINITIALIZED
name|UNINITIALIZED
block|,
DECL|enumConstant|BETWEEN_LOG_SEGMENTS
name|BETWEEN_LOG_SEGMENTS
block|,
DECL|enumConstant|IN_SEGMENT
name|IN_SEGMENT
block|,
DECL|enumConstant|CLOSED
name|CLOSED
block|;   }
DECL|field|state
specifier|private
name|State
name|state
init|=
name|State
operator|.
name|UNINITIALIZED
decl_stmt|;
DECL|field|journals
specifier|private
name|List
argument_list|<
name|JournalAndStream
argument_list|>
name|journals
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
comment|// a monotonically increasing counter that represents transactionIds.
DECL|field|txid
specifier|private
name|long
name|txid
init|=
literal|0
decl_stmt|;
comment|// stores the last synced transactionId.
DECL|field|synctxid
specifier|private
name|long
name|synctxid
init|=
literal|0
decl_stmt|;
comment|// the first txid of the log that's currently open for writing.
comment|// If this value is N, we are currently writing to edits_inprogress_N
DECL|field|curSegmentTxId
specifier|private
name|long
name|curSegmentTxId
init|=
name|FSConstants
operator|.
name|INVALID_TXID
decl_stmt|;
comment|// the time of printing the statistics to the log file.
DECL|field|lastPrintTime
specifier|private
name|long
name|lastPrintTime
decl_stmt|;
comment|// is a sync currently running?
DECL|field|isSyncRunning
specifier|private
specifier|volatile
name|boolean
name|isSyncRunning
decl_stmt|;
comment|// is an automatic sync scheduled?
DECL|field|isAutoSyncScheduled
specifier|private
specifier|volatile
name|boolean
name|isAutoSyncScheduled
init|=
literal|false
decl_stmt|;
comment|// Used to exit in the event of a failure to sync to all journals. It's a
comment|// member variable so it can be swapped out for testing.
DECL|field|runtime
specifier|private
name|Runtime
name|runtime
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
decl_stmt|;
comment|// these are statistics counters.
DECL|field|numTransactions
specifier|private
name|long
name|numTransactions
decl_stmt|;
comment|// number of transactions
DECL|field|numTransactionsBatchedInSync
specifier|private
name|long
name|numTransactionsBatchedInSync
decl_stmt|;
DECL|field|totalTimeTransactions
specifier|private
name|long
name|totalTimeTransactions
decl_stmt|;
comment|// total time for all transactions
DECL|field|metrics
specifier|private
name|NameNodeMetrics
name|metrics
decl_stmt|;
DECL|field|storage
specifier|private
name|NNStorage
name|storage
decl_stmt|;
DECL|field|localChecksum
specifier|private
specifier|static
name|ThreadLocal
argument_list|<
name|Checksum
argument_list|>
name|localChecksum
init|=
operator|new
name|ThreadLocal
argument_list|<
name|Checksum
argument_list|>
argument_list|()
block|{
specifier|protected
name|Checksum
name|initialValue
parameter_list|()
block|{
return|return
operator|new
name|PureJavaCrc32
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|/** Get a thread local checksum */
DECL|method|getChecksum ()
specifier|public
specifier|static
name|Checksum
name|getChecksum
parameter_list|()
block|{
return|return
name|localChecksum
operator|.
name|get
argument_list|()
return|;
block|}
DECL|class|TransactionId
specifier|private
specifier|static
class|class
name|TransactionId
block|{
DECL|field|txid
specifier|public
name|long
name|txid
decl_stmt|;
DECL|method|TransactionId (long value)
name|TransactionId
parameter_list|(
name|long
name|value
parameter_list|)
block|{
name|this
operator|.
name|txid
operator|=
name|value
expr_stmt|;
block|}
block|}
comment|// stores the most current transactionId of this thread.
DECL|field|myTransactionId
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|TransactionId
argument_list|>
name|myTransactionId
init|=
operator|new
name|ThreadLocal
argument_list|<
name|TransactionId
argument_list|>
argument_list|()
block|{
specifier|protected
specifier|synchronized
name|TransactionId
name|initialValue
parameter_list|()
block|{
return|return
operator|new
name|TransactionId
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|method|FSEditLog (NNStorage storage)
name|FSEditLog
parameter_list|(
name|NNStorage
name|storage
parameter_list|)
block|{
name|isSyncRunning
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|storage
operator|=
name|storage
expr_stmt|;
name|metrics
operator|=
name|NameNode
operator|.
name|getNameNodeMetrics
argument_list|()
expr_stmt|;
name|lastPrintTime
operator|=
name|now
argument_list|()
expr_stmt|;
block|}
comment|/**    * Initialize the list of edit journals    */
DECL|method|initJournals ()
specifier|synchronized
name|void
name|initJournals
parameter_list|()
block|{
assert|assert
name|journals
operator|.
name|isEmpty
argument_list|()
assert|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|state
operator|==
name|State
operator|.
name|UNINITIALIZED
argument_list|,
literal|"Bad state: %s"
argument_list|,
name|state
argument_list|)
expr_stmt|;
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|storage
operator|.
name|dirIterable
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
control|)
block|{
name|journals
operator|.
name|add
argument_list|(
operator|new
name|JournalAndStream
argument_list|(
operator|new
name|FileJournalManager
argument_list|(
name|sd
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|journals
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"No edits directories configured!"
argument_list|)
expr_stmt|;
block|}
name|state
operator|=
name|State
operator|.
name|BETWEEN_LOG_SEGMENTS
expr_stmt|;
block|}
comment|/**    * Initialize the output stream for logging, opening the first    * log segment.    */
DECL|method|open ()
specifier|synchronized
name|void
name|open
parameter_list|()
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|state
operator|==
name|State
operator|.
name|UNINITIALIZED
argument_list|)
expr_stmt|;
name|initJournals
argument_list|()
expr_stmt|;
name|startLogSegment
argument_list|(
name|getLastWrittenTxId
argument_list|()
operator|+
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
assert|assert
name|state
operator|==
name|State
operator|.
name|IN_SEGMENT
operator|:
literal|"Bad state: "
operator|+
name|state
assert|;
block|}
DECL|method|isOpen ()
specifier|synchronized
name|boolean
name|isOpen
parameter_list|()
block|{
return|return
name|state
operator|==
name|State
operator|.
name|IN_SEGMENT
return|;
block|}
comment|/**    * Shutdown the file store.    */
DECL|method|close ()
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|CLOSED
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Closing log when already closed"
argument_list|,
operator|new
name|Exception
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|IN_SEGMENT
condition|)
block|{
assert|assert
operator|!
name|journals
operator|.
name|isEmpty
argument_list|()
assert|;
name|waitForSyncToFinish
argument_list|()
expr_stmt|;
name|endCurrentLogSegment
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|state
operator|=
name|State
operator|.
name|CLOSED
expr_stmt|;
block|}
comment|/**    * Write an operation to the edit log. Do not sync to persistent    * store yet.    */
DECL|method|logEdit (final FSEditLogOp op)
name|void
name|logEdit
parameter_list|(
specifier|final
name|FSEditLogOp
name|op
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
assert|assert
name|state
operator|!=
name|State
operator|.
name|CLOSED
assert|;
comment|// wait if an automatic sync is scheduled
name|waitIfAutoSyncScheduled
argument_list|()
expr_stmt|;
if|if
condition|(
name|journals
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|java
operator|.
name|lang
operator|.
name|IllegalStateException
argument_list|(
name|NO_JOURNAL_STREAMS_WARNING
argument_list|)
throw|;
block|}
name|long
name|start
init|=
name|beginTransaction
argument_list|()
decl_stmt|;
name|op
operator|.
name|setTransactionId
argument_list|(
name|txid
argument_list|)
expr_stmt|;
name|mapJournalsAndReportErrors
argument_list|(
operator|new
name|JournalClosure
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|JournalAndStream
name|jas
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|jas
operator|.
name|isActive
argument_list|()
condition|)
return|return;
name|jas
operator|.
name|stream
operator|.
name|write
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|,
literal|"logging edit"
argument_list|)
expr_stmt|;
name|endTransaction
argument_list|(
name|start
argument_list|)
expr_stmt|;
comment|// check if it is time to schedule an automatic sync
if|if
condition|(
operator|!
name|shouldForceSync
argument_list|()
condition|)
block|{
return|return;
block|}
name|isAutoSyncScheduled
operator|=
literal|true
expr_stmt|;
block|}
comment|// sync buffered edit log entries to persistent store
name|logSync
argument_list|()
expr_stmt|;
block|}
comment|/**    * Wait if an automatic sync is scheduled    * @throws InterruptedException    */
DECL|method|waitIfAutoSyncScheduled ()
specifier|synchronized
name|void
name|waitIfAutoSyncScheduled
parameter_list|()
block|{
try|try
block|{
while|while
condition|(
name|isAutoSyncScheduled
condition|)
block|{
name|this
operator|.
name|wait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{     }
block|}
comment|/**    * Signal that an automatic sync scheduling is done if it is scheduled    */
DECL|method|doneWithAutoSyncScheduling ()
specifier|synchronized
name|void
name|doneWithAutoSyncScheduling
parameter_list|()
block|{
if|if
condition|(
name|isAutoSyncScheduled
condition|)
block|{
name|isAutoSyncScheduled
operator|=
literal|false
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Check if should automatically sync buffered edits to     * persistent store    *     * @return true if any of the edit stream says that it should sync    */
DECL|method|shouldForceSync ()
specifier|private
name|boolean
name|shouldForceSync
parameter_list|()
block|{
for|for
control|(
name|JournalAndStream
name|jas
range|:
name|journals
control|)
block|{
if|if
condition|(
operator|!
name|jas
operator|.
name|isActive
argument_list|()
condition|)
continue|continue;
if|if
condition|(
name|jas
operator|.
name|getCurrentStream
argument_list|()
operator|.
name|shouldForceSync
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|beginTransaction ()
specifier|private
name|long
name|beginTransaction
parameter_list|()
block|{
assert|assert
name|Thread
operator|.
name|holdsLock
argument_list|(
name|this
argument_list|)
assert|;
comment|// get a new transactionId
name|txid
operator|++
expr_stmt|;
comment|//
comment|// record the transactionId when new data was written to the edits log
comment|//
name|TransactionId
name|id
init|=
name|myTransactionId
operator|.
name|get
argument_list|()
decl_stmt|;
name|id
operator|.
name|txid
operator|=
name|txid
expr_stmt|;
return|return
name|now
argument_list|()
return|;
block|}
DECL|method|endTransaction (long start)
specifier|private
name|void
name|endTransaction
parameter_list|(
name|long
name|start
parameter_list|)
block|{
assert|assert
name|Thread
operator|.
name|holdsLock
argument_list|(
name|this
argument_list|)
assert|;
comment|// update statistics
name|long
name|end
init|=
name|now
argument_list|()
decl_stmt|;
name|numTransactions
operator|++
expr_stmt|;
name|totalTimeTransactions
operator|+=
operator|(
name|end
operator|-
name|start
operator|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
comment|// Metrics is non-null only when used inside name node
name|metrics
operator|.
name|addTransaction
argument_list|(
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return the transaction ID of the last transaction written to the log.    */
DECL|method|getLastWrittenTxId ()
specifier|synchronized
name|long
name|getLastWrittenTxId
parameter_list|()
block|{
return|return
name|txid
return|;
block|}
comment|/**    * @return the first transaction ID in the current log segment    */
DECL|method|getCurSegmentTxId ()
specifier|synchronized
name|long
name|getCurSegmentTxId
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|state
operator|==
name|State
operator|.
name|IN_SEGMENT
argument_list|,
literal|"Bad state: %s"
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
name|curSegmentTxId
return|;
block|}
comment|/**    * Set the transaction ID to use for the next transaction written.    */
DECL|method|setNextTxId (long nextTxId)
specifier|synchronized
name|void
name|setNextTxId
parameter_list|(
name|long
name|nextTxId
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|synctxid
operator|<=
name|txid
operator|&&
name|nextTxId
operator|>=
name|txid
argument_list|,
literal|"May not decrease txid."
operator|+
literal|" synctxid=%s txid=%s nextTxId=%s"
argument_list|,
name|synctxid
argument_list|,
name|txid
argument_list|,
name|nextTxId
argument_list|)
expr_stmt|;
name|txid
operator|=
name|nextTxId
operator|-
literal|1
expr_stmt|;
block|}
comment|/**    * Blocks until all ongoing edits have been synced to disk.    * This differs from logSync in that it waits for edits that have been    * written by other threads, not just edits from the calling thread.    *    * NOTE: this should be done while holding the FSNamesystem lock, or    * else more operations can start writing while this is in progress.    */
DECL|method|logSyncAll ()
name|void
name|logSyncAll
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Record the most recent transaction ID as our own id
synchronized|synchronized
init|(
name|this
init|)
block|{
name|TransactionId
name|id
init|=
name|myTransactionId
operator|.
name|get
argument_list|()
decl_stmt|;
name|id
operator|.
name|txid
operator|=
name|txid
expr_stmt|;
block|}
comment|// Then make sure we're synced up to this point
name|logSync
argument_list|()
expr_stmt|;
block|}
comment|/**    * Sync all modifications done by this thread.    *    * The internal concurrency design of this class is as follows:    *   - Log items are written synchronized into an in-memory buffer,    *     and each assigned a transaction ID.    *   - When a thread (client) would like to sync all of its edits, logSync()    *     uses a ThreadLocal transaction ID to determine what edit number must    *     be synced to.    *   - The isSyncRunning volatile boolean tracks whether a sync is currently    *     under progress.    *    * The data is double-buffered within each edit log implementation so that    * in-memory writing can occur in parallel with the on-disk writing.    *    * Each sync occurs in three steps:    *   1. synchronized, it swaps the double buffer and sets the isSyncRunning    *      flag.    *   2. unsynchronized, it flushes the data to storage    *   3. synchronized, it resets the flag and notifies anyone waiting on the    *      sync.    *    * The lack of synchronization on step 2 allows other threads to continue    * to write into the memory buffer while the sync is in progress.    * Because this step is unsynchronized, actions that need to avoid    * concurrency with sync() should be synchronized and also call    * waitForSyncToFinish() before assuming they are running alone.    */
DECL|method|logSync ()
specifier|public
name|void
name|logSync
parameter_list|()
block|{
name|long
name|syncStart
init|=
literal|0
decl_stmt|;
comment|// Fetch the transactionId of this thread.
name|long
name|mytxid
init|=
name|myTransactionId
operator|.
name|get
argument_list|()
operator|.
name|txid
decl_stmt|;
name|List
argument_list|<
name|JournalAndStream
argument_list|>
name|candidateJournals
init|=
name|Lists
operator|.
name|newArrayListWithCapacity
argument_list|(
name|journals
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|JournalAndStream
argument_list|>
name|badJournals
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|boolean
name|sync
init|=
literal|false
decl_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
try|try
block|{
name|printStatistics
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// if somebody is already syncing, then wait
while|while
condition|(
name|mytxid
operator|>
name|synctxid
operator|&&
name|isSyncRunning
condition|)
block|{
try|try
block|{
name|wait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{            }
block|}
comment|//
comment|// If this transaction was already flushed, then nothing to do
comment|//
if|if
condition|(
name|mytxid
operator|<=
name|synctxid
condition|)
block|{
name|numTransactionsBatchedInSync
operator|++
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
comment|// Metrics is non-null only when used inside name node
name|metrics
operator|.
name|incrTransactionsBatchedInSync
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// now, this thread will do the sync
name|syncStart
operator|=
name|txid
expr_stmt|;
name|isSyncRunning
operator|=
literal|true
expr_stmt|;
name|sync
operator|=
literal|true
expr_stmt|;
comment|// swap buffers
assert|assert
operator|!
name|journals
operator|.
name|isEmpty
argument_list|()
operator|:
literal|"no editlog streams"
assert|;
for|for
control|(
name|JournalAndStream
name|jas
range|:
name|journals
control|)
block|{
if|if
condition|(
operator|!
name|jas
operator|.
name|isActive
argument_list|()
condition|)
continue|continue;
try|try
block|{
name|jas
operator|.
name|getCurrentStream
argument_list|()
operator|.
name|setReadyToFlush
argument_list|()
expr_stmt|;
name|candidateJournals
operator|.
name|add
argument_list|(
name|jas
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to get ready to flush."
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|badJournals
operator|.
name|add
argument_list|(
name|jas
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
comment|// Prevent RuntimeException from blocking other log edit write
name|doneWithAutoSyncScheduling
argument_list|()
expr_stmt|;
block|}
block|}
comment|// do the sync
name|long
name|start
init|=
name|now
argument_list|()
decl_stmt|;
for|for
control|(
name|JournalAndStream
name|jas
range|:
name|candidateJournals
control|)
block|{
if|if
condition|(
operator|!
name|jas
operator|.
name|isActive
argument_list|()
condition|)
continue|continue;
try|try
block|{
name|jas
operator|.
name|getCurrentStream
argument_list|()
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to sync edit log."
argument_list|,
name|ie
argument_list|)
expr_stmt|;
comment|//
comment|// remember the streams that encountered an error.
comment|//
name|badJournals
operator|.
name|add
argument_list|(
name|jas
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|elapsed
init|=
name|now
argument_list|()
operator|-
name|start
decl_stmt|;
name|disableAndReportErrorOnJournals
argument_list|(
name|badJournals
argument_list|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
block|{
comment|// Metrics non-null only when used inside name node
name|metrics
operator|.
name|addSync
argument_list|(
name|elapsed
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|// Prevent RuntimeException from blocking other log edit sync
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|sync
condition|)
block|{
if|if
condition|(
name|badJournals
operator|.
name|size
argument_list|()
operator|>=
name|journals
operator|.
name|size
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Could not sync any journal to persistent storage. "
operator|+
literal|"Unsynced transactions: "
operator|+
operator|(
name|txid
operator|-
name|synctxid
operator|)
argument_list|,
operator|new
name|Exception
argument_list|()
argument_list|)
expr_stmt|;
name|runtime
operator|.
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|synctxid
operator|=
name|syncStart
expr_stmt|;
name|isSyncRunning
operator|=
literal|false
expr_stmt|;
block|}
name|this
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|//
comment|// print statistics every 1 minute.
comment|//
DECL|method|printStatistics (boolean force)
specifier|private
name|void
name|printStatistics
parameter_list|(
name|boolean
name|force
parameter_list|)
block|{
name|long
name|now
init|=
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastPrintTime
operator|+
literal|60000
operator|>
name|now
operator|&&
operator|!
name|force
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|journals
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|lastPrintTime
operator|=
name|now
expr_stmt|;
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"Number of transactions: "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|numTransactions
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" Total time for transactions(ms): "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|totalTimeTransactions
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"Number of transactions batched in Syncs: "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|numTransactionsBatchedInSync
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" Number of syncs: "
argument_list|)
expr_stmt|;
for|for
control|(
name|JournalAndStream
name|jas
range|:
name|journals
control|)
block|{
if|if
condition|(
operator|!
name|jas
operator|.
name|isActive
argument_list|()
condition|)
continue|continue;
name|buf
operator|.
name|append
argument_list|(
name|jas
operator|.
name|getCurrentStream
argument_list|()
operator|.
name|getNumSync
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|" SyncTimes(ms): "
argument_list|)
expr_stmt|;
for|for
control|(
name|JournalAndStream
name|jas
range|:
name|journals
control|)
block|{
if|if
condition|(
operator|!
name|jas
operator|.
name|isActive
argument_list|()
condition|)
continue|continue;
name|EditLogOutputStream
name|eStream
init|=
name|jas
operator|.
name|getCurrentStream
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|eStream
operator|.
name|getTotalSyncTime
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add open lease record to edit log.     * Records the block locations of the last block.    */
DECL|method|logOpenFile (String path, INodeFileUnderConstruction newNode)
specifier|public
name|void
name|logOpenFile
parameter_list|(
name|String
name|path
parameter_list|,
name|INodeFileUnderConstruction
name|newNode
parameter_list|)
block|{
name|AddOp
name|op
init|=
name|AddOp
operator|.
name|getInstance
argument_list|()
operator|.
name|setPath
argument_list|(
name|path
argument_list|)
operator|.
name|setReplication
argument_list|(
name|newNode
operator|.
name|getReplication
argument_list|()
argument_list|)
operator|.
name|setModificationTime
argument_list|(
name|newNode
operator|.
name|getModificationTime
argument_list|()
argument_list|)
operator|.
name|setAccessTime
argument_list|(
name|newNode
operator|.
name|getAccessTime
argument_list|()
argument_list|)
operator|.
name|setBlockSize
argument_list|(
name|newNode
operator|.
name|getPreferredBlockSize
argument_list|()
argument_list|)
operator|.
name|setBlocks
argument_list|(
name|newNode
operator|.
name|getBlocks
argument_list|()
argument_list|)
operator|.
name|setPermissionStatus
argument_list|(
name|newNode
operator|.
name|getPermissionStatus
argument_list|()
argument_list|)
operator|.
name|setClientName
argument_list|(
name|newNode
operator|.
name|getClientName
argument_list|()
argument_list|)
operator|.
name|setClientMachine
argument_list|(
name|newNode
operator|.
name|getClientMachine
argument_list|()
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add close lease record to edit log.    */
DECL|method|logCloseFile (String path, INodeFile newNode)
specifier|public
name|void
name|logCloseFile
parameter_list|(
name|String
name|path
parameter_list|,
name|INodeFile
name|newNode
parameter_list|)
block|{
name|CloseOp
name|op
init|=
name|CloseOp
operator|.
name|getInstance
argument_list|()
operator|.
name|setPath
argument_list|(
name|path
argument_list|)
operator|.
name|setReplication
argument_list|(
name|newNode
operator|.
name|getReplication
argument_list|()
argument_list|)
operator|.
name|setModificationTime
argument_list|(
name|newNode
operator|.
name|getModificationTime
argument_list|()
argument_list|)
operator|.
name|setAccessTime
argument_list|(
name|newNode
operator|.
name|getAccessTime
argument_list|()
argument_list|)
operator|.
name|setBlockSize
argument_list|(
name|newNode
operator|.
name|getPreferredBlockSize
argument_list|()
argument_list|)
operator|.
name|setBlocks
argument_list|(
name|newNode
operator|.
name|getBlocks
argument_list|()
argument_list|)
operator|.
name|setPermissionStatus
argument_list|(
name|newNode
operator|.
name|getPermissionStatus
argument_list|()
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add create directory record to edit log    */
DECL|method|logMkDir (String path, INode newNode)
specifier|public
name|void
name|logMkDir
parameter_list|(
name|String
name|path
parameter_list|,
name|INode
name|newNode
parameter_list|)
block|{
name|MkdirOp
name|op
init|=
name|MkdirOp
operator|.
name|getInstance
argument_list|()
operator|.
name|setPath
argument_list|(
name|path
argument_list|)
operator|.
name|setTimestamp
argument_list|(
name|newNode
operator|.
name|getModificationTime
argument_list|()
argument_list|)
operator|.
name|setPermissionStatus
argument_list|(
name|newNode
operator|.
name|getPermissionStatus
argument_list|()
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add rename record to edit log    * TODO: use String parameters until just before writing to disk    */
DECL|method|logRename (String src, String dst, long timestamp)
name|void
name|logRename
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|long
name|timestamp
parameter_list|)
block|{
name|RenameOldOp
name|op
init|=
name|RenameOldOp
operator|.
name|getInstance
argument_list|()
operator|.
name|setSource
argument_list|(
name|src
argument_list|)
operator|.
name|setDestination
argument_list|(
name|dst
argument_list|)
operator|.
name|setTimestamp
argument_list|(
name|timestamp
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add rename record to edit log    */
DECL|method|logRename (String src, String dst, long timestamp, Options.Rename... options)
name|void
name|logRename
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|long
name|timestamp
parameter_list|,
name|Options
operator|.
name|Rename
modifier|...
name|options
parameter_list|)
block|{
name|RenameOp
name|op
init|=
name|RenameOp
operator|.
name|getInstance
argument_list|()
operator|.
name|setSource
argument_list|(
name|src
argument_list|)
operator|.
name|setDestination
argument_list|(
name|dst
argument_list|)
operator|.
name|setTimestamp
argument_list|(
name|timestamp
argument_list|)
operator|.
name|setOptions
argument_list|(
name|options
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add set replication record to edit log    */
DECL|method|logSetReplication (String src, short replication)
name|void
name|logSetReplication
parameter_list|(
name|String
name|src
parameter_list|,
name|short
name|replication
parameter_list|)
block|{
name|SetReplicationOp
name|op
init|=
name|SetReplicationOp
operator|.
name|getInstance
argument_list|()
operator|.
name|setPath
argument_list|(
name|src
argument_list|)
operator|.
name|setReplication
argument_list|(
name|replication
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/** Add set namespace quota record to edit log    *     * @param src the string representation of the path to a directory    * @param quota the directory size limit    */
DECL|method|logSetQuota (String src, long nsQuota, long dsQuota)
name|void
name|logSetQuota
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|nsQuota
parameter_list|,
name|long
name|dsQuota
parameter_list|)
block|{
name|SetQuotaOp
name|op
init|=
name|SetQuotaOp
operator|.
name|getInstance
argument_list|()
operator|.
name|setSource
argument_list|(
name|src
argument_list|)
operator|.
name|setNSQuota
argument_list|(
name|nsQuota
argument_list|)
operator|.
name|setDSQuota
argument_list|(
name|dsQuota
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**  Add set permissions record to edit log */
DECL|method|logSetPermissions (String src, FsPermission permissions)
name|void
name|logSetPermissions
parameter_list|(
name|String
name|src
parameter_list|,
name|FsPermission
name|permissions
parameter_list|)
block|{
name|SetPermissionsOp
name|op
init|=
name|SetPermissionsOp
operator|.
name|getInstance
argument_list|()
operator|.
name|setSource
argument_list|(
name|src
argument_list|)
operator|.
name|setPermissions
argument_list|(
name|permissions
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**  Add set owner record to edit log */
DECL|method|logSetOwner (String src, String username, String groupname)
name|void
name|logSetOwner
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|username
parameter_list|,
name|String
name|groupname
parameter_list|)
block|{
name|SetOwnerOp
name|op
init|=
name|SetOwnerOp
operator|.
name|getInstance
argument_list|()
operator|.
name|setSource
argument_list|(
name|src
argument_list|)
operator|.
name|setUser
argument_list|(
name|username
argument_list|)
operator|.
name|setGroup
argument_list|(
name|groupname
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**    * concat(trg,src..) log    */
DECL|method|logConcat (String trg, String [] srcs, long timestamp)
name|void
name|logConcat
parameter_list|(
name|String
name|trg
parameter_list|,
name|String
index|[]
name|srcs
parameter_list|,
name|long
name|timestamp
parameter_list|)
block|{
name|ConcatDeleteOp
name|op
init|=
name|ConcatDeleteOp
operator|.
name|getInstance
argument_list|()
operator|.
name|setTarget
argument_list|(
name|trg
argument_list|)
operator|.
name|setSources
argument_list|(
name|srcs
argument_list|)
operator|.
name|setTimestamp
argument_list|(
name|timestamp
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add delete file record to edit log    */
DECL|method|logDelete (String src, long timestamp)
name|void
name|logDelete
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|timestamp
parameter_list|)
block|{
name|DeleteOp
name|op
init|=
name|DeleteOp
operator|.
name|getInstance
argument_list|()
operator|.
name|setPath
argument_list|(
name|src
argument_list|)
operator|.
name|setTimestamp
argument_list|(
name|timestamp
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add generation stamp record to edit log    */
DECL|method|logGenerationStamp (long genstamp)
name|void
name|logGenerationStamp
parameter_list|(
name|long
name|genstamp
parameter_list|)
block|{
name|SetGenstampOp
name|op
init|=
name|SetGenstampOp
operator|.
name|getInstance
argument_list|()
operator|.
name|setGenerationStamp
argument_list|(
name|genstamp
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add access time record to edit log    */
DECL|method|logTimes (String src, long mtime, long atime)
name|void
name|logTimes
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|)
block|{
name|TimesOp
name|op
init|=
name|TimesOp
operator|.
name|getInstance
argument_list|()
operator|.
name|setPath
argument_list|(
name|src
argument_list|)
operator|.
name|setModificationTime
argument_list|(
name|mtime
argument_list|)
operator|.
name|setAccessTime
argument_list|(
name|atime
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add a create symlink record.    */
DECL|method|logSymlink (String path, String value, long mtime, long atime, INodeSymlink node)
name|void
name|logSymlink
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|value
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|INodeSymlink
name|node
parameter_list|)
block|{
name|SymlinkOp
name|op
init|=
name|SymlinkOp
operator|.
name|getInstance
argument_list|()
operator|.
name|setPath
argument_list|(
name|path
argument_list|)
operator|.
name|setValue
argument_list|(
name|value
argument_list|)
operator|.
name|setModificationTime
argument_list|(
name|mtime
argument_list|)
operator|.
name|setAccessTime
argument_list|(
name|atime
argument_list|)
operator|.
name|setPermissionStatus
argument_list|(
name|node
operator|.
name|getPermissionStatus
argument_list|()
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**    * log delegation token to edit log    * @param id DelegationTokenIdentifier    * @param expiryTime of the token    * @return    */
DECL|method|logGetDelegationToken (DelegationTokenIdentifier id, long expiryTime)
name|void
name|logGetDelegationToken
parameter_list|(
name|DelegationTokenIdentifier
name|id
parameter_list|,
name|long
name|expiryTime
parameter_list|)
block|{
name|GetDelegationTokenOp
name|op
init|=
name|GetDelegationTokenOp
operator|.
name|getInstance
argument_list|()
operator|.
name|setDelegationTokenIdentifier
argument_list|(
name|id
argument_list|)
operator|.
name|setExpiryTime
argument_list|(
name|expiryTime
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
DECL|method|logRenewDelegationToken (DelegationTokenIdentifier id, long expiryTime)
name|void
name|logRenewDelegationToken
parameter_list|(
name|DelegationTokenIdentifier
name|id
parameter_list|,
name|long
name|expiryTime
parameter_list|)
block|{
name|RenewDelegationTokenOp
name|op
init|=
name|RenewDelegationTokenOp
operator|.
name|getInstance
argument_list|()
operator|.
name|setDelegationTokenIdentifier
argument_list|(
name|id
argument_list|)
operator|.
name|setExpiryTime
argument_list|(
name|expiryTime
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
DECL|method|logCancelDelegationToken (DelegationTokenIdentifier id)
name|void
name|logCancelDelegationToken
parameter_list|(
name|DelegationTokenIdentifier
name|id
parameter_list|)
block|{
name|CancelDelegationTokenOp
name|op
init|=
name|CancelDelegationTokenOp
operator|.
name|getInstance
argument_list|()
operator|.
name|setDelegationTokenIdentifier
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
DECL|method|logUpdateMasterKey (DelegationKey key)
name|void
name|logUpdateMasterKey
parameter_list|(
name|DelegationKey
name|key
parameter_list|)
block|{
name|UpdateMasterKeyOp
name|op
init|=
name|UpdateMasterKeyOp
operator|.
name|getInstance
argument_list|()
operator|.
name|setDelegationKey
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
DECL|method|logReassignLease (String leaseHolder, String src, String newHolder)
name|void
name|logReassignLease
parameter_list|(
name|String
name|leaseHolder
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|newHolder
parameter_list|)
block|{
name|ReassignLeaseOp
name|op
init|=
name|ReassignLeaseOp
operator|.
name|getInstance
argument_list|()
operator|.
name|setLeaseHolder
argument_list|(
name|leaseHolder
argument_list|)
operator|.
name|setPath
argument_list|(
name|src
argument_list|)
operator|.
name|setNewHolder
argument_list|(
name|newHolder
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/**    * @return the number of active (non-failed) journals    */
DECL|method|countActiveJournals ()
specifier|private
name|int
name|countActiveJournals
parameter_list|()
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|JournalAndStream
name|jas
range|:
name|journals
control|)
block|{
if|if
condition|(
name|jas
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
comment|/**    * Used only by unit tests.    */
annotation|@
name|VisibleForTesting
DECL|method|getJournals ()
name|List
argument_list|<
name|JournalAndStream
argument_list|>
name|getJournals
parameter_list|()
block|{
return|return
name|journals
return|;
block|}
comment|/**    * Used only by unit tests.    */
annotation|@
name|VisibleForTesting
DECL|method|setRuntimeForTesting (Runtime runtime)
specifier|synchronized
name|void
name|setRuntimeForTesting
parameter_list|(
name|Runtime
name|runtime
parameter_list|)
block|{
name|this
operator|.
name|runtime
operator|=
name|runtime
expr_stmt|;
block|}
comment|/**    * Return a manifest of what finalized edit logs are available    */
DECL|method|getEditLogManifest (long sinceTxId)
specifier|public
name|RemoteEditLogManifest
name|getEditLogManifest
parameter_list|(
name|long
name|sinceTxId
parameter_list|)
throws|throws
name|IOException
block|{
name|FSImageTransactionalStorageInspector
name|inspector
init|=
operator|new
name|FSImageTransactionalStorageInspector
argument_list|()
decl_stmt|;
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|storage
operator|.
name|dirIterable
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
control|)
block|{
name|inspector
operator|.
name|inspectDirectory
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
return|return
name|inspector
operator|.
name|getEditLogManifest
argument_list|(
name|sinceTxId
argument_list|)
return|;
block|}
comment|/**    * Finalizes the current edit log and opens a new log segment.    * @return the transaction id of the BEGIN_LOG_SEGMENT transaction    * in the new log.    */
DECL|method|rollEditLog ()
specifier|synchronized
name|long
name|rollEditLog
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Rolling edit logs."
argument_list|)
expr_stmt|;
name|endCurrentLogSegment
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|long
name|nextTxId
init|=
name|getLastWrittenTxId
argument_list|()
operator|+
literal|1
decl_stmt|;
name|startLogSegment
argument_list|(
name|nextTxId
argument_list|,
literal|true
argument_list|)
expr_stmt|;
assert|assert
name|curSegmentTxId
operator|==
name|nextTxId
assert|;
return|return
name|nextTxId
return|;
block|}
comment|/**    * Start writing to the log segment with the given txid.    * Transitions from BETWEEN_LOG_SEGMENTS state to IN_LOG_SEGMENT state.     */
DECL|method|startLogSegment (final long segmentTxId, boolean writeHeaderTxn)
specifier|synchronized
name|void
name|startLogSegment
parameter_list|(
specifier|final
name|long
name|segmentTxId
parameter_list|,
name|boolean
name|writeHeaderTxn
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting log segment at "
operator|+
name|segmentTxId
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|segmentTxId
operator|>
literal|0
argument_list|,
literal|"Bad txid: %s"
argument_list|,
name|segmentTxId
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|state
operator|==
name|State
operator|.
name|BETWEEN_LOG_SEGMENTS
argument_list|,
literal|"Bad state: %s"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|segmentTxId
operator|>
name|curSegmentTxId
argument_list|,
literal|"Cannot start writing to log segment "
operator|+
name|segmentTxId
operator|+
literal|" when previous log segment started at "
operator|+
name|curSegmentTxId
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|segmentTxId
operator|==
name|txid
operator|+
literal|1
argument_list|,
literal|"Cannot start log segment at txid %s when next expected "
operator|+
literal|"txid is %s"
argument_list|,
name|segmentTxId
argument_list|,
name|txid
operator|+
literal|1
argument_list|)
expr_stmt|;
name|numTransactions
operator|=
name|totalTimeTransactions
operator|=
name|numTransactionsBatchedInSync
operator|=
literal|0
expr_stmt|;
comment|// TODO no need to link this back to storage anymore!
comment|// See HDFS-2174.
name|storage
operator|.
name|attemptRestoreRemovedStorage
argument_list|()
expr_stmt|;
name|mapJournalsAndReportErrors
argument_list|(
operator|new
name|JournalClosure
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|JournalAndStream
name|jas
parameter_list|)
throws|throws
name|IOException
block|{
name|jas
operator|.
name|startLogSegment
argument_list|(
name|segmentTxId
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|,
literal|"starting log segment "
operator|+
name|segmentTxId
argument_list|)
expr_stmt|;
if|if
condition|(
name|countActiveJournals
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to start log segment "
operator|+
name|segmentTxId
operator|+
literal|": no journals successfully started."
argument_list|)
throw|;
block|}
name|curSegmentTxId
operator|=
name|segmentTxId
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|IN_SEGMENT
expr_stmt|;
if|if
condition|(
name|writeHeaderTxn
condition|)
block|{
name|logEdit
argument_list|(
name|LogSegmentOp
operator|.
name|getInstance
argument_list|(
name|FSEditLogOpCodes
operator|.
name|OP_START_LOG_SEGMENT
argument_list|)
argument_list|)
expr_stmt|;
name|logSync
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Finalize the current log segment.    * Transitions from IN_SEGMENT state to BETWEEN_LOG_SEGMENTS state.    */
DECL|method|endCurrentLogSegment (boolean writeEndTxn)
specifier|synchronized
name|void
name|endCurrentLogSegment
parameter_list|(
name|boolean
name|writeEndTxn
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Ending log segment "
operator|+
name|curSegmentTxId
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|state
operator|==
name|State
operator|.
name|IN_SEGMENT
argument_list|,
literal|"Bad state: %s"
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|writeEndTxn
condition|)
block|{
name|logEdit
argument_list|(
name|LogSegmentOp
operator|.
name|getInstance
argument_list|(
name|FSEditLogOpCodes
operator|.
name|OP_END_LOG_SEGMENT
argument_list|)
argument_list|)
expr_stmt|;
name|logSync
argument_list|()
expr_stmt|;
block|}
name|printStatistics
argument_list|(
literal|true
argument_list|)
expr_stmt|;
specifier|final
name|long
name|lastTxId
init|=
name|getLastWrittenTxId
argument_list|()
decl_stmt|;
name|mapJournalsAndReportErrors
argument_list|(
operator|new
name|JournalClosure
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|JournalAndStream
name|jas
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|jas
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|jas
operator|.
name|close
argument_list|(
name|lastTxId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|,
literal|"ending log segment"
argument_list|)
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|BETWEEN_LOG_SEGMENTS
expr_stmt|;
block|}
comment|/**    * Abort all current logs. Called from the backup node.    */
DECL|method|abortCurrentLogSegment ()
specifier|synchronized
name|void
name|abortCurrentLogSegment
parameter_list|()
block|{
name|mapJournalsAndReportErrors
argument_list|(
operator|new
name|JournalClosure
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|JournalAndStream
name|jas
parameter_list|)
throws|throws
name|IOException
block|{
name|jas
operator|.
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|,
literal|"aborting all streams"
argument_list|)
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|BETWEEN_LOG_SEGMENTS
expr_stmt|;
block|}
comment|/**    * Archive any log files that are older than the given txid.    */
DECL|method|purgeLogsOlderThan ( final long minTxIdToKeep, final StoragePurger purger)
specifier|public
name|void
name|purgeLogsOlderThan
parameter_list|(
specifier|final
name|long
name|minTxIdToKeep
parameter_list|,
specifier|final
name|StoragePurger
name|purger
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// synchronized to prevent findbugs warning about inconsistent
comment|// synchronization. This will be JIT-ed out if asserts are
comment|// off.
assert|assert
name|curSegmentTxId
operator|==
name|FSConstants
operator|.
name|INVALID_TXID
operator|||
comment|// on format this is no-op
name|minTxIdToKeep
operator|<=
name|curSegmentTxId
operator|:
literal|"cannot purge logs older than txid "
operator|+
name|minTxIdToKeep
operator|+
literal|" when current segment starts at "
operator|+
name|curSegmentTxId
assert|;
block|}
name|mapJournalsAndReportErrors
argument_list|(
operator|new
name|JournalClosure
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|JournalAndStream
name|jas
parameter_list|)
throws|throws
name|IOException
block|{
name|jas
operator|.
name|manager
operator|.
name|purgeLogsOlderThan
argument_list|(
name|minTxIdToKeep
argument_list|,
name|purger
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|,
literal|"purging logs older than "
operator|+
name|minTxIdToKeep
argument_list|)
expr_stmt|;
block|}
comment|/**    * The actual sync activity happens while not synchronized on this object.    * Thus, synchronized activities that require that they are not concurrent    * with file operations should wait for any running sync to finish.    */
DECL|method|waitForSyncToFinish ()
specifier|synchronized
name|void
name|waitForSyncToFinish
parameter_list|()
block|{
while|while
condition|(
name|isSyncRunning
condition|)
block|{
try|try
block|{
name|wait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{}
block|}
block|}
comment|/**    * Return the txid of the last synced transaction.    * For test use only    */
DECL|method|getSyncTxId ()
specifier|synchronized
name|long
name|getSyncTxId
parameter_list|()
block|{
return|return
name|synctxid
return|;
block|}
comment|// sets the initial capacity of the flush buffer.
DECL|method|setOutputBufferCapacity (int size)
specifier|public
name|void
name|setOutputBufferCapacity
parameter_list|(
name|int
name|size
parameter_list|)
block|{
for|for
control|(
name|JournalAndStream
name|jas
range|:
name|journals
control|)
block|{
name|jas
operator|.
name|manager
operator|.
name|setOutputBufferCapacity
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Create (or find if already exists) an edit output stream, which    * streams journal records (edits) to the specified backup node.<br>    *     * The new BackupNode will start receiving edits the next time this    * NameNode's logs roll.    *     * @param bnReg the backup node registration information.    * @param nnReg this (active) name-node registration.    * @throws IOException    */
DECL|method|registerBackupNode ( NamenodeRegistration bnReg, NamenodeRegistration nnReg)
specifier|synchronized
name|void
name|registerBackupNode
parameter_list|(
name|NamenodeRegistration
name|bnReg
parameter_list|,
comment|// backup node
name|NamenodeRegistration
name|nnReg
parameter_list|)
comment|// active name-node
throws|throws
name|IOException
block|{
if|if
condition|(
name|bnReg
operator|.
name|isRole
argument_list|(
name|NamenodeRole
operator|.
name|CHECKPOINT
argument_list|)
condition|)
return|return;
comment|// checkpoint node does not stream edits
name|JournalAndStream
name|jas
init|=
name|findBackupJournalAndStream
argument_list|(
name|bnReg
argument_list|)
decl_stmt|;
if|if
condition|(
name|jas
operator|!=
literal|null
condition|)
block|{
comment|// already registered
name|LOG
operator|.
name|info
argument_list|(
literal|"Backup node "
operator|+
name|bnReg
operator|+
literal|" re-registers"
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Registering new backup node: "
operator|+
name|bnReg
argument_list|)
expr_stmt|;
name|BackupJournalManager
name|bjm
init|=
operator|new
name|BackupJournalManager
argument_list|(
name|bnReg
argument_list|,
name|nnReg
argument_list|)
decl_stmt|;
name|journals
operator|.
name|add
argument_list|(
operator|new
name|JournalAndStream
argument_list|(
name|bjm
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|releaseBackupStream (NamenodeRegistration registration)
specifier|synchronized
name|void
name|releaseBackupStream
parameter_list|(
name|NamenodeRegistration
name|registration
parameter_list|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|JournalAndStream
argument_list|>
name|iter
init|=
name|journals
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|JournalAndStream
name|jas
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|jas
operator|.
name|manager
operator|instanceof
name|BackupJournalManager
operator|&&
operator|(
operator|(
name|BackupJournalManager
operator|)
name|jas
operator|.
name|manager
operator|)
operator|.
name|matchesRegistration
argument_list|(
name|registration
argument_list|)
condition|)
block|{
name|jas
operator|.
name|abort
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Removing backup journal "
operator|+
name|jas
argument_list|)
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Find the JournalAndStream associated with this BackupNode.    * @return null if it cannot be found    */
DECL|method|findBackupJournalAndStream ( NamenodeRegistration bnReg)
specifier|private
specifier|synchronized
name|JournalAndStream
name|findBackupJournalAndStream
parameter_list|(
name|NamenodeRegistration
name|bnReg
parameter_list|)
block|{
for|for
control|(
name|JournalAndStream
name|jas
range|:
name|journals
control|)
block|{
if|if
condition|(
name|jas
operator|.
name|manager
operator|instanceof
name|BackupJournalManager
condition|)
block|{
name|BackupJournalManager
name|bjm
init|=
operator|(
name|BackupJournalManager
operator|)
name|jas
operator|.
name|manager
decl_stmt|;
if|if
condition|(
name|bjm
operator|.
name|matchesRegistration
argument_list|(
name|bnReg
argument_list|)
condition|)
block|{
return|return
name|jas
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Write an operation to the edit log. Do not sync to persistent    * store yet.    */
DECL|method|logEdit (final int length, final byte[] data)
specifier|synchronized
name|void
name|logEdit
parameter_list|(
specifier|final
name|int
name|length
parameter_list|,
specifier|final
name|byte
index|[]
name|data
parameter_list|)
block|{
name|long
name|start
init|=
name|beginTransaction
argument_list|()
decl_stmt|;
name|mapJournalsAndReportErrors
argument_list|(
operator|new
name|JournalClosure
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|apply
parameter_list|(
name|JournalAndStream
name|jas
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|jas
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|jas
operator|.
name|getCurrentStream
argument_list|()
operator|.
name|writeRaw
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|// TODO writeRaw
block|}
block|}
block|}
argument_list|,
literal|"Logging edit"
argument_list|)
expr_stmt|;
name|endTransaction
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
comment|//// Iteration across journals
DECL|interface|JournalClosure
specifier|private
interface|interface
name|JournalClosure
block|{
DECL|method|apply (JournalAndStream jas)
specifier|public
name|void
name|apply
parameter_list|(
name|JournalAndStream
name|jas
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
comment|/**    * Apply the given function across all of the journal managers, disabling    * any for which the closure throws an IOException.    * @param status message used for logging errors (e.g. "opening journal")    */
DECL|method|mapJournalsAndReportErrors ( JournalClosure closure, String status)
specifier|private
name|void
name|mapJournalsAndReportErrors
parameter_list|(
name|JournalClosure
name|closure
parameter_list|,
name|String
name|status
parameter_list|)
block|{
name|List
argument_list|<
name|JournalAndStream
argument_list|>
name|badJAS
init|=
name|Lists
operator|.
name|newLinkedList
argument_list|()
decl_stmt|;
for|for
control|(
name|JournalAndStream
name|jas
range|:
name|journals
control|)
block|{
try|try
block|{
name|closure
operator|.
name|apply
argument_list|(
name|jas
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error "
operator|+
name|status
operator|+
literal|" (journal "
operator|+
name|jas
operator|+
literal|")"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|badJAS
operator|.
name|add
argument_list|(
name|jas
argument_list|)
expr_stmt|;
block|}
block|}
name|disableAndReportErrorOnJournals
argument_list|(
name|badJAS
argument_list|)
expr_stmt|;
block|}
comment|/**    * Called when some journals experience an error in some operation.    * This propagates errors to the storage level.    */
DECL|method|disableAndReportErrorOnJournals (List<JournalAndStream> badJournals)
specifier|private
name|void
name|disableAndReportErrorOnJournals
parameter_list|(
name|List
argument_list|<
name|JournalAndStream
argument_list|>
name|badJournals
parameter_list|)
block|{
if|if
condition|(
name|badJournals
operator|==
literal|null
operator|||
name|badJournals
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
comment|// nothing to do
block|}
for|for
control|(
name|JournalAndStream
name|j
range|:
name|badJournals
control|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Disabling journal "
operator|+
name|j
argument_list|)
expr_stmt|;
name|j
operator|.
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Container for a JournalManager paired with its currently    * active stream.    *     * If a Journal gets disabled due to an error writing to its    * stream, then the stream will be aborted and set to null.    */
DECL|class|JournalAndStream
specifier|static
class|class
name|JournalAndStream
block|{
DECL|field|manager
specifier|private
specifier|final
name|JournalManager
name|manager
decl_stmt|;
DECL|field|stream
specifier|private
name|EditLogOutputStream
name|stream
decl_stmt|;
DECL|field|segmentStartsAtTxId
specifier|private
name|long
name|segmentStartsAtTxId
init|=
name|FSConstants
operator|.
name|INVALID_TXID
decl_stmt|;
DECL|method|JournalAndStream (JournalManager manager)
specifier|private
name|JournalAndStream
parameter_list|(
name|JournalManager
name|manager
parameter_list|)
block|{
name|this
operator|.
name|manager
operator|=
name|manager
expr_stmt|;
block|}
DECL|method|startLogSegment (long txId)
specifier|private
name|void
name|startLogSegment
parameter_list|(
name|long
name|txId
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|stream
operator|==
literal|null
argument_list|)
expr_stmt|;
name|stream
operator|=
name|manager
operator|.
name|startLogSegment
argument_list|(
name|txId
argument_list|)
expr_stmt|;
name|segmentStartsAtTxId
operator|=
name|txId
expr_stmt|;
block|}
DECL|method|close (long lastTxId)
specifier|private
name|void
name|close
parameter_list|(
name|long
name|lastTxId
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|lastTxId
operator|>=
name|segmentStartsAtTxId
argument_list|,
literal|"invalid segment: lastTxId %s>= "
operator|+
literal|"segment starting txid %s"
argument_list|,
name|lastTxId
argument_list|,
name|segmentStartsAtTxId
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|==
literal|null
condition|)
return|return;
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
name|manager
operator|.
name|finalizeLogSegment
argument_list|(
name|segmentStartsAtTxId
argument_list|,
name|lastTxId
argument_list|)
expr_stmt|;
name|stream
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|abort ()
specifier|private
name|void
name|abort
parameter_list|()
block|{
if|if
condition|(
name|stream
operator|==
literal|null
condition|)
return|return;
try|try
block|{
name|stream
operator|.
name|abort
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to abort stream "
operator|+
name|stream
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
name|stream
operator|=
literal|null
expr_stmt|;
name|segmentStartsAtTxId
operator|=
name|FSConstants
operator|.
name|INVALID_TXID
expr_stmt|;
block|}
DECL|method|isActive ()
specifier|private
name|boolean
name|isActive
parameter_list|()
block|{
return|return
name|stream
operator|!=
literal|null
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getCurrentStream ()
name|EditLogOutputStream
name|getCurrentStream
parameter_list|()
block|{
return|return
name|stream
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"JournalAndStream(mgr="
operator|+
name|manager
operator|+
literal|", "
operator|+
literal|"stream="
operator|+
name|stream
operator|+
literal|")"
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|setCurrentStreamForTests (EditLogOutputStream stream)
name|void
name|setCurrentStreamForTests
parameter_list|(
name|EditLogOutputStream
name|stream
parameter_list|)
block|{
name|this
operator|.
name|stream
operator|=
name|stream
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getManager ()
name|JournalManager
name|getManager
parameter_list|()
block|{
return|return
name|manager
return|;
block|}
DECL|method|getInProgressInputStream ()
specifier|private
name|EditLogInputStream
name|getInProgressInputStream
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|manager
operator|.
name|getInProgressInputStream
argument_list|(
name|segmentStartsAtTxId
argument_list|)
return|;
block|}
block|}
comment|/**    * @return an EditLogInputStream that reads from the same log that    * the edit log is currently writing. This is used from the BackupNode    * during edits synchronization.    * @throws IOException if no valid logs are available.    */
DECL|method|getInProgressFileInputStream ()
specifier|synchronized
name|EditLogInputStream
name|getInProgressFileInputStream
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|JournalAndStream
name|jas
range|:
name|journals
control|)
block|{
if|if
condition|(
operator|!
name|jas
operator|.
name|isActive
argument_list|()
condition|)
continue|continue;
try|try
block|{
name|EditLogInputStream
name|in
init|=
name|jas
operator|.
name|getInProgressInputStream
argument_list|()
decl_stmt|;
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
return|return
name|in
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to get the in-progress input stream from "
operator|+
name|jas
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"No in-progress stream provided edits"
argument_list|)
throw|;
block|}
block|}
end_class

end_unit

