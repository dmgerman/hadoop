begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|Checksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DeprecatedUTF8
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|Block
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsConstants
operator|.
name|NamenodeRole
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|StorageDirectory
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Util
operator|.
name|now
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorage
operator|.
name|NameNodeDirType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorage
operator|.
name|NameNodeFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorage
operator|.
name|NNStorageListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|JournalStream
operator|.
name|JournalType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|metrics
operator|.
name|NameNodeMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeRegistration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|ArrayWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|BytesWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|DelegationKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|PureJavaCrc32
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSEditLogOpCodes
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * FSEditLog maintains a log of the namespace modifications.  *   */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|FSEditLog
specifier|public
class|class
name|FSEditLog
implements|implements
name|NNStorageListener
block|{
DECL|field|NO_JOURNAL_STREAMS_WARNING
specifier|static
specifier|final
name|String
name|NO_JOURNAL_STREAMS_WARNING
init|=
literal|"!!! WARNING !!!"
operator|+
literal|" File system changes are not persistent. No journal streams."
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FSEditLog
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|sizeOutputFlushBuffer
specifier|private
specifier|volatile
name|int
name|sizeOutputFlushBuffer
init|=
literal|512
operator|*
literal|1024
decl_stmt|;
DECL|field|editStreams
specifier|private
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
name|editStreams
init|=
literal|null
decl_stmt|;
comment|// a monotonically increasing counter that represents transactionIds.
DECL|field|txid
specifier|private
name|long
name|txid
init|=
literal|0
decl_stmt|;
comment|// stores the last synced transactionId.
DECL|field|synctxid
specifier|private
name|long
name|synctxid
init|=
literal|0
decl_stmt|;
comment|// the time of printing the statistics to the log file.
DECL|field|lastPrintTime
specifier|private
name|long
name|lastPrintTime
decl_stmt|;
comment|// is a sync currently running?
DECL|field|isSyncRunning
specifier|private
specifier|volatile
name|boolean
name|isSyncRunning
decl_stmt|;
comment|// is an automatic sync scheduled?
DECL|field|isAutoSyncScheduled
specifier|private
specifier|volatile
name|boolean
name|isAutoSyncScheduled
init|=
literal|false
decl_stmt|;
comment|// these are statistics counters.
DECL|field|numTransactions
specifier|private
name|long
name|numTransactions
decl_stmt|;
comment|// number of transactions
DECL|field|numTransactionsBatchedInSync
specifier|private
name|long
name|numTransactionsBatchedInSync
decl_stmt|;
DECL|field|totalTimeTransactions
specifier|private
name|long
name|totalTimeTransactions
decl_stmt|;
comment|// total time for all transactions
DECL|field|metrics
specifier|private
name|NameNodeMetrics
name|metrics
decl_stmt|;
DECL|field|storage
specifier|private
name|NNStorage
name|storage
decl_stmt|;
DECL|field|localChecksum
specifier|private
specifier|static
name|ThreadLocal
argument_list|<
name|Checksum
argument_list|>
name|localChecksum
init|=
operator|new
name|ThreadLocal
argument_list|<
name|Checksum
argument_list|>
argument_list|()
block|{
specifier|protected
name|Checksum
name|initialValue
parameter_list|()
block|{
return|return
operator|new
name|PureJavaCrc32
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|/** Get a thread local checksum */
DECL|method|getChecksum ()
specifier|public
specifier|static
name|Checksum
name|getChecksum
parameter_list|()
block|{
return|return
name|localChecksum
operator|.
name|get
argument_list|()
return|;
block|}
DECL|class|TransactionId
specifier|private
specifier|static
class|class
name|TransactionId
block|{
DECL|field|txid
specifier|public
name|long
name|txid
decl_stmt|;
DECL|method|TransactionId (long value)
name|TransactionId
parameter_list|(
name|long
name|value
parameter_list|)
block|{
name|this
operator|.
name|txid
operator|=
name|value
expr_stmt|;
block|}
block|}
comment|// stores the most current transactionId of this thread.
DECL|field|myTransactionId
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|TransactionId
argument_list|>
name|myTransactionId
init|=
operator|new
name|ThreadLocal
argument_list|<
name|TransactionId
argument_list|>
argument_list|()
block|{
specifier|protected
specifier|synchronized
name|TransactionId
name|initialValue
parameter_list|()
block|{
return|return
operator|new
name|TransactionId
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|method|FSEditLog (NNStorage storage)
name|FSEditLog
parameter_list|(
name|NNStorage
name|storage
parameter_list|)
block|{
name|isSyncRunning
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|storage
operator|=
name|storage
expr_stmt|;
name|this
operator|.
name|storage
operator|.
name|registerListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|metrics
operator|=
name|NameNode
operator|.
name|getNameNodeMetrics
argument_list|()
expr_stmt|;
name|lastPrintTime
operator|=
name|now
argument_list|()
expr_stmt|;
block|}
DECL|method|getEditFile (StorageDirectory sd)
specifier|private
name|File
name|getEditFile
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
block|{
return|return
name|storage
operator|.
name|getEditFile
argument_list|(
name|sd
argument_list|)
return|;
block|}
DECL|method|getEditNewFile (StorageDirectory sd)
specifier|private
name|File
name|getEditNewFile
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
block|{
return|return
name|storage
operator|.
name|getEditNewFile
argument_list|(
name|sd
argument_list|)
return|;
block|}
DECL|method|getNumEditsDirs ()
specifier|private
name|int
name|getNumEditsDirs
parameter_list|()
block|{
return|return
name|storage
operator|.
name|getNumStorageDirs
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
return|;
block|}
DECL|method|getNumEditStreams ()
specifier|synchronized
name|int
name|getNumEditStreams
parameter_list|()
block|{
return|return
name|editStreams
operator|==
literal|null
condition|?
literal|0
else|:
name|editStreams
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Return the currently active edit streams.    * This should be used only by unit tests.    */
DECL|method|getEditStreams ()
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
name|getEditStreams
parameter_list|()
block|{
return|return
name|editStreams
return|;
block|}
DECL|method|isOpen ()
name|boolean
name|isOpen
parameter_list|()
block|{
return|return
name|getNumEditStreams
argument_list|()
operator|>
literal|0
return|;
block|}
comment|/**    * Create empty edit log files.    * Initialize the output stream for logging.    *     * @throws IOException    */
DECL|method|open ()
specifier|synchronized
name|void
name|open
parameter_list|()
throws|throws
name|IOException
block|{
name|numTransactions
operator|=
name|totalTimeTransactions
operator|=
name|numTransactionsBatchedInSync
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|editStreams
operator|==
literal|null
condition|)
name|editStreams
operator|=
operator|new
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
argument_list|()
expr_stmt|;
name|ArrayList
argument_list|<
name|StorageDirectory
argument_list|>
name|al
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|File
name|eFile
init|=
name|getEditFile
argument_list|(
name|sd
argument_list|)
decl_stmt|;
try|try
block|{
name|addNewEditLogStream
argument_list|(
name|eFile
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to open edit log file "
operator|+
name|eFile
argument_list|)
expr_stmt|;
comment|// Remove the directory from list of storage directories
if|if
condition|(
name|al
operator|==
literal|null
condition|)
name|al
operator|=
operator|new
name|ArrayList
argument_list|<
name|StorageDirectory
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|al
operator|.
name|add
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|al
operator|!=
literal|null
condition|)
name|storage
operator|.
name|reportErrorsOnDirectories
argument_list|(
name|al
argument_list|)
expr_stmt|;
comment|// If there was an error in every storage dir, each one will have
comment|// been removed from the list of storage directories.
if|if
condition|(
name|storage
operator|.
name|getNumStorageDirs
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to initialize edits log in any storage directory."
argument_list|)
throw|;
block|}
block|}
DECL|method|addNewEditLogStream (File eFile)
specifier|synchronized
name|void
name|addNewEditLogStream
parameter_list|(
name|File
name|eFile
parameter_list|)
throws|throws
name|IOException
block|{
name|EditLogOutputStream
name|eStream
init|=
operator|new
name|EditLogFileOutputStream
argument_list|(
name|eFile
argument_list|,
name|sizeOutputFlushBuffer
argument_list|)
decl_stmt|;
name|editStreams
operator|.
name|add
argument_list|(
name|eStream
argument_list|)
expr_stmt|;
block|}
DECL|method|createEditLogFile (File name)
specifier|synchronized
name|void
name|createEditLogFile
parameter_list|(
name|File
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|waitForSyncToFinish
argument_list|()
expr_stmt|;
name|EditLogOutputStream
name|eStream
init|=
operator|new
name|EditLogFileOutputStream
argument_list|(
name|name
argument_list|,
name|sizeOutputFlushBuffer
argument_list|)
decl_stmt|;
name|eStream
operator|.
name|create
argument_list|()
expr_stmt|;
name|eStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Shutdown the file store.    */
DECL|method|close ()
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
name|waitForSyncToFinish
argument_list|()
expr_stmt|;
if|if
condition|(
name|editStreams
operator|==
literal|null
operator|||
name|editStreams
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
name|printStatistics
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|numTransactions
operator|=
name|totalTimeTransactions
operator|=
name|numTransactionsBatchedInSync
operator|=
literal|0
expr_stmt|;
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
name|errorStreams
init|=
literal|null
decl_stmt|;
name|Iterator
argument_list|<
name|EditLogOutputStream
argument_list|>
name|it
init|=
name|getOutputStreamIterator
argument_list|(
literal|null
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|EditLogOutputStream
name|eStream
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|closeStream
argument_list|(
name|eStream
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"FSEditLog:close - failed to close stream "
operator|+
name|eStream
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorStreams
operator|==
literal|null
condition|)
name|errorStreams
operator|=
operator|new
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|errorStreams
operator|.
name|add
argument_list|(
name|eStream
argument_list|)
expr_stmt|;
block|}
block|}
name|disableAndReportErrorOnStreams
argument_list|(
name|errorStreams
argument_list|)
expr_stmt|;
name|editStreams
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|/**    * Close and remove edit log stream.    * @param index of the stream    */
DECL|method|removeStream (int index)
specifier|synchronized
specifier|private
name|void
name|removeStream
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|EditLogOutputStream
name|eStream
init|=
name|editStreams
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
try|try
block|{
name|eStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{}
name|editStreams
operator|.
name|remove
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
comment|/**    * The specified streams have IO errors. Close and remove them.    */
specifier|synchronized
DECL|method|disableAndReportErrorOnStreams (List<EditLogOutputStream> errorStreams)
name|void
name|disableAndReportErrorOnStreams
parameter_list|(
name|List
argument_list|<
name|EditLogOutputStream
argument_list|>
name|errorStreams
parameter_list|)
block|{
if|if
condition|(
name|errorStreams
operator|==
literal|null
operator|||
name|errorStreams
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return;
comment|// nothing to do
block|}
name|ArrayList
argument_list|<
name|StorageDirectory
argument_list|>
name|errorDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|StorageDirectory
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|EditLogOutputStream
name|e
range|:
name|errorStreams
control|)
block|{
if|if
condition|(
name|e
operator|.
name|getType
argument_list|()
operator|==
name|JournalType
operator|.
name|FILE
condition|)
block|{
name|errorDirs
operator|.
name|add
argument_list|(
name|getStorageDirectoryForStream
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|disableStream
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
try|try
block|{
name|storage
operator|.
name|reportErrorsOnDirectories
argument_list|(
name|errorDirs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Problem erroring streams "
operator|+
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * get an editStream corresponding to a sd    * @param es - stream to remove    * @return the matching stream    */
DECL|method|getStorage (EditLogOutputStream es)
name|StorageDirectory
name|getStorage
parameter_list|(
name|EditLogOutputStream
name|es
parameter_list|)
block|{
name|String
name|parentStorageDir
init|=
operator|(
operator|(
name|EditLogFileOutputStream
operator|)
name|es
operator|)
operator|.
name|getFile
argument_list|()
operator|.
name|getParentFile
argument_list|()
operator|.
name|getParentFile
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"comparing: "
operator|+
name|parentStorageDir
operator|+
literal|" and "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|parentStorageDir
operator|.
name|equals
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
condition|)
return|return
name|sd
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * get an editStream corresponding to a sd    * @param sd    * @return the matching stream    */
DECL|method|getEditsStream (StorageDirectory sd)
specifier|synchronized
name|EditLogOutputStream
name|getEditsStream
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
block|{
for|for
control|(
name|EditLogOutputStream
name|es
range|:
name|editStreams
control|)
block|{
name|File
name|parentStorageDir
init|=
operator|(
operator|(
name|EditLogFileOutputStream
operator|)
name|es
operator|)
operator|.
name|getFile
argument_list|()
operator|.
name|getParentFile
argument_list|()
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentStorageDir
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
return|return
name|es
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * check if edits.new log exists in the specified stoorage directory    */
DECL|method|existsNew (StorageDirectory sd)
name|boolean
name|existsNew
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
block|{
return|return
name|getEditNewFile
argument_list|(
name|sd
argument_list|)
operator|.
name|exists
argument_list|()
return|;
block|}
comment|/**    * Write an operation to the edit log. Do not sync to persistent    * store yet.    */
DECL|method|logEdit (FSEditLogOpCodes opCode, Writable ... writables)
name|void
name|logEdit
parameter_list|(
name|FSEditLogOpCodes
name|opCode
parameter_list|,
name|Writable
modifier|...
name|writables
parameter_list|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// wait if an automatic sync is scheduled
name|waitIfAutoSyncScheduled
argument_list|()
expr_stmt|;
if|if
condition|(
name|getNumEditStreams
argument_list|()
operator|==
literal|0
condition|)
throw|throw
operator|new
name|java
operator|.
name|lang
operator|.
name|IllegalStateException
argument_list|(
name|NO_JOURNAL_STREAMS_WARNING
argument_list|)
throw|;
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
name|errorStreams
init|=
literal|null
decl_stmt|;
name|long
name|start
init|=
name|now
argument_list|()
decl_stmt|;
for|for
control|(
name|EditLogOutputStream
name|eStream
range|:
name|editStreams
control|)
block|{
if|if
condition|(
operator|!
name|eStream
operator|.
name|isOperationSupported
argument_list|(
name|opCode
operator|.
name|getOpCode
argument_list|()
argument_list|)
condition|)
continue|continue;
try|try
block|{
name|eStream
operator|.
name|write
argument_list|(
name|opCode
operator|.
name|getOpCode
argument_list|()
argument_list|,
name|writables
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"logEdit: removing "
operator|+
name|eStream
operator|.
name|getName
argument_list|()
argument_list|,
name|ie
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorStreams
operator|==
literal|null
condition|)
name|errorStreams
operator|=
operator|new
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|errorStreams
operator|.
name|add
argument_list|(
name|eStream
argument_list|)
expr_stmt|;
block|}
block|}
name|disableAndReportErrorOnStreams
argument_list|(
name|errorStreams
argument_list|)
expr_stmt|;
name|recordTransaction
argument_list|(
name|start
argument_list|)
expr_stmt|;
comment|// check if it is time to schedule an automatic sync
if|if
condition|(
operator|!
name|shouldForceSync
argument_list|()
condition|)
block|{
return|return;
block|}
name|isAutoSyncScheduled
operator|=
literal|true
expr_stmt|;
block|}
comment|// sync buffered edit log entries to persistent store
name|logSync
argument_list|()
expr_stmt|;
block|}
comment|/**    * Wait if an automatic sync is scheduled    * @throws InterruptedException    */
DECL|method|waitIfAutoSyncScheduled ()
specifier|synchronized
name|void
name|waitIfAutoSyncScheduled
parameter_list|()
block|{
try|try
block|{
while|while
condition|(
name|isAutoSyncScheduled
condition|)
block|{
name|this
operator|.
name|wait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{     }
block|}
comment|/**    * Signal that an automatic sync scheduling is done if it is scheduled    */
DECL|method|doneWithAutoSyncScheduling ()
specifier|synchronized
name|void
name|doneWithAutoSyncScheduling
parameter_list|()
block|{
if|if
condition|(
name|isAutoSyncScheduled
condition|)
block|{
name|isAutoSyncScheduled
operator|=
literal|false
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Check if should automatically sync buffered edits to     * persistent store    *     * @return true if any of the edit stream says that it should sync    */
DECL|method|shouldForceSync ()
specifier|private
name|boolean
name|shouldForceSync
parameter_list|()
block|{
for|for
control|(
name|EditLogOutputStream
name|eStream
range|:
name|editStreams
control|)
block|{
if|if
condition|(
name|eStream
operator|.
name|shouldForceSync
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|recordTransaction (long start)
specifier|private
name|void
name|recordTransaction
parameter_list|(
name|long
name|start
parameter_list|)
block|{
comment|// get a new transactionId
name|txid
operator|++
expr_stmt|;
comment|//
comment|// record the transactionId when new data was written to the edits log
comment|//
name|TransactionId
name|id
init|=
name|myTransactionId
operator|.
name|get
argument_list|()
decl_stmt|;
name|id
operator|.
name|txid
operator|=
name|txid
expr_stmt|;
comment|// update statistics
name|long
name|end
init|=
name|now
argument_list|()
decl_stmt|;
name|numTransactions
operator|++
expr_stmt|;
name|totalTimeTransactions
operator|+=
operator|(
name|end
operator|-
name|start
operator|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
comment|// Metrics is non-null only when used inside name node
name|metrics
operator|.
name|addTransaction
argument_list|(
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
comment|/**    * Blocks until all ongoing edits have been synced to disk.    * This differs from logSync in that it waits for edits that have been    * written by other threads, not just edits from the calling thread.    *    * NOTE: this should be done while holding the FSNamesystem lock, or    * else more operations can start writing while this is in progress.    */
DECL|method|logSyncAll ()
name|void
name|logSyncAll
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Record the most recent transaction ID as our own id
synchronized|synchronized
init|(
name|this
init|)
block|{
name|TransactionId
name|id
init|=
name|myTransactionId
operator|.
name|get
argument_list|()
decl_stmt|;
name|id
operator|.
name|txid
operator|=
name|txid
expr_stmt|;
block|}
comment|// Then make sure we're synced up to this point
name|logSync
argument_list|()
expr_stmt|;
block|}
comment|/**    * Sync all modifications done by this thread.    *    * The internal concurrency design of this class is as follows:    *   - Log items are written synchronized into an in-memory buffer,    *     and each assigned a transaction ID.    *   - When a thread (client) would like to sync all of its edits, logSync()    *     uses a ThreadLocal transaction ID to determine what edit number must    *     be synced to.    *   - The isSyncRunning volatile boolean tracks whether a sync is currently    *     under progress.    *    * The data is double-buffered within each edit log implementation so that    * in-memory writing can occur in parallel with the on-disk writing.    *    * Each sync occurs in three steps:    *   1. synchronized, it swaps the double buffer and sets the isSyncRunning    *      flag.    *   2. unsynchronized, it flushes the data to storage    *   3. synchronized, it resets the flag and notifies anyone waiting on the    *      sync.    *    * The lack of synchronization on step 2 allows other threads to continue    * to write into the memory buffer while the sync is in progress.    * Because this step is unsynchronized, actions that need to avoid    * concurrency with sync() should be synchronized and also call    * waitForSyncToFinish() before assuming they are running alone.    */
DECL|method|logSync ()
specifier|public
name|void
name|logSync
parameter_list|()
block|{
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
name|errorStreams
init|=
literal|null
decl_stmt|;
name|long
name|syncStart
init|=
literal|0
decl_stmt|;
comment|// Fetch the transactionId of this thread.
name|long
name|mytxid
init|=
name|myTransactionId
operator|.
name|get
argument_list|()
operator|.
name|txid
decl_stmt|;
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
name|streams
init|=
operator|new
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
argument_list|()
decl_stmt|;
name|boolean
name|sync
init|=
literal|false
decl_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
try|try
block|{
name|printStatistics
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// if somebody is already syncing, then wait
while|while
condition|(
name|mytxid
operator|>
name|synctxid
operator|&&
name|isSyncRunning
condition|)
block|{
try|try
block|{
name|wait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{            }
block|}
comment|//
comment|// If this transaction was already flushed, then nothing to do
comment|//
if|if
condition|(
name|mytxid
operator|<=
name|synctxid
condition|)
block|{
name|numTransactionsBatchedInSync
operator|++
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
comment|// Metrics is non-null only when used inside name node
name|metrics
operator|.
name|incrTransactionsBatchedInSync
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// now, this thread will do the sync
name|syncStart
operator|=
name|txid
expr_stmt|;
name|isSyncRunning
operator|=
literal|true
expr_stmt|;
name|sync
operator|=
literal|true
expr_stmt|;
comment|// swap buffers
assert|assert
name|editStreams
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|:
literal|"no editlog streams"
assert|;
for|for
control|(
name|EditLogOutputStream
name|eStream
range|:
name|editStreams
control|)
block|{
try|try
block|{
name|eStream
operator|.
name|setReadyToFlush
argument_list|()
expr_stmt|;
name|streams
operator|.
name|add
argument_list|(
name|eStream
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to get ready to flush."
argument_list|,
name|ie
argument_list|)
expr_stmt|;
comment|//
comment|// remember the streams that encountered an error.
comment|//
if|if
condition|(
name|errorStreams
operator|==
literal|null
condition|)
block|{
name|errorStreams
operator|=
operator|new
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|errorStreams
operator|.
name|add
argument_list|(
name|eStream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
comment|// Prevent RuntimeException from blocking other log edit write
name|doneWithAutoSyncScheduling
argument_list|()
expr_stmt|;
block|}
block|}
comment|// do the sync
name|long
name|start
init|=
name|now
argument_list|()
decl_stmt|;
for|for
control|(
name|EditLogOutputStream
name|eStream
range|:
name|streams
control|)
block|{
try|try
block|{
name|eStream
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to sync edit log."
argument_list|,
name|ie
argument_list|)
expr_stmt|;
comment|//
comment|// remember the streams that encountered an error.
comment|//
if|if
condition|(
name|errorStreams
operator|==
literal|null
condition|)
block|{
name|errorStreams
operator|=
operator|new
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|errorStreams
operator|.
name|add
argument_list|(
name|eStream
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|elapsed
init|=
name|now
argument_list|()
operator|-
name|start
decl_stmt|;
name|disableAndReportErrorOnStreams
argument_list|(
name|errorStreams
argument_list|)
expr_stmt|;
if|if
condition|(
name|metrics
operator|!=
literal|null
condition|)
comment|// Metrics non-null only when used inside name node
name|metrics
operator|.
name|addSync
argument_list|(
name|elapsed
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// Prevent RuntimeException from blocking other log edit sync
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|sync
condition|)
block|{
name|synctxid
operator|=
name|syncStart
expr_stmt|;
name|isSyncRunning
operator|=
literal|false
expr_stmt|;
block|}
name|this
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|//
comment|// print statistics every 1 minute.
comment|//
DECL|method|printStatistics (boolean force)
specifier|private
name|void
name|printStatistics
parameter_list|(
name|boolean
name|force
parameter_list|)
block|{
name|long
name|now
init|=
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastPrintTime
operator|+
literal|60000
operator|>
name|now
operator|&&
operator|!
name|force
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|editStreams
operator|==
literal|null
operator|||
name|editStreams
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|lastPrintTime
operator|=
name|now
expr_stmt|;
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"Number of transactions: "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|numTransactions
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" Total time for transactions(ms): "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|totalTimeTransactions
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"Number of transactions batched in Syncs: "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|numTransactionsBatchedInSync
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" Number of syncs: "
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|editStreams
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getNumSync
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" SyncTimes(ms): "
argument_list|)
expr_stmt|;
name|int
name|numEditStreams
init|=
name|editStreams
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|numEditStreams
condition|;
name|idx
operator|++
control|)
block|{
name|EditLogOutputStream
name|eStream
init|=
name|editStreams
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
name|eStream
operator|.
name|getTotalSyncTime
argument_list|()
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add open lease record to edit log.     * Records the block locations of the last block.    */
DECL|method|logOpenFile (String path, INodeFileUnderConstruction newNode)
specifier|public
name|void
name|logOpenFile
parameter_list|(
name|String
name|path
parameter_list|,
name|INodeFileUnderConstruction
name|newNode
parameter_list|)
block|{
name|DeprecatedUTF8
name|nameReplicationPair
index|[]
init|=
operator|new
name|DeprecatedUTF8
index|[]
block|{
operator|new
name|DeprecatedUTF8
argument_list|(
name|path
argument_list|)
block|,
name|FSEditLog
operator|.
name|toLogReplication
argument_list|(
name|newNode
operator|.
name|getReplication
argument_list|()
argument_list|)
block|,
name|FSEditLog
operator|.
name|toLogLong
argument_list|(
name|newNode
operator|.
name|getModificationTime
argument_list|()
argument_list|)
block|,
name|FSEditLog
operator|.
name|toLogLong
argument_list|(
name|newNode
operator|.
name|getAccessTime
argument_list|()
argument_list|)
block|,
name|FSEditLog
operator|.
name|toLogLong
argument_list|(
name|newNode
operator|.
name|getPreferredBlockSize
argument_list|()
argument_list|)
block|}
decl_stmt|;
name|logEdit
argument_list|(
name|OP_ADD
argument_list|,
operator|new
name|ArrayWritable
argument_list|(
name|DeprecatedUTF8
operator|.
name|class
argument_list|,
name|nameReplicationPair
argument_list|)
argument_list|,
operator|new
name|ArrayWritable
argument_list|(
name|Block
operator|.
name|class
argument_list|,
name|newNode
operator|.
name|getBlocks
argument_list|()
argument_list|)
argument_list|,
name|newNode
operator|.
name|getPermissionStatus
argument_list|()
argument_list|,
operator|new
name|DeprecatedUTF8
argument_list|(
name|newNode
operator|.
name|getClientName
argument_list|()
argument_list|)
argument_list|,
operator|new
name|DeprecatedUTF8
argument_list|(
name|newNode
operator|.
name|getClientMachine
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add close lease record to edit log.    */
DECL|method|logCloseFile (String path, INodeFile newNode)
specifier|public
name|void
name|logCloseFile
parameter_list|(
name|String
name|path
parameter_list|,
name|INodeFile
name|newNode
parameter_list|)
block|{
name|DeprecatedUTF8
name|nameReplicationPair
index|[]
init|=
operator|new
name|DeprecatedUTF8
index|[]
block|{
operator|new
name|DeprecatedUTF8
argument_list|(
name|path
argument_list|)
block|,
name|FSEditLog
operator|.
name|toLogReplication
argument_list|(
name|newNode
operator|.
name|getReplication
argument_list|()
argument_list|)
block|,
name|FSEditLog
operator|.
name|toLogLong
argument_list|(
name|newNode
operator|.
name|getModificationTime
argument_list|()
argument_list|)
block|,
name|FSEditLog
operator|.
name|toLogLong
argument_list|(
name|newNode
operator|.
name|getAccessTime
argument_list|()
argument_list|)
block|,
name|FSEditLog
operator|.
name|toLogLong
argument_list|(
name|newNode
operator|.
name|getPreferredBlockSize
argument_list|()
argument_list|)
block|}
decl_stmt|;
name|logEdit
argument_list|(
name|OP_CLOSE
argument_list|,
operator|new
name|ArrayWritable
argument_list|(
name|DeprecatedUTF8
operator|.
name|class
argument_list|,
name|nameReplicationPair
argument_list|)
argument_list|,
operator|new
name|ArrayWritable
argument_list|(
name|Block
operator|.
name|class
argument_list|,
name|newNode
operator|.
name|getBlocks
argument_list|()
argument_list|)
argument_list|,
name|newNode
operator|.
name|getPermissionStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add create directory record to edit log    */
DECL|method|logMkDir (String path, INode newNode)
specifier|public
name|void
name|logMkDir
parameter_list|(
name|String
name|path
parameter_list|,
name|INode
name|newNode
parameter_list|)
block|{
name|DeprecatedUTF8
name|info
index|[]
init|=
operator|new
name|DeprecatedUTF8
index|[]
block|{
operator|new
name|DeprecatedUTF8
argument_list|(
name|path
argument_list|)
block|,
name|FSEditLog
operator|.
name|toLogLong
argument_list|(
name|newNode
operator|.
name|getModificationTime
argument_list|()
argument_list|)
block|,
name|FSEditLog
operator|.
name|toLogLong
argument_list|(
name|newNode
operator|.
name|getAccessTime
argument_list|()
argument_list|)
block|}
decl_stmt|;
name|logEdit
argument_list|(
name|OP_MKDIR
argument_list|,
operator|new
name|ArrayWritable
argument_list|(
name|DeprecatedUTF8
operator|.
name|class
argument_list|,
name|info
argument_list|)
argument_list|,
name|newNode
operator|.
name|getPermissionStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add rename record to edit log    * TODO: use String parameters until just before writing to disk    */
DECL|method|logRename (String src, String dst, long timestamp)
name|void
name|logRename
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|long
name|timestamp
parameter_list|)
block|{
name|DeprecatedUTF8
name|info
index|[]
init|=
operator|new
name|DeprecatedUTF8
index|[]
block|{
operator|new
name|DeprecatedUTF8
argument_list|(
name|src
argument_list|)
block|,
operator|new
name|DeprecatedUTF8
argument_list|(
name|dst
argument_list|)
block|,
name|FSEditLog
operator|.
name|toLogLong
argument_list|(
name|timestamp
argument_list|)
block|}
decl_stmt|;
name|logEdit
argument_list|(
name|OP_RENAME_OLD
argument_list|,
operator|new
name|ArrayWritable
argument_list|(
name|DeprecatedUTF8
operator|.
name|class
argument_list|,
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add rename record to edit log    */
DECL|method|logRename (String src, String dst, long timestamp, Options.Rename... options)
name|void
name|logRename
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|,
name|long
name|timestamp
parameter_list|,
name|Options
operator|.
name|Rename
modifier|...
name|options
parameter_list|)
block|{
name|DeprecatedUTF8
name|info
index|[]
init|=
operator|new
name|DeprecatedUTF8
index|[]
block|{
operator|new
name|DeprecatedUTF8
argument_list|(
name|src
argument_list|)
block|,
operator|new
name|DeprecatedUTF8
argument_list|(
name|dst
argument_list|)
block|,
name|FSEditLog
operator|.
name|toLogLong
argument_list|(
name|timestamp
argument_list|)
block|}
decl_stmt|;
name|logEdit
argument_list|(
name|OP_RENAME
argument_list|,
operator|new
name|ArrayWritable
argument_list|(
name|DeprecatedUTF8
operator|.
name|class
argument_list|,
name|info
argument_list|)
argument_list|,
name|toBytesWritable
argument_list|(
name|options
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add set replication record to edit log    */
DECL|method|logSetReplication (String src, short replication)
name|void
name|logSetReplication
parameter_list|(
name|String
name|src
parameter_list|,
name|short
name|replication
parameter_list|)
block|{
name|logEdit
argument_list|(
name|OP_SET_REPLICATION
argument_list|,
operator|new
name|DeprecatedUTF8
argument_list|(
name|src
argument_list|)
argument_list|,
name|FSEditLog
operator|.
name|toLogReplication
argument_list|(
name|replication
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Add set namespace quota record to edit log    *     * @param src the string representation of the path to a directory    * @param quota the directory size limit    */
DECL|method|logSetQuota (String src, long nsQuota, long dsQuota)
name|void
name|logSetQuota
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|nsQuota
parameter_list|,
name|long
name|dsQuota
parameter_list|)
block|{
name|logEdit
argument_list|(
name|OP_SET_QUOTA
argument_list|,
operator|new
name|DeprecatedUTF8
argument_list|(
name|src
argument_list|)
argument_list|,
operator|new
name|LongWritable
argument_list|(
name|nsQuota
argument_list|)
argument_list|,
operator|new
name|LongWritable
argument_list|(
name|dsQuota
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**  Add set permissions record to edit log */
DECL|method|logSetPermissions (String src, FsPermission permissions)
name|void
name|logSetPermissions
parameter_list|(
name|String
name|src
parameter_list|,
name|FsPermission
name|permissions
parameter_list|)
block|{
name|logEdit
argument_list|(
name|OP_SET_PERMISSIONS
argument_list|,
operator|new
name|DeprecatedUTF8
argument_list|(
name|src
argument_list|)
argument_list|,
name|permissions
argument_list|)
expr_stmt|;
block|}
comment|/**  Add set owner record to edit log */
DECL|method|logSetOwner (String src, String username, String groupname)
name|void
name|logSetOwner
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|username
parameter_list|,
name|String
name|groupname
parameter_list|)
block|{
name|DeprecatedUTF8
name|u
init|=
operator|new
name|DeprecatedUTF8
argument_list|(
name|username
operator|==
literal|null
condition|?
literal|""
else|:
name|username
argument_list|)
decl_stmt|;
name|DeprecatedUTF8
name|g
init|=
operator|new
name|DeprecatedUTF8
argument_list|(
name|groupname
operator|==
literal|null
condition|?
literal|""
else|:
name|groupname
argument_list|)
decl_stmt|;
name|logEdit
argument_list|(
name|OP_SET_OWNER
argument_list|,
operator|new
name|DeprecatedUTF8
argument_list|(
name|src
argument_list|)
argument_list|,
name|u
argument_list|,
name|g
argument_list|)
expr_stmt|;
block|}
comment|/**    * concat(trg,src..) log    */
DECL|method|logConcat (String trg, String [] srcs, long timestamp)
name|void
name|logConcat
parameter_list|(
name|String
name|trg
parameter_list|,
name|String
index|[]
name|srcs
parameter_list|,
name|long
name|timestamp
parameter_list|)
block|{
name|int
name|size
init|=
literal|1
operator|+
name|srcs
operator|.
name|length
operator|+
literal|1
decl_stmt|;
comment|// trg, srcs, timestamp
name|DeprecatedUTF8
name|info
index|[]
init|=
operator|new
name|DeprecatedUTF8
index|[
name|size
index|]
decl_stmt|;
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|info
index|[
name|idx
operator|++
index|]
operator|=
operator|new
name|DeprecatedUTF8
argument_list|(
name|trg
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|srcs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|info
index|[
name|idx
operator|++
index|]
operator|=
operator|new
name|DeprecatedUTF8
argument_list|(
name|srcs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|info
index|[
name|idx
index|]
operator|=
name|FSEditLog
operator|.
name|toLogLong
argument_list|(
name|timestamp
argument_list|)
expr_stmt|;
name|logEdit
argument_list|(
name|OP_CONCAT_DELETE
argument_list|,
operator|new
name|ArrayWritable
argument_list|(
name|DeprecatedUTF8
operator|.
name|class
argument_list|,
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add delete file record to edit log    */
DECL|method|logDelete (String src, long timestamp)
name|void
name|logDelete
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|timestamp
parameter_list|)
block|{
name|DeprecatedUTF8
name|info
index|[]
init|=
operator|new
name|DeprecatedUTF8
index|[]
block|{
operator|new
name|DeprecatedUTF8
argument_list|(
name|src
argument_list|)
block|,
name|FSEditLog
operator|.
name|toLogLong
argument_list|(
name|timestamp
argument_list|)
block|}
decl_stmt|;
name|logEdit
argument_list|(
name|OP_DELETE
argument_list|,
operator|new
name|ArrayWritable
argument_list|(
name|DeprecatedUTF8
operator|.
name|class
argument_list|,
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add generation stamp record to edit log    */
DECL|method|logGenerationStamp (long genstamp)
name|void
name|logGenerationStamp
parameter_list|(
name|long
name|genstamp
parameter_list|)
block|{
name|logEdit
argument_list|(
name|OP_SET_GENSTAMP
argument_list|,
operator|new
name|LongWritable
argument_list|(
name|genstamp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add access time record to edit log    */
DECL|method|logTimes (String src, long mtime, long atime)
name|void
name|logTimes
parameter_list|(
name|String
name|src
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|)
block|{
name|DeprecatedUTF8
name|info
index|[]
init|=
operator|new
name|DeprecatedUTF8
index|[]
block|{
operator|new
name|DeprecatedUTF8
argument_list|(
name|src
argument_list|)
block|,
name|FSEditLog
operator|.
name|toLogLong
argument_list|(
name|mtime
argument_list|)
block|,
name|FSEditLog
operator|.
name|toLogLong
argument_list|(
name|atime
argument_list|)
block|}
decl_stmt|;
name|logEdit
argument_list|(
name|OP_TIMES
argument_list|,
operator|new
name|ArrayWritable
argument_list|(
name|DeprecatedUTF8
operator|.
name|class
argument_list|,
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**     * Add a create symlink record.    */
DECL|method|logSymlink (String path, String value, long mtime, long atime, INodeSymlink node)
name|void
name|logSymlink
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|value
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|,
name|INodeSymlink
name|node
parameter_list|)
block|{
name|DeprecatedUTF8
name|info
index|[]
init|=
operator|new
name|DeprecatedUTF8
index|[]
block|{
operator|new
name|DeprecatedUTF8
argument_list|(
name|path
argument_list|)
block|,
operator|new
name|DeprecatedUTF8
argument_list|(
name|value
argument_list|)
block|,
name|FSEditLog
operator|.
name|toLogLong
argument_list|(
name|mtime
argument_list|)
block|,
name|FSEditLog
operator|.
name|toLogLong
argument_list|(
name|atime
argument_list|)
block|}
decl_stmt|;
name|logEdit
argument_list|(
name|OP_SYMLINK
argument_list|,
operator|new
name|ArrayWritable
argument_list|(
name|DeprecatedUTF8
operator|.
name|class
argument_list|,
name|info
argument_list|)
argument_list|,
name|node
operator|.
name|getPermissionStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * log delegation token to edit log    * @param id DelegationTokenIdentifier    * @param expiryTime of the token    * @return    */
DECL|method|logGetDelegationToken (DelegationTokenIdentifier id, long expiryTime)
name|void
name|logGetDelegationToken
parameter_list|(
name|DelegationTokenIdentifier
name|id
parameter_list|,
name|long
name|expiryTime
parameter_list|)
block|{
name|logEdit
argument_list|(
name|OP_GET_DELEGATION_TOKEN
argument_list|,
name|id
argument_list|,
name|FSEditLog
operator|.
name|toLogLong
argument_list|(
name|expiryTime
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|logRenewDelegationToken (DelegationTokenIdentifier id, long expiryTime)
name|void
name|logRenewDelegationToken
parameter_list|(
name|DelegationTokenIdentifier
name|id
parameter_list|,
name|long
name|expiryTime
parameter_list|)
block|{
name|logEdit
argument_list|(
name|OP_RENEW_DELEGATION_TOKEN
argument_list|,
name|id
argument_list|,
name|FSEditLog
operator|.
name|toLogLong
argument_list|(
name|expiryTime
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|logCancelDelegationToken (DelegationTokenIdentifier id)
name|void
name|logCancelDelegationToken
parameter_list|(
name|DelegationTokenIdentifier
name|id
parameter_list|)
block|{
name|logEdit
argument_list|(
name|OP_CANCEL_DELEGATION_TOKEN
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
DECL|method|logUpdateMasterKey (DelegationKey key)
name|void
name|logUpdateMasterKey
parameter_list|(
name|DelegationKey
name|key
parameter_list|)
block|{
name|logEdit
argument_list|(
name|OP_UPDATE_MASTER_KEY
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
DECL|method|logReassignLease (String leaseHolder, String src, String newHolder)
name|void
name|logReassignLease
parameter_list|(
name|String
name|leaseHolder
parameter_list|,
name|String
name|src
parameter_list|,
name|String
name|newHolder
parameter_list|)
block|{
name|logEdit
argument_list|(
name|OP_REASSIGN_LEASE
argument_list|,
operator|new
name|DeprecatedUTF8
argument_list|(
name|leaseHolder
argument_list|)
argument_list|,
operator|new
name|DeprecatedUTF8
argument_list|(
name|src
argument_list|)
argument_list|,
operator|new
name|DeprecatedUTF8
argument_list|(
name|newHolder
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|toLogReplication (short replication)
specifier|static
specifier|private
name|DeprecatedUTF8
name|toLogReplication
parameter_list|(
name|short
name|replication
parameter_list|)
block|{
return|return
operator|new
name|DeprecatedUTF8
argument_list|(
name|Short
operator|.
name|toString
argument_list|(
name|replication
argument_list|)
argument_list|)
return|;
block|}
DECL|method|toLogLong (long timestamp)
specifier|static
specifier|private
name|DeprecatedUTF8
name|toLogLong
parameter_list|(
name|long
name|timestamp
parameter_list|)
block|{
return|return
operator|new
name|DeprecatedUTF8
argument_list|(
name|Long
operator|.
name|toString
argument_list|(
name|timestamp
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Return the size of the current EditLog    */
DECL|method|getEditLogSize ()
specifier|synchronized
name|long
name|getEditLogSize
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|getNumEditsDirs
argument_list|()
operator|<=
name|getNumEditStreams
argument_list|()
operator|:
literal|"Number of edits directories should not exceed the number of streams."
assert|;
name|long
name|size
init|=
literal|0
decl_stmt|;
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
name|al
init|=
literal|null
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|getNumEditStreams
argument_list|()
condition|;
name|idx
operator|++
control|)
block|{
name|EditLogOutputStream
name|es
init|=
name|editStreams
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
try|try
block|{
name|long
name|curSize
init|=
name|es
operator|.
name|length
argument_list|()
decl_stmt|;
assert|assert
operator|(
name|size
operator|==
literal|0
operator|||
name|size
operator|==
name|curSize
operator|||
name|curSize
operator|==
literal|0
operator|)
operator|:
literal|"Wrong streams size"
assert|;
name|size
operator|=
name|Math
operator|.
name|max
argument_list|(
name|size
argument_list|,
name|curSize
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"getEditLogSize: editstream.length failed. removing editlog ("
operator|+
name|idx
operator|+
literal|") "
operator|+
name|es
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|al
operator|==
literal|null
condition|)
name|al
operator|=
operator|new
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|al
operator|.
name|add
argument_list|(
name|es
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|al
operator|!=
literal|null
condition|)
name|disableAndReportErrorOnStreams
argument_list|(
name|al
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
comment|/**    * Closes the current edit log and opens edits.new.     */
DECL|method|rollEditLog ()
specifier|synchronized
name|void
name|rollEditLog
parameter_list|()
throws|throws
name|IOException
block|{
name|waitForSyncToFinish
argument_list|()
expr_stmt|;
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|it
operator|.
name|hasNext
argument_list|()
condition|)
return|return;
comment|//
comment|// If edits.new already exists in some directory, verify it
comment|// exists in all directories.
comment|//
name|boolean
name|alreadyExists
init|=
name|existsNew
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|alreadyExists
operator|!=
name|existsNew
argument_list|(
name|sd
argument_list|)
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
name|getEditNewFile
argument_list|(
name|sd
argument_list|)
operator|+
literal|"should "
operator|+
operator|(
name|alreadyExists
condition|?
literal|""
else|:
literal|"not "
operator|)
operator|+
literal|"exist."
argument_list|)
throw|;
block|}
if|if
condition|(
name|alreadyExists
condition|)
return|return;
comment|// nothing to do, edits.new exists!
comment|// check if any of failed storage is now available and put it back
name|storage
operator|.
name|attemptRestoreRemovedStorage
argument_list|()
expr_stmt|;
name|divertFileStreams
argument_list|(
name|Storage
operator|.
name|STORAGE_DIR_CURRENT
operator|+
literal|"/"
operator|+
name|NameNodeFile
operator|.
name|EDITS_NEW
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Divert file streams from file edits to file edits.new.<p>    * Close file streams, which are currently writing into edits files.    * Create new streams based on file getRoot()/dest.    * @param dest new stream path relative to the storage directory root.    * @throws IOException    */
DECL|method|divertFileStreams (String dest)
specifier|synchronized
name|void
name|divertFileStreams
parameter_list|(
name|String
name|dest
parameter_list|)
throws|throws
name|IOException
block|{
name|waitForSyncToFinish
argument_list|()
expr_stmt|;
assert|assert
name|getNumEditStreams
argument_list|()
operator|>=
name|getNumEditsDirs
argument_list|()
operator|:
literal|"Inconsistent number of streams"
assert|;
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
name|errorStreams
init|=
literal|null
decl_stmt|;
name|EditStreamIterator
name|itE
init|=
operator|(
name|EditStreamIterator
operator|)
name|getOutputStreamIterator
argument_list|(
name|JournalType
operator|.
name|FILE
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|itD
init|=
name|storage
operator|.
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
decl_stmt|;
while|while
condition|(
name|itE
operator|.
name|hasNext
argument_list|()
operator|&&
name|itD
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|EditLogOutputStream
name|eStream
init|=
name|itE
operator|.
name|next
argument_list|()
decl_stmt|;
name|StorageDirectory
name|sd
init|=
name|itD
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|eStream
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Inconsistent order of edit streams: "
operator|+
name|eStream
argument_list|)
throw|;
try|try
block|{
comment|// close old stream
name|closeStream
argument_list|(
name|eStream
argument_list|)
expr_stmt|;
comment|// create new stream
name|eStream
operator|=
operator|new
name|EditLogFileOutputStream
argument_list|(
operator|new
name|File
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
name|dest
argument_list|)
argument_list|,
name|sizeOutputFlushBuffer
argument_list|)
expr_stmt|;
name|eStream
operator|.
name|create
argument_list|()
expr_stmt|;
comment|// replace by the new stream
name|itE
operator|.
name|replace
argument_list|(
name|eStream
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error in editStream "
operator|+
name|eStream
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorStreams
operator|==
literal|null
condition|)
name|errorStreams
operator|=
operator|new
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|errorStreams
operator|.
name|add
argument_list|(
name|eStream
argument_list|)
expr_stmt|;
block|}
block|}
name|disableAndReportErrorOnStreams
argument_list|(
name|errorStreams
argument_list|)
expr_stmt|;
block|}
comment|/**    * Removes the old edit log and renames edits.new to edits.    * Reopens the edits file.    */
DECL|method|purgeEditLog ()
specifier|synchronized
name|void
name|purgeEditLog
parameter_list|()
throws|throws
name|IOException
block|{
name|waitForSyncToFinish
argument_list|()
expr_stmt|;
name|revertFileStreams
argument_list|(
name|Storage
operator|.
name|STORAGE_DIR_CURRENT
operator|+
literal|"/"
operator|+
name|NameNodeFile
operator|.
name|EDITS_NEW
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * The actual sync activity happens while not synchronized on this object.    * Thus, synchronized activities that require that they are not concurrent    * with file operations should wait for any running sync to finish.    */
DECL|method|waitForSyncToFinish ()
specifier|synchronized
name|void
name|waitForSyncToFinish
parameter_list|()
block|{
while|while
condition|(
name|isSyncRunning
condition|)
block|{
try|try
block|{
name|wait
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{}
block|}
block|}
comment|/**    * Revert file streams from file edits.new back to file edits.<p>    * Close file streams, which are currently writing into getRoot()/source.    * Rename getRoot()/source to edits.    * Reopen streams so that they start writing into edits files.    * @param dest new stream path relative to the storage directory root.    * @throws IOException    */
DECL|method|revertFileStreams (String source)
specifier|synchronized
name|void
name|revertFileStreams
parameter_list|(
name|String
name|source
parameter_list|)
throws|throws
name|IOException
block|{
name|waitForSyncToFinish
argument_list|()
expr_stmt|;
assert|assert
name|getNumEditStreams
argument_list|()
operator|>=
name|getNumEditsDirs
argument_list|()
operator|:
literal|"Inconsistent number of streams"
assert|;
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
name|errorStreams
init|=
literal|null
decl_stmt|;
name|EditStreamIterator
name|itE
init|=
operator|(
name|EditStreamIterator
operator|)
name|getOutputStreamIterator
argument_list|(
name|JournalType
operator|.
name|FILE
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|itD
init|=
name|storage
operator|.
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
decl_stmt|;
while|while
condition|(
name|itE
operator|.
name|hasNext
argument_list|()
operator|&&
name|itD
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|EditLogOutputStream
name|eStream
init|=
name|itE
operator|.
name|next
argument_list|()
decl_stmt|;
name|StorageDirectory
name|sd
init|=
name|itD
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|eStream
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Inconsistent order of edit streams: "
operator|+
name|eStream
operator|+
literal|" does not start with "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
throw|;
try|try
block|{
comment|// close old stream
name|closeStream
argument_list|(
name|eStream
argument_list|)
expr_stmt|;
comment|// rename edits.new to edits
name|File
name|editFile
init|=
name|getEditFile
argument_list|(
name|sd
argument_list|)
decl_stmt|;
name|File
name|prevEditFile
init|=
operator|new
name|File
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|prevEditFile
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|prevEditFile
operator|.
name|renameTo
argument_list|(
name|editFile
argument_list|)
condition|)
block|{
comment|//
comment|// renameTo() fails on Windows if the destination
comment|// file exists.
comment|//
if|if
condition|(
operator|!
name|editFile
operator|.
name|delete
argument_list|()
operator|||
operator|!
name|prevEditFile
operator|.
name|renameTo
argument_list|(
name|editFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Rename failed for "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
comment|// open new stream
name|eStream
operator|=
operator|new
name|EditLogFileOutputStream
argument_list|(
name|editFile
argument_list|,
name|sizeOutputFlushBuffer
argument_list|)
expr_stmt|;
comment|// replace by the new stream
name|itE
operator|.
name|replace
argument_list|(
name|eStream
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error in editStream "
operator|+
name|eStream
operator|.
name|getName
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorStreams
operator|==
literal|null
condition|)
name|errorStreams
operator|=
operator|new
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|errorStreams
operator|.
name|add
argument_list|(
name|eStream
argument_list|)
expr_stmt|;
block|}
block|}
name|disableAndReportErrorOnStreams
argument_list|(
name|errorStreams
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return the name of the edit file    */
DECL|method|getFsEditName ()
specifier|synchronized
name|File
name|getFsEditName
parameter_list|()
block|{
name|StorageDirectory
name|sd
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|sd
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|canRead
argument_list|()
condition|)
return|return
name|getEditFile
argument_list|(
name|sd
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Returns the timestamp of the edit log    */
DECL|method|getFsEditTime ()
specifier|synchronized
name|long
name|getFsEditTime
parameter_list|()
block|{
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
return|return
name|getEditFile
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|lastModified
argument_list|()
return|;
return|return
literal|0
return|;
block|}
comment|/**    * Return the txid of the last synced transaction.    * For test use only    */
DECL|method|getSyncTxId ()
specifier|synchronized
name|long
name|getSyncTxId
parameter_list|()
block|{
return|return
name|synctxid
return|;
block|}
comment|// sets the initial capacity of the flush buffer.
DECL|method|setBufferCapacity (int size)
specifier|public
name|void
name|setBufferCapacity
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|sizeOutputFlushBuffer
operator|=
name|size
expr_stmt|;
block|}
DECL|method|isEmpty ()
name|boolean
name|isEmpty
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getEditLogSize
argument_list|()
operator|<=
literal|0
return|;
block|}
comment|/**    * Create (or find if already exists) an edit output stream, which    * streams journal records (edits) to the specified backup node.<br>    * Send a record, prescribing to start journal spool.<br>    * This should be sent via regular stream of journal records so that    * the backup node new exactly after which record it should start spooling.    *     * @param bnReg the backup node registration information.    * @param nnReg this (active) name-node registration.    * @throws IOException    */
DECL|method|logJSpoolStart (NamenodeRegistration bnReg, NamenodeRegistration nnReg)
specifier|synchronized
name|void
name|logJSpoolStart
parameter_list|(
name|NamenodeRegistration
name|bnReg
parameter_list|,
comment|// backup node
name|NamenodeRegistration
name|nnReg
parameter_list|)
comment|// active name-node
throws|throws
name|IOException
block|{
if|if
condition|(
name|bnReg
operator|.
name|isRole
argument_list|(
name|NamenodeRole
operator|.
name|CHECKPOINT
argument_list|)
condition|)
return|return;
comment|// checkpoint node does not stream edits
if|if
condition|(
name|editStreams
operator|==
literal|null
condition|)
name|editStreams
operator|=
operator|new
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
argument_list|()
expr_stmt|;
name|EditLogOutputStream
name|boStream
init|=
literal|null
decl_stmt|;
for|for
control|(
name|EditLogOutputStream
name|eStream
range|:
name|editStreams
control|)
block|{
if|if
condition|(
name|eStream
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|bnReg
operator|.
name|getAddress
argument_list|()
argument_list|)
condition|)
block|{
name|boStream
operator|=
name|eStream
expr_stmt|;
comment|// already there
break|break;
block|}
block|}
if|if
condition|(
name|boStream
operator|==
literal|null
condition|)
block|{
name|boStream
operator|=
operator|new
name|EditLogBackupOutputStream
argument_list|(
name|bnReg
argument_list|,
name|nnReg
argument_list|)
expr_stmt|;
name|editStreams
operator|.
name|add
argument_list|(
name|boStream
argument_list|)
expr_stmt|;
block|}
name|logEdit
argument_list|(
name|OP_JSPOOL_START
argument_list|,
operator|(
name|Writable
index|[]
operator|)
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Write an operation to the edit log. Do not sync to persistent    * store yet.    */
DECL|method|logEdit (int length, byte[] data)
specifier|synchronized
name|void
name|logEdit
parameter_list|(
name|int
name|length
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
block|{
if|if
condition|(
name|getNumEditStreams
argument_list|()
operator|==
literal|0
condition|)
throw|throw
operator|new
name|java
operator|.
name|lang
operator|.
name|IllegalStateException
argument_list|(
name|NO_JOURNAL_STREAMS_WARNING
argument_list|)
throw|;
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
name|errorStreams
init|=
literal|null
decl_stmt|;
name|long
name|start
init|=
name|now
argument_list|()
decl_stmt|;
for|for
control|(
name|EditLogOutputStream
name|eStream
range|:
name|editStreams
control|)
block|{
try|try
block|{
name|eStream
operator|.
name|write
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Error in editStream "
operator|+
name|eStream
operator|.
name|getName
argument_list|()
argument_list|,
name|ie
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorStreams
operator|==
literal|null
condition|)
name|errorStreams
operator|=
operator|new
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|errorStreams
operator|.
name|add
argument_list|(
name|eStream
argument_list|)
expr_stmt|;
block|}
block|}
name|disableAndReportErrorOnStreams
argument_list|(
name|errorStreams
argument_list|)
expr_stmt|;
name|recordTransaction
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
comment|/**    * Iterates output streams based of the same type.    * Type null will iterate over all streams.    */
DECL|class|EditStreamIterator
specifier|private
class|class
name|EditStreamIterator
implements|implements
name|Iterator
argument_list|<
name|EditLogOutputStream
argument_list|>
block|{
DECL|field|type
name|JournalType
name|type
decl_stmt|;
DECL|field|prevIndex
name|int
name|prevIndex
decl_stmt|;
comment|// for remove()
DECL|field|nextIndex
name|int
name|nextIndex
decl_stmt|;
comment|// for next()
DECL|method|EditStreamIterator (JournalType streamType)
name|EditStreamIterator
parameter_list|(
name|JournalType
name|streamType
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|streamType
expr_stmt|;
name|this
operator|.
name|nextIndex
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|prevIndex
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
synchronized|synchronized
init|(
name|FSEditLog
operator|.
name|this
init|)
block|{
if|if
condition|(
name|editStreams
operator|==
literal|null
operator|||
name|editStreams
operator|.
name|isEmpty
argument_list|()
operator|||
name|nextIndex
operator|>=
name|editStreams
operator|.
name|size
argument_list|()
condition|)
return|return
literal|false
return|;
while|while
condition|(
name|nextIndex
operator|<
name|editStreams
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|editStreams
operator|.
name|get
argument_list|(
name|nextIndex
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|isOfType
argument_list|(
name|type
argument_list|)
condition|)
name|nextIndex
operator|++
expr_stmt|;
return|return
name|nextIndex
operator|<
name|editStreams
operator|.
name|size
argument_list|()
return|;
block|}
block|}
DECL|method|next ()
specifier|public
name|EditLogOutputStream
name|next
parameter_list|()
block|{
name|EditLogOutputStream
name|stream
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|FSEditLog
operator|.
name|this
init|)
block|{
name|stream
operator|=
name|editStreams
operator|.
name|get
argument_list|(
name|nextIndex
argument_list|)
expr_stmt|;
name|prevIndex
operator|=
name|nextIndex
expr_stmt|;
name|nextIndex
operator|++
expr_stmt|;
while|while
condition|(
name|nextIndex
operator|<
name|editStreams
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|editStreams
operator|.
name|get
argument_list|(
name|nextIndex
argument_list|)
operator|.
name|getType
argument_list|()
operator|.
name|isOfType
argument_list|(
name|type
argument_list|)
condition|)
name|nextIndex
operator|++
expr_stmt|;
block|}
return|return
name|stream
return|;
block|}
DECL|method|remove ()
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|nextIndex
operator|=
name|prevIndex
expr_stmt|;
comment|// restore previous state
name|removeStream
argument_list|(
name|prevIndex
argument_list|)
expr_stmt|;
comment|// remove last returned element
name|hasNext
argument_list|()
expr_stmt|;
comment|// reset nextIndex to correct place
block|}
DECL|method|replace (EditLogOutputStream newStream)
name|void
name|replace
parameter_list|(
name|EditLogOutputStream
name|newStream
parameter_list|)
block|{
synchronized|synchronized
init|(
name|FSEditLog
operator|.
name|this
init|)
block|{
assert|assert
literal|0
operator|<=
name|prevIndex
operator|&&
name|prevIndex
operator|<
name|editStreams
operator|.
name|size
argument_list|()
operator|:
literal|"Index out of bound."
assert|;
name|editStreams
operator|.
name|set
argument_list|(
name|prevIndex
argument_list|,
name|newStream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Get stream iterator for the specified type.    */
specifier|public
name|Iterator
argument_list|<
name|EditLogOutputStream
argument_list|>
DECL|method|getOutputStreamIterator (JournalType streamType)
name|getOutputStreamIterator
parameter_list|(
name|JournalType
name|streamType
parameter_list|)
block|{
return|return
operator|new
name|EditStreamIterator
argument_list|(
name|streamType
argument_list|)
return|;
block|}
DECL|method|closeStream (EditLogOutputStream eStream)
specifier|private
name|void
name|closeStream
parameter_list|(
name|EditLogOutputStream
name|eStream
parameter_list|)
throws|throws
name|IOException
block|{
name|eStream
operator|.
name|setReadyToFlush
argument_list|()
expr_stmt|;
name|eStream
operator|.
name|flush
argument_list|()
expr_stmt|;
name|eStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|method|incrementCheckpointTime ()
name|void
name|incrementCheckpointTime
parameter_list|()
block|{
name|storage
operator|.
name|incrementCheckpointTime
argument_list|()
expr_stmt|;
name|Writable
index|[]
name|args
init|=
block|{
operator|new
name|LongWritable
argument_list|(
name|storage
operator|.
name|getCheckpointTime
argument_list|()
argument_list|)
block|}
decl_stmt|;
name|logEdit
argument_list|(
name|OP_CHECKPOINT_TIME
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
DECL|method|releaseBackupStream (NamenodeRegistration registration)
specifier|synchronized
name|void
name|releaseBackupStream
parameter_list|(
name|NamenodeRegistration
name|registration
parameter_list|)
block|{
name|Iterator
argument_list|<
name|EditLogOutputStream
argument_list|>
name|it
init|=
name|getOutputStreamIterator
argument_list|(
name|JournalType
operator|.
name|BACKUP
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
name|errorStreams
init|=
literal|null
decl_stmt|;
name|NamenodeRegistration
name|backupNode
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|EditLogBackupOutputStream
name|eStream
init|=
operator|(
name|EditLogBackupOutputStream
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|backupNode
operator|=
name|eStream
operator|.
name|getRegistration
argument_list|()
expr_stmt|;
if|if
condition|(
name|backupNode
operator|.
name|getAddress
argument_list|()
operator|.
name|equals
argument_list|(
name|registration
operator|.
name|getAddress
argument_list|()
argument_list|)
operator|&&
name|backupNode
operator|.
name|isRole
argument_list|(
name|registration
operator|.
name|getRole
argument_list|()
argument_list|)
condition|)
block|{
name|errorStreams
operator|=
operator|new
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|errorStreams
operator|.
name|add
argument_list|(
name|eStream
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
assert|assert
name|backupNode
operator|==
literal|null
operator|||
name|backupNode
operator|.
name|isRole
argument_list|(
name|NamenodeRole
operator|.
name|BACKUP
argument_list|)
operator|:
literal|"Not a backup node corresponds to a backup stream"
assert|;
name|disableAndReportErrorOnStreams
argument_list|(
name|errorStreams
argument_list|)
expr_stmt|;
block|}
DECL|method|checkBackupRegistration ( NamenodeRegistration registration)
specifier|synchronized
name|boolean
name|checkBackupRegistration
parameter_list|(
name|NamenodeRegistration
name|registration
parameter_list|)
block|{
name|Iterator
argument_list|<
name|EditLogOutputStream
argument_list|>
name|it
init|=
name|getOutputStreamIterator
argument_list|(
name|JournalType
operator|.
name|BACKUP
argument_list|)
decl_stmt|;
name|boolean
name|regAllowed
init|=
operator|!
name|it
operator|.
name|hasNext
argument_list|()
decl_stmt|;
name|NamenodeRegistration
name|backupNode
init|=
literal|null
decl_stmt|;
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
name|errorStreams
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|EditLogBackupOutputStream
name|eStream
init|=
operator|(
name|EditLogBackupOutputStream
operator|)
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|backupNode
operator|=
name|eStream
operator|.
name|getRegistration
argument_list|()
expr_stmt|;
if|if
condition|(
name|backupNode
operator|.
name|getAddress
argument_list|()
operator|.
name|equals
argument_list|(
name|registration
operator|.
name|getAddress
argument_list|()
argument_list|)
operator|&&
name|backupNode
operator|.
name|isRole
argument_list|(
name|registration
operator|.
name|getRole
argument_list|()
argument_list|)
condition|)
block|{
name|regAllowed
operator|=
literal|true
expr_stmt|;
comment|// same node re-registers
break|break;
block|}
if|if
condition|(
operator|!
name|eStream
operator|.
name|isAlive
argument_list|()
condition|)
block|{
if|if
condition|(
name|errorStreams
operator|==
literal|null
condition|)
name|errorStreams
operator|=
operator|new
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|errorStreams
operator|.
name|add
argument_list|(
name|eStream
argument_list|)
expr_stmt|;
name|regAllowed
operator|=
literal|true
expr_stmt|;
comment|// previous backup node failed
block|}
block|}
assert|assert
name|backupNode
operator|==
literal|null
operator|||
name|backupNode
operator|.
name|isRole
argument_list|(
name|NamenodeRole
operator|.
name|BACKUP
argument_list|)
operator|:
literal|"Not a backup node corresponds to a backup stream"
assert|;
name|disableAndReportErrorOnStreams
argument_list|(
name|errorStreams
argument_list|)
expr_stmt|;
return|return
name|regAllowed
return|;
block|}
DECL|method|toBytesWritable (Options.Rename... options)
specifier|static
name|BytesWritable
name|toBytesWritable
parameter_list|(
name|Options
operator|.
name|Rename
modifier|...
name|options
parameter_list|)
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|options
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|options
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|bytes
index|[
name|i
index|]
operator|=
name|options
index|[
name|i
index|]
operator|.
name|value
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|BytesWritable
argument_list|(
name|bytes
argument_list|)
return|;
block|}
comment|/**    * Get the StorageDirectory for a stream    * @param es Stream whose StorageDirectory we wish to know    * @return the matching StorageDirectory    */
DECL|method|getStorageDirectoryForStream (EditLogOutputStream es)
name|StorageDirectory
name|getStorageDirectoryForStream
parameter_list|(
name|EditLogOutputStream
name|es
parameter_list|)
block|{
name|String
name|parentStorageDir
init|=
operator|(
operator|(
name|EditLogFileOutputStream
operator|)
name|es
operator|)
operator|.
name|getFile
argument_list|()
operator|.
name|getParentFile
argument_list|()
operator|.
name|getParentFile
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|FSNamesystem
operator|.
name|LOG
operator|.
name|info
argument_list|(
literal|"comparing: "
operator|+
name|parentStorageDir
operator|+
literal|" and "
operator|+
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|parentStorageDir
operator|.
name|equals
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
condition|)
return|return
name|sd
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|disableStream (EditLogOutputStream stream)
specifier|private
specifier|synchronized
name|void
name|disableStream
parameter_list|(
name|EditLogOutputStream
name|stream
parameter_list|)
block|{
try|try
block|{
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// nothing to do.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to close eStream "
operator|+
name|stream
operator|.
name|getName
argument_list|()
operator|+
literal|" before removing it (might be ok)"
argument_list|)
expr_stmt|;
block|}
name|editStreams
operator|.
name|remove
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|editStreams
operator|.
name|size
argument_list|()
operator|<=
literal|0
condition|)
block|{
name|String
name|msg
init|=
literal|"Fatal Error: All storage directories are inaccessible."
decl_stmt|;
name|LOG
operator|.
name|fatal
argument_list|(
name|msg
argument_list|,
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Error Handling on a storageDirectory    *    */
comment|// NNStorageListener Interface
annotation|@
name|Override
comment|// NNStorageListener
DECL|method|errorOccurred (StorageDirectory sd)
specifier|public
specifier|synchronized
name|void
name|errorOccurred
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|editStreams
operator|==
literal|null
condition|)
block|{
comment|//errors can occur on storage directories
comment|//before edit streams have been set up
return|return;
block|}
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
name|errorStreams
init|=
operator|new
name|ArrayList
argument_list|<
name|EditLogOutputStream
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|EditLogOutputStream
name|eStream
range|:
name|editStreams
control|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Unable to log edits to "
operator|+
name|eStream
operator|.
name|getName
argument_list|()
operator|+
literal|"; removing it"
argument_list|)
expr_stmt|;
name|StorageDirectory
name|streamStorageDir
init|=
name|getStorageDirectoryForStream
argument_list|(
name|eStream
argument_list|)
decl_stmt|;
if|if
condition|(
name|sd
operator|==
name|streamStorageDir
condition|)
block|{
name|errorStreams
operator|.
name|add
argument_list|(
name|eStream
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|EditLogOutputStream
name|eStream
range|:
name|errorStreams
control|)
block|{
name|disableStream
argument_list|(
name|eStream
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
comment|// NNStorageListener
DECL|method|formatOccurred (StorageDirectory sd)
specifier|public
specifier|synchronized
name|void
name|formatOccurred
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|sd
operator|.
name|getStorageDirType
argument_list|()
operator|.
name|isOfType
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
condition|)
block|{
name|createEditLogFile
argument_list|(
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sd
argument_list|,
name|NameNodeFile
operator|.
name|EDITS
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
annotation|@
name|Override
comment|// NNStorageListener
DECL|method|directoryAvailable (StorageDirectory sd)
specifier|public
specifier|synchronized
name|void
name|directoryAvailable
parameter_list|(
name|StorageDirectory
name|sd
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|sd
operator|.
name|getStorageDirType
argument_list|()
operator|.
name|isOfType
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
condition|)
block|{
name|File
name|eFile
init|=
name|getEditFile
argument_list|(
name|sd
argument_list|)
decl_stmt|;
name|addNewEditLogStream
argument_list|(
name|eFile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

