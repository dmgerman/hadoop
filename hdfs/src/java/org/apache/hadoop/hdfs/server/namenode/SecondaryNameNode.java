begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSUtil
operator|.
name|ErrorSimulator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|FSConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|InconsistentFSStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|JspHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|StorageDirectory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|StorageState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorage
operator|.
name|NameNodeDirType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorage
operator|.
name|NameNodeFile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|protocol
operator|.
name|NamenodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|http
operator|.
name|HttpServer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RPC
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|DefaultMetricsSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|source
operator|.
name|JvmMetrics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|Krb5AndCertsSslSocketConnector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SecurityUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authorize
operator|.
name|AccessControlList
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Daemon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_comment
comment|/**********************************************************  * The Secondary NameNode is a helper to the primary NameNode.  * The Secondary is responsible for supporting periodic checkpoints   * of the HDFS metadata. The current design allows only one Secondary  * NameNode per HDFs cluster.  *  * The Secondary NameNode is a daemon that periodically wakes  * up (determined by the schedule specified in the configuration),  * triggers a periodic checkpoint and then goes back to sleep.  * The Secondary NameNode uses the ClientProtocol to talk to the  * primary NameNode.  *  **********************************************************/
end_comment

begin_class
annotation|@
name|Deprecated
comment|// use BackupNode with -checkpoint argument instead.
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|SecondaryNameNode
specifier|public
class|class
name|SecondaryNameNode
implements|implements
name|Runnable
block|{
static|static
block|{
name|HdfsConfiguration
operator|.
name|init
argument_list|()
expr_stmt|;
block|}
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|SecondaryNameNode
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|starttime
specifier|private
specifier|final
name|long
name|starttime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
DECL|field|lastCheckpointTime
specifier|private
specifier|volatile
name|long
name|lastCheckpointTime
init|=
literal|0
decl_stmt|;
DECL|field|fsName
specifier|private
name|String
name|fsName
decl_stmt|;
DECL|field|checkpointImage
specifier|private
name|CheckpointStorage
name|checkpointImage
decl_stmt|;
DECL|field|namenode
specifier|private
name|NamenodeProtocol
name|namenode
decl_stmt|;
DECL|field|conf
specifier|private
name|Configuration
name|conf
decl_stmt|;
DECL|field|nameNodeAddr
specifier|private
name|InetSocketAddress
name|nameNodeAddr
decl_stmt|;
DECL|field|shouldRun
specifier|private
specifier|volatile
name|boolean
name|shouldRun
decl_stmt|;
DECL|field|infoServer
specifier|private
name|HttpServer
name|infoServer
decl_stmt|;
DECL|field|infoPort
specifier|private
name|int
name|infoPort
decl_stmt|;
DECL|field|imagePort
specifier|private
name|int
name|imagePort
decl_stmt|;
DECL|field|infoBindAddress
specifier|private
name|String
name|infoBindAddress
decl_stmt|;
DECL|field|namesystem
specifier|private
name|FSNamesystem
name|namesystem
decl_stmt|;
DECL|field|checkpointDirs
specifier|private
name|Collection
argument_list|<
name|URI
argument_list|>
name|checkpointDirs
decl_stmt|;
DECL|field|checkpointEditsDirs
specifier|private
name|Collection
argument_list|<
name|URI
argument_list|>
name|checkpointEditsDirs
decl_stmt|;
DECL|field|checkpointPeriod
specifier|private
name|long
name|checkpointPeriod
decl_stmt|;
comment|// in seconds
DECL|field|checkpointSize
specifier|private
name|long
name|checkpointSize
decl_stmt|;
comment|// size (in bytes) of current Edit Log
comment|/** {@inheritDoc} */
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" Status"
operator|+
literal|"\nName Node Address    : "
operator|+
name|nameNodeAddr
operator|+
literal|"\nStart Time           : "
operator|+
operator|new
name|Date
argument_list|(
name|starttime
argument_list|)
operator|+
literal|"\nLast Checkpoint Time : "
operator|+
operator|(
name|lastCheckpointTime
operator|==
literal|0
condition|?
literal|"--"
else|:
operator|new
name|Date
argument_list|(
name|lastCheckpointTime
argument_list|)
operator|)
operator|+
literal|"\nCheckpoint Period    : "
operator|+
name|checkpointPeriod
operator|+
literal|" seconds"
operator|+
literal|"\nCheckpoint Size      : "
operator|+
name|StringUtils
operator|.
name|byteDesc
argument_list|(
name|checkpointSize
argument_list|)
operator|+
literal|" (= "
operator|+
name|checkpointSize
operator|+
literal|" bytes)"
operator|+
literal|"\nCheckpoint Dirs      : "
operator|+
name|checkpointDirs
operator|+
literal|"\nCheckpoint Edits Dirs: "
operator|+
name|checkpointEditsDirs
return|;
block|}
DECL|method|getFSImage ()
name|FSImage
name|getFSImage
parameter_list|()
block|{
return|return
name|checkpointImage
return|;
block|}
comment|/**    * Create a connection to the primary namenode.    */
DECL|method|SecondaryNameNode (Configuration conf)
specifier|public
name|SecondaryNameNode
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|NameNode
operator|.
name|initializeGenericKeys
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|initialize
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|shutdown
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|fatal
argument_list|(
literal|"Failed to start secondary namenode. "
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|getHttpAddress (Configuration conf)
specifier|public
specifier|static
name|InetSocketAddress
name|getHttpAddress
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_NAMENODE_SECONDARY_HTTP_ADDRESS_KEY
argument_list|,
name|DFS_NAMENODE_SECONDARY_HTTP_ADDRESS_DEFAULT
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Initialize SecondaryNameNode.    */
DECL|method|initialize (final Configuration conf)
specifier|private
name|void
name|initialize
parameter_list|(
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|InetSocketAddress
name|infoSocAddr
init|=
name|getHttpAddress
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|infoBindAddress
operator|=
name|infoSocAddr
operator|.
name|getHostName
argument_list|()
expr_stmt|;
name|UserGroupInformation
operator|.
name|setConfiguration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|SecurityUtil
operator|.
name|login
argument_list|(
name|conf
argument_list|,
name|DFS_SECONDARY_NAMENODE_KEYTAB_FILE_KEY
argument_list|,
name|DFS_SECONDARY_NAMENODE_USER_NAME_KEY
argument_list|,
name|infoBindAddress
argument_list|)
expr_stmt|;
block|}
comment|// initiate Java VM metrics
name|JvmMetrics
operator|.
name|create
argument_list|(
literal|"SecondaryNameNode"
argument_list|,
name|conf
operator|.
name|get
argument_list|(
name|DFS_METRICS_SESSION_ID_KEY
argument_list|)
argument_list|,
name|DefaultMetricsSystem
operator|.
name|instance
argument_list|()
argument_list|)
expr_stmt|;
comment|// Create connection to the namenode.
name|shouldRun
operator|=
literal|true
expr_stmt|;
name|nameNodeAddr
operator|=
name|NameNode
operator|.
name|getServiceAddress
argument_list|(
name|conf
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|namenode
operator|=
operator|(
name|NamenodeProtocol
operator|)
name|RPC
operator|.
name|waitForProxy
argument_list|(
name|NamenodeProtocol
operator|.
name|class
argument_list|,
name|NamenodeProtocol
operator|.
name|versionID
argument_list|,
name|nameNodeAddr
argument_list|,
name|conf
argument_list|)
expr_stmt|;
comment|// initialize checkpoint directories
name|fsName
operator|=
name|getInfoServer
argument_list|()
expr_stmt|;
name|checkpointDirs
operator|=
name|FSImage
operator|.
name|getCheckpointDirs
argument_list|(
name|conf
argument_list|,
literal|"/tmp/hadoop/dfs/namesecondary"
argument_list|)
expr_stmt|;
name|checkpointEditsDirs
operator|=
name|FSImage
operator|.
name|getCheckpointEditsDirs
argument_list|(
name|conf
argument_list|,
literal|"/tmp/hadoop/dfs/namesecondary"
argument_list|)
expr_stmt|;
name|checkpointImage
operator|=
operator|new
name|CheckpointStorage
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|checkpointImage
operator|.
name|recoverCreate
argument_list|(
name|checkpointDirs
argument_list|,
name|checkpointEditsDirs
argument_list|)
expr_stmt|;
comment|// Initialize other scheduling parameters from the configuration
name|checkpointPeriod
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_CHECKPOINT_PERIOD_KEY
argument_list|,
name|DFS_NAMENODE_CHECKPOINT_PERIOD_DEFAULT
argument_list|)
expr_stmt|;
name|checkpointSize
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|DFS_NAMENODE_CHECKPOINT_SIZE_KEY
argument_list|,
name|DFS_NAMENODE_CHECKPOINT_SIZE_DEFAULT
argument_list|)
expr_stmt|;
comment|// initialize the webserver for uploading files.
comment|// Kerberized SSL servers must be run from the host principal...
name|UserGroupInformation
name|httpUGI
init|=
name|UserGroupInformation
operator|.
name|loginUserFromKeytabAndReturnUGI
argument_list|(
name|SecurityUtil
operator|.
name|getServerPrincipal
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_SECONDARY_NAMENODE_KRB_HTTPS_USER_NAME_KEY
argument_list|)
argument_list|,
name|infoBindAddress
argument_list|)
argument_list|,
name|conf
operator|.
name|get
argument_list|(
name|DFS_SECONDARY_NAMENODE_KEYTAB_FILE_KEY
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|infoServer
operator|=
name|httpUGI
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|HttpServer
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|HttpServer
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting web server as: "
operator|+
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|getUserName
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|tmpInfoPort
init|=
name|infoSocAddr
operator|.
name|getPort
argument_list|()
decl_stmt|;
name|infoServer
operator|=
operator|new
name|HttpServer
argument_list|(
literal|"secondary"
argument_list|,
name|infoBindAddress
argument_list|,
name|tmpInfoPort
argument_list|,
name|tmpInfoPort
operator|==
literal|0
argument_list|,
name|conf
argument_list|,
operator|new
name|AccessControlList
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_ADMIN
argument_list|,
literal|" "
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|System
operator|.
name|setProperty
argument_list|(
literal|"https.cipherSuites"
argument_list|,
name|Krb5AndCertsSslSocketConnector
operator|.
name|KRB5_CIPHER_SUITES
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|InetSocketAddress
name|secInfoSocAddr
init|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|infoBindAddress
operator|+
literal|":"
operator|+
name|conf
operator|.
name|get
argument_list|(
literal|"dfs.secondary.https.port"
argument_list|,
name|infoBindAddress
operator|+
literal|":"
operator|+
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|imagePort
operator|=
name|secInfoSocAddr
operator|.
name|getPort
argument_list|()
expr_stmt|;
name|infoServer
operator|.
name|addSslListener
argument_list|(
name|secInfoSocAddr
argument_list|,
name|conf
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|infoServer
operator|.
name|setAttribute
argument_list|(
literal|"secondary.name.node"
argument_list|,
name|SecondaryNameNode
operator|.
name|this
argument_list|)
expr_stmt|;
name|infoServer
operator|.
name|setAttribute
argument_list|(
literal|"name.system.image"
argument_list|,
name|checkpointImage
argument_list|)
expr_stmt|;
name|infoServer
operator|.
name|setAttribute
argument_list|(
name|JspHelper
operator|.
name|CURRENT_CONF
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|infoServer
operator|.
name|addInternalServlet
argument_list|(
literal|"getimage"
argument_list|,
literal|"/getimage"
argument_list|,
name|GetImageServlet
operator|.
name|class
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|infoServer
operator|.
name|start
argument_list|()
expr_stmt|;
return|return
name|infoServer
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Web server init done"
argument_list|)
expr_stmt|;
comment|// The web-server port can be ephemeral... ensure we have the correct info
name|infoPort
operator|=
name|infoServer
operator|.
name|getPort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
name|imagePort
operator|=
name|infoPort
expr_stmt|;
name|conf
operator|.
name|set
argument_list|(
name|DFS_NAMENODE_SECONDARY_HTTP_ADDRESS_KEY
argument_list|,
name|infoBindAddress
operator|+
literal|":"
operator|+
name|infoPort
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Secondary Web-server up at: "
operator|+
name|infoBindAddress
operator|+
literal|":"
operator|+
name|infoPort
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Secondary image servlet up at: "
operator|+
name|infoBindAddress
operator|+
literal|":"
operator|+
name|imagePort
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Checkpoint Period   :"
operator|+
name|checkpointPeriod
operator|+
literal|" secs "
operator|+
literal|"("
operator|+
name|checkpointPeriod
operator|/
literal|60
operator|+
literal|" min)"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Log Size Trigger    :"
operator|+
name|checkpointSize
operator|+
literal|" bytes "
operator|+
literal|"("
operator|+
name|checkpointSize
operator|/
literal|1024
operator|+
literal|" KB)"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Shut down this instance of the datanode.    * Returns only after shutdown is complete.    */
DECL|method|shutdown ()
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|shouldRun
operator|=
literal|false
expr_stmt|;
try|try
block|{
if|if
condition|(
name|infoServer
operator|!=
literal|null
condition|)
name|infoServer
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception shutting down SecondaryNameNode"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|checkpointImage
operator|!=
literal|null
condition|)
name|checkpointImage
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while closing CheckpointStorage"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
name|UserGroupInformation
name|ugi
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ugi
operator|=
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception while getting login user"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|ugi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedAction
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|run
parameter_list|()
block|{
name|doWork
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|doWork
argument_list|()
expr_stmt|;
block|}
block|}
comment|//
comment|// The main work loop
comment|//
DECL|method|doWork ()
specifier|public
name|void
name|doWork
parameter_list|()
block|{
comment|//
comment|// Poll the Namenode (once every 5 minutes) to find the size of the
comment|// pending edit log.
comment|//
name|long
name|period
init|=
literal|5
operator|*
literal|60
decl_stmt|;
comment|// 5 minutes
if|if
condition|(
name|checkpointPeriod
operator|<
name|period
condition|)
block|{
name|period
operator|=
name|checkpointPeriod
expr_stmt|;
block|}
while|while
condition|(
name|shouldRun
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
operator|*
name|period
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// do nothing
block|}
if|if
condition|(
operator|!
name|shouldRun
condition|)
block|{
break|break;
block|}
try|try
block|{
comment|// We may have lost our ticket since last checkpoint, log in again, just in case
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|reloginFromKeytab
argument_list|()
expr_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|long
name|size
init|=
name|namenode
operator|.
name|getEditLogSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|>=
name|checkpointSize
operator|||
name|now
operator|>=
name|lastCheckpointTime
operator|+
literal|1000
operator|*
name|checkpointPeriod
condition|)
block|{
name|doCheckpoint
argument_list|()
expr_stmt|;
name|lastCheckpointTime
operator|=
name|now
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception in doCheckpoint"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|checkpointImage
operator|.
name|getStorage
argument_list|()
operator|.
name|imageDigest
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Throwable Exception in doCheckpoint"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Download<code>fsimage</code> and<code>edits</code>    * files from the name-node.    * @return true if a new image has been downloaded and needs to be loaded    * @throws IOException    */
DECL|method|downloadCheckpointFiles (final CheckpointSignature sig )
specifier|private
name|boolean
name|downloadCheckpointFiles
parameter_list|(
specifier|final
name|CheckpointSignature
name|sig
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|Boolean
name|b
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|checkpointImage
operator|.
name|getStorage
argument_list|()
operator|.
name|cTime
operator|=
name|sig
operator|.
name|cTime
expr_stmt|;
name|checkpointImage
operator|.
name|getStorage
argument_list|()
operator|.
name|setCheckpointTime
argument_list|(
name|sig
operator|.
name|checkpointTime
argument_list|)
expr_stmt|;
comment|// get fsimage
name|String
name|fileid
decl_stmt|;
name|Collection
argument_list|<
name|File
argument_list|>
name|list
decl_stmt|;
name|File
index|[]
name|srcNames
decl_stmt|;
name|boolean
name|downloadImage
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|sig
operator|.
name|imageDigest
operator|.
name|equals
argument_list|(
name|checkpointImage
operator|.
name|getStorage
argument_list|()
operator|.
name|imageDigest
argument_list|)
condition|)
block|{
name|downloadImage
operator|=
literal|false
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Image has not changed. Will not download image."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fileid
operator|=
literal|"getimage=1"
expr_stmt|;
name|list
operator|=
name|checkpointImage
operator|.
name|getStorage
argument_list|()
operator|.
name|getFiles
argument_list|(
name|NameNodeFile
operator|.
name|IMAGE
argument_list|,
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
expr_stmt|;
name|srcNames
operator|=
name|list
operator|.
name|toArray
argument_list|(
operator|new
name|File
index|[
name|list
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
assert|assert
name|srcNames
operator|.
name|length
operator|>
literal|0
operator|:
literal|"No checkpoint targets."
assert|;
name|TransferFsImage
operator|.
name|getFileClient
argument_list|(
name|fsName
argument_list|,
name|fileid
argument_list|,
name|srcNames
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|checkpointImage
operator|.
name|getStorage
argument_list|()
operator|.
name|imageDigest
operator|=
name|sig
operator|.
name|imageDigest
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Downloaded file "
operator|+
name|srcNames
index|[
literal|0
index|]
operator|.
name|getName
argument_list|()
operator|+
literal|" size "
operator|+
name|srcNames
index|[
literal|0
index|]
operator|.
name|length
argument_list|()
operator|+
literal|" bytes."
argument_list|)
expr_stmt|;
block|}
comment|// get edits file
name|fileid
operator|=
literal|"getedit=1"
expr_stmt|;
name|list
operator|=
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
operator|.
name|getFiles
argument_list|(
name|NameNodeFile
operator|.
name|EDITS
argument_list|,
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
expr_stmt|;
name|srcNames
operator|=
name|list
operator|.
name|toArray
argument_list|(
operator|new
name|File
index|[
name|list
operator|.
name|size
argument_list|()
index|]
argument_list|)
expr_stmt|;
empty_stmt|;
assert|assert
name|srcNames
operator|.
name|length
operator|>
literal|0
operator|:
literal|"No checkpoint targets."
assert|;
name|TransferFsImage
operator|.
name|getFileClient
argument_list|(
name|fsName
argument_list|,
name|fileid
argument_list|,
name|srcNames
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Downloaded file "
operator|+
name|srcNames
index|[
literal|0
index|]
operator|.
name|getName
argument_list|()
operator|+
literal|" size "
operator|+
name|srcNames
index|[
literal|0
index|]
operator|.
name|length
argument_list|()
operator|+
literal|" bytes."
argument_list|)
expr_stmt|;
name|checkpointImage
operator|.
name|checkpointUploadDone
argument_list|()
expr_stmt|;
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|downloadImage
argument_list|)
return|;
block|}
block|}
argument_list|)
decl_stmt|;
return|return
name|b
operator|.
name|booleanValue
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|getNameNodeAddress ()
name|InetSocketAddress
name|getNameNodeAddress
parameter_list|()
block|{
return|return
name|nameNodeAddr
return|;
block|}
comment|/**    * Copy the new fsimage into the NameNode    */
DECL|method|putFSImage (CheckpointSignature sig)
specifier|private
name|void
name|putFSImage
parameter_list|(
name|CheckpointSignature
name|sig
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|fileid
init|=
literal|"putimage=1&port="
operator|+
name|imagePort
operator|+
literal|"&machine="
operator|+
name|infoBindAddress
operator|+
literal|"&token="
operator|+
name|sig
operator|.
name|toString
argument_list|()
operator|+
literal|"&newChecksum="
operator|+
name|checkpointImage
operator|.
name|getStorage
argument_list|()
operator|.
name|getImageDigest
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Posted URL "
operator|+
name|fsName
operator|+
name|fileid
argument_list|)
expr_stmt|;
name|TransferFsImage
operator|.
name|getFileClient
argument_list|(
name|fsName
argument_list|,
name|fileid
argument_list|,
operator|(
name|File
index|[]
operator|)
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns the Jetty server that the Namenode is listening on.    */
DECL|method|getInfoServer ()
specifier|private
name|String
name|getInfoServer
parameter_list|()
throws|throws
name|IOException
block|{
name|URI
name|fsName
init|=
name|FileSystem
operator|.
name|getDefaultUri
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|FSConstants
operator|.
name|HDFS_URI_SCHEME
operator|.
name|equalsIgnoreCase
argument_list|(
name|fsName
operator|.
name|getScheme
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"This is not a DFS"
argument_list|)
throw|;
block|}
name|String
name|configuredAddress
init|=
name|DFSUtil
operator|.
name|getInfoServer
argument_list|(
literal|null
argument_list|,
name|conf
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|InetSocketAddress
name|sockAddr
init|=
name|NetUtils
operator|.
name|createSocketAddr
argument_list|(
name|configuredAddress
argument_list|)
decl_stmt|;
if|if
condition|(
name|sockAddr
operator|.
name|getAddress
argument_list|()
operator|.
name|isAnyLocalAddress
argument_list|()
condition|)
block|{
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot use a wildcard address with security. "
operator|+
literal|"Must explicitly set bind address for Kerberos"
argument_list|)
throw|;
block|}
return|return
name|fsName
operator|.
name|getHost
argument_list|()
operator|+
literal|":"
operator|+
name|sockAddr
operator|.
name|getPort
argument_list|()
return|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"configuredAddress = "
operator|+
name|configuredAddress
argument_list|)
expr_stmt|;
block|}
return|return
name|configuredAddress
return|;
block|}
block|}
comment|/**    * Create a new checkpoint    * @return if the image is fetched from primary or not    */
DECL|method|doCheckpoint ()
name|boolean
name|doCheckpoint
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Do the required initialization of the merge work area.
name|startCheckpoint
argument_list|()
expr_stmt|;
comment|// Tell the namenode to start logging transactions in a new edit file
comment|// Returns a token that would be used to upload the merged image.
name|CheckpointSignature
name|sig
init|=
name|namenode
operator|.
name|rollEditLog
argument_list|()
decl_stmt|;
comment|// error simulation code for junit test
if|if
condition|(
name|ErrorSimulator
operator|.
name|getErrorSimulation
argument_list|(
literal|0
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Simulating error0 "
operator|+
literal|"after creating edits.new"
argument_list|)
throw|;
block|}
name|boolean
name|loadImage
init|=
name|downloadCheckpointFiles
argument_list|(
name|sig
argument_list|)
decl_stmt|;
comment|// Fetch fsimage and edits
name|doMerge
argument_list|(
name|sig
argument_list|,
name|loadImage
argument_list|)
expr_stmt|;
comment|// Do the merge
comment|//
comment|// Upload the new image into the NameNode. Then tell the Namenode
comment|// to make this new uploaded image as the most current image.
comment|//
name|putFSImage
argument_list|(
name|sig
argument_list|)
expr_stmt|;
comment|// error simulation code for junit test
if|if
condition|(
name|ErrorSimulator
operator|.
name|getErrorSimulation
argument_list|(
literal|1
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Simulating error1 "
operator|+
literal|"after uploading new image to NameNode"
argument_list|)
throw|;
block|}
name|namenode
operator|.
name|rollFsImage
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|checkpointImage
operator|.
name|endCheckpoint
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"Checkpoint done. New Image Size: "
operator|+
name|checkpointImage
operator|.
name|getStorage
argument_list|()
operator|.
name|getFsImageName
argument_list|()
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|loadImage
return|;
block|}
DECL|method|startCheckpoint ()
specifier|private
name|void
name|startCheckpoint
parameter_list|()
throws|throws
name|IOException
block|{
name|checkpointImage
operator|.
name|getStorage
argument_list|()
operator|.
name|unlockAll
argument_list|()
expr_stmt|;
name|checkpointImage
operator|.
name|getEditLog
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
name|checkpointImage
operator|.
name|recoverCreate
argument_list|(
name|checkpointDirs
argument_list|,
name|checkpointEditsDirs
argument_list|)
expr_stmt|;
name|checkpointImage
operator|.
name|startCheckpoint
argument_list|()
expr_stmt|;
block|}
comment|/**    * Merge downloaded image and edits and write the new image into    * current storage directory.    */
DECL|method|doMerge (CheckpointSignature sig, boolean loadImage)
specifier|private
name|void
name|doMerge
parameter_list|(
name|CheckpointSignature
name|sig
parameter_list|,
name|boolean
name|loadImage
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|loadImage
condition|)
block|{
name|namesystem
operator|=
operator|new
name|FSNamesystem
argument_list|(
name|checkpointImage
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
assert|assert
name|namesystem
operator|.
name|dir
operator|.
name|fsImage
operator|==
name|checkpointImage
assert|;
name|checkpointImage
operator|.
name|doMerge
argument_list|(
name|sig
argument_list|,
name|loadImage
argument_list|)
expr_stmt|;
block|}
comment|/**    * @param argv The parameters passed to this program.    * @exception Exception if the filesystem does not exist.    * @return 0 on success, non zero on error.    */
DECL|method|processArgs (String[] argv)
specifier|private
name|int
name|processArgs
parameter_list|(
name|String
index|[]
name|argv
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|argv
operator|.
name|length
operator|<
literal|1
condition|)
block|{
name|printUsage
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|int
name|exitCode
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|String
name|cmd
init|=
name|argv
index|[
name|i
operator|++
index|]
decl_stmt|;
comment|//
comment|// verify that we have enough command line parameters
comment|//
if|if
condition|(
literal|"-geteditsize"
operator|.
name|equals
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
if|if
condition|(
name|argv
operator|.
name|length
operator|!=
literal|1
condition|)
block|{
name|printUsage
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
name|exitCode
return|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"-checkpoint"
operator|.
name|equals
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
if|if
condition|(
name|argv
operator|.
name|length
operator|!=
literal|1
operator|&&
name|argv
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
name|printUsage
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
name|exitCode
return|;
block|}
if|if
condition|(
name|argv
operator|.
name|length
operator|==
literal|2
operator|&&
operator|!
literal|"force"
operator|.
name|equals
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|printUsage
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
name|exitCode
return|;
block|}
block|}
name|exitCode
operator|=
literal|0
expr_stmt|;
try|try
block|{
if|if
condition|(
literal|"-checkpoint"
operator|.
name|equals
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|long
name|size
init|=
name|namenode
operator|.
name|getEditLogSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|>=
name|checkpointSize
operator|||
name|argv
operator|.
name|length
operator|==
literal|2
operator|&&
literal|"force"
operator|.
name|equals
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|doCheckpoint
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"EditLog size "
operator|+
name|size
operator|+
literal|" bytes is "
operator|+
literal|"smaller than configured checkpoint "
operator|+
literal|"size "
operator|+
name|checkpointSize
operator|+
literal|" bytes."
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Skipping checkpoint."
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"-geteditsize"
operator|.
name|equals
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|long
name|size
init|=
name|namenode
operator|.
name|getEditLogSize
argument_list|()
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"EditLog size is "
operator|+
name|size
operator|+
literal|" bytes"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exitCode
operator|=
operator|-
literal|1
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|cmd
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
operator|+
literal|": Unknown command"
argument_list|)
expr_stmt|;
name|printUsage
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|RemoteException
name|e
parameter_list|)
block|{
comment|//
comment|// This is a error returned by hadoop server. Print
comment|// out the first line of the error mesage, ignore the stack trace.
name|exitCode
operator|=
operator|-
literal|1
expr_stmt|;
try|try
block|{
name|String
index|[]
name|content
decl_stmt|;
name|content
operator|=
name|e
operator|.
name|getLocalizedMessage
argument_list|()
operator|.
name|split
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|cmd
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
operator|+
literal|": "
operator|+
name|content
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|cmd
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
operator|+
literal|": "
operator|+
name|ex
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|//
comment|// IO exception encountered locally.
comment|//
name|exitCode
operator|=
operator|-
literal|1
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|cmd
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
operator|+
literal|": "
operator|+
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// Does the RPC connection need to be closed?
block|}
return|return
name|exitCode
return|;
block|}
comment|/**    * Displays format of commands.    * @param cmd The command that is being executed.    */
DECL|method|printUsage (String cmd)
specifier|private
name|void
name|printUsage
parameter_list|(
name|String
name|cmd
parameter_list|)
block|{
if|if
condition|(
literal|"-geteditsize"
operator|.
name|equals
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: java SecondaryNameNode"
operator|+
literal|" [-geteditsize]"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"-checkpoint"
operator|.
name|equals
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: java SecondaryNameNode"
operator|+
literal|" [-checkpoint [force]]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Usage: java SecondaryNameNode "
operator|+
literal|"[-checkpoint [force]] "
operator|+
literal|"[-geteditsize] "
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * main() has some simple utility methods.    * @param argv Command line parameters.    * @exception Exception if the filesystem does not exist.    */
DECL|method|main (String[] argv)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|argv
parameter_list|)
throws|throws
name|Exception
block|{
name|StringUtils
operator|.
name|startupShutdownMessage
argument_list|(
name|SecondaryNameNode
operator|.
name|class
argument_list|,
name|argv
argument_list|,
name|LOG
argument_list|)
expr_stmt|;
name|Configuration
name|tconf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
if|if
condition|(
name|argv
operator|.
name|length
operator|>=
literal|1
condition|)
block|{
name|SecondaryNameNode
name|secondary
init|=
operator|new
name|SecondaryNameNode
argument_list|(
name|tconf
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
name|secondary
operator|.
name|processArgs
argument_list|(
name|argv
argument_list|)
decl_stmt|;
name|System
operator|.
name|exit
argument_list|(
name|ret
argument_list|)
expr_stmt|;
block|}
comment|// Create a never ending deamon
name|Daemon
name|checkpointThread
init|=
operator|new
name|Daemon
argument_list|(
operator|new
name|SecondaryNameNode
argument_list|(
name|tconf
argument_list|)
argument_list|)
decl_stmt|;
name|checkpointThread
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|class|CheckpointStorage
specifier|static
class|class
name|CheckpointStorage
extends|extends
name|FSImage
block|{
comment|/**      */
DECL|method|CheckpointStorage (Configuration conf)
name|CheckpointStorage
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**      * Analyze checkpoint directories.      * Create directories if they do not exist.      * Recover from an unsuccessful checkpoint is necessary.       *       * @param dataDirs      * @param editsDirs      * @throws IOException      */
DECL|method|recoverCreate (Collection<URI> dataDirs, Collection<URI> editsDirs)
name|void
name|recoverCreate
parameter_list|(
name|Collection
argument_list|<
name|URI
argument_list|>
name|dataDirs
parameter_list|,
name|Collection
argument_list|<
name|URI
argument_list|>
name|editsDirs
parameter_list|)
throws|throws
name|IOException
block|{
name|Collection
argument_list|<
name|URI
argument_list|>
name|tempDataDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|URI
argument_list|>
argument_list|(
name|dataDirs
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|URI
argument_list|>
name|tempEditsDirs
init|=
operator|new
name|ArrayList
argument_list|<
name|URI
argument_list|>
argument_list|(
name|editsDirs
argument_list|)
decl_stmt|;
name|storage
operator|.
name|close
argument_list|()
expr_stmt|;
name|storage
operator|.
name|setStorageDirectories
argument_list|(
name|tempDataDirs
argument_list|,
name|tempEditsDirs
argument_list|)
expr_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|boolean
name|isAccessible
init|=
literal|true
decl_stmt|;
try|try
block|{
comment|// create directories if don't exist yet
if|if
condition|(
operator|!
name|sd
operator|.
name|getRoot
argument_list|()
operator|.
name|mkdirs
argument_list|()
condition|)
block|{
comment|// do nothing, directory is already created
block|}
block|}
catch|catch
parameter_list|(
name|SecurityException
name|se
parameter_list|)
block|{
name|isAccessible
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isAccessible
condition|)
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
literal|"cannot access checkpoint directory."
argument_list|)
throw|;
name|StorageState
name|curState
decl_stmt|;
try|try
block|{
name|curState
operator|=
name|sd
operator|.
name|analyzeStorage
argument_list|(
name|HdfsConstants
operator|.
name|StartupOption
operator|.
name|REGULAR
argument_list|)
expr_stmt|;
comment|// sd is locked but not opened
switch|switch
condition|(
name|curState
condition|)
block|{
case|case
name|NON_EXISTENT
case|:
comment|// fail if any of the configured checkpoint dirs are inaccessible
throw|throw
operator|new
name|InconsistentFSStateException
argument_list|(
name|sd
operator|.
name|getRoot
argument_list|()
argument_list|,
literal|"checkpoint directory does not exist or is not accessible."
argument_list|)
throw|;
case|case
name|NOT_FORMATTED
case|:
break|break;
comment|// it's ok since initially there is no current and VERSION
case|case
name|NORMAL
case|:
break|break;
default|default:
comment|// recovery is possible
name|sd
operator|.
name|doRecover
argument_list|(
name|curState
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|sd
operator|.
name|unlock
argument_list|()
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
block|}
block|}
comment|/**      * Prepare directories for a new checkpoint.      *<p>      * Rename<code>current</code> to<code>lastcheckpoint.tmp</code>      * and recreate<code>current</code>.      * @throws IOException      */
DECL|method|startCheckpoint ()
name|void
name|startCheckpoint
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|storage
operator|.
name|moveCurrent
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|endCheckpoint ()
name|void
name|endCheckpoint
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|storage
operator|.
name|dirIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|StorageDirectory
name|sd
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|storage
operator|.
name|moveLastCheckpoint
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Merge image and edits, and verify consistency with the signature.      */
DECL|method|doMerge (CheckpointSignature sig, boolean loadImage)
specifier|private
name|void
name|doMerge
parameter_list|(
name|CheckpointSignature
name|sig
parameter_list|,
name|boolean
name|loadImage
parameter_list|)
throws|throws
name|IOException
block|{
name|getEditLog
argument_list|()
operator|.
name|open
argument_list|()
expr_stmt|;
name|StorageDirectory
name|sdName
init|=
literal|null
decl_stmt|;
name|StorageDirectory
name|sdEdits
init|=
literal|null
decl_stmt|;
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|loadImage
condition|)
block|{
name|it
operator|=
name|getStorage
argument_list|()
operator|.
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|IMAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
name|sdName
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|sdName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not locate checkpoint fsimage"
argument_list|)
throw|;
block|}
block|}
name|it
operator|=
name|getStorage
argument_list|()
operator|.
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
name|sdEdits
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|sdEdits
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not locate checkpoint edits"
argument_list|)
throw|;
if|if
condition|(
name|loadImage
condition|)
block|{
comment|// to avoid assert in loadFSImage()
name|this
operator|.
name|getStorage
argument_list|()
operator|.
name|layoutVersion
operator|=
operator|-
literal|1
expr_stmt|;
name|getStorage
argument_list|()
expr_stmt|;
name|loadFSImage
argument_list|(
name|NNStorage
operator|.
name|getStorageFile
argument_list|(
name|sdName
argument_list|,
name|NameNodeFile
operator|.
name|IMAGE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|loadFSEdits
argument_list|(
name|sdEdits
argument_list|)
expr_stmt|;
name|storage
operator|.
name|setClusterID
argument_list|(
name|sig
operator|.
name|getClusterID
argument_list|()
argument_list|)
expr_stmt|;
name|storage
operator|.
name|setBlockPoolID
argument_list|(
name|sig
operator|.
name|getBlockpoolID
argument_list|()
argument_list|)
expr_stmt|;
name|sig
operator|.
name|validateStorageInfo
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|saveNamespace
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

