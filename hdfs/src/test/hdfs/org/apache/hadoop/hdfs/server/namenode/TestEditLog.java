begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs.server.namenode
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
package|;
end_package

begin_import
import|import
name|junit
operator|.
name|framework
operator|.
name|TestCase
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|impl
operator|.
name|Log4JLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ChecksumException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSConfigKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|HdfsConfiguration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|MiniDFSCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|HdfsFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|EditLogFileInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|Storage
operator|.
name|StorageDirectory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorage
operator|.
name|NameNodeDirType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NNStorage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|GenericTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Level
import|;
end_import

begin_import
import|import
name|org
operator|.
name|aspectj
operator|.
name|util
operator|.
name|FileUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|mockito
operator|.
name|Mockito
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|MetricsAsserts
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * This class tests the creation and validation of a checkpoint.  */
end_comment

begin_class
DECL|class|TestEditLog
specifier|public
class|class
name|TestEditLog
extends|extends
name|TestCase
block|{
static|static
block|{
operator|(
operator|(
name|Log4JLogger
operator|)
name|FSEditLog
operator|.
name|LOG
operator|)
operator|.
name|getLogger
argument_list|()
operator|.
name|setLevel
argument_list|(
name|Level
operator|.
name|ALL
argument_list|)
expr_stmt|;
block|}
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|TestEditLog
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|NUM_DATA_NODES
specifier|static
specifier|final
name|int
name|NUM_DATA_NODES
init|=
literal|0
decl_stmt|;
comment|// This test creates NUM_THREADS threads and each thread does
comment|// 2 * NUM_TRANSACTIONS Transactions concurrently.
DECL|field|NUM_TRANSACTIONS
specifier|static
specifier|final
name|int
name|NUM_TRANSACTIONS
init|=
literal|100
decl_stmt|;
DECL|field|NUM_THREADS
specifier|static
specifier|final
name|int
name|NUM_THREADS
init|=
literal|100
decl_stmt|;
DECL|field|TEST_DIR
specifier|private
specifier|static
specifier|final
name|File
name|TEST_DIR
init|=
operator|new
name|File
argument_list|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"test.build.data"
argument_list|,
literal|"build/test/data"
argument_list|)
argument_list|)
decl_stmt|;
comment|/** An edits log with 3 edits from 0.20 - the result of    * a fresh namesystem followed by hadoop fs -touchz /myfile */
DECL|field|HADOOP20_SOME_EDITS
specifier|static
specifier|final
name|byte
index|[]
name|HADOOP20_SOME_EDITS
init|=
name|StringUtils
operator|.
name|hexStringToByte
argument_list|(
operator|(
literal|"ffff ffed 0a00 0000 0000 03fa e100 0000"
operator|+
literal|"0005 0007 2f6d 7966 696c 6500 0133 000d"
operator|+
literal|"3132 3932 3331 3634 3034 3138 3400 0d31"
operator|+
literal|"3239 3233 3136 3430 3431 3834 0009 3133"
operator|+
literal|"3432 3137 3732 3800 0000 0004 746f 6464"
operator|+
literal|"0a73 7570 6572 6772 6f75 7001 a400 1544"
operator|+
literal|"4653 436c 6965 6e74 5f2d 3136 3136 3535"
operator|+
literal|"3738 3931 000b 3137 322e 3239 2e35 2e33"
operator|+
literal|"3209 0000 0005 0007 2f6d 7966 696c 6500"
operator|+
literal|"0133 000d 3132 3932 3331 3634 3034 3138"
operator|+
literal|"3400 0d31 3239 3233 3136 3430 3431 3834"
operator|+
literal|"0009 3133 3432 3137 3732 3800 0000 0004"
operator|+
literal|"746f 6464 0a73 7570 6572 6772 6f75 7001"
operator|+
literal|"a4ff 0000 0000 0000 0000 0000 0000 0000"
operator|)
operator|.
name|replace
argument_list|(
literal|" "
argument_list|,
literal|""
argument_list|)
argument_list|)
decl_stmt|;
DECL|field|TRAILER_BYTE
specifier|static
specifier|final
name|byte
name|TRAILER_BYTE
init|=
name|FSEditLogOpCodes
operator|.
name|OP_INVALID
operator|.
name|getOpCode
argument_list|()
decl_stmt|;
DECL|field|CHECKPOINT_ON_STARTUP_MIN_TXNS
specifier|private
specifier|static
specifier|final
name|int
name|CHECKPOINT_ON_STARTUP_MIN_TXNS
init|=
literal|100
decl_stmt|;
comment|//
comment|// an object that does a bunch of transactions
comment|//
DECL|class|Transactions
specifier|static
class|class
name|Transactions
implements|implements
name|Runnable
block|{
DECL|field|namesystem
name|FSNamesystem
name|namesystem
decl_stmt|;
DECL|field|numTransactions
name|int
name|numTransactions
decl_stmt|;
DECL|field|replication
name|short
name|replication
init|=
literal|3
decl_stmt|;
DECL|field|blockSize
name|long
name|blockSize
init|=
literal|64
decl_stmt|;
DECL|method|Transactions (FSNamesystem ns, int num)
name|Transactions
parameter_list|(
name|FSNamesystem
name|ns
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|namesystem
operator|=
name|ns
expr_stmt|;
name|numTransactions
operator|=
name|num
expr_stmt|;
block|}
comment|// add a bunch of transactions.
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|PermissionStatus
name|p
init|=
name|namesystem
operator|.
name|createFsOwnerPermissions
argument_list|(
operator|new
name|FsPermission
argument_list|(
operator|(
name|short
operator|)
literal|0777
argument_list|)
argument_list|)
decl_stmt|;
name|FSEditLog
name|editLog
init|=
name|namesystem
operator|.
name|getEditLog
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTransactions
condition|;
name|i
operator|++
control|)
block|{
name|INodeFileUnderConstruction
name|inode
init|=
operator|new
name|INodeFileUnderConstruction
argument_list|(
name|p
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|editLog
operator|.
name|logOpenFile
argument_list|(
literal|"/filename"
operator|+
name|i
argument_list|,
name|inode
argument_list|)
expr_stmt|;
name|editLog
operator|.
name|logCloseFile
argument_list|(
literal|"/filename"
operator|+
name|i
argument_list|,
name|inode
argument_list|)
expr_stmt|;
name|editLog
operator|.
name|logSync
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Test case for an empty edit log from a prior version of Hadoop.    */
DECL|method|testPreTxIdEditLogNoEdits ()
specifier|public
name|void
name|testPreTxIdEditLogNoEdits
parameter_list|()
throws|throws
name|Exception
block|{
name|FSNamesystem
name|namesys
init|=
name|Mockito
operator|.
name|mock
argument_list|(
name|FSNamesystem
operator|.
name|class
argument_list|)
decl_stmt|;
name|namesys
operator|.
name|dir
operator|=
name|Mockito
operator|.
name|mock
argument_list|(
name|FSDirectory
operator|.
name|class
argument_list|)
expr_stmt|;
name|int
name|numEdits
init|=
name|testLoad
argument_list|(
name|StringUtils
operator|.
name|hexStringToByte
argument_list|(
literal|"ffffffed"
argument_list|)
argument_list|,
comment|// just version number
name|namesys
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|numEdits
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test case for loading a very simple edit log from a format    * prior to the inclusion of edit transaction IDs in the log.    */
DECL|method|testPreTxidEditLogWithEdits ()
specifier|public
name|void
name|testPreTxidEditLogWithEdits
parameter_list|()
throws|throws
name|Exception
block|{
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
literal|0
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
specifier|final
name|FSNamesystem
name|namesystem
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
name|int
name|numEdits
init|=
name|testLoad
argument_list|(
name|HADOOP20_SOME_EDITS
argument_list|,
name|namesystem
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|numEdits
argument_list|)
expr_stmt|;
comment|// Sanity check the edit
name|HdfsFileStatus
name|fileInfo
init|=
name|namesystem
operator|.
name|getFileInfo
argument_list|(
literal|"/myfile"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"supergroup"
argument_list|,
name|fileInfo
operator|.
name|getGroup
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|fileInfo
operator|.
name|getReplication
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|testLoad (byte[] data, FSNamesystem namesys)
specifier|private
name|int
name|testLoad
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|FSNamesystem
name|namesys
parameter_list|)
throws|throws
name|IOException
block|{
name|FSEditLogLoader
name|loader
init|=
operator|new
name|FSEditLogLoader
argument_list|(
name|namesys
argument_list|)
decl_stmt|;
return|return
name|loader
operator|.
name|loadFSEdits
argument_list|(
operator|new
name|EditLogByteInputStream
argument_list|(
name|data
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
comment|/**    * Simple test for writing to and rolling the edit log.    */
DECL|method|testSimpleEditLog ()
specifier|public
name|void
name|testSimpleEditLog
parameter_list|()
throws|throws
name|IOException
block|{
comment|// start a cluster
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|FileSystem
name|fileSys
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fileSys
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
specifier|final
name|FSNamesystem
name|namesystem
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
name|FSImage
name|fsimage
init|=
name|namesystem
operator|.
name|getFSImage
argument_list|()
decl_stmt|;
specifier|final
name|FSEditLog
name|editLog
init|=
name|fsimage
operator|.
name|getEditLog
argument_list|()
decl_stmt|;
name|assertExistsInStorageDirs
argument_list|(
name|cluster
argument_list|,
name|NameNodeDirType
operator|.
name|EDITS
argument_list|,
name|NNStorage
operator|.
name|getInProgressEditsFileName
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|editLog
operator|.
name|logSetReplication
argument_list|(
literal|"fakefile"
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|)
expr_stmt|;
name|editLog
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|editLog
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
name|assertExistsInStorageDirs
argument_list|(
name|cluster
argument_list|,
name|NameNodeDirType
operator|.
name|EDITS
argument_list|,
name|NNStorage
operator|.
name|getFinalizedEditsFileName
argument_list|(
literal|1
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|assertExistsInStorageDirs
argument_list|(
name|cluster
argument_list|,
name|NameNodeDirType
operator|.
name|EDITS
argument_list|,
name|NNStorage
operator|.
name|getInProgressEditsFileName
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|editLog
operator|.
name|logSetReplication
argument_list|(
literal|"fakefile"
argument_list|,
operator|(
name|short
operator|)
literal|2
argument_list|)
expr_stmt|;
name|editLog
operator|.
name|logSync
argument_list|()
expr_stmt|;
name|editLog
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|fileSys
operator|!=
literal|null
condition|)
name|fileSys
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Tests transaction logging in dfs.    */
DECL|method|testMultiThreadedEditLog ()
specifier|public
name|void
name|testMultiThreadedEditLog
parameter_list|()
throws|throws
name|IOException
block|{
name|testEditLog
argument_list|(
literal|2048
argument_list|)
expr_stmt|;
comment|// force edit buffer to automatically sync on each log of edit log entry
name|testEditLog
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|assertExistsInStorageDirs (MiniDFSCluster cluster, NameNodeDirType dirType, String filename)
specifier|private
name|void
name|assertExistsInStorageDirs
parameter_list|(
name|MiniDFSCluster
name|cluster
parameter_list|,
name|NameNodeDirType
name|dirType
parameter_list|,
name|String
name|filename
parameter_list|)
block|{
name|NNStorage
name|storage
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
operator|.
name|getFSImage
argument_list|()
operator|.
name|getStorage
argument_list|()
decl_stmt|;
for|for
control|(
name|StorageDirectory
name|sd
range|:
name|storage
operator|.
name|dirIterable
argument_list|(
name|dirType
argument_list|)
control|)
block|{
name|File
name|f
init|=
operator|new
name|File
argument_list|(
name|sd
operator|.
name|getCurrentDir
argument_list|()
argument_list|,
name|filename
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Expect that "
operator|+
name|f
operator|+
literal|" exists"
argument_list|,
name|f
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Test edit log with different initial buffer size    *     * @param initialSize initial edit log buffer size    * @throws IOException    */
DECL|method|testEditLog (int initialSize)
specifier|private
name|void
name|testEditLog
parameter_list|(
name|int
name|initialSize
parameter_list|)
throws|throws
name|IOException
block|{
comment|// start a cluster
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|FileSystem
name|fileSys
init|=
literal|null
decl_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fileSys
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
specifier|final
name|FSNamesystem
name|namesystem
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|URI
argument_list|>
name|it
init|=
name|cluster
operator|.
name|getNameDirs
argument_list|(
literal|0
argument_list|)
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|File
name|dir
init|=
operator|new
name|File
argument_list|(
name|it
operator|.
name|next
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
name|FSImage
name|fsimage
init|=
name|namesystem
operator|.
name|getFSImage
argument_list|()
decl_stmt|;
name|FSEditLog
name|editLog
init|=
name|fsimage
operator|.
name|getEditLog
argument_list|()
decl_stmt|;
comment|// set small size of flush buffer
name|editLog
operator|.
name|setOutputBufferCapacity
argument_list|(
name|initialSize
argument_list|)
expr_stmt|;
comment|// Roll log so new output buffer size takes effect
comment|// we should now be writing to edits_inprogress_3
name|fsimage
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
comment|// Create threads and make them run transactions concurrently.
name|Thread
name|threadId
index|[]
init|=
operator|new
name|Thread
index|[
name|NUM_THREADS
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_THREADS
condition|;
name|i
operator|++
control|)
block|{
name|Transactions
name|trans
init|=
operator|new
name|Transactions
argument_list|(
name|namesystem
argument_list|,
name|NUM_TRANSACTIONS
argument_list|)
decl_stmt|;
name|threadId
index|[
name|i
index|]
operator|=
operator|new
name|Thread
argument_list|(
name|trans
argument_list|,
literal|"TransactionThread-"
operator|+
name|i
argument_list|)
expr_stmt|;
name|threadId
index|[
name|i
index|]
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|// wait for all transactions to get over
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_THREADS
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|threadId
index|[
name|i
index|]
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|i
operator|--
expr_stmt|;
comment|// retry
block|}
block|}
comment|// Roll another time to finalize edits_inprogress_3
name|fsimage
operator|.
name|rollEditLog
argument_list|()
expr_stmt|;
name|long
name|expectedTxns
init|=
operator|(
name|NUM_THREADS
operator|*
literal|2
operator|*
name|NUM_TRANSACTIONS
operator|)
operator|+
literal|2
decl_stmt|;
comment|// +2 for start/end txns
comment|// Verify that we can read in all the transactions that we have written.
comment|// If there were any corruptions, it is likely that the reading in
comment|// of these transactions will throw an exception.
comment|//
for|for
control|(
name|Iterator
argument_list|<
name|StorageDirectory
argument_list|>
name|it
init|=
name|fsimage
operator|.
name|getStorage
argument_list|()
operator|.
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|FSEditLogLoader
name|loader
init|=
operator|new
name|FSEditLogLoader
argument_list|(
name|namesystem
argument_list|)
decl_stmt|;
name|File
name|editFile
init|=
name|NNStorage
operator|.
name|getFinalizedEditsFile
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|,
literal|3
argument_list|,
literal|3
operator|+
name|expectedTxns
operator|-
literal|1
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Expect "
operator|+
name|editFile
operator|+
literal|" exists"
argument_list|,
name|editFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Verifying file: "
operator|+
name|editFile
argument_list|)
expr_stmt|;
name|int
name|numEdits
init|=
name|loader
operator|.
name|loadFSEdits
argument_list|(
operator|new
name|EditLogFileInputStream
argument_list|(
name|editFile
argument_list|)
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|int
name|numLeases
init|=
name|namesystem
operator|.
name|leaseManager
operator|.
name|countLease
argument_list|()
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Number of outstanding leases "
operator|+
name|numLeases
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|numLeases
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Verification for "
operator|+
name|editFile
operator|+
literal|" failed. "
operator|+
literal|"Expected "
operator|+
name|expectedTxns
operator|+
literal|" transactions. "
operator|+
literal|"Found "
operator|+
name|numEdits
operator|+
literal|" transactions."
argument_list|,
name|numEdits
operator|==
name|expectedTxns
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
try|try
block|{
if|if
condition|(
name|fileSys
operator|!=
literal|null
condition|)
name|fileSys
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Couldn't shut down cleanly"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|doLogEdit (ExecutorService exec, final FSEditLog log, final String filename)
specifier|private
name|void
name|doLogEdit
parameter_list|(
name|ExecutorService
name|exec
parameter_list|,
specifier|final
name|FSEditLog
name|log
parameter_list|,
specifier|final
name|String
name|filename
parameter_list|)
throws|throws
name|Exception
block|{
name|exec
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|call
parameter_list|()
block|{
name|log
operator|.
name|logSetReplication
argument_list|(
name|filename
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
DECL|method|doCallLogSync (ExecutorService exec, final FSEditLog log)
specifier|private
name|void
name|doCallLogSync
parameter_list|(
name|ExecutorService
name|exec
parameter_list|,
specifier|final
name|FSEditLog
name|log
parameter_list|)
throws|throws
name|Exception
block|{
name|exec
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|call
parameter_list|()
block|{
name|log
operator|.
name|logSync
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
DECL|method|doCallLogSyncAll (ExecutorService exec, final FSEditLog log)
specifier|private
name|void
name|doCallLogSyncAll
parameter_list|(
name|ExecutorService
name|exec
parameter_list|,
specifier|final
name|FSEditLog
name|log
parameter_list|)
throws|throws
name|Exception
block|{
name|exec
operator|.
name|submit
argument_list|(
operator|new
name|Callable
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|log
operator|.
name|logSyncAll
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
DECL|method|testSyncBatching ()
specifier|public
name|void
name|testSyncBatching
parameter_list|()
throws|throws
name|Exception
block|{
comment|// start a cluster
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|FileSystem
name|fileSys
init|=
literal|null
decl_stmt|;
name|ExecutorService
name|threadA
init|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|()
decl_stmt|;
name|ExecutorService
name|threadB
init|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|()
decl_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fileSys
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
specifier|final
name|FSNamesystem
name|namesystem
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
name|FSImage
name|fsimage
init|=
name|namesystem
operator|.
name|getFSImage
argument_list|()
decl_stmt|;
specifier|final
name|FSEditLog
name|editLog
init|=
name|fsimage
operator|.
name|getEditLog
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|"should start with only the BEGIN_LOG_SEGMENT txn synced"
argument_list|,
literal|1
argument_list|,
name|editLog
operator|.
name|getSyncTxId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Log an edit from thread A
name|doLogEdit
argument_list|(
name|threadA
argument_list|,
name|editLog
argument_list|,
literal|"thread-a 1"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"logging edit without syncing should do not affect txid"
argument_list|,
literal|1
argument_list|,
name|editLog
operator|.
name|getSyncTxId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Log an edit from thread B
name|doLogEdit
argument_list|(
name|threadB
argument_list|,
name|editLog
argument_list|,
literal|"thread-b 1"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"logging edit without syncing should do not affect txid"
argument_list|,
literal|1
argument_list|,
name|editLog
operator|.
name|getSyncTxId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Now ask to sync edit from B, which should sync both edits.
name|doCallLogSync
argument_list|(
name|threadB
argument_list|,
name|editLog
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"logSync from second thread should bump txid up to 2"
argument_list|,
literal|3
argument_list|,
name|editLog
operator|.
name|getSyncTxId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Now ask to sync edit from A, which was already batched in - thus
comment|// it should increment the batch count metric
name|doCallLogSync
argument_list|(
name|threadA
argument_list|,
name|editLog
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"logSync from first thread shouldn't change txid"
argument_list|,
literal|3
argument_list|,
name|editLog
operator|.
name|getSyncTxId
argument_list|()
argument_list|)
expr_stmt|;
comment|//Should have incremented the batch count exactly once
name|assertCounter
argument_list|(
literal|"TransactionsBatchedInSync"
argument_list|,
literal|1L
argument_list|,
name|getMetrics
argument_list|(
literal|"NameNodeActivity"
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|threadA
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|threadB
operator|.
name|shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
name|fileSys
operator|!=
literal|null
condition|)
name|fileSys
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Test what happens with the following sequence:    *    *  Thread A writes edit    *  Thread B calls logSyncAll    *           calls close() on stream    *  Thread A calls logSync    *    * This sequence is legal and can occur if enterSafeMode() is closely    * followed by saveNamespace.    */
DECL|method|testBatchedSyncWithClosedLogs ()
specifier|public
name|void
name|testBatchedSyncWithClosedLogs
parameter_list|()
throws|throws
name|Exception
block|{
comment|// start a cluster
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|FileSystem
name|fileSys
init|=
literal|null
decl_stmt|;
name|ExecutorService
name|threadA
init|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|()
decl_stmt|;
name|ExecutorService
name|threadB
init|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|()
decl_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fileSys
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
specifier|final
name|FSNamesystem
name|namesystem
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
name|FSImage
name|fsimage
init|=
name|namesystem
operator|.
name|getFSImage
argument_list|()
decl_stmt|;
specifier|final
name|FSEditLog
name|editLog
init|=
name|fsimage
operator|.
name|getEditLog
argument_list|()
decl_stmt|;
comment|// Log an edit from thread A
name|doLogEdit
argument_list|(
name|threadA
argument_list|,
name|editLog
argument_list|,
literal|"thread-a 1"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"logging edit without syncing should do not affect txid"
argument_list|,
literal|1
argument_list|,
name|editLog
operator|.
name|getSyncTxId
argument_list|()
argument_list|)
expr_stmt|;
comment|// logSyncAll in Thread B
name|doCallLogSyncAll
argument_list|(
name|threadB
argument_list|,
name|editLog
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"logSyncAll should sync thread A's transaction"
argument_list|,
literal|2
argument_list|,
name|editLog
operator|.
name|getSyncTxId
argument_list|()
argument_list|)
expr_stmt|;
comment|// Close edit log
name|editLog
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Ask thread A to finish sync (which should be a no-op)
name|doCallLogSync
argument_list|(
name|threadA
argument_list|,
name|editLog
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|threadA
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|threadB
operator|.
name|shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
name|fileSys
operator|!=
literal|null
condition|)
name|fileSys
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|testEditChecksum ()
specifier|public
name|void
name|testEditChecksum
parameter_list|()
throws|throws
name|Exception
block|{
comment|// start a cluster
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|FileSystem
name|fileSys
init|=
literal|null
decl_stmt|;
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|fileSys
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
specifier|final
name|FSNamesystem
name|namesystem
init|=
name|cluster
operator|.
name|getNamesystem
argument_list|()
decl_stmt|;
name|FSImage
name|fsimage
init|=
name|namesystem
operator|.
name|getFSImage
argument_list|()
decl_stmt|;
specifier|final
name|FSEditLog
name|editLog
init|=
name|fsimage
operator|.
name|getEditLog
argument_list|()
decl_stmt|;
name|fileSys
operator|.
name|mkdirs
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/tmp"
argument_list|)
argument_list|)
expr_stmt|;
name|StorageDirectory
name|sd
init|=
name|fsimage
operator|.
name|getStorage
argument_list|()
operator|.
name|dirIterator
argument_list|(
name|NameNodeDirType
operator|.
name|EDITS
argument_list|)
operator|.
name|next
argument_list|()
decl_stmt|;
name|editLog
operator|.
name|close
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|File
name|editFile
init|=
name|NNStorage
operator|.
name|getFinalizedEditsFile
argument_list|(
name|sd
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|editFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|fileLen
init|=
name|editFile
operator|.
name|length
argument_list|()
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"File name: "
operator|+
name|editFile
operator|+
literal|" len: "
operator|+
name|fileLen
argument_list|)
expr_stmt|;
name|RandomAccessFile
name|rwf
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|editFile
argument_list|,
literal|"rw"
argument_list|)
decl_stmt|;
name|rwf
operator|.
name|seek
argument_list|(
name|fileLen
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|// seek to checksum bytes
name|int
name|b
init|=
name|rwf
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|rwf
operator|.
name|seek
argument_list|(
name|fileLen
operator|-
literal|4
argument_list|)
expr_stmt|;
name|rwf
operator|.
name|writeInt
argument_list|(
name|b
operator|+
literal|1
argument_list|)
expr_stmt|;
name|rwf
operator|.
name|close
argument_list|()
expr_stmt|;
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|format
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"should not be able to start"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// expected
name|assertEquals
argument_list|(
literal|"Cause of exception should be ChecksumException"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
operator|.
name|getClass
argument_list|()
argument_list|,
name|ChecksumException
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Test what happens if the NN crashes when it has has started but    * had no transactions written.    */
DECL|method|testCrashRecoveryNoTransactions ()
specifier|public
name|void
name|testCrashRecoveryNoTransactions
parameter_list|()
throws|throws
name|Exception
block|{
name|testCrashRecovery
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test what happens if the NN crashes when it has has started and    * had a few transactions written    */
DECL|method|testCrashRecoveryWithTransactions ()
specifier|public
name|void
name|testCrashRecoveryWithTransactions
parameter_list|()
throws|throws
name|Exception
block|{
name|testCrashRecovery
argument_list|(
literal|150
argument_list|)
expr_stmt|;
block|}
comment|/**    * Do a test to make sure the edit log can recover edits even after    * a non-clean shutdown. This does a simulated crash by copying over    * the edits directory while the NN is still running, then shutting it    * down, and restoring that edits directory.    */
DECL|method|testCrashRecovery (int numTransactions)
specifier|private
name|void
name|testCrashRecovery
parameter_list|(
name|int
name|numTransactions
parameter_list|)
throws|throws
name|Exception
block|{
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|conf
operator|.
name|setInt
argument_list|(
name|DFSConfigKeys
operator|.
name|DFS_NAMENODE_CHECKPOINT_TXNS_KEY
argument_list|,
name|CHECKPOINT_ON_STARTUP_MIN_TXNS
argument_list|)
expr_stmt|;
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"\n===========================================\n"
operator|+
literal|"Starting empty cluster"
argument_list|)
expr_stmt|;
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|format
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
name|FileSystem
name|fs
init|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTransactions
condition|;
name|i
operator|++
control|)
block|{
name|fs
operator|.
name|mkdirs
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test"
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Directory layout looks like:
comment|// test/data/dfs/nameN/current/{fsimage_N,edits_...}
name|File
name|nameDir
init|=
operator|new
name|File
argument_list|(
name|cluster
operator|.
name|getNameDirs
argument_list|(
literal|0
argument_list|)
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|File
name|dfsDir
init|=
name|nameDir
operator|.
name|getParentFile
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|dfsDir
operator|.
name|getName
argument_list|()
argument_list|,
literal|"dfs"
argument_list|)
expr_stmt|;
comment|// make sure we got right dir
name|LOG
operator|.
name|info
argument_list|(
literal|"Copying data directory aside to a hot backup"
argument_list|)
expr_stmt|;
name|File
name|backupDir
init|=
operator|new
name|File
argument_list|(
name|dfsDir
operator|.
name|getParentFile
argument_list|()
argument_list|,
literal|"dfs.backup-while-running"
argument_list|)
decl_stmt|;
name|FileUtil
operator|.
name|copyDir
argument_list|(
name|dfsDir
argument_list|,
name|backupDir
argument_list|)
expr_stmt|;
empty_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Shutting down cluster #1"
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|cluster
operator|=
literal|null
expr_stmt|;
comment|// Now restore the backup
name|FileUtil
operator|.
name|deleteContents
argument_list|(
name|dfsDir
argument_list|)
expr_stmt|;
name|backupDir
operator|.
name|renameTo
argument_list|(
name|dfsDir
argument_list|)
expr_stmt|;
comment|// Directory layout looks like:
comment|// test/data/dfs/nameN/current/{fsimage_N,edits_...}
name|File
name|currentDir
init|=
operator|new
name|File
argument_list|(
name|nameDir
argument_list|,
literal|"current"
argument_list|)
decl_stmt|;
comment|// We should see the file as in-progress
name|File
name|editsFile
init|=
operator|new
name|File
argument_list|(
name|currentDir
argument_list|,
name|NNStorage
operator|.
name|getInProgressEditsFileName
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Edits file "
operator|+
name|editsFile
operator|+
literal|" should exist"
argument_list|,
name|editsFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|File
name|imageFile
init|=
name|FSImageTestUtil
operator|.
name|findNewestImageFile
argument_list|(
name|currentDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
decl_stmt|;
name|assertNotNull
argument_list|(
literal|"No image found in "
operator|+
name|nameDir
argument_list|,
name|imageFile
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|NNStorage
operator|.
name|getImageFileName
argument_list|(
literal|0
argument_list|)
argument_list|,
name|imageFile
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Try to start a new cluster
name|LOG
operator|.
name|info
argument_list|(
literal|"\n===========================================\n"
operator|+
literal|"Starting same cluster after simulated crash"
argument_list|)
expr_stmt|;
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|format
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
comment|// We should still have the files we wrote prior to the simulated crash
name|fs
operator|=
name|cluster
operator|.
name|getFileSystem
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numTransactions
condition|;
name|i
operator|++
control|)
block|{
name|assertTrue
argument_list|(
name|fs
operator|.
name|exists
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/test"
operator|+
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|long
name|expectedTxId
decl_stmt|;
if|if
condition|(
name|numTransactions
operator|>
name|CHECKPOINT_ON_STARTUP_MIN_TXNS
condition|)
block|{
comment|// It should have saved a checkpoint on startup since there
comment|// were more unfinalized edits than configured
name|expectedTxId
operator|=
name|numTransactions
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|// otherwise, it shouldn't have made a checkpoint
name|expectedTxId
operator|=
literal|0
expr_stmt|;
block|}
name|imageFile
operator|=
name|FSImageTestUtil
operator|.
name|findNewestImageFile
argument_list|(
name|currentDir
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
literal|"No image found in "
operator|+
name|nameDir
argument_list|,
name|imageFile
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|NNStorage
operator|.
name|getImageFileName
argument_list|(
name|expectedTxId
argument_list|)
argument_list|,
name|imageFile
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
comment|// Started successfully. Shut it down and make sure it can restart.
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|cluster
operator|=
literal|null
expr_stmt|;
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|format
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|waitActive
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|cluster
operator|!=
literal|null
condition|)
block|{
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|testCrashRecoveryEmptyLogOneDir ()
specifier|public
name|void
name|testCrashRecoveryEmptyLogOneDir
parameter_list|()
throws|throws
name|Exception
block|{
name|doTestCrashRecoveryEmptyLog
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|testCrashRecoveryEmptyLogBothDirs ()
specifier|public
name|void
name|testCrashRecoveryEmptyLogBothDirs
parameter_list|()
throws|throws
name|Exception
block|{
name|doTestCrashRecoveryEmptyLog
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that the NN handles the corruption properly    * after it crashes just after creating an edit log    * (ie before writing START_LOG_SEGMENT). In the case    * that all logs have this problem, it should mark them    * as corrupt instead of trying to finalize them.    *     * @param inBothDirs if true, there will be a truncated log in    * both of the edits directories. If false, the truncated log    * will only be in one of the directories. In both cases, the    * NN should fail to start up, because it's aware that txid 3    * was reached, but unable to find a non-corrupt log starting there.    */
DECL|method|doTestCrashRecoveryEmptyLog (boolean inBothDirs)
specifier|private
name|void
name|doTestCrashRecoveryEmptyLog
parameter_list|(
name|boolean
name|inBothDirs
parameter_list|)
throws|throws
name|Exception
block|{
comment|// start a cluster
name|Configuration
name|conf
init|=
operator|new
name|HdfsConfiguration
argument_list|()
decl_stmt|;
name|MiniDFSCluster
name|cluster
init|=
literal|null
decl_stmt|;
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
name|Collection
argument_list|<
name|URI
argument_list|>
name|editsDirs
init|=
name|cluster
operator|.
name|getNameEditsDirs
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|URI
name|uri
range|:
name|editsDirs
control|)
block|{
name|File
name|dir
init|=
operator|new
name|File
argument_list|(
name|uri
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|File
name|currentDir
init|=
operator|new
name|File
argument_list|(
name|dir
argument_list|,
literal|"current"
argument_list|)
decl_stmt|;
comment|// We should start with only the finalized edits_1-2
name|GenericTestUtils
operator|.
name|assertGlobEquals
argument_list|(
name|currentDir
argument_list|,
literal|"edits_.*"
argument_list|,
name|NNStorage
operator|.
name|getFinalizedEditsFileName
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|// Make a truncated edits_3_inprogress
name|File
name|log
init|=
operator|new
name|File
argument_list|(
name|currentDir
argument_list|,
name|NNStorage
operator|.
name|getInProgressEditsFileName
argument_list|(
literal|3
argument_list|)
argument_list|)
decl_stmt|;
operator|new
name|EditLogFileOutputStream
argument_list|(
name|log
argument_list|,
literal|1024
argument_list|)
operator|.
name|create
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|inBothDirs
condition|)
block|{
break|break;
block|}
block|}
try|try
block|{
name|cluster
operator|=
operator|new
name|MiniDFSCluster
operator|.
name|Builder
argument_list|(
name|conf
argument_list|)
operator|.
name|numDataNodes
argument_list|(
name|NUM_DATA_NODES
argument_list|)
operator|.
name|format
argument_list|(
literal|false
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Did not fail to start with all-corrupt logs"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|ise
parameter_list|)
block|{
name|GenericTestUtils
operator|.
name|assertExceptionContains
argument_list|(
literal|"No non-corrupt logs for txid 3"
argument_list|,
name|ise
argument_list|)
expr_stmt|;
block|}
name|cluster
operator|.
name|shutdown
argument_list|()
expr_stmt|;
block|}
DECL|class|EditLogByteInputStream
specifier|private
specifier|static
class|class
name|EditLogByteInputStream
extends|extends
name|EditLogInputStream
block|{
DECL|field|input
specifier|private
name|InputStream
name|input
decl_stmt|;
DECL|field|len
specifier|private
name|long
name|len
decl_stmt|;
DECL|field|version
specifier|private
name|int
name|version
decl_stmt|;
DECL|field|reader
specifier|private
name|FSEditLogOp
operator|.
name|Reader
name|reader
init|=
literal|null
decl_stmt|;
DECL|field|tracker
specifier|private
name|FSEditLogLoader
operator|.
name|PositionTrackingInputStream
name|tracker
init|=
literal|null
decl_stmt|;
DECL|method|EditLogByteInputStream (byte[] data)
specifier|public
name|EditLogByteInputStream
parameter_list|(
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|len
operator|=
name|data
operator|.
name|length
expr_stmt|;
name|input
operator|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|BufferedInputStream
name|bin
init|=
operator|new
name|BufferedInputStream
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|DataInputStream
name|in
init|=
operator|new
name|DataInputStream
argument_list|(
name|bin
argument_list|)
decl_stmt|;
name|version
operator|=
name|EditLogFileInputStream
operator|.
name|readLogVersion
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|tracker
operator|=
operator|new
name|FSEditLogLoader
operator|.
name|PositionTrackingInputStream
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|in
operator|=
operator|new
name|DataInputStream
argument_list|(
name|tracker
argument_list|)
expr_stmt|;
name|reader
operator|=
operator|new
name|FSEditLogOp
operator|.
name|Reader
argument_list|(
name|in
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|length ()
specifier|public
name|long
name|length
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|len
return|;
block|}
annotation|@
name|Override
DECL|method|getPosition ()
specifier|public
name|long
name|getPosition
parameter_list|()
block|{
return|return
name|tracker
operator|.
name|getPos
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|readOp ()
specifier|public
name|FSEditLogOp
name|readOp
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|reader
operator|.
name|readOp
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getVersion ()
specifier|public
name|int
name|getVersion
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|version
return|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|input
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
comment|// JournalStream
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
literal|"AnonEditLogByteInputStream"
return|;
block|}
annotation|@
name|Override
comment|// JournalStream
DECL|method|getType ()
specifier|public
name|JournalType
name|getType
parameter_list|()
block|{
return|return
name|JournalType
operator|.
name|FILE
return|;
block|}
block|}
DECL|method|testFailedOpen ()
specifier|public
name|void
name|testFailedOpen
parameter_list|()
throws|throws
name|Exception
block|{
name|File
name|logDir
init|=
operator|new
name|File
argument_list|(
name|TEST_DIR
argument_list|,
literal|"testFailedOpen"
argument_list|)
decl_stmt|;
name|logDir
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|FSEditLog
name|log
init|=
name|FSImageTestUtil
operator|.
name|createStandaloneEditLog
argument_list|(
name|logDir
argument_list|)
decl_stmt|;
try|try
block|{
name|logDir
operator|.
name|setWritable
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|log
operator|.
name|open
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Did no throw exception on only having a bad dir"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|GenericTestUtils
operator|.
name|assertExceptionContains
argument_list|(
literal|"no journals successfully started"
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|logDir
operator|.
name|setWritable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|log
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

