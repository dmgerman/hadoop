begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.hdfs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLConnection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|BlockLocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
operator|.
name|Statistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|DFSClient
operator|.
name|DFSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ClientDatanodeProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|DatanodeInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|ExtendedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|LocatedBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|datatransfer
operator|.
name|Sender
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|protocol
operator|.
name|proto
operator|.
name|DataTransferProtos
operator|.
name|BlockOpResponseProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|security
operator|.
name|token
operator|.
name|block
operator|.
name|BlockTokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|blockmanagement
operator|.
name|DatanodeDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|common
operator|.
name|HdfsConstants
operator|.
name|StartupOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|DataNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|datanode
operator|.
name|TestTransferRbw
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|FSNamesystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|hdfs
operator|.
name|server
operator|.
name|namenode
operator|.
name|NameNodeAdapter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|ShellBasedUnixGroupsMapping
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_comment
comment|/** Utilities for HDFS tests */
end_comment

begin_class
DECL|class|DFSTestUtil
specifier|public
class|class
name|DFSTestUtil
block|{
DECL|field|gen
specifier|private
specifier|static
name|Random
name|gen
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
DECL|field|dirNames
specifier|private
specifier|static
name|String
index|[]
name|dirNames
init|=
block|{
literal|"zero"
block|,
literal|"one"
block|,
literal|"two"
block|,
literal|"three"
block|,
literal|"four"
block|,
literal|"five"
block|,
literal|"six"
block|,
literal|"seven"
block|,
literal|"eight"
block|,
literal|"nine"
block|}
decl_stmt|;
DECL|field|maxLevels
specifier|private
name|int
name|maxLevels
decl_stmt|;
comment|// = 3;
DECL|field|maxSize
specifier|private
name|int
name|maxSize
decl_stmt|;
comment|// = 8*1024;
DECL|field|nFiles
specifier|private
name|int
name|nFiles
decl_stmt|;
DECL|field|files
specifier|private
name|MyFile
index|[]
name|files
decl_stmt|;
comment|/** Creates a new instance of DFSTestUtil    *    * @param testName Name of the test from where this utility is used    * @param nFiles Number of files to be created    * @param maxLevels Maximum number of directory levels    * @param maxSize Maximum size for file    */
DECL|method|DFSTestUtil (String testName, int nFiles, int maxLevels, int maxSize)
specifier|public
name|DFSTestUtil
parameter_list|(
name|String
name|testName
parameter_list|,
name|int
name|nFiles
parameter_list|,
name|int
name|maxLevels
parameter_list|,
name|int
name|maxSize
parameter_list|)
block|{
name|this
operator|.
name|nFiles
operator|=
name|nFiles
expr_stmt|;
name|this
operator|.
name|maxLevels
operator|=
name|maxLevels
expr_stmt|;
name|this
operator|.
name|maxSize
operator|=
name|maxSize
expr_stmt|;
block|}
comment|/**    * when formating a namenode - we must provide clusterid.    * @param conf    * @throws IOException    */
DECL|method|formatNameNode (Configuration conf)
specifier|public
specifier|static
name|void
name|formatNameNode
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|clusterId
init|=
name|StartupOption
operator|.
name|FORMAT
operator|.
name|getClusterId
argument_list|()
decl_stmt|;
if|if
condition|(
name|clusterId
operator|==
literal|null
operator|||
name|clusterId
operator|.
name|isEmpty
argument_list|()
condition|)
name|StartupOption
operator|.
name|FORMAT
operator|.
name|setClusterId
argument_list|(
literal|"testClusterID"
argument_list|)
expr_stmt|;
name|NameNode
operator|.
name|format
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/** class MyFile contains enough information to recreate the contents of    * a single file.    */
DECL|class|MyFile
specifier|private
class|class
name|MyFile
block|{
DECL|field|name
specifier|private
name|String
name|name
init|=
literal|""
decl_stmt|;
DECL|field|size
specifier|private
name|int
name|size
decl_stmt|;
DECL|field|seed
specifier|private
name|long
name|seed
decl_stmt|;
DECL|method|MyFile ()
name|MyFile
parameter_list|()
block|{
name|int
name|nLevels
init|=
name|gen
operator|.
name|nextInt
argument_list|(
name|maxLevels
argument_list|)
decl_stmt|;
if|if
condition|(
name|nLevels
operator|!=
literal|0
condition|)
block|{
name|int
index|[]
name|levels
init|=
operator|new
name|int
index|[
name|nLevels
index|]
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|nLevels
condition|;
name|idx
operator|++
control|)
block|{
name|levels
index|[
name|idx
index|]
operator|=
name|gen
operator|.
name|nextInt
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|StringBuffer
name|sb
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|nLevels
condition|;
name|idx
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|dirNames
index|[
name|levels
index|[
name|idx
index|]
index|]
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|long
name|fidx
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|fidx
operator|<
literal|0
condition|)
block|{
name|fidx
operator|=
name|gen
operator|.
name|nextLong
argument_list|()
expr_stmt|;
block|}
name|name
operator|=
name|name
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|fidx
argument_list|)
expr_stmt|;
name|size
operator|=
name|gen
operator|.
name|nextInt
argument_list|(
name|maxSize
argument_list|)
expr_stmt|;
name|seed
operator|=
name|gen
operator|.
name|nextLong
argument_list|()
expr_stmt|;
block|}
DECL|method|getName ()
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
DECL|method|getSize ()
name|int
name|getSize
parameter_list|()
block|{
return|return
name|size
return|;
block|}
DECL|method|getSeed ()
name|long
name|getSeed
parameter_list|()
block|{
return|return
name|seed
return|;
block|}
block|}
DECL|method|createFiles (FileSystem fs, String topdir)
specifier|public
name|void
name|createFiles
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|String
name|topdir
parameter_list|)
throws|throws
name|IOException
block|{
name|createFiles
argument_list|(
name|fs
argument_list|,
name|topdir
argument_list|,
operator|(
name|short
operator|)
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/** create nFiles with random names and directory hierarchies    *  with random (but reproducible) data in them.    */
DECL|method|createFiles (FileSystem fs, String topdir, short replicationFactor)
specifier|public
name|void
name|createFiles
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|String
name|topdir
parameter_list|,
name|short
name|replicationFactor
parameter_list|)
throws|throws
name|IOException
block|{
name|files
operator|=
operator|new
name|MyFile
index|[
name|nFiles
index|]
expr_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|nFiles
condition|;
name|idx
operator|++
control|)
block|{
name|files
index|[
name|idx
index|]
operator|=
operator|new
name|MyFile
argument_list|()
expr_stmt|;
block|}
name|Path
name|root
init|=
operator|new
name|Path
argument_list|(
name|topdir
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|nFiles
condition|;
name|idx
operator|++
control|)
block|{
name|createFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
name|root
argument_list|,
name|files
index|[
name|idx
index|]
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|files
index|[
name|idx
index|]
operator|.
name|getSize
argument_list|()
argument_list|,
name|replicationFactor
argument_list|,
name|files
index|[
name|idx
index|]
operator|.
name|getSeed
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|readFile (FileSystem fs, Path fileName)
specifier|public
specifier|static
name|String
name|readFile
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|fileName
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteArrayOutputStream
name|os
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|IOUtils
operator|.
name|copyBytes
argument_list|(
name|fs
operator|.
name|open
argument_list|(
name|fileName
argument_list|)
argument_list|,
name|os
argument_list|,
literal|1024
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|os
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|createFile (FileSystem fs, Path fileName, long fileLen, short replFactor, long seed)
specifier|public
specifier|static
name|void
name|createFile
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|fileName
parameter_list|,
name|long
name|fileLen
parameter_list|,
name|short
name|replFactor
parameter_list|,
name|long
name|seed
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|fs
operator|.
name|mkdirs
argument_list|(
name|fileName
operator|.
name|getParent
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mkdirs failed to create "
operator|+
name|fileName
operator|.
name|getParent
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|FSDataOutputStream
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
name|out
operator|=
name|fs
operator|.
name|create
argument_list|(
name|fileName
argument_list|,
name|replFactor
argument_list|)
expr_stmt|;
name|byte
index|[]
name|toWrite
init|=
operator|new
name|byte
index|[
literal|1024
index|]
decl_stmt|;
name|Random
name|rb
init|=
operator|new
name|Random
argument_list|(
name|seed
argument_list|)
decl_stmt|;
name|long
name|bytesToWrite
init|=
name|fileLen
decl_stmt|;
while|while
condition|(
name|bytesToWrite
operator|>
literal|0
condition|)
block|{
name|rb
operator|.
name|nextBytes
argument_list|(
name|toWrite
argument_list|)
expr_stmt|;
name|int
name|bytesToWriteNext
init|=
operator|(
literal|1024
operator|<
name|bytesToWrite
operator|)
condition|?
literal|1024
else|:
operator|(
name|int
operator|)
name|bytesToWrite
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
name|toWrite
argument_list|,
literal|0
argument_list|,
name|bytesToWriteNext
argument_list|)
expr_stmt|;
name|bytesToWrite
operator|-=
name|bytesToWriteNext
expr_stmt|;
block|}
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|out
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** check if the files have been copied correctly. */
DECL|method|checkFiles (FileSystem fs, String topdir)
specifier|public
name|boolean
name|checkFiles
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|String
name|topdir
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|root
init|=
operator|new
name|Path
argument_list|(
name|topdir
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|nFiles
condition|;
name|idx
operator|++
control|)
block|{
name|Path
name|fPath
init|=
operator|new
name|Path
argument_list|(
name|root
argument_list|,
name|files
index|[
name|idx
index|]
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|FSDataInputStream
name|in
init|=
name|fs
operator|.
name|open
argument_list|(
name|fPath
argument_list|)
decl_stmt|;
name|byte
index|[]
name|toRead
init|=
operator|new
name|byte
index|[
name|files
index|[
name|idx
index|]
operator|.
name|getSize
argument_list|()
index|]
decl_stmt|;
name|byte
index|[]
name|toCompare
init|=
operator|new
name|byte
index|[
name|files
index|[
name|idx
index|]
operator|.
name|getSize
argument_list|()
index|]
decl_stmt|;
name|Random
name|rb
init|=
operator|new
name|Random
argument_list|(
name|files
index|[
name|idx
index|]
operator|.
name|getSeed
argument_list|()
argument_list|)
decl_stmt|;
name|rb
operator|.
name|nextBytes
argument_list|(
name|toCompare
argument_list|)
expr_stmt|;
name|in
operator|.
name|readFully
argument_list|(
literal|0
argument_list|,
name|toRead
argument_list|)
expr_stmt|;
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|toRead
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|toRead
index|[
name|i
index|]
operator|!=
name|toCompare
index|[
name|i
index|]
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|toRead
operator|=
literal|null
expr_stmt|;
name|toCompare
operator|=
literal|null
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|setReplication (FileSystem fs, String topdir, short value)
name|void
name|setReplication
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|String
name|topdir
parameter_list|,
name|short
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|root
init|=
operator|new
name|Path
argument_list|(
name|topdir
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|nFiles
condition|;
name|idx
operator|++
control|)
block|{
name|Path
name|fPath
init|=
operator|new
name|Path
argument_list|(
name|root
argument_list|,
name|files
index|[
name|idx
index|]
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|fs
operator|.
name|setReplication
argument_list|(
name|fPath
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Waits for the replication factor of all files to reach the    * specified target.    */
DECL|method|waitReplication (FileSystem fs, String topdir, short value)
specifier|public
name|void
name|waitReplication
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|String
name|topdir
parameter_list|,
name|short
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|root
init|=
operator|new
name|Path
argument_list|(
name|topdir
argument_list|)
decl_stmt|;
comment|/** wait for the replication factor to settle down */
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|nFiles
condition|;
name|idx
operator|++
control|)
block|{
name|waitReplication
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
name|root
argument_list|,
name|files
index|[
name|idx
index|]
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Check if the given block in the given file is corrupt.    */
DECL|method|allBlockReplicasCorrupt (MiniDFSCluster cluster, Path file, int blockNo)
specifier|public
specifier|static
name|boolean
name|allBlockReplicasCorrupt
parameter_list|(
name|MiniDFSCluster
name|cluster
parameter_list|,
name|Path
name|file
parameter_list|,
name|int
name|blockNo
parameter_list|)
throws|throws
name|IOException
block|{
name|DFSClient
name|client
init|=
operator|new
name|DFSClient
argument_list|(
operator|new
name|InetSocketAddress
argument_list|(
literal|"localhost"
argument_list|,
name|cluster
operator|.
name|getNameNodePort
argument_list|()
argument_list|)
argument_list|,
name|cluster
operator|.
name|getConfiguration
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|LocatedBlocks
name|blocks
decl_stmt|;
try|try
block|{
name|blocks
operator|=
name|client
operator|.
name|getNamenode
argument_list|()
operator|.
name|getBlockLocations
argument_list|(
name|file
operator|.
name|toString
argument_list|()
argument_list|,
literal|0
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|client
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|blocks
operator|.
name|get
argument_list|(
name|blockNo
argument_list|)
operator|.
name|isCorrupt
argument_list|()
return|;
block|}
comment|/*    * Wait up to 20s for the given block to be replicated across    * the requested number of racks, with the requested number of    * replicas, and the requested number of replicas still needed.    */
DECL|method|waitForReplication (MiniDFSCluster cluster, ExtendedBlock b, int racks, int replicas, int neededReplicas)
specifier|public
specifier|static
name|void
name|waitForReplication
parameter_list|(
name|MiniDFSCluster
name|cluster
parameter_list|,
name|ExtendedBlock
name|b
parameter_list|,
name|int
name|racks
parameter_list|,
name|int
name|replicas
parameter_list|,
name|int
name|neededReplicas
parameter_list|)
throws|throws
name|IOException
throws|,
name|TimeoutException
throws|,
name|InterruptedException
block|{
name|int
name|curRacks
init|=
literal|0
decl_stmt|;
name|int
name|curReplicas
init|=
literal|0
decl_stmt|;
name|int
name|curNeededReplicas
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|ATTEMPTS
init|=
literal|20
decl_stmt|;
do|do
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|int
index|[]
name|r
init|=
name|NameNodeAdapter
operator|.
name|getReplicaInfo
argument_list|(
name|cluster
operator|.
name|getNameNode
argument_list|()
argument_list|,
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
name|curRacks
operator|=
name|r
index|[
literal|0
index|]
expr_stmt|;
name|curReplicas
operator|=
name|r
index|[
literal|1
index|]
expr_stmt|;
name|curNeededReplicas
operator|=
name|r
index|[
literal|2
index|]
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|curRacks
operator|!=
name|racks
operator|||
name|curReplicas
operator|!=
name|replicas
operator|||
name|curNeededReplicas
operator|!=
name|neededReplicas
operator|)
operator|&&
name|count
operator|<
name|ATTEMPTS
condition|)
do|;
if|if
condition|(
name|count
operator|==
name|ATTEMPTS
condition|)
block|{
throw|throw
operator|new
name|TimeoutException
argument_list|(
literal|"Timed out waiting for replication."
operator|+
literal|" Needed replicas = "
operator|+
name|neededReplicas
operator|+
literal|" Cur needed replicas = "
operator|+
name|curNeededReplicas
operator|+
literal|" Replicas = "
operator|+
name|replicas
operator|+
literal|" Cur replicas = "
operator|+
name|curReplicas
operator|+
literal|" Racks = "
operator|+
name|racks
operator|+
literal|" Cur racks = "
operator|+
name|curRacks
argument_list|)
throw|;
block|}
block|}
comment|/*    * Keep accessing the given file until the namenode reports that the    * given block in the file contains the given number of corrupt replicas.    */
DECL|method|waitCorruptReplicas (FileSystem fs, FSNamesystem ns, Path file, ExtendedBlock b, int corruptRepls)
specifier|public
specifier|static
name|void
name|waitCorruptReplicas
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|FSNamesystem
name|ns
parameter_list|,
name|Path
name|file
parameter_list|,
name|ExtendedBlock
name|b
parameter_list|,
name|int
name|corruptRepls
parameter_list|)
throws|throws
name|IOException
throws|,
name|TimeoutException
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|ATTEMPTS
init|=
literal|50
decl_stmt|;
name|int
name|repls
init|=
name|ns
operator|.
name|numCorruptReplicas
argument_list|(
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|repls
operator|!=
name|corruptRepls
operator|&&
name|count
operator|<
name|ATTEMPTS
condition|)
block|{
try|try
block|{
name|IOUtils
operator|.
name|copyBytes
argument_list|(
name|fs
operator|.
name|open
argument_list|(
name|file
argument_list|)
argument_list|,
operator|new
name|IOUtils
operator|.
name|NullOutputStream
argument_list|()
argument_list|,
literal|512
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Swallow exceptions
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Waiting for "
operator|+
name|corruptRepls
operator|+
literal|" corrupt replicas"
argument_list|)
expr_stmt|;
name|repls
operator|=
name|ns
operator|.
name|numCorruptReplicas
argument_list|(
name|b
operator|.
name|getLocalBlock
argument_list|()
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
name|ATTEMPTS
condition|)
block|{
throw|throw
operator|new
name|TimeoutException
argument_list|(
literal|"Timed out waiting for corrupt replicas."
operator|+
literal|" Waiting for "
operator|+
name|corruptRepls
operator|+
literal|", but only found "
operator|+
name|repls
argument_list|)
throw|;
block|}
block|}
comment|/*    * Wait up to 20s for the given DN (host:port) to be decommissioned.    */
DECL|method|waitForDecommission (FileSystem fs, String name)
specifier|public
specifier|static
name|void
name|waitForDecommission
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|String
name|name
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|TimeoutException
block|{
name|DatanodeInfo
name|dn
init|=
literal|null
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|final
name|int
name|ATTEMPTS
init|=
literal|20
decl_stmt|;
do|do
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|DistributedFileSystem
name|dfs
init|=
operator|(
name|DistributedFileSystem
operator|)
name|fs
decl_stmt|;
for|for
control|(
name|DatanodeInfo
name|info
range|:
name|dfs
operator|.
name|getDataNodeStats
argument_list|()
control|)
block|{
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
name|info
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|dn
operator|=
name|info
expr_stmt|;
block|}
block|}
name|count
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|dn
operator|==
literal|null
operator|||
name|dn
operator|.
name|isDecommissionInProgress
argument_list|()
operator|||
operator|!
name|dn
operator|.
name|isDecommissioned
argument_list|()
operator|)
operator|&&
name|count
operator|<
name|ATTEMPTS
condition|)
do|;
if|if
condition|(
name|count
operator|==
name|ATTEMPTS
condition|)
block|{
throw|throw
operator|new
name|TimeoutException
argument_list|(
literal|"Timed out waiting for datanode "
operator|+
name|name
operator|+
literal|" to decommission."
argument_list|)
throw|;
block|}
block|}
comment|/*    * Returns the index of the first datanode which has a copy    * of the given block, or -1 if no such datanode exists.    */
DECL|method|firstDnWithBlock (MiniDFSCluster cluster, ExtendedBlock b)
specifier|public
specifier|static
name|int
name|firstDnWithBlock
parameter_list|(
name|MiniDFSCluster
name|cluster
parameter_list|,
name|ExtendedBlock
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|numDatanodes
init|=
name|cluster
operator|.
name|getDataNodes
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numDatanodes
condition|;
name|i
operator|++
control|)
block|{
name|String
name|blockContent
init|=
name|cluster
operator|.
name|readBlockOnDataNode
argument_list|(
name|i
argument_list|,
name|b
argument_list|)
decl_stmt|;
if|if
condition|(
name|blockContent
operator|!=
literal|null
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/*    * Return the total capacity of all live DNs.    */
DECL|method|getLiveDatanodeCapacity (FSNamesystem ns)
specifier|public
specifier|static
name|long
name|getLiveDatanodeCapacity
parameter_list|(
name|FSNamesystem
name|ns
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|live
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|dead
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|ns
operator|.
name|DFSNodesStatus
argument_list|(
name|live
argument_list|,
name|dead
argument_list|)
expr_stmt|;
name|long
name|capacity
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|final
name|DatanodeDescriptor
name|dn
range|:
name|live
control|)
block|{
name|capacity
operator|+=
name|dn
operator|.
name|getCapacity
argument_list|()
expr_stmt|;
block|}
return|return
name|capacity
return|;
block|}
comment|/*    * Return the capacity of the given live DN.    */
DECL|method|getDatanodeCapacity (FSNamesystem ns, int index)
specifier|public
specifier|static
name|long
name|getDatanodeCapacity
parameter_list|(
name|FSNamesystem
name|ns
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|live
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|dead
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|ns
operator|.
name|DFSNodesStatus
argument_list|(
name|live
argument_list|,
name|dead
argument_list|)
expr_stmt|;
return|return
name|live
operator|.
name|get
argument_list|(
name|index
argument_list|)
operator|.
name|getCapacity
argument_list|()
return|;
block|}
comment|/*    * Wait for the given # live/dead DNs, total capacity, and # vol failures.     */
DECL|method|waitForDatanodeStatus (FSNamesystem ns, int expectedLive, int expectedDead, long expectedVolFails, long expectedTotalCapacity, long timeout)
specifier|public
specifier|static
name|void
name|waitForDatanodeStatus
parameter_list|(
name|FSNamesystem
name|ns
parameter_list|,
name|int
name|expectedLive
parameter_list|,
name|int
name|expectedDead
parameter_list|,
name|long
name|expectedVolFails
parameter_list|,
name|long
name|expectedTotalCapacity
parameter_list|,
name|long
name|timeout
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|TimeoutException
block|{
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|live
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
name|dead
init|=
operator|new
name|ArrayList
argument_list|<
name|DatanodeDescriptor
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|int
name|ATTEMPTS
init|=
literal|10
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|long
name|currTotalCapacity
init|=
literal|0
decl_stmt|;
name|int
name|volFails
init|=
literal|0
decl_stmt|;
do|do
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|live
operator|.
name|clear
argument_list|()
expr_stmt|;
name|dead
operator|.
name|clear
argument_list|()
expr_stmt|;
name|ns
operator|.
name|DFSNodesStatus
argument_list|(
name|live
argument_list|,
name|dead
argument_list|)
expr_stmt|;
name|currTotalCapacity
operator|=
literal|0
expr_stmt|;
name|volFails
operator|=
literal|0
expr_stmt|;
for|for
control|(
specifier|final
name|DatanodeDescriptor
name|dd
range|:
name|live
control|)
block|{
name|currTotalCapacity
operator|+=
name|dd
operator|.
name|getCapacity
argument_list|()
expr_stmt|;
name|volFails
operator|+=
name|dd
operator|.
name|getVolumeFailures
argument_list|()
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|expectedLive
operator|!=
name|live
operator|.
name|size
argument_list|()
operator|||
name|expectedDead
operator|!=
name|dead
operator|.
name|size
argument_list|()
operator|||
name|expectedTotalCapacity
operator|!=
name|currTotalCapacity
operator|||
name|expectedVolFails
operator|!=
name|volFails
operator|)
operator|&&
name|count
operator|<
name|ATTEMPTS
condition|)
do|;
if|if
condition|(
name|count
operator|==
name|ATTEMPTS
condition|)
block|{
throw|throw
operator|new
name|TimeoutException
argument_list|(
literal|"Timed out waiting for capacity."
operator|+
literal|" Live = "
operator|+
name|live
operator|.
name|size
argument_list|()
operator|+
literal|" Expected = "
operator|+
name|expectedLive
operator|+
literal|" Dead = "
operator|+
name|dead
operator|.
name|size
argument_list|()
operator|+
literal|" Expected = "
operator|+
name|expectedDead
operator|+
literal|" Total capacity = "
operator|+
name|currTotalCapacity
operator|+
literal|" Expected = "
operator|+
name|expectedTotalCapacity
operator|+
literal|" Vol Fails = "
operator|+
name|volFails
operator|+
literal|" Expected = "
operator|+
name|expectedVolFails
argument_list|)
throw|;
block|}
block|}
comment|/*    * Wait for the given DN to consider itself dead.    */
DECL|method|waitForDatanodeDeath (DataNode dn)
specifier|public
specifier|static
name|void
name|waitForDatanodeDeath
parameter_list|(
name|DataNode
name|dn
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|TimeoutException
block|{
specifier|final
name|int
name|ATTEMPTS
init|=
literal|10
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
do|do
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|dn
operator|.
name|isDatanodeUp
argument_list|()
operator|&&
name|count
operator|<
name|ATTEMPTS
condition|)
do|;
if|if
condition|(
name|count
operator|==
name|ATTEMPTS
condition|)
block|{
throw|throw
operator|new
name|TimeoutException
argument_list|(
literal|"Timed out waiting for DN to die"
argument_list|)
throw|;
block|}
block|}
comment|/** return list of filenames created as part of createFiles */
DECL|method|getFileNames (String topDir)
specifier|public
name|String
index|[]
name|getFileNames
parameter_list|(
name|String
name|topDir
parameter_list|)
block|{
if|if
condition|(
name|nFiles
operator|==
literal|0
condition|)
return|return
operator|new
name|String
index|[]
block|{}
return|;
else|else
block|{
name|String
index|[]
name|fileNames
init|=
operator|new
name|String
index|[
name|nFiles
index|]
decl_stmt|;
for|for
control|(
name|int
name|idx
init|=
literal|0
init|;
name|idx
operator|<
name|nFiles
condition|;
name|idx
operator|++
control|)
block|{
name|fileNames
index|[
name|idx
index|]
operator|=
name|topDir
operator|+
literal|"/"
operator|+
name|files
index|[
name|idx
index|]
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
return|return
name|fileNames
return|;
block|}
block|}
comment|/** wait for the file's replication to be done */
DECL|method|waitReplication (FileSystem fs, Path fileName, short replFactor)
specifier|public
specifier|static
name|void
name|waitReplication
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|fileName
parameter_list|,
name|short
name|replFactor
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|good
decl_stmt|;
do|do
block|{
name|good
operator|=
literal|true
expr_stmt|;
name|BlockLocation
name|locs
index|[]
init|=
name|fs
operator|.
name|getFileBlockLocations
argument_list|(
name|fs
operator|.
name|getFileStatus
argument_list|(
name|fileName
argument_list|)
argument_list|,
literal|0
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|locs
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|String
index|[]
name|hostnames
init|=
name|locs
index|[
name|j
index|]
operator|.
name|getNames
argument_list|()
decl_stmt|;
if|if
condition|(
name|hostnames
operator|.
name|length
operator|!=
name|replFactor
condition|)
block|{
name|String
name|hostNameList
init|=
literal|""
decl_stmt|;
for|for
control|(
name|String
name|h
range|:
name|hostnames
control|)
name|hostNameList
operator|+=
name|h
operator|+
literal|" "
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Block "
operator|+
name|j
operator|+
literal|" of file "
operator|+
name|fileName
operator|+
literal|" has replication factor "
operator|+
name|hostnames
operator|.
name|length
operator|+
literal|"; locations "
operator|+
name|hostNameList
argument_list|)
expr_stmt|;
name|good
operator|=
literal|false
expr_stmt|;
try|try
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Waiting for replication factor to drain"
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{}
break|break;
block|}
block|}
if|if
condition|(
name|good
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"All blocks of file "
operator|+
name|fileName
operator|+
literal|" verified to have replication factor "
operator|+
name|replFactor
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|good
condition|)
do|;
block|}
comment|/** delete directory and everything underneath it.*/
DECL|method|cleanup (FileSystem fs, String topdir)
specifier|public
name|void
name|cleanup
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|String
name|topdir
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|root
init|=
operator|new
name|Path
argument_list|(
name|topdir
argument_list|)
decl_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|root
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|files
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|getFirstBlock (FileSystem fs, Path path)
specifier|public
specifier|static
name|ExtendedBlock
name|getFirstBlock
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|DFSDataInputStream
name|in
init|=
call|(
name|DFSDataInputStream
call|)
argument_list|(
operator|(
name|DistributedFileSystem
operator|)
name|fs
argument_list|)
operator|.
name|open
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
return|return
name|in
operator|.
name|getCurrentBlock
argument_list|()
return|;
block|}
DECL|method|getAllBlocks (FSDataInputStream in)
specifier|public
specifier|static
name|List
argument_list|<
name|LocatedBlock
argument_list|>
name|getAllBlocks
parameter_list|(
name|FSDataInputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|(
operator|(
name|DFSClient
operator|.
name|DFSDataInputStream
operator|)
name|in
operator|)
operator|.
name|getAllBlocks
argument_list|()
return|;
block|}
DECL|method|getBlockToken ( FSDataOutputStream out)
specifier|public
specifier|static
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
name|getBlockToken
parameter_list|(
name|FSDataOutputStream
name|out
parameter_list|)
block|{
return|return
operator|(
operator|(
name|DFSOutputStream
operator|)
name|out
operator|.
name|getWrappedStream
argument_list|()
operator|)
operator|.
name|getBlockToken
argument_list|()
return|;
block|}
DECL|method|createClientDatanodeProtocolProxy ( DatanodeID datanodeid, Configuration conf, int socketTimeout, LocatedBlock locatedBlock)
specifier|public
specifier|static
name|ClientDatanodeProtocol
name|createClientDatanodeProtocolProxy
parameter_list|(
name|DatanodeID
name|datanodeid
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|int
name|socketTimeout
parameter_list|,
name|LocatedBlock
name|locatedBlock
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|DFSClient
operator|.
name|createClientDatanodeProtocolProxy
argument_list|(
name|datanodeid
argument_list|,
name|conf
argument_list|,
name|socketTimeout
argument_list|,
name|locatedBlock
argument_list|)
return|;
block|}
DECL|method|setLogLevel2All (org.apache.commons.logging.Log log)
specifier|static
name|void
name|setLogLevel2All
parameter_list|(
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
name|log
parameter_list|)
block|{
operator|(
operator|(
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|impl
operator|.
name|Log4JLogger
operator|)
name|log
operator|)
operator|.
name|getLogger
argument_list|()
operator|.
name|setLevel
argument_list|(
name|org
operator|.
name|apache
operator|.
name|log4j
operator|.
name|Level
operator|.
name|ALL
argument_list|)
expr_stmt|;
block|}
DECL|method|readFile (File f)
specifier|public
specifier|static
name|String
name|readFile
parameter_list|(
name|File
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|BufferedReader
name|in
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|FileReader
argument_list|(
name|f
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|c
init|;
operator|(
name|c
operator|=
name|in
operator|.
name|read
argument_list|()
operator|)
operator|!=
operator|-
literal|1
condition|;
name|b
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
control|)
empty_stmt|;
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/* Write the given string to the given file */
DECL|method|writeFile (FileSystem fs, Path p, String s)
specifier|public
specifier|static
name|void
name|writeFile
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|p
parameter_list|,
name|String
name|s
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|fs
operator|.
name|delete
argument_list|(
name|p
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|InputStream
name|is
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|s
operator|.
name|getBytes
argument_list|()
argument_list|)
decl_stmt|;
name|FSDataOutputStream
name|os
init|=
name|fs
operator|.
name|create
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|IOUtils
operator|.
name|copyBytes
argument_list|(
name|is
argument_list|,
name|os
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/* Append the given string to the given file */
DECL|method|appendFile (FileSystem fs, Path p, String s)
specifier|public
specifier|static
name|void
name|appendFile
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|p
parameter_list|,
name|String
name|s
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|fs
operator|.
name|exists
argument_list|(
name|p
argument_list|)
assert|;
name|InputStream
name|is
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|s
operator|.
name|getBytes
argument_list|()
argument_list|)
decl_stmt|;
name|FSDataOutputStream
name|os
init|=
name|fs
operator|.
name|append
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|IOUtils
operator|.
name|copyBytes
argument_list|(
name|is
argument_list|,
name|os
argument_list|,
name|s
operator|.
name|length
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// Returns url content as string.
DECL|method|urlGet (URL url)
specifier|public
specifier|static
name|String
name|urlGet
parameter_list|(
name|URL
name|url
parameter_list|)
throws|throws
name|IOException
block|{
name|URLConnection
name|conn
init|=
name|url
operator|.
name|openConnection
argument_list|()
decl_stmt|;
name|ByteArrayOutputStream
name|out
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|IOUtils
operator|.
name|copyBytes
argument_list|(
name|conn
operator|.
name|getInputStream
argument_list|()
argument_list|,
name|out
argument_list|,
literal|4096
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|out
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * mock class to get group mapping for fake users    *     */
DECL|class|MockUnixGroupsMapping
specifier|static
class|class
name|MockUnixGroupsMapping
extends|extends
name|ShellBasedUnixGroupsMapping
block|{
DECL|field|fakeUser2GroupsMap
specifier|static
name|Map
argument_list|<
name|String
argument_list|,
name|String
index|[]
argument_list|>
name|fakeUser2GroupsMap
decl_stmt|;
DECL|field|defaultGroups
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|defaultGroups
decl_stmt|;
static|static
block|{
name|defaultGroups
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|defaultGroups
operator|.
name|add
argument_list|(
literal|"supergroup"
argument_list|)
expr_stmt|;
name|fakeUser2GroupsMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
index|[]
argument_list|>
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getGroups (String user)
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getGroups
parameter_list|(
name|String
name|user
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|found
init|=
literal|false
decl_stmt|;
comment|// check to see if this is one of fake users
name|List
argument_list|<
name|String
argument_list|>
name|l
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|u
range|:
name|fakeUser2GroupsMap
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|user
operator|.
name|equals
argument_list|(
name|u
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|String
name|gr
range|:
name|fakeUser2GroupsMap
operator|.
name|get
argument_list|(
name|u
argument_list|)
control|)
block|{
name|l
operator|.
name|add
argument_list|(
name|gr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// default
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|l
operator|=
name|super
operator|.
name|getGroups
argument_list|(
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"failed to get real group for "
operator|+
name|user
operator|+
literal|"; using default"
argument_list|)
expr_stmt|;
return|return
name|defaultGroups
return|;
block|}
block|}
return|return
name|l
return|;
block|}
block|}
comment|/**    * update the configuration with fake class for mapping user to groups    * @param conf    * @param map - user to groups mapping    */
DECL|method|updateConfWithFakeGroupMapping (Configuration conf, Map<String, String []> map)
specifier|static
specifier|public
name|void
name|updateConfWithFakeGroupMapping
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
index|[]
argument_list|>
name|map
parameter_list|)
block|{
if|if
condition|(
name|map
operator|!=
literal|null
condition|)
block|{
name|MockUnixGroupsMapping
operator|.
name|fakeUser2GroupsMap
operator|=
name|map
expr_stmt|;
block|}
comment|// fake mapping user to groups
name|conf
operator|.
name|setClass
argument_list|(
name|CommonConfigurationKeys
operator|.
name|HADOOP_SECURITY_GROUP_MAPPING
argument_list|,
name|DFSTestUtil
operator|.
name|MockUnixGroupsMapping
operator|.
name|class
argument_list|,
name|ShellBasedUnixGroupsMapping
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get a FileSystem instance as specified user in a doAs block.    */
DECL|method|getFileSystemAs (UserGroupInformation ugi, final Configuration conf)
specifier|static
specifier|public
name|FileSystem
name|getFileSystemAs
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|ugi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|FileSystem
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileSystem
name|run
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|FileSystem
operator|.
name|get
argument_list|(
name|conf
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
DECL|method|generateSequentialBytes (int start, int length)
specifier|public
specifier|static
name|byte
index|[]
name|generateSequentialBytes
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
operator|(
name|start
operator|+
name|i
operator|)
operator|%
literal|127
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|getStatistics (FileSystem fs)
specifier|public
specifier|static
name|Statistics
name|getStatistics
parameter_list|(
name|FileSystem
name|fs
parameter_list|)
block|{
return|return
name|FileSystem
operator|.
name|getStatistics
argument_list|(
name|fs
operator|.
name|getUri
argument_list|()
operator|.
name|getScheme
argument_list|()
argument_list|,
name|fs
operator|.
name|getClass
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Load file into byte[]    */
DECL|method|loadFile (String filename)
specifier|public
specifier|static
name|byte
index|[]
name|loadFile
parameter_list|(
name|String
name|filename
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|DataInputStream
name|in
init|=
operator|new
name|DataInputStream
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
argument_list|)
decl_stmt|;
name|byte
index|[]
name|content
init|=
operator|new
name|byte
index|[
operator|(
name|int
operator|)
name|file
operator|.
name|length
argument_list|()
index|]
decl_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|content
argument_list|)
expr_stmt|;
return|return
name|content
return|;
block|}
comment|/** For {@link TestTransferRbw} */
DECL|method|transferRbw (final ExtendedBlock b, final DFSClient dfsClient, final DatanodeInfo... datanodes)
specifier|public
specifier|static
name|BlockOpResponseProto
name|transferRbw
parameter_list|(
specifier|final
name|ExtendedBlock
name|b
parameter_list|,
specifier|final
name|DFSClient
name|dfsClient
parameter_list|,
specifier|final
name|DatanodeInfo
modifier|...
name|datanodes
parameter_list|)
throws|throws
name|IOException
block|{
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|datanodes
operator|.
name|length
argument_list|)
expr_stmt|;
specifier|final
name|Socket
name|s
init|=
name|DFSOutputStream
operator|.
name|createSocketForPipeline
argument_list|(
name|datanodes
index|[
literal|0
index|]
argument_list|,
name|datanodes
operator|.
name|length
argument_list|,
name|dfsClient
argument_list|)
decl_stmt|;
specifier|final
name|long
name|writeTimeout
init|=
name|dfsClient
operator|.
name|getDatanodeWriteTimeout
argument_list|(
name|datanodes
operator|.
name|length
argument_list|)
decl_stmt|;
specifier|final
name|DataOutputStream
name|out
init|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|NetUtils
operator|.
name|getOutputStream
argument_list|(
name|s
argument_list|,
name|writeTimeout
argument_list|)
argument_list|,
name|DataNode
operator|.
name|SMALL_BUFFER_SIZE
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|DataInputStream
name|in
init|=
operator|new
name|DataInputStream
argument_list|(
name|NetUtils
operator|.
name|getInputStream
argument_list|(
name|s
argument_list|)
argument_list|)
decl_stmt|;
comment|// send the request
operator|new
name|Sender
argument_list|(
name|out
argument_list|)
operator|.
name|transferBlock
argument_list|(
name|b
argument_list|,
operator|new
name|Token
argument_list|<
name|BlockTokenIdentifier
argument_list|>
argument_list|()
argument_list|,
name|dfsClient
operator|.
name|clientName
argument_list|,
operator|new
name|DatanodeInfo
index|[]
block|{
name|datanodes
index|[
literal|1
index|]
block|}
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
return|return
name|BlockOpResponseProto
operator|.
name|parseDelimitedFrom
argument_list|(
name|in
argument_list|)
return|;
block|}
block|}
end_class

end_unit

