begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  Licensed to the Apache Software Foundation (ASF) under one or more  *  contributor license agreements.  See the NOTICE file distributed with  *  this work for additional information regarding copyright ownership.  *  The ASF licenses this file to You under the Apache License, Version 2.0  *  (the "License"); you may not use this file except in compliance with  *  the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  *  */
end_comment

begin_comment
comment|/*  * This package is based on the work done by Keiron Liddle, Aftex Software  *<keiron@aftexsw.com> to whom the Ant project is very grateful for his  * great code.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.io.compress.bzip2
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|bzip2
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_comment
comment|/**  * An output stream that compresses into the BZip2 format (without the file  * header chars) into another stream.  *  *<p>  * The compression requires large amounts of memory. Thus you should call the  * {@link #close() close()} method as soon as possible, to force  *<tt>CBZip2OutputStream</tt> to release the allocated memory.  *</p>  *  *<p>  * You can shrink the amount of allocated memory and maybe raise the compression  * speed by choosing a lower blocksize, which in turn may cause a lower  * compression ratio. You can avoid unnecessary memory allocation by avoiding  * using a blocksize which is bigger than the size of the input.  *</p>  *  *<p>  * You can compute the memory usage for compressing by the following formula:  *</p>  *  *<pre>  *&lt;code&gt;400k + (9 * blocksize)&lt;/code&gt;.  *</pre>  *  *<p>  * To get the memory required for decompression by {@link CBZip2InputStream  * CBZip2InputStream} use  *</p>  *  *<pre>  *&lt;code&gt;65k + (5 * blocksize)&lt;/code&gt;.  *</pre>  *  *<table width="100%" border="1">  *<colgroup><col width="33%" /><col width="33%" /><col width="33%" />  *</colgroup>  *<tr>  *<th colspan="3">Memory usage by blocksize</th>  *</tr>  *<tr>  *<th align="right">Blocksize</th><th align="right">Compression<br>  * memory usage</th><th align="right">Decompression<br>  * memory usage</th>  *</tr>  *<tr>  *<td align="right">100k</td>  *<td align="right">1300k</td>  *<td align="right">565k</td>  *</tr>  *<tr>  *<td align="right">200k</td>  *<td align="right">2200k</td>  *<td align="right">1065k</td>  *</tr>  *<tr>  *<td align="right">300k</td>  *<td align="right">3100k</td>  *<td align="right">1565k</td>  *</tr>  *<tr>  *<td align="right">400k</td>  *<td align="right">4000k</td>  *<td align="right">2065k</td>  *</tr>  *<tr>  *<td align="right">500k</td>  *<td align="right">4900k</td>  *<td align="right">2565k</td>  *</tr>  *<tr>  *<td align="right">600k</td>  *<td align="right">5800k</td>  *<td align="right">3065k</td>  *</tr>  *<tr>  *<td align="right">700k</td>  *<td align="right">6700k</td>  *<td align="right">3565k</td>  *</tr>  *<tr>  *<td align="right">800k</td>  *<td align="right">7600k</td>  *<td align="right">4065k</td>  *</tr>  *<tr>  *<td align="right">900k</td>  *<td align="right">8500k</td>  *<td align="right">4565k</td>  *</tr>  *</table>  *  *<p>  * For decompression<tt>CBZip2InputStream</tt> allocates less memory if the  * bzipped input is smaller than one block.  *</p>  *  *<p>  * Instances of this class are not threadsafe.  *</p>  *  *<p>  * TODO: Update to BZip2 1.0.1  *</p>  *  */
end_comment

begin_class
DECL|class|CBZip2OutputStream
specifier|public
class|class
name|CBZip2OutputStream
extends|extends
name|OutputStream
implements|implements
name|BZip2Constants
block|{
comment|/**   * The minimum supported blocksize<tt> == 1</tt>.   */
DECL|field|MIN_BLOCKSIZE
specifier|public
specifier|static
specifier|final
name|int
name|MIN_BLOCKSIZE
init|=
literal|1
decl_stmt|;
comment|/**   * The maximum supported blocksize<tt> == 9</tt>.   */
DECL|field|MAX_BLOCKSIZE
specifier|public
specifier|static
specifier|final
name|int
name|MAX_BLOCKSIZE
init|=
literal|9
decl_stmt|;
comment|/**   * This constant is accessible by subclasses for historical purposes. If you   * don't know what it means then you don't need it.   */
DECL|field|SETMASK
specifier|protected
specifier|static
specifier|final
name|int
name|SETMASK
init|=
operator|(
literal|1
operator|<<
literal|21
operator|)
decl_stmt|;
comment|/**   * This constant is accessible by subclasses for historical purposes. If you   * don't know what it means then you don't need it.   */
DECL|field|CLEARMASK
specifier|protected
specifier|static
specifier|final
name|int
name|CLEARMASK
init|=
operator|(
operator|~
name|SETMASK
operator|)
decl_stmt|;
comment|/**   * This constant is accessible by subclasses for historical purposes. If you   * don't know what it means then you don't need it.   */
DECL|field|GREATER_ICOST
specifier|protected
specifier|static
specifier|final
name|int
name|GREATER_ICOST
init|=
literal|15
decl_stmt|;
comment|/**   * This constant is accessible by subclasses for historical purposes. If you   * don't know what it means then you don't need it.   */
DECL|field|LESSER_ICOST
specifier|protected
specifier|static
specifier|final
name|int
name|LESSER_ICOST
init|=
literal|0
decl_stmt|;
comment|/**   * This constant is accessible by subclasses for historical purposes. If you   * don't know what it means then you don't need it.   */
DECL|field|SMALL_THRESH
specifier|protected
specifier|static
specifier|final
name|int
name|SMALL_THRESH
init|=
literal|20
decl_stmt|;
comment|/**   * This constant is accessible by subclasses for historical purposes. If you   * don't know what it means then you don't need it.   */
DECL|field|DEPTH_THRESH
specifier|protected
specifier|static
specifier|final
name|int
name|DEPTH_THRESH
init|=
literal|10
decl_stmt|;
comment|/**   * This constant is accessible by subclasses for historical purposes. If you   * don't know what it means then you don't need it.   */
DECL|field|WORK_FACTOR
specifier|protected
specifier|static
specifier|final
name|int
name|WORK_FACTOR
init|=
literal|30
decl_stmt|;
comment|/**   * This constant is accessible by subclasses for historical purposes. If you   * don't know what it means then you don't need it.   *<p>   * If you are ever unlucky/improbable enough to get a stack overflow whilst   * sorting, increase the following constant and try again. In practice I   * have never seen the stack go above 27 elems, so the following limit seems   * very generous.   *</p>   */
DECL|field|QSORT_STACK_SIZE
specifier|protected
specifier|static
specifier|final
name|int
name|QSORT_STACK_SIZE
init|=
literal|1000
decl_stmt|;
comment|/**   * Knuth's increments seem to work better than Incerpi-Sedgewick here.   * Possibly because the number of elems to sort is usually small, typically   *&lt;= 20.   */
DECL|field|INCS
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|INCS
init|=
block|{
literal|1
block|,
literal|4
block|,
literal|13
block|,
literal|40
block|,
literal|121
block|,
literal|364
block|,
literal|1093
block|,
literal|3280
block|,
literal|9841
block|,
literal|29524
block|,
literal|88573
block|,
literal|265720
block|,
literal|797161
block|,
literal|2391484
block|}
decl_stmt|;
comment|/**   * This method is accessible by subclasses for historical purposes. If you   * don't know what it does then you don't need it.   */
DECL|method|hbMakeCodeLengths (char[] len, int[] freq, int alphaSize, int maxLen)
specifier|protected
specifier|static
name|void
name|hbMakeCodeLengths
parameter_list|(
name|char
index|[]
name|len
parameter_list|,
name|int
index|[]
name|freq
parameter_list|,
name|int
name|alphaSize
parameter_list|,
name|int
name|maxLen
parameter_list|)
block|{
comment|/*     * Nodes and heap entries run from 1. Entry 0 for both the heap and     * nodes is a sentinel.     */
specifier|final
name|int
index|[]
name|heap
init|=
operator|new
name|int
index|[
name|MAX_ALPHA_SIZE
operator|*
literal|2
index|]
decl_stmt|;
specifier|final
name|int
index|[]
name|weight
init|=
operator|new
name|int
index|[
name|MAX_ALPHA_SIZE
operator|*
literal|2
index|]
decl_stmt|;
specifier|final
name|int
index|[]
name|parent
init|=
operator|new
name|int
index|[
name|MAX_ALPHA_SIZE
operator|*
literal|2
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|alphaSize
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|weight
index|[
name|i
operator|+
literal|1
index|]
operator|=
operator|(
name|freq
index|[
name|i
index|]
operator|==
literal|0
condition|?
literal|1
else|:
name|freq
index|[
name|i
index|]
operator|)
operator|<<
literal|8
expr_stmt|;
block|}
for|for
control|(
name|boolean
name|tooLong
init|=
literal|true
init|;
name|tooLong
condition|;
control|)
block|{
name|tooLong
operator|=
literal|false
expr_stmt|;
name|int
name|nNodes
init|=
name|alphaSize
decl_stmt|;
name|int
name|nHeap
init|=
literal|0
decl_stmt|;
name|heap
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|weight
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|parent
index|[
literal|0
index|]
operator|=
operator|-
literal|2
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
name|parent
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|nHeap
operator|++
expr_stmt|;
name|heap
index|[
name|nHeap
index|]
operator|=
name|i
expr_stmt|;
name|int
name|zz
init|=
name|nHeap
decl_stmt|;
name|int
name|tmp
init|=
name|heap
index|[
name|zz
index|]
decl_stmt|;
while|while
condition|(
name|weight
index|[
name|tmp
index|]
operator|<
name|weight
index|[
name|heap
index|[
name|zz
operator|>>
literal|1
index|]
index|]
condition|)
block|{
name|heap
index|[
name|zz
index|]
operator|=
name|heap
index|[
name|zz
operator|>>
literal|1
index|]
expr_stmt|;
name|zz
operator|>>=
literal|1
expr_stmt|;
block|}
name|heap
index|[
name|zz
index|]
operator|=
name|tmp
expr_stmt|;
block|}
comment|// assert (nHeap< (MAX_ALPHA_SIZE + 2)) : nHeap;
while|while
condition|(
name|nHeap
operator|>
literal|1
condition|)
block|{
name|int
name|n1
init|=
name|heap
index|[
literal|1
index|]
decl_stmt|;
name|heap
index|[
literal|1
index|]
operator|=
name|heap
index|[
name|nHeap
index|]
expr_stmt|;
name|nHeap
operator|--
expr_stmt|;
name|int
name|yy
init|=
literal|0
decl_stmt|;
name|int
name|zz
init|=
literal|1
decl_stmt|;
name|int
name|tmp
init|=
name|heap
index|[
literal|1
index|]
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|yy
operator|=
name|zz
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|yy
operator|>
name|nHeap
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
name|yy
operator|<
name|nHeap
operator|)
operator|&&
operator|(
name|weight
index|[
name|heap
index|[
name|yy
operator|+
literal|1
index|]
index|]
operator|<
name|weight
index|[
name|heap
index|[
name|yy
index|]
index|]
operator|)
condition|)
block|{
name|yy
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|weight
index|[
name|tmp
index|]
operator|<
name|weight
index|[
name|heap
index|[
name|yy
index|]
index|]
condition|)
block|{
break|break;
block|}
name|heap
index|[
name|zz
index|]
operator|=
name|heap
index|[
name|yy
index|]
expr_stmt|;
name|zz
operator|=
name|yy
expr_stmt|;
block|}
name|heap
index|[
name|zz
index|]
operator|=
name|tmp
expr_stmt|;
name|int
name|n2
init|=
name|heap
index|[
literal|1
index|]
decl_stmt|;
name|heap
index|[
literal|1
index|]
operator|=
name|heap
index|[
name|nHeap
index|]
expr_stmt|;
name|nHeap
operator|--
expr_stmt|;
name|yy
operator|=
literal|0
expr_stmt|;
name|zz
operator|=
literal|1
expr_stmt|;
name|tmp
operator|=
name|heap
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|yy
operator|=
name|zz
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|yy
operator|>
name|nHeap
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
name|yy
operator|<
name|nHeap
operator|)
operator|&&
operator|(
name|weight
index|[
name|heap
index|[
name|yy
operator|+
literal|1
index|]
index|]
operator|<
name|weight
index|[
name|heap
index|[
name|yy
index|]
index|]
operator|)
condition|)
block|{
name|yy
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|weight
index|[
name|tmp
index|]
operator|<
name|weight
index|[
name|heap
index|[
name|yy
index|]
index|]
condition|)
block|{
break|break;
block|}
name|heap
index|[
name|zz
index|]
operator|=
name|heap
index|[
name|yy
index|]
expr_stmt|;
name|zz
operator|=
name|yy
expr_stmt|;
block|}
name|heap
index|[
name|zz
index|]
operator|=
name|tmp
expr_stmt|;
name|nNodes
operator|++
expr_stmt|;
name|parent
index|[
name|n1
index|]
operator|=
name|parent
index|[
name|n2
index|]
operator|=
name|nNodes
expr_stmt|;
specifier|final
name|int
name|weight_n1
init|=
name|weight
index|[
name|n1
index|]
decl_stmt|;
specifier|final
name|int
name|weight_n2
init|=
name|weight
index|[
name|n2
index|]
decl_stmt|;
name|weight
index|[
name|nNodes
index|]
operator|=
operator|(
operator|(
operator|(
name|weight_n1
operator|&
literal|0xffffff00
operator|)
operator|+
operator|(
name|weight_n2
operator|&
literal|0xffffff00
operator|)
operator|)
operator||
operator|(
literal|1
operator|+
operator|(
operator|(
operator|(
name|weight_n1
operator|&
literal|0x000000ff
operator|)
operator|>
operator|(
name|weight_n2
operator|&
literal|0x000000ff
operator|)
operator|)
condition|?
operator|(
name|weight_n1
operator|&
literal|0x000000ff
operator|)
else|:
operator|(
name|weight_n2
operator|&
literal|0x000000ff
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
name|parent
index|[
name|nNodes
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|nHeap
operator|++
expr_stmt|;
name|heap
index|[
name|nHeap
index|]
operator|=
name|nNodes
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
name|zz
operator|=
name|nHeap
expr_stmt|;
name|tmp
operator|=
name|heap
index|[
name|zz
index|]
expr_stmt|;
specifier|final
name|int
name|weight_tmp
init|=
name|weight
index|[
name|tmp
index|]
decl_stmt|;
while|while
condition|(
name|weight_tmp
operator|<
name|weight
index|[
name|heap
index|[
name|zz
operator|>>
literal|1
index|]
index|]
condition|)
block|{
name|heap
index|[
name|zz
index|]
operator|=
name|heap
index|[
name|zz
operator|>>
literal|1
index|]
expr_stmt|;
name|zz
operator|>>=
literal|1
expr_stmt|;
block|}
name|heap
index|[
name|zz
index|]
operator|=
name|tmp
expr_stmt|;
block|}
comment|// assert (nNodes< (MAX_ALPHA_SIZE * 2)) : nNodes;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
name|int
name|k
init|=
name|i
decl_stmt|;
for|for
control|(
name|int
name|parent_k
init|;
operator|(
name|parent_k
operator|=
name|parent
index|[
name|k
index|]
operator|)
operator|>=
literal|0
condition|;
control|)
block|{
name|k
operator|=
name|parent_k
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|len
index|[
name|i
operator|-
literal|1
index|]
operator|=
operator|(
name|char
operator|)
name|j
expr_stmt|;
if|if
condition|(
name|j
operator|>
name|maxLen
condition|)
block|{
name|tooLong
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tooLong
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
init|=
name|weight
index|[
name|i
index|]
operator|>>
literal|8
decl_stmt|;
name|j
operator|=
literal|1
operator|+
operator|(
name|j
operator|>>
literal|1
operator|)
expr_stmt|;
name|weight
index|[
name|i
index|]
operator|=
name|j
operator|<<
literal|8
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|hbMakeCodeLengths (final byte[] len, final int[] freq, final Data dat, final int alphaSize, final int maxLen)
specifier|private
specifier|static
name|void
name|hbMakeCodeLengths
parameter_list|(
specifier|final
name|byte
index|[]
name|len
parameter_list|,
specifier|final
name|int
index|[]
name|freq
parameter_list|,
specifier|final
name|Data
name|dat
parameter_list|,
specifier|final
name|int
name|alphaSize
parameter_list|,
specifier|final
name|int
name|maxLen
parameter_list|)
block|{
comment|/*     * Nodes and heap entries run from 1. Entry 0 for both the heap and     * nodes is a sentinel.     */
specifier|final
name|int
index|[]
name|heap
init|=
name|dat
operator|.
name|heap
decl_stmt|;
specifier|final
name|int
index|[]
name|weight
init|=
name|dat
operator|.
name|weight
decl_stmt|;
specifier|final
name|int
index|[]
name|parent
init|=
name|dat
operator|.
name|parent
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|alphaSize
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|weight
index|[
name|i
operator|+
literal|1
index|]
operator|=
operator|(
name|freq
index|[
name|i
index|]
operator|==
literal|0
condition|?
literal|1
else|:
name|freq
index|[
name|i
index|]
operator|)
operator|<<
literal|8
expr_stmt|;
block|}
for|for
control|(
name|boolean
name|tooLong
init|=
literal|true
init|;
name|tooLong
condition|;
control|)
block|{
name|tooLong
operator|=
literal|false
expr_stmt|;
name|int
name|nNodes
init|=
name|alphaSize
decl_stmt|;
name|int
name|nHeap
init|=
literal|0
decl_stmt|;
name|heap
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|weight
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|parent
index|[
literal|0
index|]
operator|=
operator|-
literal|2
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
name|parent
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|nHeap
operator|++
expr_stmt|;
name|heap
index|[
name|nHeap
index|]
operator|=
name|i
expr_stmt|;
name|int
name|zz
init|=
name|nHeap
decl_stmt|;
name|int
name|tmp
init|=
name|heap
index|[
name|zz
index|]
decl_stmt|;
while|while
condition|(
name|weight
index|[
name|tmp
index|]
operator|<
name|weight
index|[
name|heap
index|[
name|zz
operator|>>
literal|1
index|]
index|]
condition|)
block|{
name|heap
index|[
name|zz
index|]
operator|=
name|heap
index|[
name|zz
operator|>>
literal|1
index|]
expr_stmt|;
name|zz
operator|>>=
literal|1
expr_stmt|;
block|}
name|heap
index|[
name|zz
index|]
operator|=
name|tmp
expr_stmt|;
block|}
while|while
condition|(
name|nHeap
operator|>
literal|1
condition|)
block|{
name|int
name|n1
init|=
name|heap
index|[
literal|1
index|]
decl_stmt|;
name|heap
index|[
literal|1
index|]
operator|=
name|heap
index|[
name|nHeap
index|]
expr_stmt|;
name|nHeap
operator|--
expr_stmt|;
name|int
name|yy
init|=
literal|0
decl_stmt|;
name|int
name|zz
init|=
literal|1
decl_stmt|;
name|int
name|tmp
init|=
name|heap
index|[
literal|1
index|]
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|yy
operator|=
name|zz
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|yy
operator|>
name|nHeap
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
name|yy
operator|<
name|nHeap
operator|)
operator|&&
operator|(
name|weight
index|[
name|heap
index|[
name|yy
operator|+
literal|1
index|]
index|]
operator|<
name|weight
index|[
name|heap
index|[
name|yy
index|]
index|]
operator|)
condition|)
block|{
name|yy
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|weight
index|[
name|tmp
index|]
operator|<
name|weight
index|[
name|heap
index|[
name|yy
index|]
index|]
condition|)
block|{
break|break;
block|}
name|heap
index|[
name|zz
index|]
operator|=
name|heap
index|[
name|yy
index|]
expr_stmt|;
name|zz
operator|=
name|yy
expr_stmt|;
block|}
name|heap
index|[
name|zz
index|]
operator|=
name|tmp
expr_stmt|;
name|int
name|n2
init|=
name|heap
index|[
literal|1
index|]
decl_stmt|;
name|heap
index|[
literal|1
index|]
operator|=
name|heap
index|[
name|nHeap
index|]
expr_stmt|;
name|nHeap
operator|--
expr_stmt|;
name|yy
operator|=
literal|0
expr_stmt|;
name|zz
operator|=
literal|1
expr_stmt|;
name|tmp
operator|=
name|heap
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|yy
operator|=
name|zz
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|yy
operator|>
name|nHeap
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
name|yy
operator|<
name|nHeap
operator|)
operator|&&
operator|(
name|weight
index|[
name|heap
index|[
name|yy
operator|+
literal|1
index|]
index|]
operator|<
name|weight
index|[
name|heap
index|[
name|yy
index|]
index|]
operator|)
condition|)
block|{
name|yy
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|weight
index|[
name|tmp
index|]
operator|<
name|weight
index|[
name|heap
index|[
name|yy
index|]
index|]
condition|)
block|{
break|break;
block|}
name|heap
index|[
name|zz
index|]
operator|=
name|heap
index|[
name|yy
index|]
expr_stmt|;
name|zz
operator|=
name|yy
expr_stmt|;
block|}
name|heap
index|[
name|zz
index|]
operator|=
name|tmp
expr_stmt|;
name|nNodes
operator|++
expr_stmt|;
name|parent
index|[
name|n1
index|]
operator|=
name|parent
index|[
name|n2
index|]
operator|=
name|nNodes
expr_stmt|;
specifier|final
name|int
name|weight_n1
init|=
name|weight
index|[
name|n1
index|]
decl_stmt|;
specifier|final
name|int
name|weight_n2
init|=
name|weight
index|[
name|n2
index|]
decl_stmt|;
name|weight
index|[
name|nNodes
index|]
operator|=
operator|(
operator|(
name|weight_n1
operator|&
literal|0xffffff00
operator|)
operator|+
operator|(
name|weight_n2
operator|&
literal|0xffffff00
operator|)
operator|)
operator||
operator|(
literal|1
operator|+
operator|(
operator|(
operator|(
name|weight_n1
operator|&
literal|0x000000ff
operator|)
operator|>
operator|(
name|weight_n2
operator|&
literal|0x000000ff
operator|)
operator|)
condition|?
operator|(
name|weight_n1
operator|&
literal|0x000000ff
operator|)
else|:
operator|(
name|weight_n2
operator|&
literal|0x000000ff
operator|)
operator|)
operator|)
expr_stmt|;
name|parent
index|[
name|nNodes
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|nHeap
operator|++
expr_stmt|;
name|heap
index|[
name|nHeap
index|]
operator|=
name|nNodes
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
name|zz
operator|=
name|nHeap
expr_stmt|;
name|tmp
operator|=
name|heap
index|[
name|zz
index|]
expr_stmt|;
specifier|final
name|int
name|weight_tmp
init|=
name|weight
index|[
name|tmp
index|]
decl_stmt|;
while|while
condition|(
name|weight_tmp
operator|<
name|weight
index|[
name|heap
index|[
name|zz
operator|>>
literal|1
index|]
index|]
condition|)
block|{
name|heap
index|[
name|zz
index|]
operator|=
name|heap
index|[
name|zz
operator|>>
literal|1
index|]
expr_stmt|;
name|zz
operator|>>=
literal|1
expr_stmt|;
block|}
name|heap
index|[
name|zz
index|]
operator|=
name|tmp
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
name|int
name|k
init|=
name|i
decl_stmt|;
for|for
control|(
name|int
name|parent_k
init|;
operator|(
name|parent_k
operator|=
name|parent
index|[
name|k
index|]
operator|)
operator|>=
literal|0
condition|;
control|)
block|{
name|k
operator|=
name|parent_k
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|len
index|[
name|i
operator|-
literal|1
index|]
operator|=
operator|(
name|byte
operator|)
name|j
expr_stmt|;
if|if
condition|(
name|j
operator|>
name|maxLen
condition|)
block|{
name|tooLong
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tooLong
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
init|=
name|weight
index|[
name|i
index|]
operator|>>
literal|8
decl_stmt|;
name|j
operator|=
literal|1
operator|+
operator|(
name|j
operator|>>
literal|1
operator|)
expr_stmt|;
name|weight
index|[
name|i
index|]
operator|=
name|j
operator|<<
literal|8
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**   * Index of the last char in the block, so the block size == last + 1.   */
DECL|field|last
specifier|private
name|int
name|last
decl_stmt|;
comment|/**   * Index in fmap[] of original string after sorting.   */
DECL|field|origPtr
specifier|private
name|int
name|origPtr
decl_stmt|;
comment|/**   * Always: in the range 0 .. 9. The current block size is 100000 * this   * number.   */
DECL|field|blockSize100k
specifier|private
specifier|final
name|int
name|blockSize100k
decl_stmt|;
DECL|field|blockRandomised
specifier|private
name|boolean
name|blockRandomised
decl_stmt|;
DECL|field|bsBuff
specifier|private
name|int
name|bsBuff
decl_stmt|;
DECL|field|bsLive
specifier|private
name|int
name|bsLive
decl_stmt|;
DECL|field|crc
specifier|private
specifier|final
name|CRC
name|crc
init|=
operator|new
name|CRC
argument_list|()
decl_stmt|;
DECL|field|nInUse
specifier|private
name|int
name|nInUse
decl_stmt|;
DECL|field|nMTF
specifier|private
name|int
name|nMTF
decl_stmt|;
comment|/*   * Used when sorting. If too many long comparisons happen, we stop sorting,   * randomise the block slightly, and try again.   */
DECL|field|workDone
specifier|private
name|int
name|workDone
decl_stmt|;
DECL|field|workLimit
specifier|private
name|int
name|workLimit
decl_stmt|;
DECL|field|firstAttempt
specifier|private
name|boolean
name|firstAttempt
decl_stmt|;
DECL|field|currentChar
specifier|private
name|int
name|currentChar
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|runLength
specifier|private
name|int
name|runLength
init|=
literal|0
decl_stmt|;
DECL|field|blockCRC
specifier|private
name|int
name|blockCRC
decl_stmt|;
DECL|field|combinedCRC
specifier|private
name|int
name|combinedCRC
decl_stmt|;
DECL|field|allowableBlockSize
specifier|private
name|int
name|allowableBlockSize
decl_stmt|;
comment|/**   * All memory intensive stuff.   */
DECL|field|data
specifier|private
name|CBZip2OutputStream
operator|.
name|Data
name|data
decl_stmt|;
DECL|field|out
specifier|private
name|OutputStream
name|out
decl_stmt|;
comment|/**   * Chooses a blocksize based on the given length of the data to compress.   *   * @return The blocksize, between {@link #MIN_BLOCKSIZE} and   *         {@link #MAX_BLOCKSIZE} both inclusive. For a negative   *<tt>inputLength</tt> this method returns<tt>MAX_BLOCKSIZE</tt>   *         always.   *   * @param inputLength   *            The length of the data which will be compressed by   *<tt>CBZip2OutputStream</tt>.   */
DECL|method|chooseBlockSize (long inputLength)
specifier|public
specifier|static
name|int
name|chooseBlockSize
parameter_list|(
name|long
name|inputLength
parameter_list|)
block|{
return|return
operator|(
name|inputLength
operator|>
literal|0
operator|)
condition|?
operator|(
name|int
operator|)
name|Math
operator|.
name|min
argument_list|(
operator|(
name|inputLength
operator|/
literal|132000
operator|)
operator|+
literal|1
argument_list|,
literal|9
argument_list|)
else|:
name|MAX_BLOCKSIZE
return|;
block|}
comment|/**   * Constructs a new<tt>CBZip2OutputStream</tt> with a blocksize of 900k.   *   *<p>   *<b>Attention:</b>The caller is resonsible to write the two BZip2 magic   * bytes<tt>"BZ"</tt> to the specified stream prior to calling this   * constructor.   *</p>   *   * @param out *   *            the destination stream.   *   * @throws IOException   *             if an I/O error occurs in the specified stream.   * @throws NullPointerException   *             if<code>out == null</code>.   */
DECL|method|CBZip2OutputStream (final OutputStream out)
specifier|public
name|CBZip2OutputStream
parameter_list|(
specifier|final
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|out
argument_list|,
name|MAX_BLOCKSIZE
argument_list|)
expr_stmt|;
block|}
comment|/**   * Constructs a new<tt>CBZip2OutputStream</tt> with specified blocksize.   *   *<p>   *<b>Attention:</b>The caller is resonsible to write the two BZip2 magic   * bytes<tt>"BZ"</tt> to the specified stream prior to calling this   * constructor.   *</p>   *   *   * @param out   *            the destination stream.   * @param blockSize   *            the blockSize as 100k units.   *   * @throws IOException   *             if an I/O error occurs in the specified stream.   * @throws IllegalArgumentException   *             if<code>(blockSize< 1) || (blockSize> 9)</code>.   * @throws NullPointerException   *             if<code>out == null</code>.   *   * @see #MIN_BLOCKSIZE   * @see #MAX_BLOCKSIZE   */
DECL|method|CBZip2OutputStream (final OutputStream out, final int blockSize)
specifier|public
name|CBZip2OutputStream
parameter_list|(
specifier|final
name|OutputStream
name|out
parameter_list|,
specifier|final
name|int
name|blockSize
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|()
expr_stmt|;
if|if
condition|(
name|blockSize
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"blockSize("
operator|+
name|blockSize
operator|+
literal|")< 1"
argument_list|)
throw|;
block|}
if|if
condition|(
name|blockSize
operator|>
literal|9
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"blockSize("
operator|+
name|blockSize
operator|+
literal|")> 9"
argument_list|)
throw|;
block|}
name|this
operator|.
name|blockSize100k
operator|=
name|blockSize
expr_stmt|;
name|this
operator|.
name|out
operator|=
name|out
expr_stmt|;
name|init
argument_list|()
expr_stmt|;
block|}
DECL|method|write (final int b)
specifier|public
name|void
name|write
parameter_list|(
specifier|final
name|int
name|b
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|out
operator|!=
literal|null
condition|)
block|{
name|write0
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"closed"
argument_list|)
throw|;
block|}
block|}
DECL|method|writeRun ()
specifier|private
name|void
name|writeRun
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|lastShadow
init|=
name|this
operator|.
name|last
decl_stmt|;
if|if
condition|(
name|lastShadow
operator|<
name|this
operator|.
name|allowableBlockSize
condition|)
block|{
specifier|final
name|int
name|currentCharShadow
init|=
name|this
operator|.
name|currentChar
decl_stmt|;
specifier|final
name|Data
name|dataShadow
init|=
name|this
operator|.
name|data
decl_stmt|;
name|dataShadow
operator|.
name|inUse
index|[
name|currentCharShadow
index|]
operator|=
literal|true
expr_stmt|;
specifier|final
name|byte
name|ch
init|=
operator|(
name|byte
operator|)
name|currentCharShadow
decl_stmt|;
name|int
name|runLengthShadow
init|=
name|this
operator|.
name|runLength
decl_stmt|;
name|this
operator|.
name|crc
operator|.
name|updateCRC
argument_list|(
name|currentCharShadow
argument_list|,
name|runLengthShadow
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|runLengthShadow
condition|)
block|{
case|case
literal|1
case|:
name|dataShadow
operator|.
name|block
index|[
name|lastShadow
operator|+
literal|2
index|]
operator|=
name|ch
expr_stmt|;
name|this
operator|.
name|last
operator|=
name|lastShadow
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|dataShadow
operator|.
name|block
index|[
name|lastShadow
operator|+
literal|2
index|]
operator|=
name|ch
expr_stmt|;
name|dataShadow
operator|.
name|block
index|[
name|lastShadow
operator|+
literal|3
index|]
operator|=
name|ch
expr_stmt|;
name|this
operator|.
name|last
operator|=
name|lastShadow
operator|+
literal|2
expr_stmt|;
break|break;
case|case
literal|3
case|:
block|{
specifier|final
name|byte
index|[]
name|block
init|=
name|dataShadow
operator|.
name|block
decl_stmt|;
name|block
index|[
name|lastShadow
operator|+
literal|2
index|]
operator|=
name|ch
expr_stmt|;
name|block
index|[
name|lastShadow
operator|+
literal|3
index|]
operator|=
name|ch
expr_stmt|;
name|block
index|[
name|lastShadow
operator|+
literal|4
index|]
operator|=
name|ch
expr_stmt|;
name|this
operator|.
name|last
operator|=
name|lastShadow
operator|+
literal|3
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|runLengthShadow
operator|-=
literal|4
expr_stmt|;
name|dataShadow
operator|.
name|inUse
index|[
name|runLengthShadow
index|]
operator|=
literal|true
expr_stmt|;
specifier|final
name|byte
index|[]
name|block
init|=
name|dataShadow
operator|.
name|block
decl_stmt|;
name|block
index|[
name|lastShadow
operator|+
literal|2
index|]
operator|=
name|ch
expr_stmt|;
name|block
index|[
name|lastShadow
operator|+
literal|3
index|]
operator|=
name|ch
expr_stmt|;
name|block
index|[
name|lastShadow
operator|+
literal|4
index|]
operator|=
name|ch
expr_stmt|;
name|block
index|[
name|lastShadow
operator|+
literal|5
index|]
operator|=
name|ch
expr_stmt|;
name|block
index|[
name|lastShadow
operator|+
literal|6
index|]
operator|=
operator|(
name|byte
operator|)
name|runLengthShadow
expr_stmt|;
name|this
operator|.
name|last
operator|=
name|lastShadow
operator|+
literal|5
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
block|{
name|endBlock
argument_list|()
expr_stmt|;
name|initBlock
argument_list|()
expr_stmt|;
name|writeRun
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**   * Overriden to close the stream.   */
DECL|method|finalize ()
specifier|protected
name|void
name|finalize
parameter_list|()
throws|throws
name|Throwable
block|{
name|finish
argument_list|()
expr_stmt|;
name|super
operator|.
name|finalize
argument_list|()
expr_stmt|;
block|}
DECL|method|finish ()
specifier|public
name|void
name|finish
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|this
operator|.
name|runLength
operator|>
literal|0
condition|)
block|{
name|writeRun
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|currentChar
operator|=
operator|-
literal|1
expr_stmt|;
name|endBlock
argument_list|()
expr_stmt|;
name|endCompression
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|out
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|data
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|OutputStream
name|outShadow
init|=
name|this
operator|.
name|out
decl_stmt|;
name|finish
argument_list|()
expr_stmt|;
name|outShadow
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|flush ()
specifier|public
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
name|OutputStream
name|outShadow
init|=
name|this
operator|.
name|out
decl_stmt|;
if|if
condition|(
name|outShadow
operator|!=
literal|null
condition|)
block|{
name|outShadow
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|init ()
specifier|private
name|void
name|init
parameter_list|()
throws|throws
name|IOException
block|{
comment|// write magic: done by caller who created this stream
comment|// this.out.write('B');
comment|// this.out.write('Z');
name|this
operator|.
name|data
operator|=
operator|new
name|Data
argument_list|(
name|this
operator|.
name|blockSize100k
argument_list|)
expr_stmt|;
comment|/*     * Write `magic' bytes h indicating file-format == huffmanised, followed     * by a digit indicating blockSize100k.     */
name|bsPutUByte
argument_list|(
literal|'h'
argument_list|)
expr_stmt|;
name|bsPutUByte
argument_list|(
literal|'0'
operator|+
name|this
operator|.
name|blockSize100k
argument_list|)
expr_stmt|;
name|this
operator|.
name|combinedCRC
operator|=
literal|0
expr_stmt|;
name|initBlock
argument_list|()
expr_stmt|;
block|}
DECL|method|initBlock ()
specifier|private
name|void
name|initBlock
parameter_list|()
block|{
comment|// blockNo++;
name|this
operator|.
name|crc
operator|.
name|initialiseCRC
argument_list|()
expr_stmt|;
name|this
operator|.
name|last
operator|=
operator|-
literal|1
expr_stmt|;
comment|// ch = 0;
name|boolean
index|[]
name|inUse
init|=
name|this
operator|.
name|data
operator|.
name|inUse
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|256
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|inUse
index|[
name|i
index|]
operator|=
literal|false
expr_stmt|;
block|}
comment|/* 20 is just a paranoia constant */
name|this
operator|.
name|allowableBlockSize
operator|=
operator|(
name|this
operator|.
name|blockSize100k
operator|*
name|BZip2Constants
operator|.
name|baseBlockSize
operator|)
operator|-
literal|20
expr_stmt|;
block|}
DECL|method|endBlock ()
specifier|private
name|void
name|endBlock
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|blockCRC
operator|=
name|this
operator|.
name|crc
operator|.
name|getFinalCRC
argument_list|()
expr_stmt|;
name|this
operator|.
name|combinedCRC
operator|=
operator|(
name|this
operator|.
name|combinedCRC
operator|<<
literal|1
operator|)
operator||
operator|(
name|this
operator|.
name|combinedCRC
operator|>>>
literal|31
operator|)
expr_stmt|;
name|this
operator|.
name|combinedCRC
operator|^=
name|this
operator|.
name|blockCRC
expr_stmt|;
comment|// empty block at end of file
if|if
condition|(
name|this
operator|.
name|last
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
block|}
comment|/* sort the block and establish posn of original string */
name|blockSort
argument_list|()
expr_stmt|;
comment|/*     * A 6-byte block header, the value chosen arbitrarily as 0x314159265359     * :-). A 32 bit value does not really give a strong enough guarantee     * that the value will not appear by chance in the compressed     * datastream. Worst-case probability of this event, for a 900k block,     * is about 2.0e-3 for 32 bits, 1.0e-5 for 40 bits and 4.0e-8 for 48     * bits. For a compressed file of size 100Gb -- about 100000 blocks --     * only a 48-bit marker will do. NB: normal compression/ decompression     * donot rely on these statistical properties. They are only important     * when trying to recover blocks from damaged files.     */
name|bsPutUByte
argument_list|(
literal|0x31
argument_list|)
expr_stmt|;
name|bsPutUByte
argument_list|(
literal|0x41
argument_list|)
expr_stmt|;
name|bsPutUByte
argument_list|(
literal|0x59
argument_list|)
expr_stmt|;
name|bsPutUByte
argument_list|(
literal|0x26
argument_list|)
expr_stmt|;
name|bsPutUByte
argument_list|(
literal|0x53
argument_list|)
expr_stmt|;
name|bsPutUByte
argument_list|(
literal|0x59
argument_list|)
expr_stmt|;
comment|/* Now the block's CRC, so it is in a known place. */
name|bsPutInt
argument_list|(
name|this
operator|.
name|blockCRC
argument_list|)
expr_stmt|;
comment|/* Now a single bit indicating randomisation. */
if|if
condition|(
name|this
operator|.
name|blockRandomised
condition|)
block|{
name|bsW
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bsW
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Finally, block's contents proper. */
name|moveToFrontCodeAndSend
argument_list|()
expr_stmt|;
block|}
DECL|method|endCompression ()
specifier|private
name|void
name|endCompression
parameter_list|()
throws|throws
name|IOException
block|{
comment|/*     * Now another magic 48-bit number, 0x177245385090, to indicate the end     * of the last block. (sqrt(pi), if you want to know. I did want to use     * e, but it contains too much repetition -- 27 18 28 18 28 46 -- for me     * to feel statistically comfortable. Call me paranoid.)     */
name|bsPutUByte
argument_list|(
literal|0x17
argument_list|)
expr_stmt|;
name|bsPutUByte
argument_list|(
literal|0x72
argument_list|)
expr_stmt|;
name|bsPutUByte
argument_list|(
literal|0x45
argument_list|)
expr_stmt|;
name|bsPutUByte
argument_list|(
literal|0x38
argument_list|)
expr_stmt|;
name|bsPutUByte
argument_list|(
literal|0x50
argument_list|)
expr_stmt|;
name|bsPutUByte
argument_list|(
literal|0x90
argument_list|)
expr_stmt|;
name|bsPutInt
argument_list|(
name|this
operator|.
name|combinedCRC
argument_list|)
expr_stmt|;
name|bsFinishedWithStream
argument_list|()
expr_stmt|;
block|}
comment|/**   * Returns the blocksize parameter specified at construction time.   */
DECL|method|getBlockSize ()
specifier|public
specifier|final
name|int
name|getBlockSize
parameter_list|()
block|{
return|return
name|this
operator|.
name|blockSize100k
return|;
block|}
DECL|method|write (final byte[] buf, int offs, final int len)
specifier|public
name|void
name|write
parameter_list|(
specifier|final
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|offs
parameter_list|,
specifier|final
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|offs
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"offs("
operator|+
name|offs
operator|+
literal|")< 0."
argument_list|)
throw|;
block|}
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"len("
operator|+
name|len
operator|+
literal|")< 0."
argument_list|)
throw|;
block|}
if|if
condition|(
name|offs
operator|+
name|len
operator|>
name|buf
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"offs("
operator|+
name|offs
operator|+
literal|") + len("
operator|+
name|len
operator|+
literal|")> buf.length("
operator|+
name|buf
operator|.
name|length
operator|+
literal|")."
argument_list|)
throw|;
block|}
if|if
condition|(
name|this
operator|.
name|out
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"stream closed"
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|hi
init|=
name|offs
operator|+
name|len
init|;
name|offs
operator|<
name|hi
condition|;
control|)
block|{
name|write0
argument_list|(
name|buf
index|[
name|offs
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|write0 (int b)
specifier|private
name|void
name|write0
parameter_list|(
name|int
name|b
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|currentChar
operator|!=
operator|-
literal|1
condition|)
block|{
name|b
operator|&=
literal|0xff
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|currentChar
operator|==
name|b
condition|)
block|{
if|if
condition|(
operator|++
name|this
operator|.
name|runLength
operator|>
literal|254
condition|)
block|{
name|writeRun
argument_list|()
expr_stmt|;
name|this
operator|.
name|currentChar
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|runLength
operator|=
literal|0
expr_stmt|;
block|}
comment|// else nothing to do
block|}
else|else
block|{
name|writeRun
argument_list|()
expr_stmt|;
name|this
operator|.
name|runLength
operator|=
literal|1
expr_stmt|;
name|this
operator|.
name|currentChar
operator|=
name|b
expr_stmt|;
block|}
block|}
else|else
block|{
name|this
operator|.
name|currentChar
operator|=
name|b
operator|&
literal|0xff
expr_stmt|;
name|this
operator|.
name|runLength
operator|++
expr_stmt|;
block|}
block|}
DECL|method|hbAssignCodes (final int[] code, final byte[] length, final int minLen, final int maxLen, final int alphaSize)
specifier|private
specifier|static
name|void
name|hbAssignCodes
parameter_list|(
specifier|final
name|int
index|[]
name|code
parameter_list|,
specifier|final
name|byte
index|[]
name|length
parameter_list|,
specifier|final
name|int
name|minLen
parameter_list|,
specifier|final
name|int
name|maxLen
parameter_list|,
specifier|final
name|int
name|alphaSize
parameter_list|)
block|{
name|int
name|vec
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|n
init|=
name|minLen
init|;
name|n
operator|<=
name|maxLen
condition|;
name|n
operator|++
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|length
index|[
name|i
index|]
operator|&
literal|0xff
operator|)
operator|==
name|n
condition|)
block|{
name|code
index|[
name|i
index|]
operator|=
name|vec
expr_stmt|;
name|vec
operator|++
expr_stmt|;
block|}
block|}
name|vec
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
DECL|method|bsFinishedWithStream ()
specifier|private
name|void
name|bsFinishedWithStream
parameter_list|()
throws|throws
name|IOException
block|{
while|while
condition|(
name|this
operator|.
name|bsLive
operator|>
literal|0
condition|)
block|{
name|int
name|ch
init|=
name|this
operator|.
name|bsBuff
operator|>>
literal|24
decl_stmt|;
name|this
operator|.
name|out
operator|.
name|write
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|// write 8-bit
name|this
operator|.
name|bsBuff
operator|<<=
literal|8
expr_stmt|;
name|this
operator|.
name|bsLive
operator|-=
literal|8
expr_stmt|;
block|}
block|}
DECL|method|bsW (final int n, final int v)
specifier|private
name|void
name|bsW
parameter_list|(
specifier|final
name|int
name|n
parameter_list|,
specifier|final
name|int
name|v
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|OutputStream
name|outShadow
init|=
name|this
operator|.
name|out
decl_stmt|;
name|int
name|bsLiveShadow
init|=
name|this
operator|.
name|bsLive
decl_stmt|;
name|int
name|bsBuffShadow
init|=
name|this
operator|.
name|bsBuff
decl_stmt|;
while|while
condition|(
name|bsLiveShadow
operator|>=
literal|8
condition|)
block|{
name|outShadow
operator|.
name|write
argument_list|(
name|bsBuffShadow
operator|>>
literal|24
argument_list|)
expr_stmt|;
comment|// write 8-bit
name|bsBuffShadow
operator|<<=
literal|8
expr_stmt|;
name|bsLiveShadow
operator|-=
literal|8
expr_stmt|;
block|}
name|this
operator|.
name|bsBuff
operator|=
name|bsBuffShadow
operator||
operator|(
name|v
operator|<<
operator|(
literal|32
operator|-
name|bsLiveShadow
operator|-
name|n
operator|)
operator|)
expr_stmt|;
name|this
operator|.
name|bsLive
operator|=
name|bsLiveShadow
operator|+
name|n
expr_stmt|;
block|}
DECL|method|bsPutUByte (final int c)
specifier|private
name|void
name|bsPutUByte
parameter_list|(
specifier|final
name|int
name|c
parameter_list|)
throws|throws
name|IOException
block|{
name|bsW
argument_list|(
literal|8
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
DECL|method|bsPutInt (final int u)
specifier|private
name|void
name|bsPutInt
parameter_list|(
specifier|final
name|int
name|u
parameter_list|)
throws|throws
name|IOException
block|{
name|bsW
argument_list|(
literal|8
argument_list|,
operator|(
name|u
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bsW
argument_list|(
literal|8
argument_list|,
operator|(
name|u
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bsW
argument_list|(
literal|8
argument_list|,
operator|(
name|u
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bsW
argument_list|(
literal|8
argument_list|,
name|u
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
DECL|method|sendMTFValues ()
specifier|private
name|void
name|sendMTFValues
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|byte
index|[]
index|[]
name|len
init|=
name|this
operator|.
name|data
operator|.
name|sendMTFValues_len
decl_stmt|;
specifier|final
name|int
name|alphaSize
init|=
name|this
operator|.
name|nInUse
operator|+
literal|2
decl_stmt|;
for|for
control|(
name|int
name|t
init|=
name|N_GROUPS
init|;
operator|--
name|t
operator|>=
literal|0
condition|;
control|)
block|{
name|byte
index|[]
name|len_t
init|=
name|len
index|[
name|t
index|]
decl_stmt|;
for|for
control|(
name|int
name|v
init|=
name|alphaSize
init|;
operator|--
name|v
operator|>=
literal|0
condition|;
control|)
block|{
name|len_t
index|[
name|v
index|]
operator|=
name|GREATER_ICOST
expr_stmt|;
block|}
block|}
comment|/* Decide how many coding tables to use */
comment|// assert (this.nMTF> 0) : this.nMTF;
specifier|final
name|int
name|nGroups
init|=
operator|(
name|this
operator|.
name|nMTF
operator|<
literal|200
operator|)
condition|?
literal|2
else|:
operator|(
name|this
operator|.
name|nMTF
operator|<
literal|600
operator|)
condition|?
literal|3
else|:
operator|(
name|this
operator|.
name|nMTF
operator|<
literal|1200
operator|)
condition|?
literal|4
else|:
operator|(
name|this
operator|.
name|nMTF
operator|<
literal|2400
operator|)
condition|?
literal|5
else|:
literal|6
decl_stmt|;
comment|/* Generate an initial set of coding tables */
name|sendMTFValues0
argument_list|(
name|nGroups
argument_list|,
name|alphaSize
argument_list|)
expr_stmt|;
comment|/*     * Iterate up to N_ITERS times to improve the tables.     */
specifier|final
name|int
name|nSelectors
init|=
name|sendMTFValues1
argument_list|(
name|nGroups
argument_list|,
name|alphaSize
argument_list|)
decl_stmt|;
comment|/* Compute MTF values for the selectors. */
name|sendMTFValues2
argument_list|(
name|nGroups
argument_list|,
name|nSelectors
argument_list|)
expr_stmt|;
comment|/* Assign actual codes for the tables. */
name|sendMTFValues3
argument_list|(
name|nGroups
argument_list|,
name|alphaSize
argument_list|)
expr_stmt|;
comment|/* Transmit the mapping table. */
name|sendMTFValues4
argument_list|()
expr_stmt|;
comment|/* Now the selectors. */
name|sendMTFValues5
argument_list|(
name|nGroups
argument_list|,
name|nSelectors
argument_list|)
expr_stmt|;
comment|/* Now the coding tables. */
name|sendMTFValues6
argument_list|(
name|nGroups
argument_list|,
name|alphaSize
argument_list|)
expr_stmt|;
comment|/* And finally, the block data proper */
name|sendMTFValues7
argument_list|(
name|nSelectors
argument_list|)
expr_stmt|;
block|}
DECL|method|sendMTFValues0 (final int nGroups, final int alphaSize)
specifier|private
name|void
name|sendMTFValues0
parameter_list|(
specifier|final
name|int
name|nGroups
parameter_list|,
specifier|final
name|int
name|alphaSize
parameter_list|)
block|{
specifier|final
name|byte
index|[]
index|[]
name|len
init|=
name|this
operator|.
name|data
operator|.
name|sendMTFValues_len
decl_stmt|;
specifier|final
name|int
index|[]
name|mtfFreq
init|=
name|this
operator|.
name|data
operator|.
name|mtfFreq
decl_stmt|;
name|int
name|remF
init|=
name|this
operator|.
name|nMTF
decl_stmt|;
name|int
name|gs
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|nPart
init|=
name|nGroups
init|;
name|nPart
operator|>
literal|0
condition|;
name|nPart
operator|--
control|)
block|{
specifier|final
name|int
name|tFreq
init|=
name|remF
operator|/
name|nPart
decl_stmt|;
name|int
name|ge
init|=
name|gs
operator|-
literal|1
decl_stmt|;
name|int
name|aFreq
init|=
literal|0
decl_stmt|;
for|for
control|(
specifier|final
name|int
name|a
init|=
name|alphaSize
operator|-
literal|1
init|;
operator|(
name|aFreq
operator|<
name|tFreq
operator|)
operator|&&
operator|(
name|ge
operator|<
name|a
operator|)
condition|;
control|)
block|{
name|aFreq
operator|+=
name|mtfFreq
index|[
operator|++
name|ge
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ge
operator|>
name|gs
operator|)
operator|&&
operator|(
name|nPart
operator|!=
name|nGroups
operator|)
operator|&&
operator|(
name|nPart
operator|!=
literal|1
operator|)
operator|&&
operator|(
operator|(
operator|(
name|nGroups
operator|-
name|nPart
operator|)
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|aFreq
operator|-=
name|mtfFreq
index|[
name|ge
operator|--
index|]
expr_stmt|;
block|}
specifier|final
name|byte
index|[]
name|len_np
init|=
name|len
index|[
name|nPart
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|v
init|=
name|alphaSize
init|;
operator|--
name|v
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|v
operator|>=
name|gs
operator|)
operator|&&
operator|(
name|v
operator|<=
name|ge
operator|)
condition|)
block|{
name|len_np
index|[
name|v
index|]
operator|=
name|LESSER_ICOST
expr_stmt|;
block|}
else|else
block|{
name|len_np
index|[
name|v
index|]
operator|=
name|GREATER_ICOST
expr_stmt|;
block|}
block|}
name|gs
operator|=
name|ge
operator|+
literal|1
expr_stmt|;
name|remF
operator|-=
name|aFreq
expr_stmt|;
block|}
block|}
DECL|method|sendMTFValues1 (final int nGroups, final int alphaSize)
specifier|private
name|int
name|sendMTFValues1
parameter_list|(
specifier|final
name|int
name|nGroups
parameter_list|,
specifier|final
name|int
name|alphaSize
parameter_list|)
block|{
specifier|final
name|Data
name|dataShadow
init|=
name|this
operator|.
name|data
decl_stmt|;
specifier|final
name|int
index|[]
index|[]
name|rfreq
init|=
name|dataShadow
operator|.
name|sendMTFValues_rfreq
decl_stmt|;
specifier|final
name|int
index|[]
name|fave
init|=
name|dataShadow
operator|.
name|sendMTFValues_fave
decl_stmt|;
specifier|final
name|short
index|[]
name|cost
init|=
name|dataShadow
operator|.
name|sendMTFValues_cost
decl_stmt|;
specifier|final
name|char
index|[]
name|sfmap
init|=
name|dataShadow
operator|.
name|sfmap
decl_stmt|;
specifier|final
name|byte
index|[]
name|selector
init|=
name|dataShadow
operator|.
name|selector
decl_stmt|;
specifier|final
name|byte
index|[]
index|[]
name|len
init|=
name|dataShadow
operator|.
name|sendMTFValues_len
decl_stmt|;
specifier|final
name|byte
index|[]
name|len_0
init|=
name|len
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|byte
index|[]
name|len_1
init|=
name|len
index|[
literal|1
index|]
decl_stmt|;
specifier|final
name|byte
index|[]
name|len_2
init|=
name|len
index|[
literal|2
index|]
decl_stmt|;
specifier|final
name|byte
index|[]
name|len_3
init|=
name|len
index|[
literal|3
index|]
decl_stmt|;
specifier|final
name|byte
index|[]
name|len_4
init|=
name|len
index|[
literal|4
index|]
decl_stmt|;
specifier|final
name|byte
index|[]
name|len_5
init|=
name|len
index|[
literal|5
index|]
decl_stmt|;
specifier|final
name|int
name|nMTFShadow
init|=
name|this
operator|.
name|nMTF
decl_stmt|;
name|int
name|nSelectors
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|iter
init|=
literal|0
init|;
name|iter
operator|<
name|N_ITERS
condition|;
name|iter
operator|++
control|)
block|{
for|for
control|(
name|int
name|t
init|=
name|nGroups
init|;
operator|--
name|t
operator|>=
literal|0
condition|;
control|)
block|{
name|fave
index|[
name|t
index|]
operator|=
literal|0
expr_stmt|;
name|int
index|[]
name|rfreqt
init|=
name|rfreq
index|[
name|t
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|alphaSize
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|rfreqt
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|nSelectors
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|gs
init|=
literal|0
init|;
name|gs
operator|<
name|this
operator|.
name|nMTF
condition|;
control|)
block|{
comment|/* Set group start& end marks. */
comment|/*         * Calculate the cost of this group as coded by each of the         * coding tables.         */
specifier|final
name|int
name|ge
init|=
name|Math
operator|.
name|min
argument_list|(
name|gs
operator|+
name|G_SIZE
operator|-
literal|1
argument_list|,
name|nMTFShadow
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|nGroups
operator|==
name|N_GROUPS
condition|)
block|{
comment|// unrolled version of the else-block
name|short
name|cost0
init|=
literal|0
decl_stmt|;
name|short
name|cost1
init|=
literal|0
decl_stmt|;
name|short
name|cost2
init|=
literal|0
decl_stmt|;
name|short
name|cost3
init|=
literal|0
decl_stmt|;
name|short
name|cost4
init|=
literal|0
decl_stmt|;
name|short
name|cost5
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|gs
init|;
name|i
operator|<=
name|ge
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|icv
init|=
name|sfmap
index|[
name|i
index|]
decl_stmt|;
name|cost0
operator|+=
name|len_0
index|[
name|icv
index|]
operator|&
literal|0xff
expr_stmt|;
name|cost1
operator|+=
name|len_1
index|[
name|icv
index|]
operator|&
literal|0xff
expr_stmt|;
name|cost2
operator|+=
name|len_2
index|[
name|icv
index|]
operator|&
literal|0xff
expr_stmt|;
name|cost3
operator|+=
name|len_3
index|[
name|icv
index|]
operator|&
literal|0xff
expr_stmt|;
name|cost4
operator|+=
name|len_4
index|[
name|icv
index|]
operator|&
literal|0xff
expr_stmt|;
name|cost5
operator|+=
name|len_5
index|[
name|icv
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
name|cost
index|[
literal|0
index|]
operator|=
name|cost0
expr_stmt|;
name|cost
index|[
literal|1
index|]
operator|=
name|cost1
expr_stmt|;
name|cost
index|[
literal|2
index|]
operator|=
name|cost2
expr_stmt|;
name|cost
index|[
literal|3
index|]
operator|=
name|cost3
expr_stmt|;
name|cost
index|[
literal|4
index|]
operator|=
name|cost4
expr_stmt|;
name|cost
index|[
literal|5
index|]
operator|=
name|cost5
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|t
init|=
name|nGroups
init|;
operator|--
name|t
operator|>=
literal|0
condition|;
control|)
block|{
name|cost
index|[
name|t
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|gs
init|;
name|i
operator|<=
name|ge
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|icv
init|=
name|sfmap
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|int
name|t
init|=
name|nGroups
init|;
operator|--
name|t
operator|>=
literal|0
condition|;
control|)
block|{
name|cost
index|[
name|t
index|]
operator|+=
name|len
index|[
name|t
index|]
index|[
name|icv
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
block|}
block|}
comment|/*         * Find the coding table which is best for this group, and         * record its identity in the selector table.         */
name|int
name|bt
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|t
init|=
name|nGroups
init|,
name|bc
init|=
literal|999999999
init|;
operator|--
name|t
operator|>=
literal|0
condition|;
control|)
block|{
specifier|final
name|int
name|cost_t
init|=
name|cost
index|[
name|t
index|]
decl_stmt|;
if|if
condition|(
name|cost_t
operator|<
name|bc
condition|)
block|{
name|bc
operator|=
name|cost_t
expr_stmt|;
name|bt
operator|=
name|t
expr_stmt|;
block|}
block|}
name|fave
index|[
name|bt
index|]
operator|++
expr_stmt|;
name|selector
index|[
name|nSelectors
index|]
operator|=
operator|(
name|byte
operator|)
name|bt
expr_stmt|;
name|nSelectors
operator|++
expr_stmt|;
comment|/*         * Increment the symbol frequencies for the selected table.         */
specifier|final
name|int
index|[]
name|rfreq_bt
init|=
name|rfreq
index|[
name|bt
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|gs
init|;
name|i
operator|<=
name|ge
condition|;
name|i
operator|++
control|)
block|{
name|rfreq_bt
index|[
name|sfmap
index|[
name|i
index|]
index|]
operator|++
expr_stmt|;
block|}
name|gs
operator|=
name|ge
operator|+
literal|1
expr_stmt|;
block|}
comment|/*       * Recompute the tables based on the accumulated frequencies.       */
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|nGroups
condition|;
name|t
operator|++
control|)
block|{
name|hbMakeCodeLengths
argument_list|(
name|len
index|[
name|t
index|]
argument_list|,
name|rfreq
index|[
name|t
index|]
argument_list|,
name|this
operator|.
name|data
argument_list|,
name|alphaSize
argument_list|,
literal|20
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|nSelectors
return|;
block|}
DECL|method|sendMTFValues2 (final int nGroups, final int nSelectors)
specifier|private
name|void
name|sendMTFValues2
parameter_list|(
specifier|final
name|int
name|nGroups
parameter_list|,
specifier|final
name|int
name|nSelectors
parameter_list|)
block|{
comment|// assert (nGroups< 8) : nGroups;
specifier|final
name|Data
name|dataShadow
init|=
name|this
operator|.
name|data
decl_stmt|;
name|byte
index|[]
name|pos
init|=
name|dataShadow
operator|.
name|sendMTFValues2_pos
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|nGroups
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|pos
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|i
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nSelectors
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|byte
name|ll_i
init|=
name|dataShadow
operator|.
name|selector
index|[
name|i
index|]
decl_stmt|;
name|byte
name|tmp
init|=
name|pos
index|[
literal|0
index|]
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|ll_i
operator|!=
name|tmp
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|byte
name|tmp2
init|=
name|tmp
decl_stmt|;
name|tmp
operator|=
name|pos
index|[
name|j
index|]
expr_stmt|;
name|pos
index|[
name|j
index|]
operator|=
name|tmp2
expr_stmt|;
block|}
name|pos
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
name|dataShadow
operator|.
name|selectorMtf
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|j
expr_stmt|;
block|}
block|}
DECL|method|sendMTFValues3 (final int nGroups, final int alphaSize)
specifier|private
name|void
name|sendMTFValues3
parameter_list|(
specifier|final
name|int
name|nGroups
parameter_list|,
specifier|final
name|int
name|alphaSize
parameter_list|)
block|{
name|int
index|[]
index|[]
name|code
init|=
name|this
operator|.
name|data
operator|.
name|sendMTFValues_code
decl_stmt|;
name|byte
index|[]
index|[]
name|len
init|=
name|this
operator|.
name|data
operator|.
name|sendMTFValues_len
decl_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|nGroups
condition|;
name|t
operator|++
control|)
block|{
name|int
name|minLen
init|=
literal|32
decl_stmt|;
name|int
name|maxLen
init|=
literal|0
decl_stmt|;
specifier|final
name|byte
index|[]
name|len_t
init|=
name|len
index|[
name|t
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|alphaSize
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
specifier|final
name|int
name|l
init|=
name|len_t
index|[
name|i
index|]
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
name|l
operator|>
name|maxLen
condition|)
block|{
name|maxLen
operator|=
name|l
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|<
name|minLen
condition|)
block|{
name|minLen
operator|=
name|l
expr_stmt|;
block|}
block|}
comment|// assert (maxLen<= 20) : maxLen;
comment|// assert (minLen>= 1) : minLen;
name|hbAssignCodes
argument_list|(
name|code
index|[
name|t
index|]
argument_list|,
name|len
index|[
name|t
index|]
argument_list|,
name|minLen
argument_list|,
name|maxLen
argument_list|,
name|alphaSize
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|sendMTFValues4 ()
specifier|private
name|void
name|sendMTFValues4
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|boolean
index|[]
name|inUse
init|=
name|this
operator|.
name|data
operator|.
name|inUse
decl_stmt|;
specifier|final
name|boolean
index|[]
name|inUse16
init|=
name|this
operator|.
name|data
operator|.
name|sentMTFValues4_inUse16
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|16
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|inUse16
index|[
name|i
index|]
operator|=
literal|false
expr_stmt|;
specifier|final
name|int
name|i16
init|=
name|i
operator|*
literal|16
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|16
init|;
operator|--
name|j
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|inUse
index|[
name|i16
operator|+
name|j
index|]
condition|)
block|{
name|inUse16
index|[
name|i
index|]
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|bsW
argument_list|(
literal|1
argument_list|,
name|inUse16
index|[
name|i
index|]
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|final
name|OutputStream
name|outShadow
init|=
name|this
operator|.
name|out
decl_stmt|;
name|int
name|bsLiveShadow
init|=
name|this
operator|.
name|bsLive
decl_stmt|;
name|int
name|bsBuffShadow
init|=
name|this
operator|.
name|bsBuff
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inUse16
index|[
name|i
index|]
condition|)
block|{
specifier|final
name|int
name|i16
init|=
name|i
operator|*
literal|16
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
comment|// inlined: bsW(1, inUse[i16 + j] ? 1 : 0);
while|while
condition|(
name|bsLiveShadow
operator|>=
literal|8
condition|)
block|{
name|outShadow
operator|.
name|write
argument_list|(
name|bsBuffShadow
operator|>>
literal|24
argument_list|)
expr_stmt|;
comment|// write 8-bit
name|bsBuffShadow
operator|<<=
literal|8
expr_stmt|;
name|bsLiveShadow
operator|-=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|inUse
index|[
name|i16
operator|+
name|j
index|]
condition|)
block|{
name|bsBuffShadow
operator||=
literal|1
operator|<<
operator|(
literal|32
operator|-
name|bsLiveShadow
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|bsLiveShadow
operator|++
expr_stmt|;
block|}
block|}
block|}
name|this
operator|.
name|bsBuff
operator|=
name|bsBuffShadow
expr_stmt|;
name|this
operator|.
name|bsLive
operator|=
name|bsLiveShadow
expr_stmt|;
block|}
DECL|method|sendMTFValues5 (final int nGroups, final int nSelectors)
specifier|private
name|void
name|sendMTFValues5
parameter_list|(
specifier|final
name|int
name|nGroups
parameter_list|,
specifier|final
name|int
name|nSelectors
parameter_list|)
throws|throws
name|IOException
block|{
name|bsW
argument_list|(
literal|3
argument_list|,
name|nGroups
argument_list|)
expr_stmt|;
name|bsW
argument_list|(
literal|15
argument_list|,
name|nSelectors
argument_list|)
expr_stmt|;
specifier|final
name|OutputStream
name|outShadow
init|=
name|this
operator|.
name|out
decl_stmt|;
specifier|final
name|byte
index|[]
name|selectorMtf
init|=
name|this
operator|.
name|data
operator|.
name|selectorMtf
decl_stmt|;
name|int
name|bsLiveShadow
init|=
name|this
operator|.
name|bsLive
decl_stmt|;
name|int
name|bsBuffShadow
init|=
name|this
operator|.
name|bsBuff
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nSelectors
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|,
name|hj
init|=
name|selectorMtf
index|[
name|i
index|]
operator|&
literal|0xff
init|;
name|j
operator|<
name|hj
condition|;
name|j
operator|++
control|)
block|{
comment|// inlined: bsW(1, 1);
while|while
condition|(
name|bsLiveShadow
operator|>=
literal|8
condition|)
block|{
name|outShadow
operator|.
name|write
argument_list|(
name|bsBuffShadow
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|bsBuffShadow
operator|<<=
literal|8
expr_stmt|;
name|bsLiveShadow
operator|-=
literal|8
expr_stmt|;
block|}
name|bsBuffShadow
operator||=
literal|1
operator|<<
operator|(
literal|32
operator|-
name|bsLiveShadow
operator|-
literal|1
operator|)
expr_stmt|;
name|bsLiveShadow
operator|++
expr_stmt|;
block|}
comment|// inlined: bsW(1, 0);
while|while
condition|(
name|bsLiveShadow
operator|>=
literal|8
condition|)
block|{
name|outShadow
operator|.
name|write
argument_list|(
name|bsBuffShadow
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|bsBuffShadow
operator|<<=
literal|8
expr_stmt|;
name|bsLiveShadow
operator|-=
literal|8
expr_stmt|;
block|}
comment|// bsBuffShadow |= 0<< (32 - bsLiveShadow - 1);
name|bsLiveShadow
operator|++
expr_stmt|;
block|}
name|this
operator|.
name|bsBuff
operator|=
name|bsBuffShadow
expr_stmt|;
name|this
operator|.
name|bsLive
operator|=
name|bsLiveShadow
expr_stmt|;
block|}
DECL|method|sendMTFValues6 (final int nGroups, final int alphaSize)
specifier|private
name|void
name|sendMTFValues6
parameter_list|(
specifier|final
name|int
name|nGroups
parameter_list|,
specifier|final
name|int
name|alphaSize
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|byte
index|[]
index|[]
name|len
init|=
name|this
operator|.
name|data
operator|.
name|sendMTFValues_len
decl_stmt|;
specifier|final
name|OutputStream
name|outShadow
init|=
name|this
operator|.
name|out
decl_stmt|;
name|int
name|bsLiveShadow
init|=
name|this
operator|.
name|bsLive
decl_stmt|;
name|int
name|bsBuffShadow
init|=
name|this
operator|.
name|bsBuff
decl_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|nGroups
condition|;
name|t
operator|++
control|)
block|{
name|byte
index|[]
name|len_t
init|=
name|len
index|[
name|t
index|]
decl_stmt|;
name|int
name|curr
init|=
name|len_t
index|[
literal|0
index|]
operator|&
literal|0xff
decl_stmt|;
comment|// inlined: bsW(5, curr);
while|while
condition|(
name|bsLiveShadow
operator|>=
literal|8
condition|)
block|{
name|outShadow
operator|.
name|write
argument_list|(
name|bsBuffShadow
operator|>>
literal|24
argument_list|)
expr_stmt|;
comment|// write 8-bit
name|bsBuffShadow
operator|<<=
literal|8
expr_stmt|;
name|bsLiveShadow
operator|-=
literal|8
expr_stmt|;
block|}
name|bsBuffShadow
operator||=
name|curr
operator|<<
operator|(
literal|32
operator|-
name|bsLiveShadow
operator|-
literal|5
operator|)
expr_stmt|;
name|bsLiveShadow
operator|+=
literal|5
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
name|int
name|lti
init|=
name|len_t
index|[
name|i
index|]
operator|&
literal|0xff
decl_stmt|;
while|while
condition|(
name|curr
operator|<
name|lti
condition|)
block|{
comment|// inlined: bsW(2, 2);
while|while
condition|(
name|bsLiveShadow
operator|>=
literal|8
condition|)
block|{
name|outShadow
operator|.
name|write
argument_list|(
name|bsBuffShadow
operator|>>
literal|24
argument_list|)
expr_stmt|;
comment|// write 8-bit
name|bsBuffShadow
operator|<<=
literal|8
expr_stmt|;
name|bsLiveShadow
operator|-=
literal|8
expr_stmt|;
block|}
name|bsBuffShadow
operator||=
literal|2
operator|<<
operator|(
literal|32
operator|-
name|bsLiveShadow
operator|-
literal|2
operator|)
expr_stmt|;
name|bsLiveShadow
operator|+=
literal|2
expr_stmt|;
name|curr
operator|++
expr_stmt|;
comment|/* 10 */
block|}
while|while
condition|(
name|curr
operator|>
name|lti
condition|)
block|{
comment|// inlined: bsW(2, 3);
while|while
condition|(
name|bsLiveShadow
operator|>=
literal|8
condition|)
block|{
name|outShadow
operator|.
name|write
argument_list|(
name|bsBuffShadow
operator|>>
literal|24
argument_list|)
expr_stmt|;
comment|// write 8-bit
name|bsBuffShadow
operator|<<=
literal|8
expr_stmt|;
name|bsLiveShadow
operator|-=
literal|8
expr_stmt|;
block|}
name|bsBuffShadow
operator||=
literal|3
operator|<<
operator|(
literal|32
operator|-
name|bsLiveShadow
operator|-
literal|2
operator|)
expr_stmt|;
name|bsLiveShadow
operator|+=
literal|2
expr_stmt|;
name|curr
operator|--
expr_stmt|;
comment|/* 11 */
block|}
comment|// inlined: bsW(1, 0);
while|while
condition|(
name|bsLiveShadow
operator|>=
literal|8
condition|)
block|{
name|outShadow
operator|.
name|write
argument_list|(
name|bsBuffShadow
operator|>>
literal|24
argument_list|)
expr_stmt|;
comment|// write 8-bit
name|bsBuffShadow
operator|<<=
literal|8
expr_stmt|;
name|bsLiveShadow
operator|-=
literal|8
expr_stmt|;
block|}
comment|// bsBuffShadow |= 0<< (32 - bsLiveShadow - 1);
name|bsLiveShadow
operator|++
expr_stmt|;
block|}
block|}
name|this
operator|.
name|bsBuff
operator|=
name|bsBuffShadow
expr_stmt|;
name|this
operator|.
name|bsLive
operator|=
name|bsLiveShadow
expr_stmt|;
block|}
DECL|method|sendMTFValues7 (final int nSelectors)
specifier|private
name|void
name|sendMTFValues7
parameter_list|(
specifier|final
name|int
name|nSelectors
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Data
name|dataShadow
init|=
name|this
operator|.
name|data
decl_stmt|;
specifier|final
name|byte
index|[]
index|[]
name|len
init|=
name|dataShadow
operator|.
name|sendMTFValues_len
decl_stmt|;
specifier|final
name|int
index|[]
index|[]
name|code
init|=
name|dataShadow
operator|.
name|sendMTFValues_code
decl_stmt|;
specifier|final
name|OutputStream
name|outShadow
init|=
name|this
operator|.
name|out
decl_stmt|;
specifier|final
name|byte
index|[]
name|selector
init|=
name|dataShadow
operator|.
name|selector
decl_stmt|;
specifier|final
name|char
index|[]
name|sfmap
init|=
name|dataShadow
operator|.
name|sfmap
decl_stmt|;
specifier|final
name|int
name|nMTFShadow
init|=
name|this
operator|.
name|nMTF
decl_stmt|;
name|int
name|selCtr
init|=
literal|0
decl_stmt|;
name|int
name|bsLiveShadow
init|=
name|this
operator|.
name|bsLive
decl_stmt|;
name|int
name|bsBuffShadow
init|=
name|this
operator|.
name|bsBuff
decl_stmt|;
for|for
control|(
name|int
name|gs
init|=
literal|0
init|;
name|gs
operator|<
name|nMTFShadow
condition|;
control|)
block|{
specifier|final
name|int
name|ge
init|=
name|Math
operator|.
name|min
argument_list|(
name|gs
operator|+
name|G_SIZE
operator|-
literal|1
argument_list|,
name|nMTFShadow
operator|-
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|int
name|selector_selCtr
init|=
name|selector
index|[
name|selCtr
index|]
operator|&
literal|0xff
decl_stmt|;
specifier|final
name|int
index|[]
name|code_selCtr
init|=
name|code
index|[
name|selector_selCtr
index|]
decl_stmt|;
specifier|final
name|byte
index|[]
name|len_selCtr
init|=
name|len
index|[
name|selector_selCtr
index|]
decl_stmt|;
while|while
condition|(
name|gs
operator|<=
name|ge
condition|)
block|{
specifier|final
name|int
name|sfmap_i
init|=
name|sfmap
index|[
name|gs
index|]
decl_stmt|;
comment|//
comment|// inlined: bsW(len_selCtr[sfmap_i]& 0xff,
comment|// code_selCtr[sfmap_i]);
comment|//
while|while
condition|(
name|bsLiveShadow
operator|>=
literal|8
condition|)
block|{
name|outShadow
operator|.
name|write
argument_list|(
name|bsBuffShadow
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|bsBuffShadow
operator|<<=
literal|8
expr_stmt|;
name|bsLiveShadow
operator|-=
literal|8
expr_stmt|;
block|}
specifier|final
name|int
name|n
init|=
name|len_selCtr
index|[
name|sfmap_i
index|]
operator|&
literal|0xFF
decl_stmt|;
name|bsBuffShadow
operator||=
name|code_selCtr
index|[
name|sfmap_i
index|]
operator|<<
operator|(
literal|32
operator|-
name|bsLiveShadow
operator|-
name|n
operator|)
expr_stmt|;
name|bsLiveShadow
operator|+=
name|n
expr_stmt|;
name|gs
operator|++
expr_stmt|;
block|}
name|gs
operator|=
name|ge
operator|+
literal|1
expr_stmt|;
name|selCtr
operator|++
expr_stmt|;
block|}
name|this
operator|.
name|bsBuff
operator|=
name|bsBuffShadow
expr_stmt|;
name|this
operator|.
name|bsLive
operator|=
name|bsLiveShadow
expr_stmt|;
block|}
DECL|method|moveToFrontCodeAndSend ()
specifier|private
name|void
name|moveToFrontCodeAndSend
parameter_list|()
throws|throws
name|IOException
block|{
name|bsW
argument_list|(
literal|24
argument_list|,
name|this
operator|.
name|origPtr
argument_list|)
expr_stmt|;
name|generateMTFValues
argument_list|()
expr_stmt|;
name|sendMTFValues
argument_list|()
expr_stmt|;
block|}
comment|/**   * This is the most hammered method of this class.   *   *<p>   * This is the version using unrolled loops. Normally I never use such ones   * in Java code. The unrolling has shown a noticable performance improvement   * on JRE 1.4.2 (Linux i586 / HotSpot Client). Of course it depends on the   * JIT compiler of the vm.   *</p>   */
DECL|method|mainSimpleSort (final Data dataShadow, final int lo, final int hi, final int d)
specifier|private
name|boolean
name|mainSimpleSort
parameter_list|(
specifier|final
name|Data
name|dataShadow
parameter_list|,
specifier|final
name|int
name|lo
parameter_list|,
specifier|final
name|int
name|hi
parameter_list|,
specifier|final
name|int
name|d
parameter_list|)
block|{
specifier|final
name|int
name|bigN
init|=
name|hi
operator|-
name|lo
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|bigN
operator|<
literal|2
condition|)
block|{
return|return
name|this
operator|.
name|firstAttempt
operator|&&
operator|(
name|this
operator|.
name|workDone
operator|>
name|this
operator|.
name|workLimit
operator|)
return|;
block|}
name|int
name|hp
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|INCS
index|[
name|hp
index|]
operator|<
name|bigN
condition|)
block|{
name|hp
operator|++
expr_stmt|;
block|}
specifier|final
name|int
index|[]
name|fmap
init|=
name|dataShadow
operator|.
name|fmap
decl_stmt|;
specifier|final
name|char
index|[]
name|quadrant
init|=
name|dataShadow
operator|.
name|quadrant
decl_stmt|;
specifier|final
name|byte
index|[]
name|block
init|=
name|dataShadow
operator|.
name|block
decl_stmt|;
specifier|final
name|int
name|lastShadow
init|=
name|this
operator|.
name|last
decl_stmt|;
specifier|final
name|int
name|lastPlus1
init|=
name|lastShadow
operator|+
literal|1
decl_stmt|;
specifier|final
name|boolean
name|firstAttemptShadow
init|=
name|this
operator|.
name|firstAttempt
decl_stmt|;
specifier|final
name|int
name|workLimitShadow
init|=
name|this
operator|.
name|workLimit
decl_stmt|;
name|int
name|workDoneShadow
init|=
name|this
operator|.
name|workDone
decl_stmt|;
comment|// Following block contains unrolled code which could be shortened by
comment|// coding it in additional loops.
name|HP
label|:
while|while
condition|(
operator|--
name|hp
operator|>=
literal|0
condition|)
block|{
specifier|final
name|int
name|h
init|=
name|INCS
index|[
name|hp
index|]
decl_stmt|;
specifier|final
name|int
name|mj
init|=
name|lo
operator|+
name|h
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|lo
operator|+
name|h
init|;
name|i
operator|<=
name|hi
condition|;
control|)
block|{
comment|// copy
for|for
control|(
name|int
name|k
init|=
literal|3
init|;
operator|(
name|i
operator|<=
name|hi
operator|)
operator|&&
operator|(
operator|--
name|k
operator|>=
literal|0
operator|)
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|v
init|=
name|fmap
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|int
name|vd
init|=
name|v
operator|+
name|d
decl_stmt|;
name|int
name|j
init|=
name|i
decl_stmt|;
comment|// for (int a;
comment|// (j> mj)&& mainGtU((a = fmap[j - h]) + d, vd,
comment|// block, quadrant, lastShadow);
comment|// j -= h) {
comment|// fmap[j] = a;
comment|// }
comment|//
comment|// unrolled version:
comment|// start inline mainGTU
name|boolean
name|onceRunned
init|=
literal|false
decl_stmt|;
name|int
name|a
init|=
literal|0
decl_stmt|;
name|HAMMER
label|:
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|onceRunned
condition|)
block|{
name|fmap
index|[
name|j
index|]
operator|=
name|a
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|-=
name|h
operator|)
operator|<=
name|mj
condition|)
block|{
break|break
name|HAMMER
break|;
block|}
block|}
else|else
block|{
name|onceRunned
operator|=
literal|true
expr_stmt|;
block|}
name|a
operator|=
name|fmap
index|[
name|j
operator|-
name|h
index|]
expr_stmt|;
name|int
name|i1
init|=
name|a
operator|+
name|d
decl_stmt|;
name|int
name|i2
init|=
name|vd
decl_stmt|;
comment|// following could be done in a loop, but
comment|// unrolled it for performance:
if|if
condition|(
name|block
index|[
name|i1
operator|+
literal|1
index|]
operator|==
name|block
index|[
name|i2
operator|+
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|block
index|[
name|i1
operator|+
literal|2
index|]
operator|==
name|block
index|[
name|i2
operator|+
literal|2
index|]
condition|)
block|{
if|if
condition|(
name|block
index|[
name|i1
operator|+
literal|3
index|]
operator|==
name|block
index|[
name|i2
operator|+
literal|3
index|]
condition|)
block|{
if|if
condition|(
name|block
index|[
name|i1
operator|+
literal|4
index|]
operator|==
name|block
index|[
name|i2
operator|+
literal|4
index|]
condition|)
block|{
if|if
condition|(
name|block
index|[
name|i1
operator|+
literal|5
index|]
operator|==
name|block
index|[
name|i2
operator|+
literal|5
index|]
condition|)
block|{
if|if
condition|(
name|block
index|[
operator|(
name|i1
operator|+=
literal|6
operator|)
index|]
operator|==
name|block
index|[
operator|(
name|i2
operator|+=
literal|6
operator|)
index|]
condition|)
block|{
name|int
name|x
init|=
name|lastShadow
decl_stmt|;
name|X
label|:
while|while
condition|(
name|x
operator|>
literal|0
condition|)
block|{
name|x
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|block
index|[
name|i1
operator|+
literal|1
index|]
operator|==
name|block
index|[
name|i2
operator|+
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|quadrant
index|[
name|i1
index|]
operator|==
name|quadrant
index|[
name|i2
index|]
condition|)
block|{
if|if
condition|(
name|block
index|[
name|i1
operator|+
literal|2
index|]
operator|==
name|block
index|[
name|i2
operator|+
literal|2
index|]
condition|)
block|{
if|if
condition|(
name|quadrant
index|[
name|i1
operator|+
literal|1
index|]
operator|==
name|quadrant
index|[
name|i2
operator|+
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|block
index|[
name|i1
operator|+
literal|3
index|]
operator|==
name|block
index|[
name|i2
operator|+
literal|3
index|]
condition|)
block|{
if|if
condition|(
name|quadrant
index|[
name|i1
operator|+
literal|2
index|]
operator|==
name|quadrant
index|[
name|i2
operator|+
literal|2
index|]
condition|)
block|{
if|if
condition|(
name|block
index|[
name|i1
operator|+
literal|4
index|]
operator|==
name|block
index|[
name|i2
operator|+
literal|4
index|]
condition|)
block|{
if|if
condition|(
name|quadrant
index|[
name|i1
operator|+
literal|3
index|]
operator|==
name|quadrant
index|[
name|i2
operator|+
literal|3
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|i1
operator|+=
literal|4
operator|)
operator|>=
name|lastPlus1
condition|)
block|{
name|i1
operator|-=
name|lastPlus1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i2
operator|+=
literal|4
operator|)
operator|>=
name|lastPlus1
condition|)
block|{
name|i2
operator|-=
name|lastPlus1
expr_stmt|;
block|}
name|workDoneShadow
operator|++
expr_stmt|;
continue|continue
name|X
continue|;
block|}
elseif|else
if|if
condition|(
operator|(
name|quadrant
index|[
name|i1
operator|+
literal|3
index|]
operator|>
name|quadrant
index|[
name|i2
operator|+
literal|3
index|]
operator|)
condition|)
block|{
continue|continue
name|HAMMER
continue|;
block|}
else|else
block|{
break|break
name|HAMMER
break|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|block
index|[
name|i1
operator|+
literal|4
index|]
operator|&
literal|0xff
operator|)
operator|>
operator|(
name|block
index|[
name|i2
operator|+
literal|4
index|]
operator|&
literal|0xff
operator|)
condition|)
block|{
continue|continue
name|HAMMER
continue|;
block|}
else|else
block|{
break|break
name|HAMMER
break|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|quadrant
index|[
name|i1
operator|+
literal|2
index|]
operator|>
name|quadrant
index|[
name|i2
operator|+
literal|2
index|]
operator|)
condition|)
block|{
continue|continue
name|HAMMER
continue|;
block|}
else|else
block|{
break|break
name|HAMMER
break|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|block
index|[
name|i1
operator|+
literal|3
index|]
operator|&
literal|0xff
operator|)
operator|>
operator|(
name|block
index|[
name|i2
operator|+
literal|3
index|]
operator|&
literal|0xff
operator|)
condition|)
block|{
continue|continue
name|HAMMER
continue|;
block|}
else|else
block|{
break|break
name|HAMMER
break|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|quadrant
index|[
name|i1
operator|+
literal|1
index|]
operator|>
name|quadrant
index|[
name|i2
operator|+
literal|1
index|]
operator|)
condition|)
block|{
continue|continue
name|HAMMER
continue|;
block|}
else|else
block|{
break|break
name|HAMMER
break|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|block
index|[
name|i1
operator|+
literal|2
index|]
operator|&
literal|0xff
operator|)
operator|>
operator|(
name|block
index|[
name|i2
operator|+
literal|2
index|]
operator|&
literal|0xff
operator|)
condition|)
block|{
continue|continue
name|HAMMER
continue|;
block|}
else|else
block|{
break|break
name|HAMMER
break|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|quadrant
index|[
name|i1
index|]
operator|>
name|quadrant
index|[
name|i2
index|]
operator|)
condition|)
block|{
continue|continue
name|HAMMER
continue|;
block|}
else|else
block|{
break|break
name|HAMMER
break|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|block
index|[
name|i1
operator|+
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|>
operator|(
name|block
index|[
name|i2
operator|+
literal|1
index|]
operator|&
literal|0xff
operator|)
condition|)
block|{
continue|continue
name|HAMMER
continue|;
block|}
else|else
block|{
break|break
name|HAMMER
break|;
block|}
block|}
break|break
name|HAMMER
break|;
block|}
comment|// while x> 0
else|else
block|{
if|if
condition|(
operator|(
name|block
index|[
name|i1
index|]
operator|&
literal|0xff
operator|)
operator|>
operator|(
name|block
index|[
name|i2
index|]
operator|&
literal|0xff
operator|)
condition|)
block|{
continue|continue
name|HAMMER
continue|;
block|}
else|else
block|{
break|break
name|HAMMER
break|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|block
index|[
name|i1
operator|+
literal|5
index|]
operator|&
literal|0xff
operator|)
operator|>
operator|(
name|block
index|[
name|i2
operator|+
literal|5
index|]
operator|&
literal|0xff
operator|)
condition|)
block|{
continue|continue
name|HAMMER
continue|;
block|}
else|else
block|{
break|break
name|HAMMER
break|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|block
index|[
name|i1
operator|+
literal|4
index|]
operator|&
literal|0xff
operator|)
operator|>
operator|(
name|block
index|[
name|i2
operator|+
literal|4
index|]
operator|&
literal|0xff
operator|)
condition|)
block|{
continue|continue
name|HAMMER
continue|;
block|}
else|else
block|{
break|break
name|HAMMER
break|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|block
index|[
name|i1
operator|+
literal|3
index|]
operator|&
literal|0xff
operator|)
operator|>
operator|(
name|block
index|[
name|i2
operator|+
literal|3
index|]
operator|&
literal|0xff
operator|)
condition|)
block|{
continue|continue
name|HAMMER
continue|;
block|}
else|else
block|{
break|break
name|HAMMER
break|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|block
index|[
name|i1
operator|+
literal|2
index|]
operator|&
literal|0xff
operator|)
operator|>
operator|(
name|block
index|[
name|i2
operator|+
literal|2
index|]
operator|&
literal|0xff
operator|)
condition|)
block|{
continue|continue
name|HAMMER
continue|;
block|}
else|else
block|{
break|break
name|HAMMER
break|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|block
index|[
name|i1
operator|+
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|>
operator|(
name|block
index|[
name|i2
operator|+
literal|1
index|]
operator|&
literal|0xff
operator|)
condition|)
block|{
continue|continue
name|HAMMER
continue|;
block|}
else|else
block|{
break|break
name|HAMMER
break|;
block|}
block|}
comment|// HAMMER
comment|// end inline mainGTU
name|fmap
index|[
name|j
index|]
operator|=
name|v
expr_stmt|;
block|}
if|if
condition|(
name|firstAttemptShadow
operator|&&
operator|(
name|i
operator|<=
name|hi
operator|)
operator|&&
operator|(
name|workDoneShadow
operator|>
name|workLimitShadow
operator|)
condition|)
block|{
break|break
name|HP
break|;
block|}
block|}
block|}
name|this
operator|.
name|workDone
operator|=
name|workDoneShadow
expr_stmt|;
return|return
name|firstAttemptShadow
operator|&&
operator|(
name|workDoneShadow
operator|>
name|workLimitShadow
operator|)
return|;
block|}
DECL|method|vswap (int[] fmap, int p1, int p2, int n)
specifier|private
specifier|static
name|void
name|vswap
parameter_list|(
name|int
index|[]
name|fmap
parameter_list|,
name|int
name|p1
parameter_list|,
name|int
name|p2
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|n
operator|+=
name|p1
expr_stmt|;
while|while
condition|(
name|p1
operator|<
name|n
condition|)
block|{
name|int
name|t
init|=
name|fmap
index|[
name|p1
index|]
decl_stmt|;
name|fmap
index|[
name|p1
operator|++
index|]
operator|=
name|fmap
index|[
name|p2
index|]
expr_stmt|;
name|fmap
index|[
name|p2
operator|++
index|]
operator|=
name|t
expr_stmt|;
block|}
block|}
DECL|method|med3 (byte a, byte b, byte c)
specifier|private
specifier|static
name|byte
name|med3
parameter_list|(
name|byte
name|a
parameter_list|,
name|byte
name|b
parameter_list|,
name|byte
name|c
parameter_list|)
block|{
return|return
operator|(
name|a
operator|<
name|b
operator|)
condition|?
operator|(
name|b
operator|<
name|c
condition|?
name|b
else|:
name|a
operator|<
name|c
condition|?
name|c
else|:
name|a
operator|)
else|:
operator|(
name|b
operator|>
name|c
condition|?
name|b
else|:
name|a
operator|>
name|c
condition|?
name|c
else|:
name|a
operator|)
return|;
block|}
DECL|method|blockSort ()
specifier|private
name|void
name|blockSort
parameter_list|()
block|{
name|this
operator|.
name|workLimit
operator|=
name|WORK_FACTOR
operator|*
name|this
operator|.
name|last
expr_stmt|;
name|this
operator|.
name|workDone
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|blockRandomised
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|firstAttempt
operator|=
literal|true
expr_stmt|;
name|mainSort
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|firstAttempt
operator|&&
operator|(
name|this
operator|.
name|workDone
operator|>
name|this
operator|.
name|workLimit
operator|)
condition|)
block|{
name|randomiseBlock
argument_list|()
expr_stmt|;
name|this
operator|.
name|workLimit
operator|=
name|this
operator|.
name|workDone
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|firstAttempt
operator|=
literal|false
expr_stmt|;
name|mainSort
argument_list|()
expr_stmt|;
block|}
name|int
index|[]
name|fmap
init|=
name|this
operator|.
name|data
operator|.
name|fmap
decl_stmt|;
name|this
operator|.
name|origPtr
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|lastShadow
init|=
name|this
operator|.
name|last
init|;
name|i
operator|<=
name|lastShadow
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fmap
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|origPtr
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|// assert (this.origPtr != -1) : this.origPtr;
block|}
comment|/**   * Method "mainQSort3", file "blocksort.c", BZip2 1.0.2   */
DECL|method|mainQSort3 (final Data dataShadow, final int loSt, final int hiSt, final int dSt)
specifier|private
name|void
name|mainQSort3
parameter_list|(
specifier|final
name|Data
name|dataShadow
parameter_list|,
specifier|final
name|int
name|loSt
parameter_list|,
specifier|final
name|int
name|hiSt
parameter_list|,
specifier|final
name|int
name|dSt
parameter_list|)
block|{
specifier|final
name|int
index|[]
name|stack_ll
init|=
name|dataShadow
operator|.
name|stack_ll
decl_stmt|;
specifier|final
name|int
index|[]
name|stack_hh
init|=
name|dataShadow
operator|.
name|stack_hh
decl_stmt|;
specifier|final
name|int
index|[]
name|stack_dd
init|=
name|dataShadow
operator|.
name|stack_dd
decl_stmt|;
specifier|final
name|int
index|[]
name|fmap
init|=
name|dataShadow
operator|.
name|fmap
decl_stmt|;
specifier|final
name|byte
index|[]
name|block
init|=
name|dataShadow
operator|.
name|block
decl_stmt|;
name|stack_ll
index|[
literal|0
index|]
operator|=
name|loSt
expr_stmt|;
name|stack_hh
index|[
literal|0
index|]
operator|=
name|hiSt
expr_stmt|;
name|stack_dd
index|[
literal|0
index|]
operator|=
name|dSt
expr_stmt|;
for|for
control|(
name|int
name|sp
init|=
literal|1
init|;
operator|--
name|sp
operator|>=
literal|0
condition|;
control|)
block|{
specifier|final
name|int
name|lo
init|=
name|stack_ll
index|[
name|sp
index|]
decl_stmt|;
specifier|final
name|int
name|hi
init|=
name|stack_hh
index|[
name|sp
index|]
decl_stmt|;
specifier|final
name|int
name|d
init|=
name|stack_dd
index|[
name|sp
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|hi
operator|-
name|lo
operator|<
name|SMALL_THRESH
operator|)
operator|||
operator|(
name|d
operator|>
name|DEPTH_THRESH
operator|)
condition|)
block|{
if|if
condition|(
name|mainSimpleSort
argument_list|(
name|dataShadow
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|,
name|d
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
else|else
block|{
specifier|final
name|int
name|d1
init|=
name|d
operator|+
literal|1
decl_stmt|;
specifier|final
name|int
name|med
init|=
name|med3
argument_list|(
name|block
index|[
name|fmap
index|[
name|lo
index|]
operator|+
name|d1
index|]
argument_list|,
name|block
index|[
name|fmap
index|[
name|hi
index|]
operator|+
name|d1
index|]
argument_list|,
name|block
index|[
name|fmap
index|[
operator|(
name|lo
operator|+
name|hi
operator|)
operator|>>>
literal|1
index|]
operator|+
name|d1
index|]
argument_list|)
operator|&
literal|0xff
decl_stmt|;
name|int
name|unLo
init|=
name|lo
decl_stmt|;
name|int
name|unHi
init|=
name|hi
decl_stmt|;
name|int
name|ltLo
init|=
name|lo
decl_stmt|;
name|int
name|gtHi
init|=
name|hi
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
while|while
condition|(
name|unLo
operator|<=
name|unHi
condition|)
block|{
specifier|final
name|int
name|n
init|=
operator|(
operator|(
name|int
operator|)
name|block
index|[
name|fmap
index|[
name|unLo
index|]
operator|+
name|d1
index|]
operator|&
literal|0xff
operator|)
operator|-
name|med
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
specifier|final
name|int
name|temp
init|=
name|fmap
index|[
name|unLo
index|]
decl_stmt|;
name|fmap
index|[
name|unLo
operator|++
index|]
operator|=
name|fmap
index|[
name|ltLo
index|]
expr_stmt|;
name|fmap
index|[
name|ltLo
operator|++
index|]
operator|=
name|temp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|unLo
operator|++
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
while|while
condition|(
name|unLo
operator|<=
name|unHi
condition|)
block|{
specifier|final
name|int
name|n
init|=
operator|(
operator|(
name|int
operator|)
name|block
index|[
name|fmap
index|[
name|unHi
index|]
operator|+
name|d1
index|]
operator|&
literal|0xff
operator|)
operator|-
name|med
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
specifier|final
name|int
name|temp
init|=
name|fmap
index|[
name|unHi
index|]
decl_stmt|;
name|fmap
index|[
name|unHi
operator|--
index|]
operator|=
name|fmap
index|[
name|gtHi
index|]
expr_stmt|;
name|fmap
index|[
name|gtHi
operator|--
index|]
operator|=
name|temp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|unHi
operator|--
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
if|if
condition|(
name|unLo
operator|<=
name|unHi
condition|)
block|{
specifier|final
name|int
name|temp
init|=
name|fmap
index|[
name|unLo
index|]
decl_stmt|;
name|fmap
index|[
name|unLo
operator|++
index|]
operator|=
name|fmap
index|[
name|unHi
index|]
expr_stmt|;
name|fmap
index|[
name|unHi
operator|--
index|]
operator|=
name|temp
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
if|if
condition|(
name|gtHi
operator|<
name|ltLo
condition|)
block|{
name|stack_ll
index|[
name|sp
index|]
operator|=
name|lo
expr_stmt|;
name|stack_hh
index|[
name|sp
index|]
operator|=
name|hi
expr_stmt|;
name|stack_dd
index|[
name|sp
index|]
operator|=
name|d1
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|int
name|n
init|=
operator|(
operator|(
name|ltLo
operator|-
name|lo
operator|)
operator|<
operator|(
name|unLo
operator|-
name|ltLo
operator|)
operator|)
condition|?
operator|(
name|ltLo
operator|-
name|lo
operator|)
else|:
operator|(
name|unLo
operator|-
name|ltLo
operator|)
decl_stmt|;
name|vswap
argument_list|(
name|fmap
argument_list|,
name|lo
argument_list|,
name|unLo
operator|-
name|n
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|int
name|m
init|=
operator|(
operator|(
name|hi
operator|-
name|gtHi
operator|)
operator|<
operator|(
name|gtHi
operator|-
name|unHi
operator|)
operator|)
condition|?
operator|(
name|hi
operator|-
name|gtHi
operator|)
else|:
operator|(
name|gtHi
operator|-
name|unHi
operator|)
decl_stmt|;
name|vswap
argument_list|(
name|fmap
argument_list|,
name|unLo
argument_list|,
name|hi
operator|-
name|m
operator|+
literal|1
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|n
operator|=
name|lo
operator|+
name|unLo
operator|-
name|ltLo
operator|-
literal|1
expr_stmt|;
name|m
operator|=
name|hi
operator|-
operator|(
name|gtHi
operator|-
name|unHi
operator|)
operator|+
literal|1
expr_stmt|;
name|stack_ll
index|[
name|sp
index|]
operator|=
name|lo
expr_stmt|;
name|stack_hh
index|[
name|sp
index|]
operator|=
name|n
expr_stmt|;
name|stack_dd
index|[
name|sp
index|]
operator|=
name|d
expr_stmt|;
name|sp
operator|++
expr_stmt|;
name|stack_ll
index|[
name|sp
index|]
operator|=
name|n
operator|+
literal|1
expr_stmt|;
name|stack_hh
index|[
name|sp
index|]
operator|=
name|m
operator|-
literal|1
expr_stmt|;
name|stack_dd
index|[
name|sp
index|]
operator|=
name|d1
expr_stmt|;
name|sp
operator|++
expr_stmt|;
name|stack_ll
index|[
name|sp
index|]
operator|=
name|m
expr_stmt|;
name|stack_hh
index|[
name|sp
index|]
operator|=
name|hi
expr_stmt|;
name|stack_dd
index|[
name|sp
index|]
operator|=
name|d
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|mainSort ()
specifier|private
name|void
name|mainSort
parameter_list|()
block|{
specifier|final
name|Data
name|dataShadow
init|=
name|this
operator|.
name|data
decl_stmt|;
specifier|final
name|int
index|[]
name|runningOrder
init|=
name|dataShadow
operator|.
name|mainSort_runningOrder
decl_stmt|;
specifier|final
name|int
index|[]
name|copy
init|=
name|dataShadow
operator|.
name|mainSort_copy
decl_stmt|;
specifier|final
name|boolean
index|[]
name|bigDone
init|=
name|dataShadow
operator|.
name|mainSort_bigDone
decl_stmt|;
specifier|final
name|int
index|[]
name|ftab
init|=
name|dataShadow
operator|.
name|ftab
decl_stmt|;
specifier|final
name|byte
index|[]
name|block
init|=
name|dataShadow
operator|.
name|block
decl_stmt|;
specifier|final
name|int
index|[]
name|fmap
init|=
name|dataShadow
operator|.
name|fmap
decl_stmt|;
specifier|final
name|char
index|[]
name|quadrant
init|=
name|dataShadow
operator|.
name|quadrant
decl_stmt|;
specifier|final
name|int
name|lastShadow
init|=
name|this
operator|.
name|last
decl_stmt|;
specifier|final
name|int
name|workLimitShadow
init|=
name|this
operator|.
name|workLimit
decl_stmt|;
specifier|final
name|boolean
name|firstAttemptShadow
init|=
name|this
operator|.
name|firstAttempt
decl_stmt|;
comment|// Set up the 2-byte frequency table
for|for
control|(
name|int
name|i
init|=
literal|65537
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|ftab
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/*     * In the various block-sized structures, live data runs from 0 to     * last+NUM_OVERSHOOT_BYTES inclusive. First, set up the overshoot area     * for block.     */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUM_OVERSHOOT_BYTES
condition|;
name|i
operator|++
control|)
block|{
name|block
index|[
name|lastShadow
operator|+
name|i
operator|+
literal|2
index|]
operator|=
name|block
index|[
operator|(
name|i
operator|%
operator|(
name|lastShadow
operator|+
literal|1
operator|)
operator|)
operator|+
literal|1
index|]
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|lastShadow
operator|+
name|NUM_OVERSHOOT_BYTES
operator|+
literal|1
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|quadrant
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|block
index|[
literal|0
index|]
operator|=
name|block
index|[
name|lastShadow
operator|+
literal|1
index|]
expr_stmt|;
comment|// Complete the initial radix sort:
name|int
name|c1
init|=
name|block
index|[
literal|0
index|]
operator|&
literal|0xff
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|lastShadow
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|c2
init|=
name|block
index|[
name|i
operator|+
literal|1
index|]
operator|&
literal|0xff
decl_stmt|;
name|ftab
index|[
operator|(
name|c1
operator|<<
literal|8
operator|)
operator|+
name|c2
index|]
operator|++
expr_stmt|;
name|c1
operator|=
name|c2
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
literal|65536
condition|;
name|i
operator|++
control|)
name|ftab
index|[
name|i
index|]
operator|+=
name|ftab
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|c1
operator|=
name|block
index|[
literal|1
index|]
operator|&
literal|0xff
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lastShadow
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|c2
init|=
name|block
index|[
name|i
operator|+
literal|2
index|]
operator|&
literal|0xff
decl_stmt|;
name|fmap
index|[
operator|--
name|ftab
index|[
operator|(
name|c1
operator|<<
literal|8
operator|)
operator|+
name|c2
index|]
index|]
operator|=
name|i
expr_stmt|;
name|c1
operator|=
name|c2
expr_stmt|;
block|}
name|fmap
index|[
operator|--
name|ftab
index|[
operator|(
operator|(
name|block
index|[
name|lastShadow
operator|+
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
name|block
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
index|]
index|]
operator|=
name|lastShadow
expr_stmt|;
comment|/*     * Now ftab contains the first loc of every small bucket. Calculate the     * running order, from smallest to largest big bucket.     */
for|for
control|(
name|int
name|i
init|=
literal|256
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|bigDone
index|[
name|i
index|]
operator|=
literal|false
expr_stmt|;
name|runningOrder
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
name|int
name|h
init|=
literal|364
init|;
name|h
operator|!=
literal|1
condition|;
control|)
block|{
name|h
operator|/=
literal|3
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|h
init|;
name|i
operator|<=
literal|255
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|vv
init|=
name|runningOrder
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|int
name|a
init|=
name|ftab
index|[
operator|(
name|vv
operator|+
literal|1
operator|)
operator|<<
literal|8
index|]
operator|-
name|ftab
index|[
name|vv
operator|<<
literal|8
index|]
decl_stmt|;
specifier|final
name|int
name|b
init|=
name|h
operator|-
literal|1
decl_stmt|;
name|int
name|j
init|=
name|i
decl_stmt|;
for|for
control|(
name|int
name|ro
init|=
name|runningOrder
index|[
name|j
operator|-
name|h
index|]
init|;
operator|(
name|ftab
index|[
operator|(
name|ro
operator|+
literal|1
operator|)
operator|<<
literal|8
index|]
operator|-
name|ftab
index|[
name|ro
operator|<<
literal|8
index|]
operator|)
operator|>
name|a
condition|;
name|ro
operator|=
name|runningOrder
index|[
name|j
operator|-
name|h
index|]
control|)
block|{
name|runningOrder
index|[
name|j
index|]
operator|=
name|ro
expr_stmt|;
name|j
operator|-=
name|h
expr_stmt|;
if|if
condition|(
name|j
operator|<=
name|b
condition|)
block|{
break|break;
block|}
block|}
name|runningOrder
index|[
name|j
index|]
operator|=
name|vv
expr_stmt|;
block|}
block|}
comment|/*     * The main sorting loop.     */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
literal|255
condition|;
name|i
operator|++
control|)
block|{
comment|/*       * Process big buckets, starting with the least full.       */
specifier|final
name|int
name|ss
init|=
name|runningOrder
index|[
name|i
index|]
decl_stmt|;
comment|// Step 1:
comment|/*       * Complete the big bucket [ss] by quicksorting any unsorted small       * buckets [ss, j]. Hopefully previous pointer-scanning phases have       * already completed many of the small buckets [ss, j], so we don't       * have to sort them at all.       */
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<=
literal|255
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|int
name|sb
init|=
operator|(
name|ss
operator|<<
literal|8
operator|)
operator|+
name|j
decl_stmt|;
specifier|final
name|int
name|ftab_sb
init|=
name|ftab
index|[
name|sb
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|ftab_sb
operator|&
name|SETMASK
operator|)
operator|!=
name|SETMASK
condition|)
block|{
specifier|final
name|int
name|lo
init|=
name|ftab_sb
operator|&
name|CLEARMASK
decl_stmt|;
specifier|final
name|int
name|hi
init|=
operator|(
name|ftab
index|[
name|sb
operator|+
literal|1
index|]
operator|&
name|CLEARMASK
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|hi
operator|>
name|lo
condition|)
block|{
name|mainQSort3
argument_list|(
name|dataShadow
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstAttemptShadow
operator|&&
operator|(
name|this
operator|.
name|workDone
operator|>
name|workLimitShadow
operator|)
condition|)
block|{
return|return;
block|}
block|}
name|ftab
index|[
name|sb
index|]
operator|=
name|ftab_sb
operator||
name|SETMASK
expr_stmt|;
block|}
block|}
comment|// Step 2:
comment|// Now scan this big bucket so as to synthesise the
comment|// sorted order for small buckets [t, ss] for all t != ss.
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<=
literal|255
condition|;
name|j
operator|++
control|)
block|{
name|copy
index|[
name|j
index|]
operator|=
name|ftab
index|[
operator|(
name|j
operator|<<
literal|8
operator|)
operator|+
name|ss
index|]
operator|&
name|CLEARMASK
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
name|ftab
index|[
name|ss
operator|<<
literal|8
index|]
operator|&
name|CLEARMASK
init|,
name|hj
init|=
operator|(
name|ftab
index|[
operator|(
name|ss
operator|+
literal|1
operator|)
operator|<<
literal|8
index|]
operator|&
name|CLEARMASK
operator|)
init|;
name|j
operator|<
name|hj
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|int
name|fmap_j
init|=
name|fmap
index|[
name|j
index|]
decl_stmt|;
name|c1
operator|=
name|block
index|[
name|fmap_j
index|]
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|!
name|bigDone
index|[
name|c1
index|]
condition|)
block|{
name|fmap
index|[
name|copy
index|[
name|c1
index|]
index|]
operator|=
operator|(
name|fmap_j
operator|==
literal|0
operator|)
condition|?
name|lastShadow
else|:
operator|(
name|fmap_j
operator|-
literal|1
operator|)
expr_stmt|;
name|copy
index|[
name|c1
index|]
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|j
init|=
literal|256
init|;
operator|--
name|j
operator|>=
literal|0
condition|;
control|)
name|ftab
index|[
operator|(
name|j
operator|<<
literal|8
operator|)
operator|+
name|ss
index|]
operator||=
name|SETMASK
expr_stmt|;
comment|// Step 3:
comment|/*       * The ss big bucket is now done. Record this fact, and update the       * quadrant descriptors. Remember to update quadrants in the       * overshoot area too, if necessary. The "if (i< 255)" test merely       * skips this updating for the last bucket processed, since updating       * for the last bucket is pointless.       */
name|bigDone
index|[
name|ss
index|]
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|255
condition|)
block|{
specifier|final
name|int
name|bbStart
init|=
name|ftab
index|[
name|ss
operator|<<
literal|8
index|]
operator|&
name|CLEARMASK
decl_stmt|;
specifier|final
name|int
name|bbSize
init|=
operator|(
name|ftab
index|[
operator|(
name|ss
operator|+
literal|1
operator|)
operator|<<
literal|8
index|]
operator|&
name|CLEARMASK
operator|)
operator|-
name|bbStart
decl_stmt|;
name|int
name|shifts
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|bbSize
operator|>>
name|shifts
operator|)
operator|>
literal|65534
condition|)
block|{
name|shifts
operator|++
expr_stmt|;
block|}
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|bbSize
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|int
name|a2update
init|=
name|fmap
index|[
name|bbStart
operator|+
name|j
index|]
decl_stmt|;
specifier|final
name|char
name|qVal
init|=
call|(
name|char
call|)
argument_list|(
name|j
operator|>>
name|shifts
argument_list|)
decl_stmt|;
name|quadrant
index|[
name|a2update
index|]
operator|=
name|qVal
expr_stmt|;
if|if
condition|(
name|a2update
operator|<
name|NUM_OVERSHOOT_BYTES
condition|)
block|{
name|quadrant
index|[
name|a2update
operator|+
name|lastShadow
operator|+
literal|1
index|]
operator|=
name|qVal
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|method|randomiseBlock ()
specifier|private
name|void
name|randomiseBlock
parameter_list|()
block|{
specifier|final
name|boolean
index|[]
name|inUse
init|=
name|this
operator|.
name|data
operator|.
name|inUse
decl_stmt|;
specifier|final
name|byte
index|[]
name|block
init|=
name|this
operator|.
name|data
operator|.
name|block
decl_stmt|;
specifier|final
name|int
name|lastShadow
init|=
name|this
operator|.
name|last
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|256
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|inUse
index|[
name|i
index|]
operator|=
literal|false
expr_stmt|;
name|int
name|rNToGo
init|=
literal|0
decl_stmt|;
name|int
name|rTPos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|j
init|=
literal|1
init|;
name|i
operator|<=
name|lastShadow
condition|;
name|i
operator|=
name|j
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|rNToGo
operator|==
literal|0
condition|)
block|{
name|rNToGo
operator|=
operator|(
name|char
operator|)
name|BZip2Constants
operator|.
name|rNums
index|[
name|rTPos
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|rTPos
operator|==
literal|512
condition|)
block|{
name|rTPos
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|rNToGo
operator|--
expr_stmt|;
name|block
index|[
name|j
index|]
operator|^=
operator|(
operator|(
name|rNToGo
operator|==
literal|1
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|// handle 16 bit signed numbers
name|inUse
index|[
name|block
index|[
name|j
index|]
operator|&
literal|0xff
index|]
operator|=
literal|true
expr_stmt|;
block|}
name|this
operator|.
name|blockRandomised
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|generateMTFValues ()
specifier|private
name|void
name|generateMTFValues
parameter_list|()
block|{
specifier|final
name|int
name|lastShadow
init|=
name|this
operator|.
name|last
decl_stmt|;
specifier|final
name|Data
name|dataShadow
init|=
name|this
operator|.
name|data
decl_stmt|;
specifier|final
name|boolean
index|[]
name|inUse
init|=
name|dataShadow
operator|.
name|inUse
decl_stmt|;
specifier|final
name|byte
index|[]
name|block
init|=
name|dataShadow
operator|.
name|block
decl_stmt|;
specifier|final
name|int
index|[]
name|fmap
init|=
name|dataShadow
operator|.
name|fmap
decl_stmt|;
specifier|final
name|char
index|[]
name|sfmap
init|=
name|dataShadow
operator|.
name|sfmap
decl_stmt|;
specifier|final
name|int
index|[]
name|mtfFreq
init|=
name|dataShadow
operator|.
name|mtfFreq
decl_stmt|;
specifier|final
name|byte
index|[]
name|unseqToSeq
init|=
name|dataShadow
operator|.
name|unseqToSeq
decl_stmt|;
specifier|final
name|byte
index|[]
name|yy
init|=
name|dataShadow
operator|.
name|generateMTFValues_yy
decl_stmt|;
comment|// make maps
name|int
name|nInUseShadow
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inUse
index|[
name|i
index|]
condition|)
block|{
name|unseqToSeq
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|nInUseShadow
expr_stmt|;
name|nInUseShadow
operator|++
expr_stmt|;
block|}
block|}
name|this
operator|.
name|nInUse
operator|=
name|nInUseShadow
expr_stmt|;
specifier|final
name|int
name|eob
init|=
name|nInUseShadow
operator|+
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|eob
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|mtfFreq
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|nInUseShadow
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|yy
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|i
expr_stmt|;
block|}
name|int
name|wr
init|=
literal|0
decl_stmt|;
name|int
name|zPend
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|lastShadow
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|byte
name|ll_i
init|=
name|unseqToSeq
index|[
name|block
index|[
name|fmap
index|[
name|i
index|]
index|]
operator|&
literal|0xff
index|]
decl_stmt|;
name|byte
name|tmp
init|=
name|yy
index|[
literal|0
index|]
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|ll_i
operator|!=
name|tmp
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|byte
name|tmp2
init|=
name|tmp
decl_stmt|;
name|tmp
operator|=
name|yy
index|[
name|j
index|]
expr_stmt|;
name|yy
index|[
name|j
index|]
operator|=
name|tmp2
expr_stmt|;
block|}
name|yy
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
condition|)
block|{
name|zPend
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|zPend
operator|>
literal|0
condition|)
block|{
name|zPend
operator|--
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|(
name|zPend
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|sfmap
index|[
name|wr
index|]
operator|=
name|RUNA
expr_stmt|;
name|wr
operator|++
expr_stmt|;
name|mtfFreq
index|[
name|RUNA
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sfmap
index|[
name|wr
index|]
operator|=
name|RUNB
expr_stmt|;
name|wr
operator|++
expr_stmt|;
name|mtfFreq
index|[
name|RUNB
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|zPend
operator|>=
literal|2
condition|)
block|{
name|zPend
operator|=
operator|(
name|zPend
operator|-
literal|2
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|zPend
operator|=
literal|0
expr_stmt|;
block|}
name|sfmap
index|[
name|wr
index|]
operator|=
call|(
name|char
call|)
argument_list|(
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|wr
operator|++
expr_stmt|;
name|mtfFreq
index|[
name|j
operator|+
literal|1
index|]
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zPend
operator|>
literal|0
condition|)
block|{
name|zPend
operator|--
expr_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
operator|(
name|zPend
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|sfmap
index|[
name|wr
index|]
operator|=
name|RUNA
expr_stmt|;
name|wr
operator|++
expr_stmt|;
name|mtfFreq
index|[
name|RUNA
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sfmap
index|[
name|wr
index|]
operator|=
name|RUNB
expr_stmt|;
name|wr
operator|++
expr_stmt|;
name|mtfFreq
index|[
name|RUNB
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|zPend
operator|>=
literal|2
condition|)
block|{
name|zPend
operator|=
operator|(
name|zPend
operator|-
literal|2
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
name|sfmap
index|[
name|wr
index|]
operator|=
operator|(
name|char
operator|)
name|eob
expr_stmt|;
name|mtfFreq
index|[
name|eob
index|]
operator|++
expr_stmt|;
name|this
operator|.
name|nMTF
operator|=
name|wr
operator|+
literal|1
expr_stmt|;
block|}
DECL|class|Data
specifier|private
specifier|static
specifier|final
class|class
name|Data
extends|extends
name|Object
block|{
comment|// with blockSize 900k
DECL|field|inUse
specifier|final
name|boolean
index|[]
name|inUse
init|=
operator|new
name|boolean
index|[
literal|256
index|]
decl_stmt|;
comment|// 256 byte
DECL|field|unseqToSeq
specifier|final
name|byte
index|[]
name|unseqToSeq
init|=
operator|new
name|byte
index|[
literal|256
index|]
decl_stmt|;
comment|// 256 byte
DECL|field|mtfFreq
specifier|final
name|int
index|[]
name|mtfFreq
init|=
operator|new
name|int
index|[
name|MAX_ALPHA_SIZE
index|]
decl_stmt|;
comment|// 1032 byte
DECL|field|selector
specifier|final
name|byte
index|[]
name|selector
init|=
operator|new
name|byte
index|[
name|MAX_SELECTORS
index|]
decl_stmt|;
comment|// 18002 byte
DECL|field|selectorMtf
specifier|final
name|byte
index|[]
name|selectorMtf
init|=
operator|new
name|byte
index|[
name|MAX_SELECTORS
index|]
decl_stmt|;
comment|// 18002 byte
DECL|field|generateMTFValues_yy
specifier|final
name|byte
index|[]
name|generateMTFValues_yy
init|=
operator|new
name|byte
index|[
literal|256
index|]
decl_stmt|;
comment|// 256 byte
DECL|field|sendMTFValues_len
specifier|final
name|byte
index|[]
index|[]
name|sendMTFValues_len
init|=
operator|new
name|byte
index|[
name|N_GROUPS
index|]
index|[
name|MAX_ALPHA_SIZE
index|]
decl_stmt|;
comment|// 1548
comment|// byte
DECL|field|sendMTFValues_rfreq
specifier|final
name|int
index|[]
index|[]
name|sendMTFValues_rfreq
init|=
operator|new
name|int
index|[
name|N_GROUPS
index|]
index|[
name|MAX_ALPHA_SIZE
index|]
decl_stmt|;
comment|// 6192
comment|// byte
DECL|field|sendMTFValues_fave
specifier|final
name|int
index|[]
name|sendMTFValues_fave
init|=
operator|new
name|int
index|[
name|N_GROUPS
index|]
decl_stmt|;
comment|// 24 byte
DECL|field|sendMTFValues_cost
specifier|final
name|short
index|[]
name|sendMTFValues_cost
init|=
operator|new
name|short
index|[
name|N_GROUPS
index|]
decl_stmt|;
comment|// 12 byte
DECL|field|sendMTFValues_code
specifier|final
name|int
index|[]
index|[]
name|sendMTFValues_code
init|=
operator|new
name|int
index|[
name|N_GROUPS
index|]
index|[
name|MAX_ALPHA_SIZE
index|]
decl_stmt|;
comment|// 6192
comment|// byte
DECL|field|sendMTFValues2_pos
specifier|final
name|byte
index|[]
name|sendMTFValues2_pos
init|=
operator|new
name|byte
index|[
name|N_GROUPS
index|]
decl_stmt|;
comment|// 6 byte
DECL|field|sentMTFValues4_inUse16
specifier|final
name|boolean
index|[]
name|sentMTFValues4_inUse16
init|=
operator|new
name|boolean
index|[
literal|16
index|]
decl_stmt|;
comment|// 16 byte
DECL|field|stack_ll
specifier|final
name|int
index|[]
name|stack_ll
init|=
operator|new
name|int
index|[
name|QSORT_STACK_SIZE
index|]
decl_stmt|;
comment|// 4000 byte
DECL|field|stack_hh
specifier|final
name|int
index|[]
name|stack_hh
init|=
operator|new
name|int
index|[
name|QSORT_STACK_SIZE
index|]
decl_stmt|;
comment|// 4000 byte
DECL|field|stack_dd
specifier|final
name|int
index|[]
name|stack_dd
init|=
operator|new
name|int
index|[
name|QSORT_STACK_SIZE
index|]
decl_stmt|;
comment|// 4000 byte
DECL|field|mainSort_runningOrder
specifier|final
name|int
index|[]
name|mainSort_runningOrder
init|=
operator|new
name|int
index|[
literal|256
index|]
decl_stmt|;
comment|// 1024 byte
DECL|field|mainSort_copy
specifier|final
name|int
index|[]
name|mainSort_copy
init|=
operator|new
name|int
index|[
literal|256
index|]
decl_stmt|;
comment|// 1024 byte
DECL|field|mainSort_bigDone
specifier|final
name|boolean
index|[]
name|mainSort_bigDone
init|=
operator|new
name|boolean
index|[
literal|256
index|]
decl_stmt|;
comment|// 256 byte
DECL|field|heap
specifier|final
name|int
index|[]
name|heap
init|=
operator|new
name|int
index|[
name|MAX_ALPHA_SIZE
operator|+
literal|2
index|]
decl_stmt|;
comment|// 1040 byte
DECL|field|weight
specifier|final
name|int
index|[]
name|weight
init|=
operator|new
name|int
index|[
name|MAX_ALPHA_SIZE
operator|*
literal|2
index|]
decl_stmt|;
comment|// 2064 byte
DECL|field|parent
specifier|final
name|int
index|[]
name|parent
init|=
operator|new
name|int
index|[
name|MAX_ALPHA_SIZE
operator|*
literal|2
index|]
decl_stmt|;
comment|// 2064 byte
DECL|field|ftab
specifier|final
name|int
index|[]
name|ftab
init|=
operator|new
name|int
index|[
literal|65537
index|]
decl_stmt|;
comment|// 262148 byte
comment|// ------------
comment|// 333408 byte
DECL|field|block
specifier|final
name|byte
index|[]
name|block
decl_stmt|;
comment|// 900021 byte
DECL|field|fmap
specifier|final
name|int
index|[]
name|fmap
decl_stmt|;
comment|// 3600000 byte
DECL|field|sfmap
specifier|final
name|char
index|[]
name|sfmap
decl_stmt|;
comment|// 3600000 byte
comment|// ------------
comment|// 8433529 byte
comment|// ============
comment|/**     * Array instance identical to sfmap, both are used only temporarily and     * indepently, so we do not need to allocate additional memory.     */
DECL|field|quadrant
specifier|final
name|char
index|[]
name|quadrant
decl_stmt|;
DECL|method|Data (int blockSize100k)
name|Data
parameter_list|(
name|int
name|blockSize100k
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
specifier|final
name|int
name|n
init|=
name|blockSize100k
operator|*
name|BZip2Constants
operator|.
name|baseBlockSize
decl_stmt|;
name|this
operator|.
name|block
operator|=
operator|new
name|byte
index|[
operator|(
name|n
operator|+
literal|1
operator|+
name|NUM_OVERSHOOT_BYTES
operator|)
index|]
expr_stmt|;
name|this
operator|.
name|fmap
operator|=
operator|new
name|int
index|[
name|n
index|]
expr_stmt|;
name|this
operator|.
name|sfmap
operator|=
operator|new
name|char
index|[
literal|2
operator|*
name|n
index|]
expr_stmt|;
name|this
operator|.
name|quadrant
operator|=
name|this
operator|.
name|sfmap
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

