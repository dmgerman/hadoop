begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *       http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.contract
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FilterFileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PathFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|LambdaTestUtils
operator|.
name|intercept
import|;
end_import

begin_comment
comment|/**  * Test getFileStatus and related listing operations.  */
end_comment

begin_class
DECL|class|AbstractContractGetFileStatusTest
specifier|public
specifier|abstract
class|class
name|AbstractContractGetFileStatusTest
extends|extends
name|AbstractFSContractTestBase
block|{
DECL|field|testPath
specifier|private
name|Path
name|testPath
decl_stmt|;
DECL|field|target
specifier|private
name|Path
name|target
decl_stmt|;
comment|// the tree parameters. Kept small to avoid killing object store test
comment|// runs too much.
DECL|field|TREE_DEPTH
specifier|private
specifier|static
specifier|final
name|int
name|TREE_DEPTH
init|=
literal|2
decl_stmt|;
DECL|field|TREE_WIDTH
specifier|private
specifier|static
specifier|final
name|int
name|TREE_WIDTH
init|=
literal|3
decl_stmt|;
DECL|field|TREE_FILES
specifier|private
specifier|static
specifier|final
name|int
name|TREE_FILES
init|=
literal|4
decl_stmt|;
DECL|field|TREE_FILESIZE
specifier|private
specifier|static
specifier|final
name|int
name|TREE_FILESIZE
init|=
literal|512
decl_stmt|;
annotation|@
name|Override
DECL|method|setup ()
specifier|public
name|void
name|setup
parameter_list|()
throws|throws
name|Exception
block|{
name|super
operator|.
name|setup
argument_list|()
expr_stmt|;
name|skipIfUnsupported
argument_list|(
name|SUPPORTS_GETFILESTATUS
argument_list|)
expr_stmt|;
comment|//delete the test directory
name|testPath
operator|=
name|path
argument_list|(
literal|"test"
argument_list|)
expr_stmt|;
name|target
operator|=
operator|new
name|Path
argument_list|(
name|testPath
argument_list|,
literal|"target"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testGetFileStatusNonexistentFile ()
specifier|public
name|void
name|testGetFileStatusNonexistentFile
parameter_list|()
throws|throws
name|Throwable
block|{
try|try
block|{
name|FileStatus
name|status
init|=
name|getFileSystem
argument_list|()
operator|.
name|getFileStatus
argument_list|(
name|target
argument_list|)
decl_stmt|;
comment|//got here: trouble
name|fail
argument_list|(
literal|"expected a failure, got "
operator|+
name|status
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|//expected
name|handleExpectedException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testGetFileStatusRoot ()
specifier|public
name|void
name|testGetFileStatusRoot
parameter_list|()
throws|throws
name|Throwable
block|{
name|ContractTestUtils
operator|.
name|assertIsDirectory
argument_list|(
name|getFileSystem
argument_list|()
operator|.
name|getFileStatus
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testListStatusEmptyDirectory ()
specifier|public
name|void
name|testListStatusEmptyDirectory
parameter_list|()
throws|throws
name|IOException
block|{
name|describe
argument_list|(
literal|"List status on an empty directory"
argument_list|)
expr_stmt|;
name|Path
name|subfolder
init|=
name|createDirWithEmptySubFolder
argument_list|()
decl_stmt|;
name|FileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|Path
name|path
init|=
name|getContract
argument_list|()
operator|.
name|getTestPath
argument_list|()
decl_stmt|;
operator|new
name|TreeScanResults
argument_list|(
name|fs
operator|.
name|listStatus
argument_list|(
name|path
argument_list|)
argument_list|)
operator|.
name|assertSizeEquals
argument_list|(
literal|"listStatus("
operator|+
name|path
operator|+
literal|")"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|describe
argument_list|(
literal|"Test on empty subdirectory"
argument_list|)
expr_stmt|;
operator|new
name|TreeScanResults
argument_list|(
name|fs
operator|.
name|listStatus
argument_list|(
name|subfolder
argument_list|)
argument_list|)
operator|.
name|assertSizeEquals
argument_list|(
literal|"listStatus(empty subfolder)"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testListFilesEmptyDirectoryNonrecursive ()
specifier|public
name|void
name|testListFilesEmptyDirectoryNonrecursive
parameter_list|()
throws|throws
name|IOException
block|{
name|listFilesOnEmptyDir
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testListFilesEmptyDirectoryRecursive ()
specifier|public
name|void
name|testListFilesEmptyDirectoryRecursive
parameter_list|()
throws|throws
name|IOException
block|{
name|listFilesOnEmptyDir
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**    * Call listFiles on an directory with an empty subdir.    * @param recursive should the list be recursive?    * @throws IOException IO Problems    */
DECL|method|listFilesOnEmptyDir (boolean recursive)
specifier|private
name|void
name|listFilesOnEmptyDir
parameter_list|(
name|boolean
name|recursive
parameter_list|)
throws|throws
name|IOException
block|{
name|describe
argument_list|(
literal|"Invoke listFiles(recursive="
operator|+
name|recursive
operator|+
literal|")"
operator|+
literal|" on empty directories, expect nothing found"
argument_list|)
expr_stmt|;
name|FileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|Path
name|path
init|=
name|getContract
argument_list|()
operator|.
name|getTestPath
argument_list|()
decl_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Path
name|subfolder
init|=
name|createDirWithEmptySubFolder
argument_list|()
decl_stmt|;
operator|new
name|TreeScanResults
argument_list|(
name|fs
operator|.
name|listFiles
argument_list|(
name|path
argument_list|,
name|recursive
argument_list|)
argument_list|)
operator|.
name|assertSizeEquals
argument_list|(
literal|"listFiles(test dir, "
operator|+
name|recursive
operator|+
literal|")"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|describe
argument_list|(
literal|"Test on empty subdirectory"
argument_list|)
expr_stmt|;
operator|new
name|TreeScanResults
argument_list|(
name|fs
operator|.
name|listFiles
argument_list|(
name|subfolder
argument_list|,
name|recursive
argument_list|)
argument_list|)
operator|.
name|assertSizeEquals
argument_list|(
literal|"listFiles(empty subfolder, "
operator|+
name|recursive
operator|+
literal|")"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testListLocatedStatusEmptyDirectory ()
specifier|public
name|void
name|testListLocatedStatusEmptyDirectory
parameter_list|()
throws|throws
name|IOException
block|{
name|describe
argument_list|(
literal|"Invoke listLocatedStatus() on empty directories;"
operator|+
literal|" expect directories to be found"
argument_list|)
expr_stmt|;
name|FileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|Path
name|path
init|=
name|getContract
argument_list|()
operator|.
name|getTestPath
argument_list|()
decl_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Path
name|subfolder
init|=
name|createDirWithEmptySubFolder
argument_list|()
decl_stmt|;
operator|new
name|TreeScanResults
argument_list|(
name|fs
operator|.
name|listLocatedStatus
argument_list|(
name|path
argument_list|)
argument_list|)
operator|.
name|assertSizeEquals
argument_list|(
literal|"listLocatedStatus(test dir)"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|describe
argument_list|(
literal|"Test on empty subdirectory"
argument_list|)
expr_stmt|;
operator|new
name|TreeScanResults
argument_list|(
name|fs
operator|.
name|listLocatedStatus
argument_list|(
name|subfolder
argument_list|)
argument_list|)
operator|.
name|assertSizeEquals
argument_list|(
literal|"listLocatedStatus(empty subfolder)"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * All tests cases against complex directories are aggregated into one, so    * that the setup and teardown costs against object stores can be shared.    * @throws Throwable    */
annotation|@
name|Test
DECL|method|testComplexDirActions ()
specifier|public
name|void
name|testComplexDirActions
parameter_list|()
throws|throws
name|Throwable
block|{
name|TreeScanResults
name|tree
init|=
name|createTestTree
argument_list|()
decl_stmt|;
name|checkListStatusStatusComplexDir
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|checkListLocatedStatusStatusComplexDir
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|checkListFilesComplexDirNonRecursive
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|checkListFilesComplexDirRecursive
argument_list|(
name|tree
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test {@link FileSystem#listStatus(Path)} on a complex    * directory tree.    * @param tree directory tree to list.    * @throws Throwable    */
DECL|method|checkListStatusStatusComplexDir (TreeScanResults tree)
specifier|protected
name|void
name|checkListStatusStatusComplexDir
parameter_list|(
name|TreeScanResults
name|tree
parameter_list|)
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Expect listStatus to list all entries in top dir only"
argument_list|)
expr_stmt|;
name|FileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|TreeScanResults
name|listing
init|=
operator|new
name|TreeScanResults
argument_list|(
name|fs
operator|.
name|listStatus
argument_list|(
name|tree
operator|.
name|getBasePath
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|listing
operator|.
name|assertSizeEquals
argument_list|(
literal|"listStatus()"
argument_list|,
name|TREE_FILES
argument_list|,
name|TREE_WIDTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test {@link FileSystem#listLocatedStatus(Path)} on a complex    * directory tree.    * @param tree directory tree to list.    * @throws Throwable    */
DECL|method|checkListLocatedStatusStatusComplexDir (TreeScanResults tree)
specifier|protected
name|void
name|checkListLocatedStatusStatusComplexDir
parameter_list|(
name|TreeScanResults
name|tree
parameter_list|)
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Expect listLocatedStatus to list all entries in top dir only"
argument_list|)
expr_stmt|;
name|FileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|TreeScanResults
name|listing
init|=
operator|new
name|TreeScanResults
argument_list|(
name|fs
operator|.
name|listLocatedStatus
argument_list|(
name|tree
operator|.
name|getBasePath
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|listing
operator|.
name|assertSizeEquals
argument_list|(
literal|"listLocatedStatus()"
argument_list|,
name|TREE_FILES
argument_list|,
name|TREE_WIDTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|verifyFileStats
argument_list|(
name|fs
operator|.
name|listLocatedStatus
argument_list|(
name|tree
operator|.
name|getBasePath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// listLocatedStatus and listStatus must return the same files.
name|TreeScanResults
name|listStatus
init|=
operator|new
name|TreeScanResults
argument_list|(
name|fs
operator|.
name|listStatus
argument_list|(
name|tree
operator|.
name|getBasePath
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|listing
operator|.
name|assertEquivalent
argument_list|(
name|listStatus
argument_list|)
expr_stmt|;
comment|// now check without using
name|List
argument_list|<
name|LocatedFileStatus
argument_list|>
name|statusThroughNext
init|=
name|toListThroughNextCallsAlone
argument_list|(
name|fs
operator|.
name|listLocatedStatus
argument_list|(
name|tree
operator|.
name|getBasePath
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|TreeScanResults
name|resultsThroughNext
init|=
operator|new
name|TreeScanResults
argument_list|(
name|statusThroughNext
argument_list|)
decl_stmt|;
name|listStatus
operator|.
name|assertFieldsEquivalent
argument_list|(
literal|"files"
argument_list|,
name|listing
argument_list|,
name|listStatus
operator|.
name|getFiles
argument_list|()
argument_list|,
name|resultsThroughNext
operator|.
name|getFiles
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test {@link FileSystem#listFiles(Path, boolean)} on a complex    * directory tree and the recursive flag set to false.    * @param tree directory tree to list.    * @throws Throwable    */
DECL|method|checkListFilesComplexDirNonRecursive (TreeScanResults tree)
specifier|protected
name|void
name|checkListFilesComplexDirNonRecursive
parameter_list|(
name|TreeScanResults
name|tree
parameter_list|)
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Expect non-recursive listFiles(false) to list all entries"
operator|+
literal|" in top dir only"
argument_list|)
expr_stmt|;
name|FileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|TreeScanResults
name|listing
init|=
operator|new
name|TreeScanResults
argument_list|(
name|fs
operator|.
name|listFiles
argument_list|(
name|tree
operator|.
name|getBasePath
argument_list|()
argument_list|,
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|listing
operator|.
name|assertSizeEquals
argument_list|(
literal|"listFiles(false)"
argument_list|,
name|TREE_FILES
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|verifyFileStats
argument_list|(
name|fs
operator|.
name|listFiles
argument_list|(
name|tree
operator|.
name|getBasePath
argument_list|()
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// the files listed should match the set of files in a listStatus() call.
comment|// the directories are not checked
name|TreeScanResults
name|listStatus
init|=
operator|new
name|TreeScanResults
argument_list|(
name|fs
operator|.
name|listStatus
argument_list|(
name|tree
operator|.
name|getBasePath
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|listStatus
operator|.
name|assertFieldsEquivalent
argument_list|(
literal|"files"
argument_list|,
name|listing
argument_list|,
name|listStatus
operator|.
name|getFiles
argument_list|()
argument_list|,
name|listing
operator|.
name|getFiles
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LocatedFileStatus
argument_list|>
name|statusThroughNext
init|=
name|toListThroughNextCallsAlone
argument_list|(
name|fs
operator|.
name|listFiles
argument_list|(
name|tree
operator|.
name|getBasePath
argument_list|()
argument_list|,
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|TreeScanResults
name|resultsThroughNext
init|=
operator|new
name|TreeScanResults
argument_list|(
name|statusThroughNext
argument_list|)
decl_stmt|;
name|listStatus
operator|.
name|assertFieldsEquivalent
argument_list|(
literal|"files"
argument_list|,
name|listing
argument_list|,
name|listStatus
operator|.
name|getFiles
argument_list|()
argument_list|,
name|resultsThroughNext
operator|.
name|getFiles
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test {@link FileSystem#listFiles(Path, boolean)} on a complex    * directory tree and the recursive flag set to true.    * @param tree directory tree to list.    * @throws Throwable    */
DECL|method|checkListFilesComplexDirRecursive (TreeScanResults tree)
specifier|protected
name|void
name|checkListFilesComplexDirRecursive
parameter_list|(
name|TreeScanResults
name|tree
parameter_list|)
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Expect recursive listFiles(true) to"
operator|+
literal|" list all files down the tree"
argument_list|)
expr_stmt|;
name|FileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|TreeScanResults
name|listing
init|=
operator|new
name|TreeScanResults
argument_list|(
name|fs
operator|.
name|listFiles
argument_list|(
name|tree
operator|.
name|getBasePath
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
comment|// files are checked, but not the directories.
name|tree
operator|.
name|assertFieldsEquivalent
argument_list|(
literal|"files"
argument_list|,
name|listing
argument_list|,
name|tree
operator|.
name|getFiles
argument_list|()
argument_list|,
name|listing
operator|.
name|getFiles
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|count
init|=
name|verifyFileStats
argument_list|(
name|fs
operator|.
name|listFiles
argument_list|(
name|tree
operator|.
name|getBasePath
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
comment|// assert that the content matches that of a tree walk
name|describe
argument_list|(
literal|"verifying consistency with treewalk's files"
argument_list|)
expr_stmt|;
name|TreeScanResults
name|treeWalk
init|=
name|treeWalk
argument_list|(
name|fs
argument_list|,
name|tree
operator|.
name|getBasePath
argument_list|()
argument_list|)
decl_stmt|;
name|treeWalk
operator|.
name|assertFieldsEquivalent
argument_list|(
literal|"files"
argument_list|,
name|listing
argument_list|,
name|treeWalk
operator|.
name|getFiles
argument_list|()
argument_list|,
name|listing
operator|.
name|getFiles
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Size of status list through next() calls"
argument_list|,
name|count
argument_list|,
name|toListThroughNextCallsAlone
argument_list|(
name|fs
operator|.
name|listFiles
argument_list|(
name|tree
operator|.
name|getBasePath
argument_list|()
argument_list|,
literal|true
argument_list|)
argument_list|)
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testListFilesNoDir ()
specifier|public
name|void
name|testListFilesNoDir
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"test the listFiles calls on a path which is not present"
argument_list|)
expr_stmt|;
name|Path
name|path
init|=
name|path
argument_list|(
literal|"missing"
argument_list|)
decl_stmt|;
try|try
block|{
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|iterator
init|=
name|getFileSystem
argument_list|()
operator|.
name|listFiles
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"Expected an exception, got an iterator: "
operator|+
name|iterator
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|expected
parameter_list|)
block|{
comment|// expected
block|}
try|try
block|{
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|iterator
init|=
name|getFileSystem
argument_list|()
operator|.
name|listFiles
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"Expected an exception, got an iterator: "
operator|+
name|iterator
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|expected
parameter_list|)
block|{
comment|// expected
block|}
block|}
annotation|@
name|Test
DECL|method|testLocatedStatusNoDir ()
specifier|public
name|void
name|testLocatedStatusNoDir
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"test the LocatedStatus call on a path which is not present"
argument_list|)
expr_stmt|;
name|intercept
argument_list|(
name|FileNotFoundException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
name|getFileSystem
argument_list|()
operator|.
name|listLocatedStatus
argument_list|(
name|path
argument_list|(
literal|"missing"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testListStatusNoDir ()
specifier|public
name|void
name|testListStatusNoDir
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"test the listStatus(path) call on a path which is not present"
argument_list|)
expr_stmt|;
name|intercept
argument_list|(
name|FileNotFoundException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
name|getFileSystem
argument_list|()
operator|.
name|listStatus
argument_list|(
name|path
argument_list|(
literal|"missing"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testListStatusFilteredNoDir ()
specifier|public
name|void
name|testListStatusFilteredNoDir
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"test the listStatus(path, filter) call on a missing path"
argument_list|)
expr_stmt|;
name|intercept
argument_list|(
name|FileNotFoundException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
name|getFileSystem
argument_list|()
operator|.
name|listStatus
argument_list|(
name|path
argument_list|(
literal|"missing"
argument_list|)
argument_list|,
name|ALL_PATHS
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testListStatusFilteredFile ()
specifier|public
name|void
name|testListStatusFilteredFile
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"test the listStatus(path, filter) on a file"
argument_list|)
expr_stmt|;
name|Path
name|f
init|=
name|touchf
argument_list|(
literal|"liststatus"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|getFileSystem
argument_list|()
operator|.
name|listStatus
argument_list|(
name|f
argument_list|,
name|NO_PATHS
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testListStatusFile ()
specifier|public
name|void
name|testListStatusFile
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"test the listStatus(path) on a file"
argument_list|)
expr_stmt|;
name|Path
name|f
init|=
name|touchf
argument_list|(
literal|"liststatusfile"
argument_list|)
decl_stmt|;
name|verifyStatusArrayMatchesFile
argument_list|(
name|f
argument_list|,
name|getFileSystem
argument_list|()
operator|.
name|listStatus
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testListFilesFile ()
specifier|public
name|void
name|testListFilesFile
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"test the listStatus(path) on a file"
argument_list|)
expr_stmt|;
name|Path
name|f
init|=
name|touchf
argument_list|(
literal|"listfilesfile"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|LocatedFileStatus
argument_list|>
name|statusList
init|=
name|toList
argument_list|(
name|getFileSystem
argument_list|()
operator|.
name|listFiles
argument_list|(
name|f
argument_list|,
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"size of file list returned"
argument_list|,
literal|1
argument_list|,
name|statusList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertIsNamedFile
argument_list|(
name|f
argument_list|,
name|statusList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LocatedFileStatus
argument_list|>
name|statusList2
init|=
name|toListThroughNextCallsAlone
argument_list|(
name|getFileSystem
argument_list|()
operator|.
name|listFiles
argument_list|(
name|f
argument_list|,
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"size of file list returned through next() calls"
argument_list|,
literal|1
argument_list|,
name|statusList2
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertIsNamedFile
argument_list|(
name|f
argument_list|,
name|statusList2
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testListFilesFileRecursive ()
specifier|public
name|void
name|testListFilesFileRecursive
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"test the listFiles(path, true) on a file"
argument_list|)
expr_stmt|;
name|Path
name|f
init|=
name|touchf
argument_list|(
literal|"listfilesRecursive"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|LocatedFileStatus
argument_list|>
name|statusList
init|=
name|toList
argument_list|(
name|getFileSystem
argument_list|()
operator|.
name|listFiles
argument_list|(
name|f
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"size of file list returned"
argument_list|,
literal|1
argument_list|,
name|statusList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertIsNamedFile
argument_list|(
name|f
argument_list|,
name|statusList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LocatedFileStatus
argument_list|>
name|statusList2
init|=
name|toListThroughNextCallsAlone
argument_list|(
name|getFileSystem
argument_list|()
operator|.
name|listFiles
argument_list|(
name|f
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"size of file list returned"
argument_list|,
literal|1
argument_list|,
name|statusList2
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testListLocatedStatusFile ()
specifier|public
name|void
name|testListLocatedStatusFile
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"test the listLocatedStatus(path) on a file"
argument_list|)
expr_stmt|;
name|Path
name|f
init|=
name|touchf
argument_list|(
literal|"listLocatedStatus"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|LocatedFileStatus
argument_list|>
name|statusList
init|=
name|toList
argument_list|(
name|getFileSystem
argument_list|()
operator|.
name|listLocatedStatus
argument_list|(
name|f
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"size of file list returned"
argument_list|,
literal|1
argument_list|,
name|statusList
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertIsNamedFile
argument_list|(
name|f
argument_list|,
name|statusList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|LocatedFileStatus
argument_list|>
name|statusList2
init|=
name|toListThroughNextCallsAlone
argument_list|(
name|getFileSystem
argument_list|()
operator|.
name|listLocatedStatus
argument_list|(
name|f
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"size of file list returned through next() calls"
argument_list|,
literal|1
argument_list|,
name|statusList2
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Verify a returned status array matches a single named file.    * @param f filename    * @param status status array    */
DECL|method|verifyStatusArrayMatchesFile (Path f, FileStatus[] status)
specifier|private
name|void
name|verifyStatusArrayMatchesFile
parameter_list|(
name|Path
name|f
parameter_list|,
name|FileStatus
index|[]
name|status
parameter_list|)
block|{
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|status
operator|.
name|length
argument_list|)
expr_stmt|;
name|FileStatus
name|fileStatus
init|=
name|status
index|[
literal|0
index|]
decl_stmt|;
name|assertIsNamedFile
argument_list|(
name|f
argument_list|,
name|fileStatus
argument_list|)
expr_stmt|;
block|}
comment|/**    * Verify that a file status refers to a file at the given path.    * @param f filename    * @param fileStatus status to validate    */
DECL|method|assertIsNamedFile (Path f, FileStatus fileStatus)
specifier|private
name|void
name|assertIsNamedFile
parameter_list|(
name|Path
name|f
parameter_list|,
name|FileStatus
name|fileStatus
parameter_list|)
block|{
name|assertEquals
argument_list|(
literal|"Wrong pathname in "
operator|+
name|fileStatus
argument_list|,
name|f
argument_list|,
name|fileStatus
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"Not a file: "
operator|+
name|fileStatus
argument_list|,
name|fileStatus
operator|.
name|isFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Touch a file with a given name; return the path.    * @param name name    * @return the full name    * @throws IOException IO Problems    */
DECL|method|touchf (String name)
name|Path
name|touchf
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|path
init|=
name|path
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|ContractTestUtils
operator|.
name|touch
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
comment|/**    * Clear the test directory and add an empty subfolder.    * @return the path to the subdirectory    * @throws IOException    */
DECL|method|createDirWithEmptySubFolder ()
specifier|private
name|Path
name|createDirWithEmptySubFolder
parameter_list|()
throws|throws
name|IOException
block|{
comment|// remove the test directory
name|FileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|Path
name|path
init|=
name|getContract
argument_list|()
operator|.
name|getTestPath
argument_list|()
decl_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// create a - non-qualified - Path for a subdir
name|Path
name|subfolder
init|=
name|path
operator|.
name|suffix
argument_list|(
literal|'/'
operator|+
name|this
operator|.
name|methodName
operator|.
name|getMethodName
argument_list|()
operator|+
literal|"-"
operator|+
name|UUID
operator|.
name|randomUUID
argument_list|()
argument_list|)
decl_stmt|;
name|mkdirs
argument_list|(
name|subfolder
argument_list|)
expr_stmt|;
return|return
name|subfolder
return|;
block|}
comment|/**    * Create a test tree.    * @return the details about the created tree. The files and directories    * are those created under the path, not the base directory created.    * @throws IOException    */
DECL|method|createTestTree ()
specifier|private
name|TreeScanResults
name|createTestTree
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|createSubdirs
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|path
argument_list|(
name|methodName
operator|.
name|getMethodName
argument_list|()
argument_list|)
argument_list|,
name|TREE_DEPTH
argument_list|,
name|TREE_WIDTH
argument_list|,
name|TREE_FILES
argument_list|,
name|TREE_FILESIZE
argument_list|)
return|;
block|}
comment|/**    * Scan through a filestatus iterator, get the status of every element and    * verify core attributes. This should identify a situation where the    * attributes of a file/dir retrieved in a listing operation do not    * match the values individually retrieved. That is: the metadata returned    * in a directory listing is different from the explicitly retrieved data.    *    * Timestamps are not compared.    * @param results iterator to scan    * @return the number of entries in the result set    * @throws IOException any IO problem    */
DECL|method|verifyFileStats (RemoteIterator<LocatedFileStatus> results)
specifier|private
name|int
name|verifyFileStats
parameter_list|(
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|results
parameter_list|)
throws|throws
name|IOException
block|{
name|describe
argument_list|(
literal|"verifying file statuses"
argument_list|)
expr_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|results
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|LocatedFileStatus
name|next
init|=
name|results
operator|.
name|next
argument_list|()
decl_stmt|;
name|FileStatus
name|fileStatus
init|=
name|getFileSystem
argument_list|()
operator|.
name|getFileStatus
argument_list|(
name|next
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"isDirectory"
argument_list|,
name|fileStatus
operator|.
name|isDirectory
argument_list|()
argument_list|,
name|next
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"isFile"
argument_list|,
name|fileStatus
operator|.
name|isFile
argument_list|()
argument_list|,
name|next
operator|.
name|isFile
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"getLen"
argument_list|,
name|fileStatus
operator|.
name|getLen
argument_list|()
argument_list|,
name|next
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"getOwner"
argument_list|,
name|fileStatus
operator|.
name|getOwner
argument_list|()
argument_list|,
name|next
operator|.
name|getOwner
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
annotation|@
name|Test
DECL|method|testListStatusFiltering ()
specifier|public
name|void
name|testListStatusFiltering
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Call listStatus() against paths and directories with filtering"
argument_list|)
expr_stmt|;
name|Path
name|file1
init|=
name|touchf
argument_list|(
literal|"file-1.txt"
argument_list|)
decl_stmt|;
name|touchf
argument_list|(
literal|"file-2.txt"
argument_list|)
expr_stmt|;
name|Path
name|parent
init|=
name|file1
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|FileStatus
index|[]
name|result
decl_stmt|;
name|verifyListStatus
argument_list|(
literal|0
argument_list|,
name|parent
argument_list|,
name|NO_PATHS
argument_list|)
expr_stmt|;
name|verifyListStatus
argument_list|(
literal|2
argument_list|,
name|parent
argument_list|,
name|ALL_PATHS
argument_list|)
expr_stmt|;
name|MatchesNameFilter
name|file1Filter
init|=
operator|new
name|MatchesNameFilter
argument_list|(
literal|"file-1.txt"
argument_list|)
decl_stmt|;
name|result
operator|=
name|verifyListStatus
argument_list|(
literal|1
argument_list|,
name|parent
argument_list|,
name|file1Filter
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file1
argument_list|,
name|result
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|verifyListStatus
argument_list|(
literal|0
argument_list|,
name|file1
argument_list|,
name|NO_PATHS
argument_list|)
expr_stmt|;
name|result
operator|=
name|verifyListStatus
argument_list|(
literal|1
argument_list|,
name|file1
argument_list|,
name|ALL_PATHS
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file1
argument_list|,
name|result
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|=
name|verifyListStatus
argument_list|(
literal|1
argument_list|,
name|file1
argument_list|,
name|file1Filter
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file1
argument_list|,
name|result
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
comment|// empty subdirectory
name|Path
name|subdir
init|=
name|path
argument_list|(
literal|"subdir"
argument_list|)
decl_stmt|;
name|mkdirs
argument_list|(
name|subdir
argument_list|)
expr_stmt|;
name|verifyListStatus
argument_list|(
literal|0
argument_list|,
name|subdir
argument_list|,
name|NO_PATHS
argument_list|)
expr_stmt|;
name|verifyListStatus
argument_list|(
literal|0
argument_list|,
name|subdir
argument_list|,
name|ALL_PATHS
argument_list|)
expr_stmt|;
name|verifyListStatus
argument_list|(
literal|0
argument_list|,
name|subdir
argument_list|,
operator|new
name|MatchesNameFilter
argument_list|(
literal|"subdir"
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testListLocatedStatusFiltering ()
specifier|public
name|void
name|testListLocatedStatusFiltering
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Call listLocatedStatus() with filtering"
argument_list|)
expr_stmt|;
name|describe
argument_list|(
literal|"Call listStatus() against paths and directories with filtering"
argument_list|)
expr_stmt|;
name|Path
name|file1
init|=
name|touchf
argument_list|(
literal|"file-1.txt"
argument_list|)
decl_stmt|;
name|Path
name|file2
init|=
name|touchf
argument_list|(
literal|"file-2.txt"
argument_list|)
decl_stmt|;
name|Path
name|parent
init|=
name|file1
operator|.
name|getParent
argument_list|()
decl_stmt|;
name|FileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|touch
argument_list|(
name|fs
argument_list|,
name|file1
argument_list|)
expr_stmt|;
name|touch
argument_list|(
name|fs
argument_list|,
name|file2
argument_list|)
expr_stmt|;
comment|// this is not closed: ignore any IDE warnings.
name|ExtendedFilterFS
name|xfs
init|=
operator|new
name|ExtendedFilterFS
argument_list|(
name|fs
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|LocatedFileStatus
argument_list|>
name|result
decl_stmt|;
name|verifyListStatus
argument_list|(
literal|0
argument_list|,
name|parent
argument_list|,
name|NO_PATHS
argument_list|)
expr_stmt|;
name|verifyListStatus
argument_list|(
literal|2
argument_list|,
name|parent
argument_list|,
name|ALL_PATHS
argument_list|)
expr_stmt|;
name|MatchesNameFilter
name|file1Filter
init|=
operator|new
name|MatchesNameFilter
argument_list|(
literal|"file-1.txt"
argument_list|)
decl_stmt|;
name|result
operator|=
name|verifyListLocatedStatus
argument_list|(
name|xfs
argument_list|,
literal|1
argument_list|,
name|parent
argument_list|,
name|file1Filter
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file1
argument_list|,
name|result
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|verifyListLocatedStatus
argument_list|(
name|xfs
argument_list|,
literal|0
argument_list|,
name|file1
argument_list|,
name|NO_PATHS
argument_list|)
expr_stmt|;
name|verifyListLocatedStatus
argument_list|(
name|xfs
argument_list|,
literal|1
argument_list|,
name|file1
argument_list|,
name|ALL_PATHS
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file1
argument_list|,
name|result
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|verifyListLocatedStatus
argument_list|(
name|xfs
argument_list|,
literal|1
argument_list|,
name|file1
argument_list|,
name|file1Filter
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file1
argument_list|,
name|result
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|verifyListLocatedStatusNextCalls
argument_list|(
name|xfs
argument_list|,
literal|1
argument_list|,
name|file1
argument_list|,
name|file1Filter
argument_list|)
expr_stmt|;
comment|// empty subdirectory
name|Path
name|subdir
init|=
name|path
argument_list|(
literal|"subdir"
argument_list|)
decl_stmt|;
name|mkdirs
argument_list|(
name|subdir
argument_list|)
expr_stmt|;
name|verifyListLocatedStatus
argument_list|(
name|xfs
argument_list|,
literal|0
argument_list|,
name|subdir
argument_list|,
name|NO_PATHS
argument_list|)
expr_stmt|;
name|verifyListLocatedStatus
argument_list|(
name|xfs
argument_list|,
literal|0
argument_list|,
name|subdir
argument_list|,
name|ALL_PATHS
argument_list|)
expr_stmt|;
name|verifyListLocatedStatusNextCalls
argument_list|(
name|xfs
argument_list|,
literal|0
argument_list|,
name|subdir
argument_list|,
name|ALL_PATHS
argument_list|)
expr_stmt|;
name|verifyListLocatedStatus
argument_list|(
name|xfs
argument_list|,
literal|0
argument_list|,
name|subdir
argument_list|,
operator|new
name|MatchesNameFilter
argument_list|(
literal|"subdir"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Execute {@link FileSystem#listStatus(Path, PathFilter)},    * verify the length of the result, then return the listing.    * @param expected expected length    * @param path path to list    * @param filter filter to apply    * @return the listing    * @throws IOException IO Problems    */
DECL|method|verifyListStatus (int expected, Path path, PathFilter filter)
specifier|private
name|FileStatus
index|[]
name|verifyListStatus
parameter_list|(
name|int
name|expected
parameter_list|,
name|Path
name|path
parameter_list|,
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
index|[]
name|result
init|=
name|getFileSystem
argument_list|()
operator|.
name|listStatus
argument_list|(
name|path
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"length of listStatus("
operator|+
name|path
operator|+
literal|", "
operator|+
name|filter
operator|+
literal|" ) "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|result
argument_list|)
argument_list|,
name|expected
argument_list|,
name|result
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Execute {@link FileSystem#listLocatedStatus(Path, PathFilter)},    * generate a list from the iterator, verify the length of the list returned    * and then return it.    * @param expected expected length    * @param path path to list    * @param filter filter to apply    * @return the listing    * @throws IOException IO Problems    */
DECL|method|verifyListLocatedStatus (ExtendedFilterFS xfs, int expected, Path path, PathFilter filter)
specifier|private
name|List
argument_list|<
name|LocatedFileStatus
argument_list|>
name|verifyListLocatedStatus
parameter_list|(
name|ExtendedFilterFS
name|xfs
parameter_list|,
name|int
name|expected
parameter_list|,
name|Path
name|path
parameter_list|,
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|it
init|=
name|xfs
operator|.
name|listLocatedStatus
argument_list|(
name|path
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|LocatedFileStatus
argument_list|>
name|result
init|=
name|toList
argument_list|(
name|it
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"length of listLocatedStatus("
operator|+
name|path
operator|+
literal|", "
operator|+
name|filter
operator|+
literal|" )"
argument_list|,
name|expected
argument_list|,
name|result
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Execute {@link FileSystem#listLocatedStatus(Path, PathFilter)},    * generate a list from the iterator, verify the length of the list returned    * and then return it.    * Uses {@link ContractTestUtils#toListThroughNextCallsAlone(RemoteIterator)}    * to stress the iteration process.    * @param expected expected length    * @param path path to list    * @param filter filter to apply    * @return the listing    * @throws IOException IO Problems    */
DECL|method|verifyListLocatedStatusNextCalls ( ExtendedFilterFS xfs, int expected, Path path, PathFilter filter)
specifier|private
name|List
argument_list|<
name|LocatedFileStatus
argument_list|>
name|verifyListLocatedStatusNextCalls
parameter_list|(
name|ExtendedFilterFS
name|xfs
parameter_list|,
name|int
name|expected
parameter_list|,
name|Path
name|path
parameter_list|,
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|it
init|=
name|xfs
operator|.
name|listLocatedStatus
argument_list|(
name|path
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|LocatedFileStatus
argument_list|>
name|result
init|=
name|toListThroughNextCallsAlone
argument_list|(
name|it
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"length of listLocatedStatus("
operator|+
name|path
operator|+
literal|", "
operator|+
name|filter
operator|+
literal|" )"
argument_list|,
name|expected
argument_list|,
name|result
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
DECL|field|ALL_PATHS
specifier|private
specifier|static
specifier|final
name|PathFilter
name|ALL_PATHS
init|=
operator|new
name|AllPathsFilter
argument_list|()
decl_stmt|;
DECL|field|NO_PATHS
specifier|private
specifier|static
specifier|final
name|PathFilter
name|NO_PATHS
init|=
operator|new
name|NoPathsFilter
argument_list|()
decl_stmt|;
comment|/**    * Accept everything.    */
DECL|class|AllPathsFilter
specifier|private
specifier|static
specifier|final
class|class
name|AllPathsFilter
implements|implements
name|PathFilter
block|{
annotation|@
name|Override
DECL|method|accept (Path path)
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Accept nothing.    */
DECL|class|NoPathsFilter
specifier|private
specifier|static
specifier|final
class|class
name|NoPathsFilter
implements|implements
name|PathFilter
block|{
annotation|@
name|Override
DECL|method|accept (Path path)
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Path filter which only expects paths whose final name element    * equals the {@code match} field.    */
DECL|class|MatchesNameFilter
specifier|private
specifier|static
specifier|final
class|class
name|MatchesNameFilter
implements|implements
name|PathFilter
block|{
DECL|field|match
specifier|private
specifier|final
name|String
name|match
decl_stmt|;
DECL|method|MatchesNameFilter (String match)
name|MatchesNameFilter
parameter_list|(
name|String
name|match
parameter_list|)
block|{
name|this
operator|.
name|match
operator|=
name|match
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|accept (Path path)
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
return|return
name|match
operator|.
name|equals
argument_list|(
name|path
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**    * A filesystem filter which exposes the protected method    * {@link #listLocatedStatus(Path, PathFilter)}.    */
DECL|class|ExtendedFilterFS
specifier|protected
specifier|static
specifier|final
class|class
name|ExtendedFilterFS
extends|extends
name|FilterFileSystem
block|{
DECL|method|ExtendedFilterFS (FileSystem fs)
specifier|public
name|ExtendedFilterFS
parameter_list|(
name|FileSystem
name|fs
parameter_list|)
block|{
name|super
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|listLocatedStatus (Path f, PathFilter filter)
specifier|public
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|listLocatedStatus
parameter_list|(
name|Path
name|f
parameter_list|,
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|super
operator|.
name|listLocatedStatus
argument_list|(
name|f
argument_list|,
name|filter
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

