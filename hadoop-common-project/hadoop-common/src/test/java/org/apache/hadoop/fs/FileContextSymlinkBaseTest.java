begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
operator|.
name|CreateOpts
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
operator|.
name|Rename
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CreateFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileContextTestHelper
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assume
operator|.
name|assumeTrue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_comment
comment|/**  * Test symbolic links using FileContext.  */
end_comment

begin_class
DECL|class|FileContextSymlinkBaseTest
specifier|public
specifier|abstract
class|class
name|FileContextSymlinkBaseTest
block|{
DECL|field|seed
specifier|static
specifier|final
name|long
name|seed
init|=
literal|0xDEADBEEFL
decl_stmt|;
DECL|field|blockSize
specifier|static
specifier|final
name|int
name|blockSize
init|=
literal|8192
decl_stmt|;
DECL|field|fileSize
specifier|static
specifier|final
name|int
name|fileSize
init|=
literal|16384
decl_stmt|;
DECL|field|fc
specifier|protected
specifier|static
name|FileContext
name|fc
decl_stmt|;
DECL|method|getScheme ()
specifier|abstract
specifier|protected
name|String
name|getScheme
parameter_list|()
function_decl|;
DECL|method|testBaseDir1 ()
specifier|abstract
specifier|protected
name|String
name|testBaseDir1
parameter_list|()
throws|throws
name|IOException
function_decl|;
DECL|method|testBaseDir2 ()
specifier|abstract
specifier|protected
name|String
name|testBaseDir2
parameter_list|()
throws|throws
name|IOException
function_decl|;
DECL|method|testURI ()
specifier|abstract
specifier|protected
name|URI
name|testURI
parameter_list|()
function_decl|;
DECL|method|unwrapException (IOException e)
specifier|protected
name|IOException
name|unwrapException
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
name|e
return|;
block|}
DECL|method|createAndWriteFile (FileContext fc, Path p)
specifier|protected
specifier|static
name|void
name|createAndWriteFile
parameter_list|(
name|FileContext
name|fc
parameter_list|,
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|createFile
argument_list|(
name|fc
argument_list|,
name|p
argument_list|,
name|fileSize
operator|/
name|blockSize
argument_list|,
name|CreateOpts
operator|.
name|createParent
argument_list|()
argument_list|,
name|CreateOpts
operator|.
name|repFac
argument_list|(
operator|(
name|short
operator|)
literal|1
argument_list|)
argument_list|,
name|CreateOpts
operator|.
name|blockSize
argument_list|(
name|blockSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|createAndWriteFile (Path p)
specifier|protected
specifier|static
name|void
name|createAndWriteFile
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|createAndWriteFile
argument_list|(
name|fc
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
DECL|method|readFile (Path p)
specifier|protected
specifier|static
name|void
name|readFile
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|FileContextTestHelper
operator|.
name|readFile
argument_list|(
name|fc
argument_list|,
name|p
argument_list|,
name|fileSize
argument_list|)
expr_stmt|;
block|}
DECL|method|readFile (FileContext fc, Path p)
specifier|protected
specifier|static
name|void
name|readFile
parameter_list|(
name|FileContext
name|fc
parameter_list|,
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|FileContextTestHelper
operator|.
name|readFile
argument_list|(
name|fc
argument_list|,
name|p
argument_list|,
name|fileSize
argument_list|)
expr_stmt|;
block|}
DECL|method|appendToFile (Path p)
specifier|protected
specifier|static
name|void
name|appendToFile
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|FileContextTestHelper
operator|.
name|appendToFile
argument_list|(
name|fc
argument_list|,
name|p
argument_list|,
name|fileSize
operator|/
name|blockSize
argument_list|,
name|CreateOpts
operator|.
name|blockSize
argument_list|(
name|blockSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Before
DECL|method|setUp ()
specifier|public
name|void
name|setUp
parameter_list|()
throws|throws
name|Exception
block|{
name|fc
operator|.
name|mkdir
argument_list|(
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
argument_list|,
name|FileContext
operator|.
name|DEFAULT_PERM
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|fc
operator|.
name|mkdir
argument_list|(
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|)
argument_list|,
name|FileContext
operator|.
name|DEFAULT_PERM
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|After
DECL|method|tearDown ()
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
name|fc
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|fc
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** The root is not a symlink */
DECL|method|testStatRoot ()
specifier|public
name|void
name|testStatRoot
parameter_list|()
throws|throws
name|IOException
block|{
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test setWorkingDirectory not resolves symlinks */
DECL|method|testSetWDNotResolvesLinks ()
specifier|public
name|void
name|testSetWDNotResolvesLinks
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/link"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|dir
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|setWorkingDirectory
argument_list|(
name|linkToDir
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|linkToDir
operator|.
name|getName
argument_list|()
argument_list|,
name|fc
operator|.
name|getWorkingDirectory
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test create a dangling link */
DECL|method|testCreateDanglingLink ()
specifier|public
name|void
name|testCreateDanglingLink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
literal|"/noSuchFile"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/link"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|getFileStatus
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Got file status of non-existant file"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|f
parameter_list|)
block|{
comment|// Expected
block|}
name|fc
operator|.
name|delete
argument_list|(
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test create a link to null and empty path */
DECL|method|testCreateLinkToNullEmpty ()
specifier|public
name|void
name|testCreateLinkToNullEmpty
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/link"
argument_list|)
decl_stmt|;
try|try
block|{
name|fc
operator|.
name|createSymlink
argument_list|(
literal|null
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Can't create symlink to null"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|lang
operator|.
name|NullPointerException
name|e
parameter_list|)
block|{
comment|// Expected, create* with null yields NPEs
block|}
try|try
block|{
name|fc
operator|.
name|createSymlink
argument_list|(
operator|new
name|Path
argument_list|(
literal|""
argument_list|)
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Can't create symlink to empty string"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|lang
operator|.
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// Expected, Path("") is invalid
block|}
block|}
annotation|@
name|Test
comment|/** Create a link with createParent set */
DECL|method|testCreateLinkCanCreateParent ()
specifier|public
name|void
name|testCreateLinkCanCreateParent
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/file"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
operator|+
literal|"/linkToFile"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|delete
argument_list|(
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Created link without first creating parent dir"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
comment|// Expected. Need to create testBaseDir2() first.
block|}
name|assertFalse
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|link
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Try to create a directory given a path that refers to a symlink */
DECL|method|testMkdirExistingLink ()
specifier|public
name|void
name|testMkdirExistingLink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/link"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/doesNotExist"
argument_list|)
argument_list|,
name|dir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|mkdir
argument_list|(
name|dir
argument_list|,
name|FileContext
operator|.
name|DEFAULT_PERM
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Created a dir where a symlink exists"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileAlreadyExistsException
name|e
parameter_list|)
block|{
comment|// Expected. The symlink already exists.
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// LocalFs just throws an IOException
name|assertEquals
argument_list|(
literal|"file"
argument_list|,
name|getScheme
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
comment|/** Try to create a file with parent that is a dangling link */
DECL|method|testCreateFileViaDanglingLinkParent ()
specifier|public
name|void
name|testCreateFileViaDanglingLinkParent
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/dangling"
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/dangling/file"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/doesNotExist"
argument_list|)
argument_list|,
name|dir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|FSDataOutputStream
name|out
decl_stmt|;
try|try
block|{
name|out
operator|=
name|fc
operator|.
name|create
argument_list|(
name|file
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|CreateFlag
operator|.
name|CREATE
argument_list|)
argument_list|,
name|CreateOpts
operator|.
name|repFac
argument_list|(
operator|(
name|short
operator|)
literal|1
argument_list|)
argument_list|,
name|CreateOpts
operator|.
name|blockSize
argument_list|(
name|blockSize
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|fail
argument_list|(
literal|"Created a link with dangling link parent"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|// Expected. The parent is dangling.
block|}
block|}
annotation|@
name|Test
comment|/** Delete a link */
DECL|method|testDeleteLink ()
specifier|public
name|void
name|testDeleteLink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/file"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/linkToFile"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|fc
operator|.
name|delete
argument_list|(
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|readFile
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Symlink should have been deleted"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
comment|// Expected
block|}
comment|// If we deleted the link we can put it back
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Ensure open resolves symlinks */
DECL|method|testOpenResolvesLinks ()
specifier|public
name|void
name|testOpenResolvesLinks
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/noSuchFile"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/link"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|open
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"link target does not exist"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|x
parameter_list|)
block|{
comment|// Expected
block|}
name|fc
operator|.
name|delete
argument_list|(
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Stat a link to a file */
DECL|method|testStatLinkToFile ()
specifier|public
name|void
name|testStatLinkToFile
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/file"
argument_list|)
decl_stmt|;
name|Path
name|linkToFile
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/linkToFile"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|linkToFile
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkToFile
argument_list|)
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|isSymlink
argument_list|(
name|fc
argument_list|,
name|linkToFile
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|isFile
argument_list|(
name|fc
argument_list|,
name|linkToFile
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|isDir
argument_list|(
name|fc
argument_list|,
name|linkToFile
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|linkToFile
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// The local file system does not fully resolve the link
comment|// when obtaining the file status
if|if
condition|(
operator|!
literal|"file"
operator|.
name|equals
argument_list|(
name|getScheme
argument_list|()
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|file
argument_list|)
argument_list|,
name|fc
operator|.
name|getFileStatus
argument_list|(
name|linkToFile
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fc
operator|.
name|makeQualified
argument_list|(
name|file
argument_list|)
argument_list|,
name|fc
operator|.
name|getFileStatus
argument_list|(
name|linkToFile
argument_list|)
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fc
operator|.
name|makeQualified
argument_list|(
name|linkToFile
argument_list|)
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkToFile
argument_list|)
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
comment|/** Stat a relative link to a file */
DECL|method|testStatRelLinkToFile ()
specifier|public
name|void
name|testStatRelLinkToFile
parameter_list|()
throws|throws
name|IOException
block|{
name|assumeTrue
argument_list|(
operator|!
literal|"file"
operator|.
name|equals
argument_list|(
name|getScheme
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|baseDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|linkToFile
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
operator|new
name|Path
argument_list|(
literal|"file"
argument_list|)
argument_list|,
name|linkToFile
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|file
argument_list|)
argument_list|,
name|fc
operator|.
name|getFileStatus
argument_list|(
name|linkToFile
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fc
operator|.
name|makeQualified
argument_list|(
name|file
argument_list|)
argument_list|,
name|fc
operator|.
name|getFileStatus
argument_list|(
name|linkToFile
argument_list|)
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fc
operator|.
name|makeQualified
argument_list|(
name|linkToFile
argument_list|)
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkToFile
argument_list|)
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Stat a link to a directory */
DECL|method|testStatLinkToDir ()
specifier|public
name|void
name|testStatLinkToDir
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/linkToDir"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|dir
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|linkToDir
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|isDir
argument_list|(
name|fc
argument_list|,
name|linkToDir
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkToDir
argument_list|)
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkToDir
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|isFile
argument_list|(
name|fc
argument_list|,
name|linkToDir
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|isDir
argument_list|(
name|fc
argument_list|,
name|linkToDir
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|dir
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|linkToDir
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Stat a dangling link */
DECL|method|testStatDanglingLink ()
specifier|public
name|void
name|testStatDanglingLink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
literal|"/noSuchFile"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/link"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|link
argument_list|)
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|link
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Stat a non-existant file */
DECL|method|testStatNonExistantFiles ()
specifier|public
name|void
name|testStatNonExistantFiles
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|fileAbs
init|=
operator|new
name|Path
argument_list|(
literal|"/doesNotExist"
argument_list|)
decl_stmt|;
try|try
block|{
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|fileAbs
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Got FileStatus for non-existant file"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|f
parameter_list|)
block|{
comment|// Expected
block|}
try|try
block|{
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|fileAbs
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Got link target for non-existant file"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|f
parameter_list|)
block|{
comment|// Expected
block|}
block|}
annotation|@
name|Test
comment|/** Test stat'ing a regular file and directory */
DECL|method|testStatNonLinks ()
specifier|public
name|void
name|testStatNonLinks
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/file"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Lstat'd a non-symlink"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
try|try
block|{
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Lstat'd a non-symlink"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Expected.
block|}
block|}
annotation|@
name|Test
comment|/** Test links that link to each other */
DECL|method|testRecursiveLinks ()
specifier|public
name|void
name|testRecursiveLinks
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|link1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/link1"
argument_list|)
decl_stmt|;
name|Path
name|link2
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/link2"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|link1
argument_list|,
name|link2
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|link2
argument_list|,
name|link1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|readFile
argument_list|(
name|link1
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Read recursive link"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|f
parameter_list|)
block|{
comment|// LocalFs throws sub class of IOException, since File.exists
comment|// returns false for a link to link.
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
name|assertEquals
argument_list|(
literal|"Possible cyclic loop while following symbolic link "
operator|+
name|link1
operator|.
name|toString
argument_list|()
argument_list|,
name|x
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Assert that the given link to a file behaves as expected. */
DECL|method|checkLink (Path linkAbs, Path expectedTarget, Path targetQual)
specifier|private
name|void
name|checkLink
parameter_list|(
name|Path
name|linkAbs
parameter_list|,
name|Path
name|expectedTarget
parameter_list|,
name|Path
name|targetQual
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
comment|// isFile/Directory
name|assertTrue
argument_list|(
name|isFile
argument_list|(
name|fc
argument_list|,
name|linkAbs
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|isDir
argument_list|(
name|fc
argument_list|,
name|linkAbs
argument_list|)
argument_list|)
expr_stmt|;
comment|// Check getFileStatus
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|linkAbs
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|linkAbs
argument_list|)
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileSize
argument_list|,
name|fc
operator|.
name|getFileStatus
argument_list|(
name|linkAbs
argument_list|)
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
comment|// Check getFileLinkStatus
name|assertTrue
argument_list|(
name|isSymlink
argument_list|(
name|fc
argument_list|,
name|linkAbs
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkAbs
argument_list|)
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
comment|// Check getSymlink always returns a qualified target, except
comment|// when partially qualified paths are used (see tests below).
name|assertEquals
argument_list|(
name|targetQual
operator|.
name|toString
argument_list|()
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkAbs
argument_list|)
operator|.
name|getSymlink
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|targetQual
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkAbs
argument_list|)
operator|.
name|getSymlink
argument_list|()
argument_list|)
expr_stmt|;
comment|// Check that the target is qualified using the file system of the
comment|// path used to access the link (if the link target was not specified
comment|// fully qualified, in that case we use the link target verbatim).
if|if
condition|(
operator|!
literal|"file"
operator|.
name|equals
argument_list|(
name|getScheme
argument_list|()
argument_list|)
condition|)
block|{
name|FileContext
name|localFc
init|=
name|FileContext
operator|.
name|getLocalFSFileContext
argument_list|()
decl_stmt|;
name|Path
name|linkQual
init|=
operator|new
name|Path
argument_list|(
name|testURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|linkAbs
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|targetQual
argument_list|,
name|localFc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkQual
argument_list|)
operator|.
name|getSymlink
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Check getLinkTarget
name|assertEquals
argument_list|(
name|expectedTarget
argument_list|,
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|linkAbs
argument_list|)
argument_list|)
expr_stmt|;
comment|// Now read using all path types..
name|fc
operator|.
name|setWorkingDirectory
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
operator|new
name|Path
argument_list|(
literal|"linkToFile"
argument_list|)
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|linkAbs
argument_list|)
expr_stmt|;
comment|// And fully qualified.. (NB: for local fs this is partially qualified)
name|readFile
argument_list|(
operator|new
name|Path
argument_list|(
name|testURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|linkAbs
argument_list|)
argument_list|)
expr_stmt|;
comment|// And partially qualified..
name|boolean
name|failureExpected
init|=
literal|"file"
operator|.
name|equals
argument_list|(
name|getScheme
argument_list|()
argument_list|)
condition|?
literal|false
else|:
literal|true
decl_stmt|;
try|try
block|{
name|readFile
argument_list|(
operator|new
name|Path
argument_list|(
name|getScheme
argument_list|()
operator|+
literal|"://"
operator|+
name|testBaseDir1
argument_list|()
operator|+
literal|"/linkToFile"
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|failureExpected
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|failureExpected
argument_list|)
expr_stmt|;
block|}
comment|// Now read using a different file context (for HDFS at least)
if|if
condition|(
operator|!
literal|"file"
operator|.
name|equals
argument_list|(
name|getScheme
argument_list|()
argument_list|)
condition|)
block|{
name|FileContext
name|localFc
init|=
name|FileContext
operator|.
name|getLocalFSFileContext
argument_list|()
decl_stmt|;
name|readFile
argument_list|(
name|localFc
argument_list|,
operator|new
name|Path
argument_list|(
name|testURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|linkAbs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
comment|/** Test creating a symlink using relative paths */
DECL|method|testCreateLinkUsingRelPaths ()
specifier|public
name|void
name|testCreateLinkUsingRelPaths
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|fileAbs
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|linkAbs
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|Path
name|schemeAuth
init|=
operator|new
name|Path
argument_list|(
name|testURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|fileQual
init|=
operator|new
name|Path
argument_list|(
name|schemeAuth
argument_list|,
name|testBaseDir1
argument_list|()
operator|+
literal|"/file"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|fileAbs
argument_list|)
expr_stmt|;
name|fc
operator|.
name|setWorkingDirectory
argument_list|(
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
operator|new
name|Path
argument_list|(
literal|"file"
argument_list|)
argument_list|,
operator|new
name|Path
argument_list|(
literal|"linkToFile"
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|checkLink
argument_list|(
name|linkAbs
argument_list|,
operator|new
name|Path
argument_list|(
literal|"file"
argument_list|)
argument_list|,
name|fileQual
argument_list|)
expr_stmt|;
comment|// Now rename the link's parent. Because the target was specified
comment|// with a relative path the link should still resolve.
name|Path
name|dir1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|dir2
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|linkViaDir2
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|Path
name|fileViaDir2
init|=
operator|new
name|Path
argument_list|(
name|schemeAuth
argument_list|,
name|testBaseDir2
argument_list|()
operator|+
literal|"/file"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|rename
argument_list|(
name|dir1
argument_list|,
name|dir2
argument_list|,
name|Rename
operator|.
name|OVERWRITE
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileViaDir2
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkViaDir2
argument_list|)
operator|.
name|getSymlink
argument_list|()
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|linkViaDir2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test creating a symlink using absolute paths */
DECL|method|testCreateLinkUsingAbsPaths ()
specifier|public
name|void
name|testCreateLinkUsingAbsPaths
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|fileAbs
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/file"
argument_list|)
decl_stmt|;
name|Path
name|linkAbs
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/linkToFile"
argument_list|)
decl_stmt|;
name|Path
name|schemeAuth
init|=
operator|new
name|Path
argument_list|(
name|testURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|fileQual
init|=
operator|new
name|Path
argument_list|(
name|schemeAuth
argument_list|,
name|testBaseDir1
argument_list|()
operator|+
literal|"/file"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|fileAbs
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|fileAbs
argument_list|,
name|linkAbs
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|checkLink
argument_list|(
name|linkAbs
argument_list|,
name|fileAbs
argument_list|,
name|fileQual
argument_list|)
expr_stmt|;
comment|// Now rename the link's parent. The target doesn't change and
comment|// now no longer exists so accessing the link should fail.
name|Path
name|dir1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|dir2
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|linkViaDir2
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|rename
argument_list|(
name|dir1
argument_list|,
name|dir2
argument_list|,
name|Rename
operator|.
name|OVERWRITE
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileQual
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkViaDir2
argument_list|)
operator|.
name|getSymlink
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|readFile
argument_list|(
name|linkViaDir2
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"The target should not exist"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|x
parameter_list|)
block|{
comment|// Expected
block|}
block|}
annotation|@
name|Test
comment|/**     * Test creating a symlink using fully and partially qualified paths.    * NB: For local fs this actually tests partially qualified paths,    * as they don't support fully qualified paths.    */
DECL|method|testCreateLinkUsingFullyQualPaths ()
specifier|public
name|void
name|testCreateLinkUsingFullyQualPaths
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|fileAbs
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|linkAbs
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|Path
name|fileQual
init|=
operator|new
name|Path
argument_list|(
name|testURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|fileAbs
argument_list|)
decl_stmt|;
name|Path
name|linkQual
init|=
operator|new
name|Path
argument_list|(
name|testURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|linkAbs
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|fileAbs
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|fileQual
argument_list|,
name|linkQual
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|checkLink
argument_list|(
name|linkAbs
argument_list|,
literal|"file"
operator|.
name|equals
argument_list|(
name|getScheme
argument_list|()
argument_list|)
condition|?
name|fileAbs
else|:
name|fileQual
argument_list|,
name|fileQual
argument_list|)
expr_stmt|;
comment|// Now rename the link's parent. The target doesn't change and
comment|// now no longer exists so accessing the link should fail.
name|Path
name|dir1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|dir2
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|linkViaDir2
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|rename
argument_list|(
name|dir1
argument_list|,
name|dir2
argument_list|,
name|Rename
operator|.
name|OVERWRITE
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileQual
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkViaDir2
argument_list|)
operator|.
name|getSymlink
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|readFile
argument_list|(
name|linkViaDir2
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"The target should not exist"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|x
parameter_list|)
block|{
comment|// Expected
block|}
block|}
annotation|@
name|Test
comment|/**     * Test creating a symlink using partially qualified paths, ie a scheme     * but no authority and vice versa. We just test link targets here since    * creating using a partially qualified path is file system specific.    */
DECL|method|testCreateLinkUsingPartQualPath1 ()
specifier|public
name|void
name|testCreateLinkUsingPartQualPath1
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Partially qualified paths are covered for local file systems
comment|// in the previous test.
name|assumeTrue
argument_list|(
operator|!
literal|"file"
operator|.
name|equals
argument_list|(
name|getScheme
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|schemeAuth
init|=
operator|new
name|Path
argument_list|(
name|testURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|fileWoHost
init|=
operator|new
name|Path
argument_list|(
name|getScheme
argument_list|()
operator|+
literal|"://"
operator|+
name|testBaseDir1
argument_list|()
operator|+
literal|"/file"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
operator|+
literal|"/linkToFile"
argument_list|)
decl_stmt|;
name|Path
name|linkQual
init|=
operator|new
name|Path
argument_list|(
name|schemeAuth
argument_list|,
name|testBaseDir1
argument_list|()
operator|+
literal|"/linkToFile"
argument_list|)
decl_stmt|;
name|FileContext
name|localFc
init|=
name|FileContext
operator|.
name|getLocalFSFileContext
argument_list|()
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|fileWoHost
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Partially qualified path is stored
name|assertEquals
argument_list|(
name|fileWoHost
argument_list|,
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|linkQual
argument_list|)
argument_list|)
expr_stmt|;
comment|// NB: We do not add an authority
name|assertEquals
argument_list|(
name|fileWoHost
operator|.
name|toString
argument_list|()
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|link
argument_list|)
operator|.
name|getSymlink
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileWoHost
operator|.
name|toString
argument_list|()
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkQual
argument_list|)
operator|.
name|getSymlink
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Ditto even from another file system
name|assertEquals
argument_list|(
name|fileWoHost
operator|.
name|toString
argument_list|()
argument_list|,
name|localFc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkQual
argument_list|)
operator|.
name|getSymlink
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// Same as if we accessed a partially qualified path directly
try|try
block|{
name|readFile
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"DFS requires URIs with schemes have an authority"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|lang
operator|.
name|RuntimeException
name|e
parameter_list|)
block|{
comment|// Expected
block|}
block|}
annotation|@
name|Test
comment|/** Same as above but vice versa (authority but no scheme) */
DECL|method|testCreateLinkUsingPartQualPath2 ()
specifier|public
name|void
name|testCreateLinkUsingPartQualPath2
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|Path
name|fileWoScheme
init|=
operator|new
name|Path
argument_list|(
literal|"//"
operator|+
name|testURI
argument_list|()
operator|.
name|getAuthority
argument_list|()
operator|+
name|testBaseDir1
argument_list|()
operator|+
literal|"/file"
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"file"
operator|.
name|equals
argument_list|(
name|getScheme
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
name|fc
operator|.
name|createSymlink
argument_list|(
name|fileWoScheme
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileWoScheme
argument_list|,
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileWoScheme
operator|.
name|toString
argument_list|()
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|link
argument_list|)
operator|.
name|getSymlink
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|readFile
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Accessed a file with w/o scheme"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Expected
name|assertEquals
argument_list|(
literal|"No AbstractFileSystem for scheme: null"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
comment|/** Lstat and readlink on a normal file and directory */
DECL|method|testLinkStatusAndTargetWithNonLink ()
specifier|public
name|void
name|testLinkStatusAndTargetWithNonLink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|schemeAuth
init|=
operator|new
name|Path
argument_list|(
name|testURI
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|dirQual
init|=
operator|new
name|Path
argument_list|(
name|schemeAuth
argument_list|,
name|dir
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|fileQual
init|=
operator|new
name|Path
argument_list|(
name|schemeAuth
argument_list|,
name|file
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|file
argument_list|)
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|dir
argument_list|)
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Get link target on non-link should throw an IOException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
name|assertEquals
argument_list|(
literal|"Path "
operator|+
name|fileQual
operator|+
literal|" is not a symbolic link"
argument_list|,
name|x
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Get link target on non-link should throw an IOException"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
name|assertEquals
argument_list|(
literal|"Path "
operator|+
name|dirQual
operator|+
literal|" is not a symbolic link"
argument_list|,
name|x
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
comment|/** Test create symlink to a directory */
DECL|method|testCreateLinkToDirectory ()
specifier|public
name|void
name|testCreateLinkToDirectory
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|dir1
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|isFile
argument_list|(
name|fc
argument_list|,
name|linkToDir
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|isDir
argument_list|(
name|fc
argument_list|,
name|linkToDir
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|linkToDir
argument_list|)
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkToDir
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test create and remove a file through a symlink */
DECL|method|testCreateFileViaSymlink ()
specifier|public
name|void
name|testCreateFileViaSymlink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|Path
name|fileViaLink
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|dir
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|createAndWriteFile
argument_list|(
name|fileViaLink
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|isFile
argument_list|(
name|fc
argument_list|,
name|fileViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|isDir
argument_list|(
name|fc
argument_list|,
name|fileViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|fileViaLink
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|fileViaLink
argument_list|)
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|fileViaLink
argument_list|)
expr_stmt|;
name|fc
operator|.
name|delete
argument_list|(
name|fileViaLink
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|fileViaLink
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test make and delete directory through a symlink */
DECL|method|testCreateDirViaSymlink ()
specifier|public
name|void
name|testCreateDirViaSymlink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|subDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"subDir"
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|Path
name|subDirViaLink
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"subDir"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|dir1
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|mkdir
argument_list|(
name|subDirViaLink
argument_list|,
name|FileContext
operator|.
name|DEFAULT_PERM
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|isDir
argument_list|(
name|fc
argument_list|,
name|subDirViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|fc
operator|.
name|delete
argument_list|(
name|subDirViaLink
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|subDirViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|subDir
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Create symlink through a symlink */
DECL|method|testCreateLinkViaLink ()
specifier|public
name|void
name|testCreateLinkViaLink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|Path
name|fileViaLink
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|linkToFile
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
comment|/*      * /b2/linkToDir            -> /b1      * /b2/linkToDir/linkToFile -> /b2/linkToDir/file      */
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|dir1
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|fileViaLink
argument_list|,
name|linkToFile
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|isFile
argument_list|(
name|fc
argument_list|,
name|linkToFile
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkToFile
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|linkToFile
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileSize
argument_list|,
name|fc
operator|.
name|getFileStatus
argument_list|(
name|linkToFile
argument_list|)
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileViaLink
argument_list|,
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|linkToFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test create symlink to a directory */
DECL|method|testListStatusUsingLink ()
specifier|public
name|void
name|testListStatusUsingLink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"link"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// The size of the result is file system dependent, Hdfs is 2 (file
comment|// and link) and LocalFs is 3 (file, link, file crc).
name|FileStatus
index|[]
name|stats
init|=
name|fc
operator|.
name|util
argument_list|()
operator|.
name|listStatus
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|stats
operator|.
name|length
operator|==
literal|2
operator|||
name|stats
operator|.
name|length
operator|==
literal|3
argument_list|)
expr_stmt|;
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|statsItor
init|=
name|fc
operator|.
name|listStatus
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|int
name|dirLen
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|statsItor
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|statsItor
operator|.
name|next
argument_list|()
expr_stmt|;
name|dirLen
operator|++
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|dirLen
operator|==
literal|2
operator|||
name|dirLen
operator|==
literal|3
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test create symlink using the same path */
DECL|method|testCreateLinkTwice ()
specifier|public
name|void
name|testCreateLinkTwice
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"link already exists"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
comment|// Expected
block|}
block|}
annotation|@
name|Test
comment|/** Test access via a symlink to a symlink */
DECL|method|testCreateLinkToLink ()
specifier|public
name|void
name|testCreateLinkToLink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|Path
name|linkToLink
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToLink"
argument_list|)
decl_stmt|;
name|Path
name|fileViaLink
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToLink/file"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|dir1
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|linkToDir
argument_list|,
name|linkToLink
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|isFile
argument_list|(
name|fc
argument_list|,
name|fileViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|isDir
argument_list|(
name|fc
argument_list|,
name|fileViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|fileViaLink
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|fileViaLink
argument_list|)
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|fileViaLink
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Can not create a file with path that refers to a symlink */
DECL|method|testCreateFileDirExistingLink ()
specifier|public
name|void
name|testCreateFileDirExistingLink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|createAndWriteFile
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"link already exists"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
comment|// Expected
block|}
try|try
block|{
name|fc
operator|.
name|mkdir
argument_list|(
name|link
argument_list|,
name|FsPermission
operator|.
name|getDefault
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"link already exists"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
comment|// Expected
block|}
block|}
annotation|@
name|Test
comment|/** Test deleting and recreating a symlink */
DECL|method|testUseLinkAferDeleteLink ()
specifier|public
name|void
name|testUseLinkAferDeleteLink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|delete
argument_list|(
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|readFile
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"link was deleted"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
comment|// Expected
block|}
name|readFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|link
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test create symlink to . */
DECL|method|testCreateLinkToDot ()
specifier|public
name|void
name|testCreateLinkToDot
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToDot"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|setWorkingDirectory
argument_list|(
name|dir
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|createSymlink
argument_list|(
operator|new
name|Path
argument_list|(
literal|"."
argument_list|)
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Created symlink to dot"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
comment|// Expected. Path(".") resolves to "" because URI normalizes
comment|// the dot away and AbstractFileSystem considers "" invalid.
block|}
block|}
annotation|@
name|Test
comment|/** Test create symlink to .. */
DECL|method|testCreateLinkToDotDot ()
specifier|public
name|void
name|testCreateLinkToDotDot
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"test/file"
argument_list|)
decl_stmt|;
name|Path
name|dotDot
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"test/.."
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|Path
name|fileViaLink
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"test/file"
argument_list|)
decl_stmt|;
comment|// Symlink to .. is not a problem since the .. is squashed early
name|assertEquals
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
name|dotDot
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|dotDot
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|fileViaLink
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fileSize
argument_list|,
name|fc
operator|.
name|getFileStatus
argument_list|(
name|fileViaLink
argument_list|)
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test create symlink to ../file */
DECL|method|testCreateLinkToDotDotPrefix ()
specifier|public
name|void
name|testCreateLinkToDotDotPrefix
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"test"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"test/link"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|mkdir
argument_list|(
name|dir
argument_list|,
name|FsPermission
operator|.
name|getDefault
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|setWorkingDirectory
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
operator|new
name|Path
argument_list|(
literal|"../file"
argument_list|)
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|new
name|Path
argument_list|(
literal|"../file"
argument_list|)
argument_list|,
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test rename file using a path that contains a symlink. The rename should     * work as if the path did not contain a symlink */
DECL|method|testRenameFileViaSymlink ()
specifier|public
name|void
name|testRenameFileViaSymlink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|Path
name|fileViaLink
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|fileNewViaLink
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"fileNew"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|dir
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|rename
argument_list|(
name|fileViaLink
argument_list|,
name|fileNewViaLink
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|fileViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|fileNewViaLink
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test rename a file through a symlink but this time only the     * destination path has an intermediate symlink. The rename should work     * as if the path did not contain a symlink */
DECL|method|testRenameFileToDestViaSymlink ()
specifier|public
name|void
name|testRenameFileToDestViaSymlink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|Path
name|subDir
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"subDir"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|dir
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|mkdir
argument_list|(
name|subDir
argument_list|,
name|FileContext
operator|.
name|DEFAULT_PERM
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|rename
argument_list|(
name|file
argument_list|,
name|subDir
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Renamed file to a directory"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Expected. Both must be directories.
name|assertTrue
argument_list|(
name|unwrapException
argument_list|(
name|e
argument_list|)
operator|instanceof
name|IOException
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Similar tests as the previous ones but rename a directory */
DECL|method|testRenameDirViaSymlink ()
specifier|public
name|void
name|testRenameDirViaSymlink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|baseDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|baseDir
argument_list|,
literal|"dir"
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|Path
name|dirViaLink
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"dir"
argument_list|)
decl_stmt|;
name|Path
name|dirNewViaLink
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"dirNew"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|mkdir
argument_list|(
name|dir
argument_list|,
name|FileContext
operator|.
name|DEFAULT_PERM
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|baseDir
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|dirViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|fc
operator|.
name|rename
argument_list|(
name|dirViaLink
argument_list|,
name|dirNewViaLink
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|dirViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|dirNewViaLink
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Similar tests as the previous ones but rename a symlink */
DECL|method|testRenameSymlinkViaSymlink ()
specifier|public
name|void
name|testRenameSymlinkViaSymlink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|baseDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"link"
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|Path
name|linkViaLink
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"link"
argument_list|)
decl_stmt|;
name|Path
name|linkNewViaLink
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"linkNew"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|baseDir
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|rename
argument_list|(
name|linkViaLink
argument_list|,
name|linkNewViaLink
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|linkViaLink
argument_list|)
argument_list|)
expr_stmt|;
comment|// Check that we didn't rename the link target
name|assertTrue
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|linkNewViaLink
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|linkNewViaLink
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test rename a directory to a symlink to a directory */
DECL|method|testRenameDirToSymlinkToDir ()
specifier|public
name|void
name|testRenameDirToSymlinkToDir
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|subDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"subDir"
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|mkdir
argument_list|(
name|subDir
argument_list|,
name|FileContext
operator|.
name|DEFAULT_PERM
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|subDir
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|rename
argument_list|(
name|dir1
argument_list|,
name|linkToDir
argument_list|,
name|Rename
operator|.
name|OVERWRITE
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Renamed directory to a symlink"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Expected. Both must be directories.
name|assertTrue
argument_list|(
name|unwrapException
argument_list|(
name|e
argument_list|)
operator|instanceof
name|IOException
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|dir1
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|linkToDir
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test rename a directory to a symlink to a file */
DECL|method|testRenameDirToSymlinkToFile ()
specifier|public
name|void
name|testRenameDirToSymlinkToFile
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|linkToFile
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|linkToFile
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|rename
argument_list|(
name|dir1
argument_list|,
name|linkToFile
argument_list|,
name|Rename
operator|.
name|OVERWRITE
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Renamed directory to a symlink"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Expected. Both must be directories.
name|assertTrue
argument_list|(
name|unwrapException
argument_list|(
name|e
argument_list|)
operator|instanceof
name|IOException
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|dir1
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|linkToFile
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test rename a directory to a dangling symlink */
DECL|method|testRenameDirToDanglingSymlink ()
specifier|public
name|void
name|testRenameDirToDanglingSymlink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/doesNotExist"
argument_list|)
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|rename
argument_list|(
name|dir
argument_list|,
name|link
argument_list|,
name|Rename
operator|.
name|OVERWRITE
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Renamed directory to a symlink"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Expected. Both must be directories.
name|assertTrue
argument_list|(
name|unwrapException
argument_list|(
name|e
argument_list|)
operator|instanceof
name|IOException
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|link
argument_list|)
operator|!=
literal|null
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test rename a file to a symlink to a directory */
DECL|method|testRenameFileToSymlinkToDir ()
specifier|public
name|void
name|testRenameFileToSymlinkToDir
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|subDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"subDir"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"link"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|mkdir
argument_list|(
name|subDir
argument_list|,
name|FileContext
operator|.
name|DEFAULT_PERM
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|subDir
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|rename
argument_list|(
name|file
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Renamed file to symlink w/o overwrite"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Expected
name|assertTrue
argument_list|(
name|unwrapException
argument_list|(
name|e
argument_list|)
operator|instanceof
name|FileAlreadyExistsException
argument_list|)
expr_stmt|;
block|}
name|fc
operator|.
name|rename
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
name|Rename
operator|.
name|OVERWRITE
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|isFile
argument_list|(
name|fc
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|link
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test rename a file to a symlink to a file */
DECL|method|testRenameFileToSymlinkToFile ()
specifier|public
name|void
name|testRenameFileToSymlinkToFile
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file1"
argument_list|)
decl_stmt|;
name|Path
name|file2
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file2"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file1
argument_list|)
expr_stmt|;
name|createAndWriteFile
argument_list|(
name|file2
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file2
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|rename
argument_list|(
name|file1
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Renamed file to symlink w/o overwrite"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Expected
name|assertTrue
argument_list|(
name|unwrapException
argument_list|(
name|e
argument_list|)
operator|instanceof
name|FileAlreadyExistsException
argument_list|)
expr_stmt|;
block|}
name|fc
operator|.
name|rename
argument_list|(
name|file1
argument_list|,
name|link
argument_list|,
name|Rename
operator|.
name|OVERWRITE
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|file1
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|isFile
argument_list|(
name|fc
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|link
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test rename a file to a dangling symlink */
DECL|method|testRenameFileToDanglingSymlink ()
specifier|public
name|void
name|testRenameFileToDanglingSymlink
parameter_list|()
throws|throws
name|IOException
block|{
comment|/* NB: Local file system doesn't handle dangling links correctly      * since File.exists(danglinLink) returns false. */
if|if
condition|(
literal|"file"
operator|.
name|equals
argument_list|(
name|getScheme
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
name|Path
name|file1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file1"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file1
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/doesNotExist"
argument_list|)
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|rename
argument_list|(
name|file1
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Expected
block|}
name|fc
operator|.
name|rename
argument_list|(
name|file1
argument_list|,
name|link
argument_list|,
name|Rename
operator|.
name|OVERWRITE
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|file1
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|isFile
argument_list|(
name|fc
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|link
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Rename a symlink to a new non-existant name */
DECL|method|testRenameSymlinkNonExistantDest ()
specifier|public
name|void
name|testRenameSymlinkNonExistantDest
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|link1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile1"
argument_list|)
decl_stmt|;
name|Path
name|link2
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile2"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|rename
argument_list|(
name|link1
argument_list|,
name|link2
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|link2
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|link2
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|link1
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Rename a symlink to a file that exists */
DECL|method|testRenameSymlinkToExistingFile ()
specifier|public
name|void
name|testRenameSymlinkToExistingFile
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|file2
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"someFile"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file1
argument_list|)
expr_stmt|;
name|createAndWriteFile
argument_list|(
name|file2
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file2
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|rename
argument_list|(
name|link
argument_list|,
name|file1
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Renamed w/o passing overwrite"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Expected
name|assertTrue
argument_list|(
name|unwrapException
argument_list|(
name|e
argument_list|)
operator|instanceof
name|FileAlreadyExistsException
argument_list|)
expr_stmt|;
block|}
name|fc
operator|.
name|rename
argument_list|(
name|link
argument_list|,
name|file1
argument_list|,
name|Rename
operator|.
name|OVERWRITE
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|file1
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file2
argument_list|,
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|file1
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Rename a symlink to a directory that exists */
DECL|method|testRenameSymlinkToExistingDir ()
specifier|public
name|void
name|testRenameSymlinkToExistingDir
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|dir1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|dir2
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|subDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"subDir"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|dir1
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|rename
argument_list|(
name|link
argument_list|,
name|dir2
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Renamed link to a directory"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Expected. Both must be directories.
name|assertTrue
argument_list|(
name|unwrapException
argument_list|(
name|e
argument_list|)
operator|instanceof
name|IOException
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|fc
operator|.
name|rename
argument_list|(
name|link
argument_list|,
name|dir2
argument_list|,
name|Rename
operator|.
name|OVERWRITE
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Renamed link to a directory"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Expected. Both must be directories.
name|assertTrue
argument_list|(
name|unwrapException
argument_list|(
name|e
argument_list|)
operator|instanceof
name|IOException
argument_list|)
expr_stmt|;
block|}
comment|// Also fails when dir2 has a sub-directory
name|fc
operator|.
name|mkdir
argument_list|(
name|subDir
argument_list|,
name|FsPermission
operator|.
name|getDefault
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|rename
argument_list|(
name|link
argument_list|,
name|dir2
argument_list|,
name|Rename
operator|.
name|OVERWRITE
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Renamed link to a directory"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Expected. Both must be directories.
name|assertTrue
argument_list|(
name|unwrapException
argument_list|(
name|e
argument_list|)
operator|instanceof
name|IOException
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
comment|/** Rename a symlink to itself */
DECL|method|testRenameSymlinkToItself ()
specifier|public
name|void
name|testRenameSymlinkToItself
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile1"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
operator|new
name|Path
argument_list|(
literal|"/doestNotExist"
argument_list|)
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|rename
argument_list|(
name|link
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|unwrapException
argument_list|(
name|e
argument_list|)
operator|instanceof
name|FileAlreadyExistsException
argument_list|)
expr_stmt|;
block|}
comment|// Fails with overwrite as well
try|try
block|{
name|fc
operator|.
name|rename
argument_list|(
name|link
argument_list|,
name|link
argument_list|,
name|Rename
operator|.
name|OVERWRITE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|unwrapException
argument_list|(
name|e
argument_list|)
operator|instanceof
name|FileAlreadyExistsException
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
comment|/** Rename a symlink */
DECL|method|testRenameSymlink ()
specifier|public
name|void
name|testRenameSymlink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|link1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile1"
argument_list|)
decl_stmt|;
name|Path
name|link2
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile2"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|rename
argument_list|(
name|link1
argument_list|,
name|link2
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|link2
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|link2
argument_list|)
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|link2
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
try|try
block|{
name|createAndWriteFile
argument_list|(
name|link2
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"link was not renamed"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
comment|// Expected
block|}
block|}
annotation|@
name|Test
comment|/** Rename a symlink to the file it links to */
DECL|method|testRenameSymlinkToFileItLinksTo ()
specifier|public
name|void
name|testRenameSymlinkToFileItLinksTo
parameter_list|()
throws|throws
name|IOException
block|{
comment|/* NB: The rename is not atomic, so file is deleted before renaming      * linkToFile. In this interval linkToFile is dangling and local file       * system does not handle dangling links because File.exists returns       * false for dangling links. */
if|if
condition|(
literal|"file"
operator|.
name|equals
argument_list|(
name|getScheme
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|rename
argument_list|(
name|link
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Renamed symlink to its target"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|unwrapException
argument_list|(
name|e
argument_list|)
operator|instanceof
name|FileAlreadyExistsException
argument_list|)
expr_stmt|;
block|}
comment|// Check the rename didn't happen
name|assertTrue
argument_list|(
name|isFile
argument_list|(
name|fc
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|isSymlink
argument_list|(
name|fc
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file
argument_list|,
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|rename
argument_list|(
name|link
argument_list|,
name|file
argument_list|,
name|Rename
operator|.
name|OVERWRITE
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Renamed symlink to its target"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|unwrapException
argument_list|(
name|e
argument_list|)
operator|instanceof
name|FileAlreadyExistsException
argument_list|)
expr_stmt|;
block|}
comment|// Check the rename didn't happen
name|assertTrue
argument_list|(
name|isFile
argument_list|(
name|fc
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|isSymlink
argument_list|(
name|fc
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|file
argument_list|,
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Rename a symlink to the directory it links to */
DECL|method|testRenameSymlinkToDirItLinksTo ()
specifier|public
name|void
name|testRenameSymlinkToDirItLinksTo
parameter_list|()
throws|throws
name|IOException
block|{
comment|/* NB: The rename is not atomic, so dir is deleted before renaming      * linkToFile. In this interval linkToFile is dangling and local file       * system does not handle dangling links because File.exists returns       * false for dangling links. */
if|if
condition|(
literal|"file"
operator|.
name|equals
argument_list|(
name|getScheme
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"dir"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|mkdir
argument_list|(
name|dir
argument_list|,
name|FileContext
operator|.
name|DEFAULT_PERM
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|dir
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|rename
argument_list|(
name|link
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Renamed symlink to its target"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|unwrapException
argument_list|(
name|e
argument_list|)
operator|instanceof
name|FileAlreadyExistsException
argument_list|)
expr_stmt|;
block|}
comment|// Check the rename didn't happen
name|assertTrue
argument_list|(
name|isDir
argument_list|(
name|fc
argument_list|,
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|isSymlink
argument_list|(
name|fc
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|dir
argument_list|,
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|rename
argument_list|(
name|link
argument_list|,
name|dir
argument_list|,
name|Rename
operator|.
name|OVERWRITE
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Renamed symlink to its target"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|assertTrue
argument_list|(
name|unwrapException
argument_list|(
name|e
argument_list|)
operator|instanceof
name|FileAlreadyExistsException
argument_list|)
expr_stmt|;
block|}
comment|// Check the rename didn't happen
name|assertTrue
argument_list|(
name|isDir
argument_list|(
name|fc
argument_list|,
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|isSymlink
argument_list|(
name|fc
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|dir
argument_list|,
name|fc
operator|.
name|getLinkTarget
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test rename the symlink's target */
DECL|method|testRenameLinkTarget ()
specifier|public
name|void
name|testRenameLinkTarget
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|fileNew
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"fileNew"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|rename
argument_list|(
name|file
argument_list|,
name|fileNew
argument_list|,
name|Rename
operator|.
name|OVERWRITE
argument_list|)
expr_stmt|;
try|try
block|{
name|readFile
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Link should be dangling"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|x
parameter_list|)
block|{
comment|// Expected
block|}
name|fc
operator|.
name|rename
argument_list|(
name|fileNew
argument_list|,
name|file
argument_list|,
name|Rename
operator|.
name|OVERWRITE
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|link
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test rename a file to path with destination that has symlink parent */
DECL|method|testRenameFileWithDestParentSymlink ()
specifier|public
name|void
name|testRenameFileWithDestParentSymlink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"link"
argument_list|)
decl_stmt|;
name|Path
name|file1
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file1"
argument_list|)
decl_stmt|;
name|Path
name|file2
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file2"
argument_list|)
decl_stmt|;
name|Path
name|file3
init|=
operator|new
name|Path
argument_list|(
name|link
argument_list|,
literal|"file3"
argument_list|)
decl_stmt|;
name|Path
name|dir2
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|)
decl_stmt|;
comment|// Renaming /dir1/file1 to non-existant file /dir1/link/file3 is OK
comment|// if link points to a directory...
name|fc
operator|.
name|createSymlink
argument_list|(
name|dir2
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|createAndWriteFile
argument_list|(
name|file1
argument_list|)
expr_stmt|;
name|fc
operator|.
name|rename
argument_list|(
name|file1
argument_list|,
name|file3
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|file1
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|file3
argument_list|)
argument_list|)
expr_stmt|;
name|fc
operator|.
name|rename
argument_list|(
name|file3
argument_list|,
name|file1
argument_list|)
expr_stmt|;
comment|// But fails if link is dangling...
name|fc
operator|.
name|delete
argument_list|(
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file2
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|rename
argument_list|(
name|file1
argument_list|,
name|file3
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Expected
name|assertTrue
argument_list|(
name|unwrapException
argument_list|(
name|e
argument_list|)
operator|instanceof
name|FileNotFoundException
argument_list|)
expr_stmt|;
block|}
comment|// And if link points to a file...
name|createAndWriteFile
argument_list|(
name|file2
argument_list|)
expr_stmt|;
try|try
block|{
name|fc
operator|.
name|rename
argument_list|(
name|file1
argument_list|,
name|file3
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// Expected
name|assertTrue
argument_list|(
name|unwrapException
argument_list|(
name|e
argument_list|)
operator|instanceof
name|ParentNotDirectoryException
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
comment|/**    * Create, write, read, append, rename, get the block locations,    * checksums, and delete a file using a path with a symlink as an    * intermediate path component where the link target was specified    * using an absolute path. Rename is covered in more depth below.    */
DECL|method|testAccessFileViaInterSymlinkAbsTarget ()
specifier|public
name|void
name|testAccessFileViaInterSymlinkAbsTarget
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|baseDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|fileNew
init|=
operator|new
name|Path
argument_list|(
name|baseDir
argument_list|,
literal|"fileNew"
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|Path
name|fileViaLink
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|fileNewViaLink
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"fileNew"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|baseDir
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|createAndWriteFile
argument_list|(
name|fileViaLink
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|fileViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|isFile
argument_list|(
name|fc
argument_list|,
name|fileViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|isDir
argument_list|(
name|fc
argument_list|,
name|fileViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|fileViaLink
argument_list|)
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|isDir
argument_list|(
name|fc
argument_list|,
name|fileViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|file
argument_list|)
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|fileViaLink
argument_list|)
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|fileViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|fileViaLink
argument_list|)
expr_stmt|;
name|appendToFile
argument_list|(
name|fileViaLink
argument_list|)
expr_stmt|;
name|fc
operator|.
name|rename
argument_list|(
name|fileViaLink
argument_list|,
name|fileNewViaLink
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|fileViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|fileNewViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|fileNewViaLink
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fc
operator|.
name|getFileBlockLocations
argument_list|(
name|fileNew
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|.
name|length
argument_list|,
name|fc
operator|.
name|getFileBlockLocations
argument_list|(
name|fileNewViaLink
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fc
operator|.
name|getFileChecksum
argument_list|(
name|fileNew
argument_list|)
argument_list|,
name|fc
operator|.
name|getFileChecksum
argument_list|(
name|fileNewViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|fc
operator|.
name|delete
argument_list|(
name|fileNewViaLink
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|fileNewViaLink
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/**    * Operate on a file using a path with an intermediate symlink where    * the link target was specified as a fully qualified path.    */
DECL|method|testAccessFileViaInterSymlinkQualTarget ()
specifier|public
name|void
name|testAccessFileViaInterSymlinkQualTarget
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|baseDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|fileNew
init|=
operator|new
name|Path
argument_list|(
name|baseDir
argument_list|,
literal|"fileNew"
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|Path
name|fileViaLink
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|fileNewViaLink
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"fileNew"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|fc
operator|.
name|makeQualified
argument_list|(
name|baseDir
argument_list|)
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|createAndWriteFile
argument_list|(
name|fileViaLink
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|file
argument_list|)
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|fileViaLink
argument_list|)
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|fileViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|readFile
argument_list|(
name|fileViaLink
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/**    * Operate on a file using a path with an intermediate symlink where    * the link target was specified as a relative path.    */
DECL|method|testAccessFileViaInterSymlinkRelTarget ()
specifier|public
name|void
name|testAccessFileViaInterSymlinkRelTarget
parameter_list|()
throws|throws
name|IOException
block|{
name|assumeTrue
argument_list|(
operator|!
literal|"file"
operator|.
name|equals
argument_list|(
name|getScheme
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|baseDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"dir"
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|dir
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|Path
name|fileViaLink
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|mkdir
argument_list|(
name|dir
argument_list|,
name|FileContext
operator|.
name|DEFAULT_PERM
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
operator|new
name|Path
argument_list|(
literal|"dir"
argument_list|)
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|createAndWriteFile
argument_list|(
name|fileViaLink
argument_list|)
expr_stmt|;
comment|// Note that getFileStatus returns fully qualified paths even
comment|// when called on an absolute path.
name|assertEquals
argument_list|(
name|fc
operator|.
name|makeQualified
argument_list|(
name|file
argument_list|)
argument_list|,
name|fc
operator|.
name|getFileStatus
argument_list|(
name|file
argument_list|)
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
comment|// In each case getFileLinkStatus returns the same FileStatus
comment|// as getFileStatus since we're not calling it on a link and
comment|// FileStatus objects are compared by Path.
name|assertEquals
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|file
argument_list|)
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|fileViaLink
argument_list|)
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|fileViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|fileViaLink
argument_list|)
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|file
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** Test create, list, and delete a directory through a symlink */
DECL|method|testAccessDirViaSymlink ()
specifier|public
name|void
name|testAccessDirViaSymlink
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|baseDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|dir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"dir"
argument_list|)
decl_stmt|;
name|Path
name|linkToDir
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir2
argument_list|()
argument_list|,
literal|"linkToDir"
argument_list|)
decl_stmt|;
name|Path
name|dirViaLink
init|=
operator|new
name|Path
argument_list|(
name|linkToDir
argument_list|,
literal|"dir"
argument_list|)
decl_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|baseDir
argument_list|,
name|linkToDir
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fc
operator|.
name|mkdir
argument_list|(
name|dirViaLink
argument_list|,
name|FileContext
operator|.
name|DEFAULT_PERM
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fc
operator|.
name|getFileStatus
argument_list|(
name|dirViaLink
argument_list|)
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|stats
init|=
name|fc
operator|.
name|util
argument_list|()
operator|.
name|listStatus
argument_list|(
name|dirViaLink
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|stats
operator|.
name|length
argument_list|)
expr_stmt|;
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|statsItor
init|=
name|fc
operator|.
name|listStatus
argument_list|(
name|dirViaLink
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|statsItor
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|fc
operator|.
name|delete
argument_list|(
name|dirViaLink
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|dirViaLink
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|exists
argument_list|(
name|fc
argument_list|,
name|dir
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
comment|/** setTimes affects the target not the link */
DECL|method|testSetTimes ()
specifier|public
name|void
name|testSetTimes
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"file"
argument_list|)
decl_stmt|;
name|Path
name|link
init|=
operator|new
name|Path
argument_list|(
name|testBaseDir1
argument_list|()
argument_list|,
literal|"linkToFile"
argument_list|)
decl_stmt|;
name|createAndWriteFile
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|fc
operator|.
name|createSymlink
argument_list|(
name|file
argument_list|,
name|link
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|long
name|at
init|=
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|link
argument_list|)
operator|.
name|getAccessTime
argument_list|()
decl_stmt|;
name|fc
operator|.
name|setTimes
argument_list|(
name|link
argument_list|,
literal|2L
argument_list|,
literal|3L
argument_list|)
expr_stmt|;
comment|// NB: local file systems don't implement setTimes
if|if
condition|(
operator|!
literal|"file"
operator|.
name|equals
argument_list|(
name|getScheme
argument_list|()
argument_list|)
condition|)
block|{
name|assertEquals
argument_list|(
name|at
argument_list|,
name|fc
operator|.
name|getFileLinkStatus
argument_list|(
name|link
argument_list|)
operator|.
name|getAccessTime
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|fc
operator|.
name|getFileStatus
argument_list|(
name|file
argument_list|)
operator|.
name|getAccessTime
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|fc
operator|.
name|getFileStatus
argument_list|(
name|file
argument_list|)
operator|.
name|getModificationTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

