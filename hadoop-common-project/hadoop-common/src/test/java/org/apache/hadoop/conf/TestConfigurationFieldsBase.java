begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.conf
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Ignore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNotNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNull
import|;
end_import

begin_comment
comment|/**  * Base class for comparing fields in one or more Configuration classes  * against a corresponding .xml file.  Usage is intended as follows:  *<p></p>  *<ol>  *<li> Create a subclass to TestConfigurationFieldsBase  *<li> Define<code>initializeMemberVariables</code> method in the  *      subclass.  In this class, do the following:  *<p></p>  *<ol>  *<li><b>Required</b> Set the variable<code>xmlFilename</code> to  *        the appropriate xml definition file  *<li><b>Required</b> Set the variable<code>configurationClasses</code>  *        to an array of the classes which define the constants used by the  *        code corresponding to the xml files  *<li><b>Optional</b> Set<code>errorIfMissingConfigProps</code> if the  *        subclass should throw an error in the method  *<code>testCompareXmlAgainstConfigurationClass</code>  *<li><b>Optional</b> Set<code>errorIfMissingXmlProps</code> if the  *        subclass should throw an error in the method  *<code>testCompareConfigurationClassAgainstXml</code>  *<li><b>Optional</b> Instantiate and populate strings into one or  *        more of the following variables:  *<br><code>configurationPropsToSkipCompare</code>  *<br><code>configurationPrefixToSkipCompare</code>  *<br><code>xmlPropsToSkipCompare</code>  *<br><code>xmlPrefixToSkipCompare</code>  *<br>  *        in order to get comparisons clean  *</ol>  *</ol>  *<p></p>  * The tests to do class-to-file and file-to-class should automatically  * run.  This class (and its subclasses) are mostly not intended to be  * overridden, but to do a very specific form of comparison testing.  */
end_comment

begin_class
annotation|@
name|Ignore
DECL|class|TestConfigurationFieldsBase
specifier|public
specifier|abstract
class|class
name|TestConfigurationFieldsBase
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TestConfigurationFieldsBase
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|LOG_CONFIG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG_CONFIG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
literal|"org.apache.hadoop.conf.TestConfigurationFieldsBase.config"
argument_list|)
decl_stmt|;
DECL|field|LOG_XML
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG_XML
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
literal|"org.apache.hadoop.conf.TestConfigurationFieldsBase.xml"
argument_list|)
decl_stmt|;
comment|/**    * Member variable for storing xml filename.    */
DECL|field|xmlFilename
specifier|protected
name|String
name|xmlFilename
init|=
literal|null
decl_stmt|;
comment|/**    * Member variable for storing all related Configuration classes.    */
DECL|field|configurationClasses
specifier|protected
name|Class
index|[]
name|configurationClasses
init|=
literal|null
decl_stmt|;
comment|/**    * Throw error during comparison if missing configuration properties.    * Intended to be set by subclass.    */
DECL|field|errorIfMissingConfigProps
specifier|protected
name|boolean
name|errorIfMissingConfigProps
init|=
literal|false
decl_stmt|;
comment|/**    * Throw error during comparison if missing xml properties.  Intended    * to be set by subclass.    */
DECL|field|errorIfMissingXmlProps
specifier|protected
name|boolean
name|errorIfMissingXmlProps
init|=
literal|false
decl_stmt|;
comment|/**    * Set of properties to skip extracting (and thus comparing later) in     * {@link #extractMemberVariablesFromConfigurationFields(Field[])}.    */
DECL|field|configurationPropsToSkipCompare
specifier|protected
name|Set
argument_list|<
name|String
argument_list|>
name|configurationPropsToSkipCompare
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Set of property prefixes to skip extracting (and thus comparing later)    * in * extractMemberVariablesFromConfigurationFields.    */
DECL|field|configurationPrefixToSkipCompare
specifier|protected
name|Set
argument_list|<
name|String
argument_list|>
name|configurationPrefixToSkipCompare
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Set of properties to skip extracting (and thus comparing later) in     * extractPropertiesFromXml.    */
DECL|field|xmlPropsToSkipCompare
specifier|protected
name|Set
argument_list|<
name|String
argument_list|>
name|xmlPropsToSkipCompare
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Set of property prefixes to skip extracting (and thus comparing later)    * in extractPropertiesFromXml.    */
DECL|field|xmlPrefixToSkipCompare
specifier|protected
name|Set
argument_list|<
name|String
argument_list|>
name|xmlPrefixToSkipCompare
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Member variable to store Configuration variables for later comparison.    */
DECL|field|configurationMemberVariables
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|configurationMemberVariables
init|=
literal|null
decl_stmt|;
comment|/**    * Member variable to store Configuration variables for later reference.    */
DECL|field|configurationDefaultVariables
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|configurationDefaultVariables
init|=
literal|null
decl_stmt|;
comment|/**    * Member variable to store XML properties for later comparison.    */
DECL|field|xmlKeyValueMap
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|xmlKeyValueMap
init|=
literal|null
decl_stmt|;
comment|/**    * Member variable to store Configuration variables that are not in the    * corresponding XML file.    */
DECL|field|configurationFieldsMissingInXmlFile
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|configurationFieldsMissingInXmlFile
init|=
literal|null
decl_stmt|;
comment|/**    * Member variable to store XML variables that are not in the    * corresponding Configuration class(es).    */
DECL|field|xmlFieldsMissingInConfiguration
specifier|private
name|Set
argument_list|<
name|String
argument_list|>
name|xmlFieldsMissingInConfiguration
init|=
literal|null
decl_stmt|;
comment|/**    * A set of strings used to check for collision of default values.    * For each of the set's strings, the default values containing that string    * in their name should not coincide.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"checkstyle:visibilitymodifier"
argument_list|)
DECL|field|filtersForDefaultValueCollisionCheck
specifier|protected
name|Set
argument_list|<
name|String
argument_list|>
name|filtersForDefaultValueCollisionCheck
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Abstract method to be used by subclasses for initializing base    * members.    */
DECL|method|initializeMemberVariables ()
specifier|public
specifier|abstract
name|void
name|initializeMemberVariables
parameter_list|()
function_decl|;
comment|/**    * Utility function to extract&quot;public static final&quot; member    * variables from a Configuration type class.    *    * @param fields The class member variables    * @return HashMap containing (StringValue, MemberVariableName) entries    */
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
DECL|method|extractMemberVariablesFromConfigurationFields (Field[] fields)
name|extractMemberVariablesFromConfigurationFields
parameter_list|(
name|Field
index|[]
name|fields
parameter_list|)
block|{
comment|// Sanity Check
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|retVal
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Setup regexp for valid properties
name|String
name|propRegex
init|=
literal|"^[A-Za-z][A-Za-z0-9_-]+(\\.[A-Za-z0-9_-]+)+$"
decl_stmt|;
name|Pattern
name|p
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|propRegex
argument_list|)
decl_stmt|;
comment|// Iterate through class member variables
name|String
name|value
decl_stmt|;
for|for
control|(
name|Field
name|f
range|:
name|fields
control|)
block|{
name|LOG_CONFIG
operator|.
name|debug
argument_list|(
literal|"Field: {}"
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|// Filter out anything that isn't "public static final"
if|if
condition|(
operator|!
name|Modifier
operator|.
name|isStatic
argument_list|(
name|f
operator|.
name|getModifiers
argument_list|()
argument_list|)
operator|||
operator|!
name|Modifier
operator|.
name|isPublic
argument_list|(
name|f
operator|.
name|getModifiers
argument_list|()
argument_list|)
operator|||
operator|!
name|Modifier
operator|.
name|isFinal
argument_list|(
name|f
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// Filter out anything that isn't a string.  int/float are generally
comment|// default values
if|if
condition|(
operator|!
name|f
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"java.lang.String"
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// filter out default-value fields
if|if
condition|(
name|isFieldADefaultValue
argument_list|(
name|f
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// Convert found member into String
try|try
block|{
name|value
operator|=
operator|(
name|String
operator|)
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|iaException
parameter_list|)
block|{
continue|continue;
block|}
name|LOG_CONFIG
operator|.
name|debug
argument_list|(
literal|"  Value: {}"
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|// Special Case: Detect and ignore partial properties (ending in x)
comment|//               or file properties (ending in .xml)
if|if
condition|(
name|value
operator|.
name|endsWith
argument_list|(
literal|".xml"
argument_list|)
operator|||
name|value
operator|.
name|endsWith
argument_list|(
literal|"."
argument_list|)
operator|||
name|value
operator|.
name|endsWith
argument_list|(
literal|"-"
argument_list|)
condition|)
continue|continue;
comment|// Ignore known configuration props
if|if
condition|(
name|configurationPropsToSkipCompare
operator|.
name|contains
argument_list|(
name|value
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// Ignore known configuration prefixes
name|boolean
name|skipPrefix
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|cfgPrefix
range|:
name|configurationPrefixToSkipCompare
control|)
block|{
if|if
condition|(
name|value
operator|.
name|startsWith
argument_list|(
name|cfgPrefix
argument_list|)
condition|)
block|{
name|skipPrefix
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|skipPrefix
condition|)
block|{
continue|continue;
block|}
comment|// Positive Filter: Look only for property values.  Expect it to look
comment|//                  something like: blah.blah2(.blah3.blah4...)
name|Matcher
name|m
init|=
name|p
operator|.
name|matcher
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
name|LOG_CONFIG
operator|.
name|debug
argument_list|(
literal|"  Passes Regex: false"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|LOG_CONFIG
operator|.
name|debug
argument_list|(
literal|"  Passes Regex: true"
argument_list|)
expr_stmt|;
comment|// Save member variable/value as hash
if|if
condition|(
operator|!
name|retVal
operator|.
name|containsKey
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|retVal
operator|.
name|put
argument_list|(
name|value
argument_list|,
name|f
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG_CONFIG
operator|.
name|debug
argument_list|(
literal|"ERROR: Already found key for property "
operator|+
name|value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|retVal
return|;
block|}
comment|/**    * Pull properties and values from filename.    *    * @param filename XML filename    * @return HashMap containing&lt;Property,Value&gt; entries from XML file    */
DECL|method|extractPropertiesFromXml (String filename)
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|extractPropertiesFromXml
parameter_list|(
name|String
name|filename
parameter_list|)
block|{
if|if
condition|(
name|filename
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// Iterate through XML file for name/value pairs
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|conf
operator|.
name|setAllowNullValueProperties
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|conf
operator|.
name|addResource
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|retVal
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|kvItr
init|=
name|conf
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|kvItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
init|=
name|kvItr
operator|.
name|next
argument_list|()
decl_stmt|;
name|String
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
comment|// Ignore known xml props
if|if
condition|(
name|xmlPropsToSkipCompare
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|LOG_XML
operator|.
name|debug
argument_list|(
literal|"  Skipping Full Key: {}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// Ignore known xml prefixes
if|if
condition|(
name|xmlPrefixToSkipCompare
operator|.
name|stream
argument_list|()
operator|.
name|anyMatch
argument_list|(
name|key
operator|::
name|startsWith
argument_list|)
condition|)
block|{
name|LOG_XML
operator|.
name|debug
argument_list|(
literal|"  Skipping Prefix Key: "
operator|+
name|key
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|conf
operator|.
name|onlyKeyExists
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|retVal
operator|.
name|put
argument_list|(
name|key
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|LOG_XML
operator|.
name|debug
argument_list|(
literal|"  XML Key,Null Value: "
operator|+
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|conf
operator|.
name|get
argument_list|(
name|key
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|retVal
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|LOG_XML
operator|.
name|debug
argument_list|(
literal|"  XML Key,Valid Value: "
operator|+
name|key
argument_list|)
expr_stmt|;
block|}
block|}
name|kvItr
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
return|return
name|retVal
return|;
block|}
comment|/**    * Test if a field is a default value of another property by    * checking if its name starts with "DEFAULT_" or ends with    * "_DEFAULT".    * @param field the field to check    */
DECL|method|isFieldADefaultValue (Field field)
specifier|private
specifier|static
name|boolean
name|isFieldADefaultValue
parameter_list|(
name|Field
name|field
parameter_list|)
block|{
return|return
name|field
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"DEFAULT_"
argument_list|)
operator|||
name|field
operator|.
name|getName
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|"_DEFAULT"
argument_list|)
return|;
block|}
comment|/**    * Utility function to extract&quot;public static final&quot; default    * member variables from a Configuration type class.    *    * @param fields The class member variables    * @return HashMap containing (DefaultVariableName, DefaultValue) entries    */
specifier|private
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
DECL|method|extractDefaultVariablesFromConfigurationFields (Field[] fields)
name|extractDefaultVariablesFromConfigurationFields
parameter_list|(
name|Field
index|[]
name|fields
parameter_list|)
block|{
comment|// Sanity Check
if|if
condition|(
name|fields
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|retVal
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// Setup regexp for valid properties
name|String
name|propRegex
init|=
literal|"^[A-Za-z][A-Za-z0-9_-]+(\\.[A-Za-z0-9_-]+)+$"
decl_stmt|;
name|Pattern
name|p
init|=
name|Pattern
operator|.
name|compile
argument_list|(
name|propRegex
argument_list|)
decl_stmt|;
comment|// Iterate through class member variables
name|int
name|totalFields
init|=
literal|0
decl_stmt|;
name|String
name|value
decl_stmt|;
for|for
control|(
name|Field
name|f
range|:
name|fields
control|)
block|{
comment|// Filter out anything that isn't "public static final"
if|if
condition|(
operator|!
name|Modifier
operator|.
name|isStatic
argument_list|(
name|f
operator|.
name|getModifiers
argument_list|()
argument_list|)
operator|||
operator|!
name|Modifier
operator|.
name|isPublic
argument_list|(
name|f
operator|.
name|getModifiers
argument_list|()
argument_list|)
operator|||
operator|!
name|Modifier
operator|.
name|isFinal
argument_list|(
name|f
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// Special: Stuff any property beginning with "DEFAULT_" into a
comment|// different hash for later processing
if|if
condition|(
name|isFieldADefaultValue
argument_list|(
name|f
argument_list|)
condition|)
block|{
if|if
condition|(
name|retVal
operator|.
name|containsKey
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
try|try
block|{
if|if
condition|(
name|f
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"java.lang.String"
argument_list|)
condition|)
block|{
name|String
name|sValue
init|=
operator|(
name|String
operator|)
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|retVal
operator|.
name|put
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|sValue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"short"
argument_list|)
condition|)
block|{
name|short
name|shValue
init|=
operator|(
name|short
operator|)
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|retVal
operator|.
name|put
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|shValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"int"
argument_list|)
condition|)
block|{
name|int
name|iValue
init|=
operator|(
name|int
operator|)
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|retVal
operator|.
name|put
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|iValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"long"
argument_list|)
condition|)
block|{
name|long
name|lValue
init|=
operator|(
name|long
operator|)
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|retVal
operator|.
name|put
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|Long
operator|.
name|toString
argument_list|(
name|lValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"float"
argument_list|)
condition|)
block|{
name|float
name|fValue
init|=
operator|(
name|float
operator|)
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|retVal
operator|.
name|put
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|Float
operator|.
name|toString
argument_list|(
name|fValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"double"
argument_list|)
condition|)
block|{
name|double
name|dValue
init|=
operator|(
name|double
operator|)
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|retVal
operator|.
name|put
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|Double
operator|.
name|toString
argument_list|(
name|dValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"boolean"
argument_list|)
condition|)
block|{
name|boolean
name|bValue
init|=
operator|(
name|boolean
operator|)
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|retVal
operator|.
name|put
argument_list|(
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|bValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Config variable {} has unknown type {}"
argument_list|,
name|f
operator|.
name|getName
argument_list|()
argument_list|,
name|f
operator|.
name|getType
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|iaException
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"{}"
argument_list|,
name|f
argument_list|,
name|iaException
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|retVal
return|;
block|}
comment|/**    * Perform set difference operation on keyMap2 from keyMap1.    *    * @param keyMap1 The initial set    * @param keyMap2 The set to subtract    * @return Returns set operation keyMap1-keyMap2    */
DECL|method|compareConfigurationToXmlFields ( Map<String,String> keyMap1, Map<String,String> keyMap2)
specifier|private
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|compareConfigurationToXmlFields
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|keyMap1
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|keyMap2
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|retVal
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|keyMap1
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|retVal
operator|.
name|removeAll
argument_list|(
name|keyMap2
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|retVal
return|;
block|}
comment|/**    * Initialize the four variables corresponding the Configuration    * class and the XML properties file.    */
annotation|@
name|Before
DECL|method|setupTestConfigurationFields ()
specifier|public
name|void
name|setupTestConfigurationFields
parameter_list|()
throws|throws
name|Exception
block|{
name|initializeMemberVariables
argument_list|()
expr_stmt|;
comment|// Error if subclass hasn't set class members
name|assertNotNull
argument_list|(
name|xmlFilename
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|configurationClasses
argument_list|)
expr_stmt|;
comment|// Create class member/value map
name|configurationMemberVariables
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|LOG_CONFIG
operator|.
name|debug
argument_list|(
literal|"Reading configuration classes\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|Class
name|c
range|:
name|configurationClasses
control|)
block|{
name|Field
index|[]
name|fields
init|=
name|c
operator|.
name|getDeclaredFields
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|memberMap
init|=
name|extractMemberVariablesFromConfigurationFields
argument_list|(
name|fields
argument_list|)
decl_stmt|;
if|if
condition|(
name|memberMap
operator|!=
literal|null
condition|)
block|{
name|configurationMemberVariables
operator|.
name|putAll
argument_list|(
name|memberMap
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG_CONFIG
operator|.
name|debug
argument_list|(
literal|"\n=====\n"
argument_list|)
expr_stmt|;
comment|// Create XML key/value map
name|LOG_XML
operator|.
name|debug
argument_list|(
literal|"Reading XML property files\n"
argument_list|)
expr_stmt|;
name|xmlKeyValueMap
operator|=
name|extractPropertiesFromXml
argument_list|(
name|xmlFilename
argument_list|)
expr_stmt|;
comment|// Remove hadoop property set in ozone-default.xml
name|xmlKeyValueMap
operator|.
name|remove
argument_list|(
literal|"hadoop.custom.tags"
argument_list|)
expr_stmt|;
name|LOG_XML
operator|.
name|debug
argument_list|(
literal|"\n=====\n"
argument_list|)
expr_stmt|;
comment|// Create default configuration variable key/value map
name|LOG
operator|.
name|debug
argument_list|(
literal|"Reading Config property files for defaults\n"
argument_list|)
expr_stmt|;
name|configurationDefaultVariables
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|Arrays
operator|.
name|stream
argument_list|(
name|configurationClasses
argument_list|)
operator|.
name|map
argument_list|(
name|Class
operator|::
name|getDeclaredFields
argument_list|)
operator|.
name|map
argument_list|(
name|this
operator|::
name|extractDefaultVariablesFromConfigurationFields
argument_list|)
operator|.
name|filter
argument_list|(
name|Objects
operator|::
name|nonNull
argument_list|)
operator|.
name|forEach
argument_list|(
name|map
lambda|->
name|configurationDefaultVariables
operator|.
name|putAll
argument_list|(
name|map
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"\n=====\n"
argument_list|)
expr_stmt|;
comment|// Find class members not in the XML file
name|configurationFieldsMissingInXmlFile
operator|=
name|compareConfigurationToXmlFields
argument_list|(
name|configurationMemberVariables
argument_list|,
name|xmlKeyValueMap
argument_list|)
expr_stmt|;
comment|// Find XML properties not in the class
name|xmlFieldsMissingInConfiguration
operator|=
name|compareConfigurationToXmlFields
argument_list|(
name|xmlKeyValueMap
argument_list|,
name|configurationMemberVariables
argument_list|)
expr_stmt|;
block|}
comment|/**    * Compares the properties that are in the Configuration class, but not    * in the XML properties file.    */
annotation|@
name|Test
DECL|method|testCompareConfigurationClassAgainstXml ()
specifier|public
name|void
name|testCompareConfigurationClassAgainstXml
parameter_list|()
block|{
comment|// Error if subclass hasn't set class members
name|assertNotNull
argument_list|(
name|xmlFilename
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|configurationClasses
argument_list|)
expr_stmt|;
specifier|final
name|int
name|missingXmlSize
init|=
name|configurationFieldsMissingInXmlFile
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|Class
name|c
range|:
name|configurationClasses
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
name|c
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"({} member variables)\n"
argument_list|,
name|configurationMemberVariables
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|StringBuilder
name|xmlErrorMsg
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|Class
name|c
range|:
name|configurationClasses
control|)
block|{
name|xmlErrorMsg
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|xmlErrorMsg
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|xmlErrorMsg
operator|.
name|append
argument_list|(
literal|"has "
argument_list|)
expr_stmt|;
name|xmlErrorMsg
operator|.
name|append
argument_list|(
name|missingXmlSize
argument_list|)
expr_stmt|;
name|xmlErrorMsg
operator|.
name|append
argument_list|(
literal|" variables missing in "
argument_list|)
expr_stmt|;
name|xmlErrorMsg
operator|.
name|append
argument_list|(
name|xmlFilename
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|error
argument_list|(
name|xmlErrorMsg
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|missingXmlSize
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"  (None)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|appendMissingEntries
argument_list|(
name|xmlErrorMsg
argument_list|,
name|configurationFieldsMissingInXmlFile
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"\n=====\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorIfMissingXmlProps
condition|)
block|{
name|assertEquals
argument_list|(
name|xmlErrorMsg
operator|.
name|toString
argument_list|()
argument_list|,
literal|0
argument_list|,
name|missingXmlSize
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Take a set of missing entries, sort, append to the string builder    * and also log at INFO.    * @param sb string builder    * @param missing set of missing entries    */
DECL|method|appendMissingEntries (StringBuilder sb, Set<String> missing)
specifier|private
name|void
name|appendMissingEntries
parameter_list|(
name|StringBuilder
name|sb
parameter_list|,
name|Set
argument_list|<
name|String
argument_list|>
name|missing
parameter_list|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" Entries: "
argument_list|)
expr_stmt|;
operator|new
name|TreeSet
argument_list|<>
argument_list|(
name|missing
argument_list|)
operator|.
name|forEach
argument_list|(
parameter_list|(
name|s
parameter_list|)
lambda|->
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"  {}"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"  "
argument_list|)
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**    * Compares the properties that are in the XML properties file, but not    * in the Configuration class.    */
annotation|@
name|Test
DECL|method|testCompareXmlAgainstConfigurationClass ()
specifier|public
name|void
name|testCompareXmlAgainstConfigurationClass
parameter_list|()
block|{
comment|// Error if subclass hasn't set class members
name|assertNotNull
argument_list|(
name|xmlFilename
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|configurationClasses
argument_list|)
expr_stmt|;
specifier|final
name|int
name|missingConfigSize
init|=
name|xmlFieldsMissingInConfiguration
operator|.
name|size
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"File {} ({} properties)"
argument_list|,
name|xmlFilename
argument_list|,
name|xmlKeyValueMap
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|StringBuilder
name|configErrorMsg
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|configErrorMsg
operator|.
name|append
argument_list|(
name|xmlFilename
argument_list|)
expr_stmt|;
name|configErrorMsg
operator|.
name|append
argument_list|(
literal|" has "
argument_list|)
expr_stmt|;
name|configErrorMsg
operator|.
name|append
argument_list|(
name|missingConfigSize
argument_list|)
expr_stmt|;
name|configErrorMsg
operator|.
name|append
argument_list|(
literal|" properties missing in"
argument_list|)
expr_stmt|;
name|Arrays
operator|.
name|stream
argument_list|(
name|configurationClasses
argument_list|)
operator|.
name|forEach
argument_list|(
name|c
lambda|->
name|configErrorMsg
operator|.
name|append
argument_list|(
literal|"  "
argument_list|)
operator|.
name|append
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
name|configErrorMsg
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|missingConfigSize
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"  (None)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|appendMissingEntries
argument_list|(
name|configErrorMsg
argument_list|,
name|xmlFieldsMissingInConfiguration
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"\n=====\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorIfMissingConfigProps
condition|)
block|{
name|assertEquals
argument_list|(
name|configErrorMsg
operator|.
name|toString
argument_list|()
argument_list|,
literal|0
argument_list|,
name|missingConfigSize
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * For each property in the XML file, verify that the value matches    * up to the default if one exists.    */
annotation|@
name|Test
DECL|method|testXmlAgainstDefaultValuesInConfigurationClass ()
specifier|public
name|void
name|testXmlAgainstDefaultValuesInConfigurationClass
parameter_list|()
block|{
comment|// Error if subclass hasn't set class members
name|assertNotNull
argument_list|(
name|xmlFilename
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|configurationMemberVariables
argument_list|)
expr_stmt|;
name|assertNotNull
argument_list|(
name|configurationDefaultVariables
argument_list|)
expr_stmt|;
name|TreeSet
argument_list|<
name|String
argument_list|>
name|xmlPropertiesWithEmptyValue
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
name|TreeSet
argument_list|<
name|String
argument_list|>
name|configPropertiesWithNoDefaultConfig
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|xmlPropertiesMatchingConfigDefault
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Ugly solution.  Should have tuple-based solution.
name|HashMap
argument_list|<
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|mismatchingXmlConfig
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|xEntry
range|:
name|xmlKeyValueMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|xmlProperty
init|=
name|xEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|String
name|xmlDefaultValue
init|=
name|xEntry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|configProperty
init|=
name|configurationMemberVariables
operator|.
name|get
argument_list|(
name|xmlProperty
argument_list|)
decl_stmt|;
if|if
condition|(
name|configProperty
operator|!=
literal|null
condition|)
block|{
name|String
name|defaultConfigName
init|=
literal|null
decl_stmt|;
name|String
name|defaultConfigValue
init|=
literal|null
decl_stmt|;
comment|// Type 1: Prepend DEFAULT_
name|String
name|defaultNameCheck1
init|=
literal|"DEFAULT_"
operator|+
name|configProperty
decl_stmt|;
name|String
name|defaultValueCheck1
init|=
name|configurationDefaultVariables
operator|.
name|get
argument_list|(
name|defaultNameCheck1
argument_list|)
decl_stmt|;
comment|// Type 2: Swap _KEY suffix with _DEFAULT suffix
name|String
name|defaultNameCheck2
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|configProperty
operator|.
name|endsWith
argument_list|(
literal|"_KEY"
argument_list|)
condition|)
block|{
name|defaultNameCheck2
operator|=
name|configProperty
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|configProperty
operator|.
name|length
argument_list|()
operator|-
literal|4
argument_list|)
operator|+
literal|"_DEFAULT"
expr_stmt|;
block|}
name|String
name|defaultValueCheck2
init|=
name|configurationDefaultVariables
operator|.
name|get
argument_list|(
name|defaultNameCheck2
argument_list|)
decl_stmt|;
comment|// Type Last: Append _DEFAULT suffix
name|String
name|defaultNameCheck3
init|=
name|configProperty
operator|+
literal|"_DEFAULT"
decl_stmt|;
name|String
name|defaultValueCheck3
init|=
name|configurationDefaultVariables
operator|.
name|get
argument_list|(
name|defaultNameCheck3
argument_list|)
decl_stmt|;
comment|// Pick the default value that exists
if|if
condition|(
name|defaultValueCheck1
operator|!=
literal|null
condition|)
block|{
name|defaultConfigName
operator|=
name|defaultNameCheck1
expr_stmt|;
name|defaultConfigValue
operator|=
name|defaultValueCheck1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defaultValueCheck2
operator|!=
literal|null
condition|)
block|{
name|defaultConfigName
operator|=
name|defaultNameCheck2
expr_stmt|;
name|defaultConfigValue
operator|=
name|defaultValueCheck2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defaultValueCheck3
operator|!=
literal|null
condition|)
block|{
name|defaultConfigName
operator|=
name|defaultNameCheck3
expr_stmt|;
name|defaultConfigValue
operator|=
name|defaultValueCheck3
expr_stmt|;
block|}
if|if
condition|(
name|defaultConfigValue
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|xmlDefaultValue
operator|==
literal|null
condition|)
block|{
name|xmlPropertiesWithEmptyValue
operator|.
name|add
argument_list|(
name|xmlProperty
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|xmlDefaultValue
operator|.
name|equals
argument_list|(
name|defaultConfigValue
argument_list|)
condition|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|xmlEntry
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|xmlEntry
operator|.
name|put
argument_list|(
name|xmlProperty
argument_list|,
name|xmlDefaultValue
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|configEntry
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|configEntry
operator|.
name|put
argument_list|(
name|defaultConfigName
argument_list|,
name|defaultConfigValue
argument_list|)
expr_stmt|;
name|mismatchingXmlConfig
operator|.
name|put
argument_list|(
name|xmlEntry
argument_list|,
name|configEntry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xmlPropertiesMatchingConfigDefault
operator|.
name|put
argument_list|(
name|xmlProperty
argument_list|,
name|defaultConfigName
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|configPropertiesWithNoDefaultConfig
operator|.
name|add
argument_list|(
name|configProperty
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Print out any unknown mismatching XML value/Config default value
name|LOG
operator|.
name|info
argument_list|(
literal|"{} has {} properties that do not match the default Config value"
argument_list|,
name|xmlFilename
argument_list|,
name|mismatchingXmlConfig
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|mismatchingXmlConfig
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"  (None)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|,
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|xcEntry
range|:
name|mismatchingXmlConfig
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|xcEntry
operator|.
name|getKey
argument_list|()
operator|.
name|forEach
argument_list|(
parameter_list|(
name|key
parameter_list|,
name|value
parameter_list|)
lambda|->
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"XML Property: {}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"XML Value:    {}"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|xcEntry
operator|.
name|getValue
argument_list|()
operator|.
name|forEach
argument_list|(
parameter_list|(
name|key
parameter_list|,
name|value
parameter_list|)
lambda|->
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Config Name:  {}"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Config Value: {}"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|// Print out Config properties that have no corresponding DEFAULT_*
comment|// variable and cannot do any XML comparison (i.e. probably needs to
comment|// be checked by hand)
name|LOG
operator|.
name|info
argument_list|(
literal|"Configuration(s) have {} "
operator|+
literal|" properties with no corresponding default member variable.  These"
operator|+
literal|" will need to be verified manually."
argument_list|,
name|configPropertiesWithNoDefaultConfig
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|configPropertiesWithNoDefaultConfig
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"  (None)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|configPropertiesWithNoDefaultConfig
operator|.
name|forEach
argument_list|(
name|c
lambda|->
name|LOG
operator|.
name|info
argument_list|(
literal|" {}"
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|// MAYBE TODO Print out any known mismatching XML value/Config default
comment|// Print out XML properties that have empty values (i.e. should result
comment|// in code-based default)
name|LOG
operator|.
name|info
argument_list|(
literal|"{} has {} properties with empty values"
argument_list|,
name|xmlFilename
argument_list|,
name|xmlPropertiesWithEmptyValue
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmlPropertiesWithEmptyValue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"  (None)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xmlPropertiesWithEmptyValue
operator|.
name|forEach
argument_list|(
name|p
lambda|->
name|LOG
operator|.
name|info
argument_list|(
literal|"  {}"
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|// Print out any matching XML value/Config default value
name|LOG
operator|.
name|info
argument_list|(
literal|"{} has {} properties which match a corresponding Config variable"
argument_list|,
name|xmlFilename
argument_list|,
name|xmlPropertiesMatchingConfigDefault
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmlPropertiesMatchingConfigDefault
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"  (None)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xmlPropertiesMatchingConfigDefault
operator|.
name|forEach
argument_list|(
parameter_list|(
name|key
parameter_list|,
name|value
parameter_list|)
lambda|->
name|LOG
operator|.
name|info
argument_list|(
literal|"  {} / {}"
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"\n=====\n"
argument_list|)
expr_stmt|;
block|}
comment|/**    * For each specified string, get the default parameter values whose names    * contain the string. Then check whether any of these default values collide.    * This is, for example, useful to make sure there is no collision of default    * ports across different services.    */
annotation|@
name|Test
DECL|method|testDefaultValueCollision ()
specifier|public
name|void
name|testDefaultValueCollision
parameter_list|()
block|{
for|for
control|(
name|String
name|filter
range|:
name|filtersForDefaultValueCollisionCheck
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Checking if any of the default values whose name "
operator|+
literal|"contains string \"{}\" collide."
argument_list|,
name|filter
argument_list|)
expr_stmt|;
comment|// Map from filtered default value to name of the corresponding parameter.
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|filteredValues
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|valuesChecked
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|ent
range|:
name|configurationDefaultVariables
operator|.
name|entrySet
argument_list|()
control|)
block|{
comment|// Apply the name filter to the default parameters.
if|if
condition|(
name|ent
operator|.
name|getKey
argument_list|()
operator|.
name|contains
argument_list|(
name|filter
argument_list|)
condition|)
block|{
comment|// Check only for numerical values.
if|if
condition|(
name|StringUtils
operator|.
name|isNumeric
argument_list|(
name|ent
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|crtValue
init|=
name|filteredValues
operator|.
name|putIfAbsent
argument_list|(
name|ent
operator|.
name|getValue
argument_list|()
argument_list|,
name|ent
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
literal|"Parameters "
operator|+
name|ent
operator|.
name|getKey
argument_list|()
operator|+
literal|" and "
operator|+
name|crtValue
operator|+
literal|" are using the same default value!"
argument_list|,
name|crtValue
argument_list|)
expr_stmt|;
block|}
name|valuesChecked
operator|++
expr_stmt|;
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Checked {} default values for collision."
argument_list|,
name|valuesChecked
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

