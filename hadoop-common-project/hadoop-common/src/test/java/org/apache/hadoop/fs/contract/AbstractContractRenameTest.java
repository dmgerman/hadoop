begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *       http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.contract
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
operator|.
name|ContractTestUtils
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Test creating files, overwrite options&c  */
end_comment

begin_class
DECL|class|AbstractContractRenameTest
specifier|public
specifier|abstract
class|class
name|AbstractContractRenameTest
extends|extends
name|AbstractFSContractTestBase
block|{
annotation|@
name|Test
DECL|method|testRenameNewFileSameDir ()
specifier|public
name|void
name|testRenameNewFileSameDir
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"rename a file into a new file in the same directory"
argument_list|)
expr_stmt|;
name|Path
name|renameSrc
init|=
name|path
argument_list|(
literal|"rename_src"
argument_list|)
decl_stmt|;
name|Path
name|renameTarget
init|=
name|path
argument_list|(
literal|"rename_dest"
argument_list|)
decl_stmt|;
name|byte
index|[]
name|data
init|=
name|dataset
argument_list|(
literal|256
argument_list|,
literal|'a'
argument_list|,
literal|'z'
argument_list|)
decl_stmt|;
name|writeDataset
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|renameSrc
argument_list|,
name|data
argument_list|,
name|data
operator|.
name|length
argument_list|,
literal|1024
operator|*
literal|1024
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|boolean
name|rename
init|=
name|rename
argument_list|(
name|renameSrc
argument_list|,
name|renameTarget
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"rename("
operator|+
name|renameSrc
operator|+
literal|", "
operator|+
name|renameTarget
operator|+
literal|") returned false"
argument_list|,
name|rename
argument_list|)
expr_stmt|;
name|assertListStatusFinds
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|renameTarget
operator|.
name|getParent
argument_list|()
argument_list|,
name|renameTarget
argument_list|)
expr_stmt|;
name|verifyFileContents
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|renameTarget
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testRenameNonexistentFile ()
specifier|public
name|void
name|testRenameNonexistentFile
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"rename a file into a new file in the same directory"
argument_list|)
expr_stmt|;
name|Path
name|missing
init|=
name|path
argument_list|(
literal|"testRenameNonexistentFileSrc"
argument_list|)
decl_stmt|;
name|Path
name|target
init|=
name|path
argument_list|(
literal|"testRenameNonexistentFileDest"
argument_list|)
decl_stmt|;
name|boolean
name|renameReturnsFalseOnFailure
init|=
name|isSupported
argument_list|(
name|ContractOptions
operator|.
name|RENAME_RETURNS_FALSE_IF_SOURCE_MISSING
argument_list|)
decl_stmt|;
name|mkdirs
argument_list|(
name|missing
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|boolean
name|renamed
init|=
name|rename
argument_list|(
name|missing
argument_list|,
name|target
argument_list|)
decl_stmt|;
comment|//expected an exception
if|if
condition|(
operator|!
name|renameReturnsFalseOnFailure
condition|)
block|{
name|String
name|destDirLS
init|=
name|generateAndLogErrorListing
argument_list|(
name|missing
argument_list|,
name|target
argument_list|)
decl_stmt|;
name|fail
argument_list|(
literal|"expected rename("
operator|+
name|missing
operator|+
literal|", "
operator|+
name|target
operator|+
literal|" ) to fail,"
operator|+
literal|" got a result of "
operator|+
name|renamed
operator|+
literal|" and a destination directory of "
operator|+
name|destDirLS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// at least one FS only returns false here, if that is the case
comment|// warn but continue
name|getLog
argument_list|()
operator|.
name|warn
argument_list|(
literal|"Rename returned {} renaming a nonexistent file"
argument_list|,
name|renamed
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Renaming a missing file returned true"
argument_list|,
name|renamed
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
if|if
condition|(
name|renameReturnsFalseOnFailure
condition|)
block|{
name|ContractTestUtils
operator|.
name|fail
argument_list|(
literal|"Renaming a missing file unexpectedly threw an exception"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|handleExpectedException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|handleRelaxedException
argument_list|(
literal|"rename nonexistent file"
argument_list|,
literal|"FileNotFoundException"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|assertPathDoesNotExist
argument_list|(
literal|"rename nonexistent file created a destination file"
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
comment|/**    * Rename test -handles filesystems that will overwrite the destination    * as well as those that do not (i.e. HDFS).    * @throws Throwable    */
annotation|@
name|Test
DECL|method|testRenameFileOverExistingFile ()
specifier|public
name|void
name|testRenameFileOverExistingFile
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Verify renaming a file onto an existing file matches expectations"
argument_list|)
expr_stmt|;
name|Path
name|srcFile
init|=
name|path
argument_list|(
literal|"source-256.txt"
argument_list|)
decl_stmt|;
name|byte
index|[]
name|srcData
init|=
name|dataset
argument_list|(
literal|256
argument_list|,
literal|'a'
argument_list|,
literal|'z'
argument_list|)
decl_stmt|;
name|writeDataset
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|srcFile
argument_list|,
name|srcData
argument_list|,
name|srcData
operator|.
name|length
argument_list|,
literal|1024
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Path
name|destFile
init|=
name|path
argument_list|(
literal|"dest-512.txt"
argument_list|)
decl_stmt|;
name|byte
index|[]
name|destData
init|=
name|dataset
argument_list|(
literal|512
argument_list|,
literal|'A'
argument_list|,
literal|'Z'
argument_list|)
decl_stmt|;
name|writeDataset
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|destFile
argument_list|,
name|destData
argument_list|,
name|destData
operator|.
name|length
argument_list|,
literal|1024
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertIsFile
argument_list|(
name|destFile
argument_list|)
expr_stmt|;
name|boolean
name|renameOverwritesDest
init|=
name|isSupported
argument_list|(
name|RENAME_OVERWRITES_DEST
argument_list|)
decl_stmt|;
name|boolean
name|renameReturnsFalseOnRenameDestExists
init|=
operator|!
name|isSupported
argument_list|(
name|RENAME_RETURNS_FALSE_IF_DEST_EXISTS
argument_list|)
decl_stmt|;
name|boolean
name|destUnchanged
init|=
literal|true
decl_stmt|;
try|try
block|{
name|boolean
name|renamed
init|=
name|rename
argument_list|(
name|srcFile
argument_list|,
name|destFile
argument_list|)
decl_stmt|;
if|if
condition|(
name|renameOverwritesDest
condition|)
block|{
comment|// the filesystem supports rename(file, file2) by overwriting file2
name|assertTrue
argument_list|(
literal|"Rename returned false"
argument_list|,
name|renamed
argument_list|)
expr_stmt|;
name|destUnchanged
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|// rename is rejected by returning 'false' or throwing an exception
if|if
condition|(
name|renamed
operator|&&
operator|!
name|renameReturnsFalseOnRenameDestExists
condition|)
block|{
comment|//expected an exception
name|String
name|destDirLS
init|=
name|generateAndLogErrorListing
argument_list|(
name|srcFile
argument_list|,
name|destFile
argument_list|)
decl_stmt|;
name|getLog
argument_list|()
operator|.
name|error
argument_list|(
literal|"dest dir {}"
argument_list|,
name|destDirLS
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"expected rename("
operator|+
name|srcFile
operator|+
literal|", "
operator|+
name|destFile
operator|+
literal|" ) to fail,"
operator|+
literal|" but got success and destination of "
operator|+
name|destDirLS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|FileAlreadyExistsException
name|e
parameter_list|)
block|{
name|handleExpectedException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|// verify that the destination file is as expected based on the expected
comment|// outcome
name|verifyFileContents
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|destFile
argument_list|,
name|destUnchanged
condition|?
name|destData
else|:
name|srcData
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testRenameDirIntoExistingDir ()
specifier|public
name|void
name|testRenameDirIntoExistingDir
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"Verify renaming a dir into an existing dir puts it underneath"
operator|+
literal|" and leaves existing files alone"
argument_list|)
expr_stmt|;
name|FileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|String
name|sourceSubdir
init|=
literal|"source"
decl_stmt|;
name|Path
name|srcDir
init|=
name|path
argument_list|(
name|sourceSubdir
argument_list|)
decl_stmt|;
name|Path
name|srcFilePath
init|=
operator|new
name|Path
argument_list|(
name|srcDir
argument_list|,
literal|"source-256.txt"
argument_list|)
decl_stmt|;
name|byte
index|[]
name|srcDataset
init|=
name|dataset
argument_list|(
literal|256
argument_list|,
literal|'a'
argument_list|,
literal|'z'
argument_list|)
decl_stmt|;
name|writeDataset
argument_list|(
name|fs
argument_list|,
name|srcFilePath
argument_list|,
name|srcDataset
argument_list|,
name|srcDataset
operator|.
name|length
argument_list|,
literal|1024
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Path
name|destDir
init|=
name|path
argument_list|(
literal|"dest"
argument_list|)
decl_stmt|;
name|Path
name|destFilePath
init|=
operator|new
name|Path
argument_list|(
name|destDir
argument_list|,
literal|"dest-512.txt"
argument_list|)
decl_stmt|;
name|byte
index|[]
name|destDateset
init|=
name|dataset
argument_list|(
literal|512
argument_list|,
literal|'A'
argument_list|,
literal|'Z'
argument_list|)
decl_stmt|;
name|writeDataset
argument_list|(
name|fs
argument_list|,
name|destFilePath
argument_list|,
name|destDateset
argument_list|,
name|destDateset
operator|.
name|length
argument_list|,
literal|1024
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertIsFile
argument_list|(
name|destFilePath
argument_list|)
expr_stmt|;
name|boolean
name|rename
init|=
name|rename
argument_list|(
name|srcDir
argument_list|,
name|destDir
argument_list|)
decl_stmt|;
name|Path
name|renamedSrc
init|=
operator|new
name|Path
argument_list|(
name|destDir
argument_list|,
name|sourceSubdir
argument_list|)
decl_stmt|;
name|assertIsFile
argument_list|(
name|destFilePath
argument_list|)
expr_stmt|;
name|assertIsDirectory
argument_list|(
name|renamedSrc
argument_list|)
expr_stmt|;
name|verifyFileContents
argument_list|(
name|fs
argument_list|,
name|destFilePath
argument_list|,
name|destDateset
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"rename returned false though the contents were copied"
argument_list|,
name|rename
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testRenameFileNonexistentDir ()
specifier|public
name|void
name|testRenameFileNonexistentDir
parameter_list|()
throws|throws
name|Throwable
block|{
name|describe
argument_list|(
literal|"rename a file into a new file in the same directory"
argument_list|)
expr_stmt|;
name|Path
name|renameSrc
init|=
name|path
argument_list|(
literal|"testRenameSrc"
argument_list|)
decl_stmt|;
name|Path
name|renameTarget
init|=
name|path
argument_list|(
literal|"subdir/testRenameTarget"
argument_list|)
decl_stmt|;
name|byte
index|[]
name|data
init|=
name|dataset
argument_list|(
literal|256
argument_list|,
literal|'a'
argument_list|,
literal|'z'
argument_list|)
decl_stmt|;
name|writeDataset
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|renameSrc
argument_list|,
name|data
argument_list|,
name|data
operator|.
name|length
argument_list|,
literal|1024
operator|*
literal|1024
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|boolean
name|renameCreatesDestDirs
init|=
name|isSupported
argument_list|(
name|RENAME_CREATES_DEST_DIRS
argument_list|)
decl_stmt|;
try|try
block|{
name|boolean
name|rename
init|=
name|rename
argument_list|(
name|renameSrc
argument_list|,
name|renameTarget
argument_list|)
decl_stmt|;
if|if
condition|(
name|renameCreatesDestDirs
condition|)
block|{
name|assertTrue
argument_list|(
name|rename
argument_list|)
expr_stmt|;
name|verifyFileContents
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|renameTarget
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertFalse
argument_list|(
name|rename
argument_list|)
expr_stmt|;
name|verifyFileContents
argument_list|(
name|getFileSystem
argument_list|()
argument_list|,
name|renameSrc
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|// allowed unless that rename flag is set
name|assertFalse
argument_list|(
name|renameCreatesDestDirs
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
DECL|method|testRenameWithNonEmptySubDir ()
specifier|public
name|void
name|testRenameWithNonEmptySubDir
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|Path
name|renameTestDir
init|=
name|path
argument_list|(
literal|"testRenameWithNonEmptySubDir"
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|srcDir
init|=
operator|new
name|Path
argument_list|(
name|renameTestDir
argument_list|,
literal|"src1"
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|srcSubDir
init|=
operator|new
name|Path
argument_list|(
name|srcDir
argument_list|,
literal|"sub"
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|finalDir
init|=
operator|new
name|Path
argument_list|(
name|renameTestDir
argument_list|,
literal|"dest"
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
name|boolean
name|renameRemoveEmptyDest
init|=
name|isSupported
argument_list|(
name|RENAME_REMOVE_DEST_IF_EMPTY_DIR
argument_list|)
decl_stmt|;
name|rm
argument_list|(
name|fs
argument_list|,
name|renameTestDir
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|srcDir
argument_list|)
expr_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|finalDir
argument_list|)
expr_stmt|;
name|writeTextFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
name|srcDir
argument_list|,
literal|"source.txt"
argument_list|)
argument_list|,
literal|"this is the file in src dir"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|writeTextFile
argument_list|(
name|fs
argument_list|,
operator|new
name|Path
argument_list|(
name|srcSubDir
argument_list|,
literal|"subfile.txt"
argument_list|)
argument_list|,
literal|"this is the file in src/sub dir"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertPathExists
argument_list|(
literal|"not created in src dir"
argument_list|,
operator|new
name|Path
argument_list|(
name|srcDir
argument_list|,
literal|"source.txt"
argument_list|)
argument_list|)
expr_stmt|;
name|assertPathExists
argument_list|(
literal|"not created in src/sub dir"
argument_list|,
operator|new
name|Path
argument_list|(
name|srcSubDir
argument_list|,
literal|"subfile.txt"
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|.
name|rename
argument_list|(
name|srcDir
argument_list|,
name|finalDir
argument_list|)
expr_stmt|;
comment|// Accept both POSIX rename behavior and CLI rename behavior
if|if
condition|(
name|renameRemoveEmptyDest
condition|)
block|{
comment|// POSIX rename behavior
name|assertPathExists
argument_list|(
literal|"not renamed into dest dir"
argument_list|,
operator|new
name|Path
argument_list|(
name|finalDir
argument_list|,
literal|"source.txt"
argument_list|)
argument_list|)
expr_stmt|;
name|assertPathExists
argument_list|(
literal|"not renamed into dest/sub dir"
argument_list|,
operator|new
name|Path
argument_list|(
name|finalDir
argument_list|,
literal|"sub/subfile.txt"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// CLI rename behavior
name|assertPathExists
argument_list|(
literal|"not renamed into dest dir"
argument_list|,
operator|new
name|Path
argument_list|(
name|finalDir
argument_list|,
literal|"src1/source.txt"
argument_list|)
argument_list|)
expr_stmt|;
name|assertPathExists
argument_list|(
literal|"not renamed into dest/sub dir"
argument_list|,
operator|new
name|Path
argument_list|(
name|finalDir
argument_list|,
literal|"src1/sub/subfile.txt"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertPathDoesNotExist
argument_list|(
literal|"not deleted"
argument_list|,
operator|new
name|Path
argument_list|(
name|srcDir
argument_list|,
literal|"source.txt"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that after renaming, the nested subdirectory is moved along with all    * its ancestors.    */
annotation|@
name|Test
DECL|method|testRenamePopulatesDirectoryAncestors ()
specifier|public
name|void
name|testRenamePopulatesDirectoryAncestors
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|FileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|src
init|=
name|path
argument_list|(
literal|"testRenamePopulatesDirectoryAncestors/source"
argument_list|)
decl_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|src
argument_list|)
expr_stmt|;
specifier|final
name|String
name|nestedDir
init|=
literal|"/dir1/dir2/dir3/dir4"
decl_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|path
argument_list|(
name|src
operator|+
name|nestedDir
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|dst
init|=
name|path
argument_list|(
literal|"testRenamePopulatesDirectoryAncestorsNew"
argument_list|)
decl_stmt|;
name|fs
operator|.
name|rename
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|validateAncestorsMoved
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|nestedDir
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that after renaming, the nested file is moved along with all its    * ancestors. It is similar to {@link #testRenamePopulatesDirectoryAncestors}.    */
annotation|@
name|Test
DECL|method|testRenamePopulatesFileAncestors ()
specifier|public
name|void
name|testRenamePopulatesFileAncestors
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|FileSystem
name|fs
init|=
name|getFileSystem
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|src
init|=
name|path
argument_list|(
literal|"testRenamePopulatesFileAncestors/source"
argument_list|)
decl_stmt|;
name|fs
operator|.
name|mkdirs
argument_list|(
name|src
argument_list|)
expr_stmt|;
specifier|final
name|String
name|nestedFile
init|=
literal|"/dir1/dir2/dir3/file4"
decl_stmt|;
name|byte
index|[]
name|srcDataset
init|=
name|dataset
argument_list|(
literal|256
argument_list|,
literal|'a'
argument_list|,
literal|'z'
argument_list|)
decl_stmt|;
name|writeDataset
argument_list|(
name|fs
argument_list|,
name|path
argument_list|(
name|src
operator|+
name|nestedFile
argument_list|)
argument_list|,
name|srcDataset
argument_list|,
name|srcDataset
operator|.
name|length
argument_list|,
literal|1024
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Path
name|dst
init|=
name|path
argument_list|(
literal|"testRenamePopulatesFileAncestorsNew"
argument_list|)
decl_stmt|;
name|fs
operator|.
name|rename
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|validateAncestorsMoved
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|nestedFile
argument_list|)
expr_stmt|;
block|}
comment|/**    * Validate that the nested path and its ancestors should have been moved.    *    * @param src the source root to move    * @param dst the destination root to move    * @param nestedPath the nested path to move    */
DECL|method|validateAncestorsMoved (Path src, Path dst, String nestedPath)
specifier|private
name|void
name|validateAncestorsMoved
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|,
name|String
name|nestedPath
parameter_list|)
throws|throws
name|IOException
block|{
name|assertIsDirectory
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|assertPathDoesNotExist
argument_list|(
literal|"src path should not exist"
argument_list|,
name|path
argument_list|(
name|src
operator|+
name|nestedPath
argument_list|)
argument_list|)
expr_stmt|;
name|assertPathExists
argument_list|(
literal|"dst path should exist"
argument_list|,
name|path
argument_list|(
name|dst
operator|+
name|nestedPath
argument_list|)
argument_list|)
expr_stmt|;
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|nestedPath
argument_list|)
operator|.
name|getParent
argument_list|()
decl_stmt|;
while|while
condition|(
name|path
operator|!=
literal|null
operator|&&
operator|!
name|path
operator|.
name|isRoot
argument_list|()
condition|)
block|{
specifier|final
name|Path
name|parentSrc
init|=
name|path
argument_list|(
name|src
operator|+
name|path
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|assertPathDoesNotExist
argument_list|(
name|parentSrc
operator|+
literal|" is not deleted"
argument_list|,
name|parentSrc
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|parentDst
init|=
name|path
argument_list|(
name|dst
operator|+
name|path
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
name|assertPathExists
argument_list|(
name|parentDst
operator|+
literal|" should exist after rename"
argument_list|,
name|parentDst
argument_list|)
expr_stmt|;
name|assertIsDirectory
argument_list|(
name|parentDst
argument_list|)
expr_stmt|;
name|path
operator|=
name|path
operator|.
name|getParent
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

