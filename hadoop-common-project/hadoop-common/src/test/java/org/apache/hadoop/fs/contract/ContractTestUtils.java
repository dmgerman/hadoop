begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *       http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.contract
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|contract
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|LocatedFileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|RemoteIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|internal
operator|.
name|AssumptionViolatedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Properties
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|UUID
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|IO_FILE_BUFFER_SIZE_DEFAULT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|IO_FILE_BUFFER_SIZE_KEY
import|;
end_import

begin_comment
comment|/**  * Utilities used across test cases.  */
end_comment

begin_class
DECL|class|ContractTestUtils
specifier|public
class|class
name|ContractTestUtils
extends|extends
name|Assert
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ContractTestUtils
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// For scale testing, we can repeatedly write small chunk data to generate
comment|// a large file.
DECL|field|IO_CHUNK_BUFFER_SIZE
specifier|public
specifier|static
specifier|final
name|String
name|IO_CHUNK_BUFFER_SIZE
init|=
literal|"io.chunk.buffer.size"
decl_stmt|;
DECL|field|DEFAULT_IO_CHUNK_BUFFER_SIZE
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_IO_CHUNK_BUFFER_SIZE
init|=
literal|128
decl_stmt|;
DECL|field|IO_CHUNK_MODULUS_SIZE
specifier|public
specifier|static
specifier|final
name|String
name|IO_CHUNK_MODULUS_SIZE
init|=
literal|"io.chunk.modulus.size"
decl_stmt|;
DECL|field|DEFAULT_IO_CHUNK_MODULUS_SIZE
specifier|public
specifier|static
specifier|final
name|int
name|DEFAULT_IO_CHUNK_MODULUS_SIZE
init|=
literal|128
decl_stmt|;
comment|/**    * Assert that a property in the property set matches the expected value.    * @param props property set    * @param key property name    * @param expected expected value. If null, the property must not be in the set    */
DECL|method|assertPropertyEquals (Properties props, String key, String expected)
specifier|public
specifier|static
name|void
name|assertPropertyEquals
parameter_list|(
name|Properties
name|props
parameter_list|,
name|String
name|key
parameter_list|,
name|String
name|expected
parameter_list|)
block|{
name|String
name|val
init|=
name|props
operator|.
name|getProperty
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|expected
operator|==
literal|null
condition|)
block|{
name|assertNull
argument_list|(
literal|"Non null property "
operator|+
name|key
operator|+
literal|" = "
operator|+
name|val
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertEquals
argument_list|(
literal|"property "
operator|+
name|key
operator|+
literal|" = "
operator|+
name|val
argument_list|,
name|expected
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    *    * Write a file and read it in, validating the result. Optional flags control    * whether file overwrite operations should be enabled, and whether the    * file should be deleted afterwards.    *    * If there is a mismatch between what was written and what was expected,    * a small range of bytes either side of the first error are logged to aid    * diagnosing what problem occurred -whether it was a previous file    * or a corrupting of the current file. This assumes that two    * sequential runs to the same path use datasets with different character    * moduli.    *    * @param fs filesystem    * @param path path to write to    * @param len length of data    * @param overwrite should the create option allow overwrites?    * @param delete should the file be deleted afterwards? -with a verification    * that it worked. Deletion is not attempted if an assertion has failed    * earlier -it is not in a<code>finally{}</code> block.    * @throws IOException IO problems    */
DECL|method|writeAndRead (FileSystem fs, Path path, byte[] src, int len, int blocksize, boolean overwrite, boolean delete)
specifier|public
specifier|static
name|void
name|writeAndRead
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|byte
index|[]
name|src
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|blocksize
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|boolean
name|delete
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|mkdirs
argument_list|(
name|path
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
name|writeDataset
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|src
argument_list|,
name|len
argument_list|,
name|blocksize
argument_list|,
name|overwrite
argument_list|)
expr_stmt|;
name|byte
index|[]
name|dest
init|=
name|readDataset
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|compareByteArrays
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete
condition|)
block|{
name|rejectRootOperation
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|boolean
name|deleted
init|=
name|fs
operator|.
name|delete
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Deleted"
argument_list|,
name|deleted
argument_list|)
expr_stmt|;
name|assertPathDoesNotExist
argument_list|(
name|fs
argument_list|,
literal|"Cleanup failed"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Write a file.    * Optional flags control    * whether file overwrite operations should be enabled    * @param fs filesystem    * @param path path to write to    * @param len length of data    * @param overwrite should the create option allow overwrites?    * @throws IOException IO problems    */
DECL|method|writeDataset (FileSystem fs, Path path, byte[] src, int len, int buffersize, boolean overwrite)
specifier|public
specifier|static
name|void
name|writeDataset
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|byte
index|[]
name|src
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|buffersize
parameter_list|,
name|boolean
name|overwrite
parameter_list|)
throws|throws
name|IOException
block|{
name|assertTrue
argument_list|(
literal|"Not enough data in source array to write "
operator|+
name|len
operator|+
literal|" bytes"
argument_list|,
name|src
operator|.
name|length
operator|>=
name|len
argument_list|)
expr_stmt|;
name|FSDataOutputStream
name|out
init|=
name|fs
operator|.
name|create
argument_list|(
name|path
argument_list|,
name|overwrite
argument_list|,
name|fs
operator|.
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|IO_FILE_BUFFER_SIZE_KEY
argument_list|,
name|IO_FILE_BUFFER_SIZE_DEFAULT
argument_list|)
argument_list|,
operator|(
name|short
operator|)
literal|1
argument_list|,
name|buffersize
argument_list|)
decl_stmt|;
name|out
operator|.
name|write
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|assertFileHasLength
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/**    * Read the file and convert to a byte dataset.    * This implements readfully internally, so that it will read    * in the file without ever having to seek()    * @param fs filesystem    * @param path path to read from    * @param len length of data to read    * @return the bytes    * @throws IOException IO problems    */
DECL|method|readDataset (FileSystem fs, Path path, int len)
specifier|public
specifier|static
name|byte
index|[]
name|readDataset
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|dest
init|=
operator|new
name|byte
index|[
name|len
index|]
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|nread
init|=
literal|0
decl_stmt|;
try|try
init|(
name|FSDataInputStream
name|in
init|=
name|fs
operator|.
name|open
argument_list|(
name|path
argument_list|)
init|)
block|{
while|while
condition|(
name|nread
operator|<
name|len
condition|)
block|{
name|int
name|nbytes
init|=
name|in
operator|.
name|read
argument_list|(
name|dest
argument_list|,
name|offset
operator|+
name|nread
argument_list|,
name|len
operator|-
name|nread
argument_list|)
decl_stmt|;
if|if
condition|(
name|nbytes
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"End of file reached before reading fully."
argument_list|)
throw|;
block|}
name|nread
operator|+=
name|nbytes
expr_stmt|;
block|}
block|}
return|return
name|dest
return|;
block|}
comment|/**    * Read a file, verify its length and contents match the expected array.    * @param fs filesystem    * @param path path to file    * @param original original dataset    * @throws IOException IO Problems    */
DECL|method|verifyFileContents (FileSystem fs, Path path, byte[] original)
specifier|public
specifier|static
name|void
name|verifyFileContents
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|byte
index|[]
name|original
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
name|stat
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|String
name|statText
init|=
name|stat
operator|.
name|toString
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"not a file "
operator|+
name|statText
argument_list|,
name|stat
operator|.
name|isFile
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"wrong length "
operator|+
name|statText
argument_list|,
name|original
operator|.
name|length
argument_list|,
name|stat
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
name|byte
index|[]
name|bytes
init|=
name|readDataset
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|original
operator|.
name|length
argument_list|)
decl_stmt|;
name|compareByteArrays
argument_list|(
name|original
argument_list|,
name|bytes
argument_list|,
name|original
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**    * Verify that the read at a specific offset in a stream    * matches that expected.    * @param stm stream    * @param fileContents original file contents    * @param seekOff seek offset    * @param toRead number of bytes to read    * @throws IOException IO problems    */
DECL|method|verifyRead (FSDataInputStream stm, byte[] fileContents, int seekOff, int toRead)
specifier|public
specifier|static
name|void
name|verifyRead
parameter_list|(
name|FSDataInputStream
name|stm
parameter_list|,
name|byte
index|[]
name|fileContents
parameter_list|,
name|int
name|seekOff
parameter_list|,
name|int
name|toRead
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|out
init|=
operator|new
name|byte
index|[
name|toRead
index|]
decl_stmt|;
name|stm
operator|.
name|seek
argument_list|(
name|seekOff
argument_list|)
expr_stmt|;
name|stm
operator|.
name|readFully
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|byte
index|[]
name|expected
init|=
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|fileContents
argument_list|,
name|seekOff
argument_list|,
name|seekOff
operator|+
name|toRead
argument_list|)
decl_stmt|;
name|compareByteArrays
argument_list|(
name|expected
argument_list|,
name|out
argument_list|,
name|toRead
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that tthe array original[0..len] and received[] are equal.    * A failure triggers the logging of the bytes near where the first    * difference surfaces.    * @param original source data    * @param received actual    * @param len length of bytes to compare    */
DECL|method|compareByteArrays (byte[] original, byte[] received, int len)
specifier|public
specifier|static
name|void
name|compareByteArrays
parameter_list|(
name|byte
index|[]
name|original
parameter_list|,
name|byte
index|[]
name|received
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|assertEquals
argument_list|(
literal|"Number of bytes read != number written"
argument_list|,
name|len
argument_list|,
name|received
operator|.
name|length
argument_list|)
expr_stmt|;
name|int
name|errors
init|=
literal|0
decl_stmt|;
name|int
name|first_error_byte
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|original
index|[
name|i
index|]
operator|!=
name|received
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|errors
operator|==
literal|0
condition|)
block|{
name|first_error_byte
operator|=
name|i
expr_stmt|;
block|}
name|errors
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errors
operator|>
literal|0
condition|)
block|{
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
literal|" %d errors in file of length %d"
argument_list|,
name|errors
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|message
argument_list|)
expr_stmt|;
comment|// the range either side of the first error to print
comment|// this is a purely arbitrary number, to aid user debugging
specifier|final
name|int
name|overlap
init|=
literal|10
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|first_error_byte
operator|-
name|overlap
argument_list|)
init|;
name|i
operator|<
name|Math
operator|.
name|min
argument_list|(
name|first_error_byte
operator|+
name|overlap
argument_list|,
name|len
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|byte
name|actual
init|=
name|received
index|[
name|i
index|]
decl_stmt|;
name|byte
name|expected
init|=
name|original
index|[
name|i
index|]
decl_stmt|;
name|String
name|letter
init|=
name|toChar
argument_list|(
name|actual
argument_list|)
decl_stmt|;
name|String
name|line
init|=
name|String
operator|.
name|format
argument_list|(
literal|"[%04d] %2x %s%n"
argument_list|,
name|i
argument_list|,
name|actual
argument_list|,
name|letter
argument_list|)
decl_stmt|;
if|if
condition|(
name|expected
operator|!=
name|actual
condition|)
block|{
name|line
operator|=
name|String
operator|.
name|format
argument_list|(
literal|"[%04d] %2x %s -expected %2x %s%n"
argument_list|,
name|i
argument_list|,
name|actual
argument_list|,
name|letter
argument_list|,
name|expected
argument_list|,
name|toChar
argument_list|(
name|expected
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|warn
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|fail
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Convert a byte to a character for printing. If the    * byte value is< 32 -and hence unprintable- the byte is    * returned as a two digit hex value    * @param b byte    * @return the printable character string    */
DECL|method|toChar (byte b)
specifier|public
specifier|static
name|String
name|toChar
parameter_list|(
name|byte
name|b
parameter_list|)
block|{
if|if
condition|(
name|b
operator|>=
literal|0x20
condition|)
block|{
return|return
name|Character
operator|.
name|toString
argument_list|(
operator|(
name|char
operator|)
name|b
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%02x"
argument_list|,
name|b
argument_list|)
return|;
block|}
block|}
comment|/**    * Convert a buffer to a string, character by character.    * @param buffer input bytes    * @return a string conversion    */
DECL|method|toChar (byte[] buffer)
specifier|public
specifier|static
name|String
name|toChar
parameter_list|(
name|byte
index|[]
name|buffer
parameter_list|)
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
name|buffer
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|byte
name|b
range|:
name|buffer
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|toChar
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|toAsciiByteArray (String s)
specifier|public
specifier|static
name|byte
index|[]
name|toAsciiByteArray
parameter_list|(
name|String
name|s
parameter_list|)
block|{
name|char
index|[]
name|chars
init|=
name|s
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|chars
operator|.
name|length
decl_stmt|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
name|len
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|chars
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
return|;
block|}
comment|/**    * Cleanup at the end of a test run.    * @param action action triggering the operation (for use in logging)    * @param fileSystem filesystem to work with. May be null    * @param cleanupPath path to delete as a string    */
DECL|method|cleanup (String action, FileSystem fileSystem, String cleanupPath)
specifier|public
specifier|static
name|void
name|cleanup
parameter_list|(
name|String
name|action
parameter_list|,
name|FileSystem
name|fileSystem
parameter_list|,
name|String
name|cleanupPath
parameter_list|)
block|{
if|if
condition|(
name|fileSystem
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|cleanupPath
argument_list|)
operator|.
name|makeQualified
argument_list|(
name|fileSystem
operator|.
name|getUri
argument_list|()
argument_list|,
name|fileSystem
operator|.
name|getWorkingDirectory
argument_list|()
argument_list|)
decl_stmt|;
name|cleanup
argument_list|(
name|action
argument_list|,
name|fileSystem
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
comment|/**    * Cleanup at the end of a test run.    * @param action action triggering the operation (for use in logging)    * @param fileSystem filesystem to work with. May be null    * @param path path to delete    */
DECL|method|cleanup (String action, FileSystem fileSystem, Path path)
specifier|public
specifier|static
name|void
name|cleanup
parameter_list|(
name|String
name|action
parameter_list|,
name|FileSystem
name|fileSystem
parameter_list|,
name|Path
name|path
parameter_list|)
block|{
name|noteAction
argument_list|(
name|action
argument_list|)
expr_stmt|;
try|try
block|{
name|rm
argument_list|(
name|fileSystem
argument_list|,
name|path
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error deleting in "
operator|+
name|action
operator|+
literal|" - "
operator|+
name|path
operator|+
literal|": "
operator|+
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Delete a directory. There's a safety check for operations against the    * root directory -these are intercepted and rejected with an IOException    * unless the allowRootDelete flag is true    * @param fileSystem filesystem to work with. May be null    * @param path path to delete    * @param recursive flag to enable recursive delete    * @param allowRootDelete can the root directory be deleted?    * @throws IOException on any problem.    */
DECL|method|rm (FileSystem fileSystem, Path path, boolean recursive, boolean allowRootDelete)
specifier|public
specifier|static
name|boolean
name|rm
parameter_list|(
name|FileSystem
name|fileSystem
parameter_list|,
name|Path
name|path
parameter_list|,
name|boolean
name|recursive
parameter_list|,
name|boolean
name|allowRootDelete
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fileSystem
operator|!=
literal|null
condition|)
block|{
name|rejectRootOperation
argument_list|(
name|path
argument_list|,
name|allowRootDelete
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileSystem
operator|.
name|exists
argument_list|(
name|path
argument_list|)
condition|)
block|{
return|return
name|fileSystem
operator|.
name|delete
argument_list|(
name|path
argument_list|,
name|recursive
argument_list|)
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Block any operation on the root path. This is a safety check    * @param path path in the filesystem    * @param allowRootOperation can the root directory be manipulated?    * @throws IOException if the operation was rejected    */
DECL|method|rejectRootOperation (Path path, boolean allowRootOperation)
specifier|public
specifier|static
name|void
name|rejectRootOperation
parameter_list|(
name|Path
name|path
parameter_list|,
name|boolean
name|allowRootOperation
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|path
operator|.
name|isRoot
argument_list|()
operator|&&
operator|!
name|allowRootOperation
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Root directory operation rejected: "
operator|+
name|path
argument_list|)
throw|;
block|}
block|}
comment|/**    * Block any operation on the root path. This is a safety check    * @param path path in the filesystem    * @throws IOException if the operation was rejected    */
DECL|method|rejectRootOperation (Path path)
specifier|public
specifier|static
name|void
name|rejectRootOperation
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|rejectRootOperation
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * List then delete the children of a path, but not the path itself.    * This can be used to delete the entries under a root path when that    * FS does not support {@code delete("/")}.    * @param fileSystem filesystem    * @param path path to delete    * @param recursive flag to indicate child entry deletion should be recursive    * @return the immediate child entries found and deleted (not including    * any recursive children of those entries)    * @throws IOException problem in the deletion process.    */
DECL|method|deleteChildren (FileSystem fileSystem, Path path, boolean recursive)
specifier|public
specifier|static
name|FileStatus
index|[]
name|deleteChildren
parameter_list|(
name|FileSystem
name|fileSystem
parameter_list|,
name|Path
name|path
parameter_list|,
name|boolean
name|recursive
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
index|[]
name|children
init|=
name|listChildren
argument_list|(
name|fileSystem
argument_list|,
name|path
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|entry
range|:
name|children
control|)
block|{
name|fileSystem
operator|.
name|delete
argument_list|(
name|entry
operator|.
name|getPath
argument_list|()
argument_list|,
name|recursive
argument_list|)
expr_stmt|;
block|}
return|return
name|children
return|;
block|}
comment|/**    * List all children of a path, but not the path itself in the case    * that the path refers to a file or empty directory.    * @param fileSystem FS    * @param path path    * @return a list of children, and never the path itself.    * @throws IOException problem in the list process    */
DECL|method|listChildren (FileSystem fileSystem, Path path)
specifier|public
specifier|static
name|FileStatus
index|[]
name|listChildren
parameter_list|(
name|FileSystem
name|fileSystem
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
index|[]
name|entries
init|=
name|fileSystem
operator|.
name|listStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|entries
operator|.
name|length
operator|==
literal|1
operator|&&
name|path
operator|.
name|equals
argument_list|(
name|entries
index|[
literal|0
index|]
operator|.
name|getPath
argument_list|()
argument_list|)
condition|)
block|{
comment|// this is the path: ignore
return|return
operator|new
name|FileStatus
index|[]
block|{}
return|;
block|}
else|else
block|{
return|return
name|entries
return|;
block|}
block|}
DECL|method|noteAction (String action)
specifier|public
specifier|static
name|void
name|noteAction
parameter_list|(
name|String
name|action
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"==============  "
operator|+
name|action
operator|+
literal|" ============="
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * downgrade a failure to a message and a warning, then an    * exception for the Junit test runner to mark as failed.    * @param message text message    * @param failure what failed    * @throws AssumptionViolatedException always    */
DECL|method|downgrade (String message, Throwable failure)
specifier|public
specifier|static
name|void
name|downgrade
parameter_list|(
name|String
name|message
parameter_list|,
name|Throwable
name|failure
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Downgrading test "
operator|+
name|message
argument_list|,
name|failure
argument_list|)
expr_stmt|;
name|AssumptionViolatedException
name|ave
init|=
operator|new
name|AssumptionViolatedException
argument_list|(
name|failure
argument_list|,
literal|null
argument_list|)
decl_stmt|;
throw|throw
name|ave
throw|;
block|}
comment|/**    * report an overridden test as unsupported.    * @param message message to use in the text    * @throws AssumptionViolatedException always    */
DECL|method|unsupported (String message)
specifier|public
specifier|static
name|void
name|unsupported
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|skip
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
comment|/**    * report a test has been skipped for some reason.    * @param message message to use in the text    * @throws AssumptionViolatedException always    */
DECL|method|skip (String message)
specifier|public
specifier|static
name|void
name|skip
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Skipping: {}"
argument_list|,
name|message
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AssumptionViolatedException
argument_list|(
name|message
argument_list|)
throw|;
block|}
comment|/**    * Fail with an exception that was received.    * @param text text to use in the exception    * @param thrown a (possibly null) throwable to init the cause with    * @throws AssertionError with the text and throwable -always    */
DECL|method|fail (String text, Throwable thrown)
specifier|public
specifier|static
name|void
name|fail
parameter_list|(
name|String
name|text
parameter_list|,
name|Throwable
name|thrown
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|text
argument_list|,
name|thrown
argument_list|)
throw|;
block|}
comment|/**    * Make an assertion about the length of a file.    * @param fs filesystem    * @param path path of the file    * @param expected expected length    * @throws IOException on File IO problems    */
DECL|method|assertFileHasLength (FileSystem fs, Path path, int expected)
specifier|public
specifier|static
name|void
name|assertFileHasLength
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|int
name|expected
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
name|status
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Wrong file length of file "
operator|+
name|path
operator|+
literal|" status: "
operator|+
name|status
argument_list|,
name|expected
argument_list|,
name|status
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that a path refers to a directory.    * @param fs filesystem    * @param path path of the directory    * @throws IOException on File IO problems    */
DECL|method|assertIsDirectory (FileSystem fs, Path path)
specifier|public
specifier|static
name|void
name|assertIsDirectory
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
name|fileStatus
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|assertIsDirectory
argument_list|(
name|fileStatus
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that a path refers to a directory.    * @param fileStatus stats to check    */
DECL|method|assertIsDirectory (FileStatus fileStatus)
specifier|public
specifier|static
name|void
name|assertIsDirectory
parameter_list|(
name|FileStatus
name|fileStatus
parameter_list|)
block|{
name|assertTrue
argument_list|(
literal|"Should be a directory -but isn't: "
operator|+
name|fileStatus
argument_list|,
name|fileStatus
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that a path is Erasure Coded.    *    * @param fs filesystem    * @param path path of the file or directory    * @throws IOException on File IO problems    */
DECL|method|assertErasureCoded (final FileSystem fs, final Path path)
specifier|public
specifier|static
name|void
name|assertErasureCoded
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
name|fileStatus
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|path
operator|+
literal|" must be erasure coded!"
argument_list|,
name|fileStatus
operator|.
name|isErasureCoded
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that a path is not Erasure Coded.    *    * @param fs filesystem    * @param path path of the file or directory    * @throws IOException on File IO problems    */
DECL|method|assertNotErasureCoded (final FileSystem fs, final Path path)
specifier|public
specifier|static
name|void
name|assertNotErasureCoded
parameter_list|(
specifier|final
name|FileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
name|fileStatus
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|path
operator|+
literal|" should not be erasure coded!"
argument_list|,
name|fileStatus
operator|.
name|isErasureCoded
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Write the text to a file, returning the converted byte array    * for use in validating the round trip.    * @param fs filesystem    * @param path path of file    * @param text text to write    * @param overwrite should the operation overwrite any existing file?    * @return the read bytes    * @throws IOException on IO problems    */
DECL|method|writeTextFile (FileSystem fs, Path path, String text, boolean overwrite)
specifier|public
specifier|static
name|byte
index|[]
name|writeTextFile
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|String
name|text
parameter_list|,
name|boolean
name|overwrite
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|text
operator|!=
literal|null
condition|)
block|{
name|bytes
operator|=
name|toAsciiByteArray
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
name|createFile
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|overwrite
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
return|return
name|bytes
return|;
block|}
comment|/**    * Create a file.    * @param fs filesystem    * @param path       path to write    * @param overwrite overwrite flag    * @param data source dataset. Can be null    * @throws IOException on any problem    */
DECL|method|createFile (FileSystem fs, Path path, boolean overwrite, byte[] data)
specifier|public
specifier|static
name|void
name|createFile
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|FSDataOutputStream
name|stream
init|=
name|fs
operator|.
name|create
argument_list|(
name|path
argument_list|,
name|overwrite
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|data
operator|!=
literal|null
operator|&&
name|data
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|stream
operator|.
name|write
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Touch a file.    * @param fs filesystem    * @param path path    * @throws IOException IO problems    */
DECL|method|touch (FileSystem fs, Path path)
specifier|public
specifier|static
name|void
name|touch
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|createFile
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
literal|true
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete a file/dir and assert that delete() returned true    *<i>and</i> that the path no longer exists. This variant rejects    * all operations on root directories.    * @param fs filesystem    * @param file path to delete    * @param recursive flag to enable recursive delete    * @throws IOException IO problems    */
DECL|method|assertDeleted (FileSystem fs, Path file, boolean recursive)
specifier|public
specifier|static
name|void
name|assertDeleted
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|file
parameter_list|,
name|boolean
name|recursive
parameter_list|)
throws|throws
name|IOException
block|{
name|assertDeleted
argument_list|(
name|fs
argument_list|,
name|file
argument_list|,
name|recursive
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete a file/dir and assert that delete() returned true    *<i>and</i> that the path no longer exists. This variant rejects    * all operations on root directories    * @param fs filesystem    * @param file path to delete    * @param recursive flag to enable recursive delete    * @param allowRootOperations can the root dir be deleted?    * @throws IOException IO problems    */
DECL|method|assertDeleted (FileSystem fs, Path file, boolean recursive, boolean allowRootOperations)
specifier|public
specifier|static
name|void
name|assertDeleted
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|file
parameter_list|,
name|boolean
name|recursive
parameter_list|,
name|boolean
name|allowRootOperations
parameter_list|)
throws|throws
name|IOException
block|{
name|rejectRootOperation
argument_list|(
name|file
argument_list|,
name|allowRootOperations
argument_list|)
expr_stmt|;
name|assertPathExists
argument_list|(
name|fs
argument_list|,
literal|"about to be deleted file"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|boolean
name|deleted
init|=
name|fs
operator|.
name|delete
argument_list|(
name|file
argument_list|,
name|recursive
argument_list|)
decl_stmt|;
name|String
name|dir
init|=
name|ls
argument_list|(
name|fs
argument_list|,
name|file
operator|.
name|getParent
argument_list|()
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"Delete failed on "
operator|+
name|file
operator|+
literal|": "
operator|+
name|dir
argument_list|,
name|deleted
argument_list|)
expr_stmt|;
name|assertPathDoesNotExist
argument_list|(
name|fs
argument_list|,
literal|"Deleted file"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
comment|/**    * Read in "length" bytes, convert to an ascii string.    * @param fs filesystem    * @param path path to read    * @param length #of bytes to read.    * @return the bytes read and converted to a string    * @throws IOException IO problems    */
DECL|method|readBytesToString (FileSystem fs, Path path, int length)
specifier|public
specifier|static
name|String
name|readBytesToString
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|FSDataInputStream
name|in
init|=
name|fs
operator|.
name|open
argument_list|(
name|path
argument_list|)
init|)
block|{
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
name|length
index|]
decl_stmt|;
name|in
operator|.
name|readFully
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|toChar
argument_list|(
name|buf
argument_list|)
return|;
block|}
block|}
comment|/**    * Take an array of filestats and convert to a string    * (prefixed with/ a [%02d] counter).    * @param stats array of stats    * @param separator separator after every entry    * @return a stringified set    */
DECL|method|fileStatsToString (FileStatus[] stats, String separator)
specifier|public
specifier|static
name|String
name|fileStatsToString
parameter_list|(
name|FileStatus
index|[]
name|stats
parameter_list|,
name|String
name|separator
parameter_list|)
block|{
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
name|stats
operator|.
name|length
operator|*
literal|128
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stats
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"[%02d] %s"
argument_list|,
name|i
argument_list|,
name|stats
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
name|separator
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * List a directory.    * @param fileSystem FS    * @param path path    * @return a directory listing or failure message    * @throws IOException    */
DECL|method|ls (FileSystem fileSystem, Path path)
specifier|public
specifier|static
name|String
name|ls
parameter_list|(
name|FileSystem
name|fileSystem
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|path
operator|==
literal|null
condition|)
block|{
comment|//surfaces when someone calls getParent() on something at the top of the path
return|return
literal|"/"
return|;
block|}
name|FileStatus
index|[]
name|stats
decl_stmt|;
name|String
name|pathtext
init|=
literal|"ls "
operator|+
name|path
decl_stmt|;
try|try
block|{
name|stats
operator|=
name|fileSystem
operator|.
name|listStatus
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return
name|pathtext
operator|+
literal|" -file not found"
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
name|pathtext
operator|+
literal|" -failed: "
operator|+
name|e
return|;
block|}
return|return
name|dumpStats
argument_list|(
name|pathtext
argument_list|,
name|stats
argument_list|)
return|;
block|}
DECL|method|dumpStats (String pathname, FileStatus[] stats)
specifier|public
specifier|static
name|String
name|dumpStats
parameter_list|(
name|String
name|pathname
parameter_list|,
name|FileStatus
index|[]
name|stats
parameter_list|)
block|{
return|return
name|pathname
operator|+
literal|' '
operator|+
name|fileStatsToString
argument_list|(
name|stats
argument_list|,
name|System
operator|.
name|lineSeparator
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Assert that a file exists and whose {@link FileStatus} entry    * declares that this is a file and not a symlink or directory.    * @param fileSystem filesystem to resolve path against    * @param filename name of the file    * @throws IOException IO problems during file operations    */
DECL|method|assertIsFile (FileSystem fileSystem, Path filename)
specifier|public
specifier|static
name|void
name|assertIsFile
parameter_list|(
name|FileSystem
name|fileSystem
parameter_list|,
name|Path
name|filename
parameter_list|)
throws|throws
name|IOException
block|{
name|assertPathExists
argument_list|(
name|fileSystem
argument_list|,
literal|"Expected file"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|FileStatus
name|status
init|=
name|fileSystem
operator|.
name|getFileStatus
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|assertIsFile
argument_list|(
name|filename
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that a file exists and whose {@link FileStatus} entry    * declares that this is a file and not a symlink or directory.    * @param filename name of the file    * @param status file status    */
DECL|method|assertIsFile (Path filename, FileStatus status)
specifier|public
specifier|static
name|void
name|assertIsFile
parameter_list|(
name|Path
name|filename
parameter_list|,
name|FileStatus
name|status
parameter_list|)
block|{
name|String
name|fileInfo
init|=
name|filename
operator|+
literal|"  "
operator|+
name|status
decl_stmt|;
name|assertFalse
argument_list|(
literal|"File claims to be a directory "
operator|+
name|fileInfo
argument_list|,
name|status
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"File claims to be a symlink "
operator|+
name|fileInfo
argument_list|,
name|status
operator|.
name|isSymlink
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a dataset for use in the tests; all data is in the range    * base to (base+modulo-1) inclusive.    * @param len length of data    * @param base base of the data    * @param modulo the modulo    * @return the newly generated dataset    */
DECL|method|dataset (int len, int base, int modulo)
specifier|public
specifier|static
name|byte
index|[]
name|dataset
parameter_list|(
name|int
name|len
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|modulo
parameter_list|)
block|{
name|byte
index|[]
name|dataset
init|=
operator|new
name|byte
index|[
name|len
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|dataset
index|[
name|i
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|base
operator|+
operator|(
name|i
operator|%
name|modulo
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|dataset
return|;
block|}
comment|/**    * Assert that a path exists -but make no assertions as to the    * type of that entry.    *    * @param fileSystem filesystem to examine    * @param message message to include in the assertion failure message    * @param path path in the filesystem    * @throws FileNotFoundException raised if the path is missing    * @throws IOException IO problems    */
DECL|method|assertPathExists (FileSystem fileSystem, String message, Path path)
specifier|public
specifier|static
name|void
name|assertPathExists
parameter_list|(
name|FileSystem
name|fileSystem
parameter_list|,
name|String
name|message
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|fileSystem
operator|.
name|exists
argument_list|(
name|path
argument_list|)
condition|)
block|{
comment|//failure, report it
name|ls
argument_list|(
name|fileSystem
argument_list|,
name|path
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
name|message
operator|+
literal|": not found "
operator|+
name|path
operator|+
literal|" in "
operator|+
name|path
operator|.
name|getParent
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Assert that a path does not exist.    *    * @param fileSystem filesystem to examine    * @param message message to include in the assertion failure message    * @param path path in the filesystem    * @throws IOException IO problems    */
DECL|method|assertPathDoesNotExist (FileSystem fileSystem, String message, Path path)
specifier|public
specifier|static
name|void
name|assertPathDoesNotExist
parameter_list|(
name|FileSystem
name|fileSystem
parameter_list|,
name|String
name|message
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|FileStatus
name|status
init|=
name|fileSystem
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|fail
argument_list|(
name|message
operator|+
literal|": unexpectedly found "
operator|+
name|path
operator|+
literal|" as  "
operator|+
name|status
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|expected
parameter_list|)
block|{
comment|//this is expected
block|}
block|}
comment|/**    * Assert that a FileSystem.listStatus on a dir finds the subdir/child entry.    * @param fs filesystem    * @param dir directory to scan    * @param subdir full path to look for    * @throws IOException IO probles    */
DECL|method|assertListStatusFinds (FileSystem fs, Path dir, Path subdir)
specifier|public
specifier|static
name|void
name|assertListStatusFinds
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|dir
parameter_list|,
name|Path
name|subdir
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
index|[]
name|stats
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|boolean
name|found
init|=
literal|false
decl_stmt|;
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|FileStatus
name|stat
range|:
name|stats
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
name|stat
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
name|System
operator|.
name|lineSeparator
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|.
name|getPath
argument_list|()
operator|.
name|equals
argument_list|(
name|subdir
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|assertTrue
argument_list|(
literal|"Path "
operator|+
name|subdir
operator|+
literal|" not found in directory "
operator|+
name|dir
operator|+
literal|":"
operator|+
name|builder
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test for the host being an OSX machine    * @return true if the JVM thinks that is running on OSX    */
DECL|method|isOSX ()
specifier|public
specifier|static
name|boolean
name|isOSX
parameter_list|()
block|{
return|return
name|System
operator|.
name|getProperty
argument_list|(
literal|"os.name"
argument_list|)
operator|.
name|contains
argument_list|(
literal|"OS X"
argument_list|)
return|;
block|}
comment|/**    * compare content of file operations using a double byte array.    * @param concat concatenated files    * @param bytes bytes    */
DECL|method|validateFileContent (byte[] concat, byte[][] bytes)
specifier|public
specifier|static
name|void
name|validateFileContent
parameter_list|(
name|byte
index|[]
name|concat
parameter_list|,
name|byte
index|[]
index|[]
name|bytes
parameter_list|)
block|{
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|boolean
name|mismatch
init|=
literal|false
decl_stmt|;
for|for
control|(
name|byte
index|[]
name|bb
range|:
name|bytes
control|)
block|{
for|for
control|(
name|byte
name|b
range|:
name|bb
control|)
block|{
if|if
condition|(
name|b
operator|!=
name|concat
index|[
name|idx
operator|++
index|]
condition|)
block|{
name|mismatch
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|mismatch
condition|)
break|break;
block|}
name|assertFalse
argument_list|(
literal|"File content of file is not as expected at offset "
operator|+
name|idx
argument_list|,
name|mismatch
argument_list|)
expr_stmt|;
block|}
comment|/**    * Receives test data from the given input file and checks the size of the    * data as well as the pattern inside the received data.    *    * @param fs FileSystem    * @param path Input file to be checked    * @param expectedSize the expected size of the data to be read from the    *        input file in bytes    * @param bufferLen Pattern length    * @param modulus   Pattern modulus    * @throws IOException    *         thrown if an error occurs while reading the data    */
DECL|method|verifyReceivedData (FileSystem fs, Path path, final long expectedSize, final int bufferLen, final int modulus)
specifier|public
specifier|static
name|void
name|verifyReceivedData
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
specifier|final
name|long
name|expectedSize
parameter_list|,
specifier|final
name|int
name|bufferLen
parameter_list|,
specifier|final
name|int
name|modulus
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|byte
index|[]
name|testBuffer
init|=
operator|new
name|byte
index|[
name|bufferLen
index|]
decl_stmt|;
name|long
name|totalBytesRead
init|=
literal|0
decl_stmt|;
name|int
name|nextExpectedNumber
init|=
literal|0
decl_stmt|;
name|NanoTimer
name|timer
init|=
operator|new
name|NanoTimer
argument_list|()
decl_stmt|;
try|try
init|(
name|InputStream
name|inputStream
init|=
name|fs
operator|.
name|open
argument_list|(
name|path
argument_list|)
init|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|bytesRead
init|=
name|inputStream
operator|.
name|read
argument_list|(
name|testBuffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytesRead
operator|<
literal|0
condition|)
block|{
break|break;
block|}
name|totalBytesRead
operator|+=
name|bytesRead
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bytesRead
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|testBuffer
index|[
name|i
index|]
operator|!=
name|nextExpectedNumber
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Read number "
operator|+
name|testBuffer
index|[
name|i
index|]
operator|+
literal|" but expected "
operator|+
name|nextExpectedNumber
argument_list|)
throw|;
block|}
operator|++
name|nextExpectedNumber
expr_stmt|;
if|if
condition|(
name|nextExpectedNumber
operator|==
name|modulus
condition|)
block|{
name|nextExpectedNumber
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|totalBytesRead
operator|!=
name|expectedSize
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Expected to read "
operator|+
name|expectedSize
operator|+
literal|" bytes but only received "
operator|+
name|totalBytesRead
argument_list|)
throw|;
block|}
block|}
name|timer
operator|.
name|end
argument_list|(
literal|"Time to read %d bytes"
argument_list|,
name|expectedSize
argument_list|)
expr_stmt|;
name|bandwidth
argument_list|(
name|timer
argument_list|,
name|expectedSize
argument_list|)
expr_stmt|;
block|}
comment|/**    * Generates test data of the given size according to some specific pattern    * and writes it to the provided output file.    *    * @param fs FileSystem    * @param path Test file to be generated    * @param size The size of the test data to be generated in bytes    * @param bufferLen Pattern length    * @param modulus   Pattern modulus    * @throws IOException    *         thrown if an error occurs while writing the data    */
DECL|method|generateTestFile (FileSystem fs, Path path, final long size, final int bufferLen, final int modulus)
specifier|public
specifier|static
name|long
name|generateTestFile
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
specifier|final
name|long
name|size
parameter_list|,
specifier|final
name|int
name|bufferLen
parameter_list|,
specifier|final
name|int
name|modulus
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|byte
index|[]
name|testBuffer
init|=
operator|new
name|byte
index|[
name|bufferLen
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|testBuffer
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|testBuffer
index|[
name|i
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|i
operator|%
name|modulus
argument_list|)
expr_stmt|;
block|}
name|long
name|bytesWritten
init|=
literal|0
decl_stmt|;
try|try
init|(
name|OutputStream
name|outputStream
init|=
name|fs
operator|.
name|create
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
init|)
block|{
while|while
condition|(
name|bytesWritten
operator|<
name|size
condition|)
block|{
specifier|final
name|long
name|diff
init|=
name|size
operator|-
name|bytesWritten
decl_stmt|;
if|if
condition|(
name|diff
operator|<
name|testBuffer
operator|.
name|length
condition|)
block|{
name|outputStream
operator|.
name|write
argument_list|(
name|testBuffer
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|diff
argument_list|)
expr_stmt|;
name|bytesWritten
operator|+=
name|diff
expr_stmt|;
block|}
else|else
block|{
name|outputStream
operator|.
name|write
argument_list|(
name|testBuffer
argument_list|)
expr_stmt|;
name|bytesWritten
operator|+=
name|testBuffer
operator|.
name|length
expr_stmt|;
block|}
block|}
return|return
name|bytesWritten
return|;
block|}
block|}
comment|/**    * Creates and reads a file with the given size. The test file is generated    * according to a specific pattern so it can be easily verified even if it's    * a multi-GB one.    * During the read phase the incoming data stream is also checked against    * this pattern.    *    * @param fs FileSystem    * @param parent Test file parent dir path    * @throws IOException    *    thrown if an I/O error occurs while writing or reading the test file    */
DECL|method|createAndVerifyFile (FileSystem fs, Path parent, final long fileSize)
specifier|public
specifier|static
name|void
name|createAndVerifyFile
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|parent
parameter_list|,
specifier|final
name|long
name|fileSize
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|testBufferSize
init|=
name|fs
operator|.
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|IO_CHUNK_BUFFER_SIZE
argument_list|,
name|DEFAULT_IO_CHUNK_BUFFER_SIZE
argument_list|)
decl_stmt|;
name|int
name|modulus
init|=
name|fs
operator|.
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|IO_CHUNK_MODULUS_SIZE
argument_list|,
name|DEFAULT_IO_CHUNK_MODULUS_SIZE
argument_list|)
decl_stmt|;
specifier|final
name|String
name|objectName
init|=
name|UUID
operator|.
name|randomUUID
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|objectPath
init|=
operator|new
name|Path
argument_list|(
name|parent
argument_list|,
name|objectName
argument_list|)
decl_stmt|;
comment|// Write test file in a specific pattern
name|NanoTimer
name|timer
init|=
operator|new
name|NanoTimer
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|fileSize
argument_list|,
name|generateTestFile
argument_list|(
name|fs
argument_list|,
name|objectPath
argument_list|,
name|fileSize
argument_list|,
name|testBufferSize
argument_list|,
name|modulus
argument_list|)
argument_list|)
expr_stmt|;
name|assertPathExists
argument_list|(
name|fs
argument_list|,
literal|"not created successful"
argument_list|,
name|objectPath
argument_list|)
expr_stmt|;
name|timer
operator|.
name|end
argument_list|(
literal|"Time to write %d bytes"
argument_list|,
name|fileSize
argument_list|)
expr_stmt|;
name|bandwidth
argument_list|(
name|timer
argument_list|,
name|fileSize
argument_list|)
expr_stmt|;
comment|// Now read the same file back and verify its content
try|try
block|{
name|verifyReceivedData
argument_list|(
name|fs
argument_list|,
name|objectPath
argument_list|,
name|fileSize
argument_list|,
name|testBufferSize
argument_list|,
name|modulus
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// Delete test file
name|fs
operator|.
name|delete
argument_list|(
name|objectPath
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Make times more readable, by adding a "," every three digits.    * @param nanos nanos or other large number    * @return a string for logging    */
DECL|method|toHuman (long nanos)
specifier|public
specifier|static
name|String
name|toHuman
parameter_list|(
name|long
name|nanos
parameter_list|)
block|{
return|return
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ENGLISH
argument_list|,
literal|"%,d"
argument_list|,
name|nanos
argument_list|)
return|;
block|}
comment|/**    * Log the bandwidth of a timer as inferred from the number of    * bytes processed.    * @param timer timer    * @param bytes bytes processed in the time period    */
DECL|method|bandwidth (NanoTimer timer, long bytes)
specifier|public
specifier|static
name|void
name|bandwidth
parameter_list|(
name|NanoTimer
name|timer
parameter_list|,
name|long
name|bytes
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Bandwidth = {}  MB/S"
argument_list|,
name|timer
operator|.
name|bandwidthDescription
argument_list|(
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Work out the bandwidth in MB/s.    * @param bytes bytes    * @param durationNS duration in nanos    * @return the number of megabytes/second of the recorded operation    */
DECL|method|bandwidthMBs (long bytes, long durationNS)
specifier|public
specifier|static
name|double
name|bandwidthMBs
parameter_list|(
name|long
name|bytes
parameter_list|,
name|long
name|durationNS
parameter_list|)
block|{
return|return
name|bytes
operator|/
operator|(
literal|1024.0
operator|*
literal|1024
operator|)
operator|*
literal|1.0e9
operator|/
name|durationNS
return|;
block|}
comment|/**    * Recursively create a directory tree.    * Return the details about the created tree. The files and directories    * are those created under the path, not the base directory created. That    * is retrievable via {@link TreeScanResults#getBasePath()}.    * @param fs filesystem    * @param current parent dir    * @param depth depth of directory tree    * @param width width: subdirs per entry    * @param files number of files per entry    * @param filesize size of files to create in bytes.    * @return the details about the created tree.    * @throws IOException IO Problems    */
DECL|method|createSubdirs (FileSystem fs, Path current, int depth, int width, int files, int filesize)
specifier|public
specifier|static
name|TreeScanResults
name|createSubdirs
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|current
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|files
parameter_list|,
name|int
name|filesize
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createSubdirs
argument_list|(
name|fs
argument_list|,
name|current
argument_list|,
name|depth
argument_list|,
name|width
argument_list|,
name|files
argument_list|,
name|filesize
argument_list|,
literal|"dir-"
argument_list|,
literal|"file-"
argument_list|,
literal|"0"
argument_list|)
return|;
block|}
comment|/**    * Recursively create a directory tree.    * @param fs filesystem    * @param current the current dir in the walk    * @param depth depth of directory tree    * @param width width: subdirs per entry    * @param files number of files per entry    * @param filesize size of files to create in bytes.    * @param dirPrefix prefix for directory entries    * @param filePrefix prefix for file entries    * @param marker string which is slowly built up to uniquely name things    * @return the details about the created tree.    * @throws IOException IO Problems    */
DECL|method|createSubdirs (FileSystem fs, Path current, int depth, int width, int files, int filesize, String dirPrefix, String filePrefix, String marker)
specifier|public
specifier|static
name|TreeScanResults
name|createSubdirs
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|current
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|files
parameter_list|,
name|int
name|filesize
parameter_list|,
name|String
name|dirPrefix
parameter_list|,
name|String
name|filePrefix
parameter_list|,
name|String
name|marker
parameter_list|)
throws|throws
name|IOException
block|{
name|fs
operator|.
name|mkdirs
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|TreeScanResults
name|results
init|=
operator|new
name|TreeScanResults
argument_list|(
name|current
argument_list|)
decl_stmt|;
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
name|byte
index|[]
name|data
init|=
name|dataset
argument_list|(
name|filesize
argument_list|,
literal|'a'
argument_list|,
literal|'z'
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|files
condition|;
name|i
operator|++
control|)
block|{
name|String
name|name
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%s-%s-%04d.txt"
argument_list|,
name|filePrefix
argument_list|,
name|marker
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
name|current
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|createFile
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
literal|true
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|results
operator|.
name|add
argument_list|(
name|fs
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|w
init|=
literal|0
init|;
name|w
operator|<
name|width
condition|;
name|w
operator|++
control|)
block|{
name|String
name|marker2
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%s-%04d"
argument_list|,
name|marker
argument_list|,
name|w
argument_list|)
decl_stmt|;
name|Path
name|child
init|=
operator|new
name|Path
argument_list|(
name|current
argument_list|,
name|dirPrefix
operator|+
name|marker2
argument_list|)
decl_stmt|;
name|results
operator|.
name|add
argument_list|(
name|createSubdirs
argument_list|(
name|fs
argument_list|,
name|child
argument_list|,
name|depth
operator|-
literal|1
argument_list|,
name|width
argument_list|,
name|files
argument_list|,
name|filesize
argument_list|,
name|dirPrefix
argument_list|,
name|filePrefix
argument_list|,
name|marker2
argument_list|)
argument_list|)
expr_stmt|;
name|results
operator|.
name|add
argument_list|(
name|fs
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|results
return|;
block|}
comment|/**    * Predicate to determine if two lists are equivalent, that is, they    * contain the same entries.    * @param left first collection of paths    * @param right second collection of paths    * @return true if all entries are in each collection of path.    */
DECL|method|collectionsEquivalent (Collection<Path> left, Collection<Path> right)
specifier|public
specifier|static
name|boolean
name|collectionsEquivalent
parameter_list|(
name|Collection
argument_list|<
name|Path
argument_list|>
name|left
parameter_list|,
name|Collection
argument_list|<
name|Path
argument_list|>
name|right
parameter_list|)
block|{
name|Set
argument_list|<
name|Path
argument_list|>
name|leftSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|left
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|Path
argument_list|>
name|rightSet
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|right
argument_list|)
decl_stmt|;
return|return
name|leftSet
operator|.
name|containsAll
argument_list|(
name|right
argument_list|)
operator|&&
name|rightSet
operator|.
name|containsAll
argument_list|(
name|left
argument_list|)
return|;
block|}
comment|/**    * Take a collection of paths and build a string from them: useful    * for assertion messages.    * @param paths paths to stringify    * @return a string representation    */
DECL|method|pathsToString (Collection<Path> paths)
specifier|public
specifier|static
name|String
name|pathsToString
parameter_list|(
name|Collection
argument_list|<
name|Path
argument_list|>
name|paths
parameter_list|)
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
name|paths
operator|.
name|size
argument_list|()
operator|*
literal|100
argument_list|)
decl_stmt|;
name|String
name|nl
init|=
name|System
operator|.
name|lineSeparator
argument_list|()
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
name|nl
argument_list|)
expr_stmt|;
for|for
control|(
name|Path
name|path
range|:
name|paths
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"  \""
argument_list|)
operator|.
name|append
argument_list|(
name|path
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\""
argument_list|)
operator|.
name|append
argument_list|(
name|nl
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Predicate to determine if two lists are equivalent, that is, they    * contain the same entries.    * @param left first collection of paths    * @param right second collection of paths    * @return true if all entries are in each collection of path.    */
DECL|method|collectionsEquivalentNoDuplicates (Collection<Path> left, Collection<Path> right)
specifier|public
specifier|static
name|boolean
name|collectionsEquivalentNoDuplicates
parameter_list|(
name|Collection
argument_list|<
name|Path
argument_list|>
name|left
parameter_list|,
name|Collection
argument_list|<
name|Path
argument_list|>
name|right
parameter_list|)
block|{
return|return
name|collectionsEquivalent
argument_list|(
name|left
argument_list|,
name|right
argument_list|)
operator|&&
operator|!
name|containsDuplicates
argument_list|(
name|left
argument_list|)
operator|&&
operator|!
name|containsDuplicates
argument_list|(
name|right
argument_list|)
return|;
block|}
comment|/**    * Predicate to test for a collection of paths containing duplicate entries.    * @param paths collection of paths    * @return true if there are duplicates.    */
DECL|method|containsDuplicates (Collection<Path> paths)
specifier|public
specifier|static
name|boolean
name|containsDuplicates
parameter_list|(
name|Collection
argument_list|<
name|Path
argument_list|>
name|paths
parameter_list|)
block|{
return|return
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|paths
argument_list|)
operator|.
name|size
argument_list|()
operator|!=
name|paths
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**    * Get the status of a path eventually, even if the FS doesn't have create    * consistency. If the path is not there by the time the timeout completes,    * an assertion is raised.    * @param fs FileSystem    * @param path path to look for    * @param timeout timeout in milliseconds    * @return the status    * @throws IOException if an I/O error occurs while writing or reading the    * test file<i>other than file not found</i>    */
DECL|method|getFileStatusEventually (FileSystem fs, Path path, int timeout)
specifier|public
specifier|static
name|FileStatus
name|getFileStatusEventually
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|,
name|int
name|timeout
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|long
name|endTime
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|+
name|timeout
decl_stmt|;
name|FileStatus
name|stat
init|=
literal|null
decl_stmt|;
do|do
block|{
try|try
block|{
name|stat
operator|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
if|if
condition|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|>
name|endTime
condition|)
block|{
comment|// timeout, raise an assert with more diagnostics
name|assertPathExists
argument_list|(
name|fs
argument_list|,
literal|"Path not found after "
operator|+
name|timeout
operator|+
literal|" mS"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|stat
operator|==
literal|null
condition|)
do|;
return|return
name|stat
return|;
block|}
comment|/**    * Recursively list all entries, with a depth first traversal of the    * directory tree.    * @param path path    * @return the number of entries listed    * @throws IOException IO problems    */
DECL|method|treeWalk (FileSystem fs, Path path)
specifier|public
specifier|static
name|TreeScanResults
name|treeWalk
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|TreeScanResults
name|dirsAndFiles
init|=
operator|new
name|TreeScanResults
argument_list|()
decl_stmt|;
name|FileStatus
index|[]
name|statuses
init|=
name|fs
operator|.
name|listStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|status
range|:
name|statuses
control|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"{}{}"
argument_list|,
name|status
operator|.
name|getPath
argument_list|()
argument_list|,
name|status
operator|.
name|isDirectory
argument_list|()
condition|?
literal|"*"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|FileStatus
name|status
range|:
name|statuses
control|)
block|{
name|dirsAndFiles
operator|.
name|add
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|dirsAndFiles
operator|.
name|add
argument_list|(
name|treeWalk
argument_list|(
name|fs
argument_list|,
name|status
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dirsAndFiles
return|;
block|}
comment|/**    * Convert a remote iterator over file status results into a list.    * The utility equivalents in commons collection and guava cannot be    * used here, as this is a different interface, one whose operators    * can throw IOEs.    * @param iterator input iterator    * @return the status entries as a list.    * @throws IOException    */
DECL|method|toList ( RemoteIterator<LocatedFileStatus> iterator)
specifier|public
specifier|static
name|List
argument_list|<
name|LocatedFileStatus
argument_list|>
name|toList
parameter_list|(
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|iterator
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|LocatedFileStatus
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
comment|/**    * Convert a remote iterator over file status results into a list.    * This uses {@link RemoteIterator#next()} calls only, expecting    * a raised {@link NoSuchElementException} exception to indicate that    * the end of the listing has been reached. This iteration strategy is    * designed to verify that the implementation of the remote iterator    * generates results and terminates consistently with the {@code hasNext/next}    * iteration. More succinctly "verifies that the {@code next()} operator    * isn't relying on {@code hasNext()} to always be called during an iteration.    * @param iterator input iterator    * @return the status entries as a list.    * @throws IOException IO problems    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"InfiniteLoopStatement"
argument_list|)
DECL|method|toListThroughNextCallsAlone ( RemoteIterator<LocatedFileStatus> iterator)
specifier|public
specifier|static
name|List
argument_list|<
name|LocatedFileStatus
argument_list|>
name|toListThroughNextCallsAlone
parameter_list|(
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|iterator
parameter_list|)
throws|throws
name|IOException
block|{
name|ArrayList
argument_list|<
name|LocatedFileStatus
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
try|try
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NoSuchElementException
name|expected
parameter_list|)
block|{
comment|// ignored
block|}
return|return
name|list
return|;
block|}
comment|/**    * Results of recursive directory creation/scan operations.    */
DECL|class|TreeScanResults
specifier|public
specifier|static
specifier|final
class|class
name|TreeScanResults
block|{
DECL|field|basePath
specifier|private
name|Path
name|basePath
decl_stmt|;
DECL|field|files
specifier|private
specifier|final
name|List
argument_list|<
name|Path
argument_list|>
name|files
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|directories
specifier|private
specifier|final
name|List
argument_list|<
name|Path
argument_list|>
name|directories
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|other
specifier|private
specifier|final
name|List
argument_list|<
name|Path
argument_list|>
name|other
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|TreeScanResults ()
specifier|public
name|TreeScanResults
parameter_list|()
block|{     }
DECL|method|TreeScanResults (Path basePath)
specifier|public
name|TreeScanResults
parameter_list|(
name|Path
name|basePath
parameter_list|)
block|{
name|this
operator|.
name|basePath
operator|=
name|basePath
expr_stmt|;
block|}
comment|/**      * Build from a located file status iterator.      * @param results results of the listFiles/listStatus call.      * @throws IOException IO problems during the iteration.      */
DECL|method|TreeScanResults (RemoteIterator<LocatedFileStatus> results)
specifier|public
name|TreeScanResults
parameter_list|(
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|results
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
name|results
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|add
argument_list|(
name|results
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Construct results from an array of statistics.      * @param stats statistics array. Must not be null.      */
DECL|method|TreeScanResults (FileStatus[] stats)
specifier|public
name|TreeScanResults
parameter_list|(
name|FileStatus
index|[]
name|stats
parameter_list|)
block|{
name|assertNotNull
argument_list|(
literal|"Null file status array"
argument_list|,
name|stats
argument_list|)
expr_stmt|;
for|for
control|(
name|FileStatus
name|stat
range|:
name|stats
control|)
block|{
name|add
argument_list|(
name|stat
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Construct results from an iterable collection of statistics.      * @param stats statistics source. Must not be null.      */
DECL|method|TreeScanResults (Iterable<F> stats)
specifier|public
parameter_list|<
name|F
extends|extends
name|FileStatus
parameter_list|>
name|TreeScanResults
parameter_list|(
name|Iterable
argument_list|<
name|F
argument_list|>
name|stats
parameter_list|)
block|{
for|for
control|(
name|FileStatus
name|stat
range|:
name|stats
control|)
block|{
name|add
argument_list|(
name|stat
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Add all paths in the other set of results to this instance.      * @param that the other instance      * @return this instance      */
DECL|method|add (TreeScanResults that)
specifier|public
name|TreeScanResults
name|add
parameter_list|(
name|TreeScanResults
name|that
parameter_list|)
block|{
name|files
operator|.
name|addAll
argument_list|(
name|that
operator|.
name|files
argument_list|)
expr_stmt|;
name|directories
operator|.
name|addAll
argument_list|(
name|that
operator|.
name|directories
argument_list|)
expr_stmt|;
name|other
operator|.
name|addAll
argument_list|(
name|that
operator|.
name|other
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Increment the counters based on the file status.      * @param status path status to count.      */
DECL|method|add (FileStatus status)
specifier|public
name|void
name|add
parameter_list|(
name|FileStatus
name|status
parameter_list|)
block|{
if|if
condition|(
name|status
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|files
operator|.
name|add
argument_list|(
name|status
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|directories
operator|.
name|add
argument_list|(
name|status
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|other
operator|.
name|add
argument_list|(
name|status
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|add (FileSystem fs, Path path)
specifier|public
name|void
name|add
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|add
argument_list|(
name|fs
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%d director%s and %d file%s"
argument_list|,
name|getDirCount
argument_list|()
argument_list|,
name|getDirCount
argument_list|()
operator|==
literal|1
condition|?
literal|"y"
else|:
literal|"ies"
argument_list|,
name|getFileCount
argument_list|()
argument_list|,
name|getFileCount
argument_list|()
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
return|;
block|}
comment|/**      * Equality check compares files and directory counts.      * As these are non-final fields, this class cannot be used in      * hash tables.      * @param o other object      * @return true iff the file and dir count match.      */
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|TreeScanResults
name|that
init|=
operator|(
name|TreeScanResults
operator|)
name|o
decl_stmt|;
return|return
name|getFileCount
argument_list|()
operator|==
name|that
operator|.
name|getFileCount
argument_list|()
operator|&&
name|getDirCount
argument_list|()
operator|==
name|that
operator|.
name|getDirCount
argument_list|()
return|;
block|}
comment|/**      * This is a spurious hash code subclass to keep findbugs quiet.      * @return the base {@link Object#hashCode()}      */
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|super
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|/**      * Assert that the state of a listing has the specific number of files,      * directories and other entries. The error text will include      * the {@code text} param, the field in question, and the entire object's      * string value.      * @param text text prefix for assertions.      * @param f file count      * @param d expected directory count      * @param o expected other entries.      */
DECL|method|assertSizeEquals (String text, long f, long d, long o)
specifier|public
name|void
name|assertSizeEquals
parameter_list|(
name|String
name|text
parameter_list|,
name|long
name|f
parameter_list|,
name|long
name|d
parameter_list|,
name|long
name|o
parameter_list|)
block|{
name|String
name|self
init|=
name|toString
argument_list|()
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|text
operator|+
literal|": file count in "
operator|+
name|self
argument_list|,
name|f
argument_list|,
name|getFileCount
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|text
operator|+
literal|": directory count in "
operator|+
name|self
argument_list|,
name|d
argument_list|,
name|getDirCount
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|text
operator|+
literal|": 'other' count in "
operator|+
name|self
argument_list|,
name|o
argument_list|,
name|getOtherCount
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Assert that the trees are equivalent: that every list matches (and      * that neither has any duplicates).      * @param that the other entry      */
DECL|method|assertEquivalent (TreeScanResults that)
specifier|public
name|void
name|assertEquivalent
parameter_list|(
name|TreeScanResults
name|that
parameter_list|)
block|{
name|assertFieldsEquivalent
argument_list|(
literal|"files"
argument_list|,
name|that
argument_list|,
name|files
argument_list|,
name|that
operator|.
name|files
argument_list|)
expr_stmt|;
name|assertFieldsEquivalent
argument_list|(
literal|"directories"
argument_list|,
name|that
argument_list|,
name|directories
argument_list|,
name|that
operator|.
name|directories
argument_list|)
expr_stmt|;
name|assertFieldsEquivalent
argument_list|(
literal|"other"
argument_list|,
name|that
argument_list|,
name|other
argument_list|,
name|that
operator|.
name|other
argument_list|)
expr_stmt|;
block|}
comment|/**      * Assert that a field in two instances are equivalent.      * @param fieldname field name for error messages      * @param that the other instance to scan      * @param ours our field's contents      * @param theirs the other instance's field constants      */
DECL|method|assertFieldsEquivalent (String fieldname, TreeScanResults that, List<Path> ours, List<Path> theirs)
specifier|public
name|void
name|assertFieldsEquivalent
parameter_list|(
name|String
name|fieldname
parameter_list|,
name|TreeScanResults
name|that
parameter_list|,
name|List
argument_list|<
name|Path
argument_list|>
name|ours
parameter_list|,
name|List
argument_list|<
name|Path
argument_list|>
name|theirs
parameter_list|)
block|{
name|String
name|ourList
init|=
name|pathsToString
argument_list|(
name|ours
argument_list|)
decl_stmt|;
name|String
name|theirList
init|=
name|pathsToString
argument_list|(
name|theirs
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
literal|"Duplicate  "
operator|+
name|fieldname
operator|+
literal|" in "
operator|+
name|this
operator|+
literal|": "
operator|+
name|ourList
argument_list|,
name|containsDuplicates
argument_list|(
name|ours
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
literal|"Duplicate  "
operator|+
name|fieldname
operator|+
literal|" in other "
operator|+
name|that
operator|+
literal|": "
operator|+
name|theirList
argument_list|,
name|containsDuplicates
argument_list|(
name|theirs
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|fieldname
operator|+
literal|" mismatch: between "
operator|+
name|ourList
operator|+
literal|" and "
operator|+
name|theirList
argument_list|,
name|collectionsEquivalent
argument_list|(
name|ours
argument_list|,
name|theirs
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|getFiles ()
specifier|public
name|List
argument_list|<
name|Path
argument_list|>
name|getFiles
parameter_list|()
block|{
return|return
name|files
return|;
block|}
DECL|method|getDirectories ()
specifier|public
name|List
argument_list|<
name|Path
argument_list|>
name|getDirectories
parameter_list|()
block|{
return|return
name|directories
return|;
block|}
DECL|method|getOther ()
specifier|public
name|List
argument_list|<
name|Path
argument_list|>
name|getOther
parameter_list|()
block|{
return|return
name|other
return|;
block|}
DECL|method|getBasePath ()
specifier|public
name|Path
name|getBasePath
parameter_list|()
block|{
return|return
name|basePath
return|;
block|}
DECL|method|getFileCount ()
specifier|public
name|long
name|getFileCount
parameter_list|()
block|{
return|return
name|files
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|getDirCount ()
specifier|public
name|long
name|getDirCount
parameter_list|()
block|{
return|return
name|directories
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|getOtherCount ()
specifier|public
name|long
name|getOtherCount
parameter_list|()
block|{
return|return
name|other
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Total count of entries.      * @return the total number of entries      */
DECL|method|totalCount ()
specifier|public
name|long
name|totalCount
parameter_list|()
block|{
return|return
name|getFileCount
argument_list|()
operator|+
name|getDirCount
argument_list|()
operator|+
name|getOtherCount
argument_list|()
return|;
block|}
block|}
comment|/**    * A simple class for timing operations in nanoseconds, and for    * printing some useful results in the process.    */
DECL|class|NanoTimer
specifier|public
specifier|static
specifier|final
class|class
name|NanoTimer
block|{
DECL|field|startTime
specifier|private
specifier|final
name|long
name|startTime
decl_stmt|;
DECL|field|endTime
specifier|private
name|long
name|endTime
decl_stmt|;
DECL|method|NanoTimer ()
specifier|public
name|NanoTimer
parameter_list|()
block|{
name|startTime
operator|=
name|now
argument_list|()
expr_stmt|;
block|}
comment|/**      * End the operation.      * @return the duration of the operation      */
DECL|method|end ()
specifier|public
name|long
name|end
parameter_list|()
block|{
name|endTime
operator|=
name|now
argument_list|()
expr_stmt|;
return|return
name|duration
argument_list|()
return|;
block|}
comment|/**      * End the operation; log the duration.      * @param format message      * @param args any arguments      * @return the duration of the operation      */
DECL|method|end (String format, Object... args)
specifier|public
name|long
name|end
parameter_list|(
name|String
name|format
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
block|{
name|long
name|d
init|=
name|end
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Duration of {}: {} nS"
argument_list|,
name|String
operator|.
name|format
argument_list|(
name|format
argument_list|,
name|args
argument_list|)
argument_list|,
name|toHuman
argument_list|(
name|d
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
DECL|method|now ()
specifier|public
name|long
name|now
parameter_list|()
block|{
return|return
name|System
operator|.
name|nanoTime
argument_list|()
return|;
block|}
DECL|method|duration ()
specifier|public
name|long
name|duration
parameter_list|()
block|{
return|return
name|endTime
operator|-
name|startTime
return|;
block|}
comment|/**      * Intermediate duration of the operation.      * @return how much time has passed since the start (in nanos).      */
DECL|method|elapsedTime ()
specifier|public
name|long
name|elapsedTime
parameter_list|()
block|{
return|return
name|now
argument_list|()
operator|-
name|startTime
return|;
block|}
DECL|method|bandwidth (long bytes)
specifier|public
name|double
name|bandwidth
parameter_list|(
name|long
name|bytes
parameter_list|)
block|{
return|return
name|bandwidthMBs
argument_list|(
name|bytes
argument_list|,
name|duration
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Bandwidth as bytes per second.      * @param bytes bytes in      * @return the number of bytes per second this operation.      *         0 if duration == 0.      */
DECL|method|bandwidthBytes (long bytes)
specifier|public
name|double
name|bandwidthBytes
parameter_list|(
name|long
name|bytes
parameter_list|)
block|{
name|double
name|duration
init|=
name|duration
argument_list|()
decl_stmt|;
return|return
name|duration
operator|>
literal|0
condition|?
name|bytes
operator|/
name|duration
else|:
literal|0
return|;
block|}
comment|/**      * How many nanoseconds per IOP, byte, etc.      * @param operations operations processed in this time period      * @return the nanoseconds it took each byte to be processed      */
DECL|method|nanosPerOperation (long operations)
specifier|public
name|long
name|nanosPerOperation
parameter_list|(
name|long
name|operations
parameter_list|)
block|{
return|return
name|duration
argument_list|()
operator|/
name|operations
return|;
block|}
comment|/**      * Get a description of the bandwidth, even down to fractions of      * a MB.      * @param bytes bytes processed      * @return bandwidth      */
DECL|method|bandwidthDescription (long bytes)
specifier|public
name|String
name|bandwidthDescription
parameter_list|(
name|long
name|bytes
parameter_list|)
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"%,.6f"
argument_list|,
name|bandwidth
argument_list|(
name|bytes
argument_list|)
argument_list|)
return|;
block|}
DECL|method|getStartTime ()
specifier|public
name|long
name|getStartTime
parameter_list|()
block|{
return|return
name|startTime
return|;
block|}
DECL|method|getEndTime ()
specifier|public
name|long
name|getEndTime
parameter_list|()
block|{
return|return
name|endTime
return|;
block|}
block|}
block|}
end_class

end_unit

