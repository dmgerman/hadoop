begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.test
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_comment
comment|/**  * Class containing methods and associated classes to make the most of Lambda  * expressions in Hadoop tests.  *  * The code has been designed from the outset to be Java-8 friendly, but  * to still be usable in Java 7.  *  * The code is modelled on {@code GenericTestUtils#waitFor(Supplier, int, int)},  * but also lifts concepts from Scalatest's {@code awaitResult} and  * its notion of pluggable retry logic (simple, backoff, maybe even things  * with jitter: test author gets to choose).  * The {@link #intercept(Class, Callable)} method is also all credit due  * Scalatest, though it's been extended to also support a string message  * check; useful when checking the contents of the exception.  */
end_comment

begin_class
DECL|class|LambdaTestUtils
specifier|public
specifier|final
class|class
name|LambdaTestUtils
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|LambdaTestUtils
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|method|LambdaTestUtils ()
specifier|private
name|LambdaTestUtils
parameter_list|()
block|{   }
comment|/**    * This is the string included in the assertion text in    * {@link #intercept(Class, Callable)} if    * the closure returned a null value.    */
DECL|field|NULL_RESULT
specifier|public
specifier|static
specifier|final
name|String
name|NULL_RESULT
init|=
literal|"(null)"
decl_stmt|;
comment|/**    * Interface to implement for converting a timeout into some form    * of exception to raise.    */
annotation|@
name|FunctionalInterface
DECL|interface|TimeoutHandler
specifier|public
interface|interface
name|TimeoutHandler
block|{
comment|/**      * Create an exception (or throw one, if desired).      * @param timeoutMillis timeout which has arisen      * @param caught any exception which was caught; may be null      * @return an exception which will then be thrown      * @throws Exception if the handler wishes to raise an exception      * that way.      */
DECL|method|evaluate (int timeoutMillis, Throwable caught)
name|Throwable
name|evaluate
parameter_list|(
name|int
name|timeoutMillis
parameter_list|,
name|Throwable
name|caught
parameter_list|)
throws|throws
name|Throwable
function_decl|;
block|}
comment|/**    * Wait for a condition to be met, with a retry policy returning the    * sleep time before the next attempt is made. If, at the end    * of the timeout period, the condition is still false (or failing with    * an exception), the timeout handler is invoked, passing in the timeout    * and any exception raised in the last invocation. The exception returned    * by this timeout handler is then rethrown.    *<p>    * Example: Wait 30s for a condition to be met, with a sleep of 30s    * between each probe.    * If the operation is failing, then, after 30s, the timeout handler    * is called. This returns the exception passed in (if any),    * or generates a new one.    *<pre>    * await(    *   30 * 1000,    *   () -> { return 0 == filesystem.listFiles(new Path("/")).length); },    *   () -> 500),    *   (timeout, ex) -> ex != null ? ex : new TimeoutException("timeout"));    *</pre>    *    * @param timeoutMillis timeout in milliseconds.    * Can be zero, in which case only one attempt is made.    * @param check predicate to evaluate    * @param retry retry escalation logic    * @param timeoutHandler handler invoked on timeout;    * the returned exception will be thrown    * @return the number of iterations before the condition was satisfied    * @throws Exception the exception returned by {@code timeoutHandler} on    * timeout    * @throws FailFastException immediately if the evaluated operation raises it    * @throws InterruptedException if interrupted.    */
DECL|method|await (int timeoutMillis, Callable<Boolean> check, Callable<Integer> retry, TimeoutHandler timeoutHandler)
specifier|public
specifier|static
name|int
name|await
parameter_list|(
name|int
name|timeoutMillis
parameter_list|,
name|Callable
argument_list|<
name|Boolean
argument_list|>
name|check
parameter_list|,
name|Callable
argument_list|<
name|Integer
argument_list|>
name|retry
parameter_list|,
name|TimeoutHandler
name|timeoutHandler
parameter_list|)
throws|throws
name|Exception
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|timeoutMillis
operator|>=
literal|0
argument_list|,
literal|"timeoutMillis must be>= 0"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|timeoutHandler
argument_list|)
expr_stmt|;
name|long
name|endTime
init|=
name|Time
operator|.
name|now
argument_list|()
operator|+
name|timeoutMillis
decl_stmt|;
name|Throwable
name|ex
init|=
literal|null
decl_stmt|;
name|boolean
name|running
init|=
literal|true
decl_stmt|;
name|int
name|iterations
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|running
condition|)
block|{
name|iterations
operator|++
expr_stmt|;
try|try
block|{
if|if
condition|(
name|check
operator|.
name|call
argument_list|()
condition|)
block|{
return|return
name|iterations
return|;
block|}
comment|// the probe failed but did not raise an exception. Reset any
comment|// exception raised by a previous probe failure.
name|ex
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
decl||
name|FailFastException
decl||
name|VirtualMachineError
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"eventually() iteration {}"
argument_list|,
name|iterations
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|ex
operator|=
name|e
expr_stmt|;
block|}
name|running
operator|=
name|Time
operator|.
name|now
argument_list|()
operator|<
name|endTime
expr_stmt|;
if|if
condition|(
name|running
condition|)
block|{
name|int
name|sleeptime
init|=
name|retry
operator|.
name|call
argument_list|()
decl_stmt|;
if|if
condition|(
name|sleeptime
operator|>=
literal|0
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleeptime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|running
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
comment|// timeout
name|Throwable
name|evaluate
decl_stmt|;
try|try
block|{
name|evaluate
operator|=
name|timeoutHandler
operator|.
name|evaluate
argument_list|(
name|timeoutMillis
argument_list|,
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|evaluate
operator|==
literal|null
condition|)
block|{
comment|// bad timeout handler logic; fall back to GenerateTimeout so the
comment|// underlying problem isn't lost.
name|LOG
operator|.
name|error
argument_list|(
literal|"timeout handler {} did not throw an exception "
argument_list|,
name|timeoutHandler
argument_list|)
expr_stmt|;
name|evaluate
operator|=
operator|new
name|GenerateTimeout
argument_list|()
operator|.
name|evaluate
argument_list|(
name|timeoutMillis
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|throwable
parameter_list|)
block|{
name|evaluate
operator|=
name|throwable
expr_stmt|;
block|}
return|return
name|raise
argument_list|(
name|evaluate
argument_list|)
return|;
block|}
comment|/**    * Simplified {@link #await(int, Callable, Callable, TimeoutHandler)}    * operation with a fixed interval    * and {@link GenerateTimeout} handler to generate a {@code TimeoutException}.    *<p>    * Example: await for probe to succeed:    *<pre>    * await(    *   30 * 1000, 500,    *   () -> { return 0 == filesystem.listFiles(new Path("/")).length); });    *</pre>    *    * @param timeoutMillis timeout in milliseconds.    * Can be zero, in which case only one attempt is made.    * @param intervalMillis interval in milliseconds between checks    * @param check predicate to evaluate    * @return the number of iterations before the condition was satisfied    * @throws Exception returned by {@code failure} on timeout    * @throws FailFastException immediately if the evaluated operation raises it    * @throws InterruptedException if interrupted.    */
DECL|method|await (int timeoutMillis, int intervalMillis, Callable<Boolean> check)
specifier|public
specifier|static
name|int
name|await
parameter_list|(
name|int
name|timeoutMillis
parameter_list|,
name|int
name|intervalMillis
parameter_list|,
name|Callable
argument_list|<
name|Boolean
argument_list|>
name|check
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|await
argument_list|(
name|timeoutMillis
argument_list|,
name|check
argument_list|,
operator|new
name|FixedRetryInterval
argument_list|(
name|intervalMillis
argument_list|)
argument_list|,
operator|new
name|GenerateTimeout
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Repeatedly execute a closure until it returns a value rather than    * raise an exception.    * Exceptions are caught and, with one exception,    * trigger a sleep and retry. This is similar of ScalaTest's    * {@code eventually(timeout, closure)} operation, though that lacks    * the ability to fail fast if the inner closure has determined that    * a failure condition is non-recoverable.    *<p>    * Example: spin until an the number of files in a filesystem is non-zero,    * returning the files found.    * The sleep interval backs off by 500 ms each iteration to a maximum of 5s.    *<pre>    * FileStatus[] files = eventually( 30 * 1000,    *   () -> {    *     FileStatus[] f = filesystem.listFiles(new Path("/"));    *     assertEquals(0, f.length);    *     return f;    *   },    *   new ProportionalRetryInterval(500, 5000));    *</pre>    * This allows for a fast exit, yet reduces probe frequency over time.    *    * @param<T> return type    * @param timeoutMillis timeout in milliseconds.    * Can be zero, in which case only one attempt is made before failing.    * @param eval expression to evaluate    * @param retry retry interval generator    * @return result of the first successful eval call    * @throws Exception the last exception thrown before timeout was triggered    * @throws FailFastException if raised -without any retry attempt.    * @throws InterruptedException if interrupted during the sleep operation.    * @throws OutOfMemoryError you've run out of memory.    */
DECL|method|eventually (int timeoutMillis, Callable<T> eval, Callable<Integer> retry)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|eventually
parameter_list|(
name|int
name|timeoutMillis
parameter_list|,
name|Callable
argument_list|<
name|T
argument_list|>
name|eval
parameter_list|,
name|Callable
argument_list|<
name|Integer
argument_list|>
name|retry
parameter_list|)
throws|throws
name|Exception
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|timeoutMillis
operator|>=
literal|0
argument_list|,
literal|"timeoutMillis must be>= 0"
argument_list|)
expr_stmt|;
name|long
name|endTime
init|=
name|Time
operator|.
name|now
argument_list|()
operator|+
name|timeoutMillis
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
name|boolean
name|running
decl_stmt|;
name|int
name|sleeptime
decl_stmt|;
name|int
name|iterations
init|=
literal|0
decl_stmt|;
do|do
block|{
name|iterations
operator|++
expr_stmt|;
try|try
block|{
return|return
name|eval
operator|.
name|call
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
decl||
name|FailFastException
decl||
name|VirtualMachineError
name|e
parameter_list|)
block|{
comment|// these two exceptions trigger an immediate exit
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"evaluate() iteration {}"
argument_list|,
name|iterations
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|ex
operator|=
name|e
expr_stmt|;
block|}
name|running
operator|=
name|Time
operator|.
name|now
argument_list|()
operator|<
name|endTime
expr_stmt|;
if|if
condition|(
name|running
operator|&&
operator|(
name|sleeptime
operator|=
name|retry
operator|.
name|call
argument_list|()
operator|)
operator|>=
literal|0
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleeptime
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|running
condition|)
do|;
comment|// timeout. Throw the last exception raised
return|return
name|raise
argument_list|(
name|ex
argument_list|)
return|;
block|}
comment|/**    * Take the throwable and raise it as an exception or an error, depending    * upon its type. This allows callers to declare that they only throw    * Exception (i.e. can be invoked by Callable) yet still rethrow a    * previously caught Throwable.    * @param throwable Throwable to rethrow    * @param<T> expected return type    * @return never    * @throws Exception if throwable is an Exception    * @throws Error if throwable is not an Exception    */
DECL|method|raise (Throwable throwable)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|raise
parameter_list|(
name|Throwable
name|throwable
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|throwable
operator|instanceof
name|Exception
condition|)
block|{
throw|throw
operator|(
name|Exception
operator|)
name|throwable
throw|;
block|}
else|else
block|{
throw|throw
operator|(
name|Error
operator|)
name|throwable
throw|;
block|}
block|}
comment|/**    * Variant of {@link #eventually(int, Callable, Callable)} method for    * void lambda expressions.    * @param timeoutMillis timeout in milliseconds.    * Can be zero, in which case only one attempt is made before failing.    * @param eval expression to evaluate    * @param retry retry interval generator    * @throws Exception the last exception thrown before timeout was triggered    * @throws FailFastException if raised -without any retry attempt.    * @throws InterruptedException if interrupted during the sleep operation.    */
DECL|method|eventually (int timeoutMillis, VoidCallable eval, Callable<Integer> retry)
specifier|public
specifier|static
name|void
name|eventually
parameter_list|(
name|int
name|timeoutMillis
parameter_list|,
name|VoidCallable
name|eval
parameter_list|,
name|Callable
argument_list|<
name|Integer
argument_list|>
name|retry
parameter_list|)
throws|throws
name|Exception
block|{
name|eventually
argument_list|(
name|timeoutMillis
argument_list|,
operator|new
name|VoidCaller
argument_list|(
name|eval
argument_list|)
argument_list|,
name|retry
argument_list|)
expr_stmt|;
block|}
comment|/**    * Simplified {@link #eventually(int, Callable, Callable)} method    * with a fixed interval.    *<p>    * Example: wait 30s until an assertion holds, sleeping 1s between each    * check.    *<pre>    * eventually( 30 * 1000, 1000,    *   () -> { assertEquals(0, filesystem.listFiles(new Path("/")).length); }    * );    *</pre>    *    * @param timeoutMillis timeout in milliseconds.    * Can be zero, in which case only one attempt is made before failing.    * @param intervalMillis interval in milliseconds    * @param eval expression to evaluate    * @return result of the first successful invocation of {@code eval()}    * @throws Exception the last exception thrown before timeout was triggered    * @throws FailFastException if raised -without any retry attempt.    * @throws InterruptedException if interrupted during the sleep operation.    */
DECL|method|eventually (int timeoutMillis, int intervalMillis, Callable<T> eval)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|eventually
parameter_list|(
name|int
name|timeoutMillis
parameter_list|,
name|int
name|intervalMillis
parameter_list|,
name|Callable
argument_list|<
name|T
argument_list|>
name|eval
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|eventually
argument_list|(
name|timeoutMillis
argument_list|,
name|eval
argument_list|,
operator|new
name|FixedRetryInterval
argument_list|(
name|intervalMillis
argument_list|)
argument_list|)
return|;
block|}
comment|/**    /**    * Variant of {@link #eventually(int, int, Callable)} method for    * void lambda expressions.    * @param timeoutMillis timeout in milliseconds.    * Can be zero, in which case only one attempt is made before failing.    * @param intervalMillis interval in milliseconds    * @param eval expression to evaluate    * @throws Exception the last exception thrown before timeout was triggered    * @throws FailFastException if raised -without any retry attempt.    * @throws InterruptedException if interrupted during the sleep operation.    */
DECL|method|eventually (int timeoutMillis, int intervalMillis, VoidCallable eval)
specifier|public
specifier|static
name|void
name|eventually
parameter_list|(
name|int
name|timeoutMillis
parameter_list|,
name|int
name|intervalMillis
parameter_list|,
name|VoidCallable
name|eval
parameter_list|)
throws|throws
name|Exception
block|{
name|eventually
argument_list|(
name|timeoutMillis
argument_list|,
name|eval
argument_list|,
operator|new
name|FixedRetryInterval
argument_list|(
name|intervalMillis
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Intercept an exception; throw an {@code AssertionError} if one not raised.    * The caught exception is rethrown if it is of the wrong class or    * does not contain the text defined in {@code contained}.    *<p>    * Example: expect deleting a nonexistent file to raise a    * {@code FileNotFoundException}.    *<pre>    * FileNotFoundException ioe = intercept(FileNotFoundException.class,    *   () -> {    *     filesystem.delete(new Path("/missing"), false);    *   });    *</pre>    *    * @param clazz class of exception; the raised exception must be this class    *<i>or a subclass</i>.    * @param eval expression to eval    * @param<T> return type of expression    * @param<E> exception class    * @return the caught exception if it was of the expected type    * @throws Exception any other exception raised    * @throws AssertionError if the evaluation call didn't raise an exception.    * The error includes the {@code toString()} value of the result, if this    * can be determined.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|intercept ( Class<E> clazz, Callable<T> eval)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|E
extends|extends
name|Throwable
parameter_list|>
name|E
name|intercept
parameter_list|(
name|Class
argument_list|<
name|E
argument_list|>
name|clazz
parameter_list|,
name|Callable
argument_list|<
name|T
argument_list|>
name|eval
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|intercept
argument_list|(
name|clazz
argument_list|,
literal|null
argument_list|,
literal|"Expected a "
operator|+
name|clazz
operator|.
name|getName
argument_list|()
operator|+
literal|" to be thrown,"
operator|+
literal|" but got the result: "
argument_list|,
name|eval
argument_list|)
return|;
block|}
comment|/**    * Variant of {@link #intercept(Class, Callable)} to simplify void    * invocations.    * @param clazz class of exception; the raised exception must be this class    *<i>or a subclass</i>.    * @param eval expression to eval    * @param<E> exception class    * @return the caught exception if it was of the expected type    * @throws Exception any other exception raised    * @throws AssertionError if the evaluation call didn't raise an exception.    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|intercept ( Class<E> clazz, VoidCallable eval)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Throwable
parameter_list|>
name|E
name|intercept
parameter_list|(
name|Class
argument_list|<
name|E
argument_list|>
name|clazz
parameter_list|,
name|VoidCallable
name|eval
parameter_list|)
throws|throws
name|Exception
block|{
try|try
block|{
name|eval
operator|.
name|call
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Expected an exception"
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
if|if
condition|(
name|clazz
operator|.
name|isAssignableFrom
argument_list|(
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
return|return
operator|(
name|E
operator|)
name|e
return|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
comment|/**    * Intercept an exception; throw an {@code AssertionError} if one not raised.    * The caught exception is rethrown if it is of the wrong class or    * does not contain the text defined in {@code contained}.    *<p>    * Example: expect deleting a nonexistent file to raise a    * {@code FileNotFoundException} with the {@code toString()} value    * containing the text {@code "missing"}.    *<pre>    * FileNotFoundException ioe = intercept(FileNotFoundException.class,    *   "missing",    *   () -> {    *     filesystem.delete(new Path("/missing"), false);    *   });    *</pre>    *    * @param clazz class of exception; the raised exception must be this class    *<i>or a subclass</i>.    * @param contained string which must be in the {@code toString()} value    * of the exception    * @param eval expression to eval    * @param<T> return type of expression    * @param<E> exception class    * @return the caught exception if it was of the expected type and contents    * @throws Exception any other exception raised    * @throws AssertionError if the evaluation call didn't raise an exception.    * The error includes the {@code toString()} value of the result, if this    * can be determined.    * @see GenericTestUtils#assertExceptionContains(String, Throwable)    */
DECL|method|intercept ( Class<E> clazz, String contained, Callable<T> eval)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|E
extends|extends
name|Throwable
parameter_list|>
name|E
name|intercept
parameter_list|(
name|Class
argument_list|<
name|E
argument_list|>
name|clazz
parameter_list|,
name|String
name|contained
parameter_list|,
name|Callable
argument_list|<
name|T
argument_list|>
name|eval
parameter_list|)
throws|throws
name|Exception
block|{
name|E
name|ex
init|=
name|intercept
argument_list|(
name|clazz
argument_list|,
name|eval
argument_list|)
decl_stmt|;
name|GenericTestUtils
operator|.
name|assertExceptionContains
argument_list|(
name|contained
argument_list|,
name|ex
argument_list|)
expr_stmt|;
return|return
name|ex
return|;
block|}
comment|/**    * Intercept an exception; throw an {@code AssertionError} if one not raised.    * The caught exception is rethrown if it is of the wrong class or    * does not contain the text defined in {@code contained}.    *<p>    * Example: expect deleting a nonexistent file to raise a    * {@code FileNotFoundException} with the {@code toString()} value    * containing the text {@code "missing"}.    *<pre>    * FileNotFoundException ioe = intercept(FileNotFoundException.class,    *   "missing",    *   "path should not be found",    *   () -> {    *     filesystem.delete(new Path("/missing"), false);    *   });    *</pre>    *    * @param clazz class of exception; the raised exception must be this class    *<i>or a subclass</i>.    * @param contained string which must be in the {@code toString()} value    * of the exception    * @param message any message tho include in exception/log messages    * @param eval expression to eval    * @param<T> return type of expression    * @param<E> exception class    * @return the caught exception if it was of the expected type and contents    * @throws Exception any other exception raised    * @throws AssertionError if the evaluation call didn't raise an exception.    * The error includes the {@code toString()} value of the result, if this    * can be determined.    * @see GenericTestUtils#assertExceptionContains(String, Throwable)    */
DECL|method|intercept ( Class<E> clazz, String contained, String message, Callable<T> eval)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|E
extends|extends
name|Throwable
parameter_list|>
name|E
name|intercept
parameter_list|(
name|Class
argument_list|<
name|E
argument_list|>
name|clazz
parameter_list|,
name|String
name|contained
parameter_list|,
name|String
name|message
parameter_list|,
name|Callable
argument_list|<
name|T
argument_list|>
name|eval
parameter_list|)
throws|throws
name|Exception
block|{
name|E
name|ex
decl_stmt|;
try|try
block|{
name|T
name|result
init|=
name|eval
operator|.
name|call
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
name|message
operator|+
literal|": "
operator|+
name|robustToString
argument_list|(
name|result
argument_list|)
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|clazz
operator|.
name|isAssignableFrom
argument_list|(
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
name|e
throw|;
block|}
else|else
block|{
name|ex
operator|=
operator|(
name|E
operator|)
name|e
expr_stmt|;
block|}
block|}
name|GenericTestUtils
operator|.
name|assertExceptionContains
argument_list|(
name|contained
argument_list|,
name|ex
argument_list|,
name|message
argument_list|)
expr_stmt|;
return|return
name|ex
return|;
block|}
comment|/**    * Variant of {@link #intercept(Class, Callable)} to simplify void    * invocations.    * @param clazz class of exception; the raised exception must be this class    *<i>or a subclass</i>.    * @param contained string which must be in the {@code toString()} value    * of the exception    * @param eval expression to eval    * @param<E> exception class    * @return the caught exception if it was of the expected type    * @throws Exception any other exception raised    * @throws AssertionError if the evaluation call didn't raise an exception.    */
DECL|method|intercept ( Class<E> clazz, String contained, VoidCallable eval)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Throwable
parameter_list|>
name|E
name|intercept
parameter_list|(
name|Class
argument_list|<
name|E
argument_list|>
name|clazz
parameter_list|,
name|String
name|contained
parameter_list|,
name|VoidCallable
name|eval
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|intercept
argument_list|(
name|clazz
argument_list|,
name|contained
argument_list|,
literal|"Expecting "
operator|+
name|clazz
operator|.
name|getName
argument_list|()
operator|+
operator|(
name|contained
operator|!=
literal|null
condition|?
operator|(
literal|" with text "
operator|+
name|contained
operator|)
else|:
literal|""
operator|)
operator|+
literal|" but got "
argument_list|,
parameter_list|()
lambda|->
block|{
name|eval
operator|.
name|call
argument_list|()
expr_stmt|;
return|return
literal|"void"
return|;
block|}
argument_list|)
return|;
block|}
comment|/**    * Variant of {@link #intercept(Class, Callable)} to simplify void    * invocations.    * @param clazz class of exception; the raised exception must be this class    *<i>or a subclass</i>.    * @param contained string which must be in the {@code toString()} value    * of the exception    * @param message any message tho include in exception/log messages    * @param eval expression to eval    * @param<E> exception class    * @return the caught exception if it was of the expected type    * @throws Exception any other exception raised    * @throws AssertionError if the evaluation call didn't raise an exception.    */
DECL|method|intercept ( Class<E> clazz, String contained, String message, VoidCallable eval)
specifier|public
specifier|static
parameter_list|<
name|E
extends|extends
name|Throwable
parameter_list|>
name|E
name|intercept
parameter_list|(
name|Class
argument_list|<
name|E
argument_list|>
name|clazz
parameter_list|,
name|String
name|contained
parameter_list|,
name|String
name|message
parameter_list|,
name|VoidCallable
name|eval
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|intercept
argument_list|(
name|clazz
argument_list|,
name|contained
argument_list|,
name|message
argument_list|,
parameter_list|()
lambda|->
block|{
name|eval
operator|.
name|call
argument_list|()
expr_stmt|;
return|return
literal|"void"
return|;
block|}
argument_list|)
return|;
block|}
comment|/**    * Robust string converter for exception messages; if the {@code toString()}    * method throws an exception then that exception is caught and logged,    * then a simple string of the classname logged.    * This stops a {@code toString()} failure hiding underlying problems.    * @param o object to stringify    * @return a string for exception messages    */
DECL|method|robustToString (Object o)
specifier|private
specifier|static
name|String
name|robustToString
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
block|{
return|return
name|NULL_RESULT
return|;
block|}
else|else
block|{
try|try
block|{
return|return
name|o
operator|.
name|toString
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Exception calling toString()"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|o
operator|.
name|getClass
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|}
comment|/**    * Assert that an optional value matches an expected one;    * checks include null and empty on the actual value.    * @param message message text    * @param expected expected value    * @param actual actual optional value    * @param<T> type    */
DECL|method|assertOptionalEquals (String message, T expected, Optional<T> actual)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|void
name|assertOptionalEquals
parameter_list|(
name|String
name|message
parameter_list|,
name|T
name|expected
parameter_list|,
name|Optional
argument_list|<
name|T
argument_list|>
name|actual
parameter_list|)
block|{
name|Assert
operator|.
name|assertNotNull
argument_list|(
name|message
argument_list|,
name|actual
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|message
operator|+
literal|" -not present"
argument_list|,
name|actual
operator|.
name|isPresent
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|message
argument_list|,
name|expected
argument_list|,
name|actual
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Assert that an optional value matches an expected one;    * checks include null and empty on the actual value.    * @param message message text    * @param expected expected value    * @param actual actual optional value    * @param<T> type    */
DECL|method|assertOptionalUnset (String message, Optional<T> actual)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|void
name|assertOptionalUnset
parameter_list|(
name|String
name|message
parameter_list|,
name|Optional
argument_list|<
name|T
argument_list|>
name|actual
parameter_list|)
block|{
name|Assert
operator|.
name|assertNotNull
argument_list|(
name|message
argument_list|,
name|actual
argument_list|)
expr_stmt|;
name|actual
operator|.
name|ifPresent
argument_list|(
name|t
lambda|->
name|Assert
operator|.
name|fail
argument_list|(
literal|"Expected empty option, got "
operator|+
name|t
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Invoke a callable; wrap all checked exceptions with an    * AssertionError.    * @param closure closure to execute    * @param<T> return type of closure    * @return the value of the closure    * @throws AssertionError if the operation raised an IOE or    * other checked exception.    */
DECL|method|eval (Callable<T> closure)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|eval
parameter_list|(
name|Callable
argument_list|<
name|T
argument_list|>
name|closure
parameter_list|)
block|{
try|try
block|{
return|return
name|closure
operator|.
name|call
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Invoke a callable; wrap all checked exceptions with an    * AssertionError.    * @param closure closure to execute    * @return the value of the closure    * @throws AssertionError if the operation raised an IOE or    * other checked exception.    */
DECL|method|eval (VoidCallable closure)
specifier|public
specifier|static
name|void
name|eval
parameter_list|(
name|VoidCallable
name|closure
parameter_list|)
block|{
try|try
block|{
name|closure
operator|.
name|call
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Evaluate a closure and return the result, after verifying that it is    * not null.    * @param message message to use in assertion text if the result is null    * @param eval closure to evaluate    * @param<T> type of response    * @return the evaluated result    * @throws Exception on any problem    */
DECL|method|notNull (String message, Callable<T> eval)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|notNull
parameter_list|(
name|String
name|message
parameter_list|,
name|Callable
argument_list|<
name|T
argument_list|>
name|eval
parameter_list|)
throws|throws
name|Exception
block|{
name|T
name|t
init|=
name|eval
operator|.
name|call
argument_list|()
decl_stmt|;
name|Assert
operator|.
name|assertNotNull
argument_list|(
name|message
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/**    * Execute a closure as the given user.    * @param user user to invoke the closure as    * @param eval closure to evaluate    * @param<T> return type    * @return the result of calling the closure under the identity of the user.    * @throws IOException IO failure    * @throws InterruptedException interrupted operation.    */
DECL|method|doAs (UserGroupInformation user, Callable<T> eval)
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|doAs
parameter_list|(
name|UserGroupInformation
name|user
parameter_list|,
name|Callable
argument_list|<
name|T
argument_list|>
name|eval
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|user
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedOperation
argument_list|<>
argument_list|(
name|eval
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Execute a closure as the given user.    * @param user user to invoke the closure as    * @param eval closure to evaluate    * @throws IOException IO failure    * @throws InterruptedException interrupted operation.    */
DECL|method|doAs (UserGroupInformation user, VoidCallable eval)
specifier|public
specifier|static
name|void
name|doAs
parameter_list|(
name|UserGroupInformation
name|user
parameter_list|,
name|VoidCallable
name|eval
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|user
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedVoidOperation
argument_list|(
name|eval
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns {@code TimeoutException} on a timeout. If    * there was a inner class passed in, includes it as the    * inner failure.    */
DECL|class|GenerateTimeout
specifier|public
specifier|static
class|class
name|GenerateTimeout
implements|implements
name|TimeoutHandler
block|{
DECL|field|message
specifier|private
specifier|final
name|String
name|message
decl_stmt|;
DECL|method|GenerateTimeout (String message)
specifier|public
name|GenerateTimeout
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|this
operator|.
name|message
operator|=
name|message
expr_stmt|;
block|}
DECL|method|GenerateTimeout ()
specifier|public
name|GenerateTimeout
parameter_list|()
block|{
name|this
argument_list|(
literal|"timeout"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Evaluate operation creates a new {@code TimeoutException}.      * @param timeoutMillis timeout in millis      * @param caught optional caught exception      * @return TimeoutException      */
annotation|@
name|Override
DECL|method|evaluate (int timeoutMillis, Throwable caught)
specifier|public
name|Throwable
name|evaluate
parameter_list|(
name|int
name|timeoutMillis
parameter_list|,
name|Throwable
name|caught
parameter_list|)
throws|throws
name|Throwable
block|{
name|String
name|s
init|=
name|String
operator|.
name|format
argument_list|(
literal|"%s: after %d millis"
argument_list|,
name|message
argument_list|,
name|timeoutMillis
argument_list|)
decl_stmt|;
name|String
name|caughtText
init|=
name|caught
operator|!=
literal|null
condition|?
operator|(
literal|"; "
operator|+
name|robustToString
argument_list|(
name|caught
argument_list|)
operator|)
else|:
literal|""
decl_stmt|;
return|return
operator|(
operator|new
name|TimeoutException
argument_list|(
name|s
operator|+
name|caughtText
argument_list|)
operator|.
name|initCause
argument_list|(
name|caught
argument_list|)
operator|)
return|;
block|}
block|}
comment|/**    * Retry at a fixed time period between calls.    */
DECL|class|FixedRetryInterval
specifier|public
specifier|static
class|class
name|FixedRetryInterval
implements|implements
name|Callable
argument_list|<
name|Integer
argument_list|>
block|{
DECL|field|intervalMillis
specifier|private
specifier|final
name|int
name|intervalMillis
decl_stmt|;
DECL|field|invocationCount
specifier|private
name|int
name|invocationCount
init|=
literal|0
decl_stmt|;
DECL|method|FixedRetryInterval (int intervalMillis)
specifier|public
name|FixedRetryInterval
parameter_list|(
name|int
name|intervalMillis
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|intervalMillis
operator|>
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|intervalMillis
operator|=
name|intervalMillis
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|call ()
specifier|public
name|Integer
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|invocationCount
operator|++
expr_stmt|;
return|return
name|intervalMillis
return|;
block|}
DECL|method|getInvocationCount ()
specifier|public
name|int
name|getInvocationCount
parameter_list|()
block|{
return|return
name|invocationCount
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"FixedRetryInterval{"
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"interval="
argument_list|)
operator|.
name|append
argument_list|(
name|intervalMillis
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", invocationCount="
argument_list|)
operator|.
name|append
argument_list|(
name|invocationCount
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Gradually increase the sleep time by the initial interval, until    * the limit set by {@code maxIntervalMillis} is reached.    */
DECL|class|ProportionalRetryInterval
specifier|public
specifier|static
class|class
name|ProportionalRetryInterval
implements|implements
name|Callable
argument_list|<
name|Integer
argument_list|>
block|{
DECL|field|intervalMillis
specifier|private
specifier|final
name|int
name|intervalMillis
decl_stmt|;
DECL|field|maxIntervalMillis
specifier|private
specifier|final
name|int
name|maxIntervalMillis
decl_stmt|;
DECL|field|current
specifier|private
name|int
name|current
decl_stmt|;
DECL|field|invocationCount
specifier|private
name|int
name|invocationCount
init|=
literal|0
decl_stmt|;
DECL|method|ProportionalRetryInterval (int intervalMillis, int maxIntervalMillis)
specifier|public
name|ProportionalRetryInterval
parameter_list|(
name|int
name|intervalMillis
parameter_list|,
name|int
name|maxIntervalMillis
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|intervalMillis
operator|>
literal|0
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|maxIntervalMillis
operator|>
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|intervalMillis
operator|=
name|intervalMillis
expr_stmt|;
name|this
operator|.
name|current
operator|=
name|intervalMillis
expr_stmt|;
name|this
operator|.
name|maxIntervalMillis
operator|=
name|maxIntervalMillis
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|call ()
specifier|public
name|Integer
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|invocationCount
operator|++
expr_stmt|;
name|int
name|last
init|=
name|current
decl_stmt|;
if|if
condition|(
name|last
operator|<
name|maxIntervalMillis
condition|)
block|{
name|current
operator|+=
name|intervalMillis
expr_stmt|;
block|}
return|return
name|last
return|;
block|}
DECL|method|getInvocationCount ()
specifier|public
name|int
name|getInvocationCount
parameter_list|()
block|{
return|return
name|invocationCount
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"ProportionalRetryInterval{"
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"interval="
argument_list|)
operator|.
name|append
argument_list|(
name|intervalMillis
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", current="
argument_list|)
operator|.
name|append
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", limit="
argument_list|)
operator|.
name|append
argument_list|(
name|maxIntervalMillis
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", invocationCount="
argument_list|)
operator|.
name|append
argument_list|(
name|invocationCount
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * An exception which triggers a fast exist from the    * {@link #eventually(int, Callable, Callable)} and    * {@link #await(int, Callable, Callable, TimeoutHandler)} loops.    */
DECL|class|FailFastException
specifier|public
specifier|static
class|class
name|FailFastException
extends|extends
name|Exception
block|{
DECL|method|FailFastException (String detailMessage)
specifier|public
name|FailFastException
parameter_list|(
name|String
name|detailMessage
parameter_list|)
block|{
name|super
argument_list|(
name|detailMessage
argument_list|)
expr_stmt|;
block|}
DECL|method|FailFastException (String message, Throwable cause)
specifier|public
name|FailFastException
parameter_list|(
name|String
name|message
parameter_list|,
name|Throwable
name|cause
parameter_list|)
block|{
name|super
argument_list|(
name|message
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
comment|/**      * Instantiate from a format string.      * @param format format string      * @param args arguments to format      * @return an instance with the message string constructed.      */
DECL|method|newInstance (String format, Object...args)
specifier|public
specifier|static
name|FailFastException
name|newInstance
parameter_list|(
name|String
name|format
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
block|{
return|return
operator|new
name|FailFastException
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|format
argument_list|,
name|args
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**    * A simple interface for lambdas, which returns nothing; this exists    * to simplify lambda tests on operations with no return value.    */
annotation|@
name|FunctionalInterface
DECL|interface|VoidCallable
specifier|public
interface|interface
name|VoidCallable
block|{
DECL|method|call ()
name|void
name|call
parameter_list|()
throws|throws
name|Exception
function_decl|;
block|}
comment|/**    * Bridge class to make {@link VoidCallable} something to use in anything    * which takes an {@link Callable}.    */
DECL|class|VoidCaller
specifier|public
specifier|static
class|class
name|VoidCaller
implements|implements
name|Callable
argument_list|<
name|Void
argument_list|>
block|{
DECL|field|callback
specifier|private
specifier|final
name|VoidCallable
name|callback
decl_stmt|;
DECL|method|VoidCaller (VoidCallable callback)
specifier|public
name|VoidCaller
parameter_list|(
name|VoidCallable
name|callback
parameter_list|)
block|{
name|this
operator|.
name|callback
operator|=
name|callback
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|call ()
specifier|public
name|Void
name|call
parameter_list|()
throws|throws
name|Exception
block|{
name|callback
operator|.
name|call
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**    * A lambda-invoker for doAs use; invokes the callable provided    * in the constructor.    * @param<T> return type.    */
DECL|class|PrivilegedOperation
specifier|public
specifier|static
class|class
name|PrivilegedOperation
parameter_list|<
name|T
parameter_list|>
implements|implements
name|PrivilegedExceptionAction
argument_list|<
name|T
argument_list|>
block|{
DECL|field|callable
specifier|private
specifier|final
name|Callable
argument_list|<
name|T
argument_list|>
name|callable
decl_stmt|;
comment|/**      * Constructor.      * @param callable a non-null callable/closure.      */
DECL|method|PrivilegedOperation (final Callable<T> callable)
specifier|public
name|PrivilegedOperation
parameter_list|(
specifier|final
name|Callable
argument_list|<
name|T
argument_list|>
name|callable
parameter_list|)
block|{
name|this
operator|.
name|callable
operator|=
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|callable
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|T
name|run
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|callable
operator|.
name|call
argument_list|()
return|;
block|}
block|}
comment|/**    * VoidCaller variant of {@link PrivilegedOperation}: converts    * a void-returning closure to an action which {@code doAs} can call.    */
DECL|class|PrivilegedVoidOperation
specifier|public
specifier|static
class|class
name|PrivilegedVoidOperation
implements|implements
name|PrivilegedExceptionAction
argument_list|<
name|Void
argument_list|>
block|{
DECL|field|callable
specifier|private
specifier|final
name|Callable
argument_list|<
name|Void
argument_list|>
name|callable
decl_stmt|;
comment|/**      * Constructor.      * @param callable a non-null callable/closure.      */
DECL|method|PrivilegedVoidOperation (final VoidCallable callable)
specifier|public
name|PrivilegedVoidOperation
parameter_list|(
specifier|final
name|VoidCallable
name|callable
parameter_list|)
block|{
name|this
operator|.
name|callable
operator|=
operator|new
name|VoidCaller
argument_list|(
name|callable
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|Void
name|run
parameter_list|()
throws|throws
name|Exception
block|{
return|return
name|callable
operator|.
name|call
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

