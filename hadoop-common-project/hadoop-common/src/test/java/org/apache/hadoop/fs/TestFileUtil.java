begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
package|;
end_package

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|PlatformAssumptions
operator|.
name|assumeNotWindows
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertFalse
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNotEquals
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertNull
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertTrue
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|fail
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|mock
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|mockito
operator|.
name|Mockito
operator|.
name|when
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|FileSystems
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|jar
operator|.
name|Attributes
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|jar
operator|.
name|JarFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|jar
operator|.
name|Manifest
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|ZipEntry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|ZipOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|tar
operator|.
name|TarArchiveEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|compress
operator|.
name|archivers
operator|.
name|tar
operator|.
name|TarArchiveOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|test
operator|.
name|GenericTestUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tools
operator|.
name|tar
operator|.
name|TarEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|tools
operator|.
name|tar
operator|.
name|TarOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|After
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Assert
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Before
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Ignore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|Test
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_class
DECL|class|TestFileUtil
specifier|public
class|class
name|TestFileUtil
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|TestFileUtil
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TEST_DIR
specifier|private
specifier|static
specifier|final
name|File
name|TEST_DIR
init|=
name|GenericTestUtils
operator|.
name|getTestDir
argument_list|(
literal|"fu"
argument_list|)
decl_stmt|;
DECL|field|FILE
specifier|private
specifier|static
specifier|final
name|String
name|FILE
init|=
literal|"x"
decl_stmt|;
DECL|field|LINK
specifier|private
specifier|static
specifier|final
name|String
name|LINK
init|=
literal|"y"
decl_stmt|;
DECL|field|DIR
specifier|private
specifier|static
specifier|final
name|String
name|DIR
init|=
literal|"dir"
decl_stmt|;
DECL|field|del
specifier|private
specifier|final
name|File
name|del
init|=
operator|new
name|File
argument_list|(
name|TEST_DIR
argument_list|,
literal|"del"
argument_list|)
decl_stmt|;
DECL|field|tmp
specifier|private
specifier|final
name|File
name|tmp
init|=
operator|new
name|File
argument_list|(
name|TEST_DIR
argument_list|,
literal|"tmp"
argument_list|)
decl_stmt|;
DECL|field|dir1
specifier|private
specifier|final
name|File
name|dir1
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
name|DIR
operator|+
literal|"1"
argument_list|)
decl_stmt|;
DECL|field|dir2
specifier|private
specifier|final
name|File
name|dir2
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
name|DIR
operator|+
literal|"2"
argument_list|)
decl_stmt|;
DECL|field|partitioned
specifier|private
specifier|final
name|File
name|partitioned
init|=
operator|new
name|File
argument_list|(
name|TEST_DIR
argument_list|,
literal|"partitioned"
argument_list|)
decl_stmt|;
DECL|field|inet1
specifier|private
name|InetAddress
name|inet1
decl_stmt|;
DECL|field|inet2
specifier|private
name|InetAddress
name|inet2
decl_stmt|;
DECL|field|inet3
specifier|private
name|InetAddress
name|inet3
decl_stmt|;
DECL|field|inet4
specifier|private
name|InetAddress
name|inet4
decl_stmt|;
DECL|field|inet5
specifier|private
name|InetAddress
name|inet5
decl_stmt|;
DECL|field|inet6
specifier|private
name|InetAddress
name|inet6
decl_stmt|;
DECL|field|uri1
specifier|private
name|URI
name|uri1
decl_stmt|;
DECL|field|uri2
specifier|private
name|URI
name|uri2
decl_stmt|;
DECL|field|uri3
specifier|private
name|URI
name|uri3
decl_stmt|;
DECL|field|uri4
specifier|private
name|URI
name|uri4
decl_stmt|;
DECL|field|uri5
specifier|private
name|URI
name|uri5
decl_stmt|;
DECL|field|uri6
specifier|private
name|URI
name|uri6
decl_stmt|;
DECL|field|fs1
specifier|private
name|FileSystem
name|fs1
decl_stmt|;
DECL|field|fs2
specifier|private
name|FileSystem
name|fs2
decl_stmt|;
DECL|field|fs3
specifier|private
name|FileSystem
name|fs3
decl_stmt|;
DECL|field|fs4
specifier|private
name|FileSystem
name|fs4
decl_stmt|;
DECL|field|fs5
specifier|private
name|FileSystem
name|fs5
decl_stmt|;
DECL|field|fs6
specifier|private
name|FileSystem
name|fs6
decl_stmt|;
comment|/**    * Creates multiple directories for testing.    *     * Contents of them are    * dir:tmp:     *   file: x    * dir:del:    *   file: x    *   dir: dir1 : file:x    *   dir: dir2 : file:x    *   link: y to tmp/x    *   link: tmpDir to tmp    * dir:partitioned:    *   file: part-r-00000, contents: "foo"    *   file: part-r-00001, contents: "bar"    */
annotation|@
name|Ignore
DECL|method|setupDirs ()
specifier|private
name|void
name|setupDirs
parameter_list|()
throws|throws
name|IOException
block|{
name|Assert
operator|.
name|assertFalse
argument_list|(
name|del
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
name|tmp
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
name|partitioned
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|del
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|tmp
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|partitioned
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
operator|new
name|File
argument_list|(
name|del
argument_list|,
name|FILE
argument_list|)
operator|.
name|createNewFile
argument_list|()
expr_stmt|;
name|File
name|tmpFile
init|=
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
name|FILE
argument_list|)
decl_stmt|;
name|tmpFile
operator|.
name|createNewFile
argument_list|()
expr_stmt|;
comment|// create directories
name|dir1
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|dir2
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
operator|new
name|File
argument_list|(
name|dir1
argument_list|,
name|FILE
argument_list|)
operator|.
name|createNewFile
argument_list|()
expr_stmt|;
operator|new
name|File
argument_list|(
name|dir2
argument_list|,
name|FILE
argument_list|)
operator|.
name|createNewFile
argument_list|()
expr_stmt|;
comment|// create a symlink to file
name|File
name|link
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
name|LINK
argument_list|)
decl_stmt|;
name|FileUtil
operator|.
name|symLink
argument_list|(
name|tmpFile
operator|.
name|toString
argument_list|()
argument_list|,
name|link
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
comment|// create a symlink to dir
name|File
name|linkDir
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
literal|"tmpDir"
argument_list|)
decl_stmt|;
name|FileUtil
operator|.
name|symLink
argument_list|(
name|tmp
operator|.
name|toString
argument_list|()
argument_list|,
name|linkDir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|del
operator|.
name|listFiles
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// create files in partitioned directories
name|createFile
argument_list|(
name|partitioned
argument_list|,
literal|"part-r-00000"
argument_list|,
literal|"foo"
argument_list|)
expr_stmt|;
name|createFile
argument_list|(
name|partitioned
argument_list|,
literal|"part-r-00001"
argument_list|,
literal|"bar"
argument_list|)
expr_stmt|;
comment|// create a cycle using symlinks. Cycles should be handled
name|FileUtil
operator|.
name|symLink
argument_list|(
name|del
operator|.
name|toString
argument_list|()
argument_list|,
name|dir1
operator|.
name|toString
argument_list|()
operator|+
literal|"/cycle"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Creates a new file in the specified directory, with the specified name and    * the specified file contents.  This method will add a newline terminator to    * the end of the contents string in the destination file.    * @param directory File non-null destination directory.    * @param name String non-null file name.    * @param contents String non-null file contents.    * @throws IOException if an I/O error occurs.    */
DECL|method|createFile (File directory, String name, String contents)
specifier|private
name|File
name|createFile
parameter_list|(
name|File
name|directory
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|contents
parameter_list|)
throws|throws
name|IOException
block|{
name|File
name|newFile
init|=
operator|new
name|File
argument_list|(
name|directory
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|PrintWriter
name|pw
init|=
operator|new
name|PrintWriter
argument_list|(
name|newFile
argument_list|)
decl_stmt|;
try|try
block|{
name|pw
operator|.
name|println
argument_list|(
name|contents
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|pw
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|newFile
return|;
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testListFiles ()
specifier|public
name|void
name|testListFiles
parameter_list|()
throws|throws
name|IOException
block|{
name|setupDirs
argument_list|()
expr_stmt|;
comment|//Test existing files case
name|File
index|[]
name|files
init|=
name|FileUtil
operator|.
name|listFiles
argument_list|(
name|partitioned
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|files
operator|.
name|length
argument_list|)
expr_stmt|;
comment|//Test existing directory with no files case
name|File
name|newDir
init|=
operator|new
name|File
argument_list|(
name|tmp
operator|.
name|getPath
argument_list|()
argument_list|,
literal|"test"
argument_list|)
decl_stmt|;
name|newDir
operator|.
name|mkdir
argument_list|()
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Failed to create test dir"
argument_list|,
name|newDir
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|files
operator|=
name|FileUtil
operator|.
name|listFiles
argument_list|(
name|newDir
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|files
operator|.
name|length
argument_list|)
expr_stmt|;
name|newDir
operator|.
name|delete
argument_list|()
expr_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
literal|"Failed to delete test dir"
argument_list|,
name|newDir
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
comment|//Test non-existing directory case, this throws
comment|//IOException
try|try
block|{
name|files
operator|=
name|FileUtil
operator|.
name|listFiles
argument_list|(
name|newDir
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|fail
argument_list|(
literal|"IOException expected on listFiles() for non-existent dir "
operator|+
name|newDir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|//Expected an IOException
block|}
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testListAPI ()
specifier|public
name|void
name|testListAPI
parameter_list|()
throws|throws
name|IOException
block|{
name|setupDirs
argument_list|()
expr_stmt|;
comment|//Test existing files case
name|String
index|[]
name|files
init|=
name|FileUtil
operator|.
name|list
argument_list|(
name|partitioned
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"Unexpected number of pre-existing files"
argument_list|,
literal|2
argument_list|,
name|files
operator|.
name|length
argument_list|)
expr_stmt|;
comment|//Test existing directory with no files case
name|File
name|newDir
init|=
operator|new
name|File
argument_list|(
name|tmp
operator|.
name|getPath
argument_list|()
argument_list|,
literal|"test"
argument_list|)
decl_stmt|;
name|newDir
operator|.
name|mkdir
argument_list|()
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"Failed to create test dir"
argument_list|,
name|newDir
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|files
operator|=
name|FileUtil
operator|.
name|list
argument_list|(
name|newDir
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"New directory unexpectedly contains files"
argument_list|,
literal|0
argument_list|,
name|files
operator|.
name|length
argument_list|)
expr_stmt|;
name|newDir
operator|.
name|delete
argument_list|()
expr_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
literal|"Failed to delete test dir"
argument_list|,
name|newDir
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
comment|//Test non-existing directory case, this throws
comment|//IOException
try|try
block|{
name|files
operator|=
name|FileUtil
operator|.
name|list
argument_list|(
name|newDir
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|fail
argument_list|(
literal|"IOException expected on list() for non-existent dir "
operator|+
name|newDir
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|//Expected an IOException
block|}
block|}
annotation|@
name|Before
DECL|method|before ()
specifier|public
name|void
name|before
parameter_list|()
throws|throws
name|IOException
block|{
name|cleanupImpl
argument_list|()
expr_stmt|;
block|}
annotation|@
name|After
DECL|method|tearDown ()
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|IOException
block|{
name|cleanupImpl
argument_list|()
expr_stmt|;
block|}
DECL|method|cleanupImpl ()
specifier|private
name|void
name|cleanupImpl
parameter_list|()
throws|throws
name|IOException
block|{
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|del
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
operator|!
name|del
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|tmp
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
operator|!
name|tmp
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|partitioned
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
operator|!
name|partitioned
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testFullyDelete ()
specifier|public
name|void
name|testFullyDelete
parameter_list|()
throws|throws
name|IOException
block|{
name|setupDirs
argument_list|()
expr_stmt|;
name|boolean
name|ret
init|=
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|del
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
name|del
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|validateTmpDir
argument_list|()
expr_stmt|;
block|}
comment|/**    * Tests if fullyDelete deletes    * (a) symlink to file only and not the file pointed to by symlink.    * (b) symlink to dir only and not the dir pointed to by symlink.    * @throws IOException    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testFullyDeleteSymlinks ()
specifier|public
name|void
name|testFullyDeleteSymlinks
parameter_list|()
throws|throws
name|IOException
block|{
name|setupDirs
argument_list|()
expr_stmt|;
name|File
name|link
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
name|LINK
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|del
operator|.
name|list
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// Since tmpDir is symlink to tmp, fullyDelete(tmpDir) should not
comment|// delete contents of tmp. See setupDirs for details.
name|boolean
name|ret
init|=
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
name|link
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|del
operator|.
name|list
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|validateTmpDir
argument_list|()
expr_stmt|;
name|File
name|linkDir
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
literal|"tmpDir"
argument_list|)
decl_stmt|;
comment|// Since tmpDir is symlink to tmp, fullyDelete(tmpDir) should not
comment|// delete contents of tmp. See setupDirs for details.
name|ret
operator|=
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|linkDir
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
name|linkDir
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|del
operator|.
name|list
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|validateTmpDir
argument_list|()
expr_stmt|;
block|}
comment|/**    * Tests if fullyDelete deletes    * (a) dangling symlink to file properly    * (b) dangling symlink to directory properly    * @throws IOException    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testFullyDeleteDanglingSymlinks ()
specifier|public
name|void
name|testFullyDeleteDanglingSymlinks
parameter_list|()
throws|throws
name|IOException
block|{
name|setupDirs
argument_list|()
expr_stmt|;
comment|// delete the directory tmp to make tmpDir a dangling link to dir tmp and
comment|// to make y as a dangling link to file tmp/x
name|boolean
name|ret
init|=
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|tmp
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
name|tmp
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
comment|// dangling symlink to file
name|File
name|link
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
name|LINK
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|del
operator|.
name|list
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// Even though 'y' is dangling symlink to file tmp/x, fullyDelete(y)
comment|// should delete 'y' properly.
name|ret
operator|=
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|del
operator|.
name|list
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
comment|// dangling symlink to directory
name|File
name|linkDir
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
literal|"tmpDir"
argument_list|)
decl_stmt|;
comment|// Even though tmpDir is dangling symlink to tmp, fullyDelete(tmpDir) should
comment|// delete tmpDir properly.
name|ret
operator|=
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|linkDir
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|3
argument_list|,
name|del
operator|.
name|list
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testFullyDeleteContents ()
specifier|public
name|void
name|testFullyDeleteContents
parameter_list|()
throws|throws
name|IOException
block|{
name|setupDirs
argument_list|()
expr_stmt|;
name|boolean
name|ret
init|=
name|FileUtil
operator|.
name|fullyDeleteContents
argument_list|(
name|del
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|del
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|del
operator|.
name|listFiles
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|validateTmpDir
argument_list|()
expr_stmt|;
block|}
DECL|method|validateTmpDir ()
specifier|private
name|void
name|validateTmpDir
parameter_list|()
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
name|tmp
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|tmp
operator|.
name|listFiles
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
name|FILE
argument_list|)
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|field|xSubDir
specifier|private
specifier|final
name|File
name|xSubDir
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
literal|"xSubDir"
argument_list|)
decl_stmt|;
DECL|field|xSubSubDir
specifier|private
specifier|final
name|File
name|xSubSubDir
init|=
operator|new
name|File
argument_list|(
name|xSubDir
argument_list|,
literal|"xSubSubDir"
argument_list|)
decl_stmt|;
DECL|field|ySubDir
specifier|private
specifier|final
name|File
name|ySubDir
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
literal|"ySubDir"
argument_list|)
decl_stmt|;
DECL|field|file1Name
specifier|private
specifier|static
specifier|final
name|String
name|file1Name
init|=
literal|"file1"
decl_stmt|;
DECL|field|file2
specifier|private
specifier|final
name|File
name|file2
init|=
operator|new
name|File
argument_list|(
name|xSubDir
argument_list|,
literal|"file2"
argument_list|)
decl_stmt|;
DECL|field|file22
specifier|private
specifier|final
name|File
name|file22
init|=
operator|new
name|File
argument_list|(
name|xSubSubDir
argument_list|,
literal|"file22"
argument_list|)
decl_stmt|;
DECL|field|file3
specifier|private
specifier|final
name|File
name|file3
init|=
operator|new
name|File
argument_list|(
name|ySubDir
argument_list|,
literal|"file3"
argument_list|)
decl_stmt|;
DECL|field|zlink
specifier|private
specifier|final
name|File
name|zlink
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
literal|"zlink"
argument_list|)
decl_stmt|;
comment|/**    * Creates a directory which can not be deleted completely.    *     * Directory structure. The naming is important in that {@link MyFile}    * is used to return them in alphabetical order when listed.    *     *                     del(+w)    *                       |    *    .---------------------------------------,    *    |            |              |           |    *  file1(!w)   xSubDir(-rwx)   ySubDir(+w)   zlink    *              |  |              |    *              | file2(-rwx)   file3    *              |    *            xSubSubDir(-rwx)     *              |    *             file22(-rwx)    *                 * @throws IOException    */
DECL|method|setupDirsAndNonWritablePermissions ()
specifier|private
name|void
name|setupDirsAndNonWritablePermissions
parameter_list|()
throws|throws
name|IOException
block|{
name|Assert
operator|.
name|assertFalse
argument_list|(
literal|"The directory del should not have existed!"
argument_list|,
name|del
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|del
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
operator|new
name|MyFile
argument_list|(
name|del
argument_list|,
name|file1Name
argument_list|)
operator|.
name|createNewFile
argument_list|()
expr_stmt|;
comment|// "file1" is non-deletable by default, see MyFile.delete().
name|xSubDir
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|file2
operator|.
name|createNewFile
argument_list|()
expr_stmt|;
name|xSubSubDir
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|file22
operator|.
name|createNewFile
argument_list|()
expr_stmt|;
name|revokePermissions
argument_list|(
name|file22
argument_list|)
expr_stmt|;
name|revokePermissions
argument_list|(
name|xSubSubDir
argument_list|)
expr_stmt|;
name|revokePermissions
argument_list|(
name|file2
argument_list|)
expr_stmt|;
name|revokePermissions
argument_list|(
name|xSubDir
argument_list|)
expr_stmt|;
name|ySubDir
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|file3
operator|.
name|createNewFile
argument_list|()
expr_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
literal|"The directory tmp should not have existed!"
argument_list|,
name|tmp
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|File
name|tmpFile
init|=
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
name|FILE
argument_list|)
decl_stmt|;
name|tmpFile
operator|.
name|createNewFile
argument_list|()
expr_stmt|;
name|FileUtil
operator|.
name|symLink
argument_list|(
name|tmpFile
operator|.
name|toString
argument_list|()
argument_list|,
name|zlink
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|grantPermissions (final File f)
specifier|private
specifier|static
name|void
name|grantPermissions
parameter_list|(
specifier|final
name|File
name|f
parameter_list|)
block|{
name|FileUtil
operator|.
name|setReadable
argument_list|(
name|f
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|FileUtil
operator|.
name|setWritable
argument_list|(
name|f
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|FileUtil
operator|.
name|setExecutable
argument_list|(
name|f
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|revokePermissions (final File f)
specifier|private
specifier|static
name|void
name|revokePermissions
parameter_list|(
specifier|final
name|File
name|f
parameter_list|)
block|{
name|FileUtil
operator|.
name|setWritable
argument_list|(
name|f
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|FileUtil
operator|.
name|setExecutable
argument_list|(
name|f
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|FileUtil
operator|.
name|setReadable
argument_list|(
name|f
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// Validates the return value.
comment|// Validates the existence of the file "file1"
DECL|method|validateAndSetWritablePermissions ( final boolean expectedRevokedPermissionDirsExist, final boolean ret)
specifier|private
name|void
name|validateAndSetWritablePermissions
parameter_list|(
specifier|final
name|boolean
name|expectedRevokedPermissionDirsExist
parameter_list|,
specifier|final
name|boolean
name|ret
parameter_list|)
block|{
name|grantPermissions
argument_list|(
name|xSubDir
argument_list|)
expr_stmt|;
name|grantPermissions
argument_list|(
name|xSubSubDir
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
literal|"The return value should have been false."
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"The file file1 should not have been deleted."
argument_list|,
operator|new
name|File
argument_list|(
name|del
argument_list|,
name|file1Name
argument_list|)
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"The directory xSubDir *should* not have been deleted."
argument_list|,
name|expectedRevokedPermissionDirsExist
argument_list|,
name|xSubDir
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"The file file2 *should* not have been deleted."
argument_list|,
name|expectedRevokedPermissionDirsExist
argument_list|,
name|file2
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"The directory xSubSubDir *should* not have been deleted."
argument_list|,
name|expectedRevokedPermissionDirsExist
argument_list|,
name|xSubSubDir
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|"The file file22 *should* not have been deleted."
argument_list|,
name|expectedRevokedPermissionDirsExist
argument_list|,
name|file22
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
literal|"The directory ySubDir should have been deleted."
argument_list|,
name|ySubDir
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
literal|"The link zlink should have been deleted."
argument_list|,
name|zlink
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testFailFullyDelete ()
specifier|public
name|void
name|testFailFullyDelete
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Windows Dir.setWritable(false) does not work for directories
name|assumeNotWindows
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Running test to verify failure of fullyDelete()"
argument_list|)
expr_stmt|;
name|setupDirsAndNonWritablePermissions
argument_list|()
expr_stmt|;
name|boolean
name|ret
init|=
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
operator|new
name|MyFile
argument_list|(
name|del
argument_list|)
argument_list|)
decl_stmt|;
name|validateAndSetWritablePermissions
argument_list|(
literal|true
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testFailFullyDeleteGrantPermissions ()
specifier|public
name|void
name|testFailFullyDeleteGrantPermissions
parameter_list|()
throws|throws
name|IOException
block|{
name|setupDirsAndNonWritablePermissions
argument_list|()
expr_stmt|;
name|boolean
name|ret
init|=
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
operator|new
name|MyFile
argument_list|(
name|del
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// this time the directories with revoked permissions *should* be deleted:
name|validateAndSetWritablePermissions
argument_list|(
literal|false
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
comment|/**    * Extend {@link File}. Same as {@link File} except for two things: (1) This    * treats file1Name as a very special file which is not delete-able    * irrespective of it's parent-dir's permissions, a peculiar file instance for    * testing. (2) It returns the files in alphabetically sorted order when    * listed.    *     */
DECL|class|MyFile
specifier|public
specifier|static
class|class
name|MyFile
extends|extends
name|File
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
DECL|method|MyFile (File f)
specifier|public
name|MyFile
parameter_list|(
name|File
name|f
parameter_list|)
block|{
name|super
argument_list|(
name|f
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|MyFile (File parent, String child)
specifier|public
name|MyFile
parameter_list|(
name|File
name|parent
parameter_list|,
name|String
name|child
parameter_list|)
block|{
name|super
argument_list|(
name|parent
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
comment|/**      * Same as {@link File#delete()} except for file1Name which will never be      * deleted (hard-coded)      */
annotation|@
name|Override
DECL|method|delete ()
specifier|public
name|boolean
name|delete
parameter_list|()
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Trying to delete myFile "
operator|+
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|boolean
name|bool
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|file1Name
argument_list|)
condition|)
block|{
name|bool
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|bool
operator|=
name|super
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bool
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleted "
operator|+
name|getAbsolutePath
argument_list|()
operator|+
literal|" successfully"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Cannot delete "
operator|+
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|bool
return|;
block|}
comment|/**      * Return the list of files in an alphabetically sorted order      */
annotation|@
name|Override
DECL|method|listFiles ()
specifier|public
name|File
index|[]
name|listFiles
parameter_list|()
block|{
specifier|final
name|File
index|[]
name|files
init|=
name|super
operator|.
name|listFiles
argument_list|()
decl_stmt|;
if|if
condition|(
name|files
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|File
argument_list|>
name|filesList
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|files
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|filesList
argument_list|)
expr_stmt|;
name|File
index|[]
name|myFiles
init|=
operator|new
name|MyFile
index|[
name|files
operator|.
name|length
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|File
name|f
range|:
name|filesList
control|)
block|{
name|myFiles
index|[
name|i
operator|++
index|]
operator|=
operator|new
name|MyFile
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
return|return
name|myFiles
return|;
block|}
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testFailFullyDeleteContents ()
specifier|public
name|void
name|testFailFullyDeleteContents
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Windows Dir.setWritable(false) does not work for directories
name|assumeNotWindows
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Running test to verify failure of fullyDeleteContents()"
argument_list|)
expr_stmt|;
name|setupDirsAndNonWritablePermissions
argument_list|()
expr_stmt|;
name|boolean
name|ret
init|=
name|FileUtil
operator|.
name|fullyDeleteContents
argument_list|(
operator|new
name|MyFile
argument_list|(
name|del
argument_list|)
argument_list|)
decl_stmt|;
name|validateAndSetWritablePermissions
argument_list|(
literal|true
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testFailFullyDeleteContentsGrantPermissions ()
specifier|public
name|void
name|testFailFullyDeleteContentsGrantPermissions
parameter_list|()
throws|throws
name|IOException
block|{
name|setupDirsAndNonWritablePermissions
argument_list|()
expr_stmt|;
name|boolean
name|ret
init|=
name|FileUtil
operator|.
name|fullyDeleteContents
argument_list|(
operator|new
name|MyFile
argument_list|(
name|del
argument_list|)
argument_list|,
literal|true
argument_list|)
decl_stmt|;
comment|// this time the directories with revoked permissions *should* be deleted:
name|validateAndSetWritablePermissions
argument_list|(
literal|false
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that getDU is able to handle cycles caused due to symbolic links    * and that directory sizes are not added to the final calculated size    * @throws IOException    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testGetDU ()
specifier|public
name|void
name|testGetDU
parameter_list|()
throws|throws
name|Exception
block|{
name|setupDirs
argument_list|()
expr_stmt|;
name|long
name|du
init|=
name|FileUtil
operator|.
name|getDU
argument_list|(
name|TEST_DIR
argument_list|)
decl_stmt|;
comment|// Only two files (in partitioned).  Each has 3 characters + system-specific
comment|// line separator.
specifier|final
name|long
name|expected
init|=
literal|2
operator|*
operator|(
literal|3
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
operator|.
name|length
argument_list|()
operator|)
decl_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|du
argument_list|)
expr_stmt|;
comment|// target file does not exist:
specifier|final
name|File
name|doesNotExist
init|=
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
literal|"QuickBrownFoxJumpsOverTheLazyDog"
argument_list|)
decl_stmt|;
name|long
name|duDoesNotExist
init|=
name|FileUtil
operator|.
name|getDU
argument_list|(
name|doesNotExist
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|duDoesNotExist
argument_list|)
expr_stmt|;
comment|// target file is not a directory:
name|File
name|notADirectory
init|=
operator|new
name|File
argument_list|(
name|partitioned
argument_list|,
literal|"part-r-00000"
argument_list|)
decl_stmt|;
name|long
name|duNotADirectoryActual
init|=
name|FileUtil
operator|.
name|getDU
argument_list|(
name|notADirectory
argument_list|)
decl_stmt|;
name|long
name|duNotADirectoryExpected
init|=
literal|3
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
operator|.
name|length
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|duNotADirectoryExpected
argument_list|,
name|duNotADirectoryActual
argument_list|)
expr_stmt|;
try|try
block|{
comment|// one of target files is not accessible, but the containing directory
comment|// is accessible:
try|try
block|{
name|FileUtil
operator|.
name|chmod
argument_list|(
name|notADirectory
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
literal|"0000"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// should never happen since that method never throws InterruptedException.
name|assertNull
argument_list|(
name|ie
argument_list|)
expr_stmt|;
block|}
name|assertFalse
argument_list|(
name|FileUtil
operator|.
name|canRead
argument_list|(
name|notADirectory
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|long
name|du3
init|=
name|FileUtil
operator|.
name|getDU
argument_list|(
name|partitioned
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|expected
argument_list|,
name|du3
argument_list|)
expr_stmt|;
comment|// some target files and containing directory are not accessible:
try|try
block|{
name|FileUtil
operator|.
name|chmod
argument_list|(
name|partitioned
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
literal|"0000"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// should never happen since that method never throws InterruptedException.
name|assertNull
argument_list|(
name|ie
argument_list|)
expr_stmt|;
block|}
name|assertFalse
argument_list|(
name|FileUtil
operator|.
name|canRead
argument_list|(
name|partitioned
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|long
name|du4
init|=
name|FileUtil
operator|.
name|getDU
argument_list|(
name|partitioned
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|du4
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// Restore the permissions so that we can delete the folder
comment|// in @After method:
name|FileUtil
operator|.
name|chmod
argument_list|(
name|partitioned
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
literal|"0777"
argument_list|,
literal|true
comment|/*recursive*/
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testUnTar ()
specifier|public
name|void
name|testUnTar
parameter_list|()
throws|throws
name|IOException
block|{
name|setupDirs
argument_list|()
expr_stmt|;
comment|// make a simple tar:
specifier|final
name|File
name|simpleTar
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
name|FILE
argument_list|)
decl_stmt|;
name|OutputStream
name|os
init|=
operator|new
name|FileOutputStream
argument_list|(
name|simpleTar
argument_list|)
decl_stmt|;
name|TarOutputStream
name|tos
init|=
operator|new
name|TarOutputStream
argument_list|(
name|os
argument_list|)
decl_stmt|;
try|try
block|{
name|TarEntry
name|te
init|=
operator|new
name|TarEntry
argument_list|(
literal|"/bar/foo"
argument_list|)
decl_stmt|;
name|byte
index|[]
name|data
init|=
literal|"some-content"
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
decl_stmt|;
name|te
operator|.
name|setSize
argument_list|(
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|tos
operator|.
name|putNextEntry
argument_list|(
name|te
argument_list|)
expr_stmt|;
name|tos
operator|.
name|write
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|tos
operator|.
name|closeEntry
argument_list|()
expr_stmt|;
name|tos
operator|.
name|flush
argument_list|()
expr_stmt|;
name|tos
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|tos
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// successfully untar it into an existing dir:
name|FileUtil
operator|.
name|unTar
argument_list|(
name|simpleTar
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|// check result:
name|assertTrue
argument_list|(
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
literal|"/bar/foo"
argument_list|)
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|12
argument_list|,
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
literal|"/bar/foo"
argument_list|)
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|File
name|regularFile
init|=
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
literal|"QuickBrownFoxJumpsOverTheLazyDog"
argument_list|)
decl_stmt|;
name|regularFile
operator|.
name|createNewFile
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|regularFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|FileUtil
operator|.
name|unTar
argument_list|(
name|simpleTar
argument_list|,
name|regularFile
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"An IOException expected."
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// okay
block|}
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testReplaceFile ()
specifier|public
name|void
name|testReplaceFile
parameter_list|()
throws|throws
name|IOException
block|{
name|setupDirs
argument_list|()
expr_stmt|;
specifier|final
name|File
name|srcFile
init|=
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
literal|"src"
argument_list|)
decl_stmt|;
comment|// src exists, and target does not exist:
name|srcFile
operator|.
name|createNewFile
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|srcFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|File
name|targetFile
init|=
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
literal|"target"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
operator|!
name|targetFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|FileUtil
operator|.
name|replaceFile
argument_list|(
name|srcFile
argument_list|,
name|targetFile
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
operator|!
name|srcFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|targetFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
comment|// src exists and target is a regular file:
name|srcFile
operator|.
name|createNewFile
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|srcFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|FileUtil
operator|.
name|replaceFile
argument_list|(
name|srcFile
argument_list|,
name|targetFile
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
operator|!
name|srcFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|targetFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
comment|// src exists, and target is a non-empty directory:
name|srcFile
operator|.
name|createNewFile
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|srcFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|targetFile
operator|.
name|delete
argument_list|()
expr_stmt|;
name|targetFile
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|File
name|obstacle
init|=
operator|new
name|File
argument_list|(
name|targetFile
argument_list|,
literal|"obstacle"
argument_list|)
decl_stmt|;
name|obstacle
operator|.
name|createNewFile
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|obstacle
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|targetFile
operator|.
name|exists
argument_list|()
operator|&&
name|targetFile
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|FileUtil
operator|.
name|replaceFile
argument_list|(
name|srcFile
argument_list|,
name|targetFile
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// okay
block|}
comment|// check up the post-condition: nothing is deleted:
name|assertTrue
argument_list|(
name|srcFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|targetFile
operator|.
name|exists
argument_list|()
operator|&&
name|targetFile
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|obstacle
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testCreateLocalTempFile ()
specifier|public
name|void
name|testCreateLocalTempFile
parameter_list|()
throws|throws
name|IOException
block|{
name|setupDirs
argument_list|()
expr_stmt|;
specifier|final
name|File
name|baseFile
init|=
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
literal|"base"
argument_list|)
decl_stmt|;
name|File
name|tmp1
init|=
name|FileUtil
operator|.
name|createLocalTempFile
argument_list|(
name|baseFile
argument_list|,
literal|"foo"
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|File
name|tmp2
init|=
name|FileUtil
operator|.
name|createLocalTempFile
argument_list|(
name|baseFile
argument_list|,
literal|"foo"
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|tmp1
operator|.
name|getAbsolutePath
argument_list|()
operator|.
name|equals
argument_list|(
name|baseFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|tmp2
operator|.
name|getAbsolutePath
argument_list|()
operator|.
name|equals
argument_list|(
name|baseFile
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tmp1
operator|.
name|exists
argument_list|()
operator|&&
name|tmp2
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tmp1
operator|.
name|canWrite
argument_list|()
operator|&&
name|tmp2
operator|.
name|canWrite
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tmp1
operator|.
name|canRead
argument_list|()
operator|&&
name|tmp2
operator|.
name|canRead
argument_list|()
argument_list|)
expr_stmt|;
name|tmp1
operator|.
name|delete
argument_list|()
expr_stmt|;
name|tmp2
operator|.
name|delete
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
operator|!
name|tmp1
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|tmp2
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testUnZip ()
specifier|public
name|void
name|testUnZip
parameter_list|()
throws|throws
name|IOException
block|{
name|setupDirs
argument_list|()
expr_stmt|;
comment|// make a simple zip
specifier|final
name|File
name|simpleZip
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
name|FILE
argument_list|)
decl_stmt|;
name|OutputStream
name|os
init|=
operator|new
name|FileOutputStream
argument_list|(
name|simpleZip
argument_list|)
decl_stmt|;
name|ZipOutputStream
name|tos
init|=
operator|new
name|ZipOutputStream
argument_list|(
name|os
argument_list|)
decl_stmt|;
try|try
block|{
name|ZipEntry
name|ze
init|=
operator|new
name|ZipEntry
argument_list|(
literal|"foo"
argument_list|)
decl_stmt|;
name|byte
index|[]
name|data
init|=
literal|"some-content"
operator|.
name|getBytes
argument_list|(
literal|"UTF-8"
argument_list|)
decl_stmt|;
name|ze
operator|.
name|setSize
argument_list|(
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|tos
operator|.
name|putNextEntry
argument_list|(
name|ze
argument_list|)
expr_stmt|;
name|tos
operator|.
name|write
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|tos
operator|.
name|closeEntry
argument_list|()
expr_stmt|;
name|tos
operator|.
name|flush
argument_list|()
expr_stmt|;
name|tos
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|tos
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// successfully unzip it into an existing dir:
name|FileUtil
operator|.
name|unZip
argument_list|(
name|simpleZip
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|// check result:
name|assertTrue
argument_list|(
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
literal|"foo"
argument_list|)
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|12
argument_list|,
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
literal|"foo"
argument_list|)
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|File
name|regularFile
init|=
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
literal|"QuickBrownFoxJumpsOverTheLazyDog"
argument_list|)
decl_stmt|;
name|regularFile
operator|.
name|createNewFile
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|regularFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|FileUtil
operator|.
name|unZip
argument_list|(
name|simpleZip
argument_list|,
name|regularFile
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
literal|"An IOException expected."
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// okay
block|}
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testUnZip2 ()
specifier|public
name|void
name|testUnZip2
parameter_list|()
throws|throws
name|IOException
block|{
name|setupDirs
argument_list|()
expr_stmt|;
comment|// make a simple zip
specifier|final
name|File
name|simpleZip
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
name|FILE
argument_list|)
decl_stmt|;
name|OutputStream
name|os
init|=
operator|new
name|FileOutputStream
argument_list|(
name|simpleZip
argument_list|)
decl_stmt|;
try|try
init|(
name|ZipOutputStream
name|tos
init|=
operator|new
name|ZipOutputStream
argument_list|(
name|os
argument_list|)
init|)
block|{
comment|// Add an entry that contains invalid filename
name|ZipEntry
name|ze
init|=
operator|new
name|ZipEntry
argument_list|(
literal|"../foo"
argument_list|)
decl_stmt|;
name|byte
index|[]
name|data
init|=
literal|"some-content"
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
decl_stmt|;
name|ze
operator|.
name|setSize
argument_list|(
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|tos
operator|.
name|putNextEntry
argument_list|(
name|ze
argument_list|)
expr_stmt|;
name|tos
operator|.
name|write
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|tos
operator|.
name|closeEntry
argument_list|()
expr_stmt|;
name|tos
operator|.
name|flush
argument_list|()
expr_stmt|;
name|tos
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
comment|// Unzip it into an existing dir
try|try
block|{
name|FileUtil
operator|.
name|unZip
argument_list|(
name|simpleZip
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"unZip should throw IOException."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|GenericTestUtils
operator|.
name|assertExceptionContains
argument_list|(
literal|"would create file outside of"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
comment|/*    * Test method copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf)    */
DECL|method|testCopy5 ()
specifier|public
name|void
name|testCopy5
parameter_list|()
throws|throws
name|IOException
block|{
name|setupDirs
argument_list|()
expr_stmt|;
name|URI
name|uri
init|=
name|tmp
operator|.
name|toURI
argument_list|()
decl_stmt|;
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|FileSystem
name|fs
init|=
name|FileSystem
operator|.
name|newInstance
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|String
name|content
init|=
literal|"some-content"
decl_stmt|;
name|File
name|srcFile
init|=
name|createFile
argument_list|(
name|tmp
argument_list|,
literal|"src"
argument_list|,
name|content
argument_list|)
decl_stmt|;
name|Path
name|srcPath
init|=
operator|new
name|Path
argument_list|(
name|srcFile
operator|.
name|toURI
argument_list|()
argument_list|)
decl_stmt|;
comment|// copy regular file:
specifier|final
name|File
name|dest
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
literal|"dest"
argument_list|)
decl_stmt|;
name|boolean
name|result
init|=
name|FileUtil
operator|.
name|copy
argument_list|(
name|fs
argument_list|,
name|srcPath
argument_list|,
name|dest
argument_list|,
literal|false
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|dest
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|content
operator|.
name|getBytes
argument_list|()
operator|.
name|length
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
operator|.
name|getBytes
argument_list|()
operator|.
name|length
argument_list|,
name|dest
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|srcFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
comment|// should not be deleted
comment|// copy regular file, delete src:
name|dest
operator|.
name|delete
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
operator|!
name|dest
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|=
name|FileUtil
operator|.
name|copy
argument_list|(
name|fs
argument_list|,
name|srcPath
argument_list|,
name|dest
argument_list|,
literal|true
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|dest
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|content
operator|.
name|getBytes
argument_list|()
operator|.
name|length
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
operator|.
name|getBytes
argument_list|()
operator|.
name|length
argument_list|,
name|dest
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
operator|!
name|srcFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
comment|// should be deleted
comment|// copy a dir:
name|dest
operator|.
name|delete
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
operator|!
name|dest
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|srcPath
operator|=
operator|new
name|Path
argument_list|(
name|partitioned
operator|.
name|toURI
argument_list|()
argument_list|)
expr_stmt|;
name|result
operator|=
name|FileUtil
operator|.
name|copy
argument_list|(
name|fs
argument_list|,
name|srcPath
argument_list|,
name|dest
argument_list|,
literal|true
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|dest
operator|.
name|exists
argument_list|()
operator|&&
name|dest
operator|.
name|isDirectory
argument_list|()
argument_list|)
expr_stmt|;
name|File
index|[]
name|files
init|=
name|dest
operator|.
name|listFiles
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
name|files
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|files
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|File
name|f
range|:
name|files
control|)
block|{
name|assertEquals
argument_list|(
literal|3
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"line.separator"
argument_list|)
operator|.
name|getBytes
argument_list|()
operator|.
name|length
argument_list|,
name|f
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
operator|!
name|partitioned
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
comment|// should be deleted
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testStat2Paths1 ()
specifier|public
name|void
name|testStat2Paths1
parameter_list|()
block|{
name|assertNull
argument_list|(
name|FileUtil
operator|.
name|stat2Paths
argument_list|(
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|fileStatuses
init|=
operator|new
name|FileStatus
index|[
literal|0
index|]
decl_stmt|;
name|Path
index|[]
name|paths
init|=
name|FileUtil
operator|.
name|stat2Paths
argument_list|(
name|fileStatuses
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|paths
operator|.
name|length
argument_list|)
expr_stmt|;
name|Path
name|path1
init|=
operator|new
name|Path
argument_list|(
literal|"file://foo"
argument_list|)
decl_stmt|;
name|Path
name|path2
init|=
operator|new
name|Path
argument_list|(
literal|"file://moo"
argument_list|)
decl_stmt|;
name|fileStatuses
operator|=
operator|new
name|FileStatus
index|[]
block|{
operator|new
name|FileStatus
argument_list|(
literal|3
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|path1
argument_list|)
block|,
operator|new
name|FileStatus
argument_list|(
literal|3
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|path2
argument_list|)
block|}
expr_stmt|;
name|paths
operator|=
name|FileUtil
operator|.
name|stat2Paths
argument_list|(
name|fileStatuses
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|paths
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|paths
index|[
literal|0
index|]
argument_list|,
name|path1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|paths
index|[
literal|1
index|]
argument_list|,
name|path2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testStat2Paths2 ()
specifier|public
name|void
name|testStat2Paths2
parameter_list|()
block|{
name|Path
name|defaultPath
init|=
operator|new
name|Path
argument_list|(
literal|"file://default"
argument_list|)
decl_stmt|;
name|Path
index|[]
name|paths
init|=
name|FileUtil
operator|.
name|stat2Paths
argument_list|(
literal|null
argument_list|,
name|defaultPath
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|paths
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|defaultPath
argument_list|,
name|paths
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|paths
operator|=
name|FileUtil
operator|.
name|stat2Paths
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|paths
operator|!=
literal|null
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|paths
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|null
argument_list|,
name|paths
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|Path
name|path1
init|=
operator|new
name|Path
argument_list|(
literal|"file://foo"
argument_list|)
decl_stmt|;
name|Path
name|path2
init|=
operator|new
name|Path
argument_list|(
literal|"file://moo"
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|fileStatuses
init|=
operator|new
name|FileStatus
index|[]
block|{
operator|new
name|FileStatus
argument_list|(
literal|3
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|path1
argument_list|)
block|,
operator|new
name|FileStatus
argument_list|(
literal|3
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|path2
argument_list|)
block|}
decl_stmt|;
name|paths
operator|=
name|FileUtil
operator|.
name|stat2Paths
argument_list|(
name|fileStatuses
argument_list|,
name|defaultPath
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|paths
operator|.
name|length
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|paths
index|[
literal|0
index|]
argument_list|,
name|path1
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|paths
index|[
literal|1
index|]
argument_list|,
name|path2
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testSymlink ()
specifier|public
name|void
name|testSymlink
parameter_list|()
throws|throws
name|Exception
block|{
name|Assert
operator|.
name|assertFalse
argument_list|(
name|del
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|del
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|byte
index|[]
name|data
init|=
literal|"testSymLink"
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
name|FILE
argument_list|)
decl_stmt|;
name|File
name|link
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
literal|"_link"
argument_list|)
decl_stmt|;
comment|//write some data to the file
name|FileOutputStream
name|os
init|=
operator|new
name|FileOutputStream
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|os
operator|.
name|write
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
comment|//create the symlink
name|FileUtil
operator|.
name|symLink
argument_list|(
name|file
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|link
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
comment|//ensure that symlink length is correctly reported by Java
name|Assert
operator|.
name|assertEquals
argument_list|(
name|data
operator|.
name|length
argument_list|,
name|file
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|data
operator|.
name|length
argument_list|,
name|link
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
comment|//ensure that we can read from link.
name|FileInputStream
name|in
init|=
operator|new
name|FileInputStream
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|long
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|in
operator|.
name|read
argument_list|()
operator|>
literal|0
condition|)
block|{
name|len
operator|++
expr_stmt|;
block|}
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|data
operator|.
name|length
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that rename on a symlink works as expected.    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testSymlinkRenameTo ()
specifier|public
name|void
name|testSymlinkRenameTo
parameter_list|()
throws|throws
name|Exception
block|{
name|Assert
operator|.
name|assertFalse
argument_list|(
name|del
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|del
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
name|FILE
argument_list|)
decl_stmt|;
name|file
operator|.
name|createNewFile
argument_list|()
expr_stmt|;
name|File
name|link
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
literal|"_link"
argument_list|)
decl_stmt|;
comment|// create the symlink
name|FileUtil
operator|.
name|symLink
argument_list|(
name|file
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|link
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|file
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|link
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|File
name|link2
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
literal|"_link2"
argument_list|)
decl_stmt|;
comment|// Rename the symlink
name|Assert
operator|.
name|assertTrue
argument_list|(
name|link
operator|.
name|renameTo
argument_list|(
name|link2
argument_list|)
argument_list|)
expr_stmt|;
comment|// Make sure the file still exists
comment|// (NOTE: this would fail on Java6 on Windows if we didn't
comment|// copy the file in FileUtil#symlink)
name|Assert
operator|.
name|assertTrue
argument_list|(
name|file
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|link2
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
name|link
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that deletion of a symlink works as expected.    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testSymlinkDelete ()
specifier|public
name|void
name|testSymlinkDelete
parameter_list|()
throws|throws
name|Exception
block|{
name|Assert
operator|.
name|assertFalse
argument_list|(
name|del
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|del
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
name|FILE
argument_list|)
decl_stmt|;
name|file
operator|.
name|createNewFile
argument_list|()
expr_stmt|;
name|File
name|link
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
literal|"_link"
argument_list|)
decl_stmt|;
comment|// create the symlink
name|FileUtil
operator|.
name|symLink
argument_list|(
name|file
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|link
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|file
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|link
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
comment|// make sure that deleting a symlink works properly
name|Assert
operator|.
name|assertTrue
argument_list|(
name|link
operator|.
name|delete
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
name|link
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|file
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Test that length on a symlink works as expected.    */
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testSymlinkLength ()
specifier|public
name|void
name|testSymlinkLength
parameter_list|()
throws|throws
name|Exception
block|{
name|Assert
operator|.
name|assertFalse
argument_list|(
name|del
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|del
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|byte
index|[]
name|data
init|=
literal|"testSymLinkData"
operator|.
name|getBytes
argument_list|()
decl_stmt|;
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
name|FILE
argument_list|)
decl_stmt|;
name|File
name|link
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
literal|"_link"
argument_list|)
decl_stmt|;
comment|// write some data to the file
name|FileOutputStream
name|os
init|=
operator|new
name|FileOutputStream
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|os
operator|.
name|write
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|link
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
comment|// create the symlink
name|FileUtil
operator|.
name|symLink
argument_list|(
name|file
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|link
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
comment|// ensure that File#length returns the target file and link size
name|Assert
operator|.
name|assertEquals
argument_list|(
name|data
operator|.
name|length
argument_list|,
name|file
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|data
operator|.
name|length
argument_list|,
name|link
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|file
operator|.
name|delete
argument_list|()
expr_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
name|file
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|link
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|link
operator|.
name|delete
argument_list|()
expr_stmt|;
name|Assert
operator|.
name|assertFalse
argument_list|(
name|link
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|doUntarAndVerify (File tarFile, File untarDir)
specifier|private
name|void
name|doUntarAndVerify
parameter_list|(
name|File
name|tarFile
parameter_list|,
name|File
name|untarDir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|untarDir
operator|.
name|exists
argument_list|()
operator|&&
operator|!
name|FileUtil
operator|.
name|fullyDelete
argument_list|(
name|untarDir
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not delete directory '"
operator|+
name|untarDir
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|FileUtil
operator|.
name|unTar
argument_list|(
name|tarFile
argument_list|,
name|untarDir
argument_list|)
expr_stmt|;
name|String
name|parentDir
init|=
name|untarDir
operator|.
name|getCanonicalPath
argument_list|()
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
literal|"name"
decl_stmt|;
name|File
name|testFile
init|=
operator|new
name|File
argument_list|(
name|parentDir
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
literal|"version"
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|testFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|testFile
operator|.
name|length
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
name|String
name|imageDir
init|=
name|parentDir
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
literal|"image"
decl_stmt|;
name|testFile
operator|=
operator|new
name|File
argument_list|(
name|imageDir
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
literal|"fsimage"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|testFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|testFile
operator|.
name|length
argument_list|()
operator|==
literal|157
argument_list|)
expr_stmt|;
name|String
name|currentDir
init|=
name|parentDir
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
literal|"current"
decl_stmt|;
name|testFile
operator|=
operator|new
name|File
argument_list|(
name|currentDir
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
literal|"fsimage"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|testFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|testFile
operator|.
name|length
argument_list|()
operator|==
literal|4331
argument_list|)
expr_stmt|;
name|testFile
operator|=
operator|new
name|File
argument_list|(
name|currentDir
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
literal|"edits"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|testFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|testFile
operator|.
name|length
argument_list|()
operator|==
literal|1033
argument_list|)
expr_stmt|;
name|testFile
operator|=
operator|new
name|File
argument_list|(
name|currentDir
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
literal|"fstime"
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|testFile
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|testFile
operator|.
name|length
argument_list|()
operator|==
literal|8
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testUntar ()
specifier|public
name|void
name|testUntar
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|tarGzFileName
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"test.cache.data"
argument_list|,
literal|"target/test/cache"
argument_list|)
operator|+
literal|"/test-untar.tgz"
decl_stmt|;
name|String
name|tarFileName
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"test.cache.data"
argument_list|,
literal|"build/test/cache"
argument_list|)
operator|+
literal|"/test-untar.tar"
decl_stmt|;
name|File
name|dataDir
init|=
name|GenericTestUtils
operator|.
name|getTestDir
argument_list|()
decl_stmt|;
name|File
name|untarDir
init|=
operator|new
name|File
argument_list|(
name|dataDir
argument_list|,
literal|"untarDir"
argument_list|)
decl_stmt|;
name|doUntarAndVerify
argument_list|(
operator|new
name|File
argument_list|(
name|tarGzFileName
argument_list|)
argument_list|,
name|untarDir
argument_list|)
expr_stmt|;
name|doUntarAndVerify
argument_list|(
operator|new
name|File
argument_list|(
name|tarFileName
argument_list|)
argument_list|,
name|untarDir
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|30000
argument_list|)
DECL|method|testCreateJarWithClassPath ()
specifier|public
name|void
name|testCreateJarWithClassPath
parameter_list|()
throws|throws
name|Exception
block|{
comment|// setup test directory for files
name|Assert
operator|.
name|assertFalse
argument_list|(
name|tmp
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|tmp
operator|.
name|mkdirs
argument_list|()
argument_list|)
expr_stmt|;
comment|// create files expected to match a wildcard
name|List
argument_list|<
name|File
argument_list|>
name|wildcardMatches
init|=
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
literal|"wildcard1.jar"
argument_list|)
argument_list|,
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
literal|"wildcard2.jar"
argument_list|)
argument_list|,
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
literal|"wildcard3.JAR"
argument_list|)
argument_list|,
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
literal|"wildcard4.JAR"
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|File
name|wildcardMatch
range|:
name|wildcardMatches
control|)
block|{
name|Assert
operator|.
name|assertTrue
argument_list|(
literal|"failure creating file: "
operator|+
name|wildcardMatch
argument_list|,
name|wildcardMatch
operator|.
name|createNewFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// create non-jar files, which we expect to not be included in the classpath
name|Assert
operator|.
name|assertTrue
argument_list|(
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
literal|"text.txt"
argument_list|)
operator|.
name|createNewFile
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
literal|"executable.exe"
argument_list|)
operator|.
name|createNewFile
argument_list|()
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
literal|"README"
argument_list|)
operator|.
name|createNewFile
argument_list|()
argument_list|)
expr_stmt|;
comment|// create classpath jar
name|String
name|wildcardPath
init|=
name|tmp
operator|.
name|getCanonicalPath
argument_list|()
operator|+
name|File
operator|.
name|separator
operator|+
literal|"*"
decl_stmt|;
name|String
name|nonExistentSubdir
init|=
name|tmp
operator|.
name|getCanonicalPath
argument_list|()
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
literal|"subdir"
operator|+
name|Path
operator|.
name|SEPARATOR
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|classPaths
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|""
argument_list|,
literal|"cp1.jar"
argument_list|,
literal|"cp2.jar"
argument_list|,
name|wildcardPath
argument_list|,
literal|"cp3.jar"
argument_list|,
name|nonExistentSubdir
argument_list|)
decl_stmt|;
name|String
name|inputClassPath
init|=
name|StringUtils
operator|.
name|join
argument_list|(
name|File
operator|.
name|pathSeparator
argument_list|,
name|classPaths
argument_list|)
decl_stmt|;
name|String
index|[]
name|jarCp
init|=
name|FileUtil
operator|.
name|createJarWithClassPath
argument_list|(
name|inputClassPath
operator|+
name|File
operator|.
name|pathSeparator
operator|+
literal|"unexpandedwildcard/*"
argument_list|,
operator|new
name|Path
argument_list|(
name|tmp
operator|.
name|getCanonicalPath
argument_list|()
argument_list|)
argument_list|,
name|System
operator|.
name|getenv
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|classPathJar
init|=
name|jarCp
index|[
literal|0
index|]
decl_stmt|;
name|assertNotEquals
argument_list|(
literal|"Unexpanded wildcard was not placed in extra classpath"
argument_list|,
name|jarCp
index|[
literal|1
index|]
operator|.
name|indexOf
argument_list|(
literal|"unexpanded"
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// verify classpath by reading manifest from jar file
name|JarFile
name|jarFile
init|=
literal|null
decl_stmt|;
try|try
block|{
name|jarFile
operator|=
operator|new
name|JarFile
argument_list|(
name|classPathJar
argument_list|)
expr_stmt|;
name|Manifest
name|jarManifest
init|=
name|jarFile
operator|.
name|getManifest
argument_list|()
decl_stmt|;
name|Assert
operator|.
name|assertNotNull
argument_list|(
name|jarManifest
argument_list|)
expr_stmt|;
name|Attributes
name|mainAttributes
init|=
name|jarManifest
operator|.
name|getMainAttributes
argument_list|()
decl_stmt|;
name|Assert
operator|.
name|assertNotNull
argument_list|(
name|mainAttributes
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertTrue
argument_list|(
name|mainAttributes
operator|.
name|containsKey
argument_list|(
name|Attributes
operator|.
name|Name
operator|.
name|CLASS_PATH
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|classPathAttr
init|=
name|mainAttributes
operator|.
name|getValue
argument_list|(
name|Attributes
operator|.
name|Name
operator|.
name|CLASS_PATH
argument_list|)
decl_stmt|;
name|Assert
operator|.
name|assertNotNull
argument_list|(
name|classPathAttr
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|expectedClassPaths
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|classPath
range|:
name|classPaths
control|)
block|{
if|if
condition|(
name|classPath
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|wildcardPath
operator|.
name|equals
argument_list|(
name|classPath
argument_list|)
condition|)
block|{
comment|// add wildcard matches
for|for
control|(
name|File
name|wildcardMatch
range|:
name|wildcardMatches
control|)
block|{
name|expectedClassPaths
operator|.
name|add
argument_list|(
name|wildcardMatch
operator|.
name|toURI
argument_list|()
operator|.
name|toURL
argument_list|()
operator|.
name|toExternalForm
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|File
name|fileCp
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
operator|new
name|Path
argument_list|(
name|classPath
argument_list|)
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
name|fileCp
operator|=
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
name|classPath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fileCp
operator|=
operator|new
name|File
argument_list|(
name|classPath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nonExistentSubdir
operator|.
name|equals
argument_list|(
name|classPath
argument_list|)
condition|)
block|{
comment|// expect to maintain trailing path separator if present in input, even
comment|// if directory doesn't exist yet
name|expectedClassPaths
operator|.
name|add
argument_list|(
name|fileCp
operator|.
name|toURI
argument_list|()
operator|.
name|toURL
argument_list|()
operator|.
name|toExternalForm
argument_list|()
operator|+
name|Path
operator|.
name|SEPARATOR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expectedClassPaths
operator|.
name|add
argument_list|(
name|fileCp
operator|.
name|toURI
argument_list|()
operator|.
name|toURL
argument_list|()
operator|.
name|toExternalForm
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|List
argument_list|<
name|String
argument_list|>
name|actualClassPaths
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|classPathAttr
operator|.
name|split
argument_list|(
literal|" "
argument_list|)
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|expectedClassPaths
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|actualClassPaths
argument_list|)
expr_stmt|;
name|Assert
operator|.
name|assertEquals
argument_list|(
name|expectedClassPaths
argument_list|,
name|actualClassPaths
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|jarFile
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|jarFile
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"exception closing jarFile: "
operator|+
name|classPathJar
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Test
DECL|method|testGetJarsInDirectory ()
specifier|public
name|void
name|testGetJarsInDirectory
parameter_list|()
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|Path
argument_list|>
name|jars
init|=
name|FileUtil
operator|.
name|getJarsInDirectory
argument_list|(
literal|"/foo/bar/bogus/"
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
literal|"no jars should be returned for a bogus path"
argument_list|,
name|jars
operator|.
name|isEmpty
argument_list|()
argument_list|)
expr_stmt|;
comment|// setup test directory for files
name|assertFalse
argument_list|(
name|tmp
operator|.
name|exists
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|tmp
operator|.
name|mkdirs
argument_list|()
argument_list|)
expr_stmt|;
comment|// create jar files to be returned
name|File
name|jar1
init|=
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
literal|"wildcard1.jar"
argument_list|)
decl_stmt|;
name|File
name|jar2
init|=
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
literal|"wildcard2.JAR"
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|File
argument_list|>
name|matches
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|jar1
argument_list|,
name|jar2
argument_list|)
decl_stmt|;
for|for
control|(
name|File
name|match
range|:
name|matches
control|)
block|{
name|assertTrue
argument_list|(
literal|"failure creating file: "
operator|+
name|match
argument_list|,
name|match
operator|.
name|createNewFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// create non-jar files, which we expect to not be included in the result
name|assertTrue
argument_list|(
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
literal|"text.txt"
argument_list|)
operator|.
name|createNewFile
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
literal|"executable.exe"
argument_list|)
operator|.
name|createNewFile
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
operator|new
name|File
argument_list|(
name|tmp
argument_list|,
literal|"README"
argument_list|)
operator|.
name|createNewFile
argument_list|()
argument_list|)
expr_stmt|;
comment|// pass in the directory
name|String
name|directory
init|=
name|tmp
operator|.
name|getCanonicalPath
argument_list|()
decl_stmt|;
name|jars
operator|=
name|FileUtil
operator|.
name|getJarsInDirectory
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"there should be 2 jars"
argument_list|,
literal|2
argument_list|,
name|jars
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Path
name|jar
range|:
name|jars
control|)
block|{
name|URL
name|url
init|=
name|jar
operator|.
name|toUri
argument_list|()
operator|.
name|toURL
argument_list|()
decl_stmt|;
name|assertTrue
argument_list|(
literal|"the jar should match either of the jars"
argument_list|,
name|url
operator|.
name|equals
argument_list|(
name|jar1
operator|.
name|toURI
argument_list|()
operator|.
name|toURL
argument_list|()
argument_list|)
operator|||
name|url
operator|.
name|equals
argument_list|(
name|jar2
operator|.
name|toURI
argument_list|()
operator|.
name|toURL
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Ignore
DECL|method|setupCompareFs ()
specifier|public
name|void
name|setupCompareFs
parameter_list|()
block|{
comment|// Set up Strings
name|String
name|host1
init|=
literal|"1.2.3.4"
decl_stmt|;
name|String
name|host2
init|=
literal|"2.3.4.5"
decl_stmt|;
name|int
name|port1
init|=
literal|7000
decl_stmt|;
name|int
name|port2
init|=
literal|7001
decl_stmt|;
name|String
name|uris1
init|=
literal|"hdfs://"
operator|+
name|host1
operator|+
literal|":"
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|port1
argument_list|)
operator|+
literal|"/tmp/foo"
decl_stmt|;
name|String
name|uris2
init|=
literal|"hdfs://"
operator|+
name|host1
operator|+
literal|":"
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|port2
argument_list|)
operator|+
literal|"/tmp/foo"
decl_stmt|;
name|String
name|uris3
init|=
literal|"hdfs://"
operator|+
name|host2
operator|+
literal|":"
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|port2
argument_list|)
operator|+
literal|"/tmp/foo"
decl_stmt|;
name|String
name|uris4
init|=
literal|"hdfs://"
operator|+
name|host2
operator|+
literal|":"
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|port2
argument_list|)
operator|+
literal|"/tmp/foo"
decl_stmt|;
name|String
name|uris5
init|=
literal|"file:///"
operator|+
name|host1
operator|+
literal|":"
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|port1
argument_list|)
operator|+
literal|"/tmp/foo"
decl_stmt|;
name|String
name|uris6
init|=
literal|"hdfs:///"
operator|+
name|host1
operator|+
literal|"/tmp/foo"
decl_stmt|;
comment|// Set up URI objects
try|try
block|{
name|uri1
operator|=
operator|new
name|URI
argument_list|(
name|uris1
argument_list|)
expr_stmt|;
name|uri2
operator|=
operator|new
name|URI
argument_list|(
name|uris2
argument_list|)
expr_stmt|;
name|uri3
operator|=
operator|new
name|URI
argument_list|(
name|uris3
argument_list|)
expr_stmt|;
name|uri4
operator|=
operator|new
name|URI
argument_list|(
name|uris4
argument_list|)
expr_stmt|;
name|uri5
operator|=
operator|new
name|URI
argument_list|(
name|uris5
argument_list|)
expr_stmt|;
name|uri6
operator|=
operator|new
name|URI
argument_list|(
name|uris6
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|use
parameter_list|)
block|{     }
comment|// Set up InetAddress
name|inet1
operator|=
name|mock
argument_list|(
name|InetAddress
operator|.
name|class
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|inet1
operator|.
name|getCanonicalHostName
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|host1
argument_list|)
expr_stmt|;
name|inet2
operator|=
name|mock
argument_list|(
name|InetAddress
operator|.
name|class
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|inet2
operator|.
name|getCanonicalHostName
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|host1
argument_list|)
expr_stmt|;
name|inet3
operator|=
name|mock
argument_list|(
name|InetAddress
operator|.
name|class
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|inet3
operator|.
name|getCanonicalHostName
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|host2
argument_list|)
expr_stmt|;
name|inet4
operator|=
name|mock
argument_list|(
name|InetAddress
operator|.
name|class
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|inet4
operator|.
name|getCanonicalHostName
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|host2
argument_list|)
expr_stmt|;
name|inet5
operator|=
name|mock
argument_list|(
name|InetAddress
operator|.
name|class
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|inet5
operator|.
name|getCanonicalHostName
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|host1
argument_list|)
expr_stmt|;
name|inet6
operator|=
name|mock
argument_list|(
name|InetAddress
operator|.
name|class
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|inet6
operator|.
name|getCanonicalHostName
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|host1
argument_list|)
expr_stmt|;
comment|// Link of InetAddress to corresponding URI
try|try
block|{
name|when
argument_list|(
name|InetAddress
operator|.
name|getByName
argument_list|(
name|uris1
argument_list|)
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|inet1
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|InetAddress
operator|.
name|getByName
argument_list|(
name|uris2
argument_list|)
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|inet2
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|InetAddress
operator|.
name|getByName
argument_list|(
name|uris3
argument_list|)
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|inet3
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|InetAddress
operator|.
name|getByName
argument_list|(
name|uris4
argument_list|)
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|inet4
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|InetAddress
operator|.
name|getByName
argument_list|(
name|uris5
argument_list|)
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|inet5
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnknownHostException
name|ue
parameter_list|)
block|{     }
name|fs1
operator|=
name|mock
argument_list|(
name|FileSystem
operator|.
name|class
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|fs1
operator|.
name|getUri
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|uri1
argument_list|)
expr_stmt|;
name|fs2
operator|=
name|mock
argument_list|(
name|FileSystem
operator|.
name|class
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|fs2
operator|.
name|getUri
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|uri2
argument_list|)
expr_stmt|;
name|fs3
operator|=
name|mock
argument_list|(
name|FileSystem
operator|.
name|class
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|fs3
operator|.
name|getUri
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|uri3
argument_list|)
expr_stmt|;
name|fs4
operator|=
name|mock
argument_list|(
name|FileSystem
operator|.
name|class
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|fs4
operator|.
name|getUri
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|uri4
argument_list|)
expr_stmt|;
name|fs5
operator|=
name|mock
argument_list|(
name|FileSystem
operator|.
name|class
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|fs5
operator|.
name|getUri
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|uri5
argument_list|)
expr_stmt|;
name|fs6
operator|=
name|mock
argument_list|(
name|FileSystem
operator|.
name|class
argument_list|)
expr_stmt|;
name|when
argument_list|(
name|fs6
operator|.
name|getUri
argument_list|()
argument_list|)
operator|.
name|thenReturn
argument_list|(
name|uri6
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testCompareFsNull ()
specifier|public
name|void
name|testCompareFsNull
parameter_list|()
throws|throws
name|Exception
block|{
name|setupCompareFs
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|FileUtil
operator|.
name|compareFs
argument_list|(
literal|null
argument_list|,
name|fs1
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|FileUtil
operator|.
name|compareFs
argument_list|(
name|fs1
argument_list|,
literal|null
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
DECL|method|testCompareFsDirectories ()
specifier|public
name|void
name|testCompareFsDirectories
parameter_list|()
throws|throws
name|Exception
block|{
name|setupCompareFs
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
name|FileUtil
operator|.
name|compareFs
argument_list|(
name|fs1
argument_list|,
name|fs1
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|FileUtil
operator|.
name|compareFs
argument_list|(
name|fs1
argument_list|,
name|fs2
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|FileUtil
operator|.
name|compareFs
argument_list|(
name|fs1
argument_list|,
name|fs5
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|FileUtil
operator|.
name|compareFs
argument_list|(
name|fs3
argument_list|,
name|fs4
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|FileUtil
operator|.
name|compareFs
argument_list|(
name|fs1
argument_list|,
name|fs6
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Test
argument_list|(
name|timeout
operator|=
literal|8000
argument_list|)
DECL|method|testCreateSymbolicLinkUsingJava ()
specifier|public
name|void
name|testCreateSymbolicLinkUsingJava
parameter_list|()
throws|throws
name|IOException
block|{
name|setupDirs
argument_list|()
expr_stmt|;
specifier|final
name|File
name|simpleTar
init|=
operator|new
name|File
argument_list|(
name|del
argument_list|,
name|FILE
argument_list|)
decl_stmt|;
name|OutputStream
name|os
init|=
operator|new
name|FileOutputStream
argument_list|(
name|simpleTar
argument_list|)
decl_stmt|;
name|TarArchiveOutputStream
name|tos
init|=
operator|new
name|TarArchiveOutputStream
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|File
name|untarFile
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// Files to tar
specifier|final
name|String
name|tmpDir
init|=
literal|"tmp/test"
decl_stmt|;
name|File
name|tmpDir1
init|=
operator|new
name|File
argument_list|(
name|tmpDir
argument_list|,
literal|"dir1/"
argument_list|)
decl_stmt|;
name|File
name|tmpDir2
init|=
operator|new
name|File
argument_list|(
name|tmpDir
argument_list|,
literal|"dir2/"
argument_list|)
decl_stmt|;
comment|// Delete the directories if they already exist
name|tmpDir1
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|tmpDir2
operator|.
name|mkdirs
argument_list|()
expr_stmt|;
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
name|symLink
init|=
name|FileSystems
operator|.
name|getDefault
argument_list|()
operator|.
name|getPath
argument_list|(
name|tmpDir1
operator|.
name|getPath
argument_list|()
operator|+
literal|"/sl"
argument_list|)
decl_stmt|;
comment|// Create Symbolic Link
name|Files
operator|.
name|createSymbolicLink
argument_list|(
name|symLink
argument_list|,
name|FileSystems
operator|.
name|getDefault
argument_list|()
operator|.
name|getPath
argument_list|(
name|tmpDir2
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
name|assertTrue
argument_list|(
name|Files
operator|.
name|isSymbolicLink
argument_list|(
name|symLink
operator|.
name|toAbsolutePath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// put entries in tar file
name|putEntriesInTar
argument_list|(
name|tos
argument_list|,
name|tmpDir1
operator|.
name|getParentFile
argument_list|()
argument_list|)
expr_stmt|;
name|tos
operator|.
name|close
argument_list|()
expr_stmt|;
name|untarFile
operator|=
operator|new
name|File
argument_list|(
name|tmpDir
argument_list|,
literal|"2"
argument_list|)
expr_stmt|;
comment|// Untar using java
name|FileUtil
operator|.
name|unTarUsingJava
argument_list|(
name|simpleTar
argument_list|,
name|untarFile
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// Check symbolic link and other directories are there in untar file
name|assertTrue
argument_list|(
name|Files
operator|.
name|exists
argument_list|(
name|untarFile
operator|.
name|toPath
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Files
operator|.
name|exists
argument_list|(
name|FileSystems
operator|.
name|getDefault
argument_list|()
operator|.
name|getPath
argument_list|(
name|untarFile
operator|.
name|getPath
argument_list|()
argument_list|,
name|tmpDir
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|Files
operator|.
name|isSymbolicLink
argument_list|(
name|FileSystems
operator|.
name|getDefault
argument_list|()
operator|.
name|getPath
argument_list|(
name|untarFile
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|symLink
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|FileUtils
operator|.
name|deleteDirectory
argument_list|(
operator|new
name|File
argument_list|(
literal|"tmp"
argument_list|)
argument_list|)
expr_stmt|;
name|tos
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|putEntriesInTar (TarArchiveOutputStream tos, File f)
specifier|private
name|void
name|putEntriesInTar
parameter_list|(
name|TarArchiveOutputStream
name|tos
parameter_list|,
name|File
name|f
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|Files
operator|.
name|isSymbolicLink
argument_list|(
name|f
operator|.
name|toPath
argument_list|()
argument_list|)
condition|)
block|{
name|TarArchiveEntry
name|tarEntry
init|=
operator|new
name|TarArchiveEntry
argument_list|(
name|f
operator|.
name|getPath
argument_list|()
argument_list|,
name|TarArchiveEntry
operator|.
name|LF_SYMLINK
argument_list|)
decl_stmt|;
name|tarEntry
operator|.
name|setLinkName
argument_list|(
name|Files
operator|.
name|readSymbolicLink
argument_list|(
name|f
operator|.
name|toPath
argument_list|()
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|tos
operator|.
name|putArchiveEntry
argument_list|(
name|tarEntry
argument_list|)
expr_stmt|;
name|tos
operator|.
name|closeArchiveEntry
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|f
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|tos
operator|.
name|putArchiveEntry
argument_list|(
operator|new
name|TarArchiveEntry
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|tos
operator|.
name|closeArchiveEntry
argument_list|()
expr_stmt|;
for|for
control|(
name|File
name|child
range|:
name|f
operator|.
name|listFiles
argument_list|()
control|)
block|{
name|putEntriesInTar
argument_list|(
name|tos
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|f
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|tos
operator|.
name|putArchiveEntry
argument_list|(
operator|new
name|TarArchiveEntry
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|BufferedInputStream
name|origin
init|=
operator|new
name|BufferedInputStream
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|f
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|count
decl_stmt|;
name|byte
index|[]
name|data
init|=
operator|new
name|byte
index|[
literal|2048
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|count
operator|=
name|origin
operator|.
name|read
argument_list|(
name|data
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|tos
operator|.
name|write
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
name|tos
operator|.
name|flush
argument_list|()
expr_stmt|;
name|tos
operator|.
name|closeArchiveEntry
argument_list|()
expr_stmt|;
name|origin
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

