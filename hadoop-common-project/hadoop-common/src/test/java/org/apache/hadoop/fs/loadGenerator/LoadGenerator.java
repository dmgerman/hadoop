begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs.loadGenerator
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|loadGenerator
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configured
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CreateFlag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSDataOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
operator|.
name|CreateOpts
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Tool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_comment
comment|/** The load generator is a tool for testing NameNode behavior under  * different client loads.  * It allows the user to generate different mixes of read, write,  * and list requests by specifying the probabilities of read and  * write. The user controls the intensity of the load by  * adjusting parameters for the number of worker threads and the delay  * between operations. While load generators are running, the user  * can profile and monitor the running of the NameNode. When a load  * generator exits, it print some NameNode statistics like the average  * execution time of each kind of operations and the NameNode  * throughput.  *   * The user may either specify constant duration, read and write   * probabilities via the command line, or may specify a text file  * that acts as a script of which read and write probabilities to  * use for specified durations.  *   * The script takes the form of lines of duration in seconds, read  * probability and write probability, each separated by white space.  * Blank lines and lines starting with # (comments) are ignored.  *   * After command line argument parsing and data initialization,  * the load generator spawns the number of worker threads   * as specified by the user.  * Each thread sends a stream of requests to the NameNode.  * For each iteration, it first decides if it is going to read a file,  * create a file, or listing a directory following the read and write   * probabilities specified by the user.  * When reading, it randomly picks a file in the test space and reads  * the entire file. When writing, it randomly picks a directory in the  * test space and creates a file whose name consists of the current   * machine's host name and the thread id. The length of the file  * follows Gaussian distribution with an average size of 2 blocks and  * the standard deviation of 1 block. The new file is filled with 'a'.  * Immediately after the file creation completes, the file is deleted  * from the test space.  * While listing, it randomly picks a directory in the test space and  * list the directory content.  * Between two consecutive operations, the thread pauses for a random  * amount of time in the range of [0, maxDelayBetweenOps]   * if the specified max delay is not zero.  * All threads are stopped when the specified elapsed time has passed   * in command-line execution, or all the lines of script have been   * executed, if using a script.  * Before exiting, the program prints the average execution for   * each kind of NameNode operations, and the number of requests  * served by the NameNode.  *  * The synopsis of the command is  * java LoadGenerator  *   -readProbability<read probability>: read probability [0, 1]  *                                        with a default value of 0.3333.   *   -writeProbability<write probability>: write probability [0, 1]  *                                         with a default value of 0.3333.  *   -root<root>: test space with a default value of /testLoadSpace  *   -maxDelayBetweenOps<maxDelayBetweenOpsInMillis>:   *      Max delay in the unit of milliseconds between two operations with a   *      default value of 0 indicating no delay.  *   -numOfThreads<numOfThreads>:   *      number of threads to spawn with a default value of 200.  *   -elapsedTime<elapsedTimeInSecs>:   *      the elapsed time of program with a default value of 0   *      indicating running forever  *   -startTime<startTimeInMillis> : when the threads start to run.  *   -scriptFile<file name>: text file to parse for scripted operation  */
end_comment

begin_class
DECL|class|LoadGenerator
specifier|public
class|class
name|LoadGenerator
extends|extends
name|Configured
implements|implements
name|Tool
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|LoadGenerator
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|shouldRun
specifier|private
specifier|volatile
name|boolean
name|shouldRun
init|=
literal|true
decl_stmt|;
DECL|field|root
specifier|private
name|Path
name|root
init|=
name|DataGenerator
operator|.
name|DEFAULT_ROOT
decl_stmt|;
DECL|field|fc
specifier|private
name|FileContext
name|fc
decl_stmt|;
DECL|field|maxDelayBetweenOps
specifier|private
name|int
name|maxDelayBetweenOps
init|=
literal|0
decl_stmt|;
DECL|field|numOfThreads
specifier|private
name|int
name|numOfThreads
init|=
literal|200
decl_stmt|;
DECL|field|durations
specifier|private
name|long
index|[]
name|durations
init|=
block|{
literal|0
block|}
decl_stmt|;
DECL|field|readProbs
specifier|private
name|double
index|[]
name|readProbs
init|=
block|{
literal|0.3333
block|}
decl_stmt|;
DECL|field|writeProbs
specifier|private
name|double
index|[]
name|writeProbs
init|=
block|{
literal|0.3333
block|}
decl_stmt|;
DECL|field|currentIndex
specifier|private
specifier|volatile
name|int
name|currentIndex
init|=
literal|0
decl_stmt|;
DECL|field|totalTime
name|long
name|totalTime
init|=
literal|0
decl_stmt|;
DECL|field|startTime
specifier|private
name|long
name|startTime
init|=
name|Time
operator|.
name|now
argument_list|()
operator|+
literal|10000
decl_stmt|;
DECL|field|BLOCK_SIZE
specifier|final
specifier|static
specifier|private
name|int
name|BLOCK_SIZE
init|=
literal|10
decl_stmt|;
DECL|field|files
specifier|private
name|ArrayList
argument_list|<
name|String
argument_list|>
name|files
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// a table of file names
DECL|field|dirs
specifier|private
name|ArrayList
argument_list|<
name|String
argument_list|>
name|dirs
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// a table of directory names
DECL|field|r
specifier|private
name|Random
name|r
init|=
literal|null
decl_stmt|;
DECL|field|USAGE
specifier|final
specifier|private
specifier|static
name|String
name|USAGE
init|=
literal|"java LoadGenerator\n"
operator|+
literal|"-readProbability<read probability>\n"
operator|+
literal|"-writeProbability<write probability>\n"
operator|+
literal|"-root<root>\n"
operator|+
literal|"-maxDelayBetweenOps<maxDelayBetweenOpsInMillis>\n"
operator|+
literal|"-numOfThreads<numOfThreads>\n"
operator|+
literal|"-elapsedTime<elapsedTimeInSecs>\n"
operator|+
literal|"-startTime<startTimeInMillis>\n"
operator|+
literal|"-scriptFile<filename>"
decl_stmt|;
DECL|field|hostname
specifier|final
specifier|private
name|String
name|hostname
decl_stmt|;
comment|/** Constructor */
DECL|method|LoadGenerator ()
specifier|public
name|LoadGenerator
parameter_list|()
throws|throws
name|IOException
throws|,
name|UnknownHostException
block|{
name|InetAddress
name|addr
init|=
name|InetAddress
operator|.
name|getLocalHost
argument_list|()
decl_stmt|;
name|hostname
operator|=
name|addr
operator|.
name|getHostName
argument_list|()
expr_stmt|;
block|}
DECL|field|OPEN
specifier|private
specifier|final
specifier|static
name|int
name|OPEN
init|=
literal|0
decl_stmt|;
DECL|field|LIST
specifier|private
specifier|final
specifier|static
name|int
name|LIST
init|=
literal|1
decl_stmt|;
DECL|field|CREATE
specifier|private
specifier|final
specifier|static
name|int
name|CREATE
init|=
literal|2
decl_stmt|;
DECL|field|WRITE_CLOSE
specifier|private
specifier|final
specifier|static
name|int
name|WRITE_CLOSE
init|=
literal|3
decl_stmt|;
DECL|field|DELETE
specifier|private
specifier|final
specifier|static
name|int
name|DELETE
init|=
literal|4
decl_stmt|;
DECL|field|TOTAL_OP_TYPES
specifier|private
specifier|final
specifier|static
name|int
name|TOTAL_OP_TYPES
init|=
literal|5
decl_stmt|;
DECL|field|executionTime
specifier|private
name|long
index|[]
name|executionTime
init|=
operator|new
name|long
index|[
name|TOTAL_OP_TYPES
index|]
decl_stmt|;
DECL|field|totalNumOfOps
specifier|private
name|long
index|[]
name|totalNumOfOps
init|=
operator|new
name|long
index|[
name|TOTAL_OP_TYPES
index|]
decl_stmt|;
comment|/** A thread sends a stream of requests to the NameNode.    * At each iteration, it first decides if it is going to read a file,    * create a file, or listing a directory following the read    * and write probabilities.    * When reading, it randomly picks a file in the test space and reads    * the entire file. When writing, it randomly picks a directory in the    * test space and creates a file whose name consists of the current     * machine's host name and the thread id. The length of the file    * follows Gaussian distribution with an average size of 2 blocks and    * the standard deviation of 1 block. The new file is filled with 'a'.    * Immediately after the file creation completes, the file is deleted    * from the test space.    * While listing, it randomly picks a directory in the test space and    * list the directory content.    * Between two consecutive operations, the thread pauses for a random    * amount of time in the range of [0, maxDelayBetweenOps]     * if the specified max delay is not zero.    * A thread runs for the specified elapsed time if the time isn't zero.    * Otherwise, it runs forever.    */
DECL|class|DFSClientThread
specifier|private
class|class
name|DFSClientThread
extends|extends
name|Thread
block|{
DECL|field|id
specifier|private
name|int
name|id
decl_stmt|;
DECL|field|executionTime
specifier|private
name|long
index|[]
name|executionTime
init|=
operator|new
name|long
index|[
name|TOTAL_OP_TYPES
index|]
decl_stmt|;
DECL|field|totalNumOfOps
specifier|private
name|long
index|[]
name|totalNumOfOps
init|=
operator|new
name|long
index|[
name|TOTAL_OP_TYPES
index|]
decl_stmt|;
DECL|field|buffer
specifier|private
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
literal|1024
index|]
decl_stmt|;
DECL|method|DFSClientThread (int id)
specifier|private
name|DFSClientThread
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
block|}
comment|/** Main loop      * Each iteration decides what's the next operation and then pauses.      */
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
while|while
condition|(
name|shouldRun
condition|)
block|{
name|nextOp
argument_list|()
expr_stmt|;
name|delay
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ioe
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|ioe
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
name|ioe
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Let the thread pause for a random amount of time in the range of      * [0, maxDelayBetweenOps] if the delay is not zero. Otherwise, no pause.      */
DECL|method|delay ()
specifier|private
name|void
name|delay
parameter_list|()
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|maxDelayBetweenOps
operator|>
literal|0
condition|)
block|{
name|int
name|delay
init|=
name|r
operator|.
name|nextInt
argument_list|(
name|maxDelayBetweenOps
argument_list|)
decl_stmt|;
name|Thread
operator|.
name|sleep
argument_list|(
name|delay
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Perform the next operation.       *       * Depending on the read and write probabilities, the next      * operation could be either read, write, or list.      */
DECL|method|nextOp ()
specifier|private
name|void
name|nextOp
parameter_list|()
throws|throws
name|IOException
block|{
name|double
name|rn
init|=
name|r
operator|.
name|nextDouble
argument_list|()
decl_stmt|;
name|int
name|i
init|=
name|currentIndex
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Thread "
operator|+
name|this
operator|.
name|id
operator|+
literal|" moving to index "
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|rn
operator|<
name|readProbs
index|[
name|i
index|]
condition|)
block|{
name|read
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rn
operator|<
name|readProbs
index|[
name|i
index|]
operator|+
name|writeProbs
index|[
name|i
index|]
condition|)
block|{
name|write
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|list
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Read operation randomly picks a file in the test space and reads      * the entire file */
DECL|method|read ()
specifier|private
name|void
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|fileName
init|=
name|files
operator|.
name|get
argument_list|(
name|r
operator|.
name|nextInt
argument_list|(
name|files
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|startTime
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
name|InputStream
name|in
init|=
name|fc
operator|.
name|open
argument_list|(
operator|new
name|Path
argument_list|(
name|fileName
argument_list|)
argument_list|)
decl_stmt|;
name|executionTime
index|[
name|OPEN
index|]
operator|+=
operator|(
name|Time
operator|.
name|now
argument_list|()
operator|-
name|startTime
operator|)
expr_stmt|;
name|totalNumOfOps
index|[
name|OPEN
index|]
operator|++
expr_stmt|;
while|while
condition|(
name|in
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{}
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** The write operation randomly picks a directory in the      * test space and creates a file whose name consists of the current       * machine's host name and the thread id. The length of the file      * follows Gaussian distribution with an average size of 2 blocks and      * the standard deviation of 1 block. The new file is filled with 'a'.      * Immediately after the file creation completes, the file is deleted      * from the test space.      */
DECL|method|write ()
specifier|private
name|void
name|write
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|dirName
init|=
name|dirs
operator|.
name|get
argument_list|(
name|r
operator|.
name|nextInt
argument_list|(
name|dirs
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|Path
name|file
init|=
operator|new
name|Path
argument_list|(
name|dirName
argument_list|,
name|hostname
operator|+
name|id
argument_list|)
decl_stmt|;
name|double
name|fileSize
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|fileSize
operator|=
name|r
operator|.
name|nextGaussian
argument_list|()
operator|+
literal|2
operator|)
operator|<=
literal|0
condition|)
block|{}
name|genFile
argument_list|(
name|file
argument_list|,
call|(
name|long
call|)
argument_list|(
name|fileSize
operator|*
name|BLOCK_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|long
name|startTime
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
name|fc
operator|.
name|delete
argument_list|(
name|file
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|executionTime
index|[
name|DELETE
index|]
operator|+=
operator|(
name|Time
operator|.
name|now
argument_list|()
operator|-
name|startTime
operator|)
expr_stmt|;
name|totalNumOfOps
index|[
name|DELETE
index|]
operator|++
expr_stmt|;
block|}
comment|/** The list operation randomly picks a directory in the test space and      * list the directory content.      */
DECL|method|list ()
specifier|private
name|void
name|list
parameter_list|()
throws|throws
name|IOException
block|{
name|String
name|dirName
init|=
name|dirs
operator|.
name|get
argument_list|(
name|r
operator|.
name|nextInt
argument_list|(
name|dirs
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|long
name|startTime
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
name|fc
operator|.
name|listStatus
argument_list|(
operator|new
name|Path
argument_list|(
name|dirName
argument_list|)
argument_list|)
expr_stmt|;
name|executionTime
index|[
name|LIST
index|]
operator|+=
operator|(
name|Time
operator|.
name|now
argument_list|()
operator|-
name|startTime
operator|)
expr_stmt|;
name|totalNumOfOps
index|[
name|LIST
index|]
operator|++
expr_stmt|;
block|}
block|}
comment|/** Main function:    * It first initializes data by parsing the command line arguments.    * It then starts the number of DFSClient threads as specified by    * the user.    * It stops all the threads when the specified elapsed time is passed.    * Before exiting, it prints the average execution for     * each operation and operation throughput.    */
DECL|method|run (String[] args)
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|exitCode
init|=
name|init
argument_list|(
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|exitCode
operator|!=
literal|0
condition|)
block|{
return|return
name|exitCode
return|;
block|}
name|barrier
argument_list|()
expr_stmt|;
name|DFSClientThread
index|[]
name|threads
init|=
operator|new
name|DFSClientThread
index|[
name|numOfThreads
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numOfThreads
condition|;
name|i
operator|++
control|)
block|{
name|threads
index|[
name|i
index|]
operator|=
operator|new
name|DFSClientThread
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|threads
index|[
name|i
index|]
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|durations
index|[
literal|0
index|]
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|shouldRun
condition|)
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|durations
index|[
name|currentIndex
index|]
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|totalTime
operator|+=
name|durations
index|[
name|currentIndex
index|]
expr_stmt|;
comment|// Are we on the final line of the script?
if|if
condition|(
operator|(
name|currentIndex
operator|+
literal|1
operator|)
operator|==
name|durations
operator|.
name|length
condition|)
block|{
name|shouldRun
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Moving to index "
operator|+
name|currentIndex
operator|+
literal|": r = "
operator|+
name|readProbs
index|[
name|currentIndex
index|]
operator|+
literal|", w = "
operator|+
name|writeProbs
operator|+
literal|" for duration "
operator|+
name|durations
index|[
name|currentIndex
index|]
argument_list|)
expr_stmt|;
block|}
name|currentIndex
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Done with testing.  Waiting for threads to finish."
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|DFSClientThread
name|thread
range|:
name|threads
control|)
block|{
name|thread
operator|.
name|join
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|TOTAL_OP_TYPES
condition|;
name|i
operator|++
control|)
block|{
name|executionTime
index|[
name|i
index|]
operator|+=
name|thread
operator|.
name|executionTime
index|[
name|i
index|]
expr_stmt|;
name|totalNumOfOps
index|[
name|i
index|]
operator|+=
name|thread
operator|.
name|totalNumOfOps
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|long
name|totalOps
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|TOTAL_OP_TYPES
condition|;
name|i
operator|++
control|)
block|{
name|totalOps
operator|+=
name|totalNumOfOps
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|totalNumOfOps
index|[
name|OPEN
index|]
operator|!=
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Average open execution time: "
operator|+
operator|(
name|double
operator|)
name|executionTime
index|[
name|OPEN
index|]
operator|/
name|totalNumOfOps
index|[
name|OPEN
index|]
operator|+
literal|"ms"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|totalNumOfOps
index|[
name|LIST
index|]
operator|!=
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Average list execution time: "
operator|+
operator|(
name|double
operator|)
name|executionTime
index|[
name|LIST
index|]
operator|/
name|totalNumOfOps
index|[
name|LIST
index|]
operator|+
literal|"ms"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|totalNumOfOps
index|[
name|DELETE
index|]
operator|!=
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Average deletion execution time: "
operator|+
operator|(
name|double
operator|)
name|executionTime
index|[
name|DELETE
index|]
operator|/
name|totalNumOfOps
index|[
name|DELETE
index|]
operator|+
literal|"ms"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Average create execution time: "
operator|+
operator|(
name|double
operator|)
name|executionTime
index|[
name|CREATE
index|]
operator|/
name|totalNumOfOps
index|[
name|CREATE
index|]
operator|+
literal|"ms"
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Average write_close execution time: "
operator|+
operator|(
name|double
operator|)
name|executionTime
index|[
name|WRITE_CLOSE
index|]
operator|/
name|totalNumOfOps
index|[
name|WRITE_CLOSE
index|]
operator|+
literal|"ms"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|durations
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"Average operations per second: "
operator|+
operator|(
name|double
operator|)
name|totalOps
operator|/
name|totalTime
operator|+
literal|"ops/s"
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
return|return
name|exitCode
return|;
block|}
comment|/** Parse the command line arguments and initialize the data */
DECL|method|init (String[] args)
specifier|private
name|int
name|init
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|fc
operator|=
name|FileContext
operator|.
name|getFileContext
argument_list|(
name|getConf
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Can not initialize the file system: "
operator|+
name|ioe
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|int
name|hostHashCode
init|=
name|hostname
operator|.
name|hashCode
argument_list|()
decl_stmt|;
name|boolean
name|scriptSpecified
init|=
literal|false
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// parse command line
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-scriptFile"
argument_list|)
condition|)
block|{
if|if
condition|(
name|loadScriptFile
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|scriptSpecified
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-readProbability"
argument_list|)
condition|)
block|{
if|if
condition|(
name|scriptSpecified
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Can't specify probabilities and use script."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|readProbs
index|[
literal|0
index|]
operator|=
name|Double
operator|.
name|parseDouble
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|readProbs
index|[
literal|0
index|]
operator|<
literal|0
operator|||
name|readProbs
index|[
literal|0
index|]
operator|>
literal|1
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"The read probability must be [0, 1]: "
operator|+
name|readProbs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-writeProbability"
argument_list|)
condition|)
block|{
if|if
condition|(
name|scriptSpecified
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Can't specify probabilities and use script."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|writeProbs
index|[
literal|0
index|]
operator|=
name|Double
operator|.
name|parseDouble
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|writeProbs
index|[
literal|0
index|]
operator|<
literal|0
operator|||
name|writeProbs
index|[
literal|0
index|]
operator|>
literal|1
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"The write probability must be [0, 1]: "
operator|+
name|writeProbs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-root"
argument_list|)
condition|)
block|{
name|root
operator|=
operator|new
name|Path
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-maxDelayBetweenOps"
argument_list|)
condition|)
block|{
name|maxDelayBetweenOps
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
comment|// in milliseconds
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-numOfThreads"
argument_list|)
condition|)
block|{
name|numOfThreads
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|numOfThreads
operator|<=
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Number of threads must be positive: "
operator|+
name|numOfThreads
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-startTime"
argument_list|)
condition|)
block|{
name|startTime
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-elapsedTime"
argument_list|)
condition|)
block|{
if|if
condition|(
name|scriptSpecified
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Can't specify elapsedTime and use script."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|durations
index|[
literal|0
index|]
operator|=
name|Long
operator|.
name|parseLong
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
literal|"-seed"
argument_list|)
condition|)
block|{
name|r
operator|=
operator|new
name|Random
argument_list|(
name|Long
operator|.
name|parseLong
argument_list|(
name|args
index|[
operator|++
name|i
index|]
argument_list|)
operator|+
name|hostHashCode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|USAGE
argument_list|)
expr_stmt|;
name|ToolRunner
operator|.
name|printGenericCommandUsage
argument_list|(
name|System
operator|.
name|err
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Illegal parameter: "
operator|+
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|USAGE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|readProbs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|readProbs
index|[
name|i
index|]
operator|+
name|writeProbs
index|[
name|i
index|]
operator|<
literal|0
operator|||
name|readProbs
index|[
name|i
index|]
operator|+
name|writeProbs
index|[
name|i
index|]
operator|>
literal|1
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"The sum of read probability and write probability must be [0, 1]: "
operator|+
name|readProbs
index|[
name|i
index|]
operator|+
literal|" "
operator|+
name|writeProbs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|r
operator|==
literal|null
condition|)
block|{
name|r
operator|=
operator|new
name|Random
argument_list|(
name|Time
operator|.
name|now
argument_list|()
operator|+
name|hostHashCode
argument_list|)
expr_stmt|;
block|}
return|return
name|initFileDirTables
argument_list|()
return|;
block|}
comment|/**    * Read a script file of the form: lines of text with duration in seconds,    * read probability and write probability, separated by white space.    *     * @param filename Script file    * @return 0 if successful, -1 if not    * @throws IOException if errors with file IO    */
DECL|method|loadScriptFile (String filename)
specifier|private
name|int
name|loadScriptFile
parameter_list|(
name|String
name|filename
parameter_list|)
throws|throws
name|IOException
block|{
name|FileReader
name|fr
init|=
operator|new
name|FileReader
argument_list|(
operator|new
name|File
argument_list|(
name|filename
argument_list|)
argument_list|)
decl_stmt|;
name|BufferedReader
name|br
init|=
operator|new
name|BufferedReader
argument_list|(
name|fr
argument_list|)
decl_stmt|;
name|ArrayList
argument_list|<
name|Long
argument_list|>
name|duration
init|=
operator|new
name|ArrayList
argument_list|<
name|Long
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|Double
argument_list|>
name|readProb
init|=
operator|new
name|ArrayList
argument_list|<
name|Double
argument_list|>
argument_list|()
decl_stmt|;
name|ArrayList
argument_list|<
name|Double
argument_list|>
name|writeProb
init|=
operator|new
name|ArrayList
argument_list|<
name|Double
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|lineNum
init|=
literal|0
decl_stmt|;
name|String
name|line
decl_stmt|;
comment|// Read script, parse values, build array of duration, read and write probs
while|while
condition|(
operator|(
name|line
operator|=
name|br
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|lineNum
operator|++
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
literal|"#"
argument_list|)
operator|||
name|line
operator|.
name|isEmpty
argument_list|()
condition|)
comment|// skip comments and blanks
continue|continue;
name|String
index|[]
name|a
init|=
name|line
operator|.
name|split
argument_list|(
literal|"\\s"
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|.
name|length
operator|!=
literal|3
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Line "
operator|+
name|lineNum
operator|+
literal|": Incorrect number of parameters: "
operator|+
name|line
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|long
name|d
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|<
literal|0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Line "
operator|+
name|lineNum
operator|+
literal|": Invalid duration: "
operator|+
name|d
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|double
name|r
init|=
name|Double
operator|.
name|parseDouble
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
argument_list|<
literal|0.0
operator|||
name|r
argument_list|>
literal|1.0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Line "
operator|+
name|lineNum
operator|+
literal|": The read probability must be [0, 1]: "
operator|+
name|r
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|double
name|w
init|=
name|Double
operator|.
name|parseDouble
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
argument_list|<
literal|0.0
operator|||
name|w
argument_list|>
literal|1.0
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Line "
operator|+
name|lineNum
operator|+
literal|": The read probability must be [0, 1]: "
operator|+
name|r
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|readProb
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|duration
operator|.
name|add
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|writeProb
operator|.
name|add
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|lineNum
operator|+
literal|": Can't parse: "
operator|+
name|line
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|br
operator|.
name|close
argument_list|()
expr_stmt|;
name|fr
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// Copy vectors to arrays of values, to avoid autoboxing overhead later
name|durations
operator|=
operator|new
name|long
index|[
name|duration
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|readProbs
operator|=
operator|new
name|double
index|[
name|readProb
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|writeProbs
operator|=
operator|new
name|double
index|[
name|writeProb
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|durations
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|durations
index|[
name|i
index|]
operator|=
name|duration
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|readProbs
index|[
name|i
index|]
operator|=
name|readProb
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|writeProbs
index|[
name|i
index|]
operator|=
name|writeProb
operator|.
name|get
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|durations
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Initial duration set to 0.  "
operator|+
literal|"Will loop until stopped manually."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/** Create a table that contains all directories under root and    * another table that contains all files under root.    */
DECL|method|initFileDirTables ()
specifier|private
name|int
name|initFileDirTables
parameter_list|()
block|{
try|try
block|{
name|initFileDirTables
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|e
operator|.
name|getLocalizedMessage
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|dirs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"The test space "
operator|+
name|root
operator|+
literal|" is empty"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|files
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"The test space "
operator|+
name|root
operator|+
literal|" does not have any file"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/** Create a table that contains all directories under the specified path and    * another table that contains all files under the specified path and    * whose name starts with "_file_".    */
DECL|method|initFileDirTables (Path path)
specifier|private
name|void
name|initFileDirTables
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
index|[]
name|stats
init|=
name|fc
operator|.
name|util
argument_list|()
operator|.
name|listStatus
argument_list|(
name|path
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|stat
range|:
name|stats
control|)
block|{
if|if
condition|(
name|stat
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|dirs
operator|.
name|add
argument_list|(
name|stat
operator|.
name|getPath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|initFileDirTables
argument_list|(
name|stat
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Path
name|filePath
init|=
name|stat
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|filePath
operator|.
name|getName
argument_list|()
operator|.
name|startsWith
argument_list|(
name|StructureGenerator
operator|.
name|FILE_NAME_PREFIX
argument_list|)
condition|)
block|{
name|files
operator|.
name|add
argument_list|(
name|filePath
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/** Returns when the current number of seconds from the epoch equals    * the command line argument given by<code>-startTime</code>.    * This allows multiple instances of this program, running on clock    * synchronized nodes, to start at roughly the same time.    */
DECL|method|barrier ()
specifier|private
name|void
name|barrier
parameter_list|()
block|{
name|long
name|sleepTime
decl_stmt|;
while|while
condition|(
operator|(
name|sleepTime
operator|=
name|startTime
operator|-
name|Time
operator|.
name|now
argument_list|()
operator|)
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepTime
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{       }
block|}
block|}
comment|/** Create a file with a length of<code>fileSize</code>.    * The file is filled with 'a'.    */
DECL|method|genFile (Path file, long fileSize)
specifier|private
name|void
name|genFile
parameter_list|(
name|Path
name|file
parameter_list|,
name|long
name|fileSize
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|startTime
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
name|FSDataOutputStream
name|out
init|=
name|fc
operator|.
name|create
argument_list|(
name|file
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|CreateFlag
operator|.
name|CREATE
argument_list|,
name|CreateFlag
operator|.
name|OVERWRITE
argument_list|)
argument_list|,
name|CreateOpts
operator|.
name|createParent
argument_list|()
argument_list|,
name|CreateOpts
operator|.
name|bufferSize
argument_list|(
literal|4096
argument_list|)
argument_list|,
name|CreateOpts
operator|.
name|repFac
argument_list|(
operator|(
name|short
operator|)
literal|3
argument_list|)
argument_list|)
decl_stmt|;
name|executionTime
index|[
name|CREATE
index|]
operator|+=
operator|(
name|Time
operator|.
name|now
argument_list|()
operator|-
name|startTime
operator|)
expr_stmt|;
name|totalNumOfOps
index|[
name|CREATE
index|]
operator|++
expr_stmt|;
for|for
control|(
name|long
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileSize
condition|;
name|i
operator|++
control|)
block|{
name|out
operator|.
name|writeByte
argument_list|(
literal|'a'
argument_list|)
expr_stmt|;
block|}
name|startTime
operator|=
name|Time
operator|.
name|now
argument_list|()
expr_stmt|;
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
name|executionTime
index|[
name|WRITE_CLOSE
index|]
operator|+=
operator|(
name|Time
operator|.
name|now
argument_list|()
operator|-
name|startTime
operator|)
expr_stmt|;
name|totalNumOfOps
index|[
name|WRITE_CLOSE
index|]
operator|++
expr_stmt|;
block|}
comment|/** Main program    *     * @param args command line arguments    * @throws Exception    */
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|int
name|res
init|=
name|ToolRunner
operator|.
name|run
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|,
operator|new
name|LoadGenerator
argument_list|()
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|System
operator|.
name|exit
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

