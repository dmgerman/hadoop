begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.io
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|rmi
operator|.
name|server
operator|.
name|UID
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|MessageDigest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|Charsets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
operator|.
name|CreateOpts
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|CodecPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|CompressionCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|CompressionInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|CompressionOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|Compressor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|Decompressor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|DefaultCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|GzipCodec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|zlib
operator|.
name|ZlibFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|serializer
operator|.
name|Deserializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|serializer
operator|.
name|Serializer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|serializer
operator|.
name|SerializationFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Progressable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Progress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|NativeCodeLoader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|MergeSort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|PriorityQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_comment
comment|/**   *<code>SequenceFile</code>s are flat files consisting of binary key/value   * pairs.  *   *<p><code>SequenceFile</code> provides {@link SequenceFile.Writer},  * {@link SequenceFile.Reader} and {@link Sorter} classes for writing,  * reading and sorting respectively.</p>  *   * There are three<code>SequenceFile</code><code>Writer</code>s based on the   * {@link CompressionType} used to compress key/value pairs:  *<ol>  *<li>  *<code>Writer</code> : Uncompressed records.  *</li>  *<li>  *<code>RecordCompressWriter</code> : Record-compressed files, only compress   *                                       values.  *</li>  *<li>  *<code>BlockCompressWriter</code> : Block-compressed files, both keys&   *                                      values are collected in 'blocks'   *                                      separately and compressed. The size of   *                                      the 'block' is configurable.  *</ol>  *   *<p>The actual compression algorithm used to compress key and/or values can be  * specified by using the appropriate {@link CompressionCodec}.</p>  *   *<p>The recommended way is to use the static<tt>createWriter</tt> methods  * provided by the<code>SequenceFile</code> to chose the preferred format.</p>  *  *<p>The {@link SequenceFile.Reader} acts as the bridge and can read any of the  * above<code>SequenceFile</code> formats.</p>  *  *<h4 id="Formats">SequenceFile Formats</h4>  *   *<p>Essentially there are 3 different formats for<code>SequenceFile</code>s  * depending on the<code>CompressionType</code> specified. All of them share a  *<a href="#Header">common header</a> described below.  *   *<h5 id="Header">SequenceFile Header</h5>  *<ul>  *<li>  *   version - 3 bytes of magic header<b>SEQ</b>, followed by 1 byte of actual   *             version number (e.g. SEQ4 or SEQ6)  *</li>  *<li>  *   keyClassName -key class  *</li>  *<li>  *   valueClassName - value class  *</li>  *<li>  *   compression - A boolean which specifies if compression is turned on for   *                 keys/values in this file.  *</li>  *<li>  *   blockCompression - A boolean which specifies if block-compression is   *                      turned on for keys/values in this file.  *</li>  *<li>  *   compression codec -<code>CompressionCodec</code> class which is used for    *                       compression of keys and/or values (if compression is   *                       enabled).  *</li>  *<li>  *   metadata - {@link Metadata} for this file.  *</li>  *<li>  *   sync - A sync marker to denote end of the header.  *</li>  *</ul>  *   *<h5 id="#UncompressedFormat">Uncompressed SequenceFile Format</h5>  *<ul>  *<li>  *<a href="#Header">Header</a>  *</li>  *<li>  * Record  *<ul>  *<li>Record length</li>  *<li>Key length</li>  *<li>Key</li>  *<li>Value</li>  *</ul>  *</li>  *<li>  * A sync-marker every few<code>100</code> bytes or so.  *</li>  *</ul>  *  *<h5 id="#RecordCompressedFormat">Record-Compressed SequenceFile Format</h5>  *<ul>  *<li>  *<a href="#Header">Header</a>  *</li>  *<li>  * Record  *<ul>  *<li>Record length</li>  *<li>Key length</li>  *<li>Key</li>  *<li><i>Compressed</i> Value</li>  *</ul>  *</li>  *<li>  * A sync-marker every few<code>100</code> bytes or so.  *</li>  *</ul>  *   *<h5 id="#BlockCompressedFormat">Block-Compressed SequenceFile Format</h5>  *<ul>  *<li>  *<a href="#Header">Header</a>  *</li>  *<li>  * Record<i>Block</i>  *<ul>  *<li>Uncompressed number of records in the block</li>  *<li>Compressed key-lengths block-size</li>  *<li>Compressed key-lengths block</li>  *<li>Compressed keys block-size</li>  *<li>Compressed keys block</li>  *<li>Compressed value-lengths block-size</li>  *<li>Compressed value-lengths block</li>  *<li>Compressed values block-size</li>  *<li>Compressed values block</li>  *</ul>  *</li>  *<li>  * A sync-marker every block.  *</li>  *</ul>  *   *<p>The compressed blocks of key lengths and value lengths consist of the   * actual lengths of individual keys/values encoded in ZeroCompressedInteger   * format.</p>  *   * @see CompressionCodec  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Stable
DECL|class|SequenceFile
specifier|public
class|class
name|SequenceFile
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|SequenceFile
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|method|SequenceFile ()
specifier|private
name|SequenceFile
parameter_list|()
block|{}
comment|// no public ctor
DECL|field|BLOCK_COMPRESS_VERSION
specifier|private
specifier|static
specifier|final
name|byte
name|BLOCK_COMPRESS_VERSION
init|=
operator|(
name|byte
operator|)
literal|4
decl_stmt|;
DECL|field|CUSTOM_COMPRESS_VERSION
specifier|private
specifier|static
specifier|final
name|byte
name|CUSTOM_COMPRESS_VERSION
init|=
operator|(
name|byte
operator|)
literal|5
decl_stmt|;
DECL|field|VERSION_WITH_METADATA
specifier|private
specifier|static
specifier|final
name|byte
name|VERSION_WITH_METADATA
init|=
operator|(
name|byte
operator|)
literal|6
decl_stmt|;
DECL|field|VERSION
specifier|private
specifier|static
name|byte
index|[]
name|VERSION
init|=
operator|new
name|byte
index|[]
block|{
operator|(
name|byte
operator|)
literal|'S'
block|,
operator|(
name|byte
operator|)
literal|'E'
block|,
operator|(
name|byte
operator|)
literal|'Q'
block|,
name|VERSION_WITH_METADATA
block|}
decl_stmt|;
DECL|field|SYNC_ESCAPE
specifier|private
specifier|static
specifier|final
name|int
name|SYNC_ESCAPE
init|=
operator|-
literal|1
decl_stmt|;
comment|// "length" of sync entries
DECL|field|SYNC_HASH_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|SYNC_HASH_SIZE
init|=
literal|16
decl_stmt|;
comment|// number of bytes in hash
DECL|field|SYNC_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|SYNC_SIZE
init|=
literal|4
operator|+
name|SYNC_HASH_SIZE
decl_stmt|;
comment|// escape + hash
comment|/** The number of bytes between sync points.*/
DECL|field|SYNC_INTERVAL
specifier|public
specifier|static
specifier|final
name|int
name|SYNC_INTERVAL
init|=
literal|100
operator|*
name|SYNC_SIZE
decl_stmt|;
comment|/**     * The compression type used to compress key/value pairs in the     * {@link SequenceFile}.    *     * @see SequenceFile.Writer    */
DECL|enum|CompressionType
specifier|public
specifier|static
enum|enum
name|CompressionType
block|{
comment|/** Do not compress records. */
DECL|enumConstant|NONE
name|NONE
block|,
comment|/** Compress values only, each separately. */
DECL|enumConstant|RECORD
name|RECORD
block|,
comment|/** Compress sequences of records together in blocks. */
DECL|enumConstant|BLOCK
name|BLOCK
block|}
comment|/**    * Get the compression type for the reduce outputs    * @param job the job config to look in    * @return the kind of compression to use    */
DECL|method|getDefaultCompressionType (Configuration job)
specifier|static
specifier|public
name|CompressionType
name|getDefaultCompressionType
parameter_list|(
name|Configuration
name|job
parameter_list|)
block|{
name|String
name|name
init|=
name|job
operator|.
name|get
argument_list|(
literal|"io.seqfile.compression.type"
argument_list|)
decl_stmt|;
return|return
name|name
operator|==
literal|null
condition|?
name|CompressionType
operator|.
name|RECORD
else|:
name|CompressionType
operator|.
name|valueOf
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**    * Set the default compression type for sequence files.    * @param job the configuration to modify    * @param val the new compression type (none, block, record)    */
DECL|method|setDefaultCompressionType (Configuration job, CompressionType val)
specifier|static
specifier|public
name|void
name|setDefaultCompressionType
parameter_list|(
name|Configuration
name|job
parameter_list|,
name|CompressionType
name|val
parameter_list|)
block|{
name|job
operator|.
name|set
argument_list|(
literal|"io.seqfile.compression.type"
argument_list|,
name|val
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a new Writer with the given options.    * @param conf the configuration to use    * @param opts the options to create the file with    * @return a new Writer    * @throws IOException    */
DECL|method|createWriter (Configuration conf, Writer.Option... opts )
specifier|public
specifier|static
name|Writer
name|createWriter
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Writer
operator|.
name|Option
modifier|...
name|opts
parameter_list|)
throws|throws
name|IOException
block|{
name|Writer
operator|.
name|CompressionOption
name|compressionOption
init|=
name|Options
operator|.
name|getOption
argument_list|(
name|Writer
operator|.
name|CompressionOption
operator|.
name|class
argument_list|,
name|opts
argument_list|)
decl_stmt|;
name|CompressionType
name|kind
decl_stmt|;
if|if
condition|(
name|compressionOption
operator|!=
literal|null
condition|)
block|{
name|kind
operator|=
name|compressionOption
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|kind
operator|=
name|getDefaultCompressionType
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|opts
operator|=
name|Options
operator|.
name|prependOptions
argument_list|(
name|opts
argument_list|,
name|Writer
operator|.
name|compression
argument_list|(
name|kind
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|kind
condition|)
block|{
default|default:
case|case
name|NONE
case|:
return|return
operator|new
name|Writer
argument_list|(
name|conf
argument_list|,
name|opts
argument_list|)
return|;
case|case
name|RECORD
case|:
return|return
operator|new
name|RecordCompressWriter
argument_list|(
name|conf
argument_list|,
name|opts
argument_list|)
return|;
case|case
name|BLOCK
case|:
return|return
operator|new
name|BlockCompressWriter
argument_list|(
name|conf
argument_list|,
name|opts
argument_list|)
return|;
block|}
block|}
comment|/**    * Construct the preferred type of SequenceFile Writer.    * @param fs The configured filesystem.     * @param conf The configuration.    * @param name The name of the file.     * @param keyClass The 'key' type.    * @param valClass The 'value' type.    * @return Returns the handle to the constructed SequenceFile Writer.    * @throws IOException    * @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}    *     instead.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Writer
DECL|method|createWriter (FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass)
name|createWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createWriter
argument_list|(
name|conf
argument_list|,
name|Writer
operator|.
name|filesystem
argument_list|(
name|fs
argument_list|)
argument_list|,
name|Writer
operator|.
name|file
argument_list|(
name|name
argument_list|)
argument_list|,
name|Writer
operator|.
name|keyClass
argument_list|(
name|keyClass
argument_list|)
argument_list|,
name|Writer
operator|.
name|valueClass
argument_list|(
name|valClass
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Construct the preferred type of SequenceFile Writer.    * @param fs The configured filesystem.     * @param conf The configuration.    * @param name The name of the file.     * @param keyClass The 'key' type.    * @param valClass The 'value' type.    * @param compressionType The compression type.    * @return Returns the handle to the constructed SequenceFile Writer.    * @throws IOException    * @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}    *     instead.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Writer
DECL|method|createWriter (FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionType compressionType)
name|createWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionType
name|compressionType
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createWriter
argument_list|(
name|conf
argument_list|,
name|Writer
operator|.
name|filesystem
argument_list|(
name|fs
argument_list|)
argument_list|,
name|Writer
operator|.
name|file
argument_list|(
name|name
argument_list|)
argument_list|,
name|Writer
operator|.
name|keyClass
argument_list|(
name|keyClass
argument_list|)
argument_list|,
name|Writer
operator|.
name|valueClass
argument_list|(
name|valClass
argument_list|)
argument_list|,
name|Writer
operator|.
name|compression
argument_list|(
name|compressionType
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Construct the preferred type of SequenceFile Writer.    * @param fs The configured filesystem.     * @param conf The configuration.    * @param name The name of the file.     * @param keyClass The 'key' type.    * @param valClass The 'value' type.    * @param compressionType The compression type.    * @param progress The Progressable object to track progress.    * @return Returns the handle to the constructed SequenceFile Writer.    * @throws IOException    * @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}    *     instead.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Writer
DECL|method|createWriter (FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionType compressionType, Progressable progress)
name|createWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionType
name|compressionType
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createWriter
argument_list|(
name|conf
argument_list|,
name|Writer
operator|.
name|file
argument_list|(
name|name
argument_list|)
argument_list|,
name|Writer
operator|.
name|filesystem
argument_list|(
name|fs
argument_list|)
argument_list|,
name|Writer
operator|.
name|keyClass
argument_list|(
name|keyClass
argument_list|)
argument_list|,
name|Writer
operator|.
name|valueClass
argument_list|(
name|valClass
argument_list|)
argument_list|,
name|Writer
operator|.
name|compression
argument_list|(
name|compressionType
argument_list|)
argument_list|,
name|Writer
operator|.
name|progressable
argument_list|(
name|progress
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Construct the preferred type of SequenceFile Writer.    * @param fs The configured filesystem.     * @param conf The configuration.    * @param name The name of the file.     * @param keyClass The 'key' type.    * @param valClass The 'value' type.    * @param compressionType The compression type.    * @param codec The compression codec.    * @return Returns the handle to the constructed SequenceFile Writer.    * @throws IOException    * @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}    *     instead.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Writer
DECL|method|createWriter (FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionType compressionType, CompressionCodec codec)
name|createWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionType
name|compressionType
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createWriter
argument_list|(
name|conf
argument_list|,
name|Writer
operator|.
name|file
argument_list|(
name|name
argument_list|)
argument_list|,
name|Writer
operator|.
name|filesystem
argument_list|(
name|fs
argument_list|)
argument_list|,
name|Writer
operator|.
name|keyClass
argument_list|(
name|keyClass
argument_list|)
argument_list|,
name|Writer
operator|.
name|valueClass
argument_list|(
name|valClass
argument_list|)
argument_list|,
name|Writer
operator|.
name|compression
argument_list|(
name|compressionType
argument_list|,
name|codec
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Construct the preferred type of SequenceFile Writer.    * @param fs The configured filesystem.     * @param conf The configuration.    * @param name The name of the file.     * @param keyClass The 'key' type.    * @param valClass The 'value' type.    * @param compressionType The compression type.    * @param codec The compression codec.    * @param progress The Progressable object to track progress.    * @param metadata The metadata of the file.    * @return Returns the handle to the constructed SequenceFile Writer.    * @throws IOException    * @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}    *     instead.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Writer
DECL|method|createWriter (FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionType compressionType, CompressionCodec codec, Progressable progress, Metadata metadata)
name|createWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionType
name|compressionType
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createWriter
argument_list|(
name|conf
argument_list|,
name|Writer
operator|.
name|file
argument_list|(
name|name
argument_list|)
argument_list|,
name|Writer
operator|.
name|filesystem
argument_list|(
name|fs
argument_list|)
argument_list|,
name|Writer
operator|.
name|keyClass
argument_list|(
name|keyClass
argument_list|)
argument_list|,
name|Writer
operator|.
name|valueClass
argument_list|(
name|valClass
argument_list|)
argument_list|,
name|Writer
operator|.
name|compression
argument_list|(
name|compressionType
argument_list|,
name|codec
argument_list|)
argument_list|,
name|Writer
operator|.
name|progressable
argument_list|(
name|progress
argument_list|)
argument_list|,
name|Writer
operator|.
name|metadata
argument_list|(
name|metadata
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Construct the preferred type of SequenceFile Writer.    * @param fs The configured filesystem.    * @param conf The configuration.    * @param name The name of the file.    * @param keyClass The 'key' type.    * @param valClass The 'value' type.    * @param bufferSize buffer size for the underlaying outputstream.    * @param replication replication factor for the file.    * @param blockSize block size for the file.    * @param compressionType The compression type.    * @param codec The compression codec.    * @param progress The Progressable object to track progress.    * @param metadata The metadata of the file.    * @return Returns the handle to the constructed SequenceFile Writer.    * @throws IOException    * @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}    *     instead.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Writer
DECL|method|createWriter (FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, int bufferSize, short replication, long blockSize, CompressionType compressionType, CompressionCodec codec, Progressable progress, Metadata metadata)
name|createWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|CompressionType
name|compressionType
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createWriter
argument_list|(
name|conf
argument_list|,
name|Writer
operator|.
name|file
argument_list|(
name|name
argument_list|)
argument_list|,
name|Writer
operator|.
name|filesystem
argument_list|(
name|fs
argument_list|)
argument_list|,
name|Writer
operator|.
name|keyClass
argument_list|(
name|keyClass
argument_list|)
argument_list|,
name|Writer
operator|.
name|valueClass
argument_list|(
name|valClass
argument_list|)
argument_list|,
name|Writer
operator|.
name|bufferSize
argument_list|(
name|bufferSize
argument_list|)
argument_list|,
name|Writer
operator|.
name|replication
argument_list|(
name|replication
argument_list|)
argument_list|,
name|Writer
operator|.
name|blockSize
argument_list|(
name|blockSize
argument_list|)
argument_list|,
name|Writer
operator|.
name|compression
argument_list|(
name|compressionType
argument_list|,
name|codec
argument_list|)
argument_list|,
name|Writer
operator|.
name|progressable
argument_list|(
name|progress
argument_list|)
argument_list|,
name|Writer
operator|.
name|metadata
argument_list|(
name|metadata
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Construct the preferred type of SequenceFile Writer.    * @param fs The configured filesystem.    * @param conf The configuration.    * @param name The name of the file.    * @param keyClass The 'key' type.    * @param valClass The 'value' type.    * @param bufferSize buffer size for the underlaying outputstream.    * @param replication replication factor for the file.    * @param blockSize block size for the file.    * @param createParent create parent directory if non-existent    * @param compressionType The compression type.    * @param codec The compression codec.    * @param metadata The metadata of the file.    * @return Returns the handle to the constructed SequenceFile Writer.    * @throws IOException    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Writer
DECL|method|createWriter (FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, int bufferSize, short replication, long blockSize, boolean createParent, CompressionType compressionType, CompressionCodec codec, Metadata metadata)
name|createWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|boolean
name|createParent
parameter_list|,
name|CompressionType
name|compressionType
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createWriter
argument_list|(
name|FileContext
operator|.
name|getFileContext
argument_list|(
name|fs
operator|.
name|getUri
argument_list|()
argument_list|,
name|conf
argument_list|)
argument_list|,
name|conf
argument_list|,
name|name
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|compressionType
argument_list|,
name|codec
argument_list|,
name|metadata
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|CreateFlag
operator|.
name|CREATE
argument_list|,
name|CreateFlag
operator|.
name|OVERWRITE
argument_list|)
argument_list|,
name|CreateOpts
operator|.
name|bufferSize
argument_list|(
name|bufferSize
argument_list|)
argument_list|,
name|createParent
condition|?
name|CreateOpts
operator|.
name|createParent
argument_list|()
else|:
name|CreateOpts
operator|.
name|donotCreateParent
argument_list|()
argument_list|,
name|CreateOpts
operator|.
name|repFac
argument_list|(
name|replication
argument_list|)
argument_list|,
name|CreateOpts
operator|.
name|blockSize
argument_list|(
name|blockSize
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Construct the preferred type of SequenceFile Writer.    * @param fc The context for the specified file.    * @param conf The configuration.    * @param name The name of the file.    * @param keyClass The 'key' type.    * @param valClass The 'value' type.    * @param compressionType The compression type.    * @param codec The compression codec.    * @param metadata The metadata of the file.    * @param createFlag gives the semantics of create: overwrite, append etc.    * @param opts file creation options; see {@link CreateOpts}.    * @return Returns the handle to the constructed SequenceFile Writer.    * @throws IOException    */
specifier|public
specifier|static
name|Writer
DECL|method|createWriter (FileContext fc, Configuration conf, Path name, Class keyClass, Class valClass, CompressionType compressionType, CompressionCodec codec, Metadata metadata, final EnumSet<CreateFlag> createFlag, CreateOpts... opts)
name|createWriter
parameter_list|(
name|FileContext
name|fc
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionType
name|compressionType
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Metadata
name|metadata
parameter_list|,
specifier|final
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|createFlag
parameter_list|,
name|CreateOpts
modifier|...
name|opts
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createWriter
argument_list|(
name|conf
argument_list|,
name|fc
operator|.
name|create
argument_list|(
name|name
argument_list|,
name|createFlag
argument_list|,
name|opts
argument_list|)
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|compressionType
argument_list|,
name|codec
argument_list|,
name|metadata
argument_list|)
operator|.
name|ownStream
argument_list|()
return|;
block|}
comment|/**    * Construct the preferred type of SequenceFile Writer.    * @param fs The configured filesystem.     * @param conf The configuration.    * @param name The name of the file.     * @param keyClass The 'key' type.    * @param valClass The 'value' type.    * @param compressionType The compression type.    * @param codec The compression codec.    * @param progress The Progressable object to track progress.    * @return Returns the handle to the constructed SequenceFile Writer.    * @throws IOException    * @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}    *     instead.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Writer
DECL|method|createWriter (FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, CompressionType compressionType, CompressionCodec codec, Progressable progress)
name|createWriter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionType
name|compressionType
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createWriter
argument_list|(
name|conf
argument_list|,
name|Writer
operator|.
name|file
argument_list|(
name|name
argument_list|)
argument_list|,
name|Writer
operator|.
name|filesystem
argument_list|(
name|fs
argument_list|)
argument_list|,
name|Writer
operator|.
name|keyClass
argument_list|(
name|keyClass
argument_list|)
argument_list|,
name|Writer
operator|.
name|valueClass
argument_list|(
name|valClass
argument_list|)
argument_list|,
name|Writer
operator|.
name|compression
argument_list|(
name|compressionType
argument_list|,
name|codec
argument_list|)
argument_list|,
name|Writer
operator|.
name|progressable
argument_list|(
name|progress
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Construct the preferred type of 'raw' SequenceFile Writer.    * @param conf The configuration.    * @param out The stream on top which the writer is to be constructed.    * @param keyClass The 'key' type.    * @param valClass The 'value' type.    * @param compressionType The compression type.    * @param codec The compression codec.    * @param metadata The metadata of the file.    * @return Returns the handle to the constructed SequenceFile Writer.    * @throws IOException    * @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}    *     instead.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Writer
DECL|method|createWriter (Configuration conf, FSDataOutputStream out, Class keyClass, Class valClass, CompressionType compressionType, CompressionCodec codec, Metadata metadata)
name|createWriter
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FSDataOutputStream
name|out
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionType
name|compressionType
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createWriter
argument_list|(
name|conf
argument_list|,
name|Writer
operator|.
name|stream
argument_list|(
name|out
argument_list|)
argument_list|,
name|Writer
operator|.
name|keyClass
argument_list|(
name|keyClass
argument_list|)
argument_list|,
name|Writer
operator|.
name|valueClass
argument_list|(
name|valClass
argument_list|)
argument_list|,
name|Writer
operator|.
name|compression
argument_list|(
name|compressionType
argument_list|,
name|codec
argument_list|)
argument_list|,
name|Writer
operator|.
name|metadata
argument_list|(
name|metadata
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Construct the preferred type of 'raw' SequenceFile Writer.    * @param conf The configuration.    * @param out The stream on top which the writer is to be constructed.    * @param keyClass The 'key' type.    * @param valClass The 'value' type.    * @param compressionType The compression type.    * @param codec The compression codec.    * @return Returns the handle to the constructed SequenceFile Writer.    * @throws IOException    * @deprecated Use {@link #createWriter(Configuration, Writer.Option...)}    *     instead.    */
annotation|@
name|Deprecated
specifier|public
specifier|static
name|Writer
DECL|method|createWriter (Configuration conf, FSDataOutputStream out, Class keyClass, Class valClass, CompressionType compressionType, CompressionCodec codec)
name|createWriter
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FSDataOutputStream
name|out
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionType
name|compressionType
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createWriter
argument_list|(
name|conf
argument_list|,
name|Writer
operator|.
name|stream
argument_list|(
name|out
argument_list|)
argument_list|,
name|Writer
operator|.
name|keyClass
argument_list|(
name|keyClass
argument_list|)
argument_list|,
name|Writer
operator|.
name|valueClass
argument_list|(
name|valClass
argument_list|)
argument_list|,
name|Writer
operator|.
name|compression
argument_list|(
name|compressionType
argument_list|,
name|codec
argument_list|)
argument_list|)
return|;
block|}
comment|/** The interface to 'raw' values of SequenceFiles. */
DECL|interface|ValueBytes
specifier|public
specifier|static
interface|interface
name|ValueBytes
block|{
comment|/** Writes the uncompressed bytes to the outStream.      * @param outStream : Stream to write uncompressed bytes into.      * @throws IOException      */
DECL|method|writeUncompressedBytes (DataOutputStream outStream)
specifier|public
name|void
name|writeUncompressedBytes
parameter_list|(
name|DataOutputStream
name|outStream
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Write compressed bytes to outStream.       * Note: that it will NOT compress the bytes if they are not compressed.      * @param outStream : Stream to write compressed bytes into.      */
DECL|method|writeCompressedBytes (DataOutputStream outStream)
specifier|public
name|void
name|writeCompressedBytes
parameter_list|(
name|DataOutputStream
name|outStream
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|IOException
function_decl|;
comment|/**      * Size of stored data.      */
DECL|method|getSize ()
specifier|public
name|int
name|getSize
parameter_list|()
function_decl|;
block|}
DECL|class|UncompressedBytes
specifier|private
specifier|static
class|class
name|UncompressedBytes
implements|implements
name|ValueBytes
block|{
DECL|field|dataSize
specifier|private
name|int
name|dataSize
decl_stmt|;
DECL|field|data
specifier|private
name|byte
index|[]
name|data
decl_stmt|;
DECL|method|UncompressedBytes ()
specifier|private
name|UncompressedBytes
parameter_list|()
block|{
name|data
operator|=
literal|null
expr_stmt|;
name|dataSize
operator|=
literal|0
expr_stmt|;
block|}
DECL|method|reset (DataInputStream in, int length)
specifier|private
name|void
name|reset
parameter_list|(
name|DataInputStream
name|in
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
name|data
operator|=
operator|new
name|byte
index|[
name|length
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|>
name|data
operator|.
name|length
condition|)
block|{
name|data
operator|=
operator|new
name|byte
index|[
name|Math
operator|.
name|max
argument_list|(
name|length
argument_list|,
name|data
operator|.
name|length
operator|*
literal|2
argument_list|)
index|]
expr_stmt|;
block|}
name|dataSize
operator|=
operator|-
literal|1
expr_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|dataSize
operator|=
name|length
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getSize ()
specifier|public
name|int
name|getSize
parameter_list|()
block|{
return|return
name|dataSize
return|;
block|}
annotation|@
name|Override
DECL|method|writeUncompressedBytes (DataOutputStream outStream)
specifier|public
name|void
name|writeUncompressedBytes
parameter_list|(
name|DataOutputStream
name|outStream
parameter_list|)
throws|throws
name|IOException
block|{
name|outStream
operator|.
name|write
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|dataSize
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeCompressedBytes (DataOutputStream outStream)
specifier|public
name|void
name|writeCompressedBytes
parameter_list|(
name|DataOutputStream
name|outStream
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|IOException
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"UncompressedBytes cannot be compressed!"
argument_list|)
throw|;
block|}
block|}
comment|// UncompressedBytes
DECL|class|CompressedBytes
specifier|private
specifier|static
class|class
name|CompressedBytes
implements|implements
name|ValueBytes
block|{
DECL|field|dataSize
specifier|private
name|int
name|dataSize
decl_stmt|;
DECL|field|data
specifier|private
name|byte
index|[]
name|data
decl_stmt|;
DECL|field|rawData
name|DataInputBuffer
name|rawData
init|=
literal|null
decl_stmt|;
DECL|field|codec
name|CompressionCodec
name|codec
init|=
literal|null
decl_stmt|;
DECL|field|decompressedStream
name|CompressionInputStream
name|decompressedStream
init|=
literal|null
decl_stmt|;
DECL|method|CompressedBytes (CompressionCodec codec)
specifier|private
name|CompressedBytes
parameter_list|(
name|CompressionCodec
name|codec
parameter_list|)
block|{
name|data
operator|=
literal|null
expr_stmt|;
name|dataSize
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|codec
operator|=
name|codec
expr_stmt|;
block|}
DECL|method|reset (DataInputStream in, int length)
specifier|private
name|void
name|reset
parameter_list|(
name|DataInputStream
name|in
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
name|data
operator|=
operator|new
name|byte
index|[
name|length
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|>
name|data
operator|.
name|length
condition|)
block|{
name|data
operator|=
operator|new
name|byte
index|[
name|Math
operator|.
name|max
argument_list|(
name|length
argument_list|,
name|data
operator|.
name|length
operator|*
literal|2
argument_list|)
index|]
expr_stmt|;
block|}
name|dataSize
operator|=
operator|-
literal|1
expr_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|dataSize
operator|=
name|length
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getSize ()
specifier|public
name|int
name|getSize
parameter_list|()
block|{
return|return
name|dataSize
return|;
block|}
annotation|@
name|Override
DECL|method|writeUncompressedBytes (DataOutputStream outStream)
specifier|public
name|void
name|writeUncompressedBytes
parameter_list|(
name|DataOutputStream
name|outStream
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|decompressedStream
operator|==
literal|null
condition|)
block|{
name|rawData
operator|=
operator|new
name|DataInputBuffer
argument_list|()
expr_stmt|;
name|decompressedStream
operator|=
name|codec
operator|.
name|createInputStream
argument_list|(
name|rawData
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decompressedStream
operator|.
name|resetState
argument_list|()
expr_stmt|;
block|}
name|rawData
operator|.
name|reset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|dataSize
argument_list|)
expr_stmt|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
literal|8192
index|]
decl_stmt|;
name|int
name|bytesRead
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|bytesRead
operator|=
name|decompressedStream
operator|.
name|read
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
literal|8192
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|outStream
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|bytesRead
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|writeCompressedBytes (DataOutputStream outStream)
specifier|public
name|void
name|writeCompressedBytes
parameter_list|(
name|DataOutputStream
name|outStream
parameter_list|)
throws|throws
name|IllegalArgumentException
throws|,
name|IOException
block|{
name|outStream
operator|.
name|write
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|dataSize
argument_list|)
expr_stmt|;
block|}
block|}
comment|// CompressedBytes
comment|/**    * The class encapsulating with the metadata of a file.    * The metadata of a file is a list of attribute name/value    * pairs of Text type.    *    */
DECL|class|Metadata
specifier|public
specifier|static
class|class
name|Metadata
implements|implements
name|Writable
block|{
DECL|field|theMetadata
specifier|private
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|theMetadata
decl_stmt|;
DECL|method|Metadata ()
specifier|public
name|Metadata
parameter_list|()
block|{
name|this
argument_list|(
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|Metadata (TreeMap<Text, Text> arg)
specifier|public
name|Metadata
parameter_list|(
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|theMetadata
operator|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|theMetadata
operator|=
name|arg
expr_stmt|;
block|}
block|}
DECL|method|get (Text name)
specifier|public
name|Text
name|get
parameter_list|(
name|Text
name|name
parameter_list|)
block|{
return|return
name|this
operator|.
name|theMetadata
operator|.
name|get
argument_list|(
name|name
argument_list|)
return|;
block|}
DECL|method|set (Text name, Text value)
specifier|public
name|void
name|set
parameter_list|(
name|Text
name|name
parameter_list|,
name|Text
name|value
parameter_list|)
block|{
name|this
operator|.
name|theMetadata
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
DECL|method|getMetadata ()
specifier|public
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|getMetadata
parameter_list|()
block|{
return|return
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|(
name|this
operator|.
name|theMetadata
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|write (DataOutput out)
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|this
operator|.
name|theMetadata
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|>
name|iter
init|=
name|this
operator|.
name|theMetadata
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|en
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|en
operator|.
name|getKey
argument_list|()
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|en
operator|.
name|getValue
argument_list|()
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|readFields (DataInput in)
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|sz
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|sz
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Invalid size: "
operator|+
name|sz
operator|+
literal|" for file metadata object"
argument_list|)
throw|;
name|this
operator|.
name|theMetadata
operator|=
operator|new
name|TreeMap
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
name|Text
name|key
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
name|Text
name|val
init|=
operator|new
name|Text
argument_list|()
decl_stmt|;
name|key
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|val
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|this
operator|.
name|theMetadata
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|equals (Object other)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|other
operator|.
name|getClass
argument_list|()
operator|!=
name|this
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
name|equals
argument_list|(
operator|(
name|Metadata
operator|)
name|other
argument_list|)
return|;
block|}
block|}
DECL|method|equals (Metadata other)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Metadata
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|==
literal|null
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|this
operator|.
name|theMetadata
operator|.
name|size
argument_list|()
operator|!=
name|other
operator|.
name|theMetadata
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|>
name|iter1
init|=
name|this
operator|.
name|theMetadata
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|>
name|iter2
init|=
name|other
operator|.
name|theMetadata
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter1
operator|.
name|hasNext
argument_list|()
operator|&&
name|iter2
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|en1
init|=
name|iter1
operator|.
name|next
argument_list|()
decl_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|en2
init|=
name|iter2
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|en1
operator|.
name|getKey
argument_list|()
operator|.
name|equals
argument_list|(
name|en2
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|en1
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
name|en2
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|iter1
operator|.
name|hasNext
argument_list|()
operator|||
name|iter2
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
assert|assert
literal|false
operator|:
literal|"hashCode not designed"
assert|;
return|return
literal|42
return|;
comment|// any arbitrary constant will do
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"size: "
argument_list|)
operator|.
name|append
argument_list|(
name|this
operator|.
name|theMetadata
operator|.
name|size
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
argument_list|>
name|iter
init|=
name|this
operator|.
name|theMetadata
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|Text
argument_list|,
name|Text
argument_list|>
name|en
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
name|en
operator|.
name|getKey
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"\t"
argument_list|)
operator|.
name|append
argument_list|(
name|en
operator|.
name|getValue
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/** Write key/value pairs to a sequence-format file. */
DECL|class|Writer
specifier|public
specifier|static
class|class
name|Writer
implements|implements
name|java
operator|.
name|io
operator|.
name|Closeable
implements|,
name|Syncable
block|{
DECL|field|conf
specifier|private
name|Configuration
name|conf
decl_stmt|;
DECL|field|out
name|FSDataOutputStream
name|out
decl_stmt|;
DECL|field|ownOutputStream
name|boolean
name|ownOutputStream
init|=
literal|true
decl_stmt|;
DECL|field|buffer
name|DataOutputBuffer
name|buffer
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
DECL|field|keyClass
name|Class
name|keyClass
decl_stmt|;
DECL|field|valClass
name|Class
name|valClass
decl_stmt|;
DECL|field|compress
specifier|private
specifier|final
name|CompressionType
name|compress
decl_stmt|;
DECL|field|codec
name|CompressionCodec
name|codec
init|=
literal|null
decl_stmt|;
DECL|field|deflateFilter
name|CompressionOutputStream
name|deflateFilter
init|=
literal|null
decl_stmt|;
DECL|field|deflateOut
name|DataOutputStream
name|deflateOut
init|=
literal|null
decl_stmt|;
DECL|field|metadata
name|Metadata
name|metadata
init|=
literal|null
decl_stmt|;
DECL|field|compressor
name|Compressor
name|compressor
init|=
literal|null
decl_stmt|;
DECL|field|appendMode
specifier|private
name|boolean
name|appendMode
init|=
literal|false
decl_stmt|;
DECL|field|keySerializer
specifier|protected
name|Serializer
name|keySerializer
decl_stmt|;
DECL|field|uncompressedValSerializer
specifier|protected
name|Serializer
name|uncompressedValSerializer
decl_stmt|;
DECL|field|compressedValSerializer
specifier|protected
name|Serializer
name|compressedValSerializer
decl_stmt|;
comment|// Insert a globally unique 16-byte value every few entries, so that one
comment|// can seek into the middle of a file and then synchronize with record
comment|// starts and ends by scanning for this value.
DECL|field|lastSyncPos
name|long
name|lastSyncPos
decl_stmt|;
comment|// position of last sync
DECL|field|sync
name|byte
index|[]
name|sync
decl_stmt|;
comment|// 16 random bytes
block|{
try|try
block|{
name|MessageDigest
name|digester
init|=
name|MessageDigest
operator|.
name|getInstance
argument_list|(
literal|"MD5"
argument_list|)
decl_stmt|;
name|long
name|time
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
name|digester
operator|.
name|update
argument_list|(
operator|(
operator|new
name|UID
argument_list|()
operator|+
literal|"@"
operator|+
name|time
operator|)
operator|.
name|getBytes
argument_list|(
name|Charsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
name|sync
operator|=
name|digester
operator|.
name|digest
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|interface|Option
specifier|public
specifier|static
interface|interface
name|Option
block|{}
DECL|class|FileOption
specifier|static
class|class
name|FileOption
extends|extends
name|Options
operator|.
name|PathOption
implements|implements
name|Option
block|{
DECL|method|FileOption (Path path)
name|FileOption
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
name|super
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * @deprecated only used for backwards-compatibility in the createWriter methods      * that take FileSystem.      */
annotation|@
name|Deprecated
DECL|class|FileSystemOption
specifier|private
specifier|static
class|class
name|FileSystemOption
implements|implements
name|Option
block|{
DECL|field|value
specifier|private
specifier|final
name|FileSystem
name|value
decl_stmt|;
DECL|method|FileSystemOption (FileSystem value)
specifier|protected
name|FileSystemOption
parameter_list|(
name|FileSystem
name|value
parameter_list|)
block|{
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
DECL|method|getValue ()
specifier|public
name|FileSystem
name|getValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
block|}
DECL|class|StreamOption
specifier|static
class|class
name|StreamOption
extends|extends
name|Options
operator|.
name|FSDataOutputStreamOption
implements|implements
name|Option
block|{
DECL|method|StreamOption (FSDataOutputStream stream)
name|StreamOption
parameter_list|(
name|FSDataOutputStream
name|stream
parameter_list|)
block|{
name|super
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|BufferSizeOption
specifier|static
class|class
name|BufferSizeOption
extends|extends
name|Options
operator|.
name|IntegerOption
implements|implements
name|Option
block|{
DECL|method|BufferSizeOption (int value)
name|BufferSizeOption
parameter_list|(
name|int
name|value
parameter_list|)
block|{
name|super
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|BlockSizeOption
specifier|static
class|class
name|BlockSizeOption
extends|extends
name|Options
operator|.
name|LongOption
implements|implements
name|Option
block|{
DECL|method|BlockSizeOption (long value)
name|BlockSizeOption
parameter_list|(
name|long
name|value
parameter_list|)
block|{
name|super
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|ReplicationOption
specifier|static
class|class
name|ReplicationOption
extends|extends
name|Options
operator|.
name|IntegerOption
implements|implements
name|Option
block|{
DECL|method|ReplicationOption (int value)
name|ReplicationOption
parameter_list|(
name|int
name|value
parameter_list|)
block|{
name|super
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|AppendIfExistsOption
specifier|static
class|class
name|AppendIfExistsOption
extends|extends
name|Options
operator|.
name|BooleanOption
implements|implements
name|Option
block|{
DECL|method|AppendIfExistsOption (boolean value)
name|AppendIfExistsOption
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
name|super
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|KeyClassOption
specifier|static
class|class
name|KeyClassOption
extends|extends
name|Options
operator|.
name|ClassOption
implements|implements
name|Option
block|{
DECL|method|KeyClassOption (Class<?> value)
name|KeyClassOption
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|value
parameter_list|)
block|{
name|super
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|ValueClassOption
specifier|static
class|class
name|ValueClassOption
extends|extends
name|Options
operator|.
name|ClassOption
implements|implements
name|Option
block|{
DECL|method|ValueClassOption (Class<?> value)
name|ValueClassOption
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|value
parameter_list|)
block|{
name|super
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|MetadataOption
specifier|static
class|class
name|MetadataOption
implements|implements
name|Option
block|{
DECL|field|value
specifier|private
specifier|final
name|Metadata
name|value
decl_stmt|;
DECL|method|MetadataOption (Metadata value)
name|MetadataOption
parameter_list|(
name|Metadata
name|value
parameter_list|)
block|{
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
DECL|method|getValue ()
name|Metadata
name|getValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
block|}
DECL|class|ProgressableOption
specifier|static
class|class
name|ProgressableOption
extends|extends
name|Options
operator|.
name|ProgressableOption
implements|implements
name|Option
block|{
DECL|method|ProgressableOption (Progressable value)
name|ProgressableOption
parameter_list|(
name|Progressable
name|value
parameter_list|)
block|{
name|super
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|CompressionOption
specifier|private
specifier|static
class|class
name|CompressionOption
implements|implements
name|Option
block|{
DECL|field|value
specifier|private
specifier|final
name|CompressionType
name|value
decl_stmt|;
DECL|field|codec
specifier|private
specifier|final
name|CompressionCodec
name|codec
decl_stmt|;
DECL|method|CompressionOption (CompressionType value)
name|CompressionOption
parameter_list|(
name|CompressionType
name|value
parameter_list|)
block|{
name|this
argument_list|(
name|value
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|CompressionOption (CompressionType value, CompressionCodec codec)
name|CompressionOption
parameter_list|(
name|CompressionType
name|value
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|)
block|{
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|this
operator|.
name|codec
operator|=
operator|(
name|CompressionType
operator|.
name|NONE
operator|!=
name|value
operator|&&
literal|null
operator|==
name|codec
operator|)
condition|?
operator|new
name|DefaultCodec
argument_list|()
else|:
name|codec
expr_stmt|;
block|}
DECL|method|getValue ()
name|CompressionType
name|getValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
DECL|method|getCodec ()
name|CompressionCodec
name|getCodec
parameter_list|()
block|{
return|return
name|codec
return|;
block|}
block|}
DECL|method|file (Path value)
specifier|public
specifier|static
name|Option
name|file
parameter_list|(
name|Path
name|value
parameter_list|)
block|{
return|return
operator|new
name|FileOption
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**      * @deprecated only used for backwards-compatibility in the createWriter methods      * that take FileSystem.      */
annotation|@
name|Deprecated
DECL|method|filesystem (FileSystem fs)
specifier|private
specifier|static
name|Option
name|filesystem
parameter_list|(
name|FileSystem
name|fs
parameter_list|)
block|{
return|return
operator|new
name|SequenceFile
operator|.
name|Writer
operator|.
name|FileSystemOption
argument_list|(
name|fs
argument_list|)
return|;
block|}
DECL|method|bufferSize (int value)
specifier|public
specifier|static
name|Option
name|bufferSize
parameter_list|(
name|int
name|value
parameter_list|)
block|{
return|return
operator|new
name|BufferSizeOption
argument_list|(
name|value
argument_list|)
return|;
block|}
DECL|method|stream (FSDataOutputStream value)
specifier|public
specifier|static
name|Option
name|stream
parameter_list|(
name|FSDataOutputStream
name|value
parameter_list|)
block|{
return|return
operator|new
name|StreamOption
argument_list|(
name|value
argument_list|)
return|;
block|}
DECL|method|replication (short value)
specifier|public
specifier|static
name|Option
name|replication
parameter_list|(
name|short
name|value
parameter_list|)
block|{
return|return
operator|new
name|ReplicationOption
argument_list|(
name|value
argument_list|)
return|;
block|}
DECL|method|appendIfExists (boolean value)
specifier|public
specifier|static
name|Option
name|appendIfExists
parameter_list|(
name|boolean
name|value
parameter_list|)
block|{
return|return
operator|new
name|AppendIfExistsOption
argument_list|(
name|value
argument_list|)
return|;
block|}
DECL|method|blockSize (long value)
specifier|public
specifier|static
name|Option
name|blockSize
parameter_list|(
name|long
name|value
parameter_list|)
block|{
return|return
operator|new
name|BlockSizeOption
argument_list|(
name|value
argument_list|)
return|;
block|}
DECL|method|progressable (Progressable value)
specifier|public
specifier|static
name|Option
name|progressable
parameter_list|(
name|Progressable
name|value
parameter_list|)
block|{
return|return
operator|new
name|ProgressableOption
argument_list|(
name|value
argument_list|)
return|;
block|}
DECL|method|keyClass (Class<?> value)
specifier|public
specifier|static
name|Option
name|keyClass
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|value
parameter_list|)
block|{
return|return
operator|new
name|KeyClassOption
argument_list|(
name|value
argument_list|)
return|;
block|}
DECL|method|valueClass (Class<?> value)
specifier|public
specifier|static
name|Option
name|valueClass
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|value
parameter_list|)
block|{
return|return
operator|new
name|ValueClassOption
argument_list|(
name|value
argument_list|)
return|;
block|}
DECL|method|metadata (Metadata value)
specifier|public
specifier|static
name|Option
name|metadata
parameter_list|(
name|Metadata
name|value
parameter_list|)
block|{
return|return
operator|new
name|MetadataOption
argument_list|(
name|value
argument_list|)
return|;
block|}
DECL|method|compression (CompressionType value)
specifier|public
specifier|static
name|Option
name|compression
parameter_list|(
name|CompressionType
name|value
parameter_list|)
block|{
return|return
operator|new
name|CompressionOption
argument_list|(
name|value
argument_list|)
return|;
block|}
DECL|method|compression (CompressionType value, CompressionCodec codec)
specifier|public
specifier|static
name|Option
name|compression
parameter_list|(
name|CompressionType
name|value
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|)
block|{
return|return
operator|new
name|CompressionOption
argument_list|(
name|value
argument_list|,
name|codec
argument_list|)
return|;
block|}
comment|/**      * Construct a uncompressed writer from a set of options.      * @param conf the configuration to use      * @param options the options used when creating the writer      * @throws IOException if it fails      */
DECL|method|Writer (Configuration conf, Option... opts)
name|Writer
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Option
modifier|...
name|opts
parameter_list|)
throws|throws
name|IOException
block|{
name|BlockSizeOption
name|blockSizeOption
init|=
name|Options
operator|.
name|getOption
argument_list|(
name|BlockSizeOption
operator|.
name|class
argument_list|,
name|opts
argument_list|)
decl_stmt|;
name|BufferSizeOption
name|bufferSizeOption
init|=
name|Options
operator|.
name|getOption
argument_list|(
name|BufferSizeOption
operator|.
name|class
argument_list|,
name|opts
argument_list|)
decl_stmt|;
name|ReplicationOption
name|replicationOption
init|=
name|Options
operator|.
name|getOption
argument_list|(
name|ReplicationOption
operator|.
name|class
argument_list|,
name|opts
argument_list|)
decl_stmt|;
name|ProgressableOption
name|progressOption
init|=
name|Options
operator|.
name|getOption
argument_list|(
name|ProgressableOption
operator|.
name|class
argument_list|,
name|opts
argument_list|)
decl_stmt|;
name|FileOption
name|fileOption
init|=
name|Options
operator|.
name|getOption
argument_list|(
name|FileOption
operator|.
name|class
argument_list|,
name|opts
argument_list|)
decl_stmt|;
name|AppendIfExistsOption
name|appendIfExistsOption
init|=
name|Options
operator|.
name|getOption
argument_list|(
name|AppendIfExistsOption
operator|.
name|class
argument_list|,
name|opts
argument_list|)
decl_stmt|;
name|FileSystemOption
name|fsOption
init|=
name|Options
operator|.
name|getOption
argument_list|(
name|FileSystemOption
operator|.
name|class
argument_list|,
name|opts
argument_list|)
decl_stmt|;
name|StreamOption
name|streamOption
init|=
name|Options
operator|.
name|getOption
argument_list|(
name|StreamOption
operator|.
name|class
argument_list|,
name|opts
argument_list|)
decl_stmt|;
name|KeyClassOption
name|keyClassOption
init|=
name|Options
operator|.
name|getOption
argument_list|(
name|KeyClassOption
operator|.
name|class
argument_list|,
name|opts
argument_list|)
decl_stmt|;
name|ValueClassOption
name|valueClassOption
init|=
name|Options
operator|.
name|getOption
argument_list|(
name|ValueClassOption
operator|.
name|class
argument_list|,
name|opts
argument_list|)
decl_stmt|;
name|MetadataOption
name|metadataOption
init|=
name|Options
operator|.
name|getOption
argument_list|(
name|MetadataOption
operator|.
name|class
argument_list|,
name|opts
argument_list|)
decl_stmt|;
name|CompressionOption
name|compressionTypeOption
init|=
name|Options
operator|.
name|getOption
argument_list|(
name|CompressionOption
operator|.
name|class
argument_list|,
name|opts
argument_list|)
decl_stmt|;
comment|// check consistency of options
if|if
condition|(
operator|(
name|fileOption
operator|==
literal|null
operator|)
operator|==
operator|(
name|streamOption
operator|==
literal|null
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"file or stream must be specified"
argument_list|)
throw|;
block|}
if|if
condition|(
name|fileOption
operator|==
literal|null
operator|&&
operator|(
name|blockSizeOption
operator|!=
literal|null
operator|||
name|bufferSizeOption
operator|!=
literal|null
operator|||
name|replicationOption
operator|!=
literal|null
operator|||
name|progressOption
operator|!=
literal|null
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"file modifier options not "
operator|+
literal|"compatible with stream"
argument_list|)
throw|;
block|}
name|FSDataOutputStream
name|out
decl_stmt|;
name|boolean
name|ownStream
init|=
name|fileOption
operator|!=
literal|null
decl_stmt|;
if|if
condition|(
name|ownStream
condition|)
block|{
name|Path
name|p
init|=
name|fileOption
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|FileSystem
name|fs
decl_stmt|;
if|if
condition|(
name|fsOption
operator|!=
literal|null
condition|)
block|{
name|fs
operator|=
name|fsOption
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|fs
operator|=
name|p
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
name|int
name|bufferSize
init|=
name|bufferSizeOption
operator|==
literal|null
condition|?
name|getBufferSize
argument_list|(
name|conf
argument_list|)
else|:
name|bufferSizeOption
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|short
name|replication
init|=
name|replicationOption
operator|==
literal|null
condition|?
name|fs
operator|.
name|getDefaultReplication
argument_list|(
name|p
argument_list|)
else|:
operator|(
name|short
operator|)
name|replicationOption
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|long
name|blockSize
init|=
name|blockSizeOption
operator|==
literal|null
condition|?
name|fs
operator|.
name|getDefaultBlockSize
argument_list|(
name|p
argument_list|)
else|:
name|blockSizeOption
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Progressable
name|progress
init|=
name|progressOption
operator|==
literal|null
condition|?
literal|null
else|:
name|progressOption
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|appendIfExistsOption
operator|!=
literal|null
operator|&&
name|appendIfExistsOption
operator|.
name|getValue
argument_list|()
operator|&&
name|fs
operator|.
name|exists
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|// Read the file and verify header details
name|SequenceFile
operator|.
name|Reader
name|reader
init|=
operator|new
name|SequenceFile
operator|.
name|Reader
argument_list|(
name|conf
argument_list|,
name|SequenceFile
operator|.
name|Reader
operator|.
name|file
argument_list|(
name|p
argument_list|)
argument_list|,
operator|new
name|Reader
operator|.
name|OnlyHeaderOption
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|keyClassOption
operator|.
name|getValue
argument_list|()
operator|!=
name|reader
operator|.
name|getKeyClass
argument_list|()
operator|||
name|valueClassOption
operator|.
name|getValue
argument_list|()
operator|!=
name|reader
operator|.
name|getValueClass
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Key/value class provided does not match the file"
argument_list|)
throw|;
block|}
if|if
condition|(
name|reader
operator|.
name|getVersion
argument_list|()
operator|!=
name|VERSION
index|[
literal|3
index|]
condition|)
block|{
throw|throw
operator|new
name|VersionMismatchException
argument_list|(
name|VERSION
index|[
literal|3
index|]
argument_list|,
name|reader
operator|.
name|getVersion
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|metadataOption
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"MetaData Option is ignored during append"
argument_list|)
expr_stmt|;
block|}
name|metadataOption
operator|=
operator|(
name|MetadataOption
operator|)
name|SequenceFile
operator|.
name|Writer
operator|.
name|metadata
argument_list|(
name|reader
operator|.
name|getMetadata
argument_list|()
argument_list|)
expr_stmt|;
name|CompressionOption
name|readerCompressionOption
init|=
operator|new
name|CompressionOption
argument_list|(
name|reader
operator|.
name|getCompressionType
argument_list|()
argument_list|,
name|reader
operator|.
name|getCompressionCodec
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|readerCompressionOption
operator|.
name|value
operator|!=
name|compressionTypeOption
operator|.
name|value
operator|||
operator|!
name|readerCompressionOption
operator|.
name|codec
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|compressionTypeOption
operator|.
name|codec
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Compression option provided does not match the file"
argument_list|)
throw|;
block|}
name|sync
operator|=
name|reader
operator|.
name|getSync
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|out
operator|=
name|fs
operator|.
name|append
argument_list|(
name|p
argument_list|,
name|bufferSize
argument_list|,
name|progress
argument_list|)
expr_stmt|;
name|this
operator|.
name|appendMode
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|out
operator|=
name|fs
operator|.
name|create
argument_list|(
name|p
argument_list|,
literal|true
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|out
operator|=
name|streamOption
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
name|Class
argument_list|<
name|?
argument_list|>
name|keyClass
init|=
name|keyClassOption
operator|==
literal|null
condition|?
name|Object
operator|.
name|class
else|:
name|keyClassOption
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|valueClass
init|=
name|valueClassOption
operator|==
literal|null
condition|?
name|Object
operator|.
name|class
else|:
name|valueClassOption
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Metadata
name|metadata
init|=
name|metadataOption
operator|==
literal|null
condition|?
operator|new
name|Metadata
argument_list|()
else|:
name|metadataOption
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|this
operator|.
name|compress
operator|=
name|compressionTypeOption
operator|.
name|getValue
argument_list|()
expr_stmt|;
specifier|final
name|CompressionCodec
name|codec
init|=
name|compressionTypeOption
operator|.
name|getCodec
argument_list|()
decl_stmt|;
if|if
condition|(
name|codec
operator|!=
literal|null
operator|&&
operator|(
name|codec
operator|instanceof
name|GzipCodec
operator|)
operator|&&
operator|!
name|NativeCodeLoader
operator|.
name|isNativeCodeLoaded
argument_list|()
operator|&&
operator|!
name|ZlibFactory
operator|.
name|isNativeZlibLoaded
argument_list|(
name|conf
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"SequenceFile doesn't work with "
operator|+
literal|"GzipCodec without native-hadoop "
operator|+
literal|"code!"
argument_list|)
throw|;
block|}
name|init
argument_list|(
name|conf
argument_list|,
name|out
argument_list|,
name|ownStream
argument_list|,
name|keyClass
argument_list|,
name|valueClass
argument_list|,
name|codec
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
comment|/** Create the named file.      * @deprecated Use       *   {@link SequenceFile#createWriter(Configuration, Writer.Option...)}       *   instead.      */
annotation|@
name|Deprecated
DECL|method|Writer (FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass)
specifier|public
name|Writer
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|compress
operator|=
name|CompressionType
operator|.
name|NONE
expr_stmt|;
name|init
argument_list|(
name|conf
argument_list|,
name|fs
operator|.
name|create
argument_list|(
name|name
argument_list|)
argument_list|,
literal|true
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
literal|null
argument_list|,
operator|new
name|Metadata
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Create the named file with write-progress reporter.      * @deprecated Use       *   {@link SequenceFile#createWriter(Configuration, Writer.Option...)}       *   instead.      */
annotation|@
name|Deprecated
DECL|method|Writer (FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, Progressable progress, Metadata metadata)
specifier|public
name|Writer
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|compress
operator|=
name|CompressionType
operator|.
name|NONE
expr_stmt|;
name|init
argument_list|(
name|conf
argument_list|,
name|fs
operator|.
name|create
argument_list|(
name|name
argument_list|,
name|progress
argument_list|)
argument_list|,
literal|true
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
literal|null
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
comment|/** Create the named file with write-progress reporter.       * @deprecated Use       *   {@link SequenceFile#createWriter(Configuration, Writer.Option...)}       *   instead.      */
annotation|@
name|Deprecated
DECL|method|Writer (FileSystem fs, Configuration conf, Path name, Class keyClass, Class valClass, int bufferSize, short replication, long blockSize, Progressable progress, Metadata metadata)
specifier|public
name|Writer
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Path
name|name
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|compress
operator|=
name|CompressionType
operator|.
name|NONE
expr_stmt|;
name|init
argument_list|(
name|conf
argument_list|,
name|fs
operator|.
name|create
argument_list|(
name|name
argument_list|,
literal|true
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|)
argument_list|,
literal|true
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
literal|null
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
DECL|method|isCompressed ()
name|boolean
name|isCompressed
parameter_list|()
block|{
return|return
name|compress
operator|!=
name|CompressionType
operator|.
name|NONE
return|;
block|}
DECL|method|isBlockCompressed ()
name|boolean
name|isBlockCompressed
parameter_list|()
block|{
return|return
name|compress
operator|==
name|CompressionType
operator|.
name|BLOCK
return|;
block|}
DECL|method|ownStream ()
name|Writer
name|ownStream
parameter_list|()
block|{
name|this
operator|.
name|ownOutputStream
operator|=
literal|true
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/** Write and flush the file header. */
DECL|method|writeFileHeader ()
specifier|private
name|void
name|writeFileHeader
parameter_list|()
throws|throws
name|IOException
block|{
name|out
operator|.
name|write
argument_list|(
name|VERSION
argument_list|)
expr_stmt|;
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|keyClass
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
name|valClass
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBoolean
argument_list|(
name|this
operator|.
name|isCompressed
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBoolean
argument_list|(
name|this
operator|.
name|isBlockCompressed
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|isCompressed
argument_list|()
condition|)
block|{
name|Text
operator|.
name|writeString
argument_list|(
name|out
argument_list|,
operator|(
name|codec
operator|.
name|getClass
argument_list|()
operator|)
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|metadata
operator|.
name|write
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|sync
argument_list|)
expr_stmt|;
comment|// write the sync bytes
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
comment|// flush header
block|}
comment|/** Initialize. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|init (Configuration conf, FSDataOutputStream out, boolean ownStream, Class keyClass, Class valClass, CompressionCodec codec, Metadata metadata)
name|void
name|init
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|FSDataOutputStream
name|out
parameter_list|,
name|boolean
name|ownStream
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|out
operator|=
name|out
expr_stmt|;
name|this
operator|.
name|ownOutputStream
operator|=
name|ownStream
expr_stmt|;
name|this
operator|.
name|keyClass
operator|=
name|keyClass
expr_stmt|;
name|this
operator|.
name|valClass
operator|=
name|valClass
expr_stmt|;
name|this
operator|.
name|codec
operator|=
name|codec
expr_stmt|;
name|this
operator|.
name|metadata
operator|=
name|metadata
expr_stmt|;
name|SerializationFactory
name|serializationFactory
init|=
operator|new
name|SerializationFactory
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|this
operator|.
name|keySerializer
operator|=
name|serializationFactory
operator|.
name|getSerializer
argument_list|(
name|keyClass
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|keySerializer
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not find a serializer for the Key class: '"
operator|+
name|keyClass
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"'. "
operator|+
literal|"Please ensure that the configuration '"
operator|+
name|CommonConfigurationKeys
operator|.
name|IO_SERIALIZATIONS_KEY
operator|+
literal|"' is "
operator|+
literal|"properly configured, if you're using"
operator|+
literal|"custom serialization."
argument_list|)
throw|;
block|}
name|this
operator|.
name|keySerializer
operator|.
name|open
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|this
operator|.
name|uncompressedValSerializer
operator|=
name|serializationFactory
operator|.
name|getSerializer
argument_list|(
name|valClass
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|uncompressedValSerializer
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not find a serializer for the Value class: '"
operator|+
name|valClass
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"'. "
operator|+
literal|"Please ensure that the configuration '"
operator|+
name|CommonConfigurationKeys
operator|.
name|IO_SERIALIZATIONS_KEY
operator|+
literal|"' is "
operator|+
literal|"properly configured, if you're using"
operator|+
literal|"custom serialization."
argument_list|)
throw|;
block|}
name|this
operator|.
name|uncompressedValSerializer
operator|.
name|open
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|codec
operator|!=
literal|null
condition|)
block|{
name|ReflectionUtils
operator|.
name|setConf
argument_list|(
name|this
operator|.
name|codec
argument_list|,
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|compressor
operator|=
name|CodecPool
operator|.
name|getCompressor
argument_list|(
name|this
operator|.
name|codec
argument_list|)
expr_stmt|;
name|this
operator|.
name|deflateFilter
operator|=
name|this
operator|.
name|codec
operator|.
name|createOutputStream
argument_list|(
name|buffer
argument_list|,
name|compressor
argument_list|)
expr_stmt|;
name|this
operator|.
name|deflateOut
operator|=
operator|new
name|DataOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|deflateFilter
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|compressedValSerializer
operator|=
name|serializationFactory
operator|.
name|getSerializer
argument_list|(
name|valClass
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|compressedValSerializer
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not find a serializer for the Value class: '"
operator|+
name|valClass
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"'. "
operator|+
literal|"Please ensure that the configuration '"
operator|+
name|CommonConfigurationKeys
operator|.
name|IO_SERIALIZATIONS_KEY
operator|+
literal|"' is "
operator|+
literal|"properly configured, if you're using"
operator|+
literal|"custom serialization."
argument_list|)
throw|;
block|}
name|this
operator|.
name|compressedValSerializer
operator|.
name|open
argument_list|(
name|deflateOut
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|appendMode
condition|)
block|{
name|sync
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|writeFileHeader
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Returns the class of keys in this file. */
DECL|method|getKeyClass ()
specifier|public
name|Class
name|getKeyClass
parameter_list|()
block|{
return|return
name|keyClass
return|;
block|}
comment|/** Returns the class of values in this file. */
DECL|method|getValueClass ()
specifier|public
name|Class
name|getValueClass
parameter_list|()
block|{
return|return
name|valClass
return|;
block|}
comment|/** Returns the compression codec of data in this file. */
DECL|method|getCompressionCodec ()
specifier|public
name|CompressionCodec
name|getCompressionCodec
parameter_list|()
block|{
return|return
name|codec
return|;
block|}
comment|/** create a sync point */
DECL|method|sync ()
specifier|public
name|void
name|sync
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|sync
operator|!=
literal|null
operator|&&
name|lastSyncPos
operator|!=
name|out
operator|.
name|getPos
argument_list|()
condition|)
block|{
name|out
operator|.
name|writeInt
argument_list|(
name|SYNC_ESCAPE
argument_list|)
expr_stmt|;
comment|// mark the start of the sync
name|out
operator|.
name|write
argument_list|(
name|sync
argument_list|)
expr_stmt|;
comment|// write sync
name|lastSyncPos
operator|=
name|out
operator|.
name|getPos
argument_list|()
expr_stmt|;
comment|// update lastSyncPos
block|}
block|}
comment|/**      * flush all currently written data to the file system      * @deprecated Use {@link #hsync()} or {@link #hflush()} instead      */
annotation|@
name|Deprecated
DECL|method|syncFs ()
specifier|public
name|void
name|syncFs
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|hflush
argument_list|()
expr_stmt|;
comment|// flush contents to file system
block|}
block|}
annotation|@
name|Override
DECL|method|hsync ()
specifier|public
name|void
name|hsync
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|hsync
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|hflush ()
specifier|public
name|void
name|hflush
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|hflush
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Returns the configuration of this file. */
DECL|method|getConf ()
name|Configuration
name|getConf
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
comment|/** Close the file. */
annotation|@
name|Override
DECL|method|close ()
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|keySerializer
operator|.
name|close
argument_list|()
expr_stmt|;
name|uncompressedValSerializer
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|compressedValSerializer
operator|!=
literal|null
condition|)
block|{
name|compressedValSerializer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|CodecPool
operator|.
name|returnCompressor
argument_list|(
name|compressor
argument_list|)
expr_stmt|;
name|compressor
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
comment|// Close the underlying stream iff we own it...
if|if
condition|(
name|ownOutputStream
condition|)
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
name|out
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|method|checkAndWriteSync ()
specifier|synchronized
name|void
name|checkAndWriteSync
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|sync
operator|!=
literal|null
operator|&&
name|out
operator|.
name|getPos
argument_list|()
operator|>=
name|lastSyncPos
operator|+
name|SYNC_INTERVAL
condition|)
block|{
comment|// time to emit sync
name|sync
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Append a key/value pair. */
DECL|method|append (Writable key, Writable val)
specifier|public
name|void
name|append
parameter_list|(
name|Writable
name|key
parameter_list|,
name|Writable
name|val
parameter_list|)
throws|throws
name|IOException
block|{
name|append
argument_list|(
operator|(
name|Object
operator|)
name|key
argument_list|,
operator|(
name|Object
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
comment|/** Append a key/value pair. */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|append (Object key, Object val)
specifier|public
specifier|synchronized
name|void
name|append
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|key
operator|.
name|getClass
argument_list|()
operator|!=
name|keyClass
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"wrong key class: "
operator|+
name|key
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" is not "
operator|+
name|keyClass
argument_list|)
throw|;
if|if
condition|(
name|val
operator|.
name|getClass
argument_list|()
operator|!=
name|valClass
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"wrong value class: "
operator|+
name|val
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" is not "
operator|+
name|valClass
argument_list|)
throw|;
name|buffer
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// Append the 'key'
name|keySerializer
operator|.
name|serialize
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|int
name|keyLength
init|=
name|buffer
operator|.
name|getLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"negative length keys not allowed: "
operator|+
name|key
argument_list|)
throw|;
comment|// Append the 'value'
if|if
condition|(
name|compress
operator|==
name|CompressionType
operator|.
name|RECORD
condition|)
block|{
name|deflateFilter
operator|.
name|resetState
argument_list|()
expr_stmt|;
name|compressedValSerializer
operator|.
name|serialize
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|deflateOut
operator|.
name|flush
argument_list|()
expr_stmt|;
name|deflateFilter
operator|.
name|finish
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|uncompressedValSerializer
operator|.
name|serialize
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
comment|// Write the record out
name|checkAndWriteSync
argument_list|()
expr_stmt|;
comment|// sync
name|out
operator|.
name|writeInt
argument_list|(
name|buffer
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
comment|// total record length
name|out
operator|.
name|writeInt
argument_list|(
name|keyLength
argument_list|)
expr_stmt|;
comment|// key portion length
name|out
operator|.
name|write
argument_list|(
name|buffer
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|buffer
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
comment|// data
block|}
DECL|method|appendRaw (byte[] keyData, int keyOffset, int keyLength, ValueBytes val)
specifier|public
specifier|synchronized
name|void
name|appendRaw
parameter_list|(
name|byte
index|[]
name|keyData
parameter_list|,
name|int
name|keyOffset
parameter_list|,
name|int
name|keyLength
parameter_list|,
name|ValueBytes
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"negative length keys not allowed: "
operator|+
name|keyLength
argument_list|)
throw|;
name|int
name|valLength
init|=
name|val
operator|.
name|getSize
argument_list|()
decl_stmt|;
name|checkAndWriteSync
argument_list|()
expr_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|keyLength
operator|+
name|valLength
argument_list|)
expr_stmt|;
comment|// total record length
name|out
operator|.
name|writeInt
argument_list|(
name|keyLength
argument_list|)
expr_stmt|;
comment|// key portion length
name|out
operator|.
name|write
argument_list|(
name|keyData
argument_list|,
name|keyOffset
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
comment|// key
name|val
operator|.
name|writeUncompressedBytes
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|// value
block|}
comment|/** Returns the current length of the output file.      *      *<p>This always returns a synchronized position.  In other words,      * immediately after calling {@link SequenceFile.Reader#seek(long)} with a position      * returned by this method, {@link SequenceFile.Reader#next(Writable)} may be called.  However      * the key may be earlier in the file than key last written when this      * method was called (e.g., with block-compression, it may be the first key      * in the block that was being written when this method was called).      */
DECL|method|getLength ()
specifier|public
specifier|synchronized
name|long
name|getLength
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|out
operator|.
name|getPos
argument_list|()
return|;
block|}
block|}
comment|// class Writer
comment|/** Write key/compressed-value pairs to a sequence-format file. */
DECL|class|RecordCompressWriter
specifier|static
class|class
name|RecordCompressWriter
extends|extends
name|Writer
block|{
DECL|method|RecordCompressWriter (Configuration conf, Option... options)
name|RecordCompressWriter
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Option
modifier|...
name|options
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|conf
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
comment|/** Append a key/value pair. */
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|append (Object key, Object val)
specifier|public
specifier|synchronized
name|void
name|append
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|key
operator|.
name|getClass
argument_list|()
operator|!=
name|keyClass
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"wrong key class: "
operator|+
name|key
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" is not "
operator|+
name|keyClass
argument_list|)
throw|;
if|if
condition|(
name|val
operator|.
name|getClass
argument_list|()
operator|!=
name|valClass
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"wrong value class: "
operator|+
name|val
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" is not "
operator|+
name|valClass
argument_list|)
throw|;
name|buffer
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// Append the 'key'
name|keySerializer
operator|.
name|serialize
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|int
name|keyLength
init|=
name|buffer
operator|.
name|getLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"negative length keys not allowed: "
operator|+
name|key
argument_list|)
throw|;
comment|// Compress 'value' and append it
name|deflateFilter
operator|.
name|resetState
argument_list|()
expr_stmt|;
name|compressedValSerializer
operator|.
name|serialize
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|deflateOut
operator|.
name|flush
argument_list|()
expr_stmt|;
name|deflateFilter
operator|.
name|finish
argument_list|()
expr_stmt|;
comment|// Write the record out
name|checkAndWriteSync
argument_list|()
expr_stmt|;
comment|// sync
name|out
operator|.
name|writeInt
argument_list|(
name|buffer
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
comment|// total record length
name|out
operator|.
name|writeInt
argument_list|(
name|keyLength
argument_list|)
expr_stmt|;
comment|// key portion length
name|out
operator|.
name|write
argument_list|(
name|buffer
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|buffer
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
comment|// data
block|}
comment|/** Append a key/value pair. */
annotation|@
name|Override
DECL|method|appendRaw (byte[] keyData, int keyOffset, int keyLength, ValueBytes val)
specifier|public
specifier|synchronized
name|void
name|appendRaw
parameter_list|(
name|byte
index|[]
name|keyData
parameter_list|,
name|int
name|keyOffset
parameter_list|,
name|int
name|keyLength
parameter_list|,
name|ValueBytes
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"negative length keys not allowed: "
operator|+
name|keyLength
argument_list|)
throw|;
name|int
name|valLength
init|=
name|val
operator|.
name|getSize
argument_list|()
decl_stmt|;
name|checkAndWriteSync
argument_list|()
expr_stmt|;
comment|// sync
name|out
operator|.
name|writeInt
argument_list|(
name|keyLength
operator|+
name|valLength
argument_list|)
expr_stmt|;
comment|// total record length
name|out
operator|.
name|writeInt
argument_list|(
name|keyLength
argument_list|)
expr_stmt|;
comment|// key portion length
name|out
operator|.
name|write
argument_list|(
name|keyData
argument_list|,
name|keyOffset
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
comment|// 'key' data
name|val
operator|.
name|writeCompressedBytes
argument_list|(
name|out
argument_list|)
expr_stmt|;
comment|// 'value' data
block|}
block|}
comment|// RecordCompressionWriter
comment|/** Write compressed key/value blocks to a sequence-format file. */
DECL|class|BlockCompressWriter
specifier|static
class|class
name|BlockCompressWriter
extends|extends
name|Writer
block|{
DECL|field|noBufferedRecords
specifier|private
name|int
name|noBufferedRecords
init|=
literal|0
decl_stmt|;
DECL|field|keyLenBuffer
specifier|private
name|DataOutputBuffer
name|keyLenBuffer
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
DECL|field|keyBuffer
specifier|private
name|DataOutputBuffer
name|keyBuffer
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
DECL|field|valLenBuffer
specifier|private
name|DataOutputBuffer
name|valLenBuffer
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
DECL|field|valBuffer
specifier|private
name|DataOutputBuffer
name|valBuffer
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
DECL|field|compressionBlockSize
specifier|private
specifier|final
name|int
name|compressionBlockSize
decl_stmt|;
DECL|method|BlockCompressWriter (Configuration conf, Option... options)
name|BlockCompressWriter
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Option
modifier|...
name|options
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|conf
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|compressionBlockSize
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"io.seqfile.compress.blocksize"
argument_list|,
literal|1000000
argument_list|)
expr_stmt|;
name|keySerializer
operator|.
name|close
argument_list|()
expr_stmt|;
name|keySerializer
operator|.
name|open
argument_list|(
name|keyBuffer
argument_list|)
expr_stmt|;
name|uncompressedValSerializer
operator|.
name|close
argument_list|()
expr_stmt|;
name|uncompressedValSerializer
operator|.
name|open
argument_list|(
name|valBuffer
argument_list|)
expr_stmt|;
block|}
comment|/** Workhorse to check and write out compressed data/lengths */
specifier|private
specifier|synchronized
DECL|method|writeBuffer (DataOutputBuffer uncompressedDataBuffer)
name|void
name|writeBuffer
parameter_list|(
name|DataOutputBuffer
name|uncompressedDataBuffer
parameter_list|)
throws|throws
name|IOException
block|{
name|deflateFilter
operator|.
name|resetState
argument_list|()
expr_stmt|;
name|buffer
operator|.
name|reset
argument_list|()
expr_stmt|;
name|deflateOut
operator|.
name|write
argument_list|(
name|uncompressedDataBuffer
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|uncompressedDataBuffer
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|deflateOut
operator|.
name|flush
argument_list|()
expr_stmt|;
name|deflateFilter
operator|.
name|finish
argument_list|()
expr_stmt|;
name|WritableUtils
operator|.
name|writeVInt
argument_list|(
name|out
argument_list|,
name|buffer
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|buffer
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|buffer
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Compress and flush contents to dfs */
annotation|@
name|Override
DECL|method|sync ()
specifier|public
specifier|synchronized
name|void
name|sync
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|noBufferedRecords
operator|>
literal|0
condition|)
block|{
name|super
operator|.
name|sync
argument_list|()
expr_stmt|;
comment|// No. of records
name|WritableUtils
operator|.
name|writeVInt
argument_list|(
name|out
argument_list|,
name|noBufferedRecords
argument_list|)
expr_stmt|;
comment|// Write 'keys' and lengths
name|writeBuffer
argument_list|(
name|keyLenBuffer
argument_list|)
expr_stmt|;
name|writeBuffer
argument_list|(
name|keyBuffer
argument_list|)
expr_stmt|;
comment|// Write 'values' and lengths
name|writeBuffer
argument_list|(
name|valLenBuffer
argument_list|)
expr_stmt|;
name|writeBuffer
argument_list|(
name|valBuffer
argument_list|)
expr_stmt|;
comment|// Flush the file-stream
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
comment|// Reset internal states
name|keyLenBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
name|keyBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
name|valLenBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
name|valBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
name|noBufferedRecords
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/** Close the file. */
annotation|@
name|Override
DECL|method|close ()
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|sync
argument_list|()
expr_stmt|;
block|}
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** Append a key/value pair. */
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|append (Object key, Object val)
specifier|public
specifier|synchronized
name|void
name|append
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|key
operator|.
name|getClass
argument_list|()
operator|!=
name|keyClass
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"wrong key class: "
operator|+
name|key
operator|+
literal|" is not "
operator|+
name|keyClass
argument_list|)
throw|;
if|if
condition|(
name|val
operator|.
name|getClass
argument_list|()
operator|!=
name|valClass
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"wrong value class: "
operator|+
name|val
operator|+
literal|" is not "
operator|+
name|valClass
argument_list|)
throw|;
comment|// Save key/value into respective buffers
name|int
name|oldKeyLength
init|=
name|keyBuffer
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|keySerializer
operator|.
name|serialize
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|int
name|keyLength
init|=
name|keyBuffer
operator|.
name|getLength
argument_list|()
operator|-
name|oldKeyLength
decl_stmt|;
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"negative length keys not allowed: "
operator|+
name|key
argument_list|)
throw|;
name|WritableUtils
operator|.
name|writeVInt
argument_list|(
name|keyLenBuffer
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
name|int
name|oldValLength
init|=
name|valBuffer
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|uncompressedValSerializer
operator|.
name|serialize
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|int
name|valLength
init|=
name|valBuffer
operator|.
name|getLength
argument_list|()
operator|-
name|oldValLength
decl_stmt|;
name|WritableUtils
operator|.
name|writeVInt
argument_list|(
name|valLenBuffer
argument_list|,
name|valLength
argument_list|)
expr_stmt|;
comment|// Added another key/value pair
operator|++
name|noBufferedRecords
expr_stmt|;
comment|// Compress and flush?
name|int
name|currentBlockSize
init|=
name|keyBuffer
operator|.
name|getLength
argument_list|()
operator|+
name|valBuffer
operator|.
name|getLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentBlockSize
operator|>=
name|compressionBlockSize
condition|)
block|{
name|sync
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Append a key/value pair. */
annotation|@
name|Override
DECL|method|appendRaw (byte[] keyData, int keyOffset, int keyLength, ValueBytes val)
specifier|public
specifier|synchronized
name|void
name|appendRaw
parameter_list|(
name|byte
index|[]
name|keyData
parameter_list|,
name|int
name|keyOffset
parameter_list|,
name|int
name|keyLength
parameter_list|,
name|ValueBytes
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"negative length keys not allowed"
argument_list|)
throw|;
name|int
name|valLength
init|=
name|val
operator|.
name|getSize
argument_list|()
decl_stmt|;
comment|// Save key/value data in relevant buffers
name|WritableUtils
operator|.
name|writeVInt
argument_list|(
name|keyLenBuffer
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
name|keyBuffer
operator|.
name|write
argument_list|(
name|keyData
argument_list|,
name|keyOffset
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
name|WritableUtils
operator|.
name|writeVInt
argument_list|(
name|valLenBuffer
argument_list|,
name|valLength
argument_list|)
expr_stmt|;
name|val
operator|.
name|writeUncompressedBytes
argument_list|(
name|valBuffer
argument_list|)
expr_stmt|;
comment|// Added another key/value pair
operator|++
name|noBufferedRecords
expr_stmt|;
comment|// Compress and flush?
name|int
name|currentBlockSize
init|=
name|keyBuffer
operator|.
name|getLength
argument_list|()
operator|+
name|valBuffer
operator|.
name|getLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentBlockSize
operator|>=
name|compressionBlockSize
condition|)
block|{
name|sync
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// BlockCompressionWriter
comment|/** Get the configured buffer size */
DECL|method|getBufferSize (Configuration conf)
specifier|private
specifier|static
name|int
name|getBufferSize
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getInt
argument_list|(
literal|"io.file.buffer.size"
argument_list|,
literal|4096
argument_list|)
return|;
block|}
comment|/** Reads key/value pairs from a sequence-format file. */
DECL|class|Reader
specifier|public
specifier|static
class|class
name|Reader
implements|implements
name|java
operator|.
name|io
operator|.
name|Closeable
block|{
DECL|field|filename
specifier|private
name|String
name|filename
decl_stmt|;
DECL|field|in
specifier|private
name|FSDataInputStream
name|in
decl_stmt|;
DECL|field|outBuf
specifier|private
name|DataOutputBuffer
name|outBuf
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
DECL|field|version
specifier|private
name|byte
name|version
decl_stmt|;
DECL|field|keyClassName
specifier|private
name|String
name|keyClassName
decl_stmt|;
DECL|field|valClassName
specifier|private
name|String
name|valClassName
decl_stmt|;
DECL|field|keyClass
specifier|private
name|Class
name|keyClass
decl_stmt|;
DECL|field|valClass
specifier|private
name|Class
name|valClass
decl_stmt|;
DECL|field|codec
specifier|private
name|CompressionCodec
name|codec
init|=
literal|null
decl_stmt|;
DECL|field|metadata
specifier|private
name|Metadata
name|metadata
init|=
literal|null
decl_stmt|;
DECL|field|sync
specifier|private
name|byte
index|[]
name|sync
init|=
operator|new
name|byte
index|[
name|SYNC_HASH_SIZE
index|]
decl_stmt|;
DECL|field|syncCheck
specifier|private
name|byte
index|[]
name|syncCheck
init|=
operator|new
name|byte
index|[
name|SYNC_HASH_SIZE
index|]
decl_stmt|;
DECL|field|syncSeen
specifier|private
name|boolean
name|syncSeen
decl_stmt|;
DECL|field|headerEnd
specifier|private
name|long
name|headerEnd
decl_stmt|;
DECL|field|end
specifier|private
name|long
name|end
decl_stmt|;
DECL|field|keyLength
specifier|private
name|int
name|keyLength
decl_stmt|;
DECL|field|recordLength
specifier|private
name|int
name|recordLength
decl_stmt|;
DECL|field|decompress
specifier|private
name|boolean
name|decompress
decl_stmt|;
DECL|field|blockCompressed
specifier|private
name|boolean
name|blockCompressed
decl_stmt|;
DECL|field|conf
specifier|private
name|Configuration
name|conf
decl_stmt|;
DECL|field|noBufferedRecords
specifier|private
name|int
name|noBufferedRecords
init|=
literal|0
decl_stmt|;
DECL|field|lazyDecompress
specifier|private
name|boolean
name|lazyDecompress
init|=
literal|true
decl_stmt|;
DECL|field|valuesDecompressed
specifier|private
name|boolean
name|valuesDecompressed
init|=
literal|true
decl_stmt|;
DECL|field|noBufferedKeys
specifier|private
name|int
name|noBufferedKeys
init|=
literal|0
decl_stmt|;
DECL|field|noBufferedValues
specifier|private
name|int
name|noBufferedValues
init|=
literal|0
decl_stmt|;
DECL|field|keyLenBuffer
specifier|private
name|DataInputBuffer
name|keyLenBuffer
init|=
literal|null
decl_stmt|;
DECL|field|keyLenInFilter
specifier|private
name|CompressionInputStream
name|keyLenInFilter
init|=
literal|null
decl_stmt|;
DECL|field|keyLenIn
specifier|private
name|DataInputStream
name|keyLenIn
init|=
literal|null
decl_stmt|;
DECL|field|keyLenDecompressor
specifier|private
name|Decompressor
name|keyLenDecompressor
init|=
literal|null
decl_stmt|;
DECL|field|keyBuffer
specifier|private
name|DataInputBuffer
name|keyBuffer
init|=
literal|null
decl_stmt|;
DECL|field|keyInFilter
specifier|private
name|CompressionInputStream
name|keyInFilter
init|=
literal|null
decl_stmt|;
DECL|field|keyIn
specifier|private
name|DataInputStream
name|keyIn
init|=
literal|null
decl_stmt|;
DECL|field|keyDecompressor
specifier|private
name|Decompressor
name|keyDecompressor
init|=
literal|null
decl_stmt|;
DECL|field|valLenBuffer
specifier|private
name|DataInputBuffer
name|valLenBuffer
init|=
literal|null
decl_stmt|;
DECL|field|valLenInFilter
specifier|private
name|CompressionInputStream
name|valLenInFilter
init|=
literal|null
decl_stmt|;
DECL|field|valLenIn
specifier|private
name|DataInputStream
name|valLenIn
init|=
literal|null
decl_stmt|;
DECL|field|valLenDecompressor
specifier|private
name|Decompressor
name|valLenDecompressor
init|=
literal|null
decl_stmt|;
DECL|field|valBuffer
specifier|private
name|DataInputBuffer
name|valBuffer
init|=
literal|null
decl_stmt|;
DECL|field|valInFilter
specifier|private
name|CompressionInputStream
name|valInFilter
init|=
literal|null
decl_stmt|;
DECL|field|valIn
specifier|private
name|DataInputStream
name|valIn
init|=
literal|null
decl_stmt|;
DECL|field|valDecompressor
specifier|private
name|Decompressor
name|valDecompressor
init|=
literal|null
decl_stmt|;
DECL|field|keyDeserializer
specifier|private
name|Deserializer
name|keyDeserializer
decl_stmt|;
DECL|field|valDeserializer
specifier|private
name|Deserializer
name|valDeserializer
decl_stmt|;
comment|/**      * A tag interface for all of the Reader options      */
DECL|interface|Option
specifier|public
specifier|static
interface|interface
name|Option
block|{}
comment|/**      * Create an option to specify the path name of the sequence file.      * @param value the path to read      * @return a new option      */
DECL|method|file (Path value)
specifier|public
specifier|static
name|Option
name|file
parameter_list|(
name|Path
name|value
parameter_list|)
block|{
return|return
operator|new
name|FileOption
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**      * Create an option to specify the stream with the sequence file.      * @param value the stream to read.      * @return a new option      */
DECL|method|stream (FSDataInputStream value)
specifier|public
specifier|static
name|Option
name|stream
parameter_list|(
name|FSDataInputStream
name|value
parameter_list|)
block|{
return|return
operator|new
name|InputStreamOption
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**      * Create an option to specify the starting byte to read.      * @param value the number of bytes to skip over      * @return a new option      */
DECL|method|start (long value)
specifier|public
specifier|static
name|Option
name|start
parameter_list|(
name|long
name|value
parameter_list|)
block|{
return|return
operator|new
name|StartOption
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**      * Create an option to specify the number of bytes to read.      * @param value the number of bytes to read      * @return a new option      */
DECL|method|length (long value)
specifier|public
specifier|static
name|Option
name|length
parameter_list|(
name|long
name|value
parameter_list|)
block|{
return|return
operator|new
name|LengthOption
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**      * Create an option with the buffer size for reading the given pathname.      * @param value the number of bytes to buffer      * @return a new option      */
DECL|method|bufferSize (int value)
specifier|public
specifier|static
name|Option
name|bufferSize
parameter_list|(
name|int
name|value
parameter_list|)
block|{
return|return
operator|new
name|BufferSizeOption
argument_list|(
name|value
argument_list|)
return|;
block|}
DECL|class|FileOption
specifier|private
specifier|static
class|class
name|FileOption
extends|extends
name|Options
operator|.
name|PathOption
implements|implements
name|Option
block|{
DECL|method|FileOption (Path value)
specifier|private
name|FileOption
parameter_list|(
name|Path
name|value
parameter_list|)
block|{
name|super
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|InputStreamOption
specifier|private
specifier|static
class|class
name|InputStreamOption
extends|extends
name|Options
operator|.
name|FSDataInputStreamOption
implements|implements
name|Option
block|{
DECL|method|InputStreamOption (FSDataInputStream value)
specifier|private
name|InputStreamOption
parameter_list|(
name|FSDataInputStream
name|value
parameter_list|)
block|{
name|super
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|StartOption
specifier|private
specifier|static
class|class
name|StartOption
extends|extends
name|Options
operator|.
name|LongOption
implements|implements
name|Option
block|{
DECL|method|StartOption (long value)
specifier|private
name|StartOption
parameter_list|(
name|long
name|value
parameter_list|)
block|{
name|super
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|LengthOption
specifier|private
specifier|static
class|class
name|LengthOption
extends|extends
name|Options
operator|.
name|LongOption
implements|implements
name|Option
block|{
DECL|method|LengthOption (long value)
specifier|private
name|LengthOption
parameter_list|(
name|long
name|value
parameter_list|)
block|{
name|super
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|BufferSizeOption
specifier|private
specifier|static
class|class
name|BufferSizeOption
extends|extends
name|Options
operator|.
name|IntegerOption
implements|implements
name|Option
block|{
DECL|method|BufferSizeOption (int value)
specifier|private
name|BufferSizeOption
parameter_list|(
name|int
name|value
parameter_list|)
block|{
name|super
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
comment|// only used directly
DECL|class|OnlyHeaderOption
specifier|private
specifier|static
class|class
name|OnlyHeaderOption
extends|extends
name|Options
operator|.
name|BooleanOption
implements|implements
name|Option
block|{
DECL|method|OnlyHeaderOption ()
specifier|private
name|OnlyHeaderOption
parameter_list|()
block|{
name|super
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|Reader (Configuration conf, Option... opts)
specifier|public
name|Reader
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Option
modifier|...
name|opts
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Look up the options, these are null if not set
name|FileOption
name|fileOpt
init|=
name|Options
operator|.
name|getOption
argument_list|(
name|FileOption
operator|.
name|class
argument_list|,
name|opts
argument_list|)
decl_stmt|;
name|InputStreamOption
name|streamOpt
init|=
name|Options
operator|.
name|getOption
argument_list|(
name|InputStreamOption
operator|.
name|class
argument_list|,
name|opts
argument_list|)
decl_stmt|;
name|StartOption
name|startOpt
init|=
name|Options
operator|.
name|getOption
argument_list|(
name|StartOption
operator|.
name|class
argument_list|,
name|opts
argument_list|)
decl_stmt|;
name|LengthOption
name|lenOpt
init|=
name|Options
operator|.
name|getOption
argument_list|(
name|LengthOption
operator|.
name|class
argument_list|,
name|opts
argument_list|)
decl_stmt|;
name|BufferSizeOption
name|bufOpt
init|=
name|Options
operator|.
name|getOption
argument_list|(
name|BufferSizeOption
operator|.
name|class
argument_list|,
name|opts
argument_list|)
decl_stmt|;
name|OnlyHeaderOption
name|headerOnly
init|=
name|Options
operator|.
name|getOption
argument_list|(
name|OnlyHeaderOption
operator|.
name|class
argument_list|,
name|opts
argument_list|)
decl_stmt|;
comment|// check for consistency
if|if
condition|(
operator|(
name|fileOpt
operator|==
literal|null
operator|)
operator|==
operator|(
name|streamOpt
operator|==
literal|null
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"File or stream option must be specified"
argument_list|)
throw|;
block|}
if|if
condition|(
name|fileOpt
operator|==
literal|null
operator|&&
name|bufOpt
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"buffer size can only be set when"
operator|+
literal|" a file is specified."
argument_list|)
throw|;
block|}
comment|// figure out the real values
name|Path
name|filename
init|=
literal|null
decl_stmt|;
name|FSDataInputStream
name|file
decl_stmt|;
specifier|final
name|long
name|len
decl_stmt|;
if|if
condition|(
name|fileOpt
operator|!=
literal|null
condition|)
block|{
name|filename
operator|=
name|fileOpt
operator|.
name|getValue
argument_list|()
expr_stmt|;
name|FileSystem
name|fs
init|=
name|filename
operator|.
name|getFileSystem
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|int
name|bufSize
init|=
name|bufOpt
operator|==
literal|null
condition|?
name|getBufferSize
argument_list|(
name|conf
argument_list|)
else|:
name|bufOpt
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|len
operator|=
literal|null
operator|==
name|lenOpt
condition|?
name|fs
operator|.
name|getFileStatus
argument_list|(
name|filename
argument_list|)
operator|.
name|getLen
argument_list|()
else|:
name|lenOpt
operator|.
name|getValue
argument_list|()
expr_stmt|;
name|file
operator|=
name|openFile
argument_list|(
name|fs
argument_list|,
name|filename
argument_list|,
name|bufSize
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
literal|null
operator|==
name|lenOpt
condition|?
name|Long
operator|.
name|MAX_VALUE
else|:
name|lenOpt
operator|.
name|getValue
argument_list|()
expr_stmt|;
name|file
operator|=
name|streamOpt
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
name|long
name|start
init|=
name|startOpt
operator|==
literal|null
condition|?
literal|0
else|:
name|startOpt
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// really set up
name|initialize
argument_list|(
name|filename
argument_list|,
name|file
argument_list|,
name|start
argument_list|,
name|len
argument_list|,
name|conf
argument_list|,
name|headerOnly
operator|!=
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Construct a reader by opening a file from the given file system.      * @param fs The file system used to open the file.      * @param file The file being read.      * @param conf Configuration      * @throws IOException      * @deprecated Use Reader(Configuration, Option...) instead.      */
annotation|@
name|Deprecated
DECL|method|Reader (FileSystem fs, Path file, Configuration conf)
specifier|public
name|Reader
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|file
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|file
argument_list|(
name|file
operator|.
name|makeQualified
argument_list|(
name|fs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Construct a reader by the given input stream.      * @param in An input stream.      * @param buffersize unused      * @param start The starting position.      * @param length The length being read.      * @param conf Configuration      * @throws IOException      * @deprecated Use Reader(Configuration, Reader.Option...) instead.      */
annotation|@
name|Deprecated
DECL|method|Reader (FSDataInputStream in, int buffersize, long start, long length, Configuration conf)
specifier|public
name|Reader
parameter_list|(
name|FSDataInputStream
name|in
parameter_list|,
name|int
name|buffersize
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|length
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|conf
argument_list|,
name|stream
argument_list|(
name|in
argument_list|)
argument_list|,
name|start
argument_list|(
name|start
argument_list|)
argument_list|,
name|length
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** Common work of the constructors. */
DECL|method|initialize (Path filename, FSDataInputStream in, long start, long length, Configuration conf, boolean tempReader)
specifier|private
name|void
name|initialize
parameter_list|(
name|Path
name|filename
parameter_list|,
name|FSDataInputStream
name|in
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|length
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|boolean
name|tempReader
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|in
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"in == null"
argument_list|)
throw|;
block|}
name|this
operator|.
name|filename
operator|=
name|filename
operator|==
literal|null
condition|?
literal|"<unknown>"
else|:
name|filename
operator|.
name|toString
argument_list|()
expr_stmt|;
name|this
operator|.
name|in
operator|=
name|in
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|boolean
name|succeeded
init|=
literal|false
decl_stmt|;
try|try
block|{
name|seek
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|this
operator|.
name|end
operator|=
name|this
operator|.
name|in
operator|.
name|getPos
argument_list|()
operator|+
name|length
expr_stmt|;
comment|// if it wrapped around, use the max
if|if
condition|(
name|end
operator|<
name|length
condition|)
block|{
name|end
operator|=
name|Long
operator|.
name|MAX_VALUE
expr_stmt|;
block|}
name|init
argument_list|(
name|tempReader
argument_list|)
expr_stmt|;
name|succeeded
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|succeeded
condition|)
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|this
operator|.
name|in
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Override this method to specialize the type of      * {@link FSDataInputStream} returned.      * @param fs The file system used to open the file.      * @param file The file being read.      * @param bufferSize The buffer size used to read the file.      * @param length The length being read if it is>= 0.  Otherwise,      *               the length is not available.      * @return The opened stream.      * @throws IOException      */
DECL|method|openFile (FileSystem fs, Path file, int bufferSize, long length)
specifier|protected
name|FSDataInputStream
name|openFile
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|file
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|long
name|length
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|open
argument_list|(
name|file
argument_list|,
name|bufferSize
argument_list|)
return|;
block|}
comment|/**      * Initialize the {@link Reader}      * @param tmpReader<code>true</code> if we are constructing a temporary      *                  reader {@link SequenceFile.Sorter.cloneFileAttributes},       *                  and hence do not initialize every component;       *<code>false</code> otherwise.      * @throws IOException      */
DECL|method|init (boolean tempReader)
specifier|private
name|void
name|init
parameter_list|(
name|boolean
name|tempReader
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|versionBlock
init|=
operator|new
name|byte
index|[
name|VERSION
operator|.
name|length
index|]
decl_stmt|;
name|String
name|exceptionMsg
init|=
name|this
operator|+
literal|" not a SequenceFile"
decl_stmt|;
comment|// Try to read sequence file header.
try|try
block|{
name|in
operator|.
name|readFully
argument_list|(
name|versionBlock
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
name|exceptionMsg
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|versionBlock
index|[
literal|0
index|]
operator|!=
name|VERSION
index|[
literal|0
index|]
operator|)
operator|||
operator|(
name|versionBlock
index|[
literal|1
index|]
operator|!=
name|VERSION
index|[
literal|1
index|]
operator|)
operator|||
operator|(
name|versionBlock
index|[
literal|2
index|]
operator|!=
name|VERSION
index|[
literal|2
index|]
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|this
operator|+
literal|" not a SequenceFile"
argument_list|)
throw|;
block|}
comment|// Set 'version'
name|version
operator|=
name|versionBlock
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|version
operator|>
name|VERSION
index|[
literal|3
index|]
condition|)
block|{
throw|throw
operator|new
name|VersionMismatchException
argument_list|(
name|VERSION
index|[
literal|3
index|]
argument_list|,
name|version
argument_list|)
throw|;
block|}
if|if
condition|(
name|version
operator|<
name|BLOCK_COMPRESS_VERSION
condition|)
block|{
name|UTF8
name|className
init|=
operator|new
name|UTF8
argument_list|()
decl_stmt|;
name|className
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|keyClassName
operator|=
name|className
operator|.
name|toStringChecked
argument_list|()
expr_stmt|;
comment|// key class name
name|className
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|valClassName
operator|=
name|className
operator|.
name|toStringChecked
argument_list|()
expr_stmt|;
comment|// val class name
block|}
else|else
block|{
name|keyClassName
operator|=
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|valClassName
operator|=
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|version
operator|>
literal|2
condition|)
block|{
comment|// if version> 2
name|this
operator|.
name|decompress
operator|=
name|in
operator|.
name|readBoolean
argument_list|()
expr_stmt|;
comment|// is compressed?
block|}
else|else
block|{
name|decompress
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|version
operator|>=
name|BLOCK_COMPRESS_VERSION
condition|)
block|{
comment|// if version>= 4
name|this
operator|.
name|blockCompressed
operator|=
name|in
operator|.
name|readBoolean
argument_list|()
expr_stmt|;
comment|// is block-compressed?
block|}
else|else
block|{
name|blockCompressed
operator|=
literal|false
expr_stmt|;
block|}
comment|// if version>= 5
comment|// setup the compression codec
if|if
condition|(
name|decompress
condition|)
block|{
if|if
condition|(
name|version
operator|>=
name|CUSTOM_COMPRESS_VERSION
condition|)
block|{
name|String
name|codecClassname
init|=
name|Text
operator|.
name|readString
argument_list|(
name|in
argument_list|)
decl_stmt|;
try|try
block|{
name|Class
argument_list|<
name|?
extends|extends
name|CompressionCodec
argument_list|>
name|codecClass
init|=
name|conf
operator|.
name|getClassByName
argument_list|(
name|codecClassname
argument_list|)
operator|.
name|asSubclass
argument_list|(
name|CompressionCodec
operator|.
name|class
argument_list|)
decl_stmt|;
name|this
operator|.
name|codec
operator|=
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|codecClass
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|cnfe
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown codec: "
operator|+
name|codecClassname
argument_list|,
name|cnfe
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|codec
operator|=
operator|new
name|DefaultCodec
argument_list|()
expr_stmt|;
operator|(
operator|(
name|Configurable
operator|)
name|codec
operator|)
operator|.
name|setConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|metadata
operator|=
operator|new
name|Metadata
argument_list|()
expr_stmt|;
if|if
condition|(
name|version
operator|>=
name|VERSION_WITH_METADATA
condition|)
block|{
comment|// if version>= 6
name|this
operator|.
name|metadata
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|version
operator|>
literal|1
condition|)
block|{
comment|// if version> 1
name|in
operator|.
name|readFully
argument_list|(
name|sync
argument_list|)
expr_stmt|;
comment|// read sync bytes
name|headerEnd
operator|=
name|in
operator|.
name|getPos
argument_list|()
expr_stmt|;
comment|// record end of header
block|}
comment|// Initialize... *not* if this we are constructing a temporary Reader
if|if
condition|(
operator|!
name|tempReader
condition|)
block|{
name|valBuffer
operator|=
operator|new
name|DataInputBuffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|decompress
condition|)
block|{
name|valDecompressor
operator|=
name|CodecPool
operator|.
name|getDecompressor
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|valInFilter
operator|=
name|codec
operator|.
name|createInputStream
argument_list|(
name|valBuffer
argument_list|,
name|valDecompressor
argument_list|)
expr_stmt|;
name|valIn
operator|=
operator|new
name|DataInputStream
argument_list|(
name|valInFilter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|valIn
operator|=
name|valBuffer
expr_stmt|;
block|}
if|if
condition|(
name|blockCompressed
condition|)
block|{
name|keyLenBuffer
operator|=
operator|new
name|DataInputBuffer
argument_list|()
expr_stmt|;
name|keyBuffer
operator|=
operator|new
name|DataInputBuffer
argument_list|()
expr_stmt|;
name|valLenBuffer
operator|=
operator|new
name|DataInputBuffer
argument_list|()
expr_stmt|;
name|keyLenDecompressor
operator|=
name|CodecPool
operator|.
name|getDecompressor
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|keyLenInFilter
operator|=
name|codec
operator|.
name|createInputStream
argument_list|(
name|keyLenBuffer
argument_list|,
name|keyLenDecompressor
argument_list|)
expr_stmt|;
name|keyLenIn
operator|=
operator|new
name|DataInputStream
argument_list|(
name|keyLenInFilter
argument_list|)
expr_stmt|;
name|keyDecompressor
operator|=
name|CodecPool
operator|.
name|getDecompressor
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|keyInFilter
operator|=
name|codec
operator|.
name|createInputStream
argument_list|(
name|keyBuffer
argument_list|,
name|keyDecompressor
argument_list|)
expr_stmt|;
name|keyIn
operator|=
operator|new
name|DataInputStream
argument_list|(
name|keyInFilter
argument_list|)
expr_stmt|;
name|valLenDecompressor
operator|=
name|CodecPool
operator|.
name|getDecompressor
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|valLenInFilter
operator|=
name|codec
operator|.
name|createInputStream
argument_list|(
name|valLenBuffer
argument_list|,
name|valLenDecompressor
argument_list|)
expr_stmt|;
name|valLenIn
operator|=
operator|new
name|DataInputStream
argument_list|(
name|valLenInFilter
argument_list|)
expr_stmt|;
block|}
name|SerializationFactory
name|serializationFactory
init|=
operator|new
name|SerializationFactory
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|this
operator|.
name|keyDeserializer
operator|=
name|getDeserializer
argument_list|(
name|serializationFactory
argument_list|,
name|getKeyClass
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|keyDeserializer
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not find a deserializer for the Key class: '"
operator|+
name|getKeyClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"'. "
operator|+
literal|"Please ensure that the configuration '"
operator|+
name|CommonConfigurationKeys
operator|.
name|IO_SERIALIZATIONS_KEY
operator|+
literal|"' is "
operator|+
literal|"properly configured, if you're using "
operator|+
literal|"custom serialization."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|blockCompressed
condition|)
block|{
name|this
operator|.
name|keyDeserializer
operator|.
name|open
argument_list|(
name|valBuffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|keyDeserializer
operator|.
name|open
argument_list|(
name|keyIn
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|valDeserializer
operator|=
name|getDeserializer
argument_list|(
name|serializationFactory
argument_list|,
name|getValueClass
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|valDeserializer
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not find a deserializer for the Value class: '"
operator|+
name|getValueClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"'. "
operator|+
literal|"Please ensure that the configuration '"
operator|+
name|CommonConfigurationKeys
operator|.
name|IO_SERIALIZATIONS_KEY
operator|+
literal|"' is "
operator|+
literal|"properly configured, if you're using "
operator|+
literal|"custom serialization."
argument_list|)
throw|;
block|}
name|this
operator|.
name|valDeserializer
operator|.
name|open
argument_list|(
name|valIn
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getDeserializer (SerializationFactory sf, Class c)
specifier|private
name|Deserializer
name|getDeserializer
parameter_list|(
name|SerializationFactory
name|sf
parameter_list|,
name|Class
name|c
parameter_list|)
block|{
return|return
name|sf
operator|.
name|getDeserializer
argument_list|(
name|c
argument_list|)
return|;
block|}
comment|/** Close the file. */
annotation|@
name|Override
DECL|method|close ()
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Return the decompressors to the pool
name|CodecPool
operator|.
name|returnDecompressor
argument_list|(
name|keyLenDecompressor
argument_list|)
expr_stmt|;
name|CodecPool
operator|.
name|returnDecompressor
argument_list|(
name|keyDecompressor
argument_list|)
expr_stmt|;
name|CodecPool
operator|.
name|returnDecompressor
argument_list|(
name|valLenDecompressor
argument_list|)
expr_stmt|;
name|CodecPool
operator|.
name|returnDecompressor
argument_list|(
name|valDecompressor
argument_list|)
expr_stmt|;
name|keyLenDecompressor
operator|=
name|keyDecompressor
operator|=
literal|null
expr_stmt|;
name|valLenDecompressor
operator|=
name|valDecompressor
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|keyDeserializer
operator|!=
literal|null
condition|)
block|{
name|keyDeserializer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|valDeserializer
operator|!=
literal|null
condition|)
block|{
name|valDeserializer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Close the input-stream
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** Returns the name of the key class. */
DECL|method|getKeyClassName ()
specifier|public
name|String
name|getKeyClassName
parameter_list|()
block|{
return|return
name|keyClassName
return|;
block|}
comment|/** Returns the class of keys in this file. */
DECL|method|getKeyClass ()
specifier|public
specifier|synchronized
name|Class
argument_list|<
name|?
argument_list|>
name|getKeyClass
parameter_list|()
block|{
if|if
condition|(
literal|null
operator|==
name|keyClass
condition|)
block|{
try|try
block|{
name|keyClass
operator|=
name|WritableName
operator|.
name|getClass
argument_list|(
name|getKeyClassName
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|keyClass
return|;
block|}
comment|/** Returns the name of the value class. */
DECL|method|getValueClassName ()
specifier|public
name|String
name|getValueClassName
parameter_list|()
block|{
return|return
name|valClassName
return|;
block|}
comment|/** Returns the class of values in this file. */
DECL|method|getValueClass ()
specifier|public
specifier|synchronized
name|Class
argument_list|<
name|?
argument_list|>
name|getValueClass
parameter_list|()
block|{
if|if
condition|(
literal|null
operator|==
name|valClass
condition|)
block|{
try|try
block|{
name|valClass
operator|=
name|WritableName
operator|.
name|getClass
argument_list|(
name|getValueClassName
argument_list|()
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|valClass
return|;
block|}
comment|/** Returns true if values are compressed. */
DECL|method|isCompressed ()
specifier|public
name|boolean
name|isCompressed
parameter_list|()
block|{
return|return
name|decompress
return|;
block|}
comment|/** Returns true if records are block-compressed. */
DECL|method|isBlockCompressed ()
specifier|public
name|boolean
name|isBlockCompressed
parameter_list|()
block|{
return|return
name|blockCompressed
return|;
block|}
comment|/** Returns the compression codec of data in this file. */
DECL|method|getCompressionCodec ()
specifier|public
name|CompressionCodec
name|getCompressionCodec
parameter_list|()
block|{
return|return
name|codec
return|;
block|}
DECL|method|getSync ()
specifier|private
name|byte
index|[]
name|getSync
parameter_list|()
block|{
return|return
name|sync
return|;
block|}
DECL|method|getVersion ()
specifier|private
name|byte
name|getVersion
parameter_list|()
block|{
return|return
name|version
return|;
block|}
comment|/**      * Get the compression type for this file.      * @return the compression type      */
DECL|method|getCompressionType ()
specifier|public
name|CompressionType
name|getCompressionType
parameter_list|()
block|{
if|if
condition|(
name|decompress
condition|)
block|{
return|return
name|blockCompressed
condition|?
name|CompressionType
operator|.
name|BLOCK
else|:
name|CompressionType
operator|.
name|RECORD
return|;
block|}
else|else
block|{
return|return
name|CompressionType
operator|.
name|NONE
return|;
block|}
block|}
comment|/** Returns the metadata object of the file */
DECL|method|getMetadata ()
specifier|public
name|Metadata
name|getMetadata
parameter_list|()
block|{
return|return
name|this
operator|.
name|metadata
return|;
block|}
comment|/** Returns the configuration used for this file. */
DECL|method|getConf ()
name|Configuration
name|getConf
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
comment|/** Read a compressed buffer */
DECL|method|readBuffer (DataInputBuffer buffer, CompressionInputStream filter)
specifier|private
specifier|synchronized
name|void
name|readBuffer
parameter_list|(
name|DataInputBuffer
name|buffer
parameter_list|,
name|CompressionInputStream
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Read data into a temporary buffer
name|DataOutputBuffer
name|dataBuffer
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|dataBufferLength
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|dataBuffer
operator|.
name|write
argument_list|(
name|in
argument_list|,
name|dataBufferLength
argument_list|)
expr_stmt|;
comment|// Set up 'buffer' connected to the input-stream
name|buffer
operator|.
name|reset
argument_list|(
name|dataBuffer
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|dataBuffer
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|dataBuffer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|// Reset the codec
name|filter
operator|.
name|resetState
argument_list|()
expr_stmt|;
block|}
comment|/** Read the next 'compressed' block */
DECL|method|readBlock ()
specifier|private
specifier|synchronized
name|void
name|readBlock
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Check if we need to throw away a whole block of
comment|// 'values' due to 'lazy decompression'
if|if
condition|(
name|lazyDecompress
operator|&&
operator|!
name|valuesDecompressed
condition|)
block|{
name|in
operator|.
name|seek
argument_list|(
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
operator|+
name|in
operator|.
name|getPos
argument_list|()
argument_list|)
expr_stmt|;
name|in
operator|.
name|seek
argument_list|(
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
operator|+
name|in
operator|.
name|getPos
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Reset internal states
name|noBufferedKeys
operator|=
literal|0
expr_stmt|;
name|noBufferedValues
operator|=
literal|0
expr_stmt|;
name|noBufferedRecords
operator|=
literal|0
expr_stmt|;
name|valuesDecompressed
operator|=
literal|false
expr_stmt|;
comment|//Process sync
if|if
condition|(
name|sync
operator|!=
literal|null
condition|)
block|{
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|syncCheck
argument_list|)
expr_stmt|;
comment|// read syncCheck
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|sync
argument_list|,
name|syncCheck
argument_list|)
condition|)
comment|// check it
throw|throw
operator|new
name|IOException
argument_list|(
literal|"File is corrupt!"
argument_list|)
throw|;
block|}
name|syncSeen
operator|=
literal|true
expr_stmt|;
comment|// Read number of records in this block
name|noBufferedRecords
operator|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
expr_stmt|;
comment|// Read key lengths and keys
name|readBuffer
argument_list|(
name|keyLenBuffer
argument_list|,
name|keyLenInFilter
argument_list|)
expr_stmt|;
name|readBuffer
argument_list|(
name|keyBuffer
argument_list|,
name|keyInFilter
argument_list|)
expr_stmt|;
name|noBufferedKeys
operator|=
name|noBufferedRecords
expr_stmt|;
comment|// Read value lengths and values
if|if
condition|(
operator|!
name|lazyDecompress
condition|)
block|{
name|readBuffer
argument_list|(
name|valLenBuffer
argument_list|,
name|valLenInFilter
argument_list|)
expr_stmt|;
name|readBuffer
argument_list|(
name|valBuffer
argument_list|,
name|valInFilter
argument_list|)
expr_stmt|;
name|noBufferedValues
operator|=
name|noBufferedRecords
expr_stmt|;
name|valuesDecompressed
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/**       * Position valLenIn/valIn to the 'value'       * corresponding to the 'current' key       */
DECL|method|seekToCurrentValue ()
specifier|private
specifier|synchronized
name|void
name|seekToCurrentValue
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|blockCompressed
condition|)
block|{
if|if
condition|(
name|decompress
condition|)
block|{
name|valInFilter
operator|.
name|resetState
argument_list|()
expr_stmt|;
block|}
name|valBuffer
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Check if this is the first value in the 'block' to be read
if|if
condition|(
name|lazyDecompress
operator|&&
operator|!
name|valuesDecompressed
condition|)
block|{
comment|// Read the value lengths and values
name|readBuffer
argument_list|(
name|valLenBuffer
argument_list|,
name|valLenInFilter
argument_list|)
expr_stmt|;
name|readBuffer
argument_list|(
name|valBuffer
argument_list|,
name|valInFilter
argument_list|)
expr_stmt|;
name|noBufferedValues
operator|=
name|noBufferedRecords
expr_stmt|;
name|valuesDecompressed
operator|=
literal|true
expr_stmt|;
block|}
comment|// Calculate the no. of bytes to skip
comment|// Note: 'current' key has already been read!
name|int
name|skipValBytes
init|=
literal|0
decl_stmt|;
name|int
name|currentKey
init|=
name|noBufferedKeys
operator|+
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|noBufferedValues
init|;
name|i
operator|>
name|currentKey
condition|;
operator|--
name|i
control|)
block|{
name|skipValBytes
operator|+=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|valLenIn
argument_list|)
expr_stmt|;
operator|--
name|noBufferedValues
expr_stmt|;
block|}
comment|// Skip to the 'val' corresponding to 'current' key
if|if
condition|(
name|skipValBytes
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|valIn
operator|.
name|skipBytes
argument_list|(
name|skipValBytes
argument_list|)
operator|!=
name|skipValBytes
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to seek to "
operator|+
name|currentKey
operator|+
literal|"(th) value!"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**      * Get the 'value' corresponding to the last read 'key'.      * @param val : The 'value' to be read.      * @throws IOException      */
DECL|method|getCurrentValue (Writable val)
specifier|public
specifier|synchronized
name|void
name|getCurrentValue
parameter_list|(
name|Writable
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|val
operator|instanceof
name|Configurable
condition|)
block|{
operator|(
operator|(
name|Configurable
operator|)
name|val
operator|)
operator|.
name|setConf
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
block|}
comment|// Position stream to 'current' value
name|seekToCurrentValue
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|blockCompressed
condition|)
block|{
name|val
operator|.
name|readFields
argument_list|(
name|valIn
argument_list|)
expr_stmt|;
if|if
condition|(
name|valIn
operator|.
name|read
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"available bytes: "
operator|+
name|valIn
operator|.
name|available
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|val
operator|+
literal|" read "
operator|+
operator|(
name|valBuffer
operator|.
name|getPosition
argument_list|()
operator|-
name|keyLength
operator|)
operator|+
literal|" bytes, should read "
operator|+
operator|(
name|valBuffer
operator|.
name|getLength
argument_list|()
operator|-
name|keyLength
operator|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// Get the value
name|int
name|valLength
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|valLenIn
argument_list|)
decl_stmt|;
name|val
operator|.
name|readFields
argument_list|(
name|valIn
argument_list|)
expr_stmt|;
comment|// Read another compressed 'value'
operator|--
name|noBufferedValues
expr_stmt|;
comment|// Sanity check
if|if
condition|(
operator|(
name|valLength
operator|<
literal|0
operator|)
operator|&&
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|val
operator|+
literal|" is a zero-length value"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Get the 'value' corresponding to the last read 'key'.      * @param val : The 'value' to be read.      * @throws IOException      */
DECL|method|getCurrentValue (Object val)
specifier|public
specifier|synchronized
name|Object
name|getCurrentValue
parameter_list|(
name|Object
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|val
operator|instanceof
name|Configurable
condition|)
block|{
operator|(
operator|(
name|Configurable
operator|)
name|val
operator|)
operator|.
name|setConf
argument_list|(
name|this
operator|.
name|conf
argument_list|)
expr_stmt|;
block|}
comment|// Position stream to 'current' value
name|seekToCurrentValue
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|blockCompressed
condition|)
block|{
name|val
operator|=
name|deserializeValue
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|valIn
operator|.
name|read
argument_list|()
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"available bytes: "
operator|+
name|valIn
operator|.
name|available
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|val
operator|+
literal|" read "
operator|+
operator|(
name|valBuffer
operator|.
name|getPosition
argument_list|()
operator|-
name|keyLength
operator|)
operator|+
literal|" bytes, should read "
operator|+
operator|(
name|valBuffer
operator|.
name|getLength
argument_list|()
operator|-
name|keyLength
operator|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// Get the value
name|int
name|valLength
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|valLenIn
argument_list|)
decl_stmt|;
name|val
operator|=
name|deserializeValue
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|// Read another compressed 'value'
operator|--
name|noBufferedValues
expr_stmt|;
comment|// Sanity check
if|if
condition|(
operator|(
name|valLength
operator|<
literal|0
operator|)
operator|&&
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|val
operator|+
literal|" is a zero-length value"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|val
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|deserializeValue (Object val)
specifier|private
name|Object
name|deserializeValue
parameter_list|(
name|Object
name|val
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|valDeserializer
operator|.
name|deserialize
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|/** Read the next key in the file into<code>key</code>, skipping its      * value.  True if another entry exists, and false at end of file. */
DECL|method|next (Writable key)
specifier|public
specifier|synchronized
name|boolean
name|next
parameter_list|(
name|Writable
name|key
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|key
operator|.
name|getClass
argument_list|()
operator|!=
name|getKeyClass
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"wrong key class: "
operator|+
name|key
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" is not "
operator|+
name|keyClass
argument_list|)
throw|;
if|if
condition|(
operator|!
name|blockCompressed
condition|)
block|{
name|outBuf
operator|.
name|reset
argument_list|()
expr_stmt|;
name|keyLength
operator|=
name|next
argument_list|(
name|outBuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
return|return
literal|false
return|;
name|valBuffer
operator|.
name|reset
argument_list|(
name|outBuf
operator|.
name|getData
argument_list|()
argument_list|,
name|outBuf
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|key
operator|.
name|readFields
argument_list|(
name|valBuffer
argument_list|)
expr_stmt|;
name|valBuffer
operator|.
name|mark
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|valBuffer
operator|.
name|getPosition
argument_list|()
operator|!=
name|keyLength
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
name|key
operator|+
literal|" read "
operator|+
name|valBuffer
operator|.
name|getPosition
argument_list|()
operator|+
literal|" bytes, should read "
operator|+
name|keyLength
argument_list|)
throw|;
block|}
else|else
block|{
comment|//Reset syncSeen
name|syncSeen
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|noBufferedKeys
operator|==
literal|0
condition|)
block|{
try|try
block|{
name|readBlock
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|eof
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
name|int
name|keyLength
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|keyLenIn
argument_list|)
decl_stmt|;
comment|// Sanity check
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|//Read another compressed 'key'
name|key
operator|.
name|readFields
argument_list|(
name|keyIn
argument_list|)
expr_stmt|;
operator|--
name|noBufferedKeys
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/** Read the next key/value pair in the file into<code>key</code> and      *<code>val</code>.  Returns true if such a pair exists and false when at      * end of file */
DECL|method|next (Writable key, Writable val)
specifier|public
specifier|synchronized
name|boolean
name|next
parameter_list|(
name|Writable
name|key
parameter_list|,
name|Writable
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|val
operator|.
name|getClass
argument_list|()
operator|!=
name|getValueClass
argument_list|()
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"wrong value class: "
operator|+
name|val
operator|+
literal|" is not "
operator|+
name|valClass
argument_list|)
throw|;
name|boolean
name|more
init|=
name|next
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|more
condition|)
block|{
name|getCurrentValue
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|more
return|;
block|}
comment|/**      * Read and return the next record length, potentially skipping over       * a sync block.      * @return the length of the next record or -1 if there is no next record      * @throws IOException      */
DECL|method|readRecordLength ()
specifier|private
specifier|synchronized
name|int
name|readRecordLength
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|in
operator|.
name|getPos
argument_list|()
operator|>=
name|end
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|int
name|length
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|version
operator|>
literal|1
operator|&&
name|sync
operator|!=
literal|null
operator|&&
name|length
operator|==
name|SYNC_ESCAPE
condition|)
block|{
comment|// process a sync entry
name|in
operator|.
name|readFully
argument_list|(
name|syncCheck
argument_list|)
expr_stmt|;
comment|// read syncCheck
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|sync
argument_list|,
name|syncCheck
argument_list|)
condition|)
comment|// check it
throw|throw
operator|new
name|IOException
argument_list|(
literal|"File is corrupt!"
argument_list|)
throw|;
name|syncSeen
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|getPos
argument_list|()
operator|>=
name|end
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|length
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
comment|// re-read length
block|}
else|else
block|{
name|syncSeen
operator|=
literal|false
expr_stmt|;
block|}
return|return
name|length
return|;
block|}
comment|/** Read the next key/value pair in the file into<code>buffer</code>.      * Returns the length of the key read, or -1 if at end of file.  The length      * of the value may be computed by calling buffer.getLength() before and      * after calls to this method. */
comment|/** @deprecated Call {@link #nextRaw(DataOutputBuffer,SequenceFile.ValueBytes)}. */
annotation|@
name|Deprecated
DECL|method|next (DataOutputBuffer buffer)
specifier|synchronized
name|int
name|next
parameter_list|(
name|DataOutputBuffer
name|buffer
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Unsupported for block-compressed sequence files
if|if
condition|(
name|blockCompressed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unsupported call for block-compressed"
operator|+
literal|" SequenceFiles - use SequenceFile.Reader.next(DataOutputStream, ValueBytes)"
argument_list|)
throw|;
block|}
try|try
block|{
name|int
name|length
init|=
name|readRecordLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|length
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|int
name|keyLength
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|buffer
operator|.
name|write
argument_list|(
name|in
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|keyLength
return|;
block|}
catch|catch
parameter_list|(
name|ChecksumException
name|e
parameter_list|)
block|{
comment|// checksum failure
name|handleChecksumException
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
name|next
argument_list|(
name|buffer
argument_list|)
return|;
block|}
block|}
DECL|method|createValueBytes ()
specifier|public
name|ValueBytes
name|createValueBytes
parameter_list|()
block|{
name|ValueBytes
name|val
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|decompress
operator|||
name|blockCompressed
condition|)
block|{
name|val
operator|=
operator|new
name|UncompressedBytes
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
operator|new
name|CompressedBytes
argument_list|(
name|codec
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
comment|/**      * Read 'raw' records.      * @param key - The buffer into which the key is read      * @param val - The 'raw' value      * @return Returns the total record length or -1 for end of file      * @throws IOException      */
DECL|method|nextRaw (DataOutputBuffer key, ValueBytes val)
specifier|public
specifier|synchronized
name|int
name|nextRaw
parameter_list|(
name|DataOutputBuffer
name|key
parameter_list|,
name|ValueBytes
name|val
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|blockCompressed
condition|)
block|{
name|int
name|length
init|=
name|readRecordLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|length
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|int
name|keyLength
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|int
name|valLength
init|=
name|length
operator|-
name|keyLength
decl_stmt|;
name|key
operator|.
name|write
argument_list|(
name|in
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|decompress
condition|)
block|{
name|CompressedBytes
name|value
init|=
operator|(
name|CompressedBytes
operator|)
name|val
decl_stmt|;
name|value
operator|.
name|reset
argument_list|(
name|in
argument_list|,
name|valLength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UncompressedBytes
name|value
init|=
operator|(
name|UncompressedBytes
operator|)
name|val
decl_stmt|;
name|value
operator|.
name|reset
argument_list|(
name|in
argument_list|,
name|valLength
argument_list|)
expr_stmt|;
block|}
return|return
name|length
return|;
block|}
else|else
block|{
comment|//Reset syncSeen
name|syncSeen
operator|=
literal|false
expr_stmt|;
comment|// Read 'key'
if|if
condition|(
name|noBufferedKeys
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|in
operator|.
name|getPos
argument_list|()
operator|>=
name|end
condition|)
return|return
operator|-
literal|1
return|;
try|try
block|{
name|readBlock
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|eof
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
name|int
name|keyLength
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|keyLenIn
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"zero length key found!"
argument_list|)
throw|;
block|}
name|key
operator|.
name|write
argument_list|(
name|keyIn
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
operator|--
name|noBufferedKeys
expr_stmt|;
comment|// Read raw 'value'
name|seekToCurrentValue
argument_list|()
expr_stmt|;
name|int
name|valLength
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|valLenIn
argument_list|)
decl_stmt|;
name|UncompressedBytes
name|rawValue
init|=
operator|(
name|UncompressedBytes
operator|)
name|val
decl_stmt|;
name|rawValue
operator|.
name|reset
argument_list|(
name|valIn
argument_list|,
name|valLength
argument_list|)
expr_stmt|;
operator|--
name|noBufferedValues
expr_stmt|;
return|return
operator|(
name|keyLength
operator|+
name|valLength
operator|)
return|;
block|}
block|}
comment|/**      * Read 'raw' keys.      * @param key - The buffer into which the key is read      * @return Returns the key length or -1 for end of file      * @throws IOException      */
DECL|method|nextRawKey (DataOutputBuffer key)
specifier|public
specifier|synchronized
name|int
name|nextRawKey
parameter_list|(
name|DataOutputBuffer
name|key
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|blockCompressed
condition|)
block|{
name|recordLength
operator|=
name|readRecordLength
argument_list|()
expr_stmt|;
if|if
condition|(
name|recordLength
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|keyLength
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
name|key
operator|.
name|write
argument_list|(
name|in
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
return|return
name|keyLength
return|;
block|}
else|else
block|{
comment|//Reset syncSeen
name|syncSeen
operator|=
literal|false
expr_stmt|;
comment|// Read 'key'
if|if
condition|(
name|noBufferedKeys
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|in
operator|.
name|getPos
argument_list|()
operator|>=
name|end
condition|)
return|return
operator|-
literal|1
return|;
try|try
block|{
name|readBlock
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|eof
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
name|int
name|keyLength
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|keyLenIn
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"zero length key found!"
argument_list|)
throw|;
block|}
name|key
operator|.
name|write
argument_list|(
name|keyIn
argument_list|,
name|keyLength
argument_list|)
expr_stmt|;
operator|--
name|noBufferedKeys
expr_stmt|;
return|return
name|keyLength
return|;
block|}
block|}
comment|/** Read the next key in the file, skipping its      * value.  Return null at end of file. */
DECL|method|next (Object key)
specifier|public
specifier|synchronized
name|Object
name|next
parameter_list|(
name|Object
name|key
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|key
operator|!=
literal|null
operator|&&
name|key
operator|.
name|getClass
argument_list|()
operator|!=
name|getKeyClass
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"wrong key class: "
operator|+
name|key
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|" is not "
operator|+
name|keyClass
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|blockCompressed
condition|)
block|{
name|outBuf
operator|.
name|reset
argument_list|()
expr_stmt|;
name|keyLength
operator|=
name|next
argument_list|(
name|outBuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
return|return
literal|null
return|;
name|valBuffer
operator|.
name|reset
argument_list|(
name|outBuf
operator|.
name|getData
argument_list|()
argument_list|,
name|outBuf
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
name|key
operator|=
name|deserializeKey
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|valBuffer
operator|.
name|mark
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|valBuffer
operator|.
name|getPosition
argument_list|()
operator|!=
name|keyLength
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
name|key
operator|+
literal|" read "
operator|+
name|valBuffer
operator|.
name|getPosition
argument_list|()
operator|+
literal|" bytes, should read "
operator|+
name|keyLength
argument_list|)
throw|;
block|}
else|else
block|{
comment|//Reset syncSeen
name|syncSeen
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|noBufferedKeys
operator|==
literal|0
condition|)
block|{
try|try
block|{
name|readBlock
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EOFException
name|eof
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
name|int
name|keyLength
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|keyLenIn
argument_list|)
decl_stmt|;
comment|// Sanity check
if|if
condition|(
name|keyLength
operator|<
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|//Read another compressed 'key'
name|key
operator|=
name|deserializeKey
argument_list|(
name|key
argument_list|)
expr_stmt|;
operator|--
name|noBufferedKeys
expr_stmt|;
block|}
return|return
name|key
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|deserializeKey (Object key)
specifier|private
name|Object
name|deserializeKey
parameter_list|(
name|Object
name|key
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|keyDeserializer
operator|.
name|deserialize
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/**      * Read 'raw' values.      * @param val - The 'raw' value      * @return Returns the value length      * @throws IOException      */
DECL|method|nextRawValue (ValueBytes val)
specifier|public
specifier|synchronized
name|int
name|nextRawValue
parameter_list|(
name|ValueBytes
name|val
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Position stream to current value
name|seekToCurrentValue
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|blockCompressed
condition|)
block|{
name|int
name|valLength
init|=
name|recordLength
operator|-
name|keyLength
decl_stmt|;
if|if
condition|(
name|decompress
condition|)
block|{
name|CompressedBytes
name|value
init|=
operator|(
name|CompressedBytes
operator|)
name|val
decl_stmt|;
name|value
operator|.
name|reset
argument_list|(
name|in
argument_list|,
name|valLength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UncompressedBytes
name|value
init|=
operator|(
name|UncompressedBytes
operator|)
name|val
decl_stmt|;
name|value
operator|.
name|reset
argument_list|(
name|in
argument_list|,
name|valLength
argument_list|)
expr_stmt|;
block|}
return|return
name|valLength
return|;
block|}
else|else
block|{
name|int
name|valLength
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|valLenIn
argument_list|)
decl_stmt|;
name|UncompressedBytes
name|rawValue
init|=
operator|(
name|UncompressedBytes
operator|)
name|val
decl_stmt|;
name|rawValue
operator|.
name|reset
argument_list|(
name|valIn
argument_list|,
name|valLength
argument_list|)
expr_stmt|;
operator|--
name|noBufferedValues
expr_stmt|;
return|return
name|valLength
return|;
block|}
block|}
DECL|method|handleChecksumException (ChecksumException e)
specifier|private
name|void
name|handleChecksumException
parameter_list|(
name|ChecksumException
name|e
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|conf
operator|.
name|getBoolean
argument_list|(
literal|"io.skip.checksum.errors"
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Bad checksum at "
operator|+
name|getPosition
argument_list|()
operator|+
literal|". Skipping entries."
argument_list|)
expr_stmt|;
name|sync
argument_list|(
name|getPosition
argument_list|()
operator|+
name|this
operator|.
name|conf
operator|.
name|getInt
argument_list|(
literal|"io.bytes.per.checksum"
argument_list|,
literal|512
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
comment|/** disables sync. often invoked for tmp files */
DECL|method|ignoreSync ()
specifier|synchronized
name|void
name|ignoreSync
parameter_list|()
block|{
name|sync
operator|=
literal|null
expr_stmt|;
block|}
comment|/** Set the current byte position in the input file.      *      *<p>The position passed must be a position returned by {@link      * SequenceFile.Writer#getLength()} when writing this file.  To seek to an arbitrary      * position, use {@link SequenceFile.Reader#sync(long)}.      */
DECL|method|seek (long position)
specifier|public
specifier|synchronized
name|void
name|seek
parameter_list|(
name|long
name|position
parameter_list|)
throws|throws
name|IOException
block|{
name|in
operator|.
name|seek
argument_list|(
name|position
argument_list|)
expr_stmt|;
if|if
condition|(
name|blockCompressed
condition|)
block|{
comment|// trigger block read
name|noBufferedKeys
operator|=
literal|0
expr_stmt|;
name|valuesDecompressed
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/** Seek to the next sync mark past a given position.*/
DECL|method|sync (long position)
specifier|public
specifier|synchronized
name|void
name|sync
parameter_list|(
name|long
name|position
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|position
operator|+
name|SYNC_SIZE
operator|>=
name|end
condition|)
block|{
name|seek
argument_list|(
name|end
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|position
operator|<
name|headerEnd
condition|)
block|{
comment|// seek directly to first record
name|in
operator|.
name|seek
argument_list|(
name|headerEnd
argument_list|)
expr_stmt|;
comment|// note the sync marker "seen" in the header
name|syncSeen
operator|=
literal|true
expr_stmt|;
return|return;
block|}
try|try
block|{
name|seek
argument_list|(
name|position
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|// skip escape
name|in
operator|.
name|readFully
argument_list|(
name|syncCheck
argument_list|)
expr_stmt|;
name|int
name|syncLen
init|=
name|sync
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|in
operator|.
name|getPos
argument_list|()
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|j
operator|<
name|syncLen
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|sync
index|[
name|j
index|]
operator|!=
name|syncCheck
index|[
operator|(
name|i
operator|+
name|j
operator|)
operator|%
name|syncLen
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|syncLen
condition|)
block|{
name|in
operator|.
name|seek
argument_list|(
name|in
operator|.
name|getPos
argument_list|()
operator|-
name|SYNC_SIZE
argument_list|)
expr_stmt|;
comment|// position before sync
return|return;
block|}
name|syncCheck
index|[
name|i
operator|%
name|syncLen
index|]
operator|=
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ChecksumException
name|e
parameter_list|)
block|{
comment|// checksum failure
name|handleChecksumException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Returns true iff the previous call to next passed a sync mark.*/
DECL|method|syncSeen ()
specifier|public
specifier|synchronized
name|boolean
name|syncSeen
parameter_list|()
block|{
return|return
name|syncSeen
return|;
block|}
comment|/** Return the current byte position in the input file. */
DECL|method|getPosition ()
specifier|public
specifier|synchronized
name|long
name|getPosition
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|in
operator|.
name|getPos
argument_list|()
return|;
block|}
comment|/** Returns the name of the file. */
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|filename
return|;
block|}
block|}
comment|/** Sorts key/value pairs in a sequence-format file.    *    *<p>For best performance, applications should make sure that the {@link    * Writable#readFields(DataInput)} implementation of their keys is    * very efficient.  In particular, it should avoid allocating memory.    */
DECL|class|Sorter
specifier|public
specifier|static
class|class
name|Sorter
block|{
DECL|field|comparator
specifier|private
name|RawComparator
name|comparator
decl_stmt|;
DECL|field|mergeSort
specifier|private
name|MergeSort
name|mergeSort
decl_stmt|;
comment|//the implementation of merge sort
DECL|field|inFiles
specifier|private
name|Path
index|[]
name|inFiles
decl_stmt|;
comment|// when merging or sorting
DECL|field|outFile
specifier|private
name|Path
name|outFile
decl_stmt|;
DECL|field|memory
specifier|private
name|int
name|memory
decl_stmt|;
comment|// bytes
DECL|field|factor
specifier|private
name|int
name|factor
decl_stmt|;
comment|// merged per pass
DECL|field|fs
specifier|private
name|FileSystem
name|fs
init|=
literal|null
decl_stmt|;
DECL|field|keyClass
specifier|private
name|Class
name|keyClass
decl_stmt|;
DECL|field|valClass
specifier|private
name|Class
name|valClass
decl_stmt|;
DECL|field|conf
specifier|private
name|Configuration
name|conf
decl_stmt|;
DECL|field|metadata
specifier|private
name|Metadata
name|metadata
decl_stmt|;
DECL|field|progressable
specifier|private
name|Progressable
name|progressable
init|=
literal|null
decl_stmt|;
comment|/** Sort and merge files containing the named classes. */
DECL|method|Sorter (FileSystem fs, Class<? extends WritableComparable> keyClass, Class valClass, Configuration conf)
specifier|public
name|Sorter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|WritableComparable
argument_list|>
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|WritableComparator
operator|.
name|get
argument_list|(
name|keyClass
argument_list|,
name|conf
argument_list|)
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/** Sort and merge using an arbitrary {@link RawComparator}. */
DECL|method|Sorter (FileSystem fs, RawComparator comparator, Class keyClass, Class valClass, Configuration conf)
specifier|public
name|Sorter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|RawComparator
name|comparator
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
argument_list|(
name|fs
argument_list|,
name|comparator
argument_list|,
name|keyClass
argument_list|,
name|valClass
argument_list|,
name|conf
argument_list|,
operator|new
name|Metadata
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Sort and merge using an arbitrary {@link RawComparator}. */
DECL|method|Sorter (FileSystem fs, RawComparator comparator, Class keyClass, Class valClass, Configuration conf, Metadata metadata)
specifier|public
name|Sorter
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|RawComparator
name|comparator
parameter_list|,
name|Class
name|keyClass
parameter_list|,
name|Class
name|valClass
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Metadata
name|metadata
parameter_list|)
block|{
name|this
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|this
operator|.
name|comparator
operator|=
name|comparator
expr_stmt|;
name|this
operator|.
name|keyClass
operator|=
name|keyClass
expr_stmt|;
name|this
operator|.
name|valClass
operator|=
name|valClass
expr_stmt|;
name|this
operator|.
name|memory
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"io.sort.mb"
argument_list|,
literal|100
argument_list|)
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
name|this
operator|.
name|factor
operator|=
name|conf
operator|.
name|getInt
argument_list|(
literal|"io.sort.factor"
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|metadata
operator|=
name|metadata
expr_stmt|;
block|}
comment|/** Set the number of streams to merge at once.*/
DECL|method|setFactor (int factor)
specifier|public
name|void
name|setFactor
parameter_list|(
name|int
name|factor
parameter_list|)
block|{
name|this
operator|.
name|factor
operator|=
name|factor
expr_stmt|;
block|}
comment|/** Get the number of streams to merge at once.*/
DECL|method|getFactor ()
specifier|public
name|int
name|getFactor
parameter_list|()
block|{
return|return
name|factor
return|;
block|}
comment|/** Set the total amount of buffer memory, in bytes.*/
DECL|method|setMemory (int memory)
specifier|public
name|void
name|setMemory
parameter_list|(
name|int
name|memory
parameter_list|)
block|{
name|this
operator|.
name|memory
operator|=
name|memory
expr_stmt|;
block|}
comment|/** Get the total amount of buffer memory, in bytes.*/
DECL|method|getMemory ()
specifier|public
name|int
name|getMemory
parameter_list|()
block|{
return|return
name|memory
return|;
block|}
comment|/** Set the progressable object in order to report progress. */
DECL|method|setProgressable (Progressable progressable)
specifier|public
name|void
name|setProgressable
parameter_list|(
name|Progressable
name|progressable
parameter_list|)
block|{
name|this
operator|.
name|progressable
operator|=
name|progressable
expr_stmt|;
block|}
comment|/**       * Perform a file sort from a set of input files into an output file.      * @param inFiles the files to be sorted      * @param outFile the sorted output file      * @param deleteInput should the input files be deleted as they are read?      */
DECL|method|sort (Path[] inFiles, Path outFile, boolean deleteInput)
specifier|public
name|void
name|sort
parameter_list|(
name|Path
index|[]
name|inFiles
parameter_list|,
name|Path
name|outFile
parameter_list|,
name|boolean
name|deleteInput
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|outFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"already exists: "
operator|+
name|outFile
argument_list|)
throw|;
block|}
name|this
operator|.
name|inFiles
operator|=
name|inFiles
expr_stmt|;
name|this
operator|.
name|outFile
operator|=
name|outFile
expr_stmt|;
name|int
name|segments
init|=
name|sortPass
argument_list|(
name|deleteInput
argument_list|)
decl_stmt|;
if|if
condition|(
name|segments
operator|>
literal|1
condition|)
block|{
name|mergePass
argument_list|(
name|outFile
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**       * Perform a file sort from a set of input files and return an iterator.      * @param inFiles the files to be sorted      * @param tempDir the directory where temp files are created during sort      * @param deleteInput should the input files be deleted as they are read?      * @return iterator the RawKeyValueIterator      */
DECL|method|sortAndIterate (Path[] inFiles, Path tempDir, boolean deleteInput)
specifier|public
name|RawKeyValueIterator
name|sortAndIterate
parameter_list|(
name|Path
index|[]
name|inFiles
parameter_list|,
name|Path
name|tempDir
parameter_list|,
name|boolean
name|deleteInput
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|outFile
init|=
operator|new
name|Path
argument_list|(
name|tempDir
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
literal|"all.2"
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|outFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"already exists: "
operator|+
name|outFile
argument_list|)
throw|;
block|}
name|this
operator|.
name|inFiles
operator|=
name|inFiles
expr_stmt|;
comment|//outFile will basically be used as prefix for temp files in the cases
comment|//where sort outputs multiple sorted segments. For the single segment
comment|//case, the outputFile itself will contain the sorted data for that
comment|//segment
name|this
operator|.
name|outFile
operator|=
name|outFile
expr_stmt|;
name|int
name|segments
init|=
name|sortPass
argument_list|(
name|deleteInput
argument_list|)
decl_stmt|;
if|if
condition|(
name|segments
operator|>
literal|1
condition|)
return|return
name|merge
argument_list|(
name|outFile
operator|.
name|suffix
argument_list|(
literal|".0"
argument_list|)
argument_list|,
name|outFile
operator|.
name|suffix
argument_list|(
literal|".0.index"
argument_list|)
argument_list|,
name|tempDir
argument_list|)
return|;
elseif|else
if|if
condition|(
name|segments
operator|==
literal|1
condition|)
return|return
name|merge
argument_list|(
operator|new
name|Path
index|[]
block|{
name|outFile
block|}
argument_list|,
literal|true
argument_list|,
name|tempDir
argument_list|)
return|;
else|else
return|return
literal|null
return|;
block|}
comment|/**      * The backwards compatible interface to sort.      * @param inFile the input file to sort      * @param outFile the sorted output file      */
DECL|method|sort (Path inFile, Path outFile)
specifier|public
name|void
name|sort
parameter_list|(
name|Path
name|inFile
parameter_list|,
name|Path
name|outFile
parameter_list|)
throws|throws
name|IOException
block|{
name|sort
argument_list|(
operator|new
name|Path
index|[]
block|{
name|inFile
block|}
argument_list|,
name|outFile
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|sortPass (boolean deleteInput)
specifier|private
name|int
name|sortPass
parameter_list|(
name|boolean
name|deleteInput
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"running sort pass"
argument_list|)
expr_stmt|;
block|}
name|SortPass
name|sortPass
init|=
operator|new
name|SortPass
argument_list|()
decl_stmt|;
comment|// make the SortPass
name|sortPass
operator|.
name|setProgressable
argument_list|(
name|progressable
argument_list|)
expr_stmt|;
name|mergeSort
operator|=
operator|new
name|MergeSort
argument_list|(
name|sortPass
operator|.
expr|new
name|SeqFileComparator
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|sortPass
operator|.
name|run
argument_list|(
name|deleteInput
argument_list|)
return|;
comment|// run it
block|}
finally|finally
block|{
name|sortPass
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// close it
block|}
block|}
DECL|class|SortPass
specifier|private
class|class
name|SortPass
block|{
DECL|field|memoryLimit
specifier|private
name|int
name|memoryLimit
init|=
name|memory
operator|/
literal|4
decl_stmt|;
DECL|field|recordLimit
specifier|private
name|int
name|recordLimit
init|=
literal|1000000
decl_stmt|;
DECL|field|rawKeys
specifier|private
name|DataOutputBuffer
name|rawKeys
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
DECL|field|rawBuffer
specifier|private
name|byte
index|[]
name|rawBuffer
decl_stmt|;
DECL|field|keyOffsets
specifier|private
name|int
index|[]
name|keyOffsets
init|=
operator|new
name|int
index|[
literal|1024
index|]
decl_stmt|;
DECL|field|pointers
specifier|private
name|int
index|[]
name|pointers
init|=
operator|new
name|int
index|[
name|keyOffsets
operator|.
name|length
index|]
decl_stmt|;
DECL|field|pointersCopy
specifier|private
name|int
index|[]
name|pointersCopy
init|=
operator|new
name|int
index|[
name|keyOffsets
operator|.
name|length
index|]
decl_stmt|;
DECL|field|keyLengths
specifier|private
name|int
index|[]
name|keyLengths
init|=
operator|new
name|int
index|[
name|keyOffsets
operator|.
name|length
index|]
decl_stmt|;
DECL|field|rawValues
specifier|private
name|ValueBytes
index|[]
name|rawValues
init|=
operator|new
name|ValueBytes
index|[
name|keyOffsets
operator|.
name|length
index|]
decl_stmt|;
DECL|field|segmentLengths
specifier|private
name|ArrayList
name|segmentLengths
init|=
operator|new
name|ArrayList
argument_list|()
decl_stmt|;
DECL|field|in
specifier|private
name|Reader
name|in
init|=
literal|null
decl_stmt|;
DECL|field|out
specifier|private
name|FSDataOutputStream
name|out
init|=
literal|null
decl_stmt|;
DECL|field|indexOut
specifier|private
name|FSDataOutputStream
name|indexOut
init|=
literal|null
decl_stmt|;
DECL|field|outName
specifier|private
name|Path
name|outName
decl_stmt|;
DECL|field|progressable
specifier|private
name|Progressable
name|progressable
init|=
literal|null
decl_stmt|;
DECL|method|run (boolean deleteInput)
specifier|public
name|int
name|run
parameter_list|(
name|boolean
name|deleteInput
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|segments
init|=
literal|0
decl_stmt|;
name|int
name|currentFile
init|=
literal|0
decl_stmt|;
name|boolean
name|atEof
init|=
operator|(
name|currentFile
operator|>=
name|inFiles
operator|.
name|length
operator|)
decl_stmt|;
name|CompressionType
name|compressionType
decl_stmt|;
name|CompressionCodec
name|codec
init|=
literal|null
decl_stmt|;
name|segmentLengths
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|atEof
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|// Initialize
name|in
operator|=
operator|new
name|Reader
argument_list|(
name|fs
argument_list|,
name|inFiles
index|[
name|currentFile
index|]
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|compressionType
operator|=
name|in
operator|.
name|getCompressionType
argument_list|()
expr_stmt|;
name|codec
operator|=
name|in
operator|.
name|getCompressionCodec
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rawValues
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|rawValues
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|atEof
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|bytesProcessed
init|=
literal|0
decl_stmt|;
name|rawKeys
operator|.
name|reset
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|atEof
operator|&&
name|bytesProcessed
operator|<
name|memoryLimit
operator|&&
name|count
operator|<
name|recordLimit
condition|)
block|{
comment|// Read a record into buffer
comment|// Note: Attempt to re-use 'rawValue' as far as possible
name|int
name|keyOffset
init|=
name|rawKeys
operator|.
name|getLength
argument_list|()
decl_stmt|;
name|ValueBytes
name|rawValue
init|=
operator|(
name|count
operator|==
name|keyOffsets
operator|.
name|length
operator|||
name|rawValues
index|[
name|count
index|]
operator|==
literal|null
operator|)
condition|?
name|in
operator|.
name|createValueBytes
argument_list|()
else|:
name|rawValues
index|[
name|count
index|]
decl_stmt|;
name|int
name|recordLength
init|=
name|in
operator|.
name|nextRaw
argument_list|(
name|rawKeys
argument_list|,
name|rawValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|recordLength
operator|==
operator|-
literal|1
condition|)
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|deleteInput
condition|)
block|{
name|fs
operator|.
name|delete
argument_list|(
name|inFiles
index|[
name|currentFile
index|]
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
name|currentFile
operator|+=
literal|1
expr_stmt|;
name|atEof
operator|=
name|currentFile
operator|>=
name|inFiles
operator|.
name|length
expr_stmt|;
if|if
condition|(
operator|!
name|atEof
condition|)
block|{
name|in
operator|=
operator|new
name|Reader
argument_list|(
name|fs
argument_list|,
name|inFiles
index|[
name|currentFile
index|]
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in
operator|=
literal|null
expr_stmt|;
block|}
continue|continue;
block|}
name|int
name|keyLength
init|=
name|rawKeys
operator|.
name|getLength
argument_list|()
operator|-
name|keyOffset
decl_stmt|;
if|if
condition|(
name|count
operator|==
name|keyOffsets
operator|.
name|length
condition|)
name|grow
argument_list|()
expr_stmt|;
name|keyOffsets
index|[
name|count
index|]
operator|=
name|keyOffset
expr_stmt|;
comment|// update pointers
name|pointers
index|[
name|count
index|]
operator|=
name|count
expr_stmt|;
name|keyLengths
index|[
name|count
index|]
operator|=
name|keyLength
expr_stmt|;
name|rawValues
index|[
name|count
index|]
operator|=
name|rawValue
expr_stmt|;
name|bytesProcessed
operator|+=
name|recordLength
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|// buffer is full -- sort& flush it
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"flushing segment "
operator|+
name|segments
argument_list|)
expr_stmt|;
block|}
name|rawBuffer
operator|=
name|rawKeys
operator|.
name|getData
argument_list|()
expr_stmt|;
name|sort
argument_list|(
name|count
argument_list|)
expr_stmt|;
comment|// indicate we're making progress
if|if
condition|(
name|progressable
operator|!=
literal|null
condition|)
block|{
name|progressable
operator|.
name|progress
argument_list|()
expr_stmt|;
block|}
name|flush
argument_list|(
name|count
argument_list|,
name|bytesProcessed
argument_list|,
name|compressionType
argument_list|,
name|codec
argument_list|,
name|segments
operator|==
literal|0
operator|&&
name|atEof
argument_list|)
expr_stmt|;
name|segments
operator|++
expr_stmt|;
block|}
return|return
name|segments
return|;
block|}
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|indexOut
operator|!=
literal|null
condition|)
block|{
name|indexOut
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|grow ()
specifier|private
name|void
name|grow
parameter_list|()
block|{
name|int
name|newLength
init|=
name|keyOffsets
operator|.
name|length
operator|*
literal|3
operator|/
literal|2
decl_stmt|;
name|keyOffsets
operator|=
name|grow
argument_list|(
name|keyOffsets
argument_list|,
name|newLength
argument_list|)
expr_stmt|;
name|pointers
operator|=
name|grow
argument_list|(
name|pointers
argument_list|,
name|newLength
argument_list|)
expr_stmt|;
name|pointersCopy
operator|=
operator|new
name|int
index|[
name|newLength
index|]
expr_stmt|;
name|keyLengths
operator|=
name|grow
argument_list|(
name|keyLengths
argument_list|,
name|newLength
argument_list|)
expr_stmt|;
name|rawValues
operator|=
name|grow
argument_list|(
name|rawValues
argument_list|,
name|newLength
argument_list|)
expr_stmt|;
block|}
DECL|method|grow (int[] old, int newLength)
specifier|private
name|int
index|[]
name|grow
parameter_list|(
name|int
index|[]
name|old
parameter_list|,
name|int
name|newLength
parameter_list|)
block|{
name|int
index|[]
name|result
init|=
operator|new
name|int
index|[
name|newLength
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|old
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|old
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
DECL|method|grow (ValueBytes[] old, int newLength)
specifier|private
name|ValueBytes
index|[]
name|grow
parameter_list|(
name|ValueBytes
index|[]
name|old
parameter_list|,
name|int
name|newLength
parameter_list|)
block|{
name|ValueBytes
index|[]
name|result
init|=
operator|new
name|ValueBytes
index|[
name|newLength
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|old
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|old
operator|.
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|old
operator|.
name|length
init|;
name|i
operator|<
name|newLength
condition|;
operator|++
name|i
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|flush (int count, int bytesProcessed, CompressionType compressionType, CompressionCodec codec, boolean done)
specifier|private
name|void
name|flush
parameter_list|(
name|int
name|count
parameter_list|,
name|int
name|bytesProcessed
parameter_list|,
name|CompressionType
name|compressionType
parameter_list|,
name|CompressionCodec
name|codec
parameter_list|,
name|boolean
name|done
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|out
operator|==
literal|null
condition|)
block|{
name|outName
operator|=
name|done
condition|?
name|outFile
else|:
name|outFile
operator|.
name|suffix
argument_list|(
literal|".0"
argument_list|)
expr_stmt|;
name|out
operator|=
name|fs
operator|.
name|create
argument_list|(
name|outName
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|indexOut
operator|=
name|fs
operator|.
name|create
argument_list|(
name|outName
operator|.
name|suffix
argument_list|(
literal|".index"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|segmentStart
init|=
name|out
operator|.
name|getPos
argument_list|()
decl_stmt|;
name|Writer
name|writer
init|=
name|createWriter
argument_list|(
name|conf
argument_list|,
name|Writer
operator|.
name|stream
argument_list|(
name|out
argument_list|)
argument_list|,
name|Writer
operator|.
name|keyClass
argument_list|(
name|keyClass
argument_list|)
argument_list|,
name|Writer
operator|.
name|valueClass
argument_list|(
name|valClass
argument_list|)
argument_list|,
name|Writer
operator|.
name|compression
argument_list|(
name|compressionType
argument_list|,
name|codec
argument_list|)
argument_list|,
name|Writer
operator|.
name|metadata
argument_list|(
name|done
condition|?
name|metadata
else|:
operator|new
name|Metadata
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|writer
operator|.
name|sync
operator|=
literal|null
expr_stmt|;
comment|// disable sync on temp files
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|// write in sorted order
name|int
name|p
init|=
name|pointers
index|[
name|i
index|]
decl_stmt|;
name|writer
operator|.
name|appendRaw
argument_list|(
name|rawBuffer
argument_list|,
name|keyOffsets
index|[
name|p
index|]
argument_list|,
name|keyLengths
index|[
name|p
index|]
argument_list|,
name|rawValues
index|[
name|p
index|]
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
comment|// Save the segment length
name|WritableUtils
operator|.
name|writeVLong
argument_list|(
name|indexOut
argument_list|,
name|segmentStart
argument_list|)
expr_stmt|;
name|WritableUtils
operator|.
name|writeVLong
argument_list|(
name|indexOut
argument_list|,
operator|(
name|out
operator|.
name|getPos
argument_list|()
operator|-
name|segmentStart
operator|)
argument_list|)
expr_stmt|;
name|indexOut
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|sort (int count)
specifier|private
name|void
name|sort
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|pointers
argument_list|,
literal|0
argument_list|,
name|pointersCopy
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|mergeSort
operator|.
name|mergeSort
argument_list|(
name|pointersCopy
argument_list|,
name|pointers
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
DECL|class|SeqFileComparator
class|class
name|SeqFileComparator
implements|implements
name|Comparator
argument_list|<
name|IntWritable
argument_list|>
block|{
annotation|@
name|Override
DECL|method|compare (IntWritable I, IntWritable J)
specifier|public
name|int
name|compare
parameter_list|(
name|IntWritable
name|I
parameter_list|,
name|IntWritable
name|J
parameter_list|)
block|{
return|return
name|comparator
operator|.
name|compare
argument_list|(
name|rawBuffer
argument_list|,
name|keyOffsets
index|[
name|I
operator|.
name|get
argument_list|()
index|]
argument_list|,
name|keyLengths
index|[
name|I
operator|.
name|get
argument_list|()
index|]
argument_list|,
name|rawBuffer
argument_list|,
name|keyOffsets
index|[
name|J
operator|.
name|get
argument_list|()
index|]
argument_list|,
name|keyLengths
index|[
name|J
operator|.
name|get
argument_list|()
index|]
argument_list|)
return|;
block|}
block|}
comment|/** set the progressable object in order to report progress */
DECL|method|setProgressable (Progressable progressable)
specifier|public
name|void
name|setProgressable
parameter_list|(
name|Progressable
name|progressable
parameter_list|)
block|{
name|this
operator|.
name|progressable
operator|=
name|progressable
expr_stmt|;
block|}
block|}
comment|// SequenceFile.Sorter.SortPass
comment|/** The interface to iterate over raw keys/values of SequenceFiles. */
DECL|interface|RawKeyValueIterator
specifier|public
specifier|static
interface|interface
name|RawKeyValueIterator
block|{
comment|/** Gets the current raw key        * @return DataOutputBuffer        * @throws IOException        */
DECL|method|getKey ()
name|DataOutputBuffer
name|getKey
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Gets the current raw value        * @return ValueBytes         * @throws IOException        */
DECL|method|getValue ()
name|ValueBytes
name|getValue
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Sets up the current key and value (for getKey and getValue)        * @return true if there exists a key/value, false otherwise         * @throws IOException        */
DECL|method|next ()
name|boolean
name|next
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** closes the iterator so that the underlying streams can be closed        * @throws IOException        */
DECL|method|close ()
name|void
name|close
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/** Gets the Progress object; this has a float (0.0 - 1.0)         * indicating the bytes processed by the iterator so far        */
DECL|method|getProgress ()
name|Progress
name|getProgress
parameter_list|()
function_decl|;
block|}
comment|/**      * Merges the list of segments of type<code>SegmentDescriptor</code>      * @param segments the list of SegmentDescriptors      * @param tmpDir the directory to write temporary files into      * @return RawKeyValueIterator      * @throws IOException      */
DECL|method|merge (List <SegmentDescriptor> segments, Path tmpDir)
specifier|public
name|RawKeyValueIterator
name|merge
parameter_list|(
name|List
argument_list|<
name|SegmentDescriptor
argument_list|>
name|segments
parameter_list|,
name|Path
name|tmpDir
parameter_list|)
throws|throws
name|IOException
block|{
comment|// pass in object to report progress, if present
name|MergeQueue
name|mQueue
init|=
operator|new
name|MergeQueue
argument_list|(
name|segments
argument_list|,
name|tmpDir
argument_list|,
name|progressable
argument_list|)
decl_stmt|;
return|return
name|mQueue
operator|.
name|merge
argument_list|()
return|;
block|}
comment|/**      * Merges the contents of files passed in Path[] using a max factor value      * that is already set      * @param inNames the array of path names      * @param deleteInputs true if the input files should be deleted when       * unnecessary      * @param tmpDir the directory to write temporary files into      * @return RawKeyValueIteratorMergeQueue      * @throws IOException      */
DECL|method|merge (Path [] inNames, boolean deleteInputs, Path tmpDir)
specifier|public
name|RawKeyValueIterator
name|merge
parameter_list|(
name|Path
index|[]
name|inNames
parameter_list|,
name|boolean
name|deleteInputs
parameter_list|,
name|Path
name|tmpDir
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|merge
argument_list|(
name|inNames
argument_list|,
name|deleteInputs
argument_list|,
operator|(
name|inNames
operator|.
name|length
operator|<
name|factor
operator|)
condition|?
name|inNames
operator|.
name|length
else|:
name|factor
argument_list|,
name|tmpDir
argument_list|)
return|;
block|}
comment|/**      * Merges the contents of files passed in Path[]      * @param inNames the array of path names      * @param deleteInputs true if the input files should be deleted when       * unnecessary      * @param factor the factor that will be used as the maximum merge fan-in      * @param tmpDir the directory to write temporary files into      * @return RawKeyValueIteratorMergeQueue      * @throws IOException      */
DECL|method|merge (Path [] inNames, boolean deleteInputs, int factor, Path tmpDir)
specifier|public
name|RawKeyValueIterator
name|merge
parameter_list|(
name|Path
index|[]
name|inNames
parameter_list|,
name|boolean
name|deleteInputs
parameter_list|,
name|int
name|factor
parameter_list|,
name|Path
name|tmpDir
parameter_list|)
throws|throws
name|IOException
block|{
comment|//get the segments from inNames
name|ArrayList
argument_list|<
name|SegmentDescriptor
argument_list|>
name|a
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentDescriptor
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inNames
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|SegmentDescriptor
name|s
init|=
operator|new
name|SegmentDescriptor
argument_list|(
literal|0
argument_list|,
name|fs
operator|.
name|getFileStatus
argument_list|(
name|inNames
index|[
name|i
index|]
argument_list|)
operator|.
name|getLen
argument_list|()
argument_list|,
name|inNames
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|s
operator|.
name|preserveInput
argument_list|(
operator|!
name|deleteInputs
argument_list|)
expr_stmt|;
name|s
operator|.
name|doSync
argument_list|()
expr_stmt|;
name|a
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|factor
operator|=
name|factor
expr_stmt|;
name|MergeQueue
name|mQueue
init|=
operator|new
name|MergeQueue
argument_list|(
name|a
argument_list|,
name|tmpDir
argument_list|,
name|progressable
argument_list|)
decl_stmt|;
return|return
name|mQueue
operator|.
name|merge
argument_list|()
return|;
block|}
comment|/**      * Merges the contents of files passed in Path[]      * @param inNames the array of path names      * @param tempDir the directory for creating temp files during merge      * @param deleteInputs true if the input files should be deleted when       * unnecessary      * @return RawKeyValueIteratorMergeQueue      * @throws IOException      */
DECL|method|merge (Path [] inNames, Path tempDir, boolean deleteInputs)
specifier|public
name|RawKeyValueIterator
name|merge
parameter_list|(
name|Path
index|[]
name|inNames
parameter_list|,
name|Path
name|tempDir
parameter_list|,
name|boolean
name|deleteInputs
parameter_list|)
throws|throws
name|IOException
block|{
comment|//outFile will basically be used as prefix for temp files for the
comment|//intermediate merge outputs
name|this
operator|.
name|outFile
operator|=
operator|new
name|Path
argument_list|(
name|tempDir
operator|+
name|Path
operator|.
name|SEPARATOR
operator|+
literal|"merged"
argument_list|)
expr_stmt|;
comment|//get the segments from inNames
name|ArrayList
argument_list|<
name|SegmentDescriptor
argument_list|>
name|a
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentDescriptor
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inNames
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|SegmentDescriptor
name|s
init|=
operator|new
name|SegmentDescriptor
argument_list|(
literal|0
argument_list|,
name|fs
operator|.
name|getFileStatus
argument_list|(
name|inNames
index|[
name|i
index|]
argument_list|)
operator|.
name|getLen
argument_list|()
argument_list|,
name|inNames
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|s
operator|.
name|preserveInput
argument_list|(
operator|!
name|deleteInputs
argument_list|)
expr_stmt|;
name|s
operator|.
name|doSync
argument_list|()
expr_stmt|;
name|a
operator|.
name|add
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|factor
operator|=
operator|(
name|inNames
operator|.
name|length
operator|<
name|factor
operator|)
condition|?
name|inNames
operator|.
name|length
else|:
name|factor
expr_stmt|;
comment|// pass in object to report progress, if present
name|MergeQueue
name|mQueue
init|=
operator|new
name|MergeQueue
argument_list|(
name|a
argument_list|,
name|tempDir
argument_list|,
name|progressable
argument_list|)
decl_stmt|;
return|return
name|mQueue
operator|.
name|merge
argument_list|()
return|;
block|}
comment|/**      * Clones the attributes (like compression of the input file and creates a       * corresponding Writer      * @param inputFile the path of the input file whose attributes should be       * cloned      * @param outputFile the path of the output file       * @param prog the Progressable to report status during the file write      * @return Writer      * @throws IOException      */
DECL|method|cloneFileAttributes (Path inputFile, Path outputFile, Progressable prog)
specifier|public
name|Writer
name|cloneFileAttributes
parameter_list|(
name|Path
name|inputFile
parameter_list|,
name|Path
name|outputFile
parameter_list|,
name|Progressable
name|prog
parameter_list|)
throws|throws
name|IOException
block|{
name|Reader
name|reader
init|=
operator|new
name|Reader
argument_list|(
name|conf
argument_list|,
name|Reader
operator|.
name|file
argument_list|(
name|inputFile
argument_list|)
argument_list|,
operator|new
name|Reader
operator|.
name|OnlyHeaderOption
argument_list|()
argument_list|)
decl_stmt|;
name|CompressionType
name|compress
init|=
name|reader
operator|.
name|getCompressionType
argument_list|()
decl_stmt|;
name|CompressionCodec
name|codec
init|=
name|reader
operator|.
name|getCompressionCodec
argument_list|()
decl_stmt|;
name|reader
operator|.
name|close
argument_list|()
expr_stmt|;
name|Writer
name|writer
init|=
name|createWriter
argument_list|(
name|conf
argument_list|,
name|Writer
operator|.
name|file
argument_list|(
name|outputFile
argument_list|)
argument_list|,
name|Writer
operator|.
name|keyClass
argument_list|(
name|keyClass
argument_list|)
argument_list|,
name|Writer
operator|.
name|valueClass
argument_list|(
name|valClass
argument_list|)
argument_list|,
name|Writer
operator|.
name|compression
argument_list|(
name|compress
argument_list|,
name|codec
argument_list|)
argument_list|,
name|Writer
operator|.
name|progressable
argument_list|(
name|prog
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|writer
return|;
block|}
comment|/**      * Writes records from RawKeyValueIterator into a file represented by the       * passed writer      * @param records the RawKeyValueIterator      * @param writer the Writer created earlier       * @throws IOException      */
DECL|method|writeFile (RawKeyValueIterator records, Writer writer)
specifier|public
name|void
name|writeFile
parameter_list|(
name|RawKeyValueIterator
name|records
parameter_list|,
name|Writer
name|writer
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
name|records
operator|.
name|next
argument_list|()
condition|)
block|{
name|writer
operator|.
name|appendRaw
argument_list|(
name|records
operator|.
name|getKey
argument_list|()
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|records
operator|.
name|getKey
argument_list|()
operator|.
name|getLength
argument_list|()
argument_list|,
name|records
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
comment|/** Merge the provided files.      * @param inFiles the array of input path names      * @param outFile the final output file      * @throws IOException      */
DECL|method|merge (Path[] inFiles, Path outFile)
specifier|public
name|void
name|merge
parameter_list|(
name|Path
index|[]
name|inFiles
parameter_list|,
name|Path
name|outFile
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|fs
operator|.
name|exists
argument_list|(
name|outFile
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"already exists: "
operator|+
name|outFile
argument_list|)
throw|;
block|}
name|RawKeyValueIterator
name|r
init|=
name|merge
argument_list|(
name|inFiles
argument_list|,
literal|false
argument_list|,
name|outFile
operator|.
name|getParent
argument_list|()
argument_list|)
decl_stmt|;
name|Writer
name|writer
init|=
name|cloneFileAttributes
argument_list|(
name|inFiles
index|[
literal|0
index|]
argument_list|,
name|outFile
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|writeFile
argument_list|(
name|r
argument_list|,
name|writer
argument_list|)
expr_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/** sort calls this to generate the final merged output */
DECL|method|mergePass (Path tmpDir)
specifier|private
name|int
name|mergePass
parameter_list|(
name|Path
name|tmpDir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"running merge pass"
argument_list|)
expr_stmt|;
block|}
name|Writer
name|writer
init|=
name|cloneFileAttributes
argument_list|(
name|outFile
operator|.
name|suffix
argument_list|(
literal|".0"
argument_list|)
argument_list|,
name|outFile
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|RawKeyValueIterator
name|r
init|=
name|merge
argument_list|(
name|outFile
operator|.
name|suffix
argument_list|(
literal|".0"
argument_list|)
argument_list|,
name|outFile
operator|.
name|suffix
argument_list|(
literal|".0.index"
argument_list|)
argument_list|,
name|tmpDir
argument_list|)
decl_stmt|;
name|writeFile
argument_list|(
name|r
argument_list|,
name|writer
argument_list|)
expr_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/** Used by mergePass to merge the output of the sort      * @param inName the name of the input file containing sorted segments      * @param indexIn the offsets of the sorted segments      * @param tmpDir the relative directory to store intermediate results in      * @return RawKeyValueIterator      * @throws IOException      */
DECL|method|merge (Path inName, Path indexIn, Path tmpDir)
specifier|private
name|RawKeyValueIterator
name|merge
parameter_list|(
name|Path
name|inName
parameter_list|,
name|Path
name|indexIn
parameter_list|,
name|Path
name|tmpDir
parameter_list|)
throws|throws
name|IOException
block|{
comment|//get the segments from indexIn
comment|//we create a SegmentContainer so that we can track segments belonging to
comment|//inName and delete inName as soon as we see that we have looked at all
comment|//the contained segments during the merge process& hence don't need
comment|//them anymore
name|SegmentContainer
name|container
init|=
operator|new
name|SegmentContainer
argument_list|(
name|inName
argument_list|,
name|indexIn
argument_list|)
decl_stmt|;
name|MergeQueue
name|mQueue
init|=
operator|new
name|MergeQueue
argument_list|(
name|container
operator|.
name|getSegmentList
argument_list|()
argument_list|,
name|tmpDir
argument_list|,
name|progressable
argument_list|)
decl_stmt|;
return|return
name|mQueue
operator|.
name|merge
argument_list|()
return|;
block|}
comment|/** This class implements the core of the merge logic */
DECL|class|MergeQueue
specifier|private
class|class
name|MergeQueue
extends|extends
name|PriorityQueue
implements|implements
name|RawKeyValueIterator
block|{
DECL|field|compress
specifier|private
name|boolean
name|compress
decl_stmt|;
DECL|field|blockCompress
specifier|private
name|boolean
name|blockCompress
decl_stmt|;
DECL|field|rawKey
specifier|private
name|DataOutputBuffer
name|rawKey
init|=
operator|new
name|DataOutputBuffer
argument_list|()
decl_stmt|;
DECL|field|rawValue
specifier|private
name|ValueBytes
name|rawValue
decl_stmt|;
DECL|field|totalBytesProcessed
specifier|private
name|long
name|totalBytesProcessed
decl_stmt|;
DECL|field|progPerByte
specifier|private
name|float
name|progPerByte
decl_stmt|;
DECL|field|mergeProgress
specifier|private
name|Progress
name|mergeProgress
init|=
operator|new
name|Progress
argument_list|()
decl_stmt|;
DECL|field|tmpDir
specifier|private
name|Path
name|tmpDir
decl_stmt|;
DECL|field|progress
specifier|private
name|Progressable
name|progress
init|=
literal|null
decl_stmt|;
comment|//handle to the progress reporting object
DECL|field|minSegment
specifier|private
name|SegmentDescriptor
name|minSegment
decl_stmt|;
comment|//a TreeMap used to store the segments sorted by size (segment offset and
comment|//segment path name is used to break ties between segments of same sizes)
DECL|field|sortedSegmentSizes
specifier|private
name|Map
argument_list|<
name|SegmentDescriptor
argument_list|,
name|Void
argument_list|>
name|sortedSegmentSizes
init|=
operator|new
name|TreeMap
argument_list|<
name|SegmentDescriptor
argument_list|,
name|Void
argument_list|>
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|put (SegmentDescriptor stream)
specifier|public
name|void
name|put
parameter_list|(
name|SegmentDescriptor
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|compress
operator|=
name|stream
operator|.
name|in
operator|.
name|isCompressed
argument_list|()
expr_stmt|;
name|blockCompress
operator|=
name|stream
operator|.
name|in
operator|.
name|isBlockCompressed
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compress
operator|!=
name|stream
operator|.
name|in
operator|.
name|isCompressed
argument_list|()
operator|||
name|blockCompress
operator|!=
name|stream
operator|.
name|in
operator|.
name|isBlockCompressed
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"All merged files must be compressed or not."
argument_list|)
throw|;
block|}
name|super
operator|.
name|put
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/**        * A queue of file segments to merge        * @param segments the file segments to merge        * @param tmpDir a relative local directory to save intermediate files in        * @param progress the reference to the Progressable object        */
DECL|method|MergeQueue (List <SegmentDescriptor> segments, Path tmpDir, Progressable progress)
specifier|public
name|MergeQueue
parameter_list|(
name|List
argument_list|<
name|SegmentDescriptor
argument_list|>
name|segments
parameter_list|,
name|Path
name|tmpDir
parameter_list|,
name|Progressable
name|progress
parameter_list|)
block|{
name|int
name|size
init|=
name|segments
operator|.
name|size
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|sortedSegmentSizes
operator|.
name|put
argument_list|(
name|segments
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|tmpDir
operator|=
name|tmpDir
expr_stmt|;
name|this
operator|.
name|progress
operator|=
name|progress
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|lessThan (Object a, Object b)
specifier|protected
name|boolean
name|lessThan
parameter_list|(
name|Object
name|a
parameter_list|,
name|Object
name|b
parameter_list|)
block|{
comment|// indicate we're making progress
if|if
condition|(
name|progress
operator|!=
literal|null
condition|)
block|{
name|progress
operator|.
name|progress
argument_list|()
expr_stmt|;
block|}
name|SegmentDescriptor
name|msa
init|=
operator|(
name|SegmentDescriptor
operator|)
name|a
decl_stmt|;
name|SegmentDescriptor
name|msb
init|=
operator|(
name|SegmentDescriptor
operator|)
name|b
decl_stmt|;
return|return
name|comparator
operator|.
name|compare
argument_list|(
name|msa
operator|.
name|getKey
argument_list|()
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|msa
operator|.
name|getKey
argument_list|()
operator|.
name|getLength
argument_list|()
argument_list|,
name|msb
operator|.
name|getKey
argument_list|()
operator|.
name|getData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|msb
operator|.
name|getKey
argument_list|()
operator|.
name|getLength
argument_list|()
argument_list|)
operator|<
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|SegmentDescriptor
name|ms
decl_stmt|;
comment|// close inputs
while|while
condition|(
operator|(
name|ms
operator|=
operator|(
name|SegmentDescriptor
operator|)
name|pop
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|ms
operator|.
name|cleanup
argument_list|()
expr_stmt|;
block|}
name|minSegment
operator|=
literal|null
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getKey ()
specifier|public
name|DataOutputBuffer
name|getKey
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|rawKey
return|;
block|}
annotation|@
name|Override
DECL|method|getValue ()
specifier|public
name|ValueBytes
name|getValue
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|rawValue
return|;
block|}
annotation|@
name|Override
DECL|method|next ()
specifier|public
name|boolean
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|minSegment
operator|!=
literal|null
condition|)
block|{
comment|//minSegment is non-null for all invocations of next except the first
comment|//one. For the first invocation, the priority queue is ready for use
comment|//but for the subsequent invocations, first adjust the queue
name|adjustPriorityQueue
argument_list|(
name|minSegment
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|minSegment
operator|=
literal|null
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|minSegment
operator|=
operator|(
name|SegmentDescriptor
operator|)
name|top
argument_list|()
expr_stmt|;
name|long
name|startPos
init|=
name|minSegment
operator|.
name|in
operator|.
name|getPosition
argument_list|()
decl_stmt|;
comment|// Current position in stream
comment|//save the raw key reference
name|rawKey
operator|=
name|minSegment
operator|.
name|getKey
argument_list|()
expr_stmt|;
comment|//load the raw value. Re-use the existing rawValue buffer
if|if
condition|(
name|rawValue
operator|==
literal|null
condition|)
block|{
name|rawValue
operator|=
name|minSegment
operator|.
name|in
operator|.
name|createValueBytes
argument_list|()
expr_stmt|;
block|}
name|minSegment
operator|.
name|nextRawValue
argument_list|(
name|rawValue
argument_list|)
expr_stmt|;
name|long
name|endPos
init|=
name|minSegment
operator|.
name|in
operator|.
name|getPosition
argument_list|()
decl_stmt|;
comment|// End position after reading value
name|updateProgress
argument_list|(
name|endPos
operator|-
name|startPos
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|getProgress ()
specifier|public
name|Progress
name|getProgress
parameter_list|()
block|{
return|return
name|mergeProgress
return|;
block|}
DECL|method|adjustPriorityQueue (SegmentDescriptor ms)
specifier|private
name|void
name|adjustPriorityQueue
parameter_list|(
name|SegmentDescriptor
name|ms
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|startPos
init|=
name|ms
operator|.
name|in
operator|.
name|getPosition
argument_list|()
decl_stmt|;
comment|// Current position in stream
name|boolean
name|hasNext
init|=
name|ms
operator|.
name|nextRawKey
argument_list|()
decl_stmt|;
name|long
name|endPos
init|=
name|ms
operator|.
name|in
operator|.
name|getPosition
argument_list|()
decl_stmt|;
comment|// End position after reading key
name|updateProgress
argument_list|(
name|endPos
operator|-
name|startPos
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasNext
condition|)
block|{
name|adjustTop
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|pop
argument_list|()
expr_stmt|;
name|ms
operator|.
name|cleanup
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|updateProgress (long bytesProcessed)
specifier|private
name|void
name|updateProgress
parameter_list|(
name|long
name|bytesProcessed
parameter_list|)
block|{
name|totalBytesProcessed
operator|+=
name|bytesProcessed
expr_stmt|;
if|if
condition|(
name|progPerByte
operator|>
literal|0
condition|)
block|{
name|mergeProgress
operator|.
name|set
argument_list|(
name|totalBytesProcessed
operator|*
name|progPerByte
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** This is the single level merge that is called multiple times         * depending on the factor size and the number of segments        * @return RawKeyValueIterator        * @throws IOException        */
DECL|method|merge ()
specifier|public
name|RawKeyValueIterator
name|merge
parameter_list|()
throws|throws
name|IOException
block|{
comment|//create the MergeStreams from the sorted map created in the constructor
comment|//and dump the final output to a file
name|int
name|numSegments
init|=
name|sortedSegmentSizes
operator|.
name|size
argument_list|()
decl_stmt|;
name|int
name|origFactor
init|=
name|factor
decl_stmt|;
name|int
name|passNo
init|=
literal|1
decl_stmt|;
name|LocalDirAllocator
name|lDirAlloc
init|=
operator|new
name|LocalDirAllocator
argument_list|(
literal|"io.seqfile.local.dir"
argument_list|)
decl_stmt|;
do|do
block|{
comment|//get the factor for this pass of merge
name|factor
operator|=
name|getPassFactor
argument_list|(
name|passNo
argument_list|,
name|numSegments
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|SegmentDescriptor
argument_list|>
name|segmentsToMerge
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentDescriptor
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|segmentsConsidered
init|=
literal|0
decl_stmt|;
name|int
name|numSegmentsToConsider
init|=
name|factor
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|//extract the smallest 'factor' number of segment pointers from the
comment|//TreeMap. Call cleanup on the empty segments (no key/value data)
name|SegmentDescriptor
index|[]
name|mStream
init|=
name|getSegmentDescriptors
argument_list|(
name|numSegmentsToConsider
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|mStream
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mStream
index|[
name|i
index|]
operator|.
name|nextRawKey
argument_list|()
condition|)
block|{
name|segmentsToMerge
operator|.
name|add
argument_list|(
name|mStream
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|segmentsConsidered
operator|++
expr_stmt|;
comment|// Count the fact that we read some bytes in calling nextRawKey()
name|updateProgress
argument_list|(
name|mStream
index|[
name|i
index|]
operator|.
name|in
operator|.
name|getPosition
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mStream
index|[
name|i
index|]
operator|.
name|cleanup
argument_list|()
expr_stmt|;
name|numSegments
operator|--
expr_stmt|;
comment|//we ignore this segment for the merge
block|}
block|}
comment|//if we have the desired number of segments
comment|//or looked at all available segments, we break
if|if
condition|(
name|segmentsConsidered
operator|==
name|factor
operator|||
name|sortedSegmentSizes
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|numSegmentsToConsider
operator|=
name|factor
operator|-
name|segmentsConsidered
expr_stmt|;
block|}
comment|//feed the streams to the priority queue
name|initialize
argument_list|(
name|segmentsToMerge
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segmentsToMerge
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|put
argument_list|(
name|segmentsToMerge
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//if we have lesser number of segments remaining, then just return the
comment|//iterator, else do another single level merge
if|if
condition|(
name|numSegments
operator|<=
name|factor
condition|)
block|{
comment|//calculate the length of the remaining segments. Required for
comment|//calculating the merge progress
name|long
name|totalBytes
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segmentsToMerge
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|totalBytes
operator|+=
name|segmentsToMerge
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|segmentLength
expr_stmt|;
block|}
if|if
condition|(
name|totalBytes
operator|!=
literal|0
condition|)
comment|//being paranoid
name|progPerByte
operator|=
literal|1.0f
operator|/
operator|(
name|float
operator|)
name|totalBytes
expr_stmt|;
comment|//reset factor to what it originally was
name|factor
operator|=
name|origFactor
expr_stmt|;
return|return
name|this
return|;
block|}
else|else
block|{
comment|//we want to spread the creation of temp files on multiple disks if
comment|//available under the space constraints
name|long
name|approxOutputSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|SegmentDescriptor
name|s
range|:
name|segmentsToMerge
control|)
block|{
name|approxOutputSize
operator|+=
name|s
operator|.
name|segmentLength
operator|+
name|ChecksumFileSystem
operator|.
name|getApproxChkSumLength
argument_list|(
name|s
operator|.
name|segmentLength
argument_list|)
expr_stmt|;
block|}
name|Path
name|tmpFilename
init|=
operator|new
name|Path
argument_list|(
name|tmpDir
argument_list|,
literal|"intermediate"
argument_list|)
operator|.
name|suffix
argument_list|(
literal|"."
operator|+
name|passNo
argument_list|)
decl_stmt|;
name|Path
name|outputFile
init|=
name|lDirAlloc
operator|.
name|getLocalPathForWrite
argument_list|(
name|tmpFilename
operator|.
name|toString
argument_list|()
argument_list|,
name|approxOutputSize
argument_list|,
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"writing intermediate results to "
operator|+
name|outputFile
argument_list|)
expr_stmt|;
block|}
name|Writer
name|writer
init|=
name|cloneFileAttributes
argument_list|(
name|fs
operator|.
name|makeQualified
argument_list|(
name|segmentsToMerge
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|segmentPathName
argument_list|)
argument_list|,
name|fs
operator|.
name|makeQualified
argument_list|(
name|outputFile
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|writer
operator|.
name|sync
operator|=
literal|null
expr_stmt|;
comment|//disable sync for temp files
name|writeFile
argument_list|(
name|this
argument_list|,
name|writer
argument_list|)
expr_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
comment|//we finished one single level merge; now clean up the priority
comment|//queue
name|this
operator|.
name|close
argument_list|()
expr_stmt|;
name|SegmentDescriptor
name|tempSegment
init|=
operator|new
name|SegmentDescriptor
argument_list|(
literal|0
argument_list|,
name|fs
operator|.
name|getFileStatus
argument_list|(
name|outputFile
argument_list|)
operator|.
name|getLen
argument_list|()
argument_list|,
name|outputFile
argument_list|)
decl_stmt|;
comment|//put the segment back in the TreeMap
name|sortedSegmentSizes
operator|.
name|put
argument_list|(
name|tempSegment
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|numSegments
operator|=
name|sortedSegmentSizes
operator|.
name|size
argument_list|()
expr_stmt|;
name|passNo
operator|++
expr_stmt|;
block|}
comment|//we are worried about only the first pass merge factor. So reset the
comment|//factor to what it originally was
name|factor
operator|=
name|origFactor
expr_stmt|;
block|}
do|while
condition|(
literal|true
condition|)
do|;
block|}
comment|//Hadoop-591
DECL|method|getPassFactor (int passNo, int numSegments)
specifier|public
name|int
name|getPassFactor
parameter_list|(
name|int
name|passNo
parameter_list|,
name|int
name|numSegments
parameter_list|)
block|{
if|if
condition|(
name|passNo
operator|>
literal|1
operator|||
name|numSegments
operator|<=
name|factor
operator|||
name|factor
operator|==
literal|1
condition|)
return|return
name|factor
return|;
name|int
name|mod
init|=
operator|(
name|numSegments
operator|-
literal|1
operator|)
operator|%
operator|(
name|factor
operator|-
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|mod
operator|==
literal|0
condition|)
return|return
name|factor
return|;
return|return
name|mod
operator|+
literal|1
return|;
block|}
comment|/** Return (& remove) the requested number of segment descriptors from the        * sorted map.        */
DECL|method|getSegmentDescriptors (int numDescriptors)
specifier|public
name|SegmentDescriptor
index|[]
name|getSegmentDescriptors
parameter_list|(
name|int
name|numDescriptors
parameter_list|)
block|{
if|if
condition|(
name|numDescriptors
operator|>
name|sortedSegmentSizes
operator|.
name|size
argument_list|()
condition|)
name|numDescriptors
operator|=
name|sortedSegmentSizes
operator|.
name|size
argument_list|()
expr_stmt|;
name|SegmentDescriptor
index|[]
name|SegmentDescriptors
init|=
operator|new
name|SegmentDescriptor
index|[
name|numDescriptors
index|]
decl_stmt|;
name|Iterator
name|iter
init|=
name|sortedSegmentSizes
operator|.
name|keySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|numDescriptors
condition|)
block|{
name|SegmentDescriptors
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|SegmentDescriptor
operator|)
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
return|return
name|SegmentDescriptors
return|;
block|}
block|}
comment|// SequenceFile.Sorter.MergeQueue
comment|/** This class defines a merge segment. This class can be subclassed to       * provide a customized cleanup method implementation. In this       * implementation, cleanup closes the file handle and deletes the file       */
DECL|class|SegmentDescriptor
specifier|public
class|class
name|SegmentDescriptor
implements|implements
name|Comparable
block|{
DECL|field|segmentOffset
name|long
name|segmentOffset
decl_stmt|;
comment|//the start of the segment in the file
DECL|field|segmentLength
name|long
name|segmentLength
decl_stmt|;
comment|//the length of the segment
DECL|field|segmentPathName
name|Path
name|segmentPathName
decl_stmt|;
comment|//the path name of the file containing the segment
DECL|field|ignoreSync
name|boolean
name|ignoreSync
init|=
literal|true
decl_stmt|;
comment|//set to true for temp files
DECL|field|in
specifier|private
name|Reader
name|in
init|=
literal|null
decl_stmt|;
DECL|field|rawKey
specifier|private
name|DataOutputBuffer
name|rawKey
init|=
literal|null
decl_stmt|;
comment|//this will hold the current key
DECL|field|preserveInput
specifier|private
name|boolean
name|preserveInput
init|=
literal|false
decl_stmt|;
comment|//delete input segment files?
comment|/** Constructs a segment        * @param segmentOffset the offset of the segment in the file        * @param segmentLength the length of the segment        * @param segmentPathName the path name of the file containing the segment        */
DECL|method|SegmentDescriptor (long segmentOffset, long segmentLength, Path segmentPathName)
specifier|public
name|SegmentDescriptor
parameter_list|(
name|long
name|segmentOffset
parameter_list|,
name|long
name|segmentLength
parameter_list|,
name|Path
name|segmentPathName
parameter_list|)
block|{
name|this
operator|.
name|segmentOffset
operator|=
name|segmentOffset
expr_stmt|;
name|this
operator|.
name|segmentLength
operator|=
name|segmentLength
expr_stmt|;
name|this
operator|.
name|segmentPathName
operator|=
name|segmentPathName
expr_stmt|;
block|}
comment|/** Do the sync checks */
DECL|method|doSync ()
specifier|public
name|void
name|doSync
parameter_list|()
block|{
name|ignoreSync
operator|=
literal|false
expr_stmt|;
block|}
comment|/** Whether to delete the files when no longer needed */
DECL|method|preserveInput (boolean preserve)
specifier|public
name|void
name|preserveInput
parameter_list|(
name|boolean
name|preserve
parameter_list|)
block|{
name|preserveInput
operator|=
name|preserve
expr_stmt|;
block|}
DECL|method|shouldPreserveInput ()
specifier|public
name|boolean
name|shouldPreserveInput
parameter_list|()
block|{
return|return
name|preserveInput
return|;
block|}
annotation|@
name|Override
DECL|method|compareTo (Object o)
specifier|public
name|int
name|compareTo
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|SegmentDescriptor
name|that
init|=
operator|(
name|SegmentDescriptor
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|segmentLength
operator|!=
name|that
operator|.
name|segmentLength
condition|)
block|{
return|return
operator|(
name|this
operator|.
name|segmentLength
operator|<
name|that
operator|.
name|segmentLength
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|this
operator|.
name|segmentOffset
operator|!=
name|that
operator|.
name|segmentOffset
condition|)
block|{
return|return
operator|(
name|this
operator|.
name|segmentOffset
operator|<
name|that
operator|.
name|segmentOffset
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|this
operator|.
name|segmentPathName
operator|.
name|toString
argument_list|()
operator|)
operator|.
name|compareTo
argument_list|(
name|that
operator|.
name|segmentPathName
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|SegmentDescriptor
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|SegmentDescriptor
name|that
init|=
operator|(
name|SegmentDescriptor
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|segmentLength
operator|==
name|that
operator|.
name|segmentLength
operator|&&
name|this
operator|.
name|segmentOffset
operator|==
name|that
operator|.
name|segmentOffset
operator|&&
name|this
operator|.
name|segmentPathName
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|that
operator|.
name|segmentPathName
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
literal|37
operator|*
literal|17
operator|+
call|(
name|int
call|)
argument_list|(
name|segmentOffset
operator|^
operator|(
name|segmentOffset
operator|>>>
literal|32
operator|)
argument_list|)
return|;
block|}
comment|/** Fills up the rawKey object with the key returned by the Reader        * @return true if there is a key returned; false, otherwise        * @throws IOException        */
DECL|method|nextRawKey ()
specifier|public
name|boolean
name|nextRawKey
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|in
operator|==
literal|null
condition|)
block|{
name|int
name|bufferSize
init|=
name|getBufferSize
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|Reader
name|reader
init|=
operator|new
name|Reader
argument_list|(
name|conf
argument_list|,
name|Reader
operator|.
name|file
argument_list|(
name|segmentPathName
argument_list|)
argument_list|,
name|Reader
operator|.
name|bufferSize
argument_list|(
name|bufferSize
argument_list|)
argument_list|,
name|Reader
operator|.
name|start
argument_list|(
name|segmentOffset
argument_list|)
argument_list|,
name|Reader
operator|.
name|length
argument_list|(
name|segmentLength
argument_list|)
argument_list|)
decl_stmt|;
comment|//sometimes we ignore syncs especially for temp merge files
if|if
condition|(
name|ignoreSync
condition|)
name|reader
operator|.
name|ignoreSync
argument_list|()
expr_stmt|;
if|if
condition|(
name|reader
operator|.
name|getKeyClass
argument_list|()
operator|!=
name|keyClass
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"wrong key class: "
operator|+
name|reader
operator|.
name|getKeyClass
argument_list|()
operator|+
literal|" is not "
operator|+
name|keyClass
argument_list|)
throw|;
if|if
condition|(
name|reader
operator|.
name|getValueClass
argument_list|()
operator|!=
name|valClass
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"wrong value class: "
operator|+
name|reader
operator|.
name|getValueClass
argument_list|()
operator|+
literal|" is not "
operator|+
name|valClass
argument_list|)
throw|;
name|this
operator|.
name|in
operator|=
name|reader
expr_stmt|;
name|rawKey
operator|=
operator|new
name|DataOutputBuffer
argument_list|()
expr_stmt|;
block|}
name|rawKey
operator|.
name|reset
argument_list|()
expr_stmt|;
name|int
name|keyLength
init|=
name|in
operator|.
name|nextRawKey
argument_list|(
name|rawKey
argument_list|)
decl_stmt|;
return|return
operator|(
name|keyLength
operator|>=
literal|0
operator|)
return|;
block|}
comment|/** Fills up the passed rawValue with the value corresponding to the key        * read earlier        * @param rawValue        * @return the length of the value        * @throws IOException        */
DECL|method|nextRawValue (ValueBytes rawValue)
specifier|public
name|int
name|nextRawValue
parameter_list|(
name|ValueBytes
name|rawValue
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|valLength
init|=
name|in
operator|.
name|nextRawValue
argument_list|(
name|rawValue
argument_list|)
decl_stmt|;
return|return
name|valLength
return|;
block|}
comment|/** Returns the stored rawKey */
DECL|method|getKey ()
specifier|public
name|DataOutputBuffer
name|getKey
parameter_list|()
block|{
return|return
name|rawKey
return|;
block|}
comment|/** closes the underlying reader */
DECL|method|close ()
specifier|private
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|in
operator|=
literal|null
expr_stmt|;
block|}
comment|/** The default cleanup. Subclasses can override this with a custom         * cleanup         */
DECL|method|cleanup ()
specifier|public
name|void
name|cleanup
parameter_list|()
throws|throws
name|IOException
block|{
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|preserveInput
condition|)
block|{
name|fs
operator|.
name|delete
argument_list|(
name|segmentPathName
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// SequenceFile.Sorter.SegmentDescriptor
comment|/** This class provisions multiple segments contained within a single      *  file      */
DECL|class|LinkedSegmentsDescriptor
specifier|private
class|class
name|LinkedSegmentsDescriptor
extends|extends
name|SegmentDescriptor
block|{
DECL|field|parentContainer
name|SegmentContainer
name|parentContainer
init|=
literal|null
decl_stmt|;
comment|/** Constructs a segment        * @param segmentOffset the offset of the segment in the file        * @param segmentLength the length of the segment        * @param segmentPathName the path name of the file containing the segment        * @param parent the parent SegmentContainer that holds the segment        */
DECL|method|LinkedSegmentsDescriptor (long segmentOffset, long segmentLength, Path segmentPathName, SegmentContainer parent)
specifier|public
name|LinkedSegmentsDescriptor
parameter_list|(
name|long
name|segmentOffset
parameter_list|,
name|long
name|segmentLength
parameter_list|,
name|Path
name|segmentPathName
parameter_list|,
name|SegmentContainer
name|parent
parameter_list|)
block|{
name|super
argument_list|(
name|segmentOffset
argument_list|,
name|segmentLength
argument_list|,
name|segmentPathName
argument_list|)
expr_stmt|;
name|this
operator|.
name|parentContainer
operator|=
name|parent
expr_stmt|;
block|}
comment|/** The default cleanup. Subclasses can override this with a custom         * cleanup         */
annotation|@
name|Override
DECL|method|cleanup ()
specifier|public
name|void
name|cleanup
parameter_list|()
throws|throws
name|IOException
block|{
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|super
operator|.
name|shouldPreserveInput
argument_list|()
condition|)
return|return;
name|parentContainer
operator|.
name|cleanup
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|LinkedSegmentsDescriptor
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|super
operator|.
name|equals
argument_list|(
name|o
argument_list|)
return|;
block|}
block|}
comment|//SequenceFile.Sorter.LinkedSegmentsDescriptor
comment|/** The class that defines a container for segments to be merged. Primarily      * required to delete temp files as soon as all the contained segments      * have been looked at */
DECL|class|SegmentContainer
specifier|private
class|class
name|SegmentContainer
block|{
DECL|field|numSegmentsCleanedUp
specifier|private
name|int
name|numSegmentsCleanedUp
init|=
literal|0
decl_stmt|;
comment|//track the no. of segment cleanups
DECL|field|numSegmentsContained
specifier|private
name|int
name|numSegmentsContained
decl_stmt|;
comment|//# of segments contained
DECL|field|inName
specifier|private
name|Path
name|inName
decl_stmt|;
comment|//input file from where segments are created
comment|//the list of segments read from the file
DECL|field|segments
specifier|private
name|ArrayList
argument_list|<
name|SegmentDescriptor
argument_list|>
name|segments
init|=
operator|new
name|ArrayList
argument_list|<
name|SegmentDescriptor
argument_list|>
argument_list|()
decl_stmt|;
comment|/** This constructor is there primarily to serve the sort routine that         * generates a single output file with an associated index file */
DECL|method|SegmentContainer (Path inName, Path indexIn)
specifier|public
name|SegmentContainer
parameter_list|(
name|Path
name|inName
parameter_list|,
name|Path
name|indexIn
parameter_list|)
throws|throws
name|IOException
block|{
comment|//get the segments from indexIn
name|FSDataInputStream
name|fsIndexIn
init|=
name|fs
operator|.
name|open
argument_list|(
name|indexIn
argument_list|)
decl_stmt|;
name|long
name|end
init|=
name|fs
operator|.
name|getFileStatus
argument_list|(
name|indexIn
argument_list|)
operator|.
name|getLen
argument_list|()
decl_stmt|;
while|while
condition|(
name|fsIndexIn
operator|.
name|getPos
argument_list|()
operator|<
name|end
condition|)
block|{
name|long
name|segmentOffset
init|=
name|WritableUtils
operator|.
name|readVLong
argument_list|(
name|fsIndexIn
argument_list|)
decl_stmt|;
name|long
name|segmentLength
init|=
name|WritableUtils
operator|.
name|readVLong
argument_list|(
name|fsIndexIn
argument_list|)
decl_stmt|;
name|Path
name|segmentName
init|=
name|inName
decl_stmt|;
name|segments
operator|.
name|add
argument_list|(
operator|new
name|LinkedSegmentsDescriptor
argument_list|(
name|segmentOffset
argument_list|,
name|segmentLength
argument_list|,
name|segmentName
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fsIndexIn
operator|.
name|close
argument_list|()
expr_stmt|;
name|fs
operator|.
name|delete
argument_list|(
name|indexIn
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|numSegmentsContained
operator|=
name|segments
operator|.
name|size
argument_list|()
expr_stmt|;
name|this
operator|.
name|inName
operator|=
name|inName
expr_stmt|;
block|}
DECL|method|getSegmentList ()
specifier|public
name|List
argument_list|<
name|SegmentDescriptor
argument_list|>
name|getSegmentList
parameter_list|()
block|{
return|return
name|segments
return|;
block|}
DECL|method|cleanup ()
specifier|public
name|void
name|cleanup
parameter_list|()
throws|throws
name|IOException
block|{
name|numSegmentsCleanedUp
operator|++
expr_stmt|;
if|if
condition|(
name|numSegmentsCleanedUp
operator|==
name|numSegmentsContained
condition|)
block|{
name|fs
operator|.
name|delete
argument_list|(
name|inName
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|//SequenceFile.Sorter.SegmentContainer
block|}
comment|// SequenceFile.Sorter
block|}
end_class

begin_comment
comment|// SequenceFile
end_comment

end_unit

