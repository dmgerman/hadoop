begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|HadoopIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
operator|.
name|Statistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
operator|.
name|ChecksumOpt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
operator|.
name|CreateOpts
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
operator|.
name|Rename
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|InvalidPathException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SecurityUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Progressable
import|;
end_import

begin_comment
comment|/**  * This class provides an interface for implementors of a Hadoop file system  * (analogous to the VFS of Unix). Applications do not access this class;  * instead they access files across all file systems using {@link FileContext}.  *   * Pathnames passed to AbstractFileSystem can be fully qualified URI that  * matches the "this" file system (ie same scheme and authority)   * or a Slash-relative name that is assumed to be relative  * to the root of the "this" file system .  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
comment|/*Evolving for a release,to be changed to Stable */
DECL|class|AbstractFileSystem
specifier|public
specifier|abstract
class|class
name|AbstractFileSystem
block|{
DECL|field|LOG
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|AbstractFileSystem
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** Recording statistics per a file system class. */
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|URI
argument_list|,
name|Statistics
argument_list|>
DECL|field|STATISTICS_TABLE
name|STATISTICS_TABLE
init|=
operator|new
name|HashMap
argument_list|<
name|URI
argument_list|,
name|Statistics
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Cache of constructors for each file system class. */
DECL|field|CONSTRUCTOR_CACHE
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|Constructor
argument_list|<
name|?
argument_list|>
argument_list|>
name|CONSTRUCTOR_CACHE
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|Constructor
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|URI_CONFIG_ARGS
specifier|private
specifier|static
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|URI_CONFIG_ARGS
init|=
operator|new
name|Class
index|[]
block|{
name|URI
operator|.
name|class
block|,
name|Configuration
operator|.
name|class
block|}
decl_stmt|;
comment|/** The statistics for this file system. */
DECL|field|statistics
specifier|protected
name|Statistics
name|statistics
decl_stmt|;
DECL|field|myUri
specifier|private
specifier|final
name|URI
name|myUri
decl_stmt|;
DECL|method|getStatistics ()
specifier|public
name|Statistics
name|getStatistics
parameter_list|()
block|{
return|return
name|statistics
return|;
block|}
comment|/**    * Returns true if the specified string is considered valid in the path part    * of a URI by this file system.  The default implementation enforces the rules    * of HDFS, but subclasses may override this method to implement specific    * validation rules for specific file systems.    *     * @param src String source filename to check, path part of the URI    * @return boolean true if the specified string is considered valid    */
DECL|method|isValidName (String src)
specifier|public
name|boolean
name|isValidName
parameter_list|(
name|String
name|src
parameter_list|)
block|{
comment|// Prohibit ".." "." and anything containing ":"
name|StringTokenizer
name|tokens
init|=
operator|new
name|StringTokenizer
argument_list|(
name|src
argument_list|,
name|Path
operator|.
name|SEPARATOR
argument_list|)
decl_stmt|;
while|while
condition|(
name|tokens
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|element
init|=
name|tokens
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|element
operator|.
name|equals
argument_list|(
literal|".."
argument_list|)
operator|||
name|element
operator|.
name|equals
argument_list|(
literal|"."
argument_list|)
operator|||
operator|(
name|element
operator|.
name|indexOf
argument_list|(
literal|":"
argument_list|)
operator|>=
literal|0
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**     * Create an object for the given class and initialize it from conf.    * @param theClass class of which an object is created    * @param conf Configuration    * @return a new object    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|newInstance (Class<T> theClass, URI uri, Configuration conf)
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|newInstance
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|theClass
parameter_list|,
name|URI
name|uri
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|T
name|result
decl_stmt|;
try|try
block|{
name|Constructor
argument_list|<
name|T
argument_list|>
name|meth
init|=
operator|(
name|Constructor
argument_list|<
name|T
argument_list|>
operator|)
name|CONSTRUCTOR_CACHE
operator|.
name|get
argument_list|(
name|theClass
argument_list|)
decl_stmt|;
if|if
condition|(
name|meth
operator|==
literal|null
condition|)
block|{
name|meth
operator|=
name|theClass
operator|.
name|getDeclaredConstructor
argument_list|(
name|URI_CONFIG_ARGS
argument_list|)
expr_stmt|;
name|meth
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|CONSTRUCTOR_CACHE
operator|.
name|put
argument_list|(
name|theClass
argument_list|,
name|meth
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|meth
operator|.
name|newInstance
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Create a file system instance for the specified uri using the conf. The    * conf is used to find the class name that implements the file system. The    * conf is also passed to the file system for its configuration.    *    * @param uri URI of the file system    * @param conf Configuration for the file system    *     * @return Returns the file system for the given URI    *    * @throws UnsupportedFileSystemException file system for<code>uri</code> is    *           not found    */
DECL|method|createFileSystem (URI uri, Configuration conf)
specifier|public
specifier|static
name|AbstractFileSystem
name|createFileSystem
parameter_list|(
name|URI
name|uri
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|UnsupportedFileSystemException
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|conf
operator|.
name|getClass
argument_list|(
literal|"fs.AbstractFileSystem."
operator|+
name|uri
operator|.
name|getScheme
argument_list|()
operator|+
literal|".impl"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|clazz
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnsupportedFileSystemException
argument_list|(
literal|"No AbstractFileSystem for scheme: "
operator|+
name|uri
operator|.
name|getScheme
argument_list|()
argument_list|)
throw|;
block|}
return|return
operator|(
name|AbstractFileSystem
operator|)
name|newInstance
argument_list|(
name|clazz
argument_list|,
name|uri
argument_list|,
name|conf
argument_list|)
return|;
block|}
comment|/**    * Get the statistics for a particular file system.    *     * @param uri    *          used as key to lookup STATISTICS_TABLE. Only scheme and authority    *          part of the uri are used.    * @return a statistics object    */
DECL|method|getStatistics (URI uri)
specifier|protected
specifier|static
specifier|synchronized
name|Statistics
name|getStatistics
parameter_list|(
name|URI
name|uri
parameter_list|)
block|{
name|String
name|scheme
init|=
name|uri
operator|.
name|getScheme
argument_list|()
decl_stmt|;
if|if
condition|(
name|scheme
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Scheme not defined in the uri: "
operator|+
name|uri
argument_list|)
throw|;
block|}
name|URI
name|baseUri
init|=
name|getBaseUri
argument_list|(
name|uri
argument_list|)
decl_stmt|;
name|Statistics
name|result
init|=
name|STATISTICS_TABLE
operator|.
name|get
argument_list|(
name|baseUri
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|result
operator|=
operator|new
name|Statistics
argument_list|(
name|scheme
argument_list|)
expr_stmt|;
name|STATISTICS_TABLE
operator|.
name|put
argument_list|(
name|baseUri
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|getBaseUri (URI uri)
specifier|private
specifier|static
name|URI
name|getBaseUri
parameter_list|(
name|URI
name|uri
parameter_list|)
block|{
name|String
name|scheme
init|=
name|uri
operator|.
name|getScheme
argument_list|()
decl_stmt|;
name|String
name|authority
init|=
name|uri
operator|.
name|getAuthority
argument_list|()
decl_stmt|;
name|String
name|baseUriString
init|=
name|scheme
operator|+
literal|"://"
decl_stmt|;
if|if
condition|(
name|authority
operator|!=
literal|null
condition|)
block|{
name|baseUriString
operator|=
name|baseUriString
operator|+
name|authority
expr_stmt|;
block|}
else|else
block|{
name|baseUriString
operator|=
name|baseUriString
operator|+
literal|"/"
expr_stmt|;
block|}
return|return
name|URI
operator|.
name|create
argument_list|(
name|baseUriString
argument_list|)
return|;
block|}
DECL|method|clearStatistics ()
specifier|public
specifier|static
specifier|synchronized
name|void
name|clearStatistics
parameter_list|()
block|{
for|for
control|(
name|Statistics
name|stat
range|:
name|STATISTICS_TABLE
operator|.
name|values
argument_list|()
control|)
block|{
name|stat
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Prints statistics for all file systems.    */
DECL|method|printStatistics ()
specifier|public
specifier|static
specifier|synchronized
name|void
name|printStatistics
parameter_list|()
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|URI
argument_list|,
name|Statistics
argument_list|>
name|pair
range|:
name|STATISTICS_TABLE
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  FileSystem "
operator|+
name|pair
operator|.
name|getKey
argument_list|()
operator|.
name|getScheme
argument_list|()
operator|+
literal|"://"
operator|+
name|pair
operator|.
name|getKey
argument_list|()
operator|.
name|getAuthority
argument_list|()
operator|+
literal|": "
operator|+
name|pair
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getAllStatistics ()
specifier|protected
specifier|static
specifier|synchronized
name|Map
argument_list|<
name|URI
argument_list|,
name|Statistics
argument_list|>
name|getAllStatistics
parameter_list|()
block|{
name|Map
argument_list|<
name|URI
argument_list|,
name|Statistics
argument_list|>
name|statsMap
init|=
operator|new
name|HashMap
argument_list|<
name|URI
argument_list|,
name|Statistics
argument_list|>
argument_list|(
name|STATISTICS_TABLE
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|URI
argument_list|,
name|Statistics
argument_list|>
name|pair
range|:
name|STATISTICS_TABLE
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|URI
name|key
init|=
name|pair
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Statistics
name|value
init|=
name|pair
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Statistics
name|newStatsObj
init|=
operator|new
name|Statistics
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|statsMap
operator|.
name|put
argument_list|(
name|URI
operator|.
name|create
argument_list|(
name|key
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|,
name|newStatsObj
argument_list|)
expr_stmt|;
block|}
return|return
name|statsMap
return|;
block|}
comment|/**    * The main factory method for creating a file system. Get a file system for    * the URI's scheme and authority. The scheme of the<code>uri</code>    * determines a configuration property name,    *<tt>fs.AbstractFileSystem.<i>scheme</i>.impl</tt> whose value names the    * AbstractFileSystem class.    *     * The entire URI and conf is passed to the AbstractFileSystem factory method.    *     * @param uri for the file system to be created.    * @param conf which is passed to the file system impl.    *     * @return file system for the given URI.    *     * @throws UnsupportedFileSystemException if the file system for    *<code>uri</code> is not supported.    */
DECL|method|get (final URI uri, final Configuration conf)
specifier|public
specifier|static
name|AbstractFileSystem
name|get
parameter_list|(
specifier|final
name|URI
name|uri
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|UnsupportedFileSystemException
block|{
return|return
name|createFileSystem
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
return|;
block|}
comment|/**    * Constructor to be called by subclasses.    *     * @param uri for this file system.    * @param supportedScheme the scheme supported by the implementor    * @param authorityNeeded if true then theURI must have authority, if false    *          then the URI must have null authority.    *    * @throws URISyntaxException<code>uri</code> has syntax error    */
DECL|method|AbstractFileSystem (final URI uri, final String supportedScheme, final boolean authorityNeeded, final int defaultPort)
specifier|public
name|AbstractFileSystem
parameter_list|(
specifier|final
name|URI
name|uri
parameter_list|,
specifier|final
name|String
name|supportedScheme
parameter_list|,
specifier|final
name|boolean
name|authorityNeeded
parameter_list|,
specifier|final
name|int
name|defaultPort
parameter_list|)
throws|throws
name|URISyntaxException
block|{
name|myUri
operator|=
name|getUri
argument_list|(
name|uri
argument_list|,
name|supportedScheme
argument_list|,
name|authorityNeeded
argument_list|,
name|defaultPort
argument_list|)
expr_stmt|;
name|statistics
operator|=
name|getStatistics
argument_list|(
name|uri
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check that the Uri's scheme matches    * @param uri    * @param supportedScheme    */
DECL|method|checkScheme (URI uri, String supportedScheme)
specifier|public
name|void
name|checkScheme
parameter_list|(
name|URI
name|uri
parameter_list|,
name|String
name|supportedScheme
parameter_list|)
block|{
name|String
name|scheme
init|=
name|uri
operator|.
name|getScheme
argument_list|()
decl_stmt|;
if|if
condition|(
name|scheme
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Uri without scheme: "
operator|+
name|uri
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|scheme
operator|.
name|equals
argument_list|(
name|supportedScheme
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Uri scheme "
operator|+
name|uri
operator|+
literal|" does not match the scheme "
operator|+
name|supportedScheme
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get the URI for the file system based on the given URI. The path, query    * part of the given URI is stripped out and default file system port is used    * to form the URI.    *     * @param uri FileSystem URI.    * @param authorityNeeded if true authority cannot be null in the URI. If    *          false authority must be null.    * @param defaultPort default port to use if port is not specified in the URI.    *     * @return URI of the file system    *     * @throws URISyntaxException<code>uri</code> has syntax error    */
DECL|method|getUri (URI uri, String supportedScheme, boolean authorityNeeded, int defaultPort)
specifier|private
name|URI
name|getUri
parameter_list|(
name|URI
name|uri
parameter_list|,
name|String
name|supportedScheme
parameter_list|,
name|boolean
name|authorityNeeded
parameter_list|,
name|int
name|defaultPort
parameter_list|)
throws|throws
name|URISyntaxException
block|{
name|checkScheme
argument_list|(
name|uri
argument_list|,
name|supportedScheme
argument_list|)
expr_stmt|;
comment|// A file system implementation that requires authority must always
comment|// specify default port
if|if
condition|(
name|defaultPort
operator|<
literal|0
operator|&&
name|authorityNeeded
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"FileSystem implementation error -  default port "
operator|+
name|defaultPort
operator|+
literal|" is not valid"
argument_list|)
throw|;
block|}
name|String
name|authority
init|=
name|uri
operator|.
name|getAuthority
argument_list|()
decl_stmt|;
if|if
condition|(
name|authority
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|authorityNeeded
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Uri without authority: "
operator|+
name|uri
argument_list|)
throw|;
block|}
else|else
block|{
return|return
operator|new
name|URI
argument_list|(
name|supportedScheme
operator|+
literal|":///"
argument_list|)
return|;
block|}
block|}
comment|// authority is non null  - AuthorityNeeded may be true or false.
name|int
name|port
init|=
name|uri
operator|.
name|getPort
argument_list|()
decl_stmt|;
name|port
operator|=
operator|(
name|port
operator|==
operator|-
literal|1
condition|?
name|defaultPort
else|:
name|port
operator|)
expr_stmt|;
if|if
condition|(
name|port
operator|==
operator|-
literal|1
condition|)
block|{
comment|// no port supplied and default port is not specified
return|return
operator|new
name|URI
argument_list|(
name|supportedScheme
argument_list|,
name|authority
argument_list|,
literal|"/"
argument_list|,
literal|null
argument_list|)
return|;
block|}
return|return
operator|new
name|URI
argument_list|(
name|supportedScheme
operator|+
literal|"://"
operator|+
name|uri
operator|.
name|getHost
argument_list|()
operator|+
literal|":"
operator|+
name|port
argument_list|)
return|;
block|}
comment|/**    * The default port of this file system.    *     * @return default port of this file system's Uri scheme    *         A uri with a port of -1 => default port;    */
DECL|method|getUriDefaultPort ()
specifier|public
specifier|abstract
name|int
name|getUriDefaultPort
parameter_list|()
function_decl|;
comment|/**    * Returns a URI whose scheme and authority identify this FileSystem.    *     * @return the uri of this file system.    */
DECL|method|getUri ()
specifier|public
name|URI
name|getUri
parameter_list|()
block|{
return|return
name|myUri
return|;
block|}
comment|/**    * Check that a Path belongs to this FileSystem.    *     * If the path is fully qualified URI, then its scheme and authority    * matches that of this file system. Otherwise the path must be     * slash-relative name.    *     * @throws InvalidPathException if the path is invalid    */
DECL|method|checkPath (Path path)
specifier|public
name|void
name|checkPath
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
name|URI
name|uri
init|=
name|path
operator|.
name|toUri
argument_list|()
decl_stmt|;
name|String
name|thatScheme
init|=
name|uri
operator|.
name|getScheme
argument_list|()
decl_stmt|;
name|String
name|thatAuthority
init|=
name|uri
operator|.
name|getAuthority
argument_list|()
decl_stmt|;
if|if
condition|(
name|thatScheme
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|thatAuthority
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|path
operator|.
name|isUriPathAbsolute
argument_list|()
condition|)
block|{
return|return;
block|}
throw|throw
operator|new
name|InvalidPathException
argument_list|(
literal|"relative paths not allowed:"
operator|+
name|path
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|InvalidPathException
argument_list|(
literal|"Path without scheme with non-null authority:"
operator|+
name|path
argument_list|)
throw|;
block|}
block|}
name|String
name|thisScheme
init|=
name|this
operator|.
name|getUri
argument_list|()
operator|.
name|getScheme
argument_list|()
decl_stmt|;
name|String
name|thisHost
init|=
name|this
operator|.
name|getUri
argument_list|()
operator|.
name|getHost
argument_list|()
decl_stmt|;
name|String
name|thatHost
init|=
name|uri
operator|.
name|getHost
argument_list|()
decl_stmt|;
comment|// Schemes and hosts must match.
comment|// Allow for null Authority for file:///
if|if
condition|(
operator|!
name|thisScheme
operator|.
name|equalsIgnoreCase
argument_list|(
name|thatScheme
argument_list|)
operator|||
operator|(
name|thisHost
operator|!=
literal|null
operator|&&
operator|!
name|thisHost
operator|.
name|equalsIgnoreCase
argument_list|(
name|thatHost
argument_list|)
operator|)
operator|||
operator|(
name|thisHost
operator|==
literal|null
operator|&&
name|thatHost
operator|!=
literal|null
operator|)
condition|)
block|{
throw|throw
operator|new
name|InvalidPathException
argument_list|(
literal|"Wrong FS: "
operator|+
name|path
operator|+
literal|", expected: "
operator|+
name|this
operator|.
name|getUri
argument_list|()
argument_list|)
throw|;
block|}
comment|// Ports must match, unless this FS instance is using the default port, in
comment|// which case the port may be omitted from the given URI
name|int
name|thisPort
init|=
name|this
operator|.
name|getUri
argument_list|()
operator|.
name|getPort
argument_list|()
decl_stmt|;
name|int
name|thatPort
init|=
name|uri
operator|.
name|getPort
argument_list|()
decl_stmt|;
if|if
condition|(
name|thatPort
operator|==
operator|-
literal|1
condition|)
block|{
comment|// -1 => defaultPort of Uri scheme
name|thatPort
operator|=
name|this
operator|.
name|getUriDefaultPort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|thisPort
operator|!=
name|thatPort
condition|)
block|{
throw|throw
operator|new
name|InvalidPathException
argument_list|(
literal|"Wrong FS: "
operator|+
name|path
operator|+
literal|", expected: "
operator|+
name|this
operator|.
name|getUri
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get the path-part of a pathname. Checks that URI matches this file system    * and that the path-part is a valid name.    *     * @param p path    *     * @return path-part of the Path p    */
DECL|method|getUriPath (final Path p)
specifier|public
name|String
name|getUriPath
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
block|{
name|checkPath
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|String
name|s
init|=
name|p
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|isValidName
argument_list|(
name|s
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InvalidPathException
argument_list|(
literal|"Path part "
operator|+
name|s
operator|+
literal|" from URI "
operator|+
name|p
operator|+
literal|" is not a valid filename."
argument_list|)
throw|;
block|}
return|return
name|s
return|;
block|}
comment|/**    * Make the path fully qualified to this file system    * @param path    * @return the qualified path    */
DECL|method|makeQualified (Path path)
specifier|public
name|Path
name|makeQualified
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
name|checkPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|path
operator|.
name|makeQualified
argument_list|(
name|this
operator|.
name|getUri
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Some file systems like LocalFileSystem have an initial workingDir    * that is used as the starting workingDir. For other file systems    * like HDFS there is no built in notion of an initial workingDir.    *     * @return the initial workingDir if the file system has such a notion    *         otherwise return a null.    */
DECL|method|getInitialWorkingDirectory ()
specifier|public
name|Path
name|getInitialWorkingDirectory
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
comment|/**     * Return the current user's home directory in this file system.    * The default implementation returns "/user/$USER/".    *     * @return current user's home directory.    */
DECL|method|getHomeDirectory ()
specifier|public
name|Path
name|getHomeDirectory
parameter_list|()
block|{
return|return
operator|new
name|Path
argument_list|(
literal|"/user/"
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"user.name"
argument_list|)
argument_list|)
operator|.
name|makeQualified
argument_list|(
name|getUri
argument_list|()
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Return a set of server default configuration values.    *     * @return server default configuration values    *     * @throws IOException an I/O error occurred    */
DECL|method|getServerDefaults ()
specifier|public
specifier|abstract
name|FsServerDefaults
name|getServerDefaults
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**    * Return the fully-qualified path of path f resolving the path    * through any internal symlinks or mount point    * @param p path to be resolved    * @return fully qualified path     * @throws FileNotFoundException, AccessControlException, IOException    *         UnresolvedLinkException if symbolic link on path cannot be resolved    *          internally    */
DECL|method|resolvePath (final Path p)
specifier|public
name|Path
name|resolvePath
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|AccessControlException
throws|,
name|IOException
block|{
name|checkPath
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|getFileStatus
argument_list|(
name|p
argument_list|)
operator|.
name|getPath
argument_list|()
return|;
comment|// default impl is to return the path
block|}
comment|/**    * The specification of this method matches that of    * {@link FileContext#create(Path, EnumSet, Options.CreateOpts...)} except    * that the Path f must be fully qualified and the permission is absolute    * (i.e. umask has been applied).    */
DECL|method|create (final Path f, final EnumSet<CreateFlag> createFlag, Options.CreateOpts... opts)
specifier|public
specifier|final
name|FSDataOutputStream
name|create
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|createFlag
parameter_list|,
name|Options
operator|.
name|CreateOpts
modifier|...
name|opts
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileAlreadyExistsException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|UnsupportedFileSystemException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
name|checkPath
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|int
name|bufferSize
init|=
operator|-
literal|1
decl_stmt|;
name|short
name|replication
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|blockSize
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|bytesPerChecksum
init|=
operator|-
literal|1
decl_stmt|;
name|ChecksumOpt
name|checksumOpt
init|=
literal|null
decl_stmt|;
name|FsPermission
name|permission
init|=
literal|null
decl_stmt|;
name|Progressable
name|progress
init|=
literal|null
decl_stmt|;
name|Boolean
name|createParent
init|=
literal|null
decl_stmt|;
for|for
control|(
name|CreateOpts
name|iOpt
range|:
name|opts
control|)
block|{
if|if
condition|(
name|CreateOpts
operator|.
name|BlockSize
operator|.
name|class
operator|.
name|isInstance
argument_list|(
name|iOpt
argument_list|)
condition|)
block|{
if|if
condition|(
name|blockSize
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"BlockSize option is set multiple times"
argument_list|)
throw|;
block|}
name|blockSize
operator|=
operator|(
operator|(
name|CreateOpts
operator|.
name|BlockSize
operator|)
name|iOpt
operator|)
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CreateOpts
operator|.
name|BufferSize
operator|.
name|class
operator|.
name|isInstance
argument_list|(
name|iOpt
argument_list|)
condition|)
block|{
if|if
condition|(
name|bufferSize
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"BufferSize option is set multiple times"
argument_list|)
throw|;
block|}
name|bufferSize
operator|=
operator|(
operator|(
name|CreateOpts
operator|.
name|BufferSize
operator|)
name|iOpt
operator|)
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CreateOpts
operator|.
name|ReplicationFactor
operator|.
name|class
operator|.
name|isInstance
argument_list|(
name|iOpt
argument_list|)
condition|)
block|{
if|if
condition|(
name|replication
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"ReplicationFactor option is set multiple times"
argument_list|)
throw|;
block|}
name|replication
operator|=
operator|(
operator|(
name|CreateOpts
operator|.
name|ReplicationFactor
operator|)
name|iOpt
operator|)
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CreateOpts
operator|.
name|BytesPerChecksum
operator|.
name|class
operator|.
name|isInstance
argument_list|(
name|iOpt
argument_list|)
condition|)
block|{
if|if
condition|(
name|bytesPerChecksum
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"BytesPerChecksum option is set multiple times"
argument_list|)
throw|;
block|}
name|bytesPerChecksum
operator|=
operator|(
operator|(
name|CreateOpts
operator|.
name|BytesPerChecksum
operator|)
name|iOpt
operator|)
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CreateOpts
operator|.
name|ChecksumParam
operator|.
name|class
operator|.
name|isInstance
argument_list|(
name|iOpt
argument_list|)
condition|)
block|{
if|if
condition|(
name|checksumOpt
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"CreateChecksumType option is set multiple times"
argument_list|)
throw|;
block|}
name|checksumOpt
operator|=
operator|(
operator|(
name|CreateOpts
operator|.
name|ChecksumParam
operator|)
name|iOpt
operator|)
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CreateOpts
operator|.
name|Perms
operator|.
name|class
operator|.
name|isInstance
argument_list|(
name|iOpt
argument_list|)
condition|)
block|{
if|if
condition|(
name|permission
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Perms option is set multiple times"
argument_list|)
throw|;
block|}
name|permission
operator|=
operator|(
operator|(
name|CreateOpts
operator|.
name|Perms
operator|)
name|iOpt
operator|)
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CreateOpts
operator|.
name|Progress
operator|.
name|class
operator|.
name|isInstance
argument_list|(
name|iOpt
argument_list|)
condition|)
block|{
if|if
condition|(
name|progress
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Progress option is set multiple times"
argument_list|)
throw|;
block|}
name|progress
operator|=
operator|(
operator|(
name|CreateOpts
operator|.
name|Progress
operator|)
name|iOpt
operator|)
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CreateOpts
operator|.
name|CreateParent
operator|.
name|class
operator|.
name|isInstance
argument_list|(
name|iOpt
argument_list|)
condition|)
block|{
if|if
condition|(
name|createParent
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"CreateParent option is set multiple times"
argument_list|)
throw|;
block|}
name|createParent
operator|=
operator|(
operator|(
name|CreateOpts
operator|.
name|CreateParent
operator|)
name|iOpt
operator|)
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Unkown CreateOpts of type "
operator|+
name|iOpt
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|permission
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"no permission supplied"
argument_list|)
throw|;
block|}
name|FsServerDefaults
name|ssDef
init|=
name|getServerDefaults
argument_list|()
decl_stmt|;
if|if
condition|(
name|ssDef
operator|.
name|getBlockSize
argument_list|()
operator|%
name|ssDef
operator|.
name|getBytesPerChecksum
argument_list|()
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Internal error: default blockSize is"
operator|+
literal|" not a multiple of default bytesPerChecksum "
argument_list|)
throw|;
block|}
if|if
condition|(
name|blockSize
operator|==
operator|-
literal|1
condition|)
block|{
name|blockSize
operator|=
name|ssDef
operator|.
name|getBlockSize
argument_list|()
expr_stmt|;
block|}
comment|// Create a checksum option honoring user input as much as possible.
comment|// If bytesPerChecksum is specified, it will override the one set in
comment|// checksumOpt. Any missing value will be filled in using the default.
name|ChecksumOpt
name|defaultOpt
init|=
operator|new
name|ChecksumOpt
argument_list|(
name|ssDef
operator|.
name|getChecksumType
argument_list|()
argument_list|,
name|ssDef
operator|.
name|getBytesPerChecksum
argument_list|()
argument_list|)
decl_stmt|;
name|checksumOpt
operator|=
name|ChecksumOpt
operator|.
name|processChecksumOpt
argument_list|(
name|defaultOpt
argument_list|,
name|checksumOpt
argument_list|,
name|bytesPerChecksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufferSize
operator|==
operator|-
literal|1
condition|)
block|{
name|bufferSize
operator|=
name|ssDef
operator|.
name|getFileBufferSize
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|replication
operator|==
operator|-
literal|1
condition|)
block|{
name|replication
operator|=
name|ssDef
operator|.
name|getReplication
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|createParent
operator|==
literal|null
condition|)
block|{
name|createParent
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|blockSize
operator|%
name|bytesPerChecksum
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"blockSize should be a multiple of checksumsize"
argument_list|)
throw|;
block|}
return|return
name|this
operator|.
name|createInternal
argument_list|(
name|f
argument_list|,
name|createFlag
argument_list|,
name|permission
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|,
name|checksumOpt
argument_list|,
name|createParent
argument_list|)
return|;
block|}
comment|/**    * The specification of this method matches that of    * {@link #create(Path, EnumSet, Options.CreateOpts...)} except that the opts    * have been declared explicitly.    */
DECL|method|createInternal (Path f, EnumSet<CreateFlag> flag, FsPermission absolutePermission, int bufferSize, short replication, long blockSize, Progressable progress, ChecksumOpt checksumOpt, boolean createParent)
specifier|public
specifier|abstract
name|FSDataOutputStream
name|createInternal
parameter_list|(
name|Path
name|f
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|FsPermission
name|absolutePermission
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|ChecksumOpt
name|checksumOpt
parameter_list|,
name|boolean
name|createParent
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileAlreadyExistsException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|UnsupportedFileSystemException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
function_decl|;
comment|/**    * The specification of this method matches that of    * {@link FileContext#mkdir(Path, FsPermission, boolean)} except that the Path    * f must be fully qualified and the permission is absolute (i.e.     * umask has been applied).    */
DECL|method|mkdir (final Path dir, final FsPermission permission, final boolean createParent)
specifier|public
specifier|abstract
name|void
name|mkdir
parameter_list|(
specifier|final
name|Path
name|dir
parameter_list|,
specifier|final
name|FsPermission
name|permission
parameter_list|,
specifier|final
name|boolean
name|createParent
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileAlreadyExistsException
throws|,
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
function_decl|;
comment|/**    * The specification of this method matches that of    * {@link FileContext#delete(Path, boolean)} except that Path f must be for    * this file system.    */
DECL|method|delete (final Path f, final boolean recursive)
specifier|public
specifier|abstract
name|boolean
name|delete
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|boolean
name|recursive
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
function_decl|;
comment|/**    * The specification of this method matches that of    * {@link FileContext#open(Path)} except that Path f must be for this    * file system.    */
DECL|method|open (final Path f)
specifier|public
name|FSDataInputStream
name|open
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
return|return
name|open
argument_list|(
name|f
argument_list|,
name|getServerDefaults
argument_list|()
operator|.
name|getFileBufferSize
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * The specification of this method matches that of    * {@link FileContext#open(Path, int)} except that Path f must be for this    * file system.    */
DECL|method|open (final Path f, int bufferSize)
specifier|public
specifier|abstract
name|FSDataInputStream
name|open
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
name|int
name|bufferSize
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
function_decl|;
comment|/**    * The specification of this method matches that of    * {@link FileContext#setReplication(Path, short)} except that Path f must be    * for this file system.    */
DECL|method|setReplication (final Path f, final short replication)
specifier|public
specifier|abstract
name|boolean
name|setReplication
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
function_decl|;
comment|/**    * The specification of this method matches that of    * {@link FileContext#rename(Path, Path, Options.Rename...)} except that Path    * f must be for this file system.    */
DECL|method|rename (final Path src, final Path dst, final Options.Rename... options)
specifier|public
specifier|final
name|void
name|rename
parameter_list|(
specifier|final
name|Path
name|src
parameter_list|,
specifier|final
name|Path
name|dst
parameter_list|,
specifier|final
name|Options
operator|.
name|Rename
modifier|...
name|options
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileAlreadyExistsException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
name|boolean
name|overwrite
init|=
literal|false
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|options
condition|)
block|{
for|for
control|(
name|Rename
name|option
range|:
name|options
control|)
block|{
if|if
condition|(
name|option
operator|==
name|Rename
operator|.
name|OVERWRITE
condition|)
block|{
name|overwrite
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
name|renameInternal
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|overwrite
argument_list|)
expr_stmt|;
block|}
comment|/**    * The specification of this method matches that of    * {@link FileContext#rename(Path, Path, Options.Rename...)} except that Path    * f must be for this file system and NO OVERWRITE is performed.    *     * File systems that do not have a built in overwrite need implement only this    * method and can take advantage of the default impl of the other    * {@link #renameInternal(Path, Path, boolean)}    */
DECL|method|renameInternal (final Path src, final Path dst)
specifier|public
specifier|abstract
name|void
name|renameInternal
parameter_list|(
specifier|final
name|Path
name|src
parameter_list|,
specifier|final
name|Path
name|dst
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileAlreadyExistsException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
function_decl|;
comment|/**    * The specification of this method matches that of    * {@link FileContext#rename(Path, Path, Options.Rename...)} except that Path    * f must be for this file system.    */
DECL|method|renameInternal (final Path src, final Path dst, boolean overwrite)
specifier|public
name|void
name|renameInternal
parameter_list|(
specifier|final
name|Path
name|src
parameter_list|,
specifier|final
name|Path
name|dst
parameter_list|,
name|boolean
name|overwrite
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileAlreadyExistsException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
comment|// Default implementation deals with overwrite in a non-atomic way
specifier|final
name|FileStatus
name|srcStatus
init|=
name|getFileLinkStatus
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|FileStatus
name|dstStatus
decl_stmt|;
try|try
block|{
name|dstStatus
operator|=
name|getFileLinkStatus
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|dstStatus
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|dstStatus
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|dst
operator|.
name|equals
argument_list|(
name|src
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"The source "
operator|+
name|src
operator|+
literal|" and destination "
operator|+
name|dst
operator|+
literal|" are the same"
argument_list|)
throw|;
block|}
if|if
condition|(
name|srcStatus
operator|.
name|isSymlink
argument_list|()
operator|&&
name|dst
operator|.
name|equals
argument_list|(
name|srcStatus
operator|.
name|getSymlink
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"Cannot rename symlink "
operator|+
name|src
operator|+
literal|" to its target "
operator|+
name|dst
argument_list|)
throw|;
block|}
comment|// It's OK to rename a file to a symlink and vice versa
if|if
condition|(
name|srcStatus
operator|.
name|isDirectory
argument_list|()
operator|!=
name|dstStatus
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Source "
operator|+
name|src
operator|+
literal|" and destination "
operator|+
name|dst
operator|+
literal|" must both be directories"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|overwrite
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"Rename destination "
operator|+
name|dst
operator|+
literal|" already exists."
argument_list|)
throw|;
block|}
comment|// Delete the destination that is a file or an empty directory
if|if
condition|(
name|dstStatus
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|list
init|=
name|listStatusIterator
argument_list|(
name|dst
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|!=
literal|null
operator|&&
name|list
operator|.
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Rename cannot overwrite non empty destination directory "
operator|+
name|dst
argument_list|)
throw|;
block|}
block|}
name|delete
argument_list|(
name|dst
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|Path
name|parent
init|=
name|dst
operator|.
name|getParent
argument_list|()
decl_stmt|;
specifier|final
name|FileStatus
name|parentStatus
init|=
name|getFileStatus
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentStatus
operator|.
name|isFile
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ParentNotDirectoryException
argument_list|(
literal|"Rename destination parent "
operator|+
name|parent
operator|+
literal|" is a file."
argument_list|)
throw|;
block|}
block|}
name|renameInternal
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns true if the file system supports symlinks, false otherwise.    * @return true if filesystem supports symlinks    */
DECL|method|supportsSymlinks ()
specifier|public
name|boolean
name|supportsSymlinks
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**    * The specification of this method matches that of      * {@link FileContext#createSymlink(Path, Path, boolean)};    */
DECL|method|createSymlink (final Path target, final Path link, final boolean createParent)
specifier|public
name|void
name|createSymlink
parameter_list|(
specifier|final
name|Path
name|target
parameter_list|,
specifier|final
name|Path
name|link
parameter_list|,
specifier|final
name|boolean
name|createParent
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"File system does not support symlinks"
argument_list|)
throw|;
block|}
comment|/**    * Partially resolves the path. This is used during symlink resolution in    * {@link FSLinkResolver}, and differs from the similarly named method    * {@link FileContext#getLinkTarget(Path)}.    * @throws IOException subclass implementations may throw IOException     */
DECL|method|getLinkTarget (final Path f)
specifier|public
name|Path
name|getLinkTarget
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Implementation Error: "
operator|+
name|getClass
argument_list|()
operator|+
literal|" that threw an UnresolvedLinkException, causing this method to be"
operator|+
literal|" called, needs to override this method."
argument_list|)
throw|;
block|}
comment|/**    * The specification of this method matches that of    * {@link FileContext#setPermission(Path, FsPermission)} except that Path f    * must be for this file system.    */
DECL|method|setPermission (final Path f, final FsPermission permission)
specifier|public
specifier|abstract
name|void
name|setPermission
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
function_decl|;
comment|/**    * The specification of this method matches that of    * {@link FileContext#setOwner(Path, String, String)} except that Path f must    * be for this file system.    */
DECL|method|setOwner (final Path f, final String username, final String groupname)
specifier|public
specifier|abstract
name|void
name|setOwner
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|String
name|username
parameter_list|,
specifier|final
name|String
name|groupname
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
function_decl|;
comment|/**    * The specification of this method matches that of    * {@link FileContext#setTimes(Path, long, long)} except that Path f must be    * for this file system.    */
DECL|method|setTimes (final Path f, final long mtime, final long atime)
specifier|public
specifier|abstract
name|void
name|setTimes
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|long
name|mtime
parameter_list|,
specifier|final
name|long
name|atime
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
function_decl|;
comment|/**    * The specification of this method matches that of    * {@link FileContext#getFileChecksum(Path)} except that Path f must be for    * this file system.    */
DECL|method|getFileChecksum (final Path f)
specifier|public
specifier|abstract
name|FileChecksum
name|getFileChecksum
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
function_decl|;
comment|/**    * The specification of this method matches that of    * {@link FileContext#getFileStatus(Path)}     * except that an UnresolvedLinkException may be thrown if a symlink is     * encountered in the path.    */
DECL|method|getFileStatus (final Path f)
specifier|public
specifier|abstract
name|FileStatus
name|getFileStatus
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
function_decl|;
comment|/**    * The specification of this method matches that of    * {@link FileContext#getFileLinkStatus(Path)}    * except that an UnresolvedLinkException may be thrown if a symlink is      * encountered in the path leading up to the final path component.    * If the file system does not support symlinks then the behavior is    * equivalent to {@link AbstractFileSystem#getFileStatus(Path)}.    */
DECL|method|getFileLinkStatus (final Path f)
specifier|public
name|FileStatus
name|getFileLinkStatus
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
return|return
name|getFileStatus
argument_list|(
name|f
argument_list|)
return|;
block|}
comment|/**    * The specification of this method matches that of    * {@link FileContext#getFileBlockLocations(Path, long, long)} except that    * Path f must be for this file system.    */
DECL|method|getFileBlockLocations (final Path f, final long start, final long len)
specifier|public
specifier|abstract
name|BlockLocation
index|[]
name|getFileBlockLocations
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|long
name|start
parameter_list|,
specifier|final
name|long
name|len
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
function_decl|;
comment|/**    * The specification of this method matches that of    * {@link FileContext#getFsStatus(Path)} except that Path f must be for this    * file system.    */
DECL|method|getFsStatus (final Path f)
specifier|public
name|FsStatus
name|getFsStatus
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
comment|// default impl gets FsStatus of root
return|return
name|getFsStatus
argument_list|()
return|;
block|}
comment|/**    * The specification of this method matches that of    * {@link FileContext#getFsStatus(Path)}.    */
DECL|method|getFsStatus ()
specifier|public
specifier|abstract
name|FsStatus
name|getFsStatus
parameter_list|()
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|IOException
function_decl|;
comment|/**    * The specification of this method matches that of    * {@link FileContext#listStatus(Path)} except that Path f must be for this    * file system.    */
DECL|method|listStatusIterator (final Path f)
specifier|public
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|listStatusIterator
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
return|return
operator|new
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
block|{
specifier|private
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|private
name|FileStatus
index|[]
name|statusList
init|=
name|listStatus
argument_list|(
name|f
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|i
operator|<
name|statusList
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|FileStatus
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
return|return
name|statusList
index|[
name|i
operator|++
index|]
return|;
block|}
block|}
return|;
block|}
comment|/**    * The specification of this method matches that of    * {@link FileContext#listLocatedStatus(Path)} except that Path f     * must be for this file system.    */
DECL|method|listLocatedStatus (final Path f)
specifier|public
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|listLocatedStatus
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
block|{
return|return
operator|new
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
argument_list|()
block|{
specifier|private
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|itor
init|=
name|listStatusIterator
argument_list|(
name|f
argument_list|)
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|itor
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|LocatedFileStatus
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|(
literal|"No more entry in "
operator|+
name|f
argument_list|)
throw|;
block|}
name|FileStatus
name|result
init|=
name|itor
operator|.
name|next
argument_list|()
decl_stmt|;
name|BlockLocation
index|[]
name|locs
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|locs
operator|=
name|getFileBlockLocations
argument_list|(
name|result
operator|.
name|getPath
argument_list|()
argument_list|,
literal|0
argument_list|,
name|result
operator|.
name|getLen
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|LocatedFileStatus
argument_list|(
name|result
argument_list|,
name|locs
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * The specification of this method matches that of    * {@link FileContext.Util#listStatus(Path)} except that Path f must be     * for this file system.    */
DECL|method|listStatus (final Path f)
specifier|public
specifier|abstract
name|FileStatus
index|[]
name|listStatus
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|IOException
function_decl|;
comment|/**    * @return an iterator over the corrupt files under the given path    * (may contain duplicates if a file has more than one corrupt block)    * @throws IOException    */
DECL|method|listCorruptFileBlocks (Path path)
specifier|public
name|RemoteIterator
argument_list|<
name|Path
argument_list|>
name|listCorruptFileBlocks
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|" does not support"
operator|+
literal|" listCorruptFileBlocks"
argument_list|)
throw|;
block|}
comment|/**    * The specification of this method matches that of    * {@link FileContext#setVerifyChecksum(boolean, Path)} except that Path f    * must be for this file system.    */
DECL|method|setVerifyChecksum (final boolean verifyChecksum)
specifier|public
specifier|abstract
name|void
name|setVerifyChecksum
parameter_list|(
specifier|final
name|boolean
name|verifyChecksum
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|IOException
function_decl|;
comment|/**    * Get a canonical name for this file system.    * @return a URI string that uniquely identifies this file system    */
DECL|method|getCanonicalServiceName ()
specifier|public
name|String
name|getCanonicalServiceName
parameter_list|()
block|{
return|return
name|SecurityUtil
operator|.
name|buildDTServiceName
argument_list|(
name|getUri
argument_list|()
argument_list|,
name|getUriDefaultPort
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get one or more delegation tokens associated with the filesystem. Normally    * a file system returns a single delegation token. A file system that manages    * multiple file systems underneath, could return set of delegation tokens for    * all the file systems it manages    *     * @param renewer the account name that is allowed to renew the token.    * @return List of delegation tokens.    *   If delegation tokens not supported then return a list of size zero.    * @throws IOException    */
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|,
literal|"MapReduce"
block|}
argument_list|)
DECL|method|getDelegationTokens (String renewer)
specifier|public
name|List
argument_list|<
name|Token
argument_list|<
name|?
argument_list|>
argument_list|>
name|getDelegationTokens
parameter_list|(
name|String
name|renewer
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|ArrayList
argument_list|<
name|Token
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**    * Modifies ACL entries of files and directories.  This method can add new ACL    * entries or modify the permissions on existing ACL entries.  All existing    * ACL entries that are not specified in this call are retained without    * changes.  (Modifications are merged into the current ACL.)    *    * @param path Path to modify    * @param aclSpec List<AclEntry> describing modifications    * @throws IOException if an ACL could not be modified    */
DECL|method|modifyAclEntries (Path path, List<AclEntry> aclSpec)
specifier|public
name|void
name|modifyAclEntries
parameter_list|(
name|Path
name|path
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support modifyAclEntries"
argument_list|)
throw|;
block|}
comment|/**    * Removes ACL entries from files and directories.  Other ACL entries are    * retained.    *    * @param path Path to modify    * @param aclSpec List<AclEntry> describing entries to remove    * @throws IOException if an ACL could not be modified    */
DECL|method|removeAclEntries (Path path, List<AclEntry> aclSpec)
specifier|public
name|void
name|removeAclEntries
parameter_list|(
name|Path
name|path
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support removeAclEntries"
argument_list|)
throw|;
block|}
comment|/**    * Removes all default ACL entries from files and directories.    *    * @param path Path to modify    * @throws IOException if an ACL could not be modified    */
DECL|method|removeDefaultAcl (Path path)
specifier|public
name|void
name|removeDefaultAcl
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support removeDefaultAcl"
argument_list|)
throw|;
block|}
comment|/**    * Removes all but the base ACL entries of files and directories.  The entries    * for user, group, and others are retained for compatibility with permission    * bits.    *    * @param path Path to modify    * @throws IOException if an ACL could not be removed    */
DECL|method|removeAcl (Path path)
specifier|public
name|void
name|removeAcl
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support removeAcl"
argument_list|)
throw|;
block|}
comment|/**    * Fully replaces ACL of files and directories, discarding all existing    * entries.    *    * @param path Path to modify    * @param aclSpec List<AclEntry> describing modifications, must include entries    *   for user, group, and others for compatibility with permission bits.    * @throws IOException if an ACL could not be modified    */
DECL|method|setAcl (Path path, List<AclEntry> aclSpec)
specifier|public
name|void
name|setAcl
parameter_list|(
name|Path
name|path
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support setAcl"
argument_list|)
throw|;
block|}
comment|/**    * Gets the ACLs of files and directories.    *    * @param path Path to get    * @return RemoteIterator<AclStatus> which returns each AclStatus    * @throws IOException if an ACL could not be read    */
DECL|method|getAclStatus (Path path)
specifier|public
name|AclStatus
name|getAclStatus
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support getAclStatus"
argument_list|)
throw|;
block|}
annotation|@
name|Override
comment|//Object
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|myUri
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
comment|//Object
DECL|method|equals (Object other)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|==
literal|null
operator|||
operator|!
operator|(
name|other
operator|instanceof
name|AbstractFileSystem
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|myUri
operator|.
name|equals
argument_list|(
operator|(
operator|(
name|AbstractFileSystem
operator|)
name|other
operator|)
operator|.
name|myUri
argument_list|)
return|;
block|}
block|}
end_class

end_unit

