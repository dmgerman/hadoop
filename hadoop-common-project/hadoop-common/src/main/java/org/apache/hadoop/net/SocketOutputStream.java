begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.net
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|Socket
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketTimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|FileChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|SelectableChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|SelectionKey
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|WritableByteChannel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|LongWritable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|lib
operator|.
name|MutableRate
import|;
end_import

begin_comment
comment|/**  * This implements an output stream that can have a timeout while writing.  * This sets non-blocking flag on the socket channel.  * So after creating this object , read() on   * {@link Socket#getInputStream()} and write() on   * {@link Socket#getOutputStream()} on the associated socket will throw   * llegalBlockingModeException.  * Please use {@link SocketInputStream} for reading.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|,
literal|"MapReduce"
block|}
argument_list|)
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|SocketOutputStream
specifier|public
class|class
name|SocketOutputStream
extends|extends
name|OutputStream
implements|implements
name|WritableByteChannel
block|{
DECL|field|writer
specifier|private
name|Writer
name|writer
decl_stmt|;
DECL|class|Writer
specifier|private
specifier|static
class|class
name|Writer
extends|extends
name|SocketIOWithTimeout
block|{
DECL|field|channel
name|WritableByteChannel
name|channel
decl_stmt|;
DECL|method|Writer (WritableByteChannel channel, long timeout)
name|Writer
parameter_list|(
name|WritableByteChannel
name|channel
parameter_list|,
name|long
name|timeout
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
operator|(
name|SelectableChannel
operator|)
name|channel
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|this
operator|.
name|channel
operator|=
name|channel
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|performIO (ByteBuffer buf)
name|int
name|performIO
parameter_list|(
name|ByteBuffer
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|channel
operator|.
name|write
argument_list|(
name|buf
argument_list|)
return|;
block|}
block|}
comment|/**    * Create a new ouput stream with the given timeout. If the timeout    * is zero, it will be treated as infinite timeout. The socket's    * channel will be configured to be non-blocking.    *     * @param channel     *        Channel for writing, should also be a {@link SelectableChannel}.      *        The channel will be configured to be non-blocking.    * @param timeout timeout in milliseconds. must not be negative.    * @throws IOException    */
DECL|method|SocketOutputStream (WritableByteChannel channel, long timeout)
specifier|public
name|SocketOutputStream
parameter_list|(
name|WritableByteChannel
name|channel
parameter_list|,
name|long
name|timeout
parameter_list|)
throws|throws
name|IOException
block|{
name|SocketIOWithTimeout
operator|.
name|checkChannelValidity
argument_list|(
name|channel
argument_list|)
expr_stmt|;
name|writer
operator|=
operator|new
name|Writer
argument_list|(
name|channel
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
comment|/**    * Same as SocketOutputStream(socket.getChannel(), timeout):<br><br>    *     * Create a new ouput stream with the given timeout. If the timeout    * is zero, it will be treated as infinite timeout. The socket's    * channel will be configured to be non-blocking.    *     * @see SocketOutputStream#SocketOutputStream(WritableByteChannel, long)    *      * @param socket should have a channel associated with it.    * @param timeout timeout timeout in milliseconds. must not be negative.    * @throws IOException    */
DECL|method|SocketOutputStream (Socket socket, long timeout)
specifier|public
name|SocketOutputStream
parameter_list|(
name|Socket
name|socket
parameter_list|,
name|long
name|timeout
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|socket
operator|.
name|getChannel
argument_list|()
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|write (int b)
specifier|public
name|void
name|write
parameter_list|(
name|int
name|b
parameter_list|)
throws|throws
name|IOException
block|{
comment|/* If we need to, we can optimize this allocation.      * probably no need to optimize or encourage single byte writes.      */
name|byte
index|[]
name|buf
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|byte
operator|)
name|b
expr_stmt|;
name|write
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|write (byte[] b, int off, int len)
specifier|public
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteBuffer
name|buf
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
decl_stmt|;
while|while
condition|(
name|buf
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
try|try
block|{
if|if
condition|(
name|write
argument_list|(
name|buf
argument_list|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"The stream is closed"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|/* Unlike read, write can not inform user of partial writes.          * So will close this if there was a partial write.          */
if|if
condition|(
name|buf
operator|.
name|capacity
argument_list|()
operator|>
name|buf
operator|.
name|remaining
argument_list|()
condition|)
block|{
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
comment|/* close the channel since Socket.getOuputStream().close()       * closes the socket.      */
name|writer
operator|.
name|channel
operator|.
name|close
argument_list|()
expr_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
comment|/**    * Returns underlying channel used by this stream.    * This is useful in certain cases like channel for     * {@link FileChannel#transferTo(long, long, WritableByteChannel)}    */
DECL|method|getChannel ()
specifier|public
name|WritableByteChannel
name|getChannel
parameter_list|()
block|{
return|return
name|writer
operator|.
name|channel
return|;
block|}
comment|//WritableByteChannle interface
annotation|@
name|Override
DECL|method|isOpen ()
specifier|public
name|boolean
name|isOpen
parameter_list|()
block|{
return|return
name|writer
operator|.
name|isOpen
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|write (ByteBuffer src)
specifier|public
name|int
name|write
parameter_list|(
name|ByteBuffer
name|src
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|writer
operator|.
name|doIO
argument_list|(
name|src
argument_list|,
name|SelectionKey
operator|.
name|OP_WRITE
argument_list|)
return|;
block|}
comment|/**    * waits for the underlying channel to be ready for writing.    * The timeout specified for this stream applies to this wait.    *    * @throws SocketTimeoutException     *         if select on the channel times out.    * @throws IOException    *         if any other I/O error occurs.     */
DECL|method|waitForWritable ()
specifier|public
name|void
name|waitForWritable
parameter_list|()
throws|throws
name|IOException
block|{
name|writer
operator|.
name|waitForIO
argument_list|(
name|SelectionKey
operator|.
name|OP_WRITE
argument_list|)
expr_stmt|;
block|}
comment|/**    * Transfers data from FileChannel using     * {@link FileChannel#transferTo(long, long, WritableByteChannel)}.    * Updates<code>waitForWritableTime</code> and<code>transferToTime</code>    * with the time spent blocked on the network and the time spent transferring    * data from disk to network respectively.    *     * Similar to readFully(), this waits till requested amount of     * data is transfered.    *     * @param fileCh FileChannel to transfer data from.    * @param position position within the channel where the transfer begins    * @param count number of bytes to transfer.    * @param waitForWritableTime nanoseconds spent waiting for the socket     *        to become writable    * @param transferTime nanoseconds spent transferring data    *     * @throws EOFException     *         If end of input file is reached before requested number of     *         bytes are transfered.    *    * @throws SocketTimeoutException     *         If this channel blocks transfer longer than timeout for     *         this stream.    *              * @throws IOException Includes any exception thrown by     *         {@link FileChannel#transferTo(long, long, WritableByteChannel)}.     */
DECL|method|transferToFully (FileChannel fileCh, long position, int count, LongWritable waitForWritableTime, LongWritable transferToTime)
specifier|public
name|void
name|transferToFully
parameter_list|(
name|FileChannel
name|fileCh
parameter_list|,
name|long
name|position
parameter_list|,
name|int
name|count
parameter_list|,
name|LongWritable
name|waitForWritableTime
parameter_list|,
name|LongWritable
name|transferToTime
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|waitTime
init|=
literal|0
decl_stmt|;
name|long
name|transferTime
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
comment|/*         * Ideally we should wait after transferTo returns 0. But because of        * a bug in JRE on Linux (http://bugs.sun.com/view_bug.do?bug_id=5103988),        * which throws an exception instead of returning 0, we wait for the        * channel to be writable before writing to it. If you ever see         * IOException with message "Resource temporarily unavailable"         * thrown here, please let us know.        *         * Once we move to JAVA SE 7, wait should be moved to correct place.        */
name|long
name|start
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|waitForWritable
argument_list|()
expr_stmt|;
name|long
name|wait
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|int
name|nTransfered
init|=
operator|(
name|int
operator|)
name|fileCh
operator|.
name|transferTo
argument_list|(
name|position
argument_list|,
name|count
argument_list|,
name|getChannel
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|nTransfered
operator|==
literal|0
condition|)
block|{
comment|//check if end of file is reached.
if|if
condition|(
name|position
operator|>=
name|fileCh
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"EOF Reached. file size is "
operator|+
name|fileCh
operator|.
name|size
argument_list|()
operator|+
literal|" and "
operator|+
name|count
operator|+
literal|" more bytes left to be "
operator|+
literal|"transfered."
argument_list|)
throw|;
block|}
comment|//otherwise assume the socket is full.
comment|//waitForWritable(); // see comment above.
block|}
elseif|else
if|if
condition|(
name|nTransfered
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unexpected return of "
operator|+
name|nTransfered
operator|+
literal|" from transferTo()"
argument_list|)
throw|;
block|}
else|else
block|{
name|position
operator|+=
name|nTransfered
expr_stmt|;
name|count
operator|-=
name|nTransfered
expr_stmt|;
block|}
name|long
name|transfer
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|waitTime
operator|+=
name|wait
operator|-
name|start
expr_stmt|;
name|transferTime
operator|+=
name|transfer
operator|-
name|wait
expr_stmt|;
block|}
if|if
condition|(
name|waitForWritableTime
operator|!=
literal|null
condition|)
block|{
name|waitForWritableTime
operator|.
name|set
argument_list|(
name|waitTime
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|transferToTime
operator|!=
literal|null
condition|)
block|{
name|transferToTime
operator|.
name|set
argument_list|(
name|transferTime
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Call    * {@link #transferToFully(FileChannel, long, int, MutableRate, MutableRate)}    * with null<code>waitForWritableTime</code> and<code>transferToTime</code>    */
DECL|method|transferToFully (FileChannel fileCh, long position, int count)
specifier|public
name|void
name|transferToFully
parameter_list|(
name|FileChannel
name|fileCh
parameter_list|,
name|long
name|position
parameter_list|,
name|int
name|count
parameter_list|)
throws|throws
name|IOException
block|{
name|transferToFully
argument_list|(
name|fileCh
argument_list|,
name|position
argument_list|,
name|count
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

