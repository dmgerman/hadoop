begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.security
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configured
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authentication
operator|.
name|util
operator|.
name|KerberosName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|TokenIdentifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ExitUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Tool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ToolRunner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kerby
operator|.
name|kerberos
operator|.
name|kerb
operator|.
name|keytab
operator|.
name|Keytab
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kerby
operator|.
name|kerberos
operator|.
name|kerb
operator|.
name|keytab
operator|.
name|KeytabEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kerby
operator|.
name|kerberos
operator|.
name|kerb
operator|.
name|type
operator|.
name|base
operator|.
name|EncryptionKey
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|kerby
operator|.
name|kerberos
operator|.
name|kerb
operator|.
name|type
operator|.
name|base
operator|.
name|PrincipalName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|crypto
operator|.
name|Cipher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|NoSuchAlgorithmException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|authentication
operator|.
name|util
operator|.
name|KerberosUtil
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|popOption
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
operator|.
name|popOptionWithArgument
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_TOKEN_FILES
import|;
end_import

begin_comment
comment|/**  * Kerberos diagnostics  *  * This operation expands some of the diagnostic output of the security code,  * but not all. For completeness  *  * Set the environment variable {@code HADOOP_JAAS_DEBUG=true}  * Set the log level for {@code org.apache.hadoop.security=DEBUG}  */
end_comment

begin_class
DECL|class|KDiag
specifier|public
class|class
name|KDiag
extends|extends
name|Configured
implements|implements
name|Tool
implements|,
name|Closeable
block|{
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|KDiag
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Location of the kerberos ticket cache as passed down via an environment    * variable. This is what kinit will use by default: {@value}    */
DECL|field|KRB5_CCNAME
specifier|public
specifier|static
specifier|final
name|String
name|KRB5_CCNAME
init|=
literal|"KRB5CCNAME"
decl_stmt|;
DECL|field|JAVA_SECURITY_KRB5_CONF
specifier|public
specifier|static
specifier|final
name|String
name|JAVA_SECURITY_KRB5_CONF
init|=
literal|"java.security.krb5.conf"
decl_stmt|;
DECL|field|JAVA_SECURITY_KRB5_REALM
specifier|public
specifier|static
specifier|final
name|String
name|JAVA_SECURITY_KRB5_REALM
init|=
literal|"java.security.krb5.realm"
decl_stmt|;
DECL|field|JAVA_SECURITY_KRB5_KDC_ADDRESS
specifier|public
specifier|static
specifier|final
name|String
name|JAVA_SECURITY_KRB5_KDC_ADDRESS
init|=
literal|"java.security.krb5.kdc"
decl_stmt|;
DECL|field|SUN_SECURITY_KRB5_DEBUG
specifier|public
specifier|static
specifier|final
name|String
name|SUN_SECURITY_KRB5_DEBUG
init|=
literal|"sun.security.krb5.debug"
decl_stmt|;
DECL|field|SUN_SECURITY_SPNEGO_DEBUG
specifier|public
specifier|static
specifier|final
name|String
name|SUN_SECURITY_SPNEGO_DEBUG
init|=
literal|"sun.security.spnego.debug"
decl_stmt|;
DECL|field|SUN_SECURITY_JAAS_FILE
specifier|public
specifier|static
specifier|final
name|String
name|SUN_SECURITY_JAAS_FILE
init|=
literal|"java.security.auth.login.config"
decl_stmt|;
DECL|field|KERBEROS_KINIT_COMMAND
specifier|public
specifier|static
specifier|final
name|String
name|KERBEROS_KINIT_COMMAND
init|=
literal|"hadoop.kerberos.kinit.command"
decl_stmt|;
DECL|field|HADOOP_AUTHENTICATION_IS_DISABLED
specifier|public
specifier|static
specifier|final
name|String
name|HADOOP_AUTHENTICATION_IS_DISABLED
init|=
literal|"Hadoop authentication is disabled"
decl_stmt|;
DECL|field|UNSET
specifier|public
specifier|static
specifier|final
name|String
name|UNSET
init|=
literal|"(unset)"
decl_stmt|;
comment|/**    * String seen in {@code getDefaultRealm()} exceptions if the user has    * no realm: {@value}.    */
DECL|field|NO_DEFAULT_REALM
specifier|public
specifier|static
specifier|final
name|String
name|NO_DEFAULT_REALM
init|=
literal|"Cannot locate default realm"
decl_stmt|;
comment|/**    * The exit code for a failure of the diagnostics: 41 == HTTP 401 == unauth.    */
DECL|field|KDIAG_FAILURE
specifier|public
specifier|static
specifier|final
name|int
name|KDIAG_FAILURE
init|=
literal|41
decl_stmt|;
DECL|field|DFS_DATA_TRANSFER_SASLPROPERTIES_RESOLVER_CLASS
specifier|public
specifier|static
specifier|final
name|String
name|DFS_DATA_TRANSFER_SASLPROPERTIES_RESOLVER_CLASS
init|=
literal|"dfs.data.transfer.saslproperties.resolver.class"
decl_stmt|;
DECL|field|DFS_DATA_TRANSFER_PROTECTION
specifier|public
specifier|static
specifier|final
name|String
name|DFS_DATA_TRANSFER_PROTECTION
init|=
literal|"dfs.data.transfer.protection"
decl_stmt|;
DECL|field|ETC_KRB5_CONF
specifier|public
specifier|static
specifier|final
name|String
name|ETC_KRB5_CONF
init|=
literal|"/etc/krb5.conf"
decl_stmt|;
DECL|field|ETC_NTP
specifier|public
specifier|static
specifier|final
name|String
name|ETC_NTP
init|=
literal|"/etc/ntp.conf"
decl_stmt|;
DECL|field|HADOOP_JAAS_DEBUG
specifier|public
specifier|static
specifier|final
name|String
name|HADOOP_JAAS_DEBUG
init|=
literal|"HADOOP_JAAS_DEBUG"
decl_stmt|;
DECL|field|out
specifier|private
name|PrintWriter
name|out
decl_stmt|;
DECL|field|keytab
specifier|private
name|File
name|keytab
decl_stmt|;
DECL|field|principal
specifier|private
name|String
name|principal
decl_stmt|;
DECL|field|minKeyLength
specifier|private
name|long
name|minKeyLength
init|=
literal|256
decl_stmt|;
DECL|field|securityRequired
specifier|private
name|boolean
name|securityRequired
decl_stmt|;
DECL|field|nofail
specifier|private
name|boolean
name|nofail
init|=
literal|false
decl_stmt|;
DECL|field|nologin
specifier|private
name|boolean
name|nologin
init|=
literal|false
decl_stmt|;
DECL|field|jaas
specifier|private
name|boolean
name|jaas
init|=
literal|false
decl_stmt|;
DECL|field|checkShortName
specifier|private
name|boolean
name|checkShortName
init|=
literal|false
decl_stmt|;
comment|/**    * A pattern that recognizes simple/non-simple names. Per KerberosName    */
DECL|field|nonSimplePattern
specifier|private
specifier|static
specifier|final
name|Pattern
name|nonSimplePattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"[/@]"
argument_list|)
decl_stmt|;
comment|/**    * Flag set to true if a {@link #verify(boolean, String, String, Object...)}    * probe failed.    */
DECL|field|probeHasFailed
specifier|private
name|boolean
name|probeHasFailed
init|=
literal|false
decl_stmt|;
DECL|field|CAT_CONFIG
specifier|public
specifier|static
specifier|final
name|String
name|CAT_CONFIG
init|=
literal|"CONFIG"
decl_stmt|;
DECL|field|CAT_JAAS
specifier|public
specifier|static
specifier|final
name|String
name|CAT_JAAS
init|=
literal|"JAAS"
decl_stmt|;
DECL|field|CAT_JVM
specifier|public
specifier|static
specifier|final
name|String
name|CAT_JVM
init|=
literal|"JVM"
decl_stmt|;
DECL|field|CAT_KERBEROS
specifier|public
specifier|static
specifier|final
name|String
name|CAT_KERBEROS
init|=
literal|"KERBEROS"
decl_stmt|;
DECL|field|CAT_LOGIN
specifier|public
specifier|static
specifier|final
name|String
name|CAT_LOGIN
init|=
literal|"LOGIN"
decl_stmt|;
DECL|field|CAT_OS
specifier|public
specifier|static
specifier|final
name|String
name|CAT_OS
init|=
literal|"JAAS"
decl_stmt|;
DECL|field|CAT_SASL
specifier|public
specifier|static
specifier|final
name|String
name|CAT_SASL
init|=
literal|"SASL"
decl_stmt|;
DECL|field|CAT_UGI
specifier|public
specifier|static
specifier|final
name|String
name|CAT_UGI
init|=
literal|"UGI"
decl_stmt|;
DECL|field|CAT_TOKEN
specifier|public
specifier|static
specifier|final
name|String
name|CAT_TOKEN
init|=
literal|"TOKEN"
decl_stmt|;
DECL|field|ARG_KEYLEN
specifier|public
specifier|static
specifier|final
name|String
name|ARG_KEYLEN
init|=
literal|"--keylen"
decl_stmt|;
DECL|field|ARG_KEYTAB
specifier|public
specifier|static
specifier|final
name|String
name|ARG_KEYTAB
init|=
literal|"--keytab"
decl_stmt|;
DECL|field|ARG_JAAS
specifier|public
specifier|static
specifier|final
name|String
name|ARG_JAAS
init|=
literal|"--jaas"
decl_stmt|;
DECL|field|ARG_NOFAIL
specifier|public
specifier|static
specifier|final
name|String
name|ARG_NOFAIL
init|=
literal|"--nofail"
decl_stmt|;
DECL|field|ARG_NOLOGIN
specifier|public
specifier|static
specifier|final
name|String
name|ARG_NOLOGIN
init|=
literal|"--nologin"
decl_stmt|;
DECL|field|ARG_OUTPUT
specifier|public
specifier|static
specifier|final
name|String
name|ARG_OUTPUT
init|=
literal|"--out"
decl_stmt|;
DECL|field|ARG_PRINCIPAL
specifier|public
specifier|static
specifier|final
name|String
name|ARG_PRINCIPAL
init|=
literal|"--principal"
decl_stmt|;
DECL|field|ARG_RESOURCE
specifier|public
specifier|static
specifier|final
name|String
name|ARG_RESOURCE
init|=
literal|"--resource"
decl_stmt|;
DECL|field|ARG_SECURE
specifier|public
specifier|static
specifier|final
name|String
name|ARG_SECURE
init|=
literal|"--secure"
decl_stmt|;
DECL|field|ARG_VERIFYSHORTNAME
specifier|public
specifier|static
specifier|final
name|String
name|ARG_VERIFYSHORTNAME
init|=
literal|"--verifyshortname"
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"IOResourceOpenedButNotSafelyClosed"
argument_list|)
DECL|method|KDiag (Configuration conf, PrintWriter out, File keytab, String principal, long minKeyLength, boolean securityRequired)
specifier|public
name|KDiag
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|PrintWriter
name|out
parameter_list|,
name|File
name|keytab
parameter_list|,
name|String
name|principal
parameter_list|,
name|long
name|minKeyLength
parameter_list|,
name|boolean
name|securityRequired
parameter_list|)
block|{
name|super
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|keytab
operator|=
name|keytab
expr_stmt|;
name|this
operator|.
name|principal
operator|=
name|principal
expr_stmt|;
name|this
operator|.
name|out
operator|=
name|out
expr_stmt|;
name|this
operator|.
name|minKeyLength
operator|=
name|minKeyLength
expr_stmt|;
name|this
operator|.
name|securityRequired
operator|=
name|securityRequired
expr_stmt|;
block|}
DECL|method|KDiag ()
specifier|public
name|KDiag
parameter_list|()
block|{   }
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|run (String[] argv)
specifier|public
name|int
name|run
parameter_list|(
name|String
index|[]
name|argv
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|String
argument_list|>
name|args
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|argv
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|keytabName
init|=
name|popOptionWithArgument
argument_list|(
name|ARG_KEYTAB
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|keytabName
operator|!=
literal|null
condition|)
block|{
name|keytab
operator|=
operator|new
name|File
argument_list|(
name|keytabName
argument_list|)
expr_stmt|;
block|}
name|principal
operator|=
name|popOptionWithArgument
argument_list|(
name|ARG_PRINCIPAL
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|String
name|outf
init|=
name|popOptionWithArgument
argument_list|(
name|ARG_OUTPUT
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|String
name|mkl
init|=
name|popOptionWithArgument
argument_list|(
name|ARG_KEYLEN
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|mkl
operator|!=
literal|null
condition|)
block|{
name|minKeyLength
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|mkl
argument_list|)
expr_stmt|;
block|}
name|securityRequired
operator|=
name|popOption
argument_list|(
name|ARG_SECURE
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|nofail
operator|=
name|popOption
argument_list|(
name|ARG_NOFAIL
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|jaas
operator|=
name|popOption
argument_list|(
name|ARG_JAAS
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|nologin
operator|=
name|popOption
argument_list|(
name|ARG_NOLOGIN
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|checkShortName
operator|=
name|popOption
argument_list|(
name|ARG_VERIFYSHORTNAME
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|// look for list of resources
name|String
name|resource
decl_stmt|;
while|while
condition|(
literal|null
operator|!=
operator|(
name|resource
operator|=
name|popOptionWithArgument
argument_list|(
name|ARG_RESOURCE
argument_list|,
name|args
argument_list|)
operator|)
condition|)
block|{
comment|// loading a resource
name|LOG
operator|.
name|info
argument_list|(
literal|"Loading resource {}"
argument_list|,
name|resource
argument_list|)
expr_stmt|;
try|try
init|(
name|InputStream
name|in
init|=
name|getClass
argument_list|()
operator|.
name|getClassLoader
argument_list|()
operator|.
name|getResourceAsStream
argument_list|(
name|resource
argument_list|)
init|)
block|{
if|if
condition|(
name|verify
argument_list|(
name|in
operator|!=
literal|null
argument_list|,
name|CAT_CONFIG
argument_list|,
literal|"No resource %s"
argument_list|,
name|resource
argument_list|)
condition|)
block|{
name|Configuration
operator|.
name|addDefaultResource
argument_list|(
name|resource
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// look for any leftovers
if|if
condition|(
operator|!
name|args
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|println
argument_list|(
literal|"Unknown arguments in command:"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|args
control|)
block|{
name|println
argument_list|(
literal|"  \"%s\""
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|println
argument_list|()
expr_stmt|;
name|println
argument_list|(
name|usage
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|outf
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
literal|"Printing output to %s"
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|out
operator|=
operator|new
name|PrintWriter
argument_list|(
operator|new
name|File
argument_list|(
name|outf
argument_list|)
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
block|}
name|execute
argument_list|()
expr_stmt|;
return|return
name|probeHasFailed
condition|?
name|KDIAG_FAILURE
else|:
literal|0
return|;
block|}
DECL|method|usage ()
specifier|private
name|String
name|usage
parameter_list|()
block|{
return|return
literal|"KDiag: Diagnose Kerberos Problems\n"
operator|+
name|arg
argument_list|(
literal|"-D"
argument_list|,
literal|"key=value"
argument_list|,
literal|"Define a configuration option"
argument_list|)
operator|+
name|arg
argument_list|(
name|ARG_JAAS
argument_list|,
literal|""
argument_list|,
literal|"Require a JAAS file to be defined in "
operator|+
name|SUN_SECURITY_JAAS_FILE
argument_list|)
operator|+
name|arg
argument_list|(
name|ARG_KEYLEN
argument_list|,
literal|"<keylen>"
argument_list|,
literal|"Require a minimum size for encryption keys supported by the JVM."
operator|+
literal|" Default value : "
operator|+
name|minKeyLength
argument_list|)
operator|+
name|arg
argument_list|(
name|ARG_KEYTAB
argument_list|,
literal|"<keytab> "
operator|+
name|ARG_PRINCIPAL
operator|+
literal|"<principal>"
argument_list|,
literal|"Login from a keytab as a specific principal"
argument_list|)
operator|+
name|arg
argument_list|(
name|ARG_NOFAIL
argument_list|,
literal|""
argument_list|,
literal|"Do not fail on the first problem"
argument_list|)
operator|+
name|arg
argument_list|(
name|ARG_NOLOGIN
argument_list|,
literal|""
argument_list|,
literal|"Do not attempt to log in"
argument_list|)
operator|+
name|arg
argument_list|(
name|ARG_OUTPUT
argument_list|,
literal|"<file>"
argument_list|,
literal|"Write output to a file"
argument_list|)
operator|+
name|arg
argument_list|(
name|ARG_RESOURCE
argument_list|,
literal|"<resource>"
argument_list|,
literal|"Load an XML configuration resource"
argument_list|)
operator|+
name|arg
argument_list|(
name|ARG_SECURE
argument_list|,
literal|""
argument_list|,
literal|"Require the hadoop configuration to be secure"
argument_list|)
operator|+
name|arg
argument_list|(
name|ARG_VERIFYSHORTNAME
argument_list|,
name|ARG_PRINCIPAL
operator|+
literal|"<principal>"
argument_list|,
literal|"Verify the short name of the specific principal does not contain '@' or '/'"
argument_list|)
return|;
block|}
DECL|method|arg (String name, String params, String meaning)
specifier|private
name|String
name|arg
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|params
parameter_list|,
name|String
name|meaning
parameter_list|)
block|{
return|return
name|String
operator|.
name|format
argument_list|(
literal|"  [%s%s%s] : %s"
argument_list|,
name|name
argument_list|,
operator|(
operator|!
name|params
operator|.
name|isEmpty
argument_list|()
condition|?
literal|" "
else|:
literal|""
operator|)
argument_list|,
name|params
argument_list|,
name|meaning
argument_list|)
operator|+
literal|".\n"
return|;
block|}
comment|/**    * Execute diagnostics.    *<p>    * Things it would be nice if UGI made accessible    *<ol>    *<li>A way to enable JAAS debug programatically</li>    *<li>Access to the TGT</li>    *</ol>    * @return true if security was enabled and all probes were successful    * @throws KerberosDiagsFailure explicitly raised failure    * @throws Exception other security problems    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"deprecation"
argument_list|)
DECL|method|execute ()
specifier|public
name|boolean
name|execute
parameter_list|()
throws|throws
name|Exception
block|{
name|title
argument_list|(
literal|"Kerberos Diagnostics scan at %s"
argument_list|,
operator|new
name|Date
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// check that the machine has a name
name|println
argument_list|(
literal|"Hostname = %s"
argument_list|,
name|InetAddress
operator|.
name|getLocalHost
argument_list|()
operator|.
name|getCanonicalHostName
argument_list|()
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"%s = %d"
argument_list|,
name|ARG_KEYLEN
argument_list|,
name|minKeyLength
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"%s = %s"
argument_list|,
name|ARG_KEYTAB
argument_list|,
name|keytab
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"%s = %s"
argument_list|,
name|ARG_PRINCIPAL
argument_list|,
name|principal
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"%s = %s"
argument_list|,
name|ARG_VERIFYSHORTNAME
argument_list|,
name|checkShortName
argument_list|)
expr_stmt|;
comment|// Fail fast on a JVM without JCE installed.
name|validateKeyLength
argument_list|()
expr_stmt|;
comment|// look at realm
name|println
argument_list|(
literal|"JVM Kerberos Login Module = %s"
argument_list|,
name|getKrb5LoginModuleName
argument_list|()
argument_list|)
expr_stmt|;
name|title
argument_list|(
literal|"Core System Properties"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|prop
range|:
operator|new
name|String
index|[]
block|{
literal|"user.name"
block|,
literal|"java.version"
block|,
literal|"java.vendor"
block|,
name|JAVA_SECURITY_KRB5_CONF
block|,
name|JAVA_SECURITY_KRB5_REALM
block|,
name|JAVA_SECURITY_KRB5_KDC_ADDRESS
block|,
name|SUN_SECURITY_KRB5_DEBUG
block|,
name|SUN_SECURITY_SPNEGO_DEBUG
block|,
name|SUN_SECURITY_JAAS_FILE
block|}
control|)
block|{
name|printSysprop
argument_list|(
name|prop
argument_list|)
expr_stmt|;
block|}
name|endln
argument_list|()
expr_stmt|;
name|title
argument_list|(
literal|"All System Properties"
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|String
argument_list|>
name|propList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|System
operator|.
name|getProperties
argument_list|()
operator|.
name|stringPropertyNames
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|sort
argument_list|(
name|propList
argument_list|,
name|String
operator|.
name|CASE_INSENSITIVE_ORDER
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|s
range|:
name|propList
control|)
block|{
name|printSysprop
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|endln
argument_list|()
expr_stmt|;
name|title
argument_list|(
literal|"Environment Variables"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|env
range|:
operator|new
name|String
index|[]
block|{
name|HADOOP_JAAS_DEBUG
block|,
name|KRB5_CCNAME
block|,
name|HADOOP_USER_NAME
block|,
name|HADOOP_PROXY_USER
block|,
name|HADOOP_TOKEN_FILE_LOCATION
block|,
literal|"HADOOP_SECURE_LOG"
block|,
literal|"HADOOP_OPTS"
block|,
literal|"HADOOP_CLIENT_OPTS"
block|,     }
control|)
block|{
name|printEnv
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
name|endln
argument_list|()
expr_stmt|;
name|title
argument_list|(
literal|"Configuration Options"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|prop
range|:
operator|new
name|String
index|[]
block|{
name|KERBEROS_KINIT_COMMAND
block|,
name|HADOOP_SECURITY_AUTHENTICATION
block|,
name|HADOOP_SECURITY_AUTHORIZATION
block|,
literal|"hadoop.kerberos.min.seconds.before.relogin"
block|,
comment|// not in 2.6
literal|"hadoop.security.dns.interface"
block|,
comment|// not in 2.6
literal|"hadoop.security.dns.nameserver"
block|,
comment|// not in 2.6
name|HADOOP_RPC_PROTECTION
block|,
name|HADOOP_SECURITY_SASL_PROPS_RESOLVER_CLASS
block|,
name|HADOOP_SECURITY_CRYPTO_CODEC_CLASSES_KEY_PREFIX
block|,
name|HADOOP_SECURITY_GROUP_MAPPING
block|,
literal|"hadoop.security.impersonation.provider.class"
block|,
comment|// not in 2.6
name|DFS_DATA_TRANSFER_PROTECTION
block|,
comment|// HDFS
name|DFS_DATA_TRANSFER_SASLPROPERTIES_RESOLVER_CLASS
comment|// HDFS
block|}
control|)
block|{
name|printConfOpt
argument_list|(
name|prop
argument_list|)
expr_stmt|;
block|}
comment|// check that authentication is enabled
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
if|if
condition|(
name|isSimpleAuthentication
argument_list|(
name|conf
argument_list|)
condition|)
block|{
name|println
argument_list|(
name|HADOOP_AUTHENTICATION_IS_DISABLED
argument_list|)
expr_stmt|;
name|failif
argument_list|(
name|securityRequired
argument_list|,
name|CAT_CONFIG
argument_list|,
name|HADOOP_AUTHENTICATION_IS_DISABLED
argument_list|)
expr_stmt|;
comment|// no security, warn
name|LOG
operator|.
name|warn
argument_list|(
literal|"Security is not enabled for the Hadoop cluster"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isSimpleAuthentication
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The default cluster security is insecure"
argument_list|)
expr_stmt|;
name|failif
argument_list|(
name|securityRequired
argument_list|,
name|CAT_CONFIG
argument_list|,
name|HADOOP_AUTHENTICATION_IS_DISABLED
argument_list|)
expr_stmt|;
block|}
block|}
comment|// now the big test: login, then try again
name|boolean
name|krb5Debug
init|=
name|getAndSet
argument_list|(
name|SUN_SECURITY_KRB5_DEBUG
argument_list|)
decl_stmt|;
name|boolean
name|spnegoDebug
init|=
name|getAndSet
argument_list|(
name|SUN_SECURITY_SPNEGO_DEBUG
argument_list|)
decl_stmt|;
try|try
block|{
name|UserGroupInformation
operator|.
name|setConfiguration
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|validateHadoopTokenFiles
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|validateKrb5File
argument_list|()
expr_stmt|;
name|printDefaultRealm
argument_list|()
expr_stmt|;
name|validateSasl
argument_list|(
name|HADOOP_SECURITY_SASL_PROPS_RESOLVER_CLASS
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|get
argument_list|(
name|DFS_DATA_TRANSFER_SASLPROPERTIES_RESOLVER_CLASS
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|validateSasl
argument_list|(
name|DFS_DATA_TRANSFER_SASLPROPERTIES_RESOLVER_CLASS
argument_list|)
expr_stmt|;
block|}
name|validateKinitExecutable
argument_list|()
expr_stmt|;
name|validateJAAS
argument_list|(
name|jaas
argument_list|)
expr_stmt|;
name|validateNTPConf
argument_list|()
expr_stmt|;
if|if
condition|(
name|checkShortName
condition|)
block|{
name|validateShortName
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nologin
condition|)
block|{
name|title
argument_list|(
literal|"Logging in"
argument_list|)
expr_stmt|;
if|if
condition|(
name|keytab
operator|!=
literal|null
condition|)
block|{
name|dumpKeytab
argument_list|(
name|keytab
argument_list|)
expr_stmt|;
name|loginFromKeytab
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|UserGroupInformation
name|loginUser
init|=
name|getLoginUser
argument_list|()
decl_stmt|;
name|dumpUGI
argument_list|(
literal|"Log in user"
argument_list|,
name|loginUser
argument_list|)
expr_stmt|;
name|validateUGI
argument_list|(
literal|"Login user"
argument_list|,
name|loginUser
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"Ticket based login: %b"
argument_list|,
name|isLoginTicketBased
argument_list|()
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"Keytab based login: %b"
argument_list|,
name|isLoginKeytabBased
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
finally|finally
block|{
comment|// restore original system properties
name|System
operator|.
name|setProperty
argument_list|(
name|SUN_SECURITY_KRB5_DEBUG
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|krb5Debug
argument_list|)
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
name|SUN_SECURITY_SPNEGO_DEBUG
argument_list|,
name|Boolean
operator|.
name|toString
argument_list|(
name|spnegoDebug
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Is the authentication method of this configuration "simple"?    * @param conf configuration to check    * @return true if auth is simple (i.e. not kerberos)    */
DECL|method|isSimpleAuthentication (Configuration conf)
specifier|protected
name|boolean
name|isSimpleAuthentication
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|SecurityUtil
operator|.
name|getAuthenticationMethod
argument_list|(
name|conf
argument_list|)
operator|.
name|equals
argument_list|(
name|AuthenticationMethod
operator|.
name|SIMPLE
argument_list|)
return|;
block|}
comment|/**    * Fail fast on a JVM without JCE installed.    *    * This is a recurrent problem    * (that is: it keeps creeping back with JVM updates);    * a fast failure is the best tactic.    * @throws NoSuchAlgorithmException    */
DECL|method|validateKeyLength ()
specifier|protected
name|void
name|validateKeyLength
parameter_list|()
throws|throws
name|NoSuchAlgorithmException
block|{
name|int
name|aesLen
init|=
name|Cipher
operator|.
name|getMaxAllowedKeyLength
argument_list|(
literal|"AES"
argument_list|)
decl_stmt|;
name|println
argument_list|(
literal|"Maximum AES encryption key length %d bits"
argument_list|,
name|aesLen
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|minKeyLength
operator|<=
name|aesLen
argument_list|,
name|CAT_JVM
argument_list|,
literal|"Java Cryptography Extensions are not installed on this JVM."
operator|+
literal|" Maximum supported key length %s - minimum required %d"
argument_list|,
name|aesLen
argument_list|,
name|minKeyLength
argument_list|)
expr_stmt|;
block|}
comment|/**    * Verify whether auth_to_local rules transform a principal name    *<p>    * Having a local user name "bar@foo.com" may be harmless, so it is noted at    * info. However if what was intended is a transformation to "bar"    * it can be difficult to debug, hence this check.    */
DECL|method|validateShortName ()
specifier|protected
name|void
name|validateShortName
parameter_list|()
block|{
name|failif
argument_list|(
name|principal
operator|==
literal|null
argument_list|,
name|CAT_KERBEROS
argument_list|,
literal|"No principal defined"
argument_list|)
expr_stmt|;
try|try
block|{
name|KerberosName
name|kn
init|=
operator|new
name|KerberosName
argument_list|(
name|principal
argument_list|)
decl_stmt|;
name|String
name|result
init|=
name|kn
operator|.
name|getShortName
argument_list|()
decl_stmt|;
if|if
condition|(
name|nonSimplePattern
operator|.
name|matcher
argument_list|(
name|result
argument_list|)
operator|.
name|find
argument_list|()
condition|)
block|{
name|warn
argument_list|(
name|CAT_KERBEROS
argument_list|,
name|principal
operator|+
literal|" short name: "
operator|+
name|result
operator|+
literal|" still contains @ or /"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|KerberosDiagsFailure
argument_list|(
name|CAT_KERBEROS
argument_list|,
name|e
argument_list|,
literal|"Failed to get short name for "
operator|+
name|principal
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
name|error
argument_list|(
name|CAT_KERBEROS
argument_list|,
literal|"KerberosName("
operator|+
name|principal
operator|+
literal|") failed: %s\n%s"
argument_list|,
name|e
argument_list|,
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Get the default realm.    *<p>    * Not having a default realm may be harmless, so is noted at info.    * All other invocation failures are downgraded to warn, as    * follow-on actions may still work.    * Failure to invoke the method via introspection is considered a failure,    * as it's a sign of JVM compatibility issues that may have other     * consequences    */
DECL|method|printDefaultRealm ()
specifier|protected
name|void
name|printDefaultRealm
parameter_list|()
block|{
try|try
block|{
name|String
name|defaultRealm
init|=
name|getDefaultRealm
argument_list|()
decl_stmt|;
name|println
argument_list|(
literal|"Default Realm = %s"
argument_list|,
name|defaultRealm
argument_list|)
expr_stmt|;
if|if
condition|(
name|defaultRealm
operator|==
literal|null
condition|)
block|{
name|warn
argument_list|(
name|CAT_KERBEROS
argument_list|,
literal|"Host has no default realm"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
decl||
name|IllegalAccessException
decl||
name|NoSuchMethodException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|KerberosDiagsFailure
argument_list|(
name|CAT_JVM
argument_list|,
name|e
argument_list|,
literal|"Failed to invoke krb5.Config.getDefaultRealm: %s: "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InvocationTargetException
name|e
parameter_list|)
block|{
name|Throwable
name|cause
init|=
name|e
operator|.
name|getCause
argument_list|()
operator|!=
literal|null
condition|?
name|e
operator|.
name|getCause
argument_list|()
else|:
name|e
decl_stmt|;
if|if
condition|(
name|cause
operator|.
name|toString
argument_list|()
operator|.
name|contains
argument_list|(
name|NO_DEFAULT_REALM
argument_list|)
condition|)
block|{
comment|// exception raised if there is no default realm. This is not
comment|// always a problem, so downgrade to a message.
name|warn
argument_list|(
name|CAT_KERBEROS
argument_list|,
literal|"Host has no default realm"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|cause
operator|.
name|toString
argument_list|()
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|CAT_KERBEROS
argument_list|,
literal|"Kerberos.getDefaultRealm() failed: %s\n%s"
argument_list|,
name|cause
argument_list|,
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|cause
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Validate that hadoop.token.files (if specified) exist and are valid.    * @throws ClassNotFoundException    * @throws SecurityException    * @throws NoSuchMethodException    * @throws KerberosDiagsFailure    */
DECL|method|validateHadoopTokenFiles (Configuration conf)
specifier|private
name|void
name|validateHadoopTokenFiles
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|ClassNotFoundException
throws|,
name|KerberosDiagsFailure
throws|,
name|NoSuchMethodException
throws|,
name|SecurityException
block|{
name|title
argument_list|(
literal|"Locating Hadoop token files"
argument_list|)
expr_stmt|;
name|String
name|tokenFileLocation
init|=
name|System
operator|.
name|getProperty
argument_list|(
name|HADOOP_TOKEN_FILES
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokenFileLocation
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
literal|"Found "
operator|+
name|HADOOP_TOKEN_FILES
operator|+
literal|" in system properties : "
operator|+
name|tokenFileLocation
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conf
operator|.
name|get
argument_list|(
name|HADOOP_TOKEN_FILES
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
literal|"Found "
operator|+
name|HADOOP_TOKEN_FILES
operator|+
literal|" in hadoop configuration : "
operator|+
name|conf
operator|.
name|get
argument_list|(
name|HADOOP_TOKEN_FILES
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|System
operator|.
name|getProperty
argument_list|(
name|HADOOP_TOKEN_FILES
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
name|HADOOP_TOKEN_FILES
operator|+
literal|" in the system properties overrides the"
operator|+
literal|" one specified in hadoop configuration"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tokenFileLocation
operator|=
name|conf
operator|.
name|get
argument_list|(
name|HADOOP_TOKEN_FILES
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tokenFileLocation
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|String
name|tokenFileName
range|:
name|StringUtils
operator|.
name|getTrimmedStrings
argument_list|(
name|tokenFileLocation
argument_list|)
control|)
block|{
if|if
condition|(
name|tokenFileName
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|File
name|tokenFile
init|=
operator|new
name|File
argument_list|(
name|tokenFileName
argument_list|)
decl_stmt|;
name|verifyFileIsValid
argument_list|(
name|tokenFile
argument_list|,
name|CAT_TOKEN
argument_list|,
literal|"token"
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|tokenFile
argument_list|,
name|conf
argument_list|,
name|CAT_TOKEN
argument_list|,
literal|"token"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**    * Locate the {@code krb5.conf} file and dump it.    *    * No-op on windows.    * @throws IOException problems reading the file.    */
DECL|method|validateKrb5File ()
specifier|private
name|void
name|validateKrb5File
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|Shell
operator|.
name|WINDOWS
condition|)
block|{
name|title
argument_list|(
literal|"Locating Kerberos configuration file"
argument_list|)
expr_stmt|;
name|String
name|krbPath
init|=
name|ETC_KRB5_CONF
decl_stmt|;
name|String
name|jvmKrbPath
init|=
name|System
operator|.
name|getProperty
argument_list|(
name|JAVA_SECURITY_KRB5_CONF
argument_list|)
decl_stmt|;
if|if
condition|(
name|jvmKrbPath
operator|!=
literal|null
operator|&&
operator|!
name|jvmKrbPath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|println
argument_list|(
literal|"Setting kerberos path from sysprop %s: \"%s\""
argument_list|,
name|JAVA_SECURITY_KRB5_CONF
argument_list|,
name|jvmKrbPath
argument_list|)
expr_stmt|;
name|krbPath
operator|=
name|jvmKrbPath
expr_stmt|;
block|}
name|String
name|krb5name
init|=
name|System
operator|.
name|getenv
argument_list|(
name|KRB5_CCNAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|krb5name
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
literal|"Setting kerberos path from environment variable %s: \"%s\""
argument_list|,
name|KRB5_CCNAME
argument_list|,
name|krb5name
argument_list|)
expr_stmt|;
name|krbPath
operator|=
name|krb5name
expr_stmt|;
if|if
condition|(
name|jvmKrbPath
operator|!=
literal|null
condition|)
block|{
name|println
argument_list|(
literal|"Warning - both %s and %s were set - %s takes priority"
argument_list|,
name|JAVA_SECURITY_KRB5_CONF
argument_list|,
name|KRB5_CCNAME
argument_list|,
name|KRB5_CCNAME
argument_list|)
expr_stmt|;
block|}
block|}
name|File
name|krbFile
init|=
operator|new
name|File
argument_list|(
name|krbPath
argument_list|)
decl_stmt|;
name|println
argument_list|(
literal|"Kerberos configuration file = %s"
argument_list|,
name|krbFile
argument_list|)
expr_stmt|;
name|dump
argument_list|(
name|krbFile
argument_list|)
expr_stmt|;
name|endln
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Dump a keytab: list all principals.    *    * @param keytabFile the keytab file    * @throws IOException IO problems    */
DECL|method|dumpKeytab (File keytabFile)
specifier|private
name|void
name|dumpKeytab
parameter_list|(
name|File
name|keytabFile
parameter_list|)
throws|throws
name|IOException
block|{
name|title
argument_list|(
literal|"Examining keytab %s"
argument_list|,
name|keytabFile
argument_list|)
expr_stmt|;
name|File
name|kt
init|=
name|keytabFile
operator|.
name|getCanonicalFile
argument_list|()
decl_stmt|;
name|verifyFileIsValid
argument_list|(
name|kt
argument_list|,
name|CAT_KERBEROS
argument_list|,
literal|"keytab"
argument_list|)
expr_stmt|;
name|Keytab
name|loadKeytab
init|=
name|Keytab
operator|.
name|loadKeytab
argument_list|(
name|kt
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|PrincipalName
argument_list|>
name|principals
init|=
name|loadKeytab
operator|.
name|getPrincipals
argument_list|()
decl_stmt|;
name|println
argument_list|(
literal|"keytab princial count: %d"
argument_list|,
name|principals
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|entrySize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|PrincipalName
name|princ
range|:
name|principals
control|)
block|{
name|List
argument_list|<
name|KeytabEntry
argument_list|>
name|entries
init|=
name|loadKeytab
operator|.
name|getKeytabEntries
argument_list|(
name|princ
argument_list|)
decl_stmt|;
name|entrySize
operator|=
name|entrySize
operator|+
name|entries
operator|.
name|size
argument_list|()
expr_stmt|;
for|for
control|(
name|KeytabEntry
name|entry
range|:
name|entries
control|)
block|{
name|EncryptionKey
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|println
argument_list|(
literal|" %s: version=%d expires=%s encryption=%s"
argument_list|,
name|entry
operator|.
name|getPrincipal
argument_list|()
argument_list|,
name|entry
operator|.
name|getKvno
argument_list|()
argument_list|,
name|entry
operator|.
name|getTimestamp
argument_list|()
argument_list|,
name|key
operator|.
name|getKeyType
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|println
argument_list|(
literal|"keytab entry count: %d"
argument_list|,
name|entrySize
argument_list|)
expr_stmt|;
name|endln
argument_list|()
expr_stmt|;
block|}
comment|/**    * Log in from a keytab, dump the UGI, validate it, then try and log in again.    *    * That second-time login catches JVM/Hadoop compatibility problems.    * @throws IOException Keytab loading problems    */
DECL|method|loginFromKeytab ()
specifier|private
name|void
name|loginFromKeytab
parameter_list|()
throws|throws
name|IOException
block|{
name|UserGroupInformation
name|ugi
decl_stmt|;
name|String
name|identity
decl_stmt|;
if|if
condition|(
name|keytab
operator|!=
literal|null
condition|)
block|{
name|File
name|kt
init|=
name|keytab
operator|.
name|getCanonicalFile
argument_list|()
decl_stmt|;
name|println
argument_list|(
literal|"Using keytab %s principal %s"
argument_list|,
name|kt
argument_list|,
name|principal
argument_list|)
expr_stmt|;
name|identity
operator|=
name|principal
expr_stmt|;
name|failif
argument_list|(
name|principal
operator|==
literal|null
argument_list|,
name|CAT_KERBEROS
argument_list|,
literal|"No principal defined"
argument_list|)
expr_stmt|;
name|ugi
operator|=
name|loginUserFromKeytabAndReturnUGI
argument_list|(
name|principal
argument_list|,
name|kt
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|dumpUGI
argument_list|(
name|identity
argument_list|,
name|ugi
argument_list|)
expr_stmt|;
name|validateUGI
argument_list|(
name|principal
argument_list|,
name|ugi
argument_list|)
expr_stmt|;
name|title
argument_list|(
literal|"Attempting to relogin"
argument_list|)
expr_stmt|;
try|try
block|{
comment|// package scoped -hence the reason why this class must be in the
comment|// hadoop.security package
name|setShouldRenewImmediatelyForTests
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// attempt a new login
name|ugi
operator|.
name|reloginFromKeytab
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessError
name|e
parameter_list|)
block|{
comment|// if you've built this class into an independent JAR, package-access
comment|// may fail. Downgrade
name|warn
argument_list|(
name|CAT_UGI
argument_list|,
literal|"Failed to reset UGI -and so could not try to relogin"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to reset UGI: {}"
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|println
argument_list|(
literal|"No keytab: attempting to log in is as current user"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Dump a UGI.    *    * @param title title of this section    * @param ugi UGI to dump    * @throws IOException    */
DECL|method|dumpUGI (String title, UserGroupInformation ugi)
specifier|private
name|void
name|dumpUGI
parameter_list|(
name|String
name|title
parameter_list|,
name|UserGroupInformation
name|ugi
parameter_list|)
throws|throws
name|IOException
block|{
name|title
argument_list|(
name|title
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"UGI instance = %s"
argument_list|,
name|ugi
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"Has kerberos credentials: %b"
argument_list|,
name|ugi
operator|.
name|hasKerberosCredentials
argument_list|()
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"Authentication method: %s"
argument_list|,
name|ugi
operator|.
name|getAuthenticationMethod
argument_list|()
argument_list|)
expr_stmt|;
name|println
argument_list|(
literal|"Real Authentication method: %s"
argument_list|,
name|ugi
operator|.
name|getRealAuthenticationMethod
argument_list|()
argument_list|)
expr_stmt|;
name|title
argument_list|(
literal|"Group names"
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|name
range|:
name|ugi
operator|.
name|getGroupNames
argument_list|()
control|)
block|{
name|println
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|title
argument_list|(
literal|"Credentials"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Text
argument_list|>
name|secretKeys
init|=
name|ugi
operator|.
name|getCredentials
argument_list|()
operator|.
name|getAllSecretKeys
argument_list|()
decl_stmt|;
name|title
argument_list|(
literal|"Secret keys"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|secretKeys
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|Text
name|secret
range|:
name|secretKeys
control|)
block|{
name|println
argument_list|(
literal|"%s"
argument_list|,
name|secret
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|println
argument_list|(
literal|"(none)"
argument_list|)
expr_stmt|;
block|}
name|dumpTokens
argument_list|(
name|ugi
argument_list|)
expr_stmt|;
block|}
comment|/**    * Validate the UGI: verify it is kerberized.    * @param messagePrefix message in exceptions    * @param user user to validate    */
DECL|method|validateUGI (String messagePrefix, UserGroupInformation user)
specifier|private
name|void
name|validateUGI
parameter_list|(
name|String
name|messagePrefix
parameter_list|,
name|UserGroupInformation
name|user
parameter_list|)
block|{
if|if
condition|(
name|verify
argument_list|(
name|user
operator|.
name|getAuthenticationMethod
argument_list|()
operator|==
name|AuthenticationMethod
operator|.
name|KERBEROS
argument_list|,
name|CAT_LOGIN
argument_list|,
literal|"User %s is not authenticated by Kerberos"
argument_list|,
name|user
argument_list|)
condition|)
block|{
name|verify
argument_list|(
name|user
operator|.
name|hasKerberosCredentials
argument_list|()
argument_list|,
name|CAT_LOGIN
argument_list|,
literal|"%s: No kerberos credentials for %s"
argument_list|,
name|messagePrefix
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|verify
argument_list|(
name|user
operator|.
name|getAuthenticationMethod
argument_list|()
operator|!=
literal|null
argument_list|,
name|CAT_LOGIN
argument_list|,
literal|"%s: Null AuthenticationMethod for %s"
argument_list|,
name|messagePrefix
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * A cursory look at the {@code kinit} executable.    *    * If it is an absolute path: it must exist with a size> 0.    * If it is just a command, it has to be on the path. There's no check    * for that -but the PATH is printed out.    */
DECL|method|validateKinitExecutable ()
specifier|private
name|void
name|validateKinitExecutable
parameter_list|()
block|{
name|String
name|kinit
init|=
name|getConf
argument_list|()
operator|.
name|getTrimmed
argument_list|(
name|KERBEROS_KINIT_COMMAND
argument_list|,
literal|""
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|kinit
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|File
name|kinitPath
init|=
operator|new
name|File
argument_list|(
name|kinit
argument_list|)
decl_stmt|;
name|println
argument_list|(
literal|"%s = %s"
argument_list|,
name|KERBEROS_KINIT_COMMAND
argument_list|,
name|kinitPath
argument_list|)
expr_stmt|;
if|if
condition|(
name|kinitPath
operator|.
name|isAbsolute
argument_list|()
condition|)
block|{
name|verifyFileIsValid
argument_list|(
name|kinitPath
argument_list|,
name|CAT_KERBEROS
argument_list|,
name|KERBEROS_KINIT_COMMAND
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|println
argument_list|(
literal|"Executable %s is relative -must be on the PATH"
argument_list|,
name|kinit
argument_list|)
expr_stmt|;
name|printEnv
argument_list|(
literal|"PATH"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Try to load the SASL resolver.    * @param saslPropsResolverKey key for the SASL resolver    */
DECL|method|validateSasl (String saslPropsResolverKey)
specifier|private
name|void
name|validateSasl
parameter_list|(
name|String
name|saslPropsResolverKey
parameter_list|)
block|{
name|title
argument_list|(
literal|"Resolving SASL property %s"
argument_list|,
name|saslPropsResolverKey
argument_list|)
expr_stmt|;
name|String
name|saslPropsResolver
init|=
name|getConf
argument_list|()
operator|.
name|getTrimmed
argument_list|(
name|saslPropsResolverKey
argument_list|)
decl_stmt|;
try|try
block|{
name|Class
argument_list|<
name|?
extends|extends
name|SaslPropertiesResolver
argument_list|>
name|resolverClass
init|=
name|getConf
argument_list|()
operator|.
name|getClass
argument_list|(
name|saslPropsResolverKey
argument_list|,
name|SaslPropertiesResolver
operator|.
name|class
argument_list|,
name|SaslPropertiesResolver
operator|.
name|class
argument_list|)
decl_stmt|;
name|println
argument_list|(
literal|"Resolver is %s"
argument_list|,
name|resolverClass
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|KerberosDiagsFailure
argument_list|(
name|CAT_SASL
argument_list|,
name|e
argument_list|,
literal|"Failed to load %s class %s"
argument_list|,
name|saslPropsResolverKey
argument_list|,
name|saslPropsResolver
argument_list|)
throw|;
block|}
block|}
comment|/**    * Validate any JAAS entry referenced in the {@link #SUN_SECURITY_JAAS_FILE}    * property.    * @param jaasRequired is JAAS required    */
DECL|method|validateJAAS (boolean jaasRequired)
specifier|private
name|void
name|validateJAAS
parameter_list|(
name|boolean
name|jaasRequired
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|jaasFilename
init|=
name|System
operator|.
name|getProperty
argument_list|(
name|SUN_SECURITY_JAAS_FILE
argument_list|)
decl_stmt|;
if|if
condition|(
name|jaasRequired
condition|)
block|{
name|verify
argument_list|(
name|jaasFilename
operator|!=
literal|null
argument_list|,
name|CAT_JAAS
argument_list|,
literal|"No JAAS file specified in "
operator|+
name|SUN_SECURITY_JAAS_FILE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|jaasFilename
operator|!=
literal|null
condition|)
block|{
name|title
argument_list|(
literal|"JAAS"
argument_list|)
expr_stmt|;
name|File
name|jaasFile
init|=
operator|new
name|File
argument_list|(
name|jaasFilename
argument_list|)
decl_stmt|;
name|println
argument_list|(
literal|"JAAS file is defined in %s: %s"
argument_list|,
name|SUN_SECURITY_JAAS_FILE
argument_list|,
name|jaasFile
argument_list|)
expr_stmt|;
name|verifyFileIsValid
argument_list|(
name|jaasFile
argument_list|,
name|CAT_JAAS
argument_list|,
literal|"JAAS file defined in "
operator|+
name|SUN_SECURITY_JAAS_FILE
argument_list|)
expr_stmt|;
name|dump
argument_list|(
name|jaasFile
argument_list|)
expr_stmt|;
name|endln
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|validateNTPConf ()
specifier|private
name|void
name|validateNTPConf
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|Shell
operator|.
name|WINDOWS
condition|)
block|{
name|File
name|ntpfile
init|=
operator|new
name|File
argument_list|(
name|ETC_NTP
argument_list|)
decl_stmt|;
if|if
condition|(
name|ntpfile
operator|.
name|exists
argument_list|()
operator|&&
name|verifyFileIsValid
argument_list|(
name|ntpfile
argument_list|,
name|CAT_OS
argument_list|,
literal|"NTP file: "
operator|+
name|ntpfile
argument_list|)
condition|)
block|{
name|title
argument_list|(
literal|"NTP"
argument_list|)
expr_stmt|;
name|dump
argument_list|(
name|ntpfile
argument_list|)
expr_stmt|;
name|endln
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Verify that a file is valid: it is a file, non-empty and readable.    * @param file file    * @param category category for exceptions    * @param text text message    * @return true if the validation held; false if it did not<i>and</i>    * {@link #nofail} has disabled raising exceptions.    */
DECL|method|verifyFileIsValid (File file, String category, String text)
specifier|private
name|boolean
name|verifyFileIsValid
parameter_list|(
name|File
name|file
parameter_list|,
name|String
name|category
parameter_list|,
name|String
name|text
parameter_list|)
block|{
return|return
name|verify
argument_list|(
name|file
operator|.
name|exists
argument_list|()
argument_list|,
name|category
argument_list|,
literal|"%s file does not exist: %s"
argument_list|,
name|text
argument_list|,
name|file
argument_list|)
operator|&&
name|verify
argument_list|(
name|file
operator|.
name|isFile
argument_list|()
argument_list|,
name|category
argument_list|,
literal|"%s path does not refer to a file: %s"
argument_list|,
name|text
argument_list|,
name|file
argument_list|)
operator|&&
name|verify
argument_list|(
name|file
operator|.
name|length
argument_list|()
operator|!=
literal|0
argument_list|,
name|category
argument_list|,
literal|"%s file is empty: %s"
argument_list|,
name|text
argument_list|,
name|file
argument_list|)
operator|&&
name|verify
argument_list|(
name|file
operator|.
name|canRead
argument_list|()
argument_list|,
name|category
argument_list|,
literal|"%s file is not readable: %s"
argument_list|,
name|text
argument_list|,
name|file
argument_list|)
return|;
block|}
comment|/**    * Dump all tokens of a UGI.    * @param ugi UGI to examine    */
DECL|method|dumpTokens (UserGroupInformation ugi)
specifier|public
name|void
name|dumpTokens
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|)
block|{
name|Collection
argument_list|<
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
argument_list|>
name|tokens
init|=
name|ugi
operator|.
name|getCredentials
argument_list|()
operator|.
name|getAllTokens
argument_list|()
decl_stmt|;
name|title
argument_list|(
literal|"Token Count: %d"
argument_list|,
name|tokens
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Token
argument_list|<
name|?
extends|extends
name|TokenIdentifier
argument_list|>
name|token
range|:
name|tokens
control|)
block|{
name|println
argument_list|(
literal|"Token %s"
argument_list|,
name|token
operator|.
name|getKind
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|endln
argument_list|()
expr_stmt|;
block|}
comment|/**    * Set the System property to true; return the old value for caching.    *    * @param sysprop property    * @return the previous value    */
DECL|method|getAndSet (String sysprop)
specifier|private
name|boolean
name|getAndSet
parameter_list|(
name|String
name|sysprop
parameter_list|)
block|{
name|boolean
name|old
init|=
name|Boolean
operator|.
name|getBoolean
argument_list|(
name|sysprop
argument_list|)
decl_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
name|sysprop
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
return|return
name|old
return|;
block|}
comment|/**    * Flush all active output channels, including {@Code System.err},    * so as to stay in sync with any JRE log messages.    */
DECL|method|flush ()
specifier|private
name|void
name|flush
parameter_list|()
block|{
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
name|System
operator|.
name|err
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**    * Print a line of output. This goes to any output file, or    * is logged at info. The output is flushed before and after, to    * try and stay in sync with JRE logging.    *    * @param format format string    * @param args any arguments    */
DECL|method|println (String format, Object... args)
specifier|private
name|void
name|println
parameter_list|(
name|String
name|format
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
block|{
name|flush
argument_list|()
expr_stmt|;
name|String
name|msg
init|=
name|String
operator|.
name|format
argument_list|(
name|format
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|out
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|println
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|()
expr_stmt|;
block|}
comment|/**    * Print a new line    */
DECL|method|println ()
specifier|private
name|void
name|println
parameter_list|()
block|{
name|println
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/**    * Print something at the end of a section    */
DECL|method|endln ()
specifier|private
name|void
name|endln
parameter_list|()
block|{
name|println
argument_list|()
expr_stmt|;
name|println
argument_list|(
literal|"-----"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Print a title entry.    *    * @param format format string    * @param args any arguments    */
DECL|method|title (String format, Object... args)
specifier|private
name|void
name|title
parameter_list|(
name|String
name|format
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
block|{
name|println
argument_list|()
expr_stmt|;
name|println
argument_list|()
expr_stmt|;
name|println
argument_list|(
literal|"== "
operator|+
name|String
operator|.
name|format
argument_list|(
name|format
argument_list|,
name|args
argument_list|)
operator|+
literal|" =="
argument_list|)
expr_stmt|;
name|println
argument_list|()
expr_stmt|;
block|}
comment|/**    * Print a system property, or {@link #UNSET} if unset.    * @param property property to print    */
DECL|method|printSysprop (String property)
specifier|private
name|void
name|printSysprop
parameter_list|(
name|String
name|property
parameter_list|)
block|{
name|println
argument_list|(
literal|"%s = \"%s\""
argument_list|,
name|property
argument_list|,
name|System
operator|.
name|getProperty
argument_list|(
name|property
argument_list|,
name|UNSET
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Print a configuration option, or {@link #UNSET} if unset.    *    * @param option option to print    */
DECL|method|printConfOpt (String option)
specifier|private
name|void
name|printConfOpt
parameter_list|(
name|String
name|option
parameter_list|)
block|{
name|println
argument_list|(
literal|"%s = \"%s\""
argument_list|,
name|option
argument_list|,
name|getConf
argument_list|()
operator|.
name|get
argument_list|(
name|option
argument_list|,
name|UNSET
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Print an environment variable's name and value; printing    * {@link #UNSET} if it is not set.    * @param variable environment variable    */
DECL|method|printEnv (String variable)
specifier|private
name|void
name|printEnv
parameter_list|(
name|String
name|variable
parameter_list|)
block|{
name|String
name|env
init|=
name|System
operator|.
name|getenv
argument_list|(
name|variable
argument_list|)
decl_stmt|;
name|println
argument_list|(
literal|"%s = \"%s\""
argument_list|,
name|variable
argument_list|,
name|env
operator|!=
literal|null
condition|?
name|env
else|:
name|UNSET
argument_list|)
expr_stmt|;
block|}
comment|/**    * Dump any file to standard out.    * @param file file to dump    * @throws IOException IO problems    */
DECL|method|dump (File file)
specifier|private
name|void
name|dump
parameter_list|(
name|File
name|file
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|FileInputStream
name|in
init|=
operator|new
name|FileInputStream
argument_list|(
name|file
argument_list|)
init|)
block|{
for|for
control|(
name|String
name|line
range|:
name|IOUtils
operator|.
name|readLines
argument_list|(
name|in
argument_list|)
control|)
block|{
name|println
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Format and raise a failure.    *    * @param category category for exception    * @param message string formatting message    * @param args any arguments for the formatting    * @throws KerberosDiagsFailure containing the formatted text    */
DECL|method|fail (String category, String message, Object... args)
specifier|private
name|void
name|fail
parameter_list|(
name|String
name|category
parameter_list|,
name|String
name|message
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
throws|throws
name|KerberosDiagsFailure
block|{
name|error
argument_list|(
name|category
argument_list|,
name|message
argument_list|,
name|args
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|KerberosDiagsFailure
argument_list|(
name|category
argument_list|,
name|message
argument_list|,
name|args
argument_list|)
throw|;
block|}
comment|/**    * Assert that a condition must hold.    *    * If not, an exception is raised, or, if {@link #nofail} is set,    * an error will be logged and the method return false.    *    * @param condition condition which must hold    * @param category category for exception    * @param message string formatting message    * @param args any arguments for the formatting    * @return true if the verification succeeded, false if it failed but    * an exception was not raised.    * @throws KerberosDiagsFailure containing the formatted text    *         if the condition was met    */
DECL|method|verify (boolean condition, String category, String message, Object... args)
specifier|private
name|boolean
name|verify
parameter_list|(
name|boolean
name|condition
parameter_list|,
name|String
name|category
parameter_list|,
name|String
name|message
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
throws|throws
name|KerberosDiagsFailure
block|{
if|if
condition|(
operator|!
name|condition
condition|)
block|{
comment|// condition not met: fail or report
name|probeHasFailed
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|nofail
condition|)
block|{
name|fail
argument_list|(
name|category
argument_list|,
name|message
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|category
argument_list|,
name|message
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// condition is met
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Verify that tokenFile contains valid Credentials.    *    * If not, an exception is raised, or, if {@link #nofail} is set,    * an error will be logged and the method return false.    *    */
DECL|method|verify (File tokenFile, Configuration conf, String category, String message)
specifier|private
name|boolean
name|verify
parameter_list|(
name|File
name|tokenFile
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|String
name|category
parameter_list|,
name|String
name|message
parameter_list|)
throws|throws
name|KerberosDiagsFailure
block|{
try|try
block|{
name|Credentials
operator|.
name|readTokenStorageFile
argument_list|(
name|tokenFile
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|nofail
condition|)
block|{
name|fail
argument_list|(
name|category
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|category
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Print a message as an error    * @param category error category    * @param message format string    * @param args list of arguments    */
DECL|method|error (String category, String message, Object...args)
specifier|private
name|void
name|error
parameter_list|(
name|String
name|category
parameter_list|,
name|String
name|message
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
block|{
name|println
argument_list|(
literal|"ERROR: %s: %s"
argument_list|,
name|category
argument_list|,
name|String
operator|.
name|format
argument_list|(
name|message
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Print a message as an warning    * @param category error category    * @param message format string    * @param args list of arguments    */
DECL|method|warn (String category, String message, Object...args)
specifier|private
name|void
name|warn
parameter_list|(
name|String
name|category
parameter_list|,
name|String
name|message
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
block|{
name|println
argument_list|(
literal|"WARNING: %s: %s"
argument_list|,
name|category
argument_list|,
name|String
operator|.
name|format
argument_list|(
name|message
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Conditional failure with string formatted arguments.    * There is no chek for the {@link #nofail} value.    * @param condition failure condition    * @param category category for exception    * @param message string formatting message    * @param args any arguments for the formatting    * @throws KerberosDiagsFailure containing the formatted text    *         if the condition was met    */
DECL|method|failif (boolean condition, String category, String message, Object... args)
specifier|private
name|void
name|failif
parameter_list|(
name|boolean
name|condition
parameter_list|,
name|String
name|category
parameter_list|,
name|String
name|message
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
throws|throws
name|KerberosDiagsFailure
block|{
if|if
condition|(
name|condition
condition|)
block|{
name|fail
argument_list|(
name|category
argument_list|,
name|message
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Inner entry point, with no logging or system exits.    *    * @param conf configuration    * @param argv argument list    * @return an exception    * @throws Exception    */
DECL|method|exec (Configuration conf, String... argv)
specifier|public
specifier|static
name|int
name|exec
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
modifier|...
name|argv
parameter_list|)
throws|throws
name|Exception
block|{
try|try
init|(
name|KDiag
name|kdiag
init|=
operator|new
name|KDiag
argument_list|()
init|)
block|{
return|return
name|ToolRunner
operator|.
name|run
argument_list|(
name|conf
argument_list|,
name|kdiag
argument_list|,
name|argv
argument_list|)
return|;
block|}
block|}
comment|/**    * Main entry point.    * @param argv args list    */
DECL|method|main (String[] argv)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|argv
parameter_list|)
block|{
try|try
block|{
name|ExitUtil
operator|.
name|terminate
argument_list|(
name|exec
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|,
name|argv
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExitUtil
operator|.
name|ExitException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|exit
argument_list|(
name|e
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|e
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|ExitUtil
operator|.
name|halt
argument_list|(
operator|-
literal|1
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Diagnostics failures return the exit code 41, "unauthorized".    *    * They have a category, initially for testing: the category can be    * validated without having to match on the entire string.    */
DECL|class|KerberosDiagsFailure
specifier|public
specifier|static
class|class
name|KerberosDiagsFailure
extends|extends
name|ExitUtil
operator|.
name|ExitException
block|{
DECL|field|category
specifier|private
specifier|final
name|String
name|category
decl_stmt|;
DECL|method|KerberosDiagsFailure (String category, String message)
specifier|public
name|KerberosDiagsFailure
parameter_list|(
name|String
name|category
parameter_list|,
name|String
name|message
parameter_list|)
block|{
name|super
argument_list|(
name|KDIAG_FAILURE
argument_list|,
name|category
operator|+
literal|": "
operator|+
name|message
argument_list|)
expr_stmt|;
name|this
operator|.
name|category
operator|=
name|category
expr_stmt|;
block|}
DECL|method|KerberosDiagsFailure (String category, String message, Object... args)
specifier|public
name|KerberosDiagsFailure
parameter_list|(
name|String
name|category
parameter_list|,
name|String
name|message
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
block|{
name|this
argument_list|(
name|category
argument_list|,
name|String
operator|.
name|format
argument_list|(
name|message
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|KerberosDiagsFailure (String category, Throwable throwable, String message, Object... args)
specifier|public
name|KerberosDiagsFailure
parameter_list|(
name|String
name|category
parameter_list|,
name|Throwable
name|throwable
parameter_list|,
name|String
name|message
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
block|{
name|this
argument_list|(
name|category
argument_list|,
name|message
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|initCause
argument_list|(
name|throwable
argument_list|)
expr_stmt|;
block|}
DECL|method|getCategory ()
specifier|public
name|String
name|getCategory
parameter_list|()
block|{
return|return
name|category
return|;
block|}
block|}
block|}
end_class

end_unit

