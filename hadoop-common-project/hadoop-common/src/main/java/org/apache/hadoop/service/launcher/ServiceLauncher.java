begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  *  or more contributor license agreements.  See the NOTICE file  *  distributed with this work for additional information  *  regarding copyright ownership.  The ASF licenses this file  *  to you under the Apache License, Version 2.0 (the  *  "License"); you may not use this file except in compliance  *  with the License.  You may obtain a copy of the License at  *  *       http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.service.launcher
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|launcher
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|CommandLine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|Option
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|OptionBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|cli
operator|.
name|Options
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|service
operator|.
name|Service
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ExitCodeProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ExitUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|GenericOptionsParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_comment
comment|/**  * A class to launch any YARN service by name.  *  * It's designed to be subclassed for custom entry points.  *  * Workflow:  *<ol>  *<li>An instance of the class is created. It must be of the type  *   {@link Service}</li>  *<li>If it implements  *   {@link LaunchableService#bindArgs(Configuration, List)},  *    it is given the binding args off the CLI after all general configuration  *    arguments have been stripped.</li>  *<li>Its {@link Service#init(Configuration)} and {@link Service#start()}  *   methods are called.</li>  *<li>If it implements it, {@link LaunchableService#execute()}  *   is called and its return code used as the exit code.</li>  *<li>Otherwise: it waits for the service to stop, assuming that the  *   {@link Service#start()} method spawns one or more thread  *   to perform work</li>  *<li>If any exception is raised and provides an exit code,  *   that is, it implements {@link ExitCodeProvider},  *   the return value of {@link ExitCodeProvider#getExitCode()},  *   becomes the exit code of the command.</li>  *</ol>  * Error and warning messages are logged to {@code stderr}.  *   * @param<S> service class to cast the generated service to.  */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"UseOfSystemOutOrSystemErr"
argument_list|)
DECL|class|ServiceLauncher
specifier|public
class|class
name|ServiceLauncher
parameter_list|<
name|S
extends|extends
name|Service
parameter_list|>
implements|implements
name|LauncherExitCodes
implements|,
name|LauncherArguments
implements|,
name|Thread
operator|.
name|UncaughtExceptionHandler
block|{
comment|/**    * Logger.    */
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ServiceLauncher
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Priority for the shutdown hook: {@value}.    */
DECL|field|SHUTDOWN_PRIORITY
specifier|protected
specifier|static
specifier|final
name|int
name|SHUTDOWN_PRIORITY
init|=
literal|30
decl_stmt|;
comment|/**    * The name of this class.    */
DECL|field|NAME
specifier|public
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"ServiceLauncher"
decl_stmt|;
DECL|field|USAGE_NAME
specifier|protected
specifier|static
specifier|final
name|String
name|USAGE_NAME
init|=
literal|"Usage: "
operator|+
name|NAME
decl_stmt|;
DECL|field|USAGE_SERVICE_ARGUMENTS
specifier|protected
specifier|static
specifier|final
name|String
name|USAGE_SERVICE_ARGUMENTS
init|=
literal|"service-classname<service arguments>"
decl_stmt|;
comment|/**    * Usage message.    *    * Text: {@value}    */
DECL|field|USAGE_MESSAGE
specifier|public
specifier|static
specifier|final
name|String
name|USAGE_MESSAGE
init|=
name|USAGE_NAME
operator|+
literal|" ["
operator|+
name|ARG_CONF_PREFIXED
operator|+
literal|"<conf file>]"
operator|+
literal|" ["
operator|+
name|ARG_CONFCLASS_PREFIXED
operator|+
literal|"<configuration classname>]"
operator|+
literal|" "
operator|+
name|USAGE_SERVICE_ARGUMENTS
decl_stmt|;
comment|/**    * The shutdown time on an interrupt: {@value}.    */
DECL|field|SHUTDOWN_TIME_ON_INTERRUPT
specifier|private
specifier|static
specifier|final
name|int
name|SHUTDOWN_TIME_ON_INTERRUPT
init|=
literal|30
operator|*
literal|1000
decl_stmt|;
comment|/**    * The launched service.    *    * Invalid until the service has been created.     */
DECL|field|service
specifier|private
specifier|volatile
name|S
name|service
decl_stmt|;
comment|/**    * Exit code of the service.    *    * Invalid until a service has    * executed or stopped, depending on the service type.    */
DECL|field|serviceExitCode
specifier|private
name|int
name|serviceExitCode
decl_stmt|;
comment|/**    * Any exception raised during execution.    */
DECL|field|serviceException
specifier|private
name|ExitUtil
operator|.
name|ExitException
name|serviceException
decl_stmt|;
comment|/**    * The interrupt escalator for the service.    */
DECL|field|interruptEscalator
specifier|private
name|InterruptEscalator
name|interruptEscalator
decl_stmt|;
comment|/**    * Configuration used for the service.    */
DECL|field|configuration
specifier|private
name|Configuration
name|configuration
decl_stmt|;
comment|/**    * Text description of service for messages.    */
DECL|field|serviceName
specifier|private
name|String
name|serviceName
decl_stmt|;
comment|/**    * Classname for the service to create.; empty string otherwise.    */
DECL|field|serviceClassName
specifier|private
name|String
name|serviceClassName
init|=
literal|""
decl_stmt|;
comment|/**    * List of the standard configurations to create (and so load in properties).    * The values are Hadoop, HDFS and YARN configurations.    */
DECL|field|DEFAULT_CONFIGS
specifier|protected
specifier|static
specifier|final
name|String
index|[]
name|DEFAULT_CONFIGS
init|=
block|{
literal|"org.apache.hadoop.conf.Configuration"
block|,
literal|"org.apache.hadoop.hdfs.HdfsConfiguration"
block|,
literal|"org.apache.hadoop.yarn.conf.YarnConfiguration"
block|}
decl_stmt|;
comment|/**    * List of classnames to load to configuration before creating a    * {@link Configuration} instance.    */
DECL|field|confClassnames
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|confClassnames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|DEFAULT_CONFIGS
operator|.
name|length
argument_list|)
decl_stmt|;
comment|/**    * URLs of configurations to load into the configuration instance created.    */
DECL|field|confResourceUrls
specifier|private
name|List
argument_list|<
name|URL
argument_list|>
name|confResourceUrls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|/** Command options. Preserved for usage statements. */
DECL|field|commandOptions
specifier|private
name|Options
name|commandOptions
decl_stmt|;
comment|/**    * Create an instance of the launcher.    * @param serviceClassName classname of the service    */
DECL|method|ServiceLauncher (String serviceClassName)
specifier|public
name|ServiceLauncher
parameter_list|(
name|String
name|serviceClassName
parameter_list|)
block|{
name|this
argument_list|(
name|serviceClassName
argument_list|,
name|serviceClassName
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create an instance of the launcher.    * @param serviceName name of service for text messages    * @param serviceClassName classname of the service    */
DECL|method|ServiceLauncher (String serviceName, String serviceClassName)
specifier|public
name|ServiceLauncher
parameter_list|(
name|String
name|serviceName
parameter_list|,
name|String
name|serviceClassName
parameter_list|)
block|{
name|this
operator|.
name|serviceClassName
operator|=
name|serviceClassName
expr_stmt|;
name|this
operator|.
name|serviceName
operator|=
name|serviceName
expr_stmt|;
comment|// set up initial list of configurations
name|confClassnames
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|DEFAULT_CONFIGS
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the service.    *    * Null until    * {@link #coreServiceLaunch(Configuration, Service, List, boolean, boolean)}    * has completed.    * @return the service    */
DECL|method|getService ()
specifier|public
specifier|final
name|S
name|getService
parameter_list|()
block|{
return|return
name|service
return|;
block|}
comment|/**    * Setter is to give subclasses the ability to manipulate the service.    * @param s the new service    */
DECL|method|setService (S s)
specifier|protected
name|void
name|setService
parameter_list|(
name|S
name|s
parameter_list|)
block|{
name|this
operator|.
name|service
operator|=
name|s
expr_stmt|;
block|}
comment|/**    * Get the configuration constructed from the command line arguments.    * @return the configuration used to create the service    */
DECL|method|getConfiguration ()
specifier|public
specifier|final
name|Configuration
name|getConfiguration
parameter_list|()
block|{
return|return
name|configuration
return|;
block|}
comment|/**    * The exit code from a successful service execution.    * @return the exit code.     */
DECL|method|getServiceExitCode ()
specifier|public
specifier|final
name|int
name|getServiceExitCode
parameter_list|()
block|{
return|return
name|serviceExitCode
return|;
block|}
comment|/**    * Get the exit exception used to end this service.    * @return an exception, which will be null until the service    * has exited (and {@code System.exit} has not been called)    */
DECL|method|getServiceException ()
specifier|public
specifier|final
name|ExitUtil
operator|.
name|ExitException
name|getServiceException
parameter_list|()
block|{
return|return
name|serviceException
return|;
block|}
comment|/**    * Probe for service classname being defined.    * @return true if the classname is set    */
DECL|method|isClassnameDefined ()
specifier|private
name|boolean
name|isClassnameDefined
parameter_list|()
block|{
return|return
name|serviceClassName
operator|!=
literal|null
operator|&&
operator|!
name|serviceClassName
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"\"ServiceLauncher for \""
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|serviceName
argument_list|)
expr_stmt|;
if|if
condition|(
name|isClassnameDefined
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", serviceClassName='"
argument_list|)
operator|.
name|append
argument_list|(
name|serviceClassName
argument_list|)
operator|.
name|append
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|service
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|", service="
argument_list|)
operator|.
name|append
argument_list|(
name|service
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**    * Launch the service and exit.    *    *<ol>    *<li>Parse the command line.</li>     *<li>Build the service configuration from it.</li>    *<li>Start the service.</li>    *<li>If it is a {@link LaunchableService}: execute it</li>    *<li>Otherwise: wait for it to finish.</li>    *<li>Exit passing the status code to the {@link #exit(int, String)}    * method.</li>    *</ol>    * @param args arguments to the service. {@code arg[0]} is     * assumed to be the service classname.    */
DECL|method|launchServiceAndExit (List<String> args)
specifier|public
name|void
name|launchServiceAndExit
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|args
parameter_list|)
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|arg
range|:
name|args
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|'"'
argument_list|)
operator|.
name|append
argument_list|(
name|arg
argument_list|)
operator|.
name|append
argument_list|(
literal|"\" "
argument_list|)
expr_stmt|;
block|}
name|String
name|argumentString
init|=
name|builder
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|startupShutdownMessage
argument_list|(
name|serviceName
argument_list|,
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|argumentString
argument_list|)
expr_stmt|;
block|}
name|registerFailureHandling
argument_list|()
expr_stmt|;
comment|// set up the configs, using reflection to push in the -site.xml files
name|loadConfigurationClasses
argument_list|()
expr_stmt|;
name|Configuration
name|conf
init|=
name|createConfiguration
argument_list|()
decl_stmt|;
for|for
control|(
name|URL
name|resourceUrl
range|:
name|confResourceUrls
control|)
block|{
name|conf
operator|.
name|addResource
argument_list|(
name|resourceUrl
argument_list|)
expr_stmt|;
block|}
name|bindCommandOptions
argument_list|()
expr_stmt|;
name|ExitUtil
operator|.
name|ExitException
name|exitException
decl_stmt|;
try|try
block|{
name|List
argument_list|<
name|String
argument_list|>
name|processedArgs
init|=
name|extractCommandOptions
argument_list|(
name|conf
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|exitException
operator|=
name|launchService
argument_list|(
name|conf
argument_list|,
name|processedArgs
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExitUtil
operator|.
name|ExitException
name|e
parameter_list|)
block|{
name|exitException
operator|=
name|e
expr_stmt|;
name|noteException
argument_list|(
name|exitException
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exitException
operator|.
name|getExitCode
argument_list|()
operator|==
name|LauncherExitCodes
operator|.
name|EXIT_USAGE
condition|)
block|{
comment|// something went wrong. Print the usage and commands
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|getUsageMessage
argument_list|()
argument_list|)
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
literal|"Command: "
operator|+
name|argumentString
argument_list|)
expr_stmt|;
block|}
name|System
operator|.
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|System
operator|.
name|err
operator|.
name|flush
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|exitException
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the {@link #commandOptions} field to the result of    * {@link #createOptions()}; protected for subclasses and test access.    */
DECL|method|bindCommandOptions ()
specifier|protected
name|void
name|bindCommandOptions
parameter_list|()
block|{
name|commandOptions
operator|=
name|createOptions
argument_list|()
expr_stmt|;
block|}
comment|/**    * Record that an Exit Exception has been raised.    * Save it to {@link #serviceException}, with its exit code in    * {@link #serviceExitCode}    * @param exitException exception    */
DECL|method|noteException (ExitUtil.ExitException exitException)
name|void
name|noteException
parameter_list|(
name|ExitUtil
operator|.
name|ExitException
name|exitException
parameter_list|)
block|{
name|int
name|exitCode
init|=
name|exitException
operator|.
name|getExitCode
argument_list|()
decl_stmt|;
if|if
condition|(
name|exitCode
operator|!=
literal|0
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception raised with exit code {}"
argument_list|,
name|exitCode
argument_list|,
name|exitException
argument_list|)
expr_stmt|;
name|Throwable
name|cause
init|=
name|exitException
operator|.
name|getCause
argument_list|()
decl_stmt|;
if|if
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
comment|// log the nested exception in more detail
name|LOG
operator|.
name|warn
argument_list|(
literal|"{}"
argument_list|,
name|cause
operator|.
name|toString
argument_list|()
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
block|}
name|serviceExitCode
operator|=
name|exitCode
expr_stmt|;
name|serviceException
operator|=
name|exitException
expr_stmt|;
block|}
comment|/**    * Get the usage message, ideally dynamically.    * @return the usage message    */
DECL|method|getUsageMessage ()
specifier|protected
name|String
name|getUsageMessage
parameter_list|()
block|{
name|String
name|message
init|=
name|USAGE_MESSAGE
decl_stmt|;
if|if
condition|(
name|commandOptions
operator|!=
literal|null
condition|)
block|{
name|message
operator|=
name|USAGE_NAME
operator|+
literal|" "
operator|+
name|commandOptions
operator|.
name|toString
argument_list|()
operator|+
literal|" "
operator|+
name|USAGE_SERVICE_ARGUMENTS
expr_stmt|;
block|}
return|return
name|message
return|;
block|}
comment|/**    * Override point: create an options instance to combine with the     * standard options set.    *<i>Important. Synchronize uses of {@link OptionBuilder}</i>    * with {@code OptionBuilder.class}    * @return the new options    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"static-access"
argument_list|)
DECL|method|createOptions ()
specifier|protected
name|Options
name|createOptions
parameter_list|()
block|{
synchronized|synchronized
init|(
name|OptionBuilder
operator|.
name|class
init|)
block|{
name|Options
name|options
init|=
operator|new
name|Options
argument_list|()
decl_stmt|;
name|Option
name|oconf
init|=
name|OptionBuilder
operator|.
name|withArgName
argument_list|(
literal|"configuration file"
argument_list|)
operator|.
name|hasArg
argument_list|()
operator|.
name|withDescription
argument_list|(
literal|"specify an application configuration file"
argument_list|)
operator|.
name|withLongOpt
argument_list|(
name|ARG_CONF
argument_list|)
operator|.
name|create
argument_list|(
name|ARG_CONF_SHORT
argument_list|)
decl_stmt|;
name|Option
name|confclass
init|=
name|OptionBuilder
operator|.
name|withArgName
argument_list|(
literal|"configuration classname"
argument_list|)
operator|.
name|hasArg
argument_list|()
operator|.
name|withDescription
argument_list|(
literal|"Classname of a Hadoop Configuration subclass to load"
argument_list|)
operator|.
name|withLongOpt
argument_list|(
name|ARG_CONFCLASS
argument_list|)
operator|.
name|create
argument_list|(
name|ARG_CONFCLASS_SHORT
argument_list|)
decl_stmt|;
name|Option
name|property
init|=
name|OptionBuilder
operator|.
name|withArgName
argument_list|(
literal|"property=value"
argument_list|)
operator|.
name|hasArg
argument_list|()
operator|.
name|withDescription
argument_list|(
literal|"use value for given property"
argument_list|)
operator|.
name|create
argument_list|(
literal|'D'
argument_list|)
decl_stmt|;
name|options
operator|.
name|addOption
argument_list|(
name|oconf
argument_list|)
expr_stmt|;
name|options
operator|.
name|addOption
argument_list|(
name|property
argument_list|)
expr_stmt|;
name|options
operator|.
name|addOption
argument_list|(
name|confclass
argument_list|)
expr_stmt|;
return|return
name|options
return|;
block|}
block|}
comment|/**    * Override point: create the base configuration for the service.    *    * Subclasses can override to create HDFS/YARN configurations etc.    * @return the configuration to use as the service initializer.    */
DECL|method|createConfiguration ()
specifier|protected
name|Configuration
name|createConfiguration
parameter_list|()
block|{
return|return
operator|new
name|Configuration
argument_list|()
return|;
block|}
comment|/**    * Override point: Get a list of configuration classes to create.    * @return the array of configs to attempt to create. If any are off the    * classpath, that is logged    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"ReturnOfCollectionOrArrayField"
argument_list|)
DECL|method|getConfigurationsToCreate ()
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getConfigurationsToCreate
parameter_list|()
block|{
return|return
name|confClassnames
return|;
block|}
comment|/**    * This creates all the configurations defined by    * {@link #getConfigurationsToCreate()} , ensuring that    * the resources have been pushed in.    * If one cannot be loaded it is logged and the operation continues    * except in the case that the class does load but it isn't actually    * a subclass of {@link Configuration}.    * @throws ExitUtil.ExitException if a loaded class is of the wrong type    */
annotation|@
name|VisibleForTesting
DECL|method|loadConfigurationClasses ()
specifier|public
name|int
name|loadConfigurationClasses
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|toCreate
init|=
name|getConfigurationsToCreate
argument_list|()
decl_stmt|;
name|int
name|loaded
init|=
literal|0
decl_stmt|;
for|for
control|(
name|String
name|classname
range|:
name|toCreate
control|)
block|{
try|try
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|loadClass
init|=
name|getClassLoader
argument_list|()
operator|.
name|loadClass
argument_list|(
name|classname
argument_list|)
decl_stmt|;
name|Object
name|instance
init|=
name|loadClass
operator|.
name|getConstructor
argument_list|()
operator|.
name|newInstance
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|instance
operator|instanceof
name|Configuration
operator|)
condition|)
block|{
throw|throw
operator|new
name|ExitUtil
operator|.
name|ExitException
argument_list|(
name|EXIT_SERVICE_CREATION_FAILURE
argument_list|,
literal|"Could not create "
operator|+
name|classname
operator|+
literal|" because it is not a Configuration class/subclass"
argument_list|)
throw|;
block|}
name|loaded
operator|++
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
comment|// class could not be found -implies it is not on the current classpath
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to load {} because it is not on the classpath"
argument_list|,
name|classname
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExitUtil
operator|.
name|ExitException
name|e
parameter_list|)
block|{
comment|// rethrow
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// any other exception
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to create {}"
argument_list|,
name|classname
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|loaded
return|;
block|}
comment|/**    * Launch a service catching all exceptions and downgrading them to exit codes    * after logging.    *    * Sets {@link #serviceException} to this value.    * @param conf configuration to use    * @param processedArgs command line after the launcher-specific arguments    * have been stripped out.    * @param addShutdownHook should a shutdown hook be added to terminate    * this service on shutdown. Tests should set this to false.    * @param execute execute/wait for the service to stop.    * @return an exit exception, which will have a status code of 0 if it worked    */
DECL|method|launchService (Configuration conf, List<String> processedArgs, boolean addShutdownHook, boolean execute)
specifier|public
name|ExitUtil
operator|.
name|ExitException
name|launchService
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|processedArgs
parameter_list|,
name|boolean
name|addShutdownHook
parameter_list|,
name|boolean
name|execute
parameter_list|)
block|{
return|return
name|launchService
argument_list|(
name|conf
argument_list|,
literal|null
argument_list|,
name|processedArgs
argument_list|,
name|addShutdownHook
argument_list|,
name|execute
argument_list|)
return|;
block|}
comment|/**    * Launch a service catching all exceptions and downgrading them to exit codes    * after logging.    *    * Sets {@link #serviceException} to this value.    * @param conf configuration to use    * @param instance optional instance of the service.    * @param processedArgs command line after the launcher-specific arguments    * have been stripped out.    * @param addShutdownHook should a shutdown hook be added to terminate    * this service on shutdown. Tests should set this to false.    * @param execute execute/wait for the service to stop.    * @return an exit exception, which will have a status code of 0 if it worked    */
DECL|method|launchService (Configuration conf, S instance, List<String> processedArgs, boolean addShutdownHook, boolean execute)
specifier|public
name|ExitUtil
operator|.
name|ExitException
name|launchService
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|S
name|instance
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|processedArgs
parameter_list|,
name|boolean
name|addShutdownHook
parameter_list|,
name|boolean
name|execute
parameter_list|)
block|{
name|ExitUtil
operator|.
name|ExitException
name|exitException
decl_stmt|;
try|try
block|{
name|int
name|exitCode
init|=
name|coreServiceLaunch
argument_list|(
name|conf
argument_list|,
name|instance
argument_list|,
name|processedArgs
argument_list|,
name|addShutdownHook
argument_list|,
name|execute
argument_list|)
decl_stmt|;
if|if
condition|(
name|service
operator|!=
literal|null
condition|)
block|{
comment|// check to see if the service failed
name|Throwable
name|failure
init|=
name|service
operator|.
name|getFailureCause
argument_list|()
decl_stmt|;
if|if
condition|(
name|failure
operator|!=
literal|null
condition|)
block|{
comment|// the service exited with a failure.
comment|// check what state it is in
name|Service
operator|.
name|STATE
name|failureState
init|=
name|service
operator|.
name|getFailureState
argument_list|()
decl_stmt|;
if|if
condition|(
name|failureState
operator|==
name|Service
operator|.
name|STATE
operator|.
name|STOPPED
condition|)
block|{
comment|// the failure occurred during shutdown, not important enough
comment|// to bother the user as it may just scare them
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failure during shutdown: {} "
argument_list|,
name|failure
argument_list|,
name|failure
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//throw it for the catch handlers to deal with
throw|throw
name|failure
throw|;
block|}
block|}
block|}
name|String
name|name
init|=
name|getServiceName
argument_list|()
decl_stmt|;
if|if
condition|(
name|exitCode
operator|==
literal|0
condition|)
block|{
name|exitException
operator|=
operator|new
name|ServiceLaunchException
argument_list|(
name|exitCode
argument_list|,
literal|"%s succeeded"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exitException
operator|=
operator|new
name|ServiceLaunchException
argument_list|(
name|exitCode
argument_list|,
literal|"%s failed "
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|// either the service succeeded, or an error raised during shutdown,
comment|// which we don't worry that much about
block|}
catch|catch
parameter_list|(
name|ExitUtil
operator|.
name|ExitException
name|ee
parameter_list|)
block|{
comment|// exit exceptions are passed through unchanged
name|exitException
operator|=
name|ee
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|thrown
parameter_list|)
block|{
comment|// other errors need a full log.
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception raised {}"
argument_list|,
name|service
operator|!=
literal|null
condition|?
operator|(
name|service
operator|.
name|toString
argument_list|()
operator|+
literal|" in state  "
operator|+
name|service
operator|.
name|getServiceState
argument_list|()
operator|)
else|:
literal|"during service instantiation"
argument_list|,
name|thrown
argument_list|)
expr_stmt|;
name|exitException
operator|=
name|convertToExitException
argument_list|(
name|thrown
argument_list|)
expr_stmt|;
block|}
name|noteException
argument_list|(
name|exitException
argument_list|)
expr_stmt|;
return|return
name|exitException
return|;
block|}
comment|/**    * Launch the service.    *    * All exceptions that occur are propagated upwards.    *    * If the method returns a status code, it means that it got as far starting    * the service, and if it implements {@link LaunchableService}, that the     * method {@link LaunchableService#execute()} has completed.     *    * After this method returns, the service can be retrieved returned by    * {@link #getService()}.    *    * @param conf configuration    * @param instance optional instance of the service.    * @param processedArgs arguments after the configuration parameters    * have been stripped out.    * @param addShutdownHook should a shutdown hook be added to terminate    * this service on shutdown. Tests should set this to false.    * @param execute execute/wait for the service to stop    * @throws ClassNotFoundException classname not on the classpath    * @throws IllegalAccessException not allowed at the class    * @throws InstantiationException not allowed to instantiate it    * @throws InterruptedException thread interrupted    * @throws ExitUtil.ExitException any exception defining the status code.    * @throws Exception any other failure -if it implements    * {@link ExitCodeProvider} then it defines the exit code for any    * containing exception    */
DECL|method|coreServiceLaunch (Configuration conf, S instance, List<String> processedArgs, boolean addShutdownHook, boolean execute)
specifier|protected
name|int
name|coreServiceLaunch
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|S
name|instance
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|processedArgs
parameter_list|,
name|boolean
name|addShutdownHook
parameter_list|,
name|boolean
name|execute
parameter_list|)
throws|throws
name|Exception
block|{
comment|// create the service instance
if|if
condition|(
name|instance
operator|==
literal|null
condition|)
block|{
name|instantiateService
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// service already exists, so instantiate
name|configuration
operator|=
name|conf
expr_stmt|;
name|service
operator|=
name|instance
expr_stmt|;
block|}
name|ServiceShutdownHook
name|shutdownHook
init|=
literal|null
decl_stmt|;
comment|// and the shutdown hook if requested
if|if
condition|(
name|addShutdownHook
condition|)
block|{
name|shutdownHook
operator|=
operator|new
name|ServiceShutdownHook
argument_list|(
name|service
argument_list|)
expr_stmt|;
name|shutdownHook
operator|.
name|register
argument_list|(
name|SHUTDOWN_PRIORITY
argument_list|)
expr_stmt|;
block|}
name|String
name|name
init|=
name|getServiceName
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Launched service {}"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|LaunchableService
name|launchableService
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|service
operator|instanceof
name|LaunchableService
condition|)
block|{
comment|// it's a LaunchableService, pass in the conf and arguments before init)
name|LOG
operator|.
name|debug
argument_list|(
literal|"Service {} implements LaunchableService"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|launchableService
operator|=
operator|(
name|LaunchableService
operator|)
name|service
expr_stmt|;
if|if
condition|(
name|launchableService
operator|.
name|isInState
argument_list|(
name|Service
operator|.
name|STATE
operator|.
name|INITED
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"LaunchableService {}"
operator|+
literal|" initialized in constructor before CLI arguments passed in"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|Configuration
name|newconf
init|=
name|launchableService
operator|.
name|bindArgs
argument_list|(
name|configuration
argument_list|,
name|processedArgs
argument_list|)
decl_stmt|;
if|if
condition|(
name|newconf
operator|!=
literal|null
condition|)
block|{
name|configuration
operator|=
name|newconf
expr_stmt|;
block|}
block|}
comment|//some class constructors init; here this is picked up on.
if|if
condition|(
operator|!
name|service
operator|.
name|isInState
argument_list|(
name|Service
operator|.
name|STATE
operator|.
name|INITED
argument_list|)
condition|)
block|{
name|service
operator|.
name|init
argument_list|(
name|configuration
argument_list|)
expr_stmt|;
block|}
name|int
name|exitCode
decl_stmt|;
try|try
block|{
comment|// start the service
name|service
operator|.
name|start
argument_list|()
expr_stmt|;
name|exitCode
operator|=
name|EXIT_SUCCESS
expr_stmt|;
if|if
condition|(
name|execute
operator|&&
name|service
operator|.
name|isInState
argument_list|(
name|Service
operator|.
name|STATE
operator|.
name|STARTED
argument_list|)
condition|)
block|{
if|if
condition|(
name|launchableService
operator|!=
literal|null
condition|)
block|{
comment|// assume that runnable services are meant to run from here
try|try
block|{
name|exitCode
operator|=
name|launchableService
operator|.
name|execute
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Service {} execution returned exit code {}"
argument_list|,
name|name
argument_list|,
name|exitCode
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// then stop the service
name|service
operator|.
name|stop
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//run the service until it stops or an interrupt happens
comment|// on a different thread.
name|LOG
operator|.
name|debug
argument_list|(
literal|"waiting for service threads to terminate"
argument_list|)
expr_stmt|;
name|service
operator|.
name|waitForServiceToStop
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|shutdownHook
operator|!=
literal|null
condition|)
block|{
name|shutdownHook
operator|.
name|unregister
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|exitCode
return|;
block|}
comment|/**    * Instantiate the service defined in {@code serviceClassName}.    *    * Sets the {@code configuration} field    * to the the value of {@code conf},    * and the {@code service} field to the service created.    *    * @param conf configuration to use    */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|instantiateService (Configuration conf)
specifier|public
name|Service
name|instantiateService
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|conf
operator|!=
literal|null
argument_list|,
literal|"null conf"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|serviceClassName
operator|!=
literal|null
argument_list|,
literal|"null service classname"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
operator|!
name|serviceClassName
operator|.
name|isEmpty
argument_list|()
argument_list|,
literal|"undefined service classname"
argument_list|)
expr_stmt|;
name|configuration
operator|=
name|conf
expr_stmt|;
comment|// Instantiate the class. this requires the service to have a public
comment|// zero-argument or string-argument constructor
name|Object
name|instance
decl_stmt|;
try|try
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|serviceClass
init|=
name|getClassLoader
argument_list|()
operator|.
name|loadClass
argument_list|(
name|serviceClassName
argument_list|)
decl_stmt|;
try|try
block|{
name|instance
operator|=
name|serviceClass
operator|.
name|getConstructor
argument_list|()
operator|.
name|newInstance
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|noEmptyConstructor
parameter_list|)
block|{
comment|// no simple constructor, fall back to a string
name|LOG
operator|.
name|debug
argument_list|(
literal|"No empty constructor {}"
argument_list|,
name|noEmptyConstructor
argument_list|,
name|noEmptyConstructor
argument_list|)
expr_stmt|;
name|instance
operator|=
name|serviceClass
operator|.
name|getConstructor
argument_list|(
name|String
operator|.
name|class
argument_list|)
operator|.
name|newInstance
argument_list|(
name|serviceClassName
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|serviceCreationFailure
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
operator|(
name|instance
operator|instanceof
name|Service
operator|)
condition|)
block|{
comment|//not a service
throw|throw
operator|new
name|ServiceLaunchException
argument_list|(
name|LauncherExitCodes
operator|.
name|EXIT_SERVICE_CREATION_FAILURE
argument_list|,
literal|"Not a service class: \"%s\""
argument_list|,
name|serviceClassName
argument_list|)
throw|;
block|}
comment|// cast to the specific instance type of this ServiceLauncher
name|service
operator|=
operator|(
name|S
operator|)
name|instance
expr_stmt|;
return|return
name|service
return|;
block|}
comment|/**    * Convert an exception to an {@code ExitException}.    *    * This process may just be a simple pass through, otherwise a new    * exception is created with an exit code, the text of the supplied    * exception, and the supplied exception as an inner cause.    *     *<ol>    *<li>If is already the right type, pass it through.</li>    *<li>If it implements {@link ExitCodeProvider#getExitCode()},    *   the exit code is extracted and used in the new exception.</li>    *<li>Otherwise, the exit code    *   {@link LauncherExitCodes#EXIT_EXCEPTION_THROWN} is used.</li>    *</ol>    *      * @param thrown the exception thrown    * @return an {@code ExitException} with a status code    */
DECL|method|convertToExitException ( Throwable thrown)
specifier|protected
specifier|static
name|ExitUtil
operator|.
name|ExitException
name|convertToExitException
parameter_list|(
name|Throwable
name|thrown
parameter_list|)
block|{
name|ExitUtil
operator|.
name|ExitException
name|exitException
decl_stmt|;
comment|// get the exception message
name|String
name|message
init|=
name|thrown
operator|.
name|toString
argument_list|()
decl_stmt|;
name|int
name|exitCode
decl_stmt|;
if|if
condition|(
name|thrown
operator|instanceof
name|ExitCodeProvider
condition|)
block|{
comment|// the exception provides a status code -extract it
name|exitCode
operator|=
operator|(
operator|(
name|ExitCodeProvider
operator|)
name|thrown
operator|)
operator|.
name|getExitCode
argument_list|()
expr_stmt|;
name|message
operator|=
name|thrown
operator|.
name|getMessage
argument_list|()
expr_stmt|;
if|if
condition|(
name|message
operator|==
literal|null
condition|)
block|{
comment|// some exceptions do not have a message; fall back
comment|// to the string value.
name|message
operator|=
name|thrown
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// no exception code: use the default
name|exitCode
operator|=
name|EXIT_EXCEPTION_THROWN
expr_stmt|;
block|}
comment|// construct the new exception with the original message and
comment|// an exit code
name|exitException
operator|=
operator|new
name|ServiceLaunchException
argument_list|(
name|exitCode
argument_list|,
name|thrown
argument_list|,
name|message
argument_list|)
expr_stmt|;
return|return
name|exitException
return|;
block|}
comment|/**    * Generate an exception announcing a failure to create the service.    * @param exception inner exception.    * @return a new exception, with the exit code    * {@link LauncherExitCodes#EXIT_SERVICE_CREATION_FAILURE}    */
DECL|method|serviceCreationFailure (Exception exception)
specifier|protected
name|ServiceLaunchException
name|serviceCreationFailure
parameter_list|(
name|Exception
name|exception
parameter_list|)
block|{
return|return
operator|new
name|ServiceLaunchException
argument_list|(
name|EXIT_SERVICE_CREATION_FAILURE
argument_list|,
name|exception
argument_list|)
return|;
block|}
comment|/**    * Override point: register this class as the handler for the control-C    * and SIGINT interrupts.    *    * Subclasses can extend this with extra operations, such as    * an exception handler:    *<pre>    *  Thread.setDefaultUncaughtExceptionHandler(    *     new YarnUncaughtExceptionHandler());    *</pre>    */
DECL|method|registerFailureHandling ()
specifier|protected
name|void
name|registerFailureHandling
parameter_list|()
block|{
try|try
block|{
name|interruptEscalator
operator|=
operator|new
name|InterruptEscalator
argument_list|(
name|this
argument_list|,
name|SHUTDOWN_TIME_ON_INTERRUPT
argument_list|)
expr_stmt|;
name|interruptEscalator
operator|.
name|register
argument_list|(
name|IrqHandler
operator|.
name|CONTROL_C
argument_list|)
expr_stmt|;
name|interruptEscalator
operator|.
name|register
argument_list|(
name|IrqHandler
operator|.
name|SIGTERM
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
comment|// downgrade interrupt registration to warnings
name|LOG
operator|.
name|warn
argument_list|(
literal|"{}"
argument_list|,
name|e
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|Thread
operator|.
name|setDefaultUncaughtExceptionHandler
argument_list|(
operator|new
name|HadoopUncaughtExceptionHandler
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Handler for uncaught exceptions: terminate the service.    * @param thread thread    * @param exception exception    */
annotation|@
name|Override
DECL|method|uncaughtException (Thread thread, Throwable exception)
specifier|public
name|void
name|uncaughtException
parameter_list|(
name|Thread
name|thread
parameter_list|,
name|Throwable
name|exception
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Uncaught exception in thread {} -exiting"
argument_list|,
name|thread
argument_list|,
name|exception
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|convertToExitException
argument_list|(
name|exception
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the service name via {@link Service#getName()}.    *    * If the service is not instantiated, the classname is returned instead.    * @return the service name    */
DECL|method|getServiceName ()
specifier|public
name|String
name|getServiceName
parameter_list|()
block|{
name|Service
name|s
init|=
name|service
decl_stmt|;
name|String
name|name
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|name
operator|=
name|s
operator|.
name|getName
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignored
parameter_list|)
block|{
comment|// ignored
block|}
block|}
if|if
condition|(
name|name
operator|!=
literal|null
condition|)
block|{
return|return
literal|"service "
operator|+
name|name
return|;
block|}
else|else
block|{
return|return
literal|"service "
operator|+
name|serviceName
return|;
block|}
block|}
comment|/**    * Print a warning message.    *<p>    * This tries to log to the log's warn() operation.    * If the log at that level is disabled it logs to system error    * @param text warning text    */
DECL|method|warn (String text)
specifier|protected
name|void
name|warn
parameter_list|(
name|String
name|text
parameter_list|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isWarnEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Report an error.     *<p>    * This tries to log to {@code LOG.error()}.    *<p>    * If that log level is disabled disabled the message    * is logged to system error along with {@code thrown.toString()}    * @param message message for the user    * @param thrown the exception thrown    */
DECL|method|error (String message, Throwable thrown)
specifier|protected
name|void
name|error
parameter_list|(
name|String
name|message
parameter_list|,
name|Throwable
name|thrown
parameter_list|)
block|{
name|String
name|text
init|=
literal|"Exception: "
operator|+
name|message
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isErrorEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|text
argument_list|,
name|thrown
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|thrown
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|thrown
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Exit the JVM.    *    * This is method can be overridden for testing, throwing an     * exception instead. Any subclassed method MUST raise an     * {@code ExitException} instance/subclass.    * The service launcher code assumes that after this method is invoked,    * no other code in the same method is called.    * @param exitCode code to exit    */
DECL|method|exit (int exitCode, String message)
specifier|protected
name|void
name|exit
parameter_list|(
name|int
name|exitCode
parameter_list|,
name|String
name|message
parameter_list|)
block|{
name|ExitUtil
operator|.
name|terminate
argument_list|(
name|exitCode
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
comment|/**    * Exit the JVM using an exception for the exit code and message,    * invoking {@link ExitUtil#terminate(ExitUtil.ExitException)}.    *    * This is the standard way a launched service exits.    * An error code of 0 means success -nothing is printed.    *    * If {@link ExitUtil#disableSystemExit()} has been called, this    * method will throw the exception.    *    * The method<i>may</i> be subclassed for testing    * @param ee exit exception    * @throws ExitUtil.ExitException if ExitUtil exceptions are disabled    */
DECL|method|exit (ExitUtil.ExitException ee)
specifier|protected
name|void
name|exit
parameter_list|(
name|ExitUtil
operator|.
name|ExitException
name|ee
parameter_list|)
block|{
name|ExitUtil
operator|.
name|terminate
argument_list|(
name|ee
argument_list|)
expr_stmt|;
block|}
comment|/**    * Override point: get the classloader to use.    * @return the classloader for loading a service class.    */
DECL|method|getClassLoader ()
specifier|protected
name|ClassLoader
name|getClassLoader
parameter_list|()
block|{
return|return
name|this
operator|.
name|getClass
argument_list|()
operator|.
name|getClassLoader
argument_list|()
return|;
block|}
comment|/**    * Extract the command options and apply them to the configuration,    * building an array of processed arguments to hand down to the service.    *    * @param conf configuration to update.    * @param args main arguments. {@code args[0]}is assumed to be    * the service classname and is skipped.    * @return the remaining arguments    * @throws ExitUtil.ExitException if JVM exiting is disabled.    */
DECL|method|extractCommandOptions (Configuration conf, List<String> args)
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|extractCommandOptions
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|args
parameter_list|)
block|{
name|int
name|size
init|=
name|args
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|size
operator|<=
literal|1
condition|)
block|{
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|0
argument_list|)
return|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|coreArgs
init|=
name|args
operator|.
name|subList
argument_list|(
literal|1
argument_list|,
name|size
argument_list|)
decl_stmt|;
return|return
name|parseCommandArgs
argument_list|(
name|conf
argument_list|,
name|coreArgs
argument_list|)
return|;
block|}
comment|/**    * Parse the command arguments, extracting the service class as the last    * element of the list (after extracting all the rest).    *    * The field {@link #commandOptions} field must already have been set.    * @param conf configuration to use    * @param args command line argument list    * @return the remaining arguments    * @throws ServiceLaunchException if processing of arguments failed    */
DECL|method|parseCommandArgs (Configuration conf, List<String> args)
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|parseCommandArgs
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|args
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|commandOptions
argument_list|,
literal|"Command options have not been created"
argument_list|)
expr_stmt|;
name|StringBuilder
name|argString
init|=
operator|new
name|StringBuilder
argument_list|(
name|args
operator|.
name|size
argument_list|()
operator|*
literal|32
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|arg
range|:
name|args
control|)
block|{
name|argString
operator|.
name|append
argument_list|(
literal|"\""
argument_list|)
operator|.
name|append
argument_list|(
name|arg
argument_list|)
operator|.
name|append
argument_list|(
literal|"\" "
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Command line: {}"
argument_list|,
name|argString
argument_list|)
expr_stmt|;
try|try
block|{
name|String
index|[]
name|argArray
init|=
name|args
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|args
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
comment|// parse this the standard way. This will
comment|// update the configuration in the parser, and potentially
comment|// patch the user credentials
name|GenericOptionsParser
name|parser
init|=
name|createGenericOptionsParser
argument_list|(
name|conf
argument_list|,
name|argArray
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|parser
operator|.
name|isParseSuccessful
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ServiceLaunchException
argument_list|(
name|EXIT_COMMAND_ARGUMENT_ERROR
argument_list|,
name|E_PARSE_FAILED
operator|+
literal|" %s"
argument_list|,
name|argString
argument_list|)
throw|;
block|}
name|CommandLine
name|line
init|=
name|parser
operator|.
name|getCommandLine
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|remainingArgs
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|parser
operator|.
name|getRemainingArgs
argument_list|()
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Remaining arguments {}"
argument_list|,
name|remainingArgs
argument_list|)
expr_stmt|;
comment|// Scan the list of configuration files
comment|// and bail out if they don't exist
if|if
condition|(
name|line
operator|.
name|hasOption
argument_list|(
name|ARG_CONF
argument_list|)
condition|)
block|{
name|String
index|[]
name|filenames
init|=
name|line
operator|.
name|getOptionValues
argument_list|(
name|ARG_CONF
argument_list|)
decl_stmt|;
name|verifyConfigurationFilesExist
argument_list|(
name|filenames
argument_list|)
expr_stmt|;
comment|// Add URLs of files as list of URLs to load
for|for
control|(
name|String
name|filename
range|:
name|filenames
control|)
block|{
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Configuration files {}"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|confResourceUrls
operator|.
name|add
argument_list|(
name|file
operator|.
name|toURI
argument_list|()
operator|.
name|toURL
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|line
operator|.
name|hasOption
argument_list|(
name|ARG_CONFCLASS
argument_list|)
condition|)
block|{
comment|// new resources to instantiate as configurations
name|List
argument_list|<
name|String
argument_list|>
name|classnameList
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|line
operator|.
name|getOptionValues
argument_list|(
name|ARG_CONFCLASS
argument_list|)
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Configuration classes {}"
argument_list|,
name|classnameList
argument_list|)
expr_stmt|;
name|confClassnames
operator|.
name|addAll
argument_list|(
name|classnameList
argument_list|)
expr_stmt|;
block|}
comment|// return the remainder
return|return
name|remainingArgs
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// parsing problem: convert to a command argument error with
comment|// the original text
throw|throw
operator|new
name|ServiceLaunchException
argument_list|(
name|EXIT_COMMAND_ARGUMENT_ERROR
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|e
parameter_list|)
block|{
comment|// lower level issue such as XML parse failure
throw|throw
operator|new
name|ServiceLaunchException
argument_list|(
name|EXIT_COMMAND_ARGUMENT_ERROR
argument_list|,
name|e
argument_list|,
name|E_PARSE_FAILED
operator|+
literal|" %s : %s"
argument_list|,
name|argString
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Override point: create a generic options parser or subclass thereof.    * @param conf Hadoop configuration    * @param argArray array of arguments    * @return a generic options parser to parse the arguments    * @throws IOException on any failure    */
DECL|method|createGenericOptionsParser (Configuration conf, String[] argArray)
specifier|protected
name|GenericOptionsParser
name|createGenericOptionsParser
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
index|[]
name|argArray
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|MinimalGenericOptionsParser
argument_list|(
name|conf
argument_list|,
name|commandOptions
argument_list|,
name|argArray
argument_list|)
return|;
block|}
comment|/**    * Verify that all the specified filenames exist.    * @param filenames a list of files    * @throws ServiceLaunchException if a file is not found    */
DECL|method|verifyConfigurationFilesExist (String[] filenames)
specifier|protected
name|void
name|verifyConfigurationFilesExist
parameter_list|(
name|String
index|[]
name|filenames
parameter_list|)
block|{
if|if
condition|(
name|filenames
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|String
name|filename
range|:
name|filenames
control|)
block|{
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Conf file {}"
argument_list|,
name|file
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
comment|// no configuration file
throw|throw
operator|new
name|ServiceLaunchException
argument_list|(
name|EXIT_NOT_FOUND
argument_list|,
name|ARG_CONF_PREFIXED
operator|+
literal|": configuration file not found: %s"
argument_list|,
name|file
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**    * Build a log message for starting up and shutting down.     * @param classname the class of the server    * @param args arguments    */
DECL|method|startupShutdownMessage (String classname, List<String> args)
specifier|protected
specifier|static
name|String
name|startupShutdownMessage
parameter_list|(
name|String
name|classname
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|args
parameter_list|)
block|{
specifier|final
name|String
name|hostname
init|=
name|NetUtils
operator|.
name|getHostname
argument_list|()
decl_stmt|;
return|return
name|StringUtils
operator|.
name|createStartupShutdownMessage
argument_list|(
name|classname
argument_list|,
name|hostname
argument_list|,
name|args
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|args
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Exit with a printed message.     * @param status status code    * @param message message message to print before exiting    * @throws ExitUtil.ExitException if exceptions are disabled    */
DECL|method|exitWithMessage (int status, String message)
specifier|protected
specifier|static
name|void
name|exitWithMessage
parameter_list|(
name|int
name|status
parameter_list|,
name|String
name|message
parameter_list|)
block|{
name|ExitUtil
operator|.
name|terminate
argument_list|(
operator|new
name|ServiceLaunchException
argument_list|(
name|status
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Exit with the usage exit code {@link #EXIT_USAGE}    * and message {@link #USAGE_MESSAGE}.    * @throws ExitUtil.ExitException if exceptions are disabled    */
DECL|method|exitWithUsageMessage ()
specifier|protected
specifier|static
name|void
name|exitWithUsageMessage
parameter_list|()
block|{
name|exitWithMessage
argument_list|(
name|EXIT_USAGE
argument_list|,
name|USAGE_MESSAGE
argument_list|)
expr_stmt|;
block|}
comment|/**    * This is the JVM entry point for the service launcher.    *    * Converts the arguments to a list, then invokes {@link #serviceMain(List)}    * @param args command line arguments.    */
DECL|method|main (String[] args)
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
block|{
name|serviceMain
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Varargs version of the entry point for testing and other in-JVM use.    * Hands off to {@link #serviceMain(List)}    * @param args command line arguments.    */
DECL|method|serviceMain (String... args)
specifier|public
specifier|static
name|void
name|serviceMain
parameter_list|(
name|String
modifier|...
name|args
parameter_list|)
block|{
name|serviceMain
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ====================================================================== */
comment|/**    * The real main function, which takes the arguments as a list.    * Argument 0 MUST be the service classname    * @param argsList the list of arguments    */
comment|/* ====================================================================== */
DECL|method|serviceMain (List<String> argsList)
specifier|public
specifier|static
name|void
name|serviceMain
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|argsList
parameter_list|)
block|{
if|if
condition|(
name|argsList
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// no arguments: usage message
name|exitWithUsageMessage
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ServiceLauncher
argument_list|<
name|Service
argument_list|>
name|serviceLauncher
init|=
operator|new
name|ServiceLauncher
argument_list|<>
argument_list|(
name|argsList
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|serviceLauncher
operator|.
name|launchServiceAndExit
argument_list|(
name|argsList
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * A generic options parser which does not parse any of the traditional    * Hadoop options.    */
DECL|class|MinimalGenericOptionsParser
specifier|protected
specifier|static
class|class
name|MinimalGenericOptionsParser
extends|extends
name|GenericOptionsParser
block|{
DECL|method|MinimalGenericOptionsParser (Configuration conf, Options options, String[] args)
specifier|public
name|MinimalGenericOptionsParser
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|Options
name|options
parameter_list|,
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|conf
argument_list|,
name|options
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|buildGeneralOptions (Options opts)
specifier|protected
name|Options
name|buildGeneralOptions
parameter_list|(
name|Options
name|opts
parameter_list|)
block|{
return|return
name|opts
return|;
block|}
block|}
block|}
end_class

end_unit

