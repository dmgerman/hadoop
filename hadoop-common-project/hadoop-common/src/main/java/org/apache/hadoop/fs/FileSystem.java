begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|WeakReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|ReferenceQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URISyntaxException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ServiceConfigurationError
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ServiceLoader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configured
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|GlobalStorageStatistics
operator|.
name|StorageStatisticsProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
operator|.
name|ChecksumOpt
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
operator|.
name|Rename
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|AclStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsCreateModes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|MultipleIOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|Credentials
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SecurityUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ClassUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|DataChecksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Progressable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ReflectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ShutdownHookManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|core
operator|.
name|Tracer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|core
operator|.
name|TraceScope
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
operator|.
name|checkArgument
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|*
import|;
end_import

begin_comment
comment|/****************************************************************  * An abstract base class for a fairly generic filesystem.  It  * may be implemented as a distributed filesystem, or as a "local"  * one that reflects the locally-connected disk.  The local version  * exists for small Hadoop instances and for testing.  *  *<p>  *  * All user code that may potentially use the Hadoop Distributed  * File System should be written to use a FileSystem object or its  * successor, {@link FileContext}.  *  *<p>  * The local implementation is {@link LocalFileSystem} and distributed  * implementation is DistributedFileSystem. There are other implementations  * for object stores and (outside the Apache Hadoop codebase),  * third party filesystems.  *<p>  * Notes  *<ol>  *<li>The behaviour of the filesystem is  *<a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/filesystem/filesystem.html">  * specified in the Hadoop documentation.</a>  * However, the normative specification of the behavior of this class is  * actually HDFS: if HDFS does not behave the way these Javadocs or  * the specification in the Hadoop documentations define, assume that  * the documentation is incorrect.  *</li>  *<li>The term {@code FileSystem} refers to an instance of this class.</li>  *<li>The acronym "FS" is used as an abbreviation of FileSystem.</li>  *<li>The term {@code filesystem} refers to the distributed/local filesystem  * itself, rather than the class used to interact with it.</li>  *<li>The term "file" refers to a file in the remote filesystem,  * rather than instances of {@code java.io.File}.</li>  *</ol>  *****************************************************************/
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"DeprecatedIsStillUsed"
argument_list|)
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Stable
DECL|class|FileSystem
specifier|public
specifier|abstract
class|class
name|FileSystem
extends|extends
name|Configured
implements|implements
name|Closeable
block|{
DECL|field|FS_DEFAULT_NAME_KEY
specifier|public
specifier|static
specifier|final
name|String
name|FS_DEFAULT_NAME_KEY
init|=
name|CommonConfigurationKeys
operator|.
name|FS_DEFAULT_NAME_KEY
decl_stmt|;
DECL|field|DEFAULT_FS
specifier|public
specifier|static
specifier|final
name|String
name|DEFAULT_FS
init|=
name|CommonConfigurationKeys
operator|.
name|FS_DEFAULT_NAME_DEFAULT
decl_stmt|;
comment|/**    * This log is widely used in the org.apache.hadoop.fs code and tests,    * so must be considered something to only be changed with care.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FileSystem
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * The SLF4J logger to use in logging within the FileSystem class itself.    */
DECL|field|LOGGER
specifier|private
specifier|static
specifier|final
name|Logger
name|LOGGER
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|FileSystem
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Priority of the FileSystem shutdown hook: {@value}.    */
DECL|field|SHUTDOWN_HOOK_PRIORITY
specifier|public
specifier|static
specifier|final
name|int
name|SHUTDOWN_HOOK_PRIORITY
init|=
literal|10
decl_stmt|;
comment|/**    * Prefix for trash directory: {@value}.    */
DECL|field|TRASH_PREFIX
specifier|public
specifier|static
specifier|final
name|String
name|TRASH_PREFIX
init|=
literal|".Trash"
decl_stmt|;
DECL|field|USER_HOME_PREFIX
specifier|public
specifier|static
specifier|final
name|String
name|USER_HOME_PREFIX
init|=
literal|"/user"
decl_stmt|;
comment|/** FileSystem cache. */
DECL|field|CACHE
specifier|static
specifier|final
name|Cache
name|CACHE
init|=
operator|new
name|Cache
argument_list|()
decl_stmt|;
comment|/** The key this instance is stored under in the cache. */
DECL|field|key
specifier|private
name|Cache
operator|.
name|Key
name|key
decl_stmt|;
comment|/** Recording statistics per a FileSystem class. */
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|FileSystem
argument_list|>
argument_list|,
name|Statistics
argument_list|>
DECL|field|statisticsTable
name|statisticsTable
init|=
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * The statistics for this file system.    */
DECL|field|statistics
specifier|protected
name|Statistics
name|statistics
decl_stmt|;
comment|/**    * A cache of files that should be deleted when the FileSystem is closed    * or the JVM is exited.    */
DECL|field|deleteOnExit
specifier|private
specifier|final
name|Set
argument_list|<
name|Path
argument_list|>
name|deleteOnExit
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Should symbolic links be resolved by {@link FileSystemLinkResolver}.    * Set to the value of    * {@link CommonConfigurationKeysPublic#FS_CLIENT_RESOLVE_REMOTE_SYMLINKS_KEY}    */
DECL|field|resolveSymlinks
name|boolean
name|resolveSymlinks
decl_stmt|;
comment|/**    * This method adds a FileSystem instance to the cache so that it can    * be retrieved later. It is only for testing.    * @param uri the uri to store it under    * @param conf the configuration to store it under    * @param fs the FileSystem to store    * @throws IOException if the current user cannot be determined.    */
annotation|@
name|VisibleForTesting
DECL|method|addFileSystemForTesting (URI uri, Configuration conf, FileSystem fs)
specifier|static
name|void
name|addFileSystemForTesting
parameter_list|(
name|URI
name|uri
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|FileSystem
name|fs
parameter_list|)
throws|throws
name|IOException
block|{
name|CACHE
operator|.
name|map
operator|.
name|put
argument_list|(
operator|new
name|Cache
operator|.
name|Key
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
argument_list|,
name|fs
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get a FileSystem instance based on the uri, the passed in    * configuration and the user.    * @param uri of the filesystem    * @param conf the configuration to use    * @param user to perform the get as    * @return the filesystem instance    * @throws IOException failure to load    * @throws InterruptedException If the {@code UGI.doAs()} call was    * somehow interrupted.    */
DECL|method|get (final URI uri, final Configuration conf, final String user)
specifier|public
specifier|static
name|FileSystem
name|get
parameter_list|(
specifier|final
name|URI
name|uri
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|String
name|user
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|String
name|ticketCachePath
init|=
name|conf
operator|.
name|get
argument_list|(
name|CommonConfigurationKeys
operator|.
name|KERBEROS_TICKET_CACHE_PATH
argument_list|)
decl_stmt|;
name|UserGroupInformation
name|ugi
init|=
name|UserGroupInformation
operator|.
name|getBestUGI
argument_list|(
name|ticketCachePath
argument_list|,
name|user
argument_list|)
decl_stmt|;
return|return
name|ugi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|FileSystem
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileSystem
name|run
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|get
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Returns the configured FileSystem implementation.    * @param conf the configuration to use    */
DECL|method|get (Configuration conf)
specifier|public
specifier|static
name|FileSystem
name|get
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|get
argument_list|(
name|getDefaultUri
argument_list|(
name|conf
argument_list|)
argument_list|,
name|conf
argument_list|)
return|;
block|}
comment|/**    * Get the default FileSystem URI from a configuration.    * @param conf the configuration to use    * @return the uri of the default filesystem    */
DECL|method|getDefaultUri (Configuration conf)
specifier|public
specifier|static
name|URI
name|getDefaultUri
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|URI
name|uri
init|=
name|URI
operator|.
name|create
argument_list|(
name|fixName
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|FS_DEFAULT_NAME_KEY
argument_list|,
name|DEFAULT_FS
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|uri
operator|.
name|getScheme
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No scheme in default FS: "
operator|+
name|uri
argument_list|)
throw|;
block|}
return|return
name|uri
return|;
block|}
comment|/**    * Set the default FileSystem URI in a configuration.    * @param conf the configuration to alter    * @param uri the new default filesystem uri    */
DECL|method|setDefaultUri (Configuration conf, URI uri)
specifier|public
specifier|static
name|void
name|setDefaultUri
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|URI
name|uri
parameter_list|)
block|{
name|conf
operator|.
name|set
argument_list|(
name|FS_DEFAULT_NAME_KEY
argument_list|,
name|uri
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Set the default FileSystem URI in a configuration.    * @param conf the configuration to alter    * @param uri the new default filesystem uri    */
DECL|method|setDefaultUri (Configuration conf, String uri)
specifier|public
specifier|static
name|void
name|setDefaultUri
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|uri
parameter_list|)
block|{
name|setDefaultUri
argument_list|(
name|conf
argument_list|,
name|URI
operator|.
name|create
argument_list|(
name|fixName
argument_list|(
name|uri
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Initialize a FileSystem.    *    * Called after the new FileSystem instance is constructed, and before it    * is ready for use.    *    * FileSystem implementations overriding this method MUST forward it to    * their superclass, though the order in which it is done, and whether    * to alter the configuration before the invocation are options of the    * subclass.    * @param name a URI whose authority section names the host, port, etc.    *   for this FileSystem    * @param conf the configuration    * @throws IOException on any failure to initialize this instance.    * @throws IllegalArgumentException if the URI is considered invalid.    */
DECL|method|initialize (URI name, Configuration conf)
specifier|public
name|void
name|initialize
parameter_list|(
name|URI
name|name
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|scheme
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|getScheme
argument_list|()
operator|==
literal|null
operator|||
name|name
operator|.
name|getScheme
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|scheme
operator|=
name|getDefaultUri
argument_list|(
name|conf
argument_list|)
operator|.
name|getScheme
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|scheme
operator|=
name|name
operator|.
name|getScheme
argument_list|()
expr_stmt|;
block|}
name|statistics
operator|=
name|getStatistics
argument_list|(
name|scheme
argument_list|,
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
name|resolveSymlinks
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|FS_CLIENT_RESOLVE_REMOTE_SYMLINKS_KEY
argument_list|,
name|CommonConfigurationKeysPublic
operator|.
name|FS_CLIENT_RESOLVE_REMOTE_SYMLINKS_DEFAULT
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return the protocol scheme for this FileSystem.    *<p>    * This implementation throws an<code>UnsupportedOperationException</code>.    *    * @return the protocol scheme for this FileSystem.    * @throws UnsupportedOperationException if the operation is unsupported    *         (default).    */
DECL|method|getScheme ()
specifier|public
name|String
name|getScheme
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Not implemented by the "
operator|+
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" FileSystem implementation"
argument_list|)
throw|;
block|}
comment|/**    * Returns a URI which identifies this FileSystem.    *    * @return the URI of this filesystem.    */
DECL|method|getUri ()
specifier|public
specifier|abstract
name|URI
name|getUri
parameter_list|()
function_decl|;
comment|/**    * Return a canonicalized form of this FileSystem's URI.    *    * The default implementation simply calls {@link #canonicalizeUri(URI)}    * on the filesystem's own URI, so subclasses typically only need to    * implement that method.    *    * @see #canonicalizeUri(URI)    */
DECL|method|getCanonicalUri ()
specifier|protected
name|URI
name|getCanonicalUri
parameter_list|()
block|{
return|return
name|canonicalizeUri
argument_list|(
name|getUri
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Canonicalize the given URI.    *    * This is implementation-dependent, and may for example consist of    * canonicalizing the hostname using DNS and adding the default    * port if not specified.    *    * The default implementation simply fills in the default port if    * not specified and if {@link #getDefaultPort()} returns a    * default port.    *    * @return URI    * @see NetUtils#getCanonicalUri(URI, int)    */
DECL|method|canonicalizeUri (URI uri)
specifier|protected
name|URI
name|canonicalizeUri
parameter_list|(
name|URI
name|uri
parameter_list|)
block|{
if|if
condition|(
name|uri
operator|.
name|getPort
argument_list|()
operator|==
operator|-
literal|1
operator|&&
name|getDefaultPort
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// reconstruct the uri with the default port set
try|try
block|{
name|uri
operator|=
operator|new
name|URI
argument_list|(
name|uri
operator|.
name|getScheme
argument_list|()
argument_list|,
name|uri
operator|.
name|getUserInfo
argument_list|()
argument_list|,
name|uri
operator|.
name|getHost
argument_list|()
argument_list|,
name|getDefaultPort
argument_list|()
argument_list|,
name|uri
operator|.
name|getPath
argument_list|()
argument_list|,
name|uri
operator|.
name|getQuery
argument_list|()
argument_list|,
name|uri
operator|.
name|getFragment
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|URISyntaxException
name|e
parameter_list|)
block|{
comment|// Should never happen!
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Valid URI became unparseable: "
operator|+
name|uri
argument_list|)
throw|;
block|}
block|}
return|return
name|uri
return|;
block|}
comment|/**    * Get the default port for this FileSystem.    * @return the default port or 0 if there isn't one    */
DECL|method|getDefaultPort ()
specifier|protected
name|int
name|getDefaultPort
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
DECL|method|getFSofPath (final Path absOrFqPath, final Configuration conf)
specifier|protected
specifier|static
name|FileSystem
name|getFSofPath
parameter_list|(
specifier|final
name|Path
name|absOrFqPath
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
name|absOrFqPath
operator|.
name|checkNotSchemeWithRelative
argument_list|()
expr_stmt|;
name|absOrFqPath
operator|.
name|checkNotRelative
argument_list|()
expr_stmt|;
comment|// Uses the default FileSystem if not fully qualified
return|return
name|get
argument_list|(
name|absOrFqPath
operator|.
name|toUri
argument_list|()
argument_list|,
name|conf
argument_list|)
return|;
block|}
comment|/**    * Get a canonical service name for this FileSystem.    * The token cache is the only user of the canonical service name,    * and uses it to lookup this FileSystem's service tokens.    * If the file system provides a token of its own then it must have a    * canonical name, otherwise the canonical name can be null.    *    * Default implementation: If the FileSystem has child file systems    * (such as an embedded file system) then it is assumed that the FS has no    * tokens of its own and hence returns a null name; otherwise a service    * name is built using Uri and port.    *    * @return a service string that uniquely identifies this file system, null    *         if the filesystem does not implement tokens    * @see SecurityUtil#buildDTServiceName(URI, int)    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|getCanonicalServiceName ()
specifier|public
name|String
name|getCanonicalServiceName
parameter_list|()
block|{
return|return
operator|(
name|getChildFileSystems
argument_list|()
operator|==
literal|null
operator|)
condition|?
name|SecurityUtil
operator|.
name|buildDTServiceName
argument_list|(
name|getUri
argument_list|()
argument_list|,
name|getDefaultPort
argument_list|()
argument_list|)
else|:
literal|null
return|;
block|}
comment|/** @deprecated call {@link #getUri()} instead.*/
annotation|@
name|Deprecated
DECL|method|getName ()
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|getUri
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/** @deprecated call {@link #get(URI, Configuration)} instead. */
annotation|@
name|Deprecated
DECL|method|getNamed (String name, Configuration conf)
specifier|public
specifier|static
name|FileSystem
name|getNamed
parameter_list|(
name|String
name|name
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|get
argument_list|(
name|URI
operator|.
name|create
argument_list|(
name|fixName
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|,
name|conf
argument_list|)
return|;
block|}
comment|/** Update old-format filesystem names, for back-compatibility.  This should    * eventually be replaced with a checkName() method that throws an exception    * for old-format names.    */
DECL|method|fixName (String name)
specifier|private
specifier|static
name|String
name|fixName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
comment|// convert old-format name to new-format name
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"local"
argument_list|)
condition|)
block|{
comment|// "local" is now "file:///".
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"\"local\" is a deprecated filesystem name."
operator|+
literal|" Use \"file:///\" instead."
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"file:///"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|indexOf
argument_list|(
literal|'/'
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|// unqualified is "hdfs://"
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"\""
operator|+
name|name
operator|+
literal|"\" is a deprecated filesystem name."
operator|+
literal|" Use \"hdfs://"
operator|+
name|name
operator|+
literal|"/\" instead."
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"hdfs://"
operator|+
name|name
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
comment|/**    * Get the local FileSystem.    * @param conf the configuration to configure the FileSystem with    * if it is newly instantiated.    * @return a LocalFileSystem    * @throws IOException if somehow the local FS cannot be instantiated.    */
DECL|method|getLocal (Configuration conf)
specifier|public
specifier|static
name|LocalFileSystem
name|getLocal
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|(
name|LocalFileSystem
operator|)
name|get
argument_list|(
name|LocalFileSystem
operator|.
name|NAME
argument_list|,
name|conf
argument_list|)
return|;
block|}
comment|/**    * Get a FileSystem for this URI's scheme and authority.    *<ol>    *<li>    *   If the configuration has the property    *   {@code "fs.$SCHEME.impl.disable.cache"} set to true,    *   a new instance will be created, initialized with the supplied URI and    *   configuration, then returned without being cached.    *</li>    *<li>    *   If the there is a cached FS instance matching the same URI, it will    *   be returned.    *</li>    *<li>    *   Otherwise: a new FS instance will be created, initialized with the    *   configuration and URI, cached and returned to the caller.    *</li>    *</ol>    * @throws IOException if the FileSystem cannot be instantiated.    */
DECL|method|get (URI uri, Configuration conf)
specifier|public
specifier|static
name|FileSystem
name|get
parameter_list|(
name|URI
name|uri
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|scheme
init|=
name|uri
operator|.
name|getScheme
argument_list|()
decl_stmt|;
name|String
name|authority
init|=
name|uri
operator|.
name|getAuthority
argument_list|()
decl_stmt|;
if|if
condition|(
name|scheme
operator|==
literal|null
operator|&&
name|authority
operator|==
literal|null
condition|)
block|{
comment|// use default FS
return|return
name|get
argument_list|(
name|conf
argument_list|)
return|;
block|}
if|if
condition|(
name|scheme
operator|!=
literal|null
operator|&&
name|authority
operator|==
literal|null
condition|)
block|{
comment|// no authority
name|URI
name|defaultUri
init|=
name|getDefaultUri
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|scheme
operator|.
name|equals
argument_list|(
name|defaultUri
operator|.
name|getScheme
argument_list|()
argument_list|)
comment|// if scheme matches default
operator|&&
name|defaultUri
operator|.
name|getAuthority
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|//& default has authority
return|return
name|get
argument_list|(
name|defaultUri
argument_list|,
name|conf
argument_list|)
return|;
comment|// return default
block|}
block|}
name|String
name|disableCacheName
init|=
name|String
operator|.
name|format
argument_list|(
literal|"fs.%s.impl.disable.cache"
argument_list|,
name|scheme
argument_list|)
decl_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|disableCacheName
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Bypassing cache to create filesystem {}"
argument_list|,
name|uri
argument_list|)
expr_stmt|;
return|return
name|createFileSystem
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
return|;
block|}
return|return
name|CACHE
operator|.
name|get
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
return|;
block|}
comment|/**    * Returns the FileSystem for this URI's scheme and authority and the    * given user. Internally invokes {@link #newInstance(URI, Configuration)}    * @param uri of the filesystem    * @param conf the configuration to use    * @param user to perform the get as    * @return filesystem instance    * @throws IOException if the FileSystem cannot be instantiated.    * @throws InterruptedException If the {@code UGI.doAs()} call was    *         somehow interrupted.    */
DECL|method|newInstance (final URI uri, final Configuration conf, final String user)
specifier|public
specifier|static
name|FileSystem
name|newInstance
parameter_list|(
specifier|final
name|URI
name|uri
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|,
specifier|final
name|String
name|user
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|String
name|ticketCachePath
init|=
name|conf
operator|.
name|get
argument_list|(
name|CommonConfigurationKeys
operator|.
name|KERBEROS_TICKET_CACHE_PATH
argument_list|)
decl_stmt|;
name|UserGroupInformation
name|ugi
init|=
name|UserGroupInformation
operator|.
name|getBestUGI
argument_list|(
name|ticketCachePath
argument_list|,
name|user
argument_list|)
decl_stmt|;
return|return
name|ugi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|FileSystem
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileSystem
name|run
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|newInstance
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**    * Returns the FileSystem for this URI's scheme and authority.    * The entire URI is passed to the FileSystem instance's initialize method.    * This always returns a new FileSystem object.    * @param uri FS URI    * @param config configuration to use    * @return the new FS instance    * @throws IOException FS creation or initialization failure.    */
DECL|method|newInstance (URI uri, Configuration config)
specifier|public
specifier|static
name|FileSystem
name|newInstance
parameter_list|(
name|URI
name|uri
parameter_list|,
name|Configuration
name|config
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|scheme
init|=
name|uri
operator|.
name|getScheme
argument_list|()
decl_stmt|;
name|String
name|authority
init|=
name|uri
operator|.
name|getAuthority
argument_list|()
decl_stmt|;
if|if
condition|(
name|scheme
operator|==
literal|null
condition|)
block|{
comment|// no scheme: use default FS
return|return
name|newInstance
argument_list|(
name|config
argument_list|)
return|;
block|}
if|if
condition|(
name|authority
operator|==
literal|null
condition|)
block|{
comment|// no authority
name|URI
name|defaultUri
init|=
name|getDefaultUri
argument_list|(
name|config
argument_list|)
decl_stmt|;
if|if
condition|(
name|scheme
operator|.
name|equals
argument_list|(
name|defaultUri
operator|.
name|getScheme
argument_list|()
argument_list|)
comment|// if scheme matches default
operator|&&
name|defaultUri
operator|.
name|getAuthority
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|//& default has authority
return|return
name|newInstance
argument_list|(
name|defaultUri
argument_list|,
name|config
argument_list|)
return|;
comment|// return default
block|}
block|}
return|return
name|CACHE
operator|.
name|getUnique
argument_list|(
name|uri
argument_list|,
name|config
argument_list|)
return|;
block|}
comment|/**    * Returns a unique configured FileSystem implementation for the default    * filesystem of the supplied configuration.    * This always returns a new FileSystem object.    * @param conf the configuration to use    * @return the new FS instance    * @throws IOException FS creation or initialization failure.    */
DECL|method|newInstance (Configuration conf)
specifier|public
specifier|static
name|FileSystem
name|newInstance
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|newInstance
argument_list|(
name|getDefaultUri
argument_list|(
name|conf
argument_list|)
argument_list|,
name|conf
argument_list|)
return|;
block|}
comment|/**    * Get a unique local FileSystem object.    * @param conf the configuration to configure the FileSystem with    * @return a new LocalFileSystem object.    * @throws IOException FS creation or initialization failure.    */
DECL|method|newInstanceLocal (Configuration conf)
specifier|public
specifier|static
name|LocalFileSystem
name|newInstanceLocal
parameter_list|(
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|(
name|LocalFileSystem
operator|)
name|newInstance
argument_list|(
name|LocalFileSystem
operator|.
name|NAME
argument_list|,
name|conf
argument_list|)
return|;
block|}
comment|/**    * Close all cached FileSystem instances. After this operation, they    * may not be used in any operations.    *    * @throws IOException a problem arose closing one or more filesystem.    */
DECL|method|closeAll ()
specifier|public
specifier|static
name|void
name|closeAll
parameter_list|()
throws|throws
name|IOException
block|{
name|CACHE
operator|.
name|closeAll
argument_list|()
expr_stmt|;
block|}
comment|/**    * Close all cached FileSystem instances for a given UGI.    * Be sure those filesystems are not used anymore.    * @param ugi user group info to close    * @throws IOException a problem arose closing one or more filesystem.    */
DECL|method|closeAllForUGI (UserGroupInformation ugi)
specifier|public
specifier|static
name|void
name|closeAllForUGI
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|)
throws|throws
name|IOException
block|{
name|CACHE
operator|.
name|closeAll
argument_list|(
name|ugi
argument_list|)
expr_stmt|;
block|}
comment|/**    * Qualify a path to one which uses this FileSystem and, if relative,    * made absolute.    * @param path to qualify.    * @return this path if it contains a scheme and authority and is absolute, or    * a new path that includes a path and authority and is fully qualified    * @see Path#makeQualified(URI, Path)    * @throws IllegalArgumentException if the path has a schema/URI different    * from this FileSystem.    */
DECL|method|makeQualified (Path path)
specifier|public
name|Path
name|makeQualified
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
name|checkPath
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|path
operator|.
name|makeQualified
argument_list|(
name|this
operator|.
name|getUri
argument_list|()
argument_list|,
name|this
operator|.
name|getWorkingDirectory
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get a new delegation token for this FileSystem.    * This is an internal method that should have been declared protected    * but wasn't historically.    * Callers should use {@link #addDelegationTokens(String, Credentials)}    *    * @param renewer the account name that is allowed to renew the token.    * @return a new delegation token or null if the FS does not support tokens.    * @throws IOException on any problem obtaining a token    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
argument_list|()
DECL|method|getDelegationToken (String renewer)
specifier|public
name|Token
argument_list|<
name|?
argument_list|>
name|getDelegationToken
parameter_list|(
name|String
name|renewer
parameter_list|)
throws|throws
name|IOException
block|{
return|return
literal|null
return|;
block|}
comment|/**    * Obtain all delegation tokens used by this FileSystem that are not    * already present in the given Credentials. Existing tokens will neither    * be verified as valid nor having the given renewer.  Missing tokens will    * be acquired and added to the given Credentials.    *    * Default Impl: works for simple FS with its own token    * and also for an embedded FS whose tokens are those of its    * child FileSystems (i.e. the embedded FS has no tokens of its own).    *    * @param renewer the user allowed to renew the delegation tokens    * @param credentials cache in which to add new delegation tokens    * @return list of new delegation tokens    * @throws IOException problems obtaining a token    */
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|addDelegationTokens ( final String renewer, Credentials credentials)
specifier|public
name|Token
argument_list|<
name|?
argument_list|>
index|[]
name|addDelegationTokens
parameter_list|(
specifier|final
name|String
name|renewer
parameter_list|,
name|Credentials
name|credentials
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|credentials
operator|==
literal|null
condition|)
block|{
name|credentials
operator|=
operator|new
name|Credentials
argument_list|()
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|Token
argument_list|<
name|?
argument_list|>
argument_list|>
name|tokens
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|collectDelegationTokens
argument_list|(
name|renewer
argument_list|,
name|credentials
argument_list|,
name|tokens
argument_list|)
expr_stmt|;
return|return
name|tokens
operator|.
name|toArray
argument_list|(
operator|new
name|Token
argument_list|<
name|?
argument_list|>
index|[
name|tokens
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * Recursively obtain the tokens for this FileSystem and all descendant    * FileSystems as determined by {@link #getChildFileSystems()}.    * @param renewer the user allowed to renew the delegation tokens    * @param credentials cache in which to add the new delegation tokens    * @param tokens list in which to add acquired tokens    * @throws IOException problems obtaining a token    */
DECL|method|collectDelegationTokens (final String renewer, final Credentials credentials, final List<Token<?>> tokens)
specifier|private
name|void
name|collectDelegationTokens
parameter_list|(
specifier|final
name|String
name|renewer
parameter_list|,
specifier|final
name|Credentials
name|credentials
parameter_list|,
specifier|final
name|List
argument_list|<
name|Token
argument_list|<
name|?
argument_list|>
argument_list|>
name|tokens
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|serviceName
init|=
name|getCanonicalServiceName
argument_list|()
decl_stmt|;
comment|// Collect token of the this filesystem and then of its embedded children
if|if
condition|(
name|serviceName
operator|!=
literal|null
condition|)
block|{
comment|// fs has token, grab it
specifier|final
name|Text
name|service
init|=
operator|new
name|Text
argument_list|(
name|serviceName
argument_list|)
decl_stmt|;
name|Token
argument_list|<
name|?
argument_list|>
name|token
init|=
name|credentials
operator|.
name|getToken
argument_list|(
name|service
argument_list|)
decl_stmt|;
if|if
condition|(
name|token
operator|==
literal|null
condition|)
block|{
name|token
operator|=
name|getDelegationToken
argument_list|(
name|renewer
argument_list|)
expr_stmt|;
if|if
condition|(
name|token
operator|!=
literal|null
condition|)
block|{
name|tokens
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|credentials
operator|.
name|addToken
argument_list|(
name|service
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Now collect the tokens from the children
specifier|final
name|FileSystem
index|[]
name|children
init|=
name|getChildFileSystems
argument_list|()
decl_stmt|;
if|if
condition|(
name|children
operator|!=
literal|null
condition|)
block|{
for|for
control|(
specifier|final
name|FileSystem
name|fs
range|:
name|children
control|)
block|{
name|fs
operator|.
name|collectDelegationTokens
argument_list|(
name|renewer
argument_list|,
name|credentials
argument_list|,
name|tokens
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Get all the immediate child FileSystems embedded in this FileSystem.    * It does not recurse and get grand children.  If a FileSystem    * has multiple child FileSystems, then it must return a unique list    * of those FileSystems.  Default is to return null to signify no children.    *    * @return FileSystems that are direct children of this FileSystem,    *         or null for "no children"    */
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|}
argument_list|)
annotation|@
name|VisibleForTesting
DECL|method|getChildFileSystems ()
specifier|public
name|FileSystem
index|[]
name|getChildFileSystems
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
comment|/**    * Create a file with the provided permission.    *    * The permission of the file is set to be the provided permission as in    * setPermission, not permission&~umask    *    * The HDFS implementation is implemented using two RPCs.    * It is understood that it is inefficient,    * but the implementation is thread-safe. The other option is to change the    * value of umask in configuration to be 0, but it is not thread-safe.    *    * @param fs FileSystem    * @param file the name of the file to be created    * @param permission the permission of the file    * @return an output stream    * @throws IOException IO failure    */
DECL|method|create (FileSystem fs, Path file, FsPermission permission)
specifier|public
specifier|static
name|FSDataOutputStream
name|create
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|file
parameter_list|,
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|IOException
block|{
comment|// create the file with default permission
name|FSDataOutputStream
name|out
init|=
name|fs
operator|.
name|create
argument_list|(
name|file
argument_list|)
decl_stmt|;
comment|// set its permission to the supplied one
name|fs
operator|.
name|setPermission
argument_list|(
name|file
argument_list|,
name|permission
argument_list|)
expr_stmt|;
return|return
name|out
return|;
block|}
comment|/**    * Create a directory with the provided permission.    * The permission of the directory is set to be the provided permission as in    * setPermission, not permission&~umask    *    * @see #create(FileSystem, Path, FsPermission)    *    * @param fs FileSystem handle    * @param dir the name of the directory to be created    * @param permission the permission of the directory    * @return true if the directory creation succeeds; false otherwise    * @throws IOException A problem creating the directories.    */
DECL|method|mkdirs (FileSystem fs, Path dir, FsPermission permission)
specifier|public
specifier|static
name|boolean
name|mkdirs
parameter_list|(
name|FileSystem
name|fs
parameter_list|,
name|Path
name|dir
parameter_list|,
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|IOException
block|{
comment|// create the directory using the default permission
name|boolean
name|result
init|=
name|fs
operator|.
name|mkdirs
argument_list|(
name|dir
argument_list|)
decl_stmt|;
comment|// set its permission to be the supplied one
name|fs
operator|.
name|setPermission
argument_list|(
name|dir
argument_list|,
name|permission
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|///////////////////////////////////////////////////////////////
comment|// FileSystem
comment|///////////////////////////////////////////////////////////////
DECL|method|FileSystem ()
specifier|protected
name|FileSystem
parameter_list|()
block|{
name|super
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check that a Path belongs to this FileSystem.    *    * The base implementation performs case insensitive equality checks    * of the URIs' schemes and authorities. Subclasses may implement slightly    * different checks.    * @param path to check    * @throws IllegalArgumentException if the path is not considered to be    * part of this FileSystem.    *    */
DECL|method|checkPath (Path path)
specifier|protected
name|void
name|checkPath
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
name|URI
name|uri
init|=
name|path
operator|.
name|toUri
argument_list|()
decl_stmt|;
name|String
name|thatScheme
init|=
name|uri
operator|.
name|getScheme
argument_list|()
decl_stmt|;
if|if
condition|(
name|thatScheme
operator|==
literal|null
condition|)
comment|// fs is relative
return|return;
name|URI
name|thisUri
init|=
name|getCanonicalUri
argument_list|()
decl_stmt|;
name|String
name|thisScheme
init|=
name|thisUri
operator|.
name|getScheme
argument_list|()
decl_stmt|;
comment|//authority and scheme are not case sensitive
if|if
condition|(
name|thisScheme
operator|.
name|equalsIgnoreCase
argument_list|(
name|thatScheme
argument_list|)
condition|)
block|{
comment|// schemes match
name|String
name|thisAuthority
init|=
name|thisUri
operator|.
name|getAuthority
argument_list|()
decl_stmt|;
name|String
name|thatAuthority
init|=
name|uri
operator|.
name|getAuthority
argument_list|()
decl_stmt|;
if|if
condition|(
name|thatAuthority
operator|==
literal|null
operator|&&
comment|// path's authority is null
name|thisAuthority
operator|!=
literal|null
condition|)
block|{
comment|// fs has an authority
name|URI
name|defaultUri
init|=
name|getDefaultUri
argument_list|(
name|getConf
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|thisScheme
operator|.
name|equalsIgnoreCase
argument_list|(
name|defaultUri
operator|.
name|getScheme
argument_list|()
argument_list|)
condition|)
block|{
name|uri
operator|=
name|defaultUri
expr_stmt|;
comment|// schemes match, so use this uri instead
block|}
else|else
block|{
name|uri
operator|=
literal|null
expr_stmt|;
comment|// can't determine auth of the path
block|}
block|}
if|if
condition|(
name|uri
operator|!=
literal|null
condition|)
block|{
comment|// canonicalize uri before comparing with this fs
name|uri
operator|=
name|canonicalizeUri
argument_list|(
name|uri
argument_list|)
expr_stmt|;
name|thatAuthority
operator|=
name|uri
operator|.
name|getAuthority
argument_list|()
expr_stmt|;
if|if
condition|(
name|thisAuthority
operator|==
name|thatAuthority
operator|||
comment|// authorities match
operator|(
name|thisAuthority
operator|!=
literal|null
operator|&&
name|thisAuthority
operator|.
name|equalsIgnoreCase
argument_list|(
name|thatAuthority
argument_list|)
operator|)
condition|)
return|return;
block|}
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Wrong FS: "
operator|+
name|path
operator|+
literal|", expected: "
operator|+
name|this
operator|.
name|getUri
argument_list|()
argument_list|)
throw|;
block|}
comment|/**    * Return an array containing hostnames, offset and size of    * portions of the given file.  For nonexistent    * file or regions, {@code null} is returned.    *    *<pre>    *   if f == null :    *     result = null    *   elif f.getLen()<= start:    *     result = []    *   else result = [ locations(FS, b) for b in blocks(FS, p, s, s+l)]    *</pre>    * This call is most helpful with and distributed filesystem    * where the hostnames of machines that contain blocks of the given file    * can be determined.    *    * The default implementation returns an array containing one element:    *<pre>    * BlockLocation( { "localhost:9866" },  { "localhost" }, 0, file.getLen())    *</pre>>    *    * @param file FilesStatus to get data from    * @param start offset into the given file    * @param len length for which to get locations for    * @throws IOException IO failure    */
DECL|method|getFileBlockLocations (FileStatus file, long start, long len)
specifier|public
name|BlockLocation
index|[]
name|getFileBlockLocations
parameter_list|(
name|FileStatus
name|file
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|file
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|start
operator|<
literal|0
operator|||
name|len
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid start or len parameter"
argument_list|)
throw|;
block|}
if|if
condition|(
name|file
operator|.
name|getLen
argument_list|()
operator|<=
name|start
condition|)
block|{
return|return
operator|new
name|BlockLocation
index|[
literal|0
index|]
return|;
block|}
name|String
index|[]
name|name
init|=
block|{
literal|"localhost:9866"
block|}
decl_stmt|;
name|String
index|[]
name|host
init|=
block|{
literal|"localhost"
block|}
decl_stmt|;
return|return
operator|new
name|BlockLocation
index|[]
block|{
operator|new
name|BlockLocation
argument_list|(
name|name
argument_list|,
name|host
argument_list|,
literal|0
argument_list|,
name|file
operator|.
name|getLen
argument_list|()
argument_list|)
block|}
return|;
block|}
comment|/**    * Return an array containing hostnames, offset and size of    * portions of the given file.  For a nonexistent    * file or regions, {@code null} is returned.    *    * This call is most helpful with location-aware distributed    * filesystems, where it returns hostnames of machines that    * contain the given file.    *    * A FileSystem will normally return the equivalent result    * of passing the {@code FileStatus} of the path to    * {@link #getFileBlockLocations(FileStatus, long, long)}    *    * @param p path is used to identify an FS since an FS could have    *          another FS that it could be delegating the call to    * @param start offset into the given file    * @param len length for which to get locations for    * @throws FileNotFoundException when the path does not exist    * @throws IOException IO failure    */
DECL|method|getFileBlockLocations (Path p, long start, long len)
specifier|public
name|BlockLocation
index|[]
name|getFileBlockLocations
parameter_list|(
name|Path
name|p
parameter_list|,
name|long
name|start
parameter_list|,
name|long
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|p
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
name|FileStatus
name|file
init|=
name|getFileStatus
argument_list|(
name|p
argument_list|)
decl_stmt|;
return|return
name|getFileBlockLocations
argument_list|(
name|file
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
return|;
block|}
comment|/**    * Return a set of server default configuration values.    * @return server default configuration values    * @throws IOException IO failure    * @deprecated use {@link #getServerDefaults(Path)} instead    */
annotation|@
name|Deprecated
DECL|method|getServerDefaults ()
specifier|public
name|FsServerDefaults
name|getServerDefaults
parameter_list|()
throws|throws
name|IOException
block|{
name|Configuration
name|config
init|=
name|getConf
argument_list|()
decl_stmt|;
comment|// CRC32 is chosen as default as it is available in all
comment|// releases that support checksum.
comment|// The client trash configuration is ignored.
return|return
operator|new
name|FsServerDefaults
argument_list|(
name|getDefaultBlockSize
argument_list|()
argument_list|,
name|config
operator|.
name|getInt
argument_list|(
literal|"io.bytes.per.checksum"
argument_list|,
literal|512
argument_list|)
argument_list|,
literal|64
operator|*
literal|1024
argument_list|,
name|getDefaultReplication
argument_list|()
argument_list|,
name|config
operator|.
name|getInt
argument_list|(
name|IO_FILE_BUFFER_SIZE_KEY
argument_list|,
name|IO_FILE_BUFFER_SIZE_DEFAULT
argument_list|)
argument_list|,
literal|false
argument_list|,
name|FS_TRASH_INTERVAL_DEFAULT
argument_list|,
name|DataChecksum
operator|.
name|Type
operator|.
name|CRC32
argument_list|,
literal|""
argument_list|)
return|;
block|}
comment|/**    * Return a set of server default configuration values.    * @param p path is used to identify an FS since an FS could have    *          another FS that it could be delegating the call to    * @return server default configuration values    * @throws IOException IO failure    */
DECL|method|getServerDefaults (Path p)
specifier|public
name|FsServerDefaults
name|getServerDefaults
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getServerDefaults
argument_list|()
return|;
block|}
comment|/**    * Return the fully-qualified path of path, resolving the path    * through any symlinks or mount point.    * @param p path to be resolved    * @return fully qualified path    * @throws FileNotFoundException if the path is not present    * @throws IOException for any other error    */
DECL|method|resolvePath (final Path p)
specifier|public
name|Path
name|resolvePath
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|checkPath
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|getFileStatus
argument_list|(
name|p
argument_list|)
operator|.
name|getPath
argument_list|()
return|;
block|}
comment|/**    * Opens an FSDataInputStream at the indicated Path.    * @param f the file name to open    * @param bufferSize the size of the buffer to be used.    * @throws IOException IO failure    */
DECL|method|open (Path f, int bufferSize)
specifier|public
specifier|abstract
name|FSDataInputStream
name|open
parameter_list|(
name|Path
name|f
parameter_list|,
name|int
name|bufferSize
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Opens an FSDataInputStream at the indicated Path.    * @param f the file to open    * @throws IOException IO failure    */
DECL|method|open (Path f)
specifier|public
name|FSDataInputStream
name|open
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|open
argument_list|(
name|f
argument_list|,
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|IO_FILE_BUFFER_SIZE_KEY
argument_list|,
name|IO_FILE_BUFFER_SIZE_DEFAULT
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Create an FSDataOutputStream at the indicated Path.    * Files are overwritten by default.    * @param f the file to create    * @throws IOException IO failure    */
DECL|method|create (Path f)
specifier|public
name|FSDataOutputStream
name|create
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|create
argument_list|(
name|f
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Create an FSDataOutputStream at the indicated Path.    * @param f the file to create    * @param overwrite if a file with this name already exists, then if true,    *   the file will be overwritten, and if false an exception will be thrown.    * @throws IOException IO failure    */
DECL|method|create (Path f, boolean overwrite)
specifier|public
name|FSDataOutputStream
name|create
parameter_list|(
name|Path
name|f
parameter_list|,
name|boolean
name|overwrite
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|create
argument_list|(
name|f
argument_list|,
name|overwrite
argument_list|,
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|IO_FILE_BUFFER_SIZE_KEY
argument_list|,
name|IO_FILE_BUFFER_SIZE_DEFAULT
argument_list|)
argument_list|,
name|getDefaultReplication
argument_list|(
name|f
argument_list|)
argument_list|,
name|getDefaultBlockSize
argument_list|(
name|f
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Create an FSDataOutputStream at the indicated Path with write-progress    * reporting.    * Files are overwritten by default.    * @param f the file to create    * @param progress to report progress    * @throws IOException IO failure    */
DECL|method|create (Path f, Progressable progress)
specifier|public
name|FSDataOutputStream
name|create
parameter_list|(
name|Path
name|f
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|create
argument_list|(
name|f
argument_list|,
literal|true
argument_list|,
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|IO_FILE_BUFFER_SIZE_KEY
argument_list|,
name|IO_FILE_BUFFER_SIZE_DEFAULT
argument_list|)
argument_list|,
name|getDefaultReplication
argument_list|(
name|f
argument_list|)
argument_list|,
name|getDefaultBlockSize
argument_list|(
name|f
argument_list|)
argument_list|,
name|progress
argument_list|)
return|;
block|}
comment|/**    * Create an FSDataOutputStream at the indicated Path.    * Files are overwritten by default.    * @param f the file to create    * @param replication the replication factor    * @throws IOException IO failure    */
DECL|method|create (Path f, short replication)
specifier|public
name|FSDataOutputStream
name|create
parameter_list|(
name|Path
name|f
parameter_list|,
name|short
name|replication
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|create
argument_list|(
name|f
argument_list|,
literal|true
argument_list|,
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|IO_FILE_BUFFER_SIZE_KEY
argument_list|,
name|IO_FILE_BUFFER_SIZE_DEFAULT
argument_list|)
argument_list|,
name|replication
argument_list|,
name|getDefaultBlockSize
argument_list|(
name|f
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Create an FSDataOutputStream at the indicated Path with write-progress    * reporting.    * Files are overwritten by default.    * @param f the file to create    * @param replication the replication factor    * @param progress to report progress    * @throws IOException IO failure    */
DECL|method|create (Path f, short replication, Progressable progress)
specifier|public
name|FSDataOutputStream
name|create
parameter_list|(
name|Path
name|f
parameter_list|,
name|short
name|replication
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|create
argument_list|(
name|f
argument_list|,
literal|true
argument_list|,
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|IO_FILE_BUFFER_SIZE_KEY
argument_list|,
name|IO_FILE_BUFFER_SIZE_DEFAULT
argument_list|)
argument_list|,
name|replication
argument_list|,
name|getDefaultBlockSize
argument_list|(
name|f
argument_list|)
argument_list|,
name|progress
argument_list|)
return|;
block|}
comment|/**    * Create an FSDataOutputStream at the indicated Path.    * @param f the file to create    * @param overwrite if a path with this name already exists, then if true,    *   the file will be overwritten, and if false an error will be thrown.    * @param bufferSize the size of the buffer to be used.    * @throws IOException IO failure    */
DECL|method|create (Path f, boolean overwrite, int bufferSize )
specifier|public
name|FSDataOutputStream
name|create
parameter_list|(
name|Path
name|f
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|int
name|bufferSize
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|create
argument_list|(
name|f
argument_list|,
name|overwrite
argument_list|,
name|bufferSize
argument_list|,
name|getDefaultReplication
argument_list|(
name|f
argument_list|)
argument_list|,
name|getDefaultBlockSize
argument_list|(
name|f
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Create an {@link FSDataOutputStream} at the indicated Path    * with write-progress reporting.    *    * The frequency of callbacks is implementation-specific; it may be "none".    * @param f the path of the file to open    * @param overwrite if a file with this name already exists, then if true,    *   the file will be overwritten, and if false an error will be thrown.    * @param bufferSize the size of the buffer to be used.    * @throws IOException IO failure    */
DECL|method|create (Path f, boolean overwrite, int bufferSize, Progressable progress )
specifier|public
name|FSDataOutputStream
name|create
parameter_list|(
name|Path
name|f
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|create
argument_list|(
name|f
argument_list|,
name|overwrite
argument_list|,
name|bufferSize
argument_list|,
name|getDefaultReplication
argument_list|(
name|f
argument_list|)
argument_list|,
name|getDefaultBlockSize
argument_list|(
name|f
argument_list|)
argument_list|,
name|progress
argument_list|)
return|;
block|}
comment|/**    * Create an FSDataOutputStream at the indicated Path.    * @param f the file name to open    * @param overwrite if a file with this name already exists, then if true,    *   the file will be overwritten, and if false an error will be thrown.    * @param bufferSize the size of the buffer to be used.    * @param replication required block replication for the file.    * @throws IOException IO failure    */
DECL|method|create (Path f, boolean overwrite, int bufferSize, short replication, long blockSize)
specifier|public
name|FSDataOutputStream
name|create
parameter_list|(
name|Path
name|f
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|create
argument_list|(
name|f
argument_list|,
name|overwrite
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Create an FSDataOutputStream at the indicated Path with write-progress    * reporting.    * @param f the file name to open    * @param overwrite if a file with this name already exists, then if true,    *   the file will be overwritten, and if false an error will be thrown.    * @param bufferSize the size of the buffer to be used.    * @param replication required block replication for the file.    * @throws IOException IO failure    */
DECL|method|create (Path f, boolean overwrite, int bufferSize, short replication, long blockSize, Progressable progress )
specifier|public
name|FSDataOutputStream
name|create
parameter_list|(
name|Path
name|f
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|create
argument_list|(
name|f
argument_list|,
name|FsCreateModes
operator|.
name|applyUMask
argument_list|(
name|FsPermission
operator|.
name|getFileDefault
argument_list|()
argument_list|,
name|FsPermission
operator|.
name|getUMask
argument_list|(
name|getConf
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|overwrite
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|)
return|;
block|}
comment|/**    * Create an FSDataOutputStream at the indicated Path with write-progress    * reporting.    * @param f the file name to open    * @param permission file permission    * @param overwrite if a file with this name already exists, then if true,    *   the file will be overwritten, and if false an error will be thrown.    * @param bufferSize the size of the buffer to be used.    * @param replication required block replication for the file.    * @param blockSize block size    * @param progress the progress reporter    * @throws IOException IO failure    * @see #setPermission(Path, FsPermission)    */
DECL|method|create (Path f, FsPermission permission, boolean overwrite, int bufferSize, short replication, long blockSize, Progressable progress)
specifier|public
specifier|abstract
name|FSDataOutputStream
name|create
parameter_list|(
name|Path
name|f
parameter_list|,
name|FsPermission
name|permission
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Create an FSDataOutputStream at the indicated Path with write-progress    * reporting.    * @param f the file name to open    * @param permission file permission    * @param flags {@link CreateFlag}s to use for this stream.    * @param bufferSize the size of the buffer to be used.    * @param replication required block replication for the file.    * @param blockSize block size    * @param progress the progress reporter    * @throws IOException IO failure    * @see #setPermission(Path, FsPermission)    */
DECL|method|create (Path f, FsPermission permission, EnumSet<CreateFlag> flags, int bufferSize, short replication, long blockSize, Progressable progress)
specifier|public
name|FSDataOutputStream
name|create
parameter_list|(
name|Path
name|f
parameter_list|,
name|FsPermission
name|permission
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flags
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|create
argument_list|(
name|f
argument_list|,
name|permission
argument_list|,
name|flags
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Create an FSDataOutputStream at the indicated Path with a custom    * checksum option.    * @param f the file name to open    * @param permission file permission    * @param flags {@link CreateFlag}s to use for this stream.    * @param bufferSize the size of the buffer to be used.    * @param replication required block replication for the file.    * @param blockSize block size    * @param progress the progress reporter    * @param checksumOpt checksum parameter. If null, the values    *        found in conf will be used.    * @throws IOException IO failure    * @see #setPermission(Path, FsPermission)    */
DECL|method|create (Path f, FsPermission permission, EnumSet<CreateFlag> flags, int bufferSize, short replication, long blockSize, Progressable progress, ChecksumOpt checksumOpt)
specifier|public
name|FSDataOutputStream
name|create
parameter_list|(
name|Path
name|f
parameter_list|,
name|FsPermission
name|permission
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flags
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|ChecksumOpt
name|checksumOpt
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Checksum options are ignored by default. The file systems that
comment|// implement checksum need to override this method. The full
comment|// support is currently only available in DFS.
return|return
name|create
argument_list|(
name|f
argument_list|,
name|permission
argument_list|,
name|flags
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|OVERWRITE
argument_list|)
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|)
return|;
block|}
comment|/**    * This create has been added to support the FileContext that processes    * the permission with umask before calling this method.    * This a temporary method added to support the transition from FileSystem    * to FileContext for user applications.    * @throws IOException IO failure    */
annotation|@
name|Deprecated
DECL|method|primitiveCreate (Path f, FsPermission absolutePermission, EnumSet<CreateFlag> flag, int bufferSize, short replication, long blockSize, Progressable progress, ChecksumOpt checksumOpt)
specifier|protected
name|FSDataOutputStream
name|primitiveCreate
parameter_list|(
name|Path
name|f
parameter_list|,
name|FsPermission
name|absolutePermission
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flag
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|,
name|ChecksumOpt
name|checksumOpt
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|pathExists
init|=
name|exists
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|CreateFlag
operator|.
name|validate
argument_list|(
name|f
argument_list|,
name|pathExists
argument_list|,
name|flag
argument_list|)
expr_stmt|;
comment|// Default impl  assumes that permissions do not matter and
comment|// nor does the bytesPerChecksum  hence
comment|// calling the regular create is good enough.
comment|// FSs that implement permissions should override this.
if|if
condition|(
name|pathExists
operator|&&
name|flag
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|APPEND
argument_list|)
condition|)
block|{
return|return
name|append
argument_list|(
name|f
argument_list|,
name|bufferSize
argument_list|,
name|progress
argument_list|)
return|;
block|}
return|return
name|this
operator|.
name|create
argument_list|(
name|f
argument_list|,
name|absolutePermission
argument_list|,
name|flag
operator|.
name|contains
argument_list|(
name|CreateFlag
operator|.
name|OVERWRITE
argument_list|)
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|)
return|;
block|}
comment|/**    * This version of the mkdirs method assumes that the permission is absolute.    * It has been added to support the FileContext that processes the permission    * with umask before calling this method.    * This a temporary method added to support the transition from FileSystem    * to FileContext for user applications.    * @param f path    * @param absolutePermission permissions    * @return true if the directory was actually created.    * @throws IOException IO failure    * @see #mkdirs(Path, FsPermission)    */
annotation|@
name|Deprecated
DECL|method|primitiveMkdir (Path f, FsPermission absolutePermission)
specifier|protected
name|boolean
name|primitiveMkdir
parameter_list|(
name|Path
name|f
parameter_list|,
name|FsPermission
name|absolutePermission
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|mkdirs
argument_list|(
name|f
argument_list|,
name|absolutePermission
argument_list|)
return|;
block|}
comment|/**    * This version of the mkdirs method assumes that the permission is absolute.    * It has been added to support the FileContext that processes the permission    * with umask before calling this method.    * This a temporary method added to support the transition from FileSystem    * to FileContext for user applications.    */
annotation|@
name|Deprecated
DECL|method|primitiveMkdir (Path f, FsPermission absolutePermission, boolean createParent)
specifier|protected
name|void
name|primitiveMkdir
parameter_list|(
name|Path
name|f
parameter_list|,
name|FsPermission
name|absolutePermission
parameter_list|,
name|boolean
name|createParent
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|createParent
condition|)
block|{
comment|// parent must exist.
comment|// since the this.mkdirs makes parent dirs automatically
comment|// we must throw exception if parent does not exist.
specifier|final
name|FileStatus
name|stat
init|=
name|getFileStatus
argument_list|(
name|f
operator|.
name|getParent
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|stat
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Missing parent:"
operator|+
name|f
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|stat
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ParentNotDirectoryException
argument_list|(
literal|"parent is not a dir"
argument_list|)
throw|;
block|}
comment|// parent does exist - go ahead with mkdir of leaf
block|}
comment|// Default impl is to assume that permissions do not matter and hence
comment|// calling the regular mkdirs is good enough.
comment|// FSs that implement permissions should override this.
if|if
condition|(
operator|!
name|this
operator|.
name|mkdirs
argument_list|(
name|f
argument_list|,
name|absolutePermission
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"mkdir of "
operator|+
name|f
operator|+
literal|" failed"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Opens an FSDataOutputStream at the indicated Path with write-progress    * reporting. Same as create(), except fails if parent directory doesn't    * already exist.    * @param f the file name to open    * @param overwrite if a file with this name already exists, then if true,    * the file will be overwritten, and if false an error will be thrown.    * @param bufferSize the size of the buffer to be used.    * @param replication required block replication for the file.    * @param blockSize block size    * @param progress the progress reporter    * @throws IOException IO failure    * @see #setPermission(Path, FsPermission)    */
DECL|method|createNonRecursive (Path f, boolean overwrite, int bufferSize, short replication, long blockSize, Progressable progress)
specifier|public
name|FSDataOutputStream
name|createNonRecursive
parameter_list|(
name|Path
name|f
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|this
operator|.
name|createNonRecursive
argument_list|(
name|f
argument_list|,
name|FsPermission
operator|.
name|getFileDefault
argument_list|()
argument_list|,
name|overwrite
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|)
return|;
block|}
comment|/**    * Opens an FSDataOutputStream at the indicated Path with write-progress    * reporting. Same as create(), except fails if parent directory doesn't    * already exist.    * @param f the file name to open    * @param permission file permission    * @param overwrite if a file with this name already exists, then if true,    * the file will be overwritten, and if false an error will be thrown.    * @param bufferSize the size of the buffer to be used.    * @param replication required block replication for the file.    * @param blockSize block size    * @param progress the progress reporter    * @throws IOException IO failure    * @see #setPermission(Path, FsPermission)    */
DECL|method|createNonRecursive (Path f, FsPermission permission, boolean overwrite, int bufferSize, short replication, long blockSize, Progressable progress)
specifier|public
name|FSDataOutputStream
name|createNonRecursive
parameter_list|(
name|Path
name|f
parameter_list|,
name|FsPermission
name|permission
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createNonRecursive
argument_list|(
name|f
argument_list|,
name|permission
argument_list|,
name|overwrite
condition|?
name|EnumSet
operator|.
name|of
argument_list|(
name|CreateFlag
operator|.
name|CREATE
argument_list|,
name|CreateFlag
operator|.
name|OVERWRITE
argument_list|)
else|:
name|EnumSet
operator|.
name|of
argument_list|(
name|CreateFlag
operator|.
name|CREATE
argument_list|)
argument_list|,
name|bufferSize
argument_list|,
name|replication
argument_list|,
name|blockSize
argument_list|,
name|progress
argument_list|)
return|;
block|}
comment|/**     * Opens an FSDataOutputStream at the indicated Path with write-progress     * reporting. Same as create(), except fails if parent directory doesn't     * already exist.     * @param f the file name to open     * @param permission file permission     * @param flags {@link CreateFlag}s to use for this stream.     * @param bufferSize the size of the buffer to be used.     * @param replication required block replication for the file.     * @param blockSize block size     * @param progress the progress reporter     * @throws IOException IO failure     * @see #setPermission(Path, FsPermission)     */
DECL|method|createNonRecursive (Path f, FsPermission permission, EnumSet<CreateFlag> flags, int bufferSize, short replication, long blockSize, Progressable progress)
specifier|public
name|FSDataOutputStream
name|createNonRecursive
parameter_list|(
name|Path
name|f
parameter_list|,
name|FsPermission
name|permission
parameter_list|,
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|flags
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|short
name|replication
parameter_list|,
name|long
name|blockSize
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"createNonRecursive unsupported for this filesystem "
operator|+
name|this
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
comment|/**    * Creates the given Path as a brand-new zero-length file.  If    * create fails, or if it already existed, return false.    *<i>Important: the default implementation is not atomic</i>    * @param f path to use for create    * @throws IOException IO failure    */
DECL|method|createNewFile (Path f)
specifier|public
name|boolean
name|createNewFile
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|exists
argument_list|(
name|f
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
name|create
argument_list|(
name|f
argument_list|,
literal|false
argument_list|,
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|IO_FILE_BUFFER_SIZE_KEY
argument_list|,
name|IO_FILE_BUFFER_SIZE_DEFAULT
argument_list|)
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
comment|/**    * Append to an existing file (optional operation).    * Same as    * {@code append(f, getConf().getInt(IO_FILE_BUFFER_SIZE_KEY,    *     IO_FILE_BUFFER_SIZE_DEFAULT), null)}    * @param f the existing file to be appended.    * @throws IOException IO failure    * @throws UnsupportedOperationException if the operation is unsupported    *         (default).    */
DECL|method|append (Path f)
specifier|public
name|FSDataOutputStream
name|append
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|append
argument_list|(
name|f
argument_list|,
name|getConf
argument_list|()
operator|.
name|getInt
argument_list|(
name|IO_FILE_BUFFER_SIZE_KEY
argument_list|,
name|IO_FILE_BUFFER_SIZE_DEFAULT
argument_list|)
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Append to an existing file (optional operation).    * Same as append(f, bufferSize, null).    * @param f the existing file to be appended.    * @param bufferSize the size of the buffer to be used.    * @throws IOException IO failure    * @throws UnsupportedOperationException if the operation is unsupported    *         (default).    */
DECL|method|append (Path f, int bufferSize)
specifier|public
name|FSDataOutputStream
name|append
parameter_list|(
name|Path
name|f
parameter_list|,
name|int
name|bufferSize
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|append
argument_list|(
name|f
argument_list|,
name|bufferSize
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Append to an existing file (optional operation).    * @param f the existing file to be appended.    * @param bufferSize the size of the buffer to be used.    * @param progress for reporting progress if it is not null.    * @throws IOException IO failure    * @throws UnsupportedOperationException if the operation is unsupported    *         (default).    */
DECL|method|append (Path f, int bufferSize, Progressable progress)
specifier|public
specifier|abstract
name|FSDataOutputStream
name|append
parameter_list|(
name|Path
name|f
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|Progressable
name|progress
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Concat existing files together.    * @param trg the path to the target destination.    * @param psrcs the paths to the sources to use for the concatenation.    * @throws IOException IO failure    * @throws UnsupportedOperationException if the operation is unsupported    *         (default).    */
DECL|method|concat (final Path trg, final Path [] psrcs)
specifier|public
name|void
name|concat
parameter_list|(
specifier|final
name|Path
name|trg
parameter_list|,
specifier|final
name|Path
index|[]
name|psrcs
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Not implemented by the "
operator|+
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" FileSystem implementation"
argument_list|)
throw|;
block|}
comment|/**    * Get the replication factor.    *    * @deprecated Use {@link #getFileStatus(Path)} instead    * @param src file name    * @return file replication    * @throws FileNotFoundException if the path does not resolve.    * @throws IOException an IO failure    */
annotation|@
name|Deprecated
DECL|method|getReplication (Path src)
specifier|public
name|short
name|getReplication
parameter_list|(
name|Path
name|src
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getFileStatus
argument_list|(
name|src
argument_list|)
operator|.
name|getReplication
argument_list|()
return|;
block|}
comment|/**    * Set the replication for an existing file.    * If a filesystem does not support replication, it will always    * return true: the check for a file existing may be bypassed.    * This is the default behavior.    * @param src file name    * @param replication new replication    * @throws IOException    * @return true if successful, or the feature in unsupported;    *         false if replication is supported but the file does not exist,    *         or is a directory    */
DECL|method|setReplication (Path src, short replication)
specifier|public
name|boolean
name|setReplication
parameter_list|(
name|Path
name|src
parameter_list|,
name|short
name|replication
parameter_list|)
throws|throws
name|IOException
block|{
return|return
literal|true
return|;
block|}
comment|/**    * Renames Path src to Path dst.    * @param src path to be renamed    * @param dst new path after rename    * @throws IOException on failure    * @return true if rename is successful    */
DECL|method|rename (Path src, Path dst)
specifier|public
specifier|abstract
name|boolean
name|rename
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Renames Path src to Path dst    *<ul>    *<li>Fails if src is a file and dst is a directory.</li>    *<li>Fails if src is a directory and dst is a file.</li>    *<li>Fails if the parent of dst does not exist or is a file.</li>    *</ul>    *<p>    * If OVERWRITE option is not passed as an argument, rename fails    * if the dst already exists.    *<p>    * If OVERWRITE option is passed as an argument, rename overwrites    * the dst if it is a file or an empty directory. Rename fails if dst is    * a non-empty directory.    *<p>    * Note that atomicity of rename is dependent on the file system    * implementation. Please refer to the file system documentation for    * details. This default implementation is non atomic.    *<p>    * This method is deprecated since it is a temporary method added to    * support the transition from FileSystem to FileContext for user    * applications.    *    * @param src path to be renamed    * @param dst new path after rename    * @throws FileNotFoundException src path does not exist, or the parent    * path of dst does not exist.    * @throws FileAlreadyExistsException dest path exists and is a file    * @throws ParentNotDirectoryException if the parent path of dest is not    * a directory    * @throws IOException on failure    */
annotation|@
name|Deprecated
DECL|method|rename (final Path src, final Path dst, final Rename... options)
specifier|protected
name|void
name|rename
parameter_list|(
specifier|final
name|Path
name|src
parameter_list|,
specifier|final
name|Path
name|dst
parameter_list|,
specifier|final
name|Rename
modifier|...
name|options
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Default implementation
specifier|final
name|FileStatus
name|srcStatus
init|=
name|getFileLinkStatus
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|srcStatus
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"rename source "
operator|+
name|src
operator|+
literal|" not found."
argument_list|)
throw|;
block|}
name|boolean
name|overwrite
init|=
literal|false
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|options
condition|)
block|{
for|for
control|(
name|Rename
name|option
range|:
name|options
control|)
block|{
if|if
condition|(
name|option
operator|==
name|Rename
operator|.
name|OVERWRITE
condition|)
block|{
name|overwrite
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
name|FileStatus
name|dstStatus
decl_stmt|;
try|try
block|{
name|dstStatus
operator|=
name|getFileLinkStatus
argument_list|(
name|dst
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|dstStatus
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|dstStatus
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|srcStatus
operator|.
name|isDirectory
argument_list|()
operator|!=
name|dstStatus
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Source "
operator|+
name|src
operator|+
literal|" Destination "
operator|+
name|dst
operator|+
literal|" both should be either file or directory"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|overwrite
condition|)
block|{
throw|throw
operator|new
name|FileAlreadyExistsException
argument_list|(
literal|"rename destination "
operator|+
name|dst
operator|+
literal|" already exists."
argument_list|)
throw|;
block|}
comment|// Delete the destination that is a file or an empty directory
if|if
condition|(
name|dstStatus
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|FileStatus
index|[]
name|list
init|=
name|listStatus
argument_list|(
name|dst
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|!=
literal|null
operator|&&
name|list
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"rename cannot overwrite non empty destination directory "
operator|+
name|dst
argument_list|)
throw|;
block|}
block|}
name|delete
argument_list|(
name|dst
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|Path
name|parent
init|=
name|dst
operator|.
name|getParent
argument_list|()
decl_stmt|;
specifier|final
name|FileStatus
name|parentStatus
init|=
name|getFileStatus
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentStatus
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"rename destination parent "
operator|+
name|parent
operator|+
literal|" not found."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|parentStatus
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ParentNotDirectoryException
argument_list|(
literal|"rename destination parent "
operator|+
name|parent
operator|+
literal|" is a file."
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|rename
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"rename from "
operator|+
name|src
operator|+
literal|" to "
operator|+
name|dst
operator|+
literal|" failed."
argument_list|)
throw|;
block|}
block|}
comment|/**    * Truncate the file in the indicated path to the indicated size.    *<ul>    *<li>Fails if path is a directory.</li>    *<li>Fails if path does not exist.</li>    *<li>Fails if path is not closed.</li>    *<li>Fails if new size is greater than current size.</li>    *</ul>    * @param f The path to the file to be truncated    * @param newLength The size the file is to be truncated to    *    * @return<code>true</code> if the file has been truncated to the desired    *<code>newLength</code> and is immediately available to be reused for    * write operations such as<code>append</code>, or    *<code>false</code> if a background process of adjusting the length of    * the last block has been started, and clients should wait for it to    * complete before proceeding with further file updates.    * @throws IOException IO failure    * @throws UnsupportedOperationException if the operation is unsupported    *         (default).    */
DECL|method|truncate (Path f, long newLength)
specifier|public
name|boolean
name|truncate
parameter_list|(
name|Path
name|f
parameter_list|,
name|long
name|newLength
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Not implemented by the "
operator|+
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" FileSystem implementation"
argument_list|)
throw|;
block|}
comment|/**    * Delete a file/directory.    * @deprecated Use {@link #delete(Path, boolean)} instead.    */
annotation|@
name|Deprecated
DECL|method|delete (Path f)
specifier|public
name|boolean
name|delete
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|delete
argument_list|(
name|f
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/** Delete a file.    *    * @param f the path to delete.    * @param recursive if path is a directory and set to    * true, the directory is deleted else throws an exception. In    * case of a file the recursive can be set to either true or false.    * @return  true if delete is successful else false.    * @throws IOException IO failure    */
DECL|method|delete (Path f, boolean recursive)
specifier|public
specifier|abstract
name|boolean
name|delete
parameter_list|(
name|Path
name|f
parameter_list|,
name|boolean
name|recursive
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Mark a path to be deleted when its FileSystem is closed.    * When the JVM shuts down cleanly, all cached FileSystem objects will be    * closed automatically âthese the marked paths will be deleted as a result.    *    * If a FileSystem instance is not cached, i.e. has been created with    * {@link #createFileSystem(URI, Configuration)}, then the paths will    * be deleted in when {@link #close()} is called on that instance.    *    * The path must exist in the filesystem at the time of the method call;    * it does not have to exist at the time of JVM shutdown.    *    * Notes    *<ol>    *<li>Clean shutdown of the JVM cannot be guaranteed.</li>    *<li>The time to shut down a FileSystem will depends on the number of    *   files to delete. For filesystems where the cost of checking    *   for the existence of a file/directory and the actual delete operation    *   (for example: object stores) is high, the time to shutdown the JVM can be    *   significantly extended by over-use of this feature.</li>    *<li>Connectivity problems with a remote filesystem may delay shutdown    *   further, and may cause the files to not be deleted.</li>    *</ol>    * @param f the path to delete.    * @return  true if deleteOnExit is successful, otherwise false.    * @throws IOException IO failure    */
DECL|method|deleteOnExit (Path f)
specifier|public
name|boolean
name|deleteOnExit
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|exists
argument_list|(
name|f
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
synchronized|synchronized
init|(
name|deleteOnExit
init|)
block|{
name|deleteOnExit
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**    * Cancel the scheduled deletion of the path when the FileSystem is closed.    * @param f the path to cancel deletion    * @return true if the path was found in the delete-on-exit list.    */
DECL|method|cancelDeleteOnExit (Path f)
specifier|public
name|boolean
name|cancelDeleteOnExit
parameter_list|(
name|Path
name|f
parameter_list|)
block|{
synchronized|synchronized
init|(
name|deleteOnExit
init|)
block|{
return|return
name|deleteOnExit
operator|.
name|remove
argument_list|(
name|f
argument_list|)
return|;
block|}
block|}
comment|/**    * Delete all paths that were marked as delete-on-exit. This recursively    * deletes all files and directories in the specified paths.    *    * The time to process this operation is {@code O(paths)}, with the actual    * time dependent on the time for existence and deletion operations to    * complete, successfully or not.    */
DECL|method|processDeleteOnExit ()
specifier|protected
name|void
name|processDeleteOnExit
parameter_list|()
block|{
synchronized|synchronized
init|(
name|deleteOnExit
init|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|Path
argument_list|>
name|iter
init|=
name|deleteOnExit
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Path
name|path
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|exists
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|delete
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOGGER
operator|.
name|info
argument_list|(
literal|"Ignoring failure to deleteOnExit for path {}"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/** Check if a path exists.    *    * It is highly discouraged to call this method back to back with other    * {@link #getFileStatus(Path)} calls, as this will involve multiple redundant    * RPC calls in HDFS.    *    * @param f source path    * @return true if the path exists    * @throws IOException IO failure    */
DECL|method|exists (Path f)
specifier|public
name|boolean
name|exists
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|getFileStatus
argument_list|(
name|f
argument_list|)
operator|!=
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/** True iff the named path is a directory.    * Note: Avoid using this method. Instead reuse the FileStatus    * returned by getFileStatus() or listStatus() methods.    *    * @param f path to check    * @throws IOException IO failure    * @deprecated Use {@link #getFileStatus(Path)} instead    */
annotation|@
name|Deprecated
DECL|method|isDirectory (Path f)
specifier|public
name|boolean
name|isDirectory
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|getFileStatus
argument_list|(
name|f
argument_list|)
operator|.
name|isDirectory
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
comment|// f does not exist
block|}
block|}
comment|/** True iff the named path is a regular file.    * Note: Avoid using this method. Instead reuse the FileStatus    * returned by {@link #getFileStatus(Path)} or listStatus() methods.    *    * @param f path to check    * @throws IOException IO failure    * @deprecated Use {@link #getFileStatus(Path)} instead    */
annotation|@
name|Deprecated
DECL|method|isFile (Path f)
specifier|public
name|boolean
name|isFile
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
return|return
name|getFileStatus
argument_list|(
name|f
argument_list|)
operator|.
name|isFile
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
comment|// f does not exist
block|}
block|}
comment|/**    * The number of bytes in a file.    * @return the number of bytes; 0 for a directory    * @deprecated Use {@link #getFileStatus(Path)} instead.    * @throws FileNotFoundException if the path does not resolve    * @throws IOException IO failure    */
annotation|@
name|Deprecated
DECL|method|getLength (Path f)
specifier|public
name|long
name|getLength
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getFileStatus
argument_list|(
name|f
argument_list|)
operator|.
name|getLen
argument_list|()
return|;
block|}
comment|/** Return the {@link ContentSummary} of a given {@link Path}.    * @param f path to use    * @throws FileNotFoundException if the path does not resolve    * @throws IOException IO failure    */
DECL|method|getContentSummary (Path f)
specifier|public
name|ContentSummary
name|getContentSummary
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
name|FileStatus
name|status
init|=
name|getFileStatus
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|.
name|isFile
argument_list|()
condition|)
block|{
comment|// f is a file
name|long
name|length
init|=
name|status
operator|.
name|getLen
argument_list|()
decl_stmt|;
return|return
operator|new
name|ContentSummary
operator|.
name|Builder
argument_list|()
operator|.
name|length
argument_list|(
name|length
argument_list|)
operator|.
name|fileCount
argument_list|(
literal|1
argument_list|)
operator|.
name|directoryCount
argument_list|(
literal|0
argument_list|)
operator|.
name|spaceConsumed
argument_list|(
name|length
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|// f is a directory
name|long
index|[]
name|summary
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
for|for
control|(
name|FileStatus
name|s
range|:
name|listStatus
argument_list|(
name|f
argument_list|)
control|)
block|{
name|long
name|length
init|=
name|s
operator|.
name|getLen
argument_list|()
decl_stmt|;
name|ContentSummary
name|c
init|=
name|s
operator|.
name|isDirectory
argument_list|()
condition|?
name|getContentSummary
argument_list|(
name|s
operator|.
name|getPath
argument_list|()
argument_list|)
else|:
operator|new
name|ContentSummary
operator|.
name|Builder
argument_list|()
operator|.
name|length
argument_list|(
name|length
argument_list|)
operator|.
name|fileCount
argument_list|(
literal|1
argument_list|)
operator|.
name|directoryCount
argument_list|(
literal|0
argument_list|)
operator|.
name|spaceConsumed
argument_list|(
name|length
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|summary
index|[
literal|0
index|]
operator|+=
name|c
operator|.
name|getLength
argument_list|()
expr_stmt|;
name|summary
index|[
literal|1
index|]
operator|+=
name|c
operator|.
name|getFileCount
argument_list|()
expr_stmt|;
name|summary
index|[
literal|2
index|]
operator|+=
name|c
operator|.
name|getDirectoryCount
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|ContentSummary
operator|.
name|Builder
argument_list|()
operator|.
name|length
argument_list|(
name|summary
index|[
literal|0
index|]
argument_list|)
operator|.
name|fileCount
argument_list|(
name|summary
index|[
literal|1
index|]
argument_list|)
operator|.
name|directoryCount
argument_list|(
name|summary
index|[
literal|2
index|]
argument_list|)
operator|.
name|spaceConsumed
argument_list|(
name|summary
index|[
literal|0
index|]
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
comment|/** Return the {@link QuotaUsage} of a given {@link Path}.    * @param f path to use    * @return the quota usage    * @throws IOException IO failure    */
DECL|method|getQuotaUsage (Path f)
specifier|public
name|QuotaUsage
name|getQuotaUsage
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getContentSummary
argument_list|(
name|f
argument_list|)
return|;
block|}
comment|/**    * The default filter accepts all paths.    */
DECL|field|DEFAULT_FILTER
specifier|private
specifier|static
specifier|final
name|PathFilter
name|DEFAULT_FILTER
init|=
operator|new
name|PathFilter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|file
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
decl_stmt|;
comment|/**    * List the statuses of the files/directories in the given path if the path is    * a directory.    *<p>    * Does not guarantee to return the List of files/directories status in a    * sorted order.    *<p>    * Will not return null. Expect IOException upon access error.    * @param f given path    * @return the statuses of the files/directories in the given patch    * @throws FileNotFoundException when the path does not exist    * @throws IOException see specific implementation    */
DECL|method|listStatus (Path f)
specifier|public
specifier|abstract
name|FileStatus
index|[]
name|listStatus
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|IOException
function_decl|;
comment|/**    * Represents a batch of directory entries when iteratively listing a    * directory. This is a private API not meant for use by end users.    *<p>    * For internal use by FileSystem subclasses that override    * {@link FileSystem#listStatusBatch(Path, byte[])} to implement iterative    * listing.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|DirectoryEntries
specifier|public
specifier|static
class|class
name|DirectoryEntries
block|{
DECL|field|entries
specifier|private
specifier|final
name|FileStatus
index|[]
name|entries
decl_stmt|;
DECL|field|token
specifier|private
specifier|final
name|byte
index|[]
name|token
decl_stmt|;
DECL|field|hasMore
specifier|private
specifier|final
name|boolean
name|hasMore
decl_stmt|;
DECL|method|DirectoryEntries (FileStatus[] entries, byte[] token, boolean hasMore)
specifier|public
name|DirectoryEntries
parameter_list|(
name|FileStatus
index|[]
name|entries
parameter_list|,
name|byte
index|[]
name|token
parameter_list|,
name|boolean
name|hasMore
parameter_list|)
block|{
name|this
operator|.
name|entries
operator|=
name|entries
expr_stmt|;
if|if
condition|(
name|token
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|token
operator|=
name|token
operator|.
name|clone
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|token
operator|=
literal|null
expr_stmt|;
block|}
name|this
operator|.
name|hasMore
operator|=
name|hasMore
expr_stmt|;
block|}
DECL|method|getEntries ()
specifier|public
name|FileStatus
index|[]
name|getEntries
parameter_list|()
block|{
return|return
name|entries
return|;
block|}
DECL|method|getToken ()
specifier|public
name|byte
index|[]
name|getToken
parameter_list|()
block|{
return|return
name|token
return|;
block|}
DECL|method|hasMore ()
specifier|public
name|boolean
name|hasMore
parameter_list|()
block|{
return|return
name|hasMore
return|;
block|}
block|}
comment|/**    * Given an opaque iteration token, return the next batch of entries in a    * directory. This is a private API not meant for use by end users.    *<p>    * This method should be overridden by FileSystem subclasses that want to    * use the generic {@link FileSystem#listStatusIterator(Path)} implementation.    * @param f Path to list    * @param token opaque iteration token returned by previous call, or null    *              if this is the first call.    * @return    * @throws FileNotFoundException    * @throws IOException    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|method|listStatusBatch (Path f, byte[] token)
specifier|protected
name|DirectoryEntries
name|listStatusBatch
parameter_list|(
name|Path
name|f
parameter_list|,
name|byte
index|[]
name|token
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|IOException
block|{
comment|// The default implementation returns the entire listing as a single batch.
comment|// Thus, there is never a second batch, and no need to respect the passed
comment|// token or set a token in the returned DirectoryEntries.
name|FileStatus
index|[]
name|listing
init|=
name|listStatus
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|DirectoryEntries
argument_list|(
name|listing
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**    * Filter files/directories in the given path using the user-supplied path    * filter. Results are added to the given array<code>results</code>.    * @throws FileNotFoundException when the path does not exist    * @throws IOException see specific implementation    */
DECL|method|listStatus (ArrayList<FileStatus> results, Path f, PathFilter filter)
specifier|private
name|void
name|listStatus
parameter_list|(
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
name|results
parameter_list|,
name|Path
name|f
parameter_list|,
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|IOException
block|{
name|FileStatus
name|listing
index|[]
init|=
name|listStatus
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|listing
argument_list|,
literal|"listStatus should not return NULL"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|listing
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|filter
operator|.
name|accept
argument_list|(
name|listing
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|)
condition|)
block|{
name|results
operator|.
name|add
argument_list|(
name|listing
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * List corrupted file blocks.    * @return an iterator over the corrupt files under the given path    * (may contain duplicates if a file has more than one corrupt block)    * @throws UnsupportedOperationException if the operation is unsupported    *         (default).    * @throws IOException IO failure    */
DECL|method|listCorruptFileBlocks (Path path)
specifier|public
name|RemoteIterator
argument_list|<
name|Path
argument_list|>
name|listCorruptFileBlocks
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|" does not support listCorruptFileBlocks"
argument_list|)
throw|;
block|}
comment|/**    * Filter files/directories in the given path using the user-supplied path    * filter.    *<p>    * Does not guarantee to return the List of files/directories status in a    * sorted order.    *    * @param f    *          a path name    * @param filter    *          the user-supplied path filter    * @return an array of FileStatus objects for the files under the given path    *         after applying the filter    * @throws FileNotFoundException when the path does not exist    * @throws IOException see specific implementation    */
DECL|method|listStatus (Path f, PathFilter filter)
specifier|public
name|FileStatus
index|[]
name|listStatus
parameter_list|(
name|Path
name|f
parameter_list|,
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|IOException
block|{
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|listStatus
argument_list|(
name|results
argument_list|,
name|f
argument_list|,
name|filter
argument_list|)
expr_stmt|;
return|return
name|results
operator|.
name|toArray
argument_list|(
operator|new
name|FileStatus
index|[
name|results
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    * Filter files/directories in the given list of paths using default    * path filter.    *<p>    * Does not guarantee to return the List of files/directories status in a    * sorted order.    *    * @param files    *          a list of paths    * @return a list of statuses for the files under the given paths after    *         applying the filter default Path filter    * @throws FileNotFoundException when the path does not exist    * @throws IOException see specific implementation    */
DECL|method|listStatus (Path[] files)
specifier|public
name|FileStatus
index|[]
name|listStatus
parameter_list|(
name|Path
index|[]
name|files
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|IOException
block|{
return|return
name|listStatus
argument_list|(
name|files
argument_list|,
name|DEFAULT_FILTER
argument_list|)
return|;
block|}
comment|/**    * Filter files/directories in the given list of paths using user-supplied    * path filter.    *<p>    * Does not guarantee to return the List of files/directories status in a    * sorted order.    *    * @param files    *          a list of paths    * @param filter    *          the user-supplied path filter    * @return a list of statuses for the files under the given paths after    *         applying the filter    * @throws FileNotFoundException when the path does not exist    * @throws IOException see specific implementation    */
DECL|method|listStatus (Path[] files, PathFilter filter)
specifier|public
name|FileStatus
index|[]
name|listStatus
parameter_list|(
name|Path
index|[]
name|files
parameter_list|,
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|IOException
block|{
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|files
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|listStatus
argument_list|(
name|results
argument_list|,
name|files
index|[
name|i
index|]
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
return|return
name|results
operator|.
name|toArray
argument_list|(
operator|new
name|FileStatus
index|[
name|results
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**    *<p>Return all the files that match filePattern and are not checksum    * files. Results are sorted by their names.    *    *<p>    * A filename pattern is composed of<i>regular</i> characters and    *<i>special pattern matching</i> characters, which are:    *    *<dl>    *<dd>    *<dl>    *<p>    *<dt><tt> ?</tt>    *<dd> Matches any single character.    *    *<p>    *<dt><tt> *</tt>    *<dd> Matches zero or more characters.    *    *<p>    *<dt><tt> [<i>abc</i>]</tt>    *<dd> Matches a single character from character set    *<tt>{<i>a,b,c</i>}</tt>.    *    *<p>    *<dt><tt> [<i>a</i>-<i>b</i>]</tt>    *<dd> Matches a single character from the character range    *<tt>{<i>a...b</i>}</tt>.  Note that character<tt><i>a</i></tt> must be    *     lexicographically less than or equal to character<tt><i>b</i></tt>.    *    *<p>    *<dt><tt> [^<i>a</i>]</tt>    *<dd> Matches a single character that is not from character set or range    *<tt>{<i>a</i>}</tt>.  Note that the<tt>^</tt> character must occur    *     immediately to the right of the opening bracket.    *    *<p>    *<dt><tt> \<i>c</i></tt>    *<dd> Removes (escapes) any special meaning of character<i>c</i>.    *    *<p>    *<dt><tt> {ab,cd}</tt>    *<dd> Matches a string from the string set<tt>{<i>ab, cd</i>}</tt>    *    *<p>    *<dt><tt> {ab,c{de,fh}}</tt>    *<dd> Matches a string from the string set<tt>{<i>ab, cde, cfh</i>}</tt>    *    *</dl>    *</dd>    *</dl>    *    * @param pathPattern a regular expression specifying a pth pattern     * @return an array of paths that match the path pattern    * @throws IOException IO failure    */
DECL|method|globStatus (Path pathPattern)
specifier|public
name|FileStatus
index|[]
name|globStatus
parameter_list|(
name|Path
name|pathPattern
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|Globber
argument_list|(
name|this
argument_list|,
name|pathPattern
argument_list|,
name|DEFAULT_FILTER
argument_list|)
operator|.
name|glob
argument_list|()
return|;
block|}
comment|/**    * Return an array of {@link FileStatus} objects whose path names match    * {@code pathPattern} and is accepted by the user-supplied path filter.    * Results are sorted by their path names.    *    * @param pathPattern a regular expression specifying the path pattern    * @param filter a user-supplied path filter    * @return null if {@code pathPattern} has no glob and the path does not exist    *         an empty array if {@code pathPattern} has a glob and no path    *         matches it else an array of {@link FileStatus} objects matching the    *         pattern    * @throws IOException if any I/O error occurs when fetching file status    */
DECL|method|globStatus (Path pathPattern, PathFilter filter)
specifier|public
name|FileStatus
index|[]
name|globStatus
parameter_list|(
name|Path
name|pathPattern
parameter_list|,
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|Globber
argument_list|(
name|this
argument_list|,
name|pathPattern
argument_list|,
name|filter
argument_list|)
operator|.
name|glob
argument_list|()
return|;
block|}
comment|/**    * List the statuses of the files/directories in the given path if the path is    * a directory.    * Return the file's status and block locations If the path is a file.    *    * If a returned status is a file, it contains the file's block locations.    *    * @param f is the path    *    * @return an iterator that traverses statuses of the files/directories    *         in the given path    *    * @throws FileNotFoundException If<code>f</code> does not exist    * @throws IOException If an I/O error occurred    */
DECL|method|listLocatedStatus (final Path f)
specifier|public
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|listLocatedStatus
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|IOException
block|{
return|return
name|listLocatedStatus
argument_list|(
name|f
argument_list|,
name|DEFAULT_FILTER
argument_list|)
return|;
block|}
comment|/**    * List a directory.    * The returned results include its block location if it is a file    * The results are filtered by the given path filter    * @param f a path    * @param filter a path filter    * @return an iterator that traverses statuses of the files/directories    *         in the given path    * @throws FileNotFoundException if<code>f</code> does not exist    * @throws IOException if any I/O error occurred    */
DECL|method|listLocatedStatus (final Path f, final PathFilter filter)
specifier|protected
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|listLocatedStatus
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|IOException
block|{
return|return
operator|new
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
argument_list|()
block|{
specifier|private
specifier|final
name|FileStatus
index|[]
name|stats
init|=
name|listStatus
argument_list|(
name|f
argument_list|,
name|filter
argument_list|)
decl_stmt|;
specifier|private
name|int
name|i
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|i
operator|<
name|stats
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|LocatedFileStatus
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|(
literal|"No more entries in "
operator|+
name|f
argument_list|)
throw|;
block|}
name|FileStatus
name|result
init|=
name|stats
index|[
name|i
operator|++
index|]
decl_stmt|;
comment|// for files, use getBlockLocations(FileStatus, int, int) to avoid
comment|// calling getFileStatus(Path) to load the FileStatus again
name|BlockLocation
index|[]
name|locs
init|=
name|result
operator|.
name|isFile
argument_list|()
condition|?
name|getFileBlockLocations
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
name|result
operator|.
name|getLen
argument_list|()
argument_list|)
else|:
literal|null
decl_stmt|;
return|return
operator|new
name|LocatedFileStatus
argument_list|(
name|result
argument_list|,
name|locs
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/**    * Generic iterator for implementing {@link #listStatusIterator(Path)}.    */
DECL|class|DirListingIterator
specifier|private
class|class
name|DirListingIterator
parameter_list|<
name|T
extends|extends
name|FileStatus
parameter_list|>
implements|implements
name|RemoteIterator
argument_list|<
name|T
argument_list|>
block|{
DECL|field|path
specifier|private
specifier|final
name|Path
name|path
decl_stmt|;
DECL|field|entries
specifier|private
name|DirectoryEntries
name|entries
decl_stmt|;
DECL|field|i
specifier|private
name|int
name|i
init|=
literal|0
decl_stmt|;
DECL|method|DirListingIterator (Path path)
name|DirListingIterator
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasNext ()
specifier|public
name|boolean
name|hasNext
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|entries
operator|==
literal|null
condition|)
block|{
name|fetchMore
argument_list|()
expr_stmt|;
block|}
return|return
name|i
operator|<
name|entries
operator|.
name|getEntries
argument_list|()
operator|.
name|length
operator|||
name|entries
operator|.
name|hasMore
argument_list|()
return|;
block|}
DECL|method|fetchMore ()
specifier|private
name|void
name|fetchMore
parameter_list|()
throws|throws
name|IOException
block|{
name|byte
index|[]
name|token
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|entries
operator|!=
literal|null
condition|)
block|{
name|token
operator|=
name|entries
operator|.
name|getToken
argument_list|()
expr_stmt|;
block|}
name|entries
operator|=
name|listStatusBatch
argument_list|(
name|path
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|next ()
specifier|public
name|T
name|next
parameter_list|()
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|hasNext
argument_list|()
argument_list|,
literal|"No more items in iterator"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|entries
operator|.
name|getEntries
argument_list|()
operator|.
name|length
condition|)
block|{
name|fetchMore
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|T
operator|)
name|entries
operator|.
name|getEntries
argument_list|()
index|[
name|i
operator|++
index|]
return|;
block|}
block|}
comment|/**    * Returns a remote iterator so that followup calls are made on demand    * while consuming the entries. Each FileSystem implementation should    * override this method and provide a more efficient implementation, if    * possible.    *    * Does not guarantee to return the iterator that traverses statuses    * of the files in a sorted order.    *    * @param p target path    * @return remote iterator    * @throws FileNotFoundException if<code>p</code> does not exist    * @throws IOException if any I/O error occurred    */
DECL|method|listStatusIterator (final Path p)
specifier|public
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|listStatusIterator
parameter_list|(
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|IOException
block|{
return|return
operator|new
name|DirListingIterator
argument_list|<>
argument_list|(
name|p
argument_list|)
return|;
block|}
comment|/**    * List the statuses and block locations of the files in the given path.    * Does not guarantee to return the iterator that traverses statuses    * of the files in a sorted order.    *<pre>    * If the path is a directory,    *   if recursive is false, returns files in the directory;    *   if recursive is true, return files in the subtree rooted at the path.    * If the path is a file, return the file's status and block locations.    *</pre>    * @param f is the path    * @param recursive if the subdirectories need to be traversed recursively    *    * @return an iterator that traverses statuses of the files    *    * @throws FileNotFoundException when the path does not exist;    * @throws IOException see specific implementation    */
DECL|method|listFiles ( final Path f, final boolean recursive)
specifier|public
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|listFiles
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|boolean
name|recursive
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|IOException
block|{
return|return
operator|new
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
argument_list|()
block|{
specifier|private
name|Stack
argument_list|<
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
argument_list|>
name|itors
init|=
operator|new
name|Stack
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|curItor
init|=
name|listLocatedStatus
argument_list|(
name|f
argument_list|)
decl_stmt|;
specifier|private
name|LocatedFileStatus
name|curFile
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
throws|throws
name|IOException
block|{
while|while
condition|(
name|curFile
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|curItor
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|handleFileStat
argument_list|(
name|curItor
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|itors
operator|.
name|empty
argument_list|()
condition|)
block|{
name|curItor
operator|=
name|itors
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**        * Process the input stat.        * If it is a file, return the file stat.        * If it is a directory, traverse the directory if recursive is true;        * ignore it if recursive is false.        * @param stat input status        * @throws IOException if any IO error occurs        */
specifier|private
name|void
name|handleFileStat
parameter_list|(
name|LocatedFileStatus
name|stat
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|stat
operator|.
name|isFile
argument_list|()
condition|)
block|{
comment|// file
name|curFile
operator|=
name|stat
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|recursive
condition|)
block|{
comment|// directory
name|itors
operator|.
name|push
argument_list|(
name|curItor
argument_list|)
expr_stmt|;
name|curItor
operator|=
name|listLocatedStatus
argument_list|(
name|stat
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|LocatedFileStatus
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|hasNext
argument_list|()
condition|)
block|{
name|LocatedFileStatus
name|result
init|=
name|curFile
decl_stmt|;
name|curFile
operator|=
literal|null
expr_stmt|;
return|return
name|result
return|;
block|}
throw|throw
operator|new
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
argument_list|(
literal|"No more entry in "
operator|+
name|f
argument_list|)
throw|;
block|}
block|}
return|;
block|}
comment|/** Return the current user's home directory in this FileSystem.    * The default implementation returns {@code "/user/$USER/"}.    */
DECL|method|getHomeDirectory ()
specifier|public
name|Path
name|getHomeDirectory
parameter_list|()
block|{
return|return
name|this
operator|.
name|makeQualified
argument_list|(
operator|new
name|Path
argument_list|(
name|USER_HOME_PREFIX
operator|+
literal|"/"
operator|+
name|System
operator|.
name|getProperty
argument_list|(
literal|"user.name"
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Set the current working directory for the given FileSystem. All relative    * paths will be resolved relative to it.    *    * @param new_dir Path of new working directory    */
DECL|method|setWorkingDirectory (Path new_dir)
specifier|public
specifier|abstract
name|void
name|setWorkingDirectory
parameter_list|(
name|Path
name|new_dir
parameter_list|)
function_decl|;
comment|/**    * Get the current working directory for the given FileSystem    * @return the directory pathname    */
DECL|method|getWorkingDirectory ()
specifier|public
specifier|abstract
name|Path
name|getWorkingDirectory
parameter_list|()
function_decl|;
comment|/**    * Note: with the new FileContext class, getWorkingDirectory()    * will be removed.    * The working directory is implemented in FileContext.    *    * Some FileSystems like LocalFileSystem have an initial workingDir    * that we use as the starting workingDir. For other file systems    * like HDFS there is no built in notion of an initial workingDir.    *    * @return if there is built in notion of workingDir then it    * is returned; else a null is returned.    */
DECL|method|getInitialWorkingDirectory ()
specifier|protected
name|Path
name|getInitialWorkingDirectory
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
comment|/**    * Call {@link #mkdirs(Path, FsPermission)} with default permission.    * @param f path    * @return true if the directory was created    * @throws IOException IO failure    */
DECL|method|mkdirs (Path f)
specifier|public
name|boolean
name|mkdirs
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|mkdirs
argument_list|(
name|f
argument_list|,
name|FsPermission
operator|.
name|getDirDefault
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Make the given file and all non-existent parents into    * directories. Has roughly the semantics of Unix @{code mkdir -p}.    * Existence of the directory hierarchy is not an error.    * @param f path to create    * @param permission to apply to f    * @throws IOException IO failure    */
DECL|method|mkdirs (Path f, FsPermission permission )
specifier|public
specifier|abstract
name|boolean
name|mkdirs
parameter_list|(
name|Path
name|f
parameter_list|,
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * The src file is on the local disk.  Add it to filesystem at    * the given dst name and the source is kept intact afterwards    * @param src path    * @param dst path    * @throws IOException IO failure    */
DECL|method|copyFromLocalFile (Path src, Path dst)
specifier|public
name|void
name|copyFromLocalFile
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
name|copyFromLocalFile
argument_list|(
literal|false
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
comment|/**    * The src files is on the local disk.  Add it to filesystem at    * the given dst name, removing the source afterwards.    * @param srcs source paths    * @param dst path    * @throws IOException IO failure    */
DECL|method|moveFromLocalFile (Path[] srcs, Path dst)
specifier|public
name|void
name|moveFromLocalFile
parameter_list|(
name|Path
index|[]
name|srcs
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
name|copyFromLocalFile
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|,
name|srcs
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
comment|/**    * The src file is on the local disk.  Add it to the filesystem at    * the given dst name, removing the source afterwards.    * @param src local path    * @param dst path    * @throws IOException IO failure    */
DECL|method|moveFromLocalFile (Path src, Path dst)
specifier|public
name|void
name|moveFromLocalFile
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
name|copyFromLocalFile
argument_list|(
literal|true
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
comment|/**    * The src file is on the local disk.  Add it to the filesystem at    * the given dst name.    * delSrc indicates if the source should be removed    * @param delSrc whether to delete the src    * @param src path    * @param dst path    */
DECL|method|copyFromLocalFile (boolean delSrc, Path src, Path dst)
specifier|public
name|void
name|copyFromLocalFile
parameter_list|(
name|boolean
name|delSrc
parameter_list|,
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
name|copyFromLocalFile
argument_list|(
name|delSrc
argument_list|,
literal|true
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
comment|/**    * The src files are on the local disk.  Add it to the filesystem at    * the given dst name.    * delSrc indicates if the source should be removed    * @param delSrc whether to delete the src    * @param overwrite whether to overwrite an existing file    * @param srcs array of paths which are source    * @param dst path    * @throws IOException IO failure    */
DECL|method|copyFromLocalFile (boolean delSrc, boolean overwrite, Path[] srcs, Path dst)
specifier|public
name|void
name|copyFromLocalFile
parameter_list|(
name|boolean
name|delSrc
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|Path
index|[]
name|srcs
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|FileUtil
operator|.
name|copy
argument_list|(
name|getLocal
argument_list|(
name|conf
argument_list|)
argument_list|,
name|srcs
argument_list|,
name|this
argument_list|,
name|dst
argument_list|,
name|delSrc
argument_list|,
name|overwrite
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * The src file is on the local disk.  Add it to the filesystem at    * the given dst name.    * delSrc indicates if the source should be removed    * @param delSrc whether to delete the src    * @param overwrite whether to overwrite an existing file    * @param src path    * @param dst path    * @throws IOException IO failure    */
DECL|method|copyFromLocalFile (boolean delSrc, boolean overwrite, Path src, Path dst)
specifier|public
name|void
name|copyFromLocalFile
parameter_list|(
name|boolean
name|delSrc
parameter_list|,
name|boolean
name|overwrite
parameter_list|,
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|FileUtil
operator|.
name|copy
argument_list|(
name|getLocal
argument_list|(
name|conf
argument_list|)
argument_list|,
name|src
argument_list|,
name|this
argument_list|,
name|dst
argument_list|,
name|delSrc
argument_list|,
name|overwrite
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Copy it a file from the remote filesystem to the local one.    * @param src path src file in the remote filesystem    * @param dst path local destination    * @throws IOException IO failure    */
DECL|method|copyToLocalFile (Path src, Path dst)
specifier|public
name|void
name|copyToLocalFile
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
name|copyToLocalFile
argument_list|(
literal|false
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
comment|/**    * Copy a file to the local filesystem, then delete it from the    * remote filesystem (if successfully copied).    * @param src path src file in the remote filesystem    * @param dst path local destination    * @throws IOException IO failure    */
DECL|method|moveToLocalFile (Path src, Path dst)
specifier|public
name|void
name|moveToLocalFile
parameter_list|(
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
name|copyToLocalFile
argument_list|(
literal|true
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
comment|/**    * Copy it a file from a remote filesystem to the local one.    * delSrc indicates if the src will be removed or not.    * @param delSrc whether to delete the src    * @param src path src file in the remote filesystem    * @param dst path local destination    * @throws IOException IO failure    */
DECL|method|copyToLocalFile (boolean delSrc, Path src, Path dst)
specifier|public
name|void
name|copyToLocalFile
parameter_list|(
name|boolean
name|delSrc
parameter_list|,
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
name|copyToLocalFile
argument_list|(
name|delSrc
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**    * The src file is under this filesystem, and the dst is on the local disk.    * Copy it from the remote filesystem to the local dst name.    * delSrc indicates if the src will be removed    * or not. useRawLocalFileSystem indicates whether to use RawLocalFileSystem    * as the local file system or not. RawLocalFileSystem is non checksumming,    * So, It will not create any crc files at local.    *    * @param delSrc    *          whether to delete the src    * @param src    *          path    * @param dst    *          path    * @param useRawLocalFileSystem    *          whether to use RawLocalFileSystem as local file system or not.    *    * @throws IOException for any IO error    */
DECL|method|copyToLocalFile (boolean delSrc, Path src, Path dst, boolean useRawLocalFileSystem)
specifier|public
name|void
name|copyToLocalFile
parameter_list|(
name|boolean
name|delSrc
parameter_list|,
name|Path
name|src
parameter_list|,
name|Path
name|dst
parameter_list|,
name|boolean
name|useRawLocalFileSystem
parameter_list|)
throws|throws
name|IOException
block|{
name|Configuration
name|conf
init|=
name|getConf
argument_list|()
decl_stmt|;
name|FileSystem
name|local
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|useRawLocalFileSystem
condition|)
block|{
name|local
operator|=
name|getLocal
argument_list|(
name|conf
argument_list|)
operator|.
name|getRawFileSystem
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|local
operator|=
name|getLocal
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
name|FileUtil
operator|.
name|copy
argument_list|(
name|this
argument_list|,
name|src
argument_list|,
name|local
argument_list|,
name|dst
argument_list|,
name|delSrc
argument_list|,
name|conf
argument_list|)
expr_stmt|;
block|}
comment|/**    * Returns a local file that the user can write output to.  The caller    * provides both the eventual target name in this FileSystem    * and the local working file path.    * If this FileSystem is local, we write directly into the target.  If    * the FileSystem is not local, we write into the tmp local area.    * @param fsOutputFile path of output file    * @param tmpLocalFile path of local tmp file    * @throws IOException IO failure    */
DECL|method|startLocalOutput (Path fsOutputFile, Path tmpLocalFile)
specifier|public
name|Path
name|startLocalOutput
parameter_list|(
name|Path
name|fsOutputFile
parameter_list|,
name|Path
name|tmpLocalFile
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|tmpLocalFile
return|;
block|}
comment|/**    * Called when we're all done writing to the target.    * A local FS will do nothing, because we've written to exactly the    * right place.    * A remote FS will copy the contents of tmpLocalFile to the correct target at    * fsOutputFile.    * @param fsOutputFile path of output file    * @param tmpLocalFile path to local tmp file    * @throws IOException IO failure    */
DECL|method|completeLocalOutput (Path fsOutputFile, Path tmpLocalFile)
specifier|public
name|void
name|completeLocalOutput
parameter_list|(
name|Path
name|fsOutputFile
parameter_list|,
name|Path
name|tmpLocalFile
parameter_list|)
throws|throws
name|IOException
block|{
name|moveFromLocalFile
argument_list|(
name|tmpLocalFile
argument_list|,
name|fsOutputFile
argument_list|)
expr_stmt|;
block|}
comment|/**    * Close this FileSystem instance.    * Will release any held locks, delete all files queued for deletion    * through calls to {@link #deleteOnExit(Path)}, and remove this FS instance    * from the cache, if cached.    *    * After this operation, the outcome of any method call on this FileSystem    * instance, or any input/output stream created by it is<i>undefined</i>.    * @throws IOException IO failure    */
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
comment|// delete all files that were marked as delete-on-exit.
name|processDeleteOnExit
argument_list|()
expr_stmt|;
name|CACHE
operator|.
name|remove
argument_list|(
name|this
operator|.
name|key
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return the total size of all files in the filesystem.    * @throws IOException IO failure    */
DECL|method|getUsed ()
specifier|public
name|long
name|getUsed
parameter_list|()
throws|throws
name|IOException
block|{
name|Path
name|path
init|=
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
return|return
name|getUsed
argument_list|(
name|path
argument_list|)
return|;
block|}
comment|/**    * Return the total size of all files from a specified path.    * @throws IOException IO failure    */
DECL|method|getUsed (Path path)
specifier|public
name|long
name|getUsed
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getContentSummary
argument_list|(
name|path
argument_list|)
operator|.
name|getLength
argument_list|()
return|;
block|}
comment|/**    * Get the block size for a particular file.    * @param f the filename    * @return the number of bytes in a block    * @deprecated Use {@link #getFileStatus(Path)} instead    * @throws FileNotFoundException if the path is not present    * @throws IOException IO failure    */
annotation|@
name|Deprecated
DECL|method|getBlockSize (Path f)
specifier|public
name|long
name|getBlockSize
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getFileStatus
argument_list|(
name|f
argument_list|)
operator|.
name|getBlockSize
argument_list|()
return|;
block|}
comment|/**    * Return the number of bytes that large input files should be optimally    * be split into to minimize I/O time.    * @deprecated use {@link #getDefaultBlockSize(Path)} instead    */
annotation|@
name|Deprecated
DECL|method|getDefaultBlockSize ()
specifier|public
name|long
name|getDefaultBlockSize
parameter_list|()
block|{
comment|// default to 32MB: large enough to minimize the impact of seeks
return|return
name|getConf
argument_list|()
operator|.
name|getLong
argument_list|(
literal|"fs.local.block.size"
argument_list|,
literal|32
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
return|;
block|}
comment|/**    * Return the number of bytes that large input files should be optimally    * be split into to minimize I/O time.  The given path will be used to    * locate the actual filesystem.  The full path does not have to exist.    * @param f path of file    * @return the default block size for the path's filesystem    */
DECL|method|getDefaultBlockSize (Path f)
specifier|public
name|long
name|getDefaultBlockSize
parameter_list|(
name|Path
name|f
parameter_list|)
block|{
return|return
name|getDefaultBlockSize
argument_list|()
return|;
block|}
comment|/**    * Get the default replication.    * @return the replication; the default value is "1".    * @deprecated use {@link #getDefaultReplication(Path)} instead    */
annotation|@
name|Deprecated
DECL|method|getDefaultReplication ()
specifier|public
name|short
name|getDefaultReplication
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
comment|/**    * Get the default replication for a path.    * The given path will be used to locate the actual FileSystem to query.    * The full path does not have to exist.    * @param path of the file    * @return default replication for the path's filesystem    */
DECL|method|getDefaultReplication (Path path)
specifier|public
name|short
name|getDefaultReplication
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
return|return
name|getDefaultReplication
argument_list|()
return|;
block|}
comment|/**    * Return a file status object that represents the path.    * @param f The path we want information from    * @return a FileStatus object    * @throws FileNotFoundException when the path does not exist    * @throws IOException see specific implementation    */
DECL|method|getFileStatus (Path f)
specifier|public
specifier|abstract
name|FileStatus
name|getFileStatus
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**    * Checks if the user can access a path.  The mode specifies which access    * checks to perform.  If the requested permissions are granted, then the    * method returns normally.  If access is denied, then the method throws an    * {@link AccessControlException}.    *<p>    * The default implementation calls {@link #getFileStatus(Path)}    * and checks the returned permissions against the requested permissions.    *    * Note that the {@link #getFileStatus(Path)} call will be subject to    * authorization checks.    * Typically, this requires search (execute) permissions on each directory in    * the path's prefix, but this is implementation-defined.  Any file system    * that provides a richer authorization model (such as ACLs) may override the    * default implementation so that it checks against that model instead.    *<p>    * In general, applications should avoid using this method, due to the risk of    * time-of-check/time-of-use race conditions.  The permissions on a file may    * change immediately after the access call returns.  Most applications should    * prefer running specific file system actions as the desired user represented    * by a {@link UserGroupInformation}.    *    * @param path Path to check    * @param mode type of access to check    * @throws AccessControlException if access is denied    * @throws FileNotFoundException if the path does not exist    * @throws IOException see specific implementation    */
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|,
literal|"Hive"
block|}
argument_list|)
DECL|method|access (Path path, FsAction mode)
specifier|public
name|void
name|access
parameter_list|(
name|Path
name|path
parameter_list|,
name|FsAction
name|mode
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|IOException
block|{
name|checkAccessPermissions
argument_list|(
name|this
operator|.
name|getFileStatus
argument_list|(
name|path
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/**    * This method provides the default implementation of    * {@link #access(Path, FsAction)}.    *    * @param stat FileStatus to check    * @param mode type of access to check    * @throws AccessControlException if access is denied    * @throws IOException for any error    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|method|checkAccessPermissions (FileStatus stat, FsAction mode)
specifier|static
name|void
name|checkAccessPermissions
parameter_list|(
name|FileStatus
name|stat
parameter_list|,
name|FsAction
name|mode
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|IOException
block|{
name|FsPermission
name|perm
init|=
name|stat
operator|.
name|getPermission
argument_list|()
decl_stmt|;
name|UserGroupInformation
name|ugi
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
decl_stmt|;
name|String
name|user
init|=
name|ugi
operator|.
name|getShortUserName
argument_list|()
decl_stmt|;
if|if
condition|(
name|user
operator|.
name|equals
argument_list|(
name|stat
operator|.
name|getOwner
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|perm
operator|.
name|getUserAction
argument_list|()
operator|.
name|implies
argument_list|(
name|mode
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|ugi
operator|.
name|getGroups
argument_list|()
operator|.
name|contains
argument_list|(
name|stat
operator|.
name|getGroup
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|perm
operator|.
name|getGroupAction
argument_list|()
operator|.
name|implies
argument_list|(
name|mode
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
name|perm
operator|.
name|getOtherAction
argument_list|()
operator|.
name|implies
argument_list|(
name|mode
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
throw|throw
operator|new
name|AccessControlException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Permission denied: user=%s, path=\"%s\":%s:%s:%s%s"
argument_list|,
name|user
argument_list|,
name|stat
operator|.
name|getPath
argument_list|()
argument_list|,
name|stat
operator|.
name|getOwner
argument_list|()
argument_list|,
name|stat
operator|.
name|getGroup
argument_list|()
argument_list|,
name|stat
operator|.
name|isDirectory
argument_list|()
condition|?
literal|"d"
else|:
literal|"-"
argument_list|,
name|perm
argument_list|)
argument_list|)
throw|;
block|}
comment|/**    * See {@link FileContext#fixRelativePart}.    */
DECL|method|fixRelativePart (Path p)
specifier|protected
name|Path
name|fixRelativePart
parameter_list|(
name|Path
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|.
name|isUriPathAbsolute
argument_list|()
condition|)
block|{
return|return
name|p
return|;
block|}
else|else
block|{
return|return
operator|new
name|Path
argument_list|(
name|getWorkingDirectory
argument_list|()
argument_list|,
name|p
argument_list|)
return|;
block|}
block|}
comment|/**    * See {@link FileContext#createSymlink(Path, Path, boolean)}.    */
DECL|method|createSymlink (final Path target, final Path link, final boolean createParent)
specifier|public
name|void
name|createSymlink
parameter_list|(
specifier|final
name|Path
name|target
parameter_list|,
specifier|final
name|Path
name|link
parameter_list|,
specifier|final
name|boolean
name|createParent
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileAlreadyExistsException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
comment|// Supporting filesystems should override this method
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Filesystem does not support symlinks!"
argument_list|)
throw|;
block|}
comment|/**    * See {@link FileContext#getFileLinkStatus(Path)}.    * @throws FileNotFoundException when the path does not exist    * @throws IOException see specific implementation    */
DECL|method|getFileLinkStatus (final Path f)
specifier|public
name|FileStatus
name|getFileLinkStatus
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
comment|// Supporting filesystems should override this method
return|return
name|getFileStatus
argument_list|(
name|f
argument_list|)
return|;
block|}
comment|/**    * See {@link AbstractFileSystem#supportsSymlinks()}.    */
DECL|method|supportsSymlinks ()
specifier|public
name|boolean
name|supportsSymlinks
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**    * See {@link FileContext#getLinkTarget(Path)}.    * @throws UnsupportedOperationException if the operation is unsupported    *         (default outcome).    */
DECL|method|getLinkTarget (Path f)
specifier|public
name|Path
name|getLinkTarget
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Supporting filesystems should override this method
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Filesystem does not support symlinks!"
argument_list|)
throw|;
block|}
comment|/**    * See {@link AbstractFileSystem#getLinkTarget(Path)}.    * @throws UnsupportedOperationException if the operation is unsupported    *         (default outcome).    */
DECL|method|resolveLink (Path f)
specifier|protected
name|Path
name|resolveLink
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Supporting filesystems should override this method
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Filesystem does not support symlinks!"
argument_list|)
throw|;
block|}
comment|/**    * Get the checksum of a file, if the FS supports checksums.    *    * @param f The file path    * @return The file checksum.  The default return value is null,    *  which indicates that no checksum algorithm is implemented    *  in the corresponding FileSystem.    * @throws IOException IO failure    */
DECL|method|getFileChecksum (Path f)
specifier|public
name|FileChecksum
name|getFileChecksum
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getFileChecksum
argument_list|(
name|f
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
return|;
block|}
comment|/**    * Get the checksum of a file, from the beginning of the file till the    * specific length.    * @param f The file path    * @param length The length of the file range for checksum calculation    * @return The file checksum or null if checksums are not supported.    * @throws IOException IO failure    */
DECL|method|getFileChecksum (Path f, final long length)
specifier|public
name|FileChecksum
name|getFileChecksum
parameter_list|(
name|Path
name|f
parameter_list|,
specifier|final
name|long
name|length
parameter_list|)
throws|throws
name|IOException
block|{
return|return
literal|null
return|;
block|}
comment|/**    * Set the verify checksum flag. This is only applicable if the    * corresponding filesystem supports checksums.    * By default doesn't do anything.    * @param verifyChecksum Verify checksum flag    */
DECL|method|setVerifyChecksum (boolean verifyChecksum)
specifier|public
name|void
name|setVerifyChecksum
parameter_list|(
name|boolean
name|verifyChecksum
parameter_list|)
block|{
comment|//doesn't do anything
block|}
comment|/**    * Set the write checksum flag. This is only applicable if the    * corresponding filesystem supports checksums.    * By default doesn't do anything.    * @param writeChecksum Write checksum flag    */
DECL|method|setWriteChecksum (boolean writeChecksum)
specifier|public
name|void
name|setWriteChecksum
parameter_list|(
name|boolean
name|writeChecksum
parameter_list|)
block|{
comment|//doesn't do anything
block|}
comment|/**    * Returns a status object describing the use and capacity of the    * filesystem. If the filesystem has multiple partitions, the    * use and capacity of the root partition is reflected.    *    * @return a FsStatus object    * @throws IOException    *           see specific implementation    */
DECL|method|getStatus ()
specifier|public
name|FsStatus
name|getStatus
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getStatus
argument_list|(
literal|null
argument_list|)
return|;
block|}
comment|/**    * Returns a status object describing the use and capacity of the    * filesystem. If the filesystem has multiple partitions, the    * use and capacity of the partition pointed to by the specified    * path is reflected.    * @param p Path for which status should be obtained. null means    * the default partition.    * @return a FsStatus object    * @throws IOException    *           see specific implementation    */
DECL|method|getStatus (Path p)
specifier|public
name|FsStatus
name|getStatus
parameter_list|(
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|FsStatus
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|,
literal|0
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
return|;
block|}
comment|/**    * Set permission of a path.    * @param p The path    * @param permission permission    * @throws IOException IO failure    */
DECL|method|setPermission (Path p, FsPermission permission )
specifier|public
name|void
name|setPermission
parameter_list|(
name|Path
name|p
parameter_list|,
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|IOException
block|{   }
comment|/**    * Set owner of a path (i.e. a file or a directory).    * The parameters username and groupname cannot both be null.    * @param p The path    * @param username If it is null, the original username remains unchanged.    * @param groupname If it is null, the original groupname remains unchanged.    * @throws IOException IO failure    */
DECL|method|setOwner (Path p, String username, String groupname )
specifier|public
name|void
name|setOwner
parameter_list|(
name|Path
name|p
parameter_list|,
name|String
name|username
parameter_list|,
name|String
name|groupname
parameter_list|)
throws|throws
name|IOException
block|{   }
comment|/**    * Set access time of a file.    * @param p The path    * @param mtime Set the modification time of this file.    *              The number of milliseconds since Jan 1, 1970.    *              A value of -1 means that this call should not set modification time.    * @param atime Set the access time of this file.    *              The number of milliseconds since Jan 1, 1970.    *              A value of -1 means that this call should not set access time.    * @throws IOException IO failure    */
DECL|method|setTimes (Path p, long mtime, long atime )
specifier|public
name|void
name|setTimes
parameter_list|(
name|Path
name|p
parameter_list|,
name|long
name|mtime
parameter_list|,
name|long
name|atime
parameter_list|)
throws|throws
name|IOException
block|{   }
comment|/**    * Create a snapshot with a default name.    * @param path The directory where snapshots will be taken.    * @return the snapshot path.    * @throws IOException IO failure    * @throws UnsupportedOperationException if the operation is unsupported    */
DECL|method|createSnapshot (Path path)
specifier|public
specifier|final
name|Path
name|createSnapshot
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|createSnapshot
argument_list|(
name|path
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Create a snapshot.    * @param path The directory where snapshots will be taken.    * @param snapshotName The name of the snapshot    * @return the snapshot path.    * @throws IOException IO failure    * @throws UnsupportedOperationException if the operation is unsupported    */
DECL|method|createSnapshot (Path path, String snapshotName)
specifier|public
name|Path
name|createSnapshot
parameter_list|(
name|Path
name|path
parameter_list|,
name|String
name|snapshotName
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support createSnapshot"
argument_list|)
throw|;
block|}
comment|/**    * Rename a snapshot.    * @param path The directory path where the snapshot was taken    * @param snapshotOldName Old name of the snapshot    * @param snapshotNewName New name of the snapshot    * @throws IOException IO failure    * @throws UnsupportedOperationException if the operation is unsupported    *         (default outcome).    */
DECL|method|renameSnapshot (Path path, String snapshotOldName, String snapshotNewName)
specifier|public
name|void
name|renameSnapshot
parameter_list|(
name|Path
name|path
parameter_list|,
name|String
name|snapshotOldName
parameter_list|,
name|String
name|snapshotNewName
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support renameSnapshot"
argument_list|)
throw|;
block|}
comment|/**    * Delete a snapshot of a directory.    * @param path  The directory that the to-be-deleted snapshot belongs to    * @param snapshotName The name of the snapshot    * @throws IOException IO failure    * @throws UnsupportedOperationException if the operation is unsupported    *         (default outcome).    */
DECL|method|deleteSnapshot (Path path, String snapshotName)
specifier|public
name|void
name|deleteSnapshot
parameter_list|(
name|Path
name|path
parameter_list|,
name|String
name|snapshotName
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support deleteSnapshot"
argument_list|)
throw|;
block|}
comment|/**    * Modifies ACL entries of files and directories.  This method can add new ACL    * entries or modify the permissions on existing ACL entries.  All existing    * ACL entries that are not specified in this call are retained without    * changes.  (Modifications are merged into the current ACL.)    *    * @param path Path to modify    * @param aclSpec List<AclEntry> describing modifications    * @throws IOException if an ACL could not be modified    * @throws UnsupportedOperationException if the operation is unsupported    *         (default outcome).    */
DECL|method|modifyAclEntries (Path path, List<AclEntry> aclSpec)
specifier|public
name|void
name|modifyAclEntries
parameter_list|(
name|Path
name|path
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support modifyAclEntries"
argument_list|)
throw|;
block|}
comment|/**    * Removes ACL entries from files and directories.  Other ACL entries are    * retained.    *    * @param path Path to modify    * @param aclSpec List describing entries to remove    * @throws IOException if an ACL could not be modified    * @throws UnsupportedOperationException if the operation is unsupported    *         (default outcome).    */
DECL|method|removeAclEntries (Path path, List<AclEntry> aclSpec)
specifier|public
name|void
name|removeAclEntries
parameter_list|(
name|Path
name|path
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support removeAclEntries"
argument_list|)
throw|;
block|}
comment|/**    * Removes all default ACL entries from files and directories.    *    * @param path Path to modify    * @throws IOException if an ACL could not be modified    * @throws UnsupportedOperationException if the operation is unsupported    *         (default outcome).    */
DECL|method|removeDefaultAcl (Path path)
specifier|public
name|void
name|removeDefaultAcl
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support removeDefaultAcl"
argument_list|)
throw|;
block|}
comment|/**    * Removes all but the base ACL entries of files and directories.  The entries    * for user, group, and others are retained for compatibility with permission    * bits.    *    * @param path Path to modify    * @throws IOException if an ACL could not be removed    * @throws UnsupportedOperationException if the operation is unsupported    *         (default outcome).    */
DECL|method|removeAcl (Path path)
specifier|public
name|void
name|removeAcl
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support removeAcl"
argument_list|)
throw|;
block|}
comment|/**    * Fully replaces ACL of files and directories, discarding all existing    * entries.    *    * @param path Path to modify    * @param aclSpec List describing modifications, which must include entries    *   for user, group, and others for compatibility with permission bits.    * @throws IOException if an ACL could not be modified    * @throws UnsupportedOperationException if the operation is unsupported    *         (default outcome).    */
DECL|method|setAcl (Path path, List<AclEntry> aclSpec)
specifier|public
name|void
name|setAcl
parameter_list|(
name|Path
name|path
parameter_list|,
name|List
argument_list|<
name|AclEntry
argument_list|>
name|aclSpec
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support setAcl"
argument_list|)
throw|;
block|}
comment|/**    * Gets the ACL of a file or directory.    *    * @param path Path to get    * @return AclStatus describing the ACL of the file or directory    * @throws IOException if an ACL could not be read    * @throws UnsupportedOperationException if the operation is unsupported    *         (default outcome).    */
DECL|method|getAclStatus (Path path)
specifier|public
name|AclStatus
name|getAclStatus
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support getAclStatus"
argument_list|)
throw|;
block|}
comment|/**    * Set an xattr of a file or directory.    * The name must be prefixed with the namespace followed by ".". For example,    * "user.attr".    *<p>    * Refer to the HDFS extended attributes user documentation for details.    *    * @param path Path to modify    * @param name xattr name.    * @param value xattr value.    * @throws IOException IO failure    * @throws UnsupportedOperationException if the operation is unsupported    *         (default outcome).    */
DECL|method|setXAttr (Path path, String name, byte[] value)
specifier|public
name|void
name|setXAttr
parameter_list|(
name|Path
name|path
parameter_list|,
name|String
name|name
parameter_list|,
name|byte
index|[]
name|value
parameter_list|)
throws|throws
name|IOException
block|{
name|setXAttr
argument_list|(
name|path
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|EnumSet
operator|.
name|of
argument_list|(
name|XAttrSetFlag
operator|.
name|CREATE
argument_list|,
name|XAttrSetFlag
operator|.
name|REPLACE
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set an xattr of a file or directory.    * The name must be prefixed with the namespace followed by ".". For example,    * "user.attr".    *<p>    * Refer to the HDFS extended attributes user documentation for details.    *    * @param path Path to modify    * @param name xattr name.    * @param value xattr value.    * @param flag xattr set flag    * @throws IOException IO failure    * @throws UnsupportedOperationException if the operation is unsupported    *         (default outcome).    */
DECL|method|setXAttr (Path path, String name, byte[] value, EnumSet<XAttrSetFlag> flag)
specifier|public
name|void
name|setXAttr
parameter_list|(
name|Path
name|path
parameter_list|,
name|String
name|name
parameter_list|,
name|byte
index|[]
name|value
parameter_list|,
name|EnumSet
argument_list|<
name|XAttrSetFlag
argument_list|>
name|flag
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support setXAttr"
argument_list|)
throw|;
block|}
comment|/**    * Get an xattr name and value for a file or directory.    * The name must be prefixed with the namespace followed by ".". For example,    * "user.attr".    *<p>    * Refer to the HDFS extended attributes user documentation for details.    *    * @param path Path to get extended attribute    * @param name xattr name.    * @return byte[] xattr value.    * @throws IOException IO failure    * @throws UnsupportedOperationException if the operation is unsupported    *         (default outcome).    */
DECL|method|getXAttr (Path path, String name)
specifier|public
name|byte
index|[]
name|getXAttr
parameter_list|(
name|Path
name|path
parameter_list|,
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support getXAttr"
argument_list|)
throw|;
block|}
comment|/**    * Get all of the xattr name/value pairs for a file or directory.    * Only those xattrs which the logged-in user has permissions to view    * are returned.    *<p>    * Refer to the HDFS extended attributes user documentation for details.    *    * @param path Path to get extended attributes    * @return Map describing the XAttrs of the file or directory    * @throws IOException IO failure    * @throws UnsupportedOperationException if the operation is unsupported    *         (default outcome).    */
DECL|method|getXAttrs (Path path)
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|byte
index|[]
argument_list|>
name|getXAttrs
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support getXAttrs"
argument_list|)
throw|;
block|}
comment|/**    * Get all of the xattrs name/value pairs for a file or directory.    * Only those xattrs which the logged-in user has permissions to view    * are returned.    *<p>    * Refer to the HDFS extended attributes user documentation for details.    *    * @param path Path to get extended attributes    * @param names XAttr names.    * @return Map describing the XAttrs of the file or directory    * @throws IOException IO failure    * @throws UnsupportedOperationException if the operation is unsupported    *         (default outcome).    */
DECL|method|getXAttrs (Path path, List<String> names)
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|byte
index|[]
argument_list|>
name|getXAttrs
parameter_list|(
name|Path
name|path
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|names
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support getXAttrs"
argument_list|)
throw|;
block|}
comment|/**    * Get all of the xattr names for a file or directory.    * Only those xattr names which the logged-in user has permissions to view    * are returned.    *<p>    * Refer to the HDFS extended attributes user documentation for details.    *    * @param path Path to get extended attributes    * @return List<String> of the XAttr names of the file or directory    * @throws IOException IO failure    * @throws UnsupportedOperationException if the operation is unsupported    *         (default outcome).    */
DECL|method|listXAttrs (Path path)
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|listXAttrs
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support listXAttrs"
argument_list|)
throw|;
block|}
comment|/**    * Remove an xattr of a file or directory.    * The name must be prefixed with the namespace followed by ".". For example,    * "user.attr".    *<p>    * Refer to the HDFS extended attributes user documentation for details.    *    * @param path Path to remove extended attribute    * @param name xattr name    * @throws IOException IO failure    * @throws UnsupportedOperationException if the operation is unsupported    *         (default outcome).    */
DECL|method|removeXAttr (Path path, String name)
specifier|public
name|void
name|removeXAttr
parameter_list|(
name|Path
name|path
parameter_list|,
name|String
name|name
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support removeXAttr"
argument_list|)
throw|;
block|}
comment|/**    * Set the storage policy for a given file or directory.    *    * @param src file or directory path.    * @param policyName the name of the target storage policy. The list    *                   of supported Storage policies can be retrieved    *                   via {@link #getAllStoragePolicies}.    * @throws IOException IO failure    * @throws UnsupportedOperationException if the operation is unsupported    *         (default outcome).    */
DECL|method|setStoragePolicy (final Path src, final String policyName)
specifier|public
name|void
name|setStoragePolicy
parameter_list|(
specifier|final
name|Path
name|src
parameter_list|,
specifier|final
name|String
name|policyName
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support setStoragePolicy"
argument_list|)
throw|;
block|}
comment|/**    * Unset the storage policy set for a given file or directory.    * @param src file or directory path.    * @throws IOException IO failure    * @throws UnsupportedOperationException if the operation is unsupported    *         (default outcome).    */
DECL|method|unsetStoragePolicy (final Path src)
specifier|public
name|void
name|unsetStoragePolicy
parameter_list|(
specifier|final
name|Path
name|src
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support unsetStoragePolicy"
argument_list|)
throw|;
block|}
comment|/**    * Query the effective storage policy ID for the given file or directory.    *    * @param src file or directory path.    * @return storage policy for give file.    * @throws IOException IO failure    * @throws UnsupportedOperationException if the operation is unsupported    *         (default outcome).    */
DECL|method|getStoragePolicy (final Path src)
specifier|public
name|BlockStoragePolicySpi
name|getStoragePolicy
parameter_list|(
specifier|final
name|Path
name|src
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support getStoragePolicy"
argument_list|)
throw|;
block|}
comment|/**    * Retrieve all the storage policies supported by this file system.    *    * @return all storage policies supported by this filesystem.    * @throws IOException IO failure    * @throws UnsupportedOperationException if the operation is unsupported    *         (default outcome).    */
DECL|method|getAllStoragePolicies ()
specifier|public
name|Collection
argument_list|<
name|?
extends|extends
name|BlockStoragePolicySpi
argument_list|>
name|getAllStoragePolicies
parameter_list|()
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" doesn't support getAllStoragePolicies"
argument_list|)
throw|;
block|}
comment|/**    * Get the root directory of Trash for current user when the path specified    * is deleted.    *    * @param path the trash root of the path to be determined.    * @return the default implementation returns {@code /user/$USER/.Trash}    */
DECL|method|getTrashRoot (Path path)
specifier|public
name|Path
name|getTrashRoot
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
return|return
name|this
operator|.
name|makeQualified
argument_list|(
operator|new
name|Path
argument_list|(
name|getHomeDirectory
argument_list|()
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|,
name|TRASH_PREFIX
argument_list|)
argument_list|)
return|;
block|}
comment|/**    * Get all the trash roots for current user or all users.    *    * @param allUsers return trash roots for all users if true.    * @return all the trash root directories.    *         Default FileSystem returns .Trash under users' home directories if    *         {@code /user/$USER/.Trash} exists.    */
DECL|method|getTrashRoots (boolean allUsers)
specifier|public
name|Collection
argument_list|<
name|FileStatus
argument_list|>
name|getTrashRoots
parameter_list|(
name|boolean
name|allUsers
parameter_list|)
block|{
name|Path
name|userHome
init|=
operator|new
name|Path
argument_list|(
name|getHomeDirectory
argument_list|()
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|FileStatus
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|allUsers
condition|)
block|{
name|Path
name|userTrash
init|=
operator|new
name|Path
argument_list|(
name|userHome
argument_list|,
name|TRASH_PREFIX
argument_list|)
decl_stmt|;
if|if
condition|(
name|exists
argument_list|(
name|userTrash
argument_list|)
condition|)
block|{
name|ret
operator|.
name|add
argument_list|(
name|getFileStatus
argument_list|(
name|userTrash
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|Path
name|homeParent
init|=
name|userHome
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|exists
argument_list|(
name|homeParent
argument_list|)
condition|)
block|{
name|FileStatus
index|[]
name|candidates
init|=
name|listStatus
argument_list|(
name|homeParent
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|candidate
range|:
name|candidates
control|)
block|{
name|Path
name|userTrash
init|=
operator|new
name|Path
argument_list|(
name|candidate
operator|.
name|getPath
argument_list|()
argument_list|,
name|TRASH_PREFIX
argument_list|)
decl_stmt|;
if|if
condition|(
name|exists
argument_list|(
name|userTrash
argument_list|)
condition|)
block|{
name|candidate
operator|.
name|setPath
argument_list|(
name|userTrash
argument_list|)
expr_stmt|;
name|ret
operator|.
name|add
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"Cannot get all trash roots"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|// making it volatile to be able to do a double checked locking
DECL|field|FILE_SYSTEMS_LOADED
specifier|private
specifier|volatile
specifier|static
name|boolean
name|FILE_SYSTEMS_LOADED
init|=
literal|false
decl_stmt|;
comment|/**    * Filesystems listed as services.    */
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Class
argument_list|<
name|?
extends|extends
name|FileSystem
argument_list|>
argument_list|>
DECL|field|SERVICE_FILE_SYSTEMS
name|SERVICE_FILE_SYSTEMS
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**    * Load the filesystem declarations from service resources.    * This is a synchronized operation.    */
DECL|method|loadFileSystems ()
specifier|private
specifier|static
name|void
name|loadFileSystems
parameter_list|()
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Loading filesystems"
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|FileSystem
operator|.
name|class
init|)
block|{
if|if
condition|(
operator|!
name|FILE_SYSTEMS_LOADED
condition|)
block|{
name|ServiceLoader
argument_list|<
name|FileSystem
argument_list|>
name|serviceLoader
init|=
name|ServiceLoader
operator|.
name|load
argument_list|(
name|FileSystem
operator|.
name|class
argument_list|)
decl_stmt|;
name|Iterator
argument_list|<
name|FileSystem
argument_list|>
name|it
init|=
name|serviceLoader
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|FileSystem
name|fs
decl_stmt|;
try|try
block|{
name|fs
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
try|try
block|{
name|SERVICE_FILE_SYSTEMS
operator|.
name|put
argument_list|(
name|fs
operator|.
name|getScheme
argument_list|()
argument_list|,
name|fs
operator|.
name|getClass
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOGGER
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"{}:// = {} from {}"
argument_list|,
name|fs
operator|.
name|getScheme
argument_list|()
argument_list|,
name|fs
operator|.
name|getClass
argument_list|()
argument_list|,
name|ClassUtil
operator|.
name|findContainingJar
argument_list|(
name|fs
operator|.
name|getClass
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"Cannot load: {} from {}"
argument_list|,
name|fs
argument_list|,
name|ClassUtil
operator|.
name|findContainingJar
argument_list|(
name|fs
operator|.
name|getClass
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|LOGGER
operator|.
name|info
argument_list|(
literal|"Full exception loading: {}"
argument_list|,
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ServiceConfigurationError
name|ee
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Cannot load filesystem: "
operator|+
name|ee
argument_list|)
expr_stmt|;
name|Throwable
name|cause
init|=
name|ee
operator|.
name|getCause
argument_list|()
decl_stmt|;
comment|// print all the nested exception messages
while|while
condition|(
name|cause
operator|!=
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|cause
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|cause
operator|=
name|cause
operator|.
name|getCause
argument_list|()
expr_stmt|;
block|}
comment|// and at debug: the full stack
name|LOG
operator|.
name|debug
argument_list|(
literal|"Stack Trace"
argument_list|,
name|ee
argument_list|)
expr_stmt|;
block|}
block|}
name|FILE_SYSTEMS_LOADED
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Get the FileSystem implementation class of a filesystem.    * This triggers a scan and load of all FileSystem implementations listed as    * services and discovered via the {@link ServiceLoader}    * @param scheme URL scheme of FS    * @param conf configuration: can be null, in which case the check for    * a filesystem binding declaration in the configuration is skipped.    * @return the filesystem    * @throws UnsupportedFileSystemException if there was no known implementation    *         for the scheme.    * @throws IOException if the filesystem could not be loaded    */
DECL|method|getFileSystemClass (String scheme, Configuration conf)
specifier|public
specifier|static
name|Class
argument_list|<
name|?
extends|extends
name|FileSystem
argument_list|>
name|getFileSystemClass
parameter_list|(
name|String
name|scheme
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|FILE_SYSTEMS_LOADED
condition|)
block|{
name|loadFileSystems
argument_list|()
expr_stmt|;
block|}
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Looking for FS supporting {}"
argument_list|,
name|scheme
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|FileSystem
argument_list|>
name|clazz
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|conf
operator|!=
literal|null
condition|)
block|{
name|String
name|property
init|=
literal|"fs."
operator|+
name|scheme
operator|+
literal|".impl"
decl_stmt|;
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"looking for configuration option {}"
argument_list|,
name|property
argument_list|)
expr_stmt|;
name|clazz
operator|=
operator|(
name|Class
argument_list|<
name|?
extends|extends
name|FileSystem
argument_list|>
operator|)
name|conf
operator|.
name|getClass
argument_list|(
name|property
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"No configuration: skipping check for fs.{}.impl"
argument_list|,
name|scheme
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clazz
operator|==
literal|null
condition|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Looking in service filesystems for implementation class"
argument_list|)
expr_stmt|;
name|clazz
operator|=
name|SERVICE_FILE_SYSTEMS
operator|.
name|get
argument_list|(
name|scheme
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Filesystem {} defined in configuration option"
argument_list|,
name|scheme
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clazz
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnsupportedFileSystemException
argument_list|(
literal|"No FileSystem for scheme "
operator|+
literal|"\""
operator|+
name|scheme
operator|+
literal|"\""
argument_list|)
throw|;
block|}
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"FS for {} is {}"
argument_list|,
name|scheme
argument_list|,
name|clazz
argument_list|)
expr_stmt|;
return|return
name|clazz
return|;
block|}
comment|/**    * Create and initialize a new instance of a FileSystem.    * @param uri URI containing the FS schema and FS details    * @param conf configuration to use to look for the FS instance declaration    * and to pass to the {@link FileSystem#initialize(URI, Configuration)}.    * @return the initialized filesystem.    * @throws IOException problems loading or initializing the FileSystem    */
DECL|method|createFileSystem (URI uri, Configuration conf)
specifier|private
specifier|static
name|FileSystem
name|createFileSystem
parameter_list|(
name|URI
name|uri
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|Tracer
name|tracer
init|=
name|FsTracer
operator|.
name|get
argument_list|(
name|conf
argument_list|)
decl_stmt|;
try|try
init|(
name|TraceScope
name|scope
init|=
name|tracer
operator|.
name|newScope
argument_list|(
literal|"FileSystem#createFileSystem"
argument_list|)
init|)
block|{
name|scope
operator|.
name|addKVAnnotation
argument_list|(
literal|"scheme"
argument_list|,
name|uri
operator|.
name|getScheme
argument_list|()
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|getFileSystemClass
argument_list|(
name|uri
operator|.
name|getScheme
argument_list|()
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|FileSystem
name|fs
init|=
operator|(
name|FileSystem
operator|)
name|ReflectionUtils
operator|.
name|newInstance
argument_list|(
name|clazz
argument_list|,
name|conf
argument_list|)
decl_stmt|;
name|fs
operator|.
name|initialize
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
expr_stmt|;
return|return
name|fs
return|;
block|}
block|}
comment|/** Caching FileSystem objects. */
DECL|class|Cache
specifier|static
class|class
name|Cache
block|{
DECL|field|clientFinalizer
specifier|private
specifier|final
name|ClientFinalizer
name|clientFinalizer
init|=
operator|new
name|ClientFinalizer
argument_list|()
decl_stmt|;
DECL|field|map
specifier|private
specifier|final
name|Map
argument_list|<
name|Key
argument_list|,
name|FileSystem
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|toAutoClose
specifier|private
specifier|final
name|Set
argument_list|<
name|Key
argument_list|>
name|toAutoClose
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** A variable that makes all objects in the cache unique. */
DECL|field|unique
specifier|private
specifier|static
name|AtomicLong
name|unique
init|=
operator|new
name|AtomicLong
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|method|get (URI uri, Configuration conf)
name|FileSystem
name|get
parameter_list|(
name|URI
name|uri
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|Key
name|key
init|=
operator|new
name|Key
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
decl_stmt|;
return|return
name|getInternal
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|,
name|key
argument_list|)
return|;
block|}
comment|/** The objects inserted into the cache using this method are all unique. */
DECL|method|getUnique (URI uri, Configuration conf)
name|FileSystem
name|getUnique
parameter_list|(
name|URI
name|uri
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|Key
name|key
init|=
operator|new
name|Key
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|,
name|unique
operator|.
name|getAndIncrement
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|getInternal
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|,
name|key
argument_list|)
return|;
block|}
comment|/**      * Get the FS instance if the key maps to an instance, creating and      * initializing the FS if it is not found.      * If this is the first entry in the map and the JVM is not shutting down,      * this registers a shutdown hook to close filesystems, and adds this      * FS to the {@code toAutoClose} set if {@code "fs.automatic.close"}      * is set in the configuration (default: true).      * @param uri filesystem URI      * @param conf configuration      * @param key key to store/retrieve this FileSystem in the cache      * @return a cached or newly instantiated FileSystem.      * @throws IOException      */
DECL|method|getInternal (URI uri, Configuration conf, Key key)
specifier|private
name|FileSystem
name|getInternal
parameter_list|(
name|URI
name|uri
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|Key
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|FileSystem
name|fs
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|fs
operator|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|!=
literal|null
condition|)
block|{
return|return
name|fs
return|;
block|}
name|fs
operator|=
name|createFileSystem
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// refetch the lock again
name|FileSystem
name|oldfs
init|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldfs
operator|!=
literal|null
condition|)
block|{
comment|// a file system is created while lock is releasing
name|fs
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// close the new file system
return|return
name|oldfs
return|;
comment|// return the old file system
block|}
comment|// now insert the new file system into the map
if|if
condition|(
name|map
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|ShutdownHookManager
operator|.
name|get
argument_list|()
operator|.
name|isShutdownInProgress
argument_list|()
condition|)
block|{
name|ShutdownHookManager
operator|.
name|get
argument_list|()
operator|.
name|addShutdownHook
argument_list|(
name|clientFinalizer
argument_list|,
name|SHUTDOWN_HOOK_PRIORITY
argument_list|)
expr_stmt|;
block|}
name|fs
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|getBoolean
argument_list|(
name|FS_AUTOMATIC_CLOSE_KEY
argument_list|,
name|FS_AUTOMATIC_CLOSE_DEFAULT
argument_list|)
condition|)
block|{
name|toAutoClose
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
return|return
name|fs
return|;
block|}
block|}
DECL|method|remove (Key key, FileSystem fs)
specifier|synchronized
name|void
name|remove
parameter_list|(
name|Key
name|key
parameter_list|,
name|FileSystem
name|fs
parameter_list|)
block|{
name|FileSystem
name|cachedFs
init|=
name|map
operator|.
name|remove
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|==
name|cachedFs
condition|)
block|{
name|toAutoClose
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cachedFs
operator|!=
literal|null
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|cachedFs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Close all FileSystems in the cache, whether they are marked for      * automatic closing or not.      * @throws IOException a problem arose closing one or more FileSystem.      */
DECL|method|closeAll ()
specifier|synchronized
name|void
name|closeAll
parameter_list|()
throws|throws
name|IOException
block|{
name|closeAll
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Close all FileSystem instances in the Cache.      * @param onlyAutomatic only close those that are marked for automatic closing      * @throws IOException a problem arose closing one or more FileSystem.      */
DECL|method|closeAll (boolean onlyAutomatic)
specifier|synchronized
name|void
name|closeAll
parameter_list|(
name|boolean
name|onlyAutomatic
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|IOException
argument_list|>
name|exceptions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Make a copy of the keys in the map since we'll be modifying
comment|// the map while iterating over it, which isn't safe.
name|List
argument_list|<
name|Key
argument_list|>
name|keys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|keys
operator|.
name|addAll
argument_list|(
name|map
operator|.
name|keySet
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Key
name|key
range|:
name|keys
control|)
block|{
specifier|final
name|FileSystem
name|fs
init|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|onlyAutomatic
operator|&&
operator|!
name|toAutoClose
operator|.
name|contains
argument_list|(
name|key
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|//remove from cache
name|map
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|toAutoClose
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|fs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|exceptions
operator|.
name|add
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|exceptions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
name|MultipleIOException
operator|.
name|createIOException
argument_list|(
name|exceptions
argument_list|)
throw|;
block|}
block|}
DECL|class|ClientFinalizer
specifier|private
class|class
name|ClientFinalizer
implements|implements
name|Runnable
block|{
annotation|@
name|Override
DECL|method|run ()
specifier|public
specifier|synchronized
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|closeAll
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOGGER
operator|.
name|info
argument_list|(
literal|"FileSystem.Cache.closeAll() threw an exception:\n"
operator|+
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|closeAll (UserGroupInformation ugi)
specifier|synchronized
name|void
name|closeAll
parameter_list|(
name|UserGroupInformation
name|ugi
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|FileSystem
argument_list|>
name|targetFSList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|//Make a pass over the list and collect the FileSystems to close
comment|//we cannot close inline since close() removes the entry from the Map
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Key
argument_list|,
name|FileSystem
argument_list|>
name|entry
range|:
name|map
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|Key
name|key
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|FileSystem
name|fs
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|ugi
operator|.
name|equals
argument_list|(
name|key
operator|.
name|ugi
argument_list|)
operator|&&
name|fs
operator|!=
literal|null
condition|)
block|{
name|targetFSList
operator|.
name|add
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|IOException
argument_list|>
name|exceptions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|//now make a pass over the target list and close each
for|for
control|(
name|FileSystem
name|fs
range|:
name|targetFSList
control|)
block|{
try|try
block|{
name|fs
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|exceptions
operator|.
name|add
argument_list|(
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|exceptions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
name|MultipleIOException
operator|.
name|createIOException
argument_list|(
name|exceptions
argument_list|)
throw|;
block|}
block|}
comment|/** FileSystem.Cache.Key */
DECL|class|Key
specifier|static
class|class
name|Key
block|{
DECL|field|scheme
specifier|final
name|String
name|scheme
decl_stmt|;
DECL|field|authority
specifier|final
name|String
name|authority
decl_stmt|;
DECL|field|ugi
specifier|final
name|UserGroupInformation
name|ugi
decl_stmt|;
DECL|field|unique
specifier|final
name|long
name|unique
decl_stmt|;
comment|// an artificial way to make a key unique
DECL|method|Key (URI uri, Configuration conf)
name|Key
parameter_list|(
name|URI
name|uri
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|Key (URI uri, Configuration conf, long unique)
name|Key
parameter_list|(
name|URI
name|uri
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|long
name|unique
parameter_list|)
throws|throws
name|IOException
block|{
name|scheme
operator|=
name|uri
operator|.
name|getScheme
argument_list|()
operator|==
literal|null
condition|?
literal|""
else|:
name|StringUtils
operator|.
name|toLowerCase
argument_list|(
name|uri
operator|.
name|getScheme
argument_list|()
argument_list|)
expr_stmt|;
name|authority
operator|=
name|uri
operator|.
name|getAuthority
argument_list|()
operator|==
literal|null
condition|?
literal|""
else|:
name|StringUtils
operator|.
name|toLowerCase
argument_list|(
name|uri
operator|.
name|getAuthority
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|unique
operator|=
name|unique
expr_stmt|;
name|this
operator|.
name|ugi
operator|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
operator|(
name|scheme
operator|+
name|authority
operator|)
operator|.
name|hashCode
argument_list|()
operator|+
name|ugi
operator|.
name|hashCode
argument_list|()
operator|+
operator|(
name|int
operator|)
name|unique
return|;
block|}
DECL|method|isEqual (Object a, Object b)
specifier|static
name|boolean
name|isEqual
parameter_list|(
name|Object
name|a
parameter_list|,
name|Object
name|b
parameter_list|)
block|{
return|return
name|a
operator|==
name|b
operator|||
operator|(
name|a
operator|!=
literal|null
operator|&&
name|a
operator|.
name|equals
argument_list|(
name|b
argument_list|)
operator|)
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object obj)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|obj
operator|instanceof
name|Key
condition|)
block|{
name|Key
name|that
init|=
operator|(
name|Key
operator|)
name|obj
decl_stmt|;
return|return
name|isEqual
argument_list|(
name|this
operator|.
name|scheme
argument_list|,
name|that
operator|.
name|scheme
argument_list|)
operator|&&
name|isEqual
argument_list|(
name|this
operator|.
name|authority
argument_list|,
name|that
operator|.
name|authority
argument_list|)
operator|&&
name|isEqual
argument_list|(
name|this
operator|.
name|ugi
argument_list|,
name|that
operator|.
name|ugi
argument_list|)
operator|&&
operator|(
name|this
operator|.
name|unique
operator|==
name|that
operator|.
name|unique
operator|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"("
operator|+
name|ugi
operator|.
name|toString
argument_list|()
operator|+
literal|")@"
operator|+
name|scheme
operator|+
literal|"://"
operator|+
name|authority
return|;
block|}
block|}
block|}
comment|/**    * Tracks statistics about how many reads, writes, and so forth have been    * done in a FileSystem.    *    * Since there is only one of these objects per FileSystem, there will    * typically be many threads writing to this object.  Almost every operation    * on an open file will involve a write to this object.  In contrast, reading    * statistics is done infrequently by most programs, and not at all by others.    * Hence, this is optimized for writes.    *    * Each thread writes to its own thread-local area of memory.  This removes    * contention and allows us to scale up to many, many threads.  To read    * statistics, the reader thread totals up the contents of all of the    * thread-local data areas.    */
DECL|class|Statistics
specifier|public
specifier|static
specifier|final
class|class
name|Statistics
block|{
comment|/**      * Statistics data.      *      * There is only a single writer to thread-local StatisticsData objects.      * Hence, volatile is adequate here-- we do not need AtomicLong or similar      * to prevent lost updates.      * The Java specification guarantees that updates to volatile longs will      * be perceived as atomic with respect to other threads, which is all we      * need.      */
DECL|class|StatisticsData
specifier|public
specifier|static
class|class
name|StatisticsData
block|{
DECL|field|bytesRead
specifier|private
specifier|volatile
name|long
name|bytesRead
decl_stmt|;
DECL|field|bytesWritten
specifier|private
specifier|volatile
name|long
name|bytesWritten
decl_stmt|;
DECL|field|readOps
specifier|private
specifier|volatile
name|int
name|readOps
decl_stmt|;
DECL|field|largeReadOps
specifier|private
specifier|volatile
name|int
name|largeReadOps
decl_stmt|;
DECL|field|writeOps
specifier|private
specifier|volatile
name|int
name|writeOps
decl_stmt|;
DECL|field|bytesReadLocalHost
specifier|private
specifier|volatile
name|long
name|bytesReadLocalHost
decl_stmt|;
DECL|field|bytesReadDistanceOfOneOrTwo
specifier|private
specifier|volatile
name|long
name|bytesReadDistanceOfOneOrTwo
decl_stmt|;
DECL|field|bytesReadDistanceOfThreeOrFour
specifier|private
specifier|volatile
name|long
name|bytesReadDistanceOfThreeOrFour
decl_stmt|;
DECL|field|bytesReadDistanceOfFiveOrLarger
specifier|private
specifier|volatile
name|long
name|bytesReadDistanceOfFiveOrLarger
decl_stmt|;
comment|/**        * Add another StatisticsData object to this one.        */
DECL|method|add (StatisticsData other)
name|void
name|add
parameter_list|(
name|StatisticsData
name|other
parameter_list|)
block|{
name|this
operator|.
name|bytesRead
operator|+=
name|other
operator|.
name|bytesRead
expr_stmt|;
name|this
operator|.
name|bytesWritten
operator|+=
name|other
operator|.
name|bytesWritten
expr_stmt|;
name|this
operator|.
name|readOps
operator|+=
name|other
operator|.
name|readOps
expr_stmt|;
name|this
operator|.
name|largeReadOps
operator|+=
name|other
operator|.
name|largeReadOps
expr_stmt|;
name|this
operator|.
name|writeOps
operator|+=
name|other
operator|.
name|writeOps
expr_stmt|;
name|this
operator|.
name|bytesReadLocalHost
operator|+=
name|other
operator|.
name|bytesReadLocalHost
expr_stmt|;
name|this
operator|.
name|bytesReadDistanceOfOneOrTwo
operator|+=
name|other
operator|.
name|bytesReadDistanceOfOneOrTwo
expr_stmt|;
name|this
operator|.
name|bytesReadDistanceOfThreeOrFour
operator|+=
name|other
operator|.
name|bytesReadDistanceOfThreeOrFour
expr_stmt|;
name|this
operator|.
name|bytesReadDistanceOfFiveOrLarger
operator|+=
name|other
operator|.
name|bytesReadDistanceOfFiveOrLarger
expr_stmt|;
block|}
comment|/**        * Negate the values of all statistics.        */
DECL|method|negate ()
name|void
name|negate
parameter_list|()
block|{
name|this
operator|.
name|bytesRead
operator|=
operator|-
name|this
operator|.
name|bytesRead
expr_stmt|;
name|this
operator|.
name|bytesWritten
operator|=
operator|-
name|this
operator|.
name|bytesWritten
expr_stmt|;
name|this
operator|.
name|readOps
operator|=
operator|-
name|this
operator|.
name|readOps
expr_stmt|;
name|this
operator|.
name|largeReadOps
operator|=
operator|-
name|this
operator|.
name|largeReadOps
expr_stmt|;
name|this
operator|.
name|writeOps
operator|=
operator|-
name|this
operator|.
name|writeOps
expr_stmt|;
name|this
operator|.
name|bytesReadLocalHost
operator|=
operator|-
name|this
operator|.
name|bytesReadLocalHost
expr_stmt|;
name|this
operator|.
name|bytesReadDistanceOfOneOrTwo
operator|=
operator|-
name|this
operator|.
name|bytesReadDistanceOfOneOrTwo
expr_stmt|;
name|this
operator|.
name|bytesReadDistanceOfThreeOrFour
operator|=
operator|-
name|this
operator|.
name|bytesReadDistanceOfThreeOrFour
expr_stmt|;
name|this
operator|.
name|bytesReadDistanceOfFiveOrLarger
operator|=
operator|-
name|this
operator|.
name|bytesReadDistanceOfFiveOrLarger
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|bytesRead
operator|+
literal|" bytes read, "
operator|+
name|bytesWritten
operator|+
literal|" bytes written, "
operator|+
name|readOps
operator|+
literal|" read ops, "
operator|+
name|largeReadOps
operator|+
literal|" large read ops, "
operator|+
name|writeOps
operator|+
literal|" write ops"
return|;
block|}
DECL|method|getBytesRead ()
specifier|public
name|long
name|getBytesRead
parameter_list|()
block|{
return|return
name|bytesRead
return|;
block|}
DECL|method|getBytesWritten ()
specifier|public
name|long
name|getBytesWritten
parameter_list|()
block|{
return|return
name|bytesWritten
return|;
block|}
DECL|method|getReadOps ()
specifier|public
name|int
name|getReadOps
parameter_list|()
block|{
return|return
name|readOps
return|;
block|}
DECL|method|getLargeReadOps ()
specifier|public
name|int
name|getLargeReadOps
parameter_list|()
block|{
return|return
name|largeReadOps
return|;
block|}
DECL|method|getWriteOps ()
specifier|public
name|int
name|getWriteOps
parameter_list|()
block|{
return|return
name|writeOps
return|;
block|}
DECL|method|getBytesReadLocalHost ()
specifier|public
name|long
name|getBytesReadLocalHost
parameter_list|()
block|{
return|return
name|bytesReadLocalHost
return|;
block|}
DECL|method|getBytesReadDistanceOfOneOrTwo ()
specifier|public
name|long
name|getBytesReadDistanceOfOneOrTwo
parameter_list|()
block|{
return|return
name|bytesReadDistanceOfOneOrTwo
return|;
block|}
DECL|method|getBytesReadDistanceOfThreeOrFour ()
specifier|public
name|long
name|getBytesReadDistanceOfThreeOrFour
parameter_list|()
block|{
return|return
name|bytesReadDistanceOfThreeOrFour
return|;
block|}
DECL|method|getBytesReadDistanceOfFiveOrLarger ()
specifier|public
name|long
name|getBytesReadDistanceOfFiveOrLarger
parameter_list|()
block|{
return|return
name|bytesReadDistanceOfFiveOrLarger
return|;
block|}
block|}
DECL|interface|StatisticsAggregator
specifier|private
interface|interface
name|StatisticsAggregator
parameter_list|<
name|T
parameter_list|>
block|{
DECL|method|accept (StatisticsData data)
name|void
name|accept
parameter_list|(
name|StatisticsData
name|data
parameter_list|)
function_decl|;
DECL|method|aggregate ()
name|T
name|aggregate
parameter_list|()
function_decl|;
block|}
DECL|field|scheme
specifier|private
specifier|final
name|String
name|scheme
decl_stmt|;
comment|/**      * rootData is data that doesn't belong to any thread, but will be added      * to the totals.  This is useful for making copies of Statistics objects,      * and for storing data that pertains to threads that have been garbage      * collected.  Protected by the Statistics lock.      */
DECL|field|rootData
specifier|private
specifier|final
name|StatisticsData
name|rootData
decl_stmt|;
comment|/**      * Thread-local data.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"ThreadLocalNotStaticFinal"
argument_list|)
DECL|field|threadData
specifier|private
specifier|final
name|ThreadLocal
argument_list|<
name|StatisticsData
argument_list|>
name|threadData
decl_stmt|;
comment|/**      * Set of all thread-local data areas.  Protected by the Statistics lock.      * The references to the statistics data are kept using weak references      * to the associated threads. Proper clean-up is performed by the cleaner      * thread when the threads are garbage collected.      */
DECL|field|allData
specifier|private
specifier|final
name|Set
argument_list|<
name|StatisticsDataReference
argument_list|>
name|allData
decl_stmt|;
comment|/**      * Global reference queue and a cleaner thread that manage statistics data      * references from all filesystem instances.      */
DECL|field|STATS_DATA_REF_QUEUE
specifier|private
specifier|static
specifier|final
name|ReferenceQueue
argument_list|<
name|Thread
argument_list|>
name|STATS_DATA_REF_QUEUE
decl_stmt|;
DECL|field|STATS_DATA_CLEANER
specifier|private
specifier|static
specifier|final
name|Thread
name|STATS_DATA_CLEANER
decl_stmt|;
static|static
block|{
name|STATS_DATA_REF_QUEUE
operator|=
operator|new
name|ReferenceQueue
argument_list|<>
argument_list|()
expr_stmt|;
comment|// start a single daemon cleaner thread
name|STATS_DATA_CLEANER
operator|=
operator|new
name|Thread
argument_list|(
operator|new
name|StatisticsDataReferenceCleaner
argument_list|()
argument_list|)
expr_stmt|;
name|STATS_DATA_CLEANER
operator|.
name|setName
argument_list|(
name|StatisticsDataReferenceCleaner
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|STATS_DATA_CLEANER
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|STATS_DATA_CLEANER
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|method|Statistics (String scheme)
specifier|public
name|Statistics
parameter_list|(
name|String
name|scheme
parameter_list|)
block|{
name|this
operator|.
name|scheme
operator|=
name|scheme
expr_stmt|;
name|this
operator|.
name|rootData
operator|=
operator|new
name|StatisticsData
argument_list|()
expr_stmt|;
name|this
operator|.
name|threadData
operator|=
operator|new
name|ThreadLocal
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|allData
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
block|}
comment|/**      * Copy constructor.      *      * @param other    The input Statistics object which is cloned.      */
DECL|method|Statistics (Statistics other)
specifier|public
name|Statistics
parameter_list|(
name|Statistics
name|other
parameter_list|)
block|{
name|this
operator|.
name|scheme
operator|=
name|other
operator|.
name|scheme
expr_stmt|;
name|this
operator|.
name|rootData
operator|=
operator|new
name|StatisticsData
argument_list|()
expr_stmt|;
name|other
operator|.
name|visitAll
argument_list|(
operator|new
name|StatisticsAggregator
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|accept
parameter_list|(
name|StatisticsData
name|data
parameter_list|)
block|{
name|rootData
operator|.
name|add
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Void
name|aggregate
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|this
operator|.
name|threadData
operator|=
operator|new
name|ThreadLocal
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|allData
operator|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
expr_stmt|;
block|}
comment|/**      * A weak reference to a thread that also includes the data associated      * with that thread. On the thread being garbage collected, it is enqueued      * to the reference queue for clean-up.      */
DECL|class|StatisticsDataReference
specifier|private
specifier|final
class|class
name|StatisticsDataReference
extends|extends
name|WeakReference
argument_list|<
name|Thread
argument_list|>
block|{
DECL|field|data
specifier|private
specifier|final
name|StatisticsData
name|data
decl_stmt|;
DECL|method|StatisticsDataReference (StatisticsData data, Thread thread)
specifier|private
name|StatisticsDataReference
parameter_list|(
name|StatisticsData
name|data
parameter_list|,
name|Thread
name|thread
parameter_list|)
block|{
name|super
argument_list|(
name|thread
argument_list|,
name|STATS_DATA_REF_QUEUE
argument_list|)
expr_stmt|;
name|this
operator|.
name|data
operator|=
name|data
expr_stmt|;
block|}
DECL|method|getData ()
specifier|public
name|StatisticsData
name|getData
parameter_list|()
block|{
return|return
name|data
return|;
block|}
comment|/**        * Performs clean-up action when the associated thread is garbage        * collected.        */
DECL|method|cleanUp ()
specifier|public
name|void
name|cleanUp
parameter_list|()
block|{
comment|// use the statistics lock for safety
synchronized|synchronized
init|(
name|Statistics
operator|.
name|this
init|)
block|{
comment|/*            * If the thread that created this thread-local data no longer exists,            * remove the StatisticsData from our list and fold the values into            * rootData.            */
name|rootData
operator|.
name|add
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|allData
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Background action to act on references being removed.      */
DECL|class|StatisticsDataReferenceCleaner
specifier|private
specifier|static
class|class
name|StatisticsDataReferenceCleaner
implements|implements
name|Runnable
block|{
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
while|while
condition|(
operator|!
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
try|try
block|{
name|StatisticsDataReference
name|ref
init|=
operator|(
name|StatisticsDataReference
operator|)
name|STATS_DATA_REF_QUEUE
operator|.
name|remove
argument_list|()
decl_stmt|;
name|ref
operator|.
name|cleanUp
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"Cleaner thread interrupted, will stop"
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|th
parameter_list|)
block|{
name|LOGGER
operator|.
name|warn
argument_list|(
literal|"Exception in the cleaner thread but it will"
operator|+
literal|" continue to run"
argument_list|,
name|th
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Get or create the thread-local data associated with the current thread.      */
DECL|method|getThreadStatistics ()
specifier|public
name|StatisticsData
name|getThreadStatistics
parameter_list|()
block|{
name|StatisticsData
name|data
init|=
name|threadData
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
name|data
operator|=
operator|new
name|StatisticsData
argument_list|()
expr_stmt|;
name|threadData
operator|.
name|set
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|StatisticsDataReference
name|ref
init|=
operator|new
name|StatisticsDataReference
argument_list|(
name|data
argument_list|,
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|allData
operator|.
name|add
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|data
return|;
block|}
comment|/**      * Increment the bytes read in the statistics.      * @param newBytes the additional bytes read      */
DECL|method|incrementBytesRead (long newBytes)
specifier|public
name|void
name|incrementBytesRead
parameter_list|(
name|long
name|newBytes
parameter_list|)
block|{
name|getThreadStatistics
argument_list|()
operator|.
name|bytesRead
operator|+=
name|newBytes
expr_stmt|;
block|}
comment|/**      * Increment the bytes written in the statistics.      * @param newBytes the additional bytes written      */
DECL|method|incrementBytesWritten (long newBytes)
specifier|public
name|void
name|incrementBytesWritten
parameter_list|(
name|long
name|newBytes
parameter_list|)
block|{
name|getThreadStatistics
argument_list|()
operator|.
name|bytesWritten
operator|+=
name|newBytes
expr_stmt|;
block|}
comment|/**      * Increment the number of read operations.      * @param count number of read operations      */
DECL|method|incrementReadOps (int count)
specifier|public
name|void
name|incrementReadOps
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|getThreadStatistics
argument_list|()
operator|.
name|readOps
operator|+=
name|count
expr_stmt|;
block|}
comment|/**      * Increment the number of large read operations.      * @param count number of large read operations      */
DECL|method|incrementLargeReadOps (int count)
specifier|public
name|void
name|incrementLargeReadOps
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|getThreadStatistics
argument_list|()
operator|.
name|largeReadOps
operator|+=
name|count
expr_stmt|;
block|}
comment|/**      * Increment the number of write operations.      * @param count number of write operations      */
DECL|method|incrementWriteOps (int count)
specifier|public
name|void
name|incrementWriteOps
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|getThreadStatistics
argument_list|()
operator|.
name|writeOps
operator|+=
name|count
expr_stmt|;
block|}
comment|/**      * Increment the bytes read by the network distance in the statistics      * In the common network topology setup, distance value should be an even      * number such as 0, 2, 4, 6. To make it more general, we group distance      * by {1, 2}, {3, 4} and {5 and beyond} for accounting.      * @param distance the network distance      * @param newBytes the additional bytes read      */
DECL|method|incrementBytesReadByDistance (int distance, long newBytes)
specifier|public
name|void
name|incrementBytesReadByDistance
parameter_list|(
name|int
name|distance
parameter_list|,
name|long
name|newBytes
parameter_list|)
block|{
switch|switch
condition|(
name|distance
condition|)
block|{
case|case
literal|0
case|:
name|getThreadStatistics
argument_list|()
operator|.
name|bytesReadLocalHost
operator|+=
name|newBytes
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|2
case|:
name|getThreadStatistics
argument_list|()
operator|.
name|bytesReadDistanceOfOneOrTwo
operator|+=
name|newBytes
expr_stmt|;
break|break;
case|case
literal|3
case|:
case|case
literal|4
case|:
name|getThreadStatistics
argument_list|()
operator|.
name|bytesReadDistanceOfThreeOrFour
operator|+=
name|newBytes
expr_stmt|;
break|break;
default|default:
name|getThreadStatistics
argument_list|()
operator|.
name|bytesReadDistanceOfFiveOrLarger
operator|+=
name|newBytes
expr_stmt|;
break|break;
block|}
block|}
comment|/**      * Apply the given aggregator to all StatisticsData objects associated with      * this Statistics object.      *      * For each StatisticsData object, we will call accept on the visitor.      * Finally, at the end, we will call aggregate to get the final total.      *      * @param         visitor to use.      * @return        The total.      */
DECL|method|visitAll (StatisticsAggregator<T> visitor)
specifier|private
specifier|synchronized
parameter_list|<
name|T
parameter_list|>
name|T
name|visitAll
parameter_list|(
name|StatisticsAggregator
argument_list|<
name|T
argument_list|>
name|visitor
parameter_list|)
block|{
name|visitor
operator|.
name|accept
argument_list|(
name|rootData
argument_list|)
expr_stmt|;
for|for
control|(
name|StatisticsDataReference
name|ref
range|:
name|allData
control|)
block|{
name|StatisticsData
name|data
init|=
name|ref
operator|.
name|getData
argument_list|()
decl_stmt|;
name|visitor
operator|.
name|accept
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|visitor
operator|.
name|aggregate
argument_list|()
return|;
block|}
comment|/**      * Get the total number of bytes read.      * @return the number of bytes      */
DECL|method|getBytesRead ()
specifier|public
name|long
name|getBytesRead
parameter_list|()
block|{
return|return
name|visitAll
argument_list|(
operator|new
name|StatisticsAggregator
argument_list|<
name|Long
argument_list|>
argument_list|()
block|{
specifier|private
name|long
name|bytesRead
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|accept
parameter_list|(
name|StatisticsData
name|data
parameter_list|)
block|{
name|bytesRead
operator|+=
name|data
operator|.
name|bytesRead
expr_stmt|;
block|}
specifier|public
name|Long
name|aggregate
parameter_list|()
block|{
return|return
name|bytesRead
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**      * Get the total number of bytes written.      * @return the number of bytes      */
DECL|method|getBytesWritten ()
specifier|public
name|long
name|getBytesWritten
parameter_list|()
block|{
return|return
name|visitAll
argument_list|(
operator|new
name|StatisticsAggregator
argument_list|<
name|Long
argument_list|>
argument_list|()
block|{
specifier|private
name|long
name|bytesWritten
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|accept
parameter_list|(
name|StatisticsData
name|data
parameter_list|)
block|{
name|bytesWritten
operator|+=
name|data
operator|.
name|bytesWritten
expr_stmt|;
block|}
specifier|public
name|Long
name|aggregate
parameter_list|()
block|{
return|return
name|bytesWritten
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**      * Get the number of file system read operations such as list files.      * @return number of read operations      */
DECL|method|getReadOps ()
specifier|public
name|int
name|getReadOps
parameter_list|()
block|{
return|return
name|visitAll
argument_list|(
operator|new
name|StatisticsAggregator
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
specifier|private
name|int
name|readOps
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|accept
parameter_list|(
name|StatisticsData
name|data
parameter_list|)
block|{
name|readOps
operator|+=
name|data
operator|.
name|readOps
expr_stmt|;
name|readOps
operator|+=
name|data
operator|.
name|largeReadOps
expr_stmt|;
block|}
specifier|public
name|Integer
name|aggregate
parameter_list|()
block|{
return|return
name|readOps
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**      * Get the number of large file system read operations such as list files      * under a large directory.      * @return number of large read operations      */
DECL|method|getLargeReadOps ()
specifier|public
name|int
name|getLargeReadOps
parameter_list|()
block|{
return|return
name|visitAll
argument_list|(
operator|new
name|StatisticsAggregator
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
specifier|private
name|int
name|largeReadOps
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|accept
parameter_list|(
name|StatisticsData
name|data
parameter_list|)
block|{
name|largeReadOps
operator|+=
name|data
operator|.
name|largeReadOps
expr_stmt|;
block|}
specifier|public
name|Integer
name|aggregate
parameter_list|()
block|{
return|return
name|largeReadOps
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**      * Get the number of file system write operations such as create, append      * rename etc.      * @return number of write operations      */
DECL|method|getWriteOps ()
specifier|public
name|int
name|getWriteOps
parameter_list|()
block|{
return|return
name|visitAll
argument_list|(
operator|new
name|StatisticsAggregator
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
specifier|private
name|int
name|writeOps
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|accept
parameter_list|(
name|StatisticsData
name|data
parameter_list|)
block|{
name|writeOps
operator|+=
name|data
operator|.
name|writeOps
expr_stmt|;
block|}
specifier|public
name|Integer
name|aggregate
parameter_list|()
block|{
return|return
name|writeOps
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**      * In the common network topology setup, distance value should be an even      * number such as 0, 2, 4, 6. To make it more general, we group distance      * by {1, 2}, {3, 4} and {5 and beyond} for accounting. So if the caller      * ask for bytes read for distance 2, the function will return the value      * for group {1, 2}.      * @param distance the network distance      * @return the total number of bytes read by the network distance      */
DECL|method|getBytesReadByDistance (int distance)
specifier|public
name|long
name|getBytesReadByDistance
parameter_list|(
name|int
name|distance
parameter_list|)
block|{
name|long
name|bytesRead
decl_stmt|;
switch|switch
condition|(
name|distance
condition|)
block|{
case|case
literal|0
case|:
name|bytesRead
operator|=
name|getData
argument_list|()
operator|.
name|getBytesReadLocalHost
argument_list|()
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|2
case|:
name|bytesRead
operator|=
name|getData
argument_list|()
operator|.
name|getBytesReadDistanceOfOneOrTwo
argument_list|()
expr_stmt|;
break|break;
case|case
literal|3
case|:
case|case
literal|4
case|:
name|bytesRead
operator|=
name|getData
argument_list|()
operator|.
name|getBytesReadDistanceOfThreeOrFour
argument_list|()
expr_stmt|;
break|break;
default|default:
name|bytesRead
operator|=
name|getData
argument_list|()
operator|.
name|getBytesReadDistanceOfFiveOrLarger
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
name|bytesRead
return|;
block|}
comment|/**      * Get all statistics data.      * MR or other frameworks can use the method to get all statistics at once.      * @return the StatisticsData      */
DECL|method|getData ()
specifier|public
name|StatisticsData
name|getData
parameter_list|()
block|{
return|return
name|visitAll
argument_list|(
operator|new
name|StatisticsAggregator
argument_list|<
name|StatisticsData
argument_list|>
argument_list|()
block|{
specifier|private
name|StatisticsData
name|all
init|=
operator|new
name|StatisticsData
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|accept
parameter_list|(
name|StatisticsData
name|data
parameter_list|)
block|{
name|all
operator|.
name|add
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
specifier|public
name|StatisticsData
name|aggregate
parameter_list|()
block|{
return|return
name|all
return|;
block|}
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|visitAll
argument_list|(
operator|new
name|StatisticsAggregator
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
specifier|private
name|StatisticsData
name|total
init|=
operator|new
name|StatisticsData
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|accept
parameter_list|(
name|StatisticsData
name|data
parameter_list|)
block|{
name|total
operator|.
name|add
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
specifier|public
name|String
name|aggregate
parameter_list|()
block|{
return|return
name|total
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
argument_list|)
return|;
block|}
comment|/**      * Resets all statistics to 0.      *      * In order to reset, we add up all the thread-local statistics data, and      * set rootData to the negative of that.      *      * This may seem like a counterintuitive way to reset the statistics.  Why      * can't we just zero out all the thread-local data?  Well, thread-local      * data can only be modified by the thread that owns it.  If we tried to      * modify the thread-local data from this thread, our modification might get      * interleaved with a read-modify-write operation done by the thread that      * owns the data.  That would result in our update getting lost.      *      * The approach used here avoids this problem because it only ever reads      * (not writes) the thread-local data.  Both reads and writes to rootData      * are done under the lock, so we're free to modify rootData from any thread      * that holds the lock.      */
DECL|method|reset ()
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|visitAll
argument_list|(
operator|new
name|StatisticsAggregator
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
specifier|private
name|StatisticsData
name|total
init|=
operator|new
name|StatisticsData
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|void
name|accept
parameter_list|(
name|StatisticsData
name|data
parameter_list|)
block|{
name|total
operator|.
name|add
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
specifier|public
name|Void
name|aggregate
parameter_list|()
block|{
name|total
operator|.
name|negate
argument_list|()
expr_stmt|;
name|rootData
operator|.
name|add
argument_list|(
name|total
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get the uri scheme associated with this statistics object.      * @return the schema associated with this set of statistics      */
DECL|method|getScheme ()
specifier|public
name|String
name|getScheme
parameter_list|()
block|{
return|return
name|scheme
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getAllThreadLocalDataSize ()
specifier|synchronized
name|int
name|getAllThreadLocalDataSize
parameter_list|()
block|{
return|return
name|allData
operator|.
name|size
argument_list|()
return|;
block|}
block|}
comment|/**    * Get the Map of Statistics object indexed by URI Scheme.    * @return a Map having a key as URI scheme and value as Statistics object    * @deprecated use {@link #getGlobalStorageStatistics()}    */
annotation|@
name|Deprecated
DECL|method|getStatistics ()
specifier|public
specifier|static
specifier|synchronized
name|Map
argument_list|<
name|String
argument_list|,
name|Statistics
argument_list|>
name|getStatistics
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Statistics
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Statistics
name|stat
range|:
name|statisticsTable
operator|.
name|values
argument_list|()
control|)
block|{
name|result
operator|.
name|put
argument_list|(
name|stat
operator|.
name|getScheme
argument_list|()
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Return the FileSystem classes that have Statistics.    * @deprecated use {@link #getGlobalStorageStatistics()}    */
annotation|@
name|Deprecated
DECL|method|getAllStatistics ()
specifier|public
specifier|static
specifier|synchronized
name|List
argument_list|<
name|Statistics
argument_list|>
name|getAllStatistics
parameter_list|()
block|{
return|return
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|statisticsTable
operator|.
name|values
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get the statistics for a particular file system.    * @param cls the class to lookup    * @return a statistics object    * @deprecated use {@link #getGlobalStorageStatistics()}    */
annotation|@
name|Deprecated
DECL|method|getStatistics (final String scheme, Class<? extends FileSystem> cls)
specifier|public
specifier|static
specifier|synchronized
name|Statistics
name|getStatistics
parameter_list|(
specifier|final
name|String
name|scheme
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|FileSystem
argument_list|>
name|cls
parameter_list|)
block|{
name|checkArgument
argument_list|(
name|scheme
operator|!=
literal|null
argument_list|,
literal|"No statistics is allowed for a file system with null scheme!"
argument_list|)
expr_stmt|;
name|Statistics
name|result
init|=
name|statisticsTable
operator|.
name|get
argument_list|(
name|cls
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
specifier|final
name|Statistics
name|newStats
init|=
operator|new
name|Statistics
argument_list|(
name|scheme
argument_list|)
decl_stmt|;
name|statisticsTable
operator|.
name|put
argument_list|(
name|cls
argument_list|,
name|newStats
argument_list|)
expr_stmt|;
name|result
operator|=
name|newStats
expr_stmt|;
name|GlobalStorageStatistics
operator|.
name|INSTANCE
operator|.
name|put
argument_list|(
name|scheme
argument_list|,
operator|new
name|StorageStatisticsProvider
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|StorageStatistics
name|provide
parameter_list|()
block|{
return|return
operator|new
name|FileSystemStorageStatistics
argument_list|(
name|scheme
argument_list|,
name|newStats
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**    * Reset all statistics for all file systems.    */
DECL|method|clearStatistics ()
specifier|public
specifier|static
specifier|synchronized
name|void
name|clearStatistics
parameter_list|()
block|{
name|GlobalStorageStatistics
operator|.
name|INSTANCE
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
comment|/**    * Print all statistics for all file systems to {@code System.out}    */
specifier|public
specifier|static
specifier|synchronized
DECL|method|printStatistics ()
name|void
name|printStatistics
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|FileSystem
argument_list|>
argument_list|,
name|Statistics
argument_list|>
name|pair
range|:
name|statisticsTable
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"  FileSystem "
operator|+
name|pair
operator|.
name|getKey
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|": "
operator|+
name|pair
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Symlinks are temporarily disabled - see HADOOP-10020 and HADOOP-10052
DECL|field|symlinksEnabled
specifier|private
specifier|static
name|boolean
name|symlinksEnabled
init|=
literal|false
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|method|areSymlinksEnabled ()
specifier|public
specifier|static
name|boolean
name|areSymlinksEnabled
parameter_list|()
block|{
return|return
name|symlinksEnabled
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|enableSymlinks ()
specifier|public
specifier|static
name|void
name|enableSymlinks
parameter_list|()
block|{
name|symlinksEnabled
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * Get the StorageStatistics for this FileSystem object.  These statistics are    * per-instance.  They are not shared with any other FileSystem object.    *    *<p>This is a default method which is intended to be overridden by    * subclasses. The default implementation returns an empty storage statistics    * object.</p>    *    * @return    The StorageStatistics for this FileSystem instance.    *            Will never be null.    */
DECL|method|getStorageStatistics ()
specifier|public
name|StorageStatistics
name|getStorageStatistics
parameter_list|()
block|{
return|return
operator|new
name|EmptyStorageStatistics
argument_list|(
name|getUri
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Get the global storage statistics.    */
DECL|method|getGlobalStorageStatistics ()
specifier|public
specifier|static
name|GlobalStorageStatistics
name|getGlobalStorageStatistics
parameter_list|()
block|{
return|return
name|GlobalStorageStatistics
operator|.
name|INSTANCE
return|;
block|}
DECL|class|FileSystemDataOutputStreamBuilder
specifier|private
specifier|static
specifier|final
class|class
name|FileSystemDataOutputStreamBuilder
extends|extends
name|FSDataOutputStreamBuilder
argument_list|<
name|FSDataOutputStream
argument_list|,
name|FileSystemDataOutputStreamBuilder
argument_list|>
block|{
comment|/**      * Constructor.      */
DECL|method|FileSystemDataOutputStreamBuilder (FileSystem fileSystem, Path p)
specifier|protected
name|FileSystemDataOutputStreamBuilder
parameter_list|(
name|FileSystem
name|fileSystem
parameter_list|,
name|Path
name|p
parameter_list|)
block|{
name|super
argument_list|(
name|fileSystem
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|build ()
specifier|public
name|FSDataOutputStream
name|build
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|getFS
argument_list|()
operator|.
name|create
argument_list|(
name|getPath
argument_list|()
argument_list|,
name|getPermission
argument_list|()
argument_list|,
name|getFlags
argument_list|()
argument_list|,
name|getBufferSize
argument_list|()
argument_list|,
name|getReplication
argument_list|()
argument_list|,
name|getBlockSize
argument_list|()
argument_list|,
name|getProgress
argument_list|()
argument_list|,
name|getChecksumOpt
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getThisBuilder ()
specifier|protected
name|FileSystemDataOutputStreamBuilder
name|getThisBuilder
parameter_list|()
block|{
return|return
name|this
return|;
block|}
block|}
comment|/**    * Create a new FSDataOutputStreamBuilder for the file with path.    * Files are overwritten by default.    *    * @param path file path    * @return a FSDataOutputStreamBuilder object to build the file    *    * HADOOP-14384. Temporarily reduce the visibility of method before the    * builder interface becomes stable.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|method|createFile (Path path)
specifier|protected
name|FSDataOutputStreamBuilder
name|createFile
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
return|return
operator|new
name|FileSystemDataOutputStreamBuilder
argument_list|(
name|this
argument_list|,
name|path
argument_list|)
operator|.
name|create
argument_list|()
operator|.
name|overwrite
argument_list|(
literal|true
argument_list|)
return|;
block|}
comment|/**    * Create a Builder to append a file.    * @param path file path.    * @return a {@link FSDataOutputStreamBuilder} to build file append request.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|method|appendFile (Path path)
specifier|protected
name|FSDataOutputStreamBuilder
name|appendFile
parameter_list|(
name|Path
name|path
parameter_list|)
block|{
return|return
operator|new
name|FileSystemDataOutputStreamBuilder
argument_list|(
name|this
argument_list|,
name|path
argument_list|)
operator|.
name|append
argument_list|()
return|;
block|}
block|}
end_class

end_unit

