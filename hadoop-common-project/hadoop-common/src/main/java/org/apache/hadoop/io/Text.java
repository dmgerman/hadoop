begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.io
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|CharBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CharacterCodingException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|Charset
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CharsetDecoder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CharsetEncoder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CodingErrorAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|MalformedInputException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|CharacterIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|text
operator|.
name|StringCharacterIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|avro
operator|.
name|reflect
operator|.
name|Stringable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_comment
comment|/** This class stores text using standard UTF8 encoding.  It provides methods  * to serialize, deserialize, and compare texts at byte level.  The type of  * length is integer and is serialized using zero-compressed format.<p>In  * addition, it provides methods for string traversal without converting the  * byte array to a string.<p>Also includes utilities for  * serializing/deserialing a string, coding/decoding a string, checking if a  * byte array contains valid UTF8 code, calculating the length of an encoded  * string.  */
end_comment

begin_class
annotation|@
name|Stringable
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Stable
DECL|class|Text
specifier|public
class|class
name|Text
extends|extends
name|BinaryComparable
implements|implements
name|WritableComparable
argument_list|<
name|BinaryComparable
argument_list|>
block|{
DECL|field|ENCODER_FACTORY
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|CharsetEncoder
argument_list|>
name|ENCODER_FACTORY
init|=
operator|new
name|ThreadLocal
argument_list|<
name|CharsetEncoder
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|CharsetEncoder
name|initialValue
parameter_list|()
block|{
return|return
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
operator|.
name|newEncoder
argument_list|()
operator|.
name|onMalformedInput
argument_list|(
name|CodingErrorAction
operator|.
name|REPORT
argument_list|)
operator|.
name|onUnmappableCharacter
argument_list|(
name|CodingErrorAction
operator|.
name|REPORT
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|field|DECODER_FACTORY
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|CharsetDecoder
argument_list|>
name|DECODER_FACTORY
init|=
operator|new
name|ThreadLocal
argument_list|<
name|CharsetDecoder
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|CharsetDecoder
name|initialValue
parameter_list|()
block|{
return|return
name|Charset
operator|.
name|forName
argument_list|(
literal|"UTF-8"
argument_list|)
operator|.
name|newDecoder
argument_list|()
operator|.
name|onMalformedInput
argument_list|(
name|CodingErrorAction
operator|.
name|REPORT
argument_list|)
operator|.
name|onUnmappableCharacter
argument_list|(
name|CodingErrorAction
operator|.
name|REPORT
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|field|EMPTY_BYTES
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|EMPTY_BYTES
init|=
operator|new
name|byte
index|[
literal|0
index|]
decl_stmt|;
DECL|field|bytes
specifier|private
name|byte
index|[]
name|bytes
decl_stmt|;
DECL|field|length
specifier|private
name|int
name|length
decl_stmt|;
DECL|method|Text ()
specifier|public
name|Text
parameter_list|()
block|{
name|bytes
operator|=
name|EMPTY_BYTES
expr_stmt|;
block|}
comment|/** Construct from a string.     */
DECL|method|Text (String string)
specifier|public
name|Text
parameter_list|(
name|String
name|string
parameter_list|)
block|{
name|set
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
comment|/** Construct from another text. */
DECL|method|Text (Text utf8)
specifier|public
name|Text
parameter_list|(
name|Text
name|utf8
parameter_list|)
block|{
name|set
argument_list|(
name|utf8
argument_list|)
expr_stmt|;
block|}
comment|/** Construct from a byte array.    */
DECL|method|Text (byte[] utf8)
specifier|public
name|Text
parameter_list|(
name|byte
index|[]
name|utf8
parameter_list|)
block|{
name|set
argument_list|(
name|utf8
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get a copy of the bytes that is exactly the length of the data.    * See {@link #getBytes()} for faster access to the underlying array.    */
DECL|method|copyBytes ()
specifier|public
name|byte
index|[]
name|copyBytes
parameter_list|()
block|{
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Returns the raw bytes; however, only data up to {@link #getLength()} is    * valid. Please use {@link #copyBytes()} if you    * need the returned array to be precisely the length of the data.    */
annotation|@
name|Override
DECL|method|getBytes ()
specifier|public
name|byte
index|[]
name|getBytes
parameter_list|()
block|{
return|return
name|bytes
return|;
block|}
comment|/** Returns the number of bytes in the byte array */
annotation|@
name|Override
DECL|method|getLength ()
specifier|public
name|int
name|getLength
parameter_list|()
block|{
return|return
name|length
return|;
block|}
comment|/**    * Returns the Unicode Scalar Value (32-bit integer value)    * for the character at<code>position</code>. Note that this    * method avoids using the converter or doing String instantiation    * @return the Unicode scalar value at position or -1    *          if the position is invalid or points to a    *          trailing byte    */
DECL|method|charAt (int position)
specifier|public
name|int
name|charAt
parameter_list|(
name|int
name|position
parameter_list|)
block|{
if|if
condition|(
name|position
operator|>
name|this
operator|.
name|length
condition|)
return|return
operator|-
literal|1
return|;
comment|// too long
if|if
condition|(
name|position
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|// duh.
name|ByteBuffer
name|bb
init|=
operator|(
name|ByteBuffer
operator|)
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|bytes
argument_list|)
operator|.
name|position
argument_list|(
name|position
argument_list|)
decl_stmt|;
return|return
name|bytesToCodePoint
argument_list|(
name|bb
operator|.
name|slice
argument_list|()
argument_list|)
return|;
block|}
DECL|method|find (String what)
specifier|public
name|int
name|find
parameter_list|(
name|String
name|what
parameter_list|)
block|{
return|return
name|find
argument_list|(
name|what
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**    * Finds any occurrence of<code>what</code> in the backing    * buffer, starting as position<code>start</code>. The starting    * position is measured in bytes and the return value is in    * terms of byte position in the buffer. The backing buffer is    * not converted to a string for this operation.    * @return byte position of the first occurrence of the search    *         string in the UTF-8 buffer or -1 if not found    */
DECL|method|find (String what, int start)
specifier|public
name|int
name|find
parameter_list|(
name|String
name|what
parameter_list|,
name|int
name|start
parameter_list|)
block|{
try|try
block|{
name|ByteBuffer
name|src
init|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|this
operator|.
name|bytes
argument_list|,
literal|0
argument_list|,
name|this
operator|.
name|length
argument_list|)
decl_stmt|;
name|ByteBuffer
name|tgt
init|=
name|encode
argument_list|(
name|what
argument_list|)
decl_stmt|;
name|byte
name|b
init|=
name|tgt
operator|.
name|get
argument_list|()
decl_stmt|;
name|src
operator|.
name|position
argument_list|(
name|start
argument_list|)
expr_stmt|;
while|while
condition|(
name|src
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
if|if
condition|(
name|b
operator|==
name|src
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// matching first byte
name|src
operator|.
name|mark
argument_list|()
expr_stmt|;
comment|// save position in loop
name|tgt
operator|.
name|mark
argument_list|()
expr_stmt|;
comment|// save position in target
name|boolean
name|found
init|=
literal|true
decl_stmt|;
name|int
name|pos
init|=
name|src
operator|.
name|position
argument_list|()
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|tgt
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|src
operator|.
name|hasRemaining
argument_list|()
condition|)
block|{
comment|// src expired first
name|tgt
operator|.
name|reset
argument_list|()
expr_stmt|;
name|src
operator|.
name|reset
argument_list|()
expr_stmt|;
name|found
operator|=
literal|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|tgt
operator|.
name|get
argument_list|()
operator|==
name|src
operator|.
name|get
argument_list|()
operator|)
condition|)
block|{
name|tgt
operator|.
name|reset
argument_list|()
expr_stmt|;
name|src
operator|.
name|reset
argument_list|()
expr_stmt|;
name|found
operator|=
literal|false
expr_stmt|;
break|break;
comment|// no match
block|}
block|}
if|if
condition|(
name|found
condition|)
return|return
name|pos
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
comment|// not found
block|}
catch|catch
parameter_list|(
name|CharacterCodingException
name|e
parameter_list|)
block|{
comment|// can't get here
name|e
operator|.
name|printStackTrace
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/** Set to contain the contents of a string.     */
DECL|method|set (String string)
specifier|public
name|void
name|set
parameter_list|(
name|String
name|string
parameter_list|)
block|{
try|try
block|{
name|ByteBuffer
name|bb
init|=
name|encode
argument_list|(
name|string
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|bytes
operator|=
name|bb
operator|.
name|array
argument_list|()
expr_stmt|;
name|length
operator|=
name|bb
operator|.
name|limit
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CharacterCodingException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Should not have happened "
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Set to a utf8 byte array    */
DECL|method|set (byte[] utf8)
specifier|public
name|void
name|set
parameter_list|(
name|byte
index|[]
name|utf8
parameter_list|)
block|{
name|set
argument_list|(
name|utf8
argument_list|,
literal|0
argument_list|,
name|utf8
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/** copy a text. */
DECL|method|set (Text other)
specifier|public
name|void
name|set
parameter_list|(
name|Text
name|other
parameter_list|)
block|{
name|set
argument_list|(
name|other
operator|.
name|getBytes
argument_list|()
argument_list|,
literal|0
argument_list|,
name|other
operator|.
name|getLength
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set the Text to range of bytes    * @param utf8 the data to copy from    * @param start the first position of the new string    * @param len the number of bytes of the new string    */
DECL|method|set (byte[] utf8, int start, int len)
specifier|public
name|void
name|set
parameter_list|(
name|byte
index|[]
name|utf8
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|setCapacity
argument_list|(
name|len
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|utf8
argument_list|,
name|start
argument_list|,
name|bytes
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|this
operator|.
name|length
operator|=
name|len
expr_stmt|;
block|}
comment|/**    * Append a range of bytes to the end of the given text    * @param utf8 the data to copy from    * @param start the first position to append from utf8    * @param len the number of bytes to append    */
DECL|method|append (byte[] utf8, int start, int len)
specifier|public
name|void
name|append
parameter_list|(
name|byte
index|[]
name|utf8
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|setCapacity
argument_list|(
name|length
operator|+
name|len
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|utf8
argument_list|,
name|start
argument_list|,
name|bytes
argument_list|,
name|length
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|length
operator|+=
name|len
expr_stmt|;
block|}
comment|/**    * Clear the string to empty.    *    *<em>Note</em>: For performance reasons, this call does not clear the    * underlying byte array that is retrievable via {@link #getBytes()}.    * In order to free the byte-array memory, call {@link #set(byte[])}    * with an empty byte array (For example,<code>new byte[0]</code>).    */
DECL|method|clear ()
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|length
operator|=
literal|0
expr_stmt|;
block|}
comment|/*    * Sets the capacity of this Text object to<em>at least</em>    *<code>len</code> bytes. If the current buffer is longer,    * then the capacity and existing content of the buffer are    * unchanged. If<code>len</code> is larger    * than the current capacity, the Text object's capacity is    * increased to match.    * @param len the number of bytes we need    * @param keepData should the old data be kept    */
DECL|method|setCapacity (int len, boolean keepData)
specifier|private
name|void
name|setCapacity
parameter_list|(
name|int
name|len
parameter_list|,
name|boolean
name|keepData
parameter_list|)
block|{
if|if
condition|(
name|bytes
operator|==
literal|null
operator|||
name|bytes
operator|.
name|length
operator|<
name|len
condition|)
block|{
if|if
condition|(
name|bytes
operator|!=
literal|null
operator|&&
name|keepData
condition|)
block|{
name|bytes
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|bytes
argument_list|,
name|Math
operator|.
name|max
argument_list|(
name|len
argument_list|,
name|length
operator|<<
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bytes
operator|=
operator|new
name|byte
index|[
name|len
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/**     * Convert text back to string    * @see java.lang.Object#toString()    */
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
try|try
block|{
return|return
name|decode
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|CharacterCodingException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Should not have happened "
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** deserialize     */
annotation|@
name|Override
DECL|method|readFields (DataInput in)
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|newLength
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|readWithKnownLength
argument_list|(
name|in
argument_list|,
name|newLength
argument_list|)
expr_stmt|;
block|}
DECL|method|readFields (DataInput in, int maxLength)
specifier|public
name|void
name|readFields
parameter_list|(
name|DataInput
name|in
parameter_list|,
name|int
name|maxLength
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|newLength
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
name|newLength
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"tried to deserialize "
operator|+
name|newLength
operator|+
literal|" bytes of data!  newLength must be non-negative."
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|newLength
operator|>=
name|maxLength
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"tried to deserialize "
operator|+
name|newLength
operator|+
literal|" bytes of data, but maxLength = "
operator|+
name|maxLength
argument_list|)
throw|;
block|}
name|readWithKnownLength
argument_list|(
name|in
argument_list|,
name|newLength
argument_list|)
expr_stmt|;
block|}
comment|/** Skips over one Text in the input. */
DECL|method|skip (DataInput in)
specifier|public
specifier|static
name|void
name|skip
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|length
init|=
name|WritableUtils
operator|.
name|readVInt
argument_list|(
name|in
argument_list|)
decl_stmt|;
name|WritableUtils
operator|.
name|skipFully
argument_list|(
name|in
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**    * Read a Text object whose length is already known.    * This allows creating Text from a stream which uses a different serialization    * format.    */
DECL|method|readWithKnownLength (DataInput in, int len)
specifier|public
name|void
name|readWithKnownLength
parameter_list|(
name|DataInput
name|in
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|setCapacity
argument_list|(
name|len
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|length
operator|=
name|len
expr_stmt|;
block|}
comment|/** serialize    * write this object to out    * length uses zero-compressed encoding    * @see Writable#write(DataOutput)    */
annotation|@
name|Override
DECL|method|write (DataOutput out)
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|WritableUtils
operator|.
name|writeVInt
argument_list|(
name|out
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
DECL|method|write (DataOutput out, int maxLength)
specifier|public
name|void
name|write
parameter_list|(
name|DataOutput
name|out
parameter_list|,
name|int
name|maxLength
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|length
operator|>
name|maxLength
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"data was too long to write!  Expected "
operator|+
literal|"less than or equal to "
operator|+
name|maxLength
operator|+
literal|" bytes, but got "
operator|+
name|length
operator|+
literal|" bytes."
argument_list|)
throw|;
block|}
name|WritableUtils
operator|.
name|writeVInt
argument_list|(
name|out
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/** Returns true iff<code>o</code> is a Text with the same contents.  */
annotation|@
name|Override
DECL|method|equals (Object o)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Text
condition|)
return|return
name|super
operator|.
name|equals
argument_list|(
name|o
argument_list|)
return|;
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|super
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|/** A WritableComparator optimized for Text keys. */
DECL|class|Comparator
specifier|public
specifier|static
class|class
name|Comparator
extends|extends
name|WritableComparator
block|{
DECL|method|Comparator ()
specifier|public
name|Comparator
parameter_list|()
block|{
name|super
argument_list|(
name|Text
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|compare (byte[] b1, int s1, int l1, byte[] b2, int s2, int l2)
specifier|public
name|int
name|compare
parameter_list|(
name|byte
index|[]
name|b1
parameter_list|,
name|int
name|s1
parameter_list|,
name|int
name|l1
parameter_list|,
name|byte
index|[]
name|b2
parameter_list|,
name|int
name|s2
parameter_list|,
name|int
name|l2
parameter_list|)
block|{
name|int
name|n1
init|=
name|WritableUtils
operator|.
name|decodeVIntSize
argument_list|(
name|b1
index|[
name|s1
index|]
argument_list|)
decl_stmt|;
name|int
name|n2
init|=
name|WritableUtils
operator|.
name|decodeVIntSize
argument_list|(
name|b2
index|[
name|s2
index|]
argument_list|)
decl_stmt|;
return|return
name|compareBytes
argument_list|(
name|b1
argument_list|,
name|s1
operator|+
name|n1
argument_list|,
name|l1
operator|-
name|n1
argument_list|,
name|b2
argument_list|,
name|s2
operator|+
name|n2
argument_list|,
name|l2
operator|-
name|n2
argument_list|)
return|;
block|}
block|}
static|static
block|{
comment|// register this comparator
name|WritableComparator
operator|.
name|define
argument_list|(
name|Text
operator|.
name|class
argument_list|,
operator|new
name|Comparator
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/// STATIC UTILITIES FROM HERE DOWN
comment|/**    * Converts the provided byte array to a String using the    * UTF-8 encoding. If the input is malformed,    * replace by a default value.    */
DECL|method|decode (byte[] utf8)
specifier|public
specifier|static
name|String
name|decode
parameter_list|(
name|byte
index|[]
name|utf8
parameter_list|)
throws|throws
name|CharacterCodingException
block|{
return|return
name|decode
argument_list|(
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|utf8
argument_list|)
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|decode (byte[] utf8, int start, int length)
specifier|public
specifier|static
name|String
name|decode
parameter_list|(
name|byte
index|[]
name|utf8
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|CharacterCodingException
block|{
return|return
name|decode
argument_list|(
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|utf8
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Converts the provided byte array to a String using the    * UTF-8 encoding. If<code>replace</code> is true, then    * malformed input is replaced with the    * substitution character, which is U+FFFD. Otherwise the    * method throws a MalformedInputException.    */
DECL|method|decode (byte[] utf8, int start, int length, boolean replace)
specifier|public
specifier|static
name|String
name|decode
parameter_list|(
name|byte
index|[]
name|utf8
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|length
parameter_list|,
name|boolean
name|replace
parameter_list|)
throws|throws
name|CharacterCodingException
block|{
return|return
name|decode
argument_list|(
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|utf8
argument_list|,
name|start
argument_list|,
name|length
argument_list|)
argument_list|,
name|replace
argument_list|)
return|;
block|}
DECL|method|decode (ByteBuffer utf8, boolean replace)
specifier|private
specifier|static
name|String
name|decode
parameter_list|(
name|ByteBuffer
name|utf8
parameter_list|,
name|boolean
name|replace
parameter_list|)
throws|throws
name|CharacterCodingException
block|{
name|CharsetDecoder
name|decoder
init|=
name|DECODER_FACTORY
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|replace
condition|)
block|{
name|decoder
operator|.
name|onMalformedInput
argument_list|(
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|CodingErrorAction
operator|.
name|REPLACE
argument_list|)
expr_stmt|;
name|decoder
operator|.
name|onUnmappableCharacter
argument_list|(
name|CodingErrorAction
operator|.
name|REPLACE
argument_list|)
expr_stmt|;
block|}
name|String
name|str
init|=
name|decoder
operator|.
name|decode
argument_list|(
name|utf8
argument_list|)
operator|.
name|toString
argument_list|()
decl_stmt|;
comment|// set decoder back to its default value: REPORT
if|if
condition|(
name|replace
condition|)
block|{
name|decoder
operator|.
name|onMalformedInput
argument_list|(
name|CodingErrorAction
operator|.
name|REPORT
argument_list|)
expr_stmt|;
name|decoder
operator|.
name|onUnmappableCharacter
argument_list|(
name|CodingErrorAction
operator|.
name|REPORT
argument_list|)
expr_stmt|;
block|}
return|return
name|str
return|;
block|}
comment|/**    * Converts the provided String to bytes using the    * UTF-8 encoding. If the input is malformed,    * invalid chars are replaced by a default value.    * @return ByteBuffer: bytes stores at ByteBuffer.array()     *                     and length is ByteBuffer.limit()    */
DECL|method|encode (String string)
specifier|public
specifier|static
name|ByteBuffer
name|encode
parameter_list|(
name|String
name|string
parameter_list|)
throws|throws
name|CharacterCodingException
block|{
return|return
name|encode
argument_list|(
name|string
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**    * Converts the provided String to bytes using the    * UTF-8 encoding. If<code>replace</code> is true, then    * malformed input is replaced with the    * substitution character, which is U+FFFD. Otherwise the    * method throws a MalformedInputException.    * @return ByteBuffer: bytes stores at ByteBuffer.array()     *                     and length is ByteBuffer.limit()    */
DECL|method|encode (String string, boolean replace)
specifier|public
specifier|static
name|ByteBuffer
name|encode
parameter_list|(
name|String
name|string
parameter_list|,
name|boolean
name|replace
parameter_list|)
throws|throws
name|CharacterCodingException
block|{
name|CharsetEncoder
name|encoder
init|=
name|ENCODER_FACTORY
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|replace
condition|)
block|{
name|encoder
operator|.
name|onMalformedInput
argument_list|(
name|CodingErrorAction
operator|.
name|REPLACE
argument_list|)
expr_stmt|;
name|encoder
operator|.
name|onUnmappableCharacter
argument_list|(
name|CodingErrorAction
operator|.
name|REPLACE
argument_list|)
expr_stmt|;
block|}
name|ByteBuffer
name|bytes
init|=
name|encoder
operator|.
name|encode
argument_list|(
name|CharBuffer
operator|.
name|wrap
argument_list|(
name|string
operator|.
name|toCharArray
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|replace
condition|)
block|{
name|encoder
operator|.
name|onMalformedInput
argument_list|(
name|CodingErrorAction
operator|.
name|REPORT
argument_list|)
expr_stmt|;
name|encoder
operator|.
name|onUnmappableCharacter
argument_list|(
name|CodingErrorAction
operator|.
name|REPORT
argument_list|)
expr_stmt|;
block|}
return|return
name|bytes
return|;
block|}
DECL|field|DEFAULT_MAX_LEN
specifier|static
specifier|final
specifier|public
name|int
name|DEFAULT_MAX_LEN
init|=
literal|1024
operator|*
literal|1024
decl_stmt|;
comment|/** Read a UTF8 encoded string from in    */
DECL|method|readString (DataInput in)
specifier|public
specifier|static
name|String
name|readString
parameter_list|(
name|DataInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|readString
argument_list|(
name|in
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
return|;
block|}
comment|/** Read a UTF8 encoded string with a maximum size    */
DECL|method|readString (DataInput in, int maxLength)
specifier|public
specifier|static
name|String
name|readString
parameter_list|(
name|DataInput
name|in
parameter_list|,
name|int
name|maxLength
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|length
init|=
name|WritableUtils
operator|.
name|readVIntInRange
argument_list|(
name|in
argument_list|,
literal|0
argument_list|,
name|maxLength
argument_list|)
decl_stmt|;
name|byte
index|[]
name|bytes
init|=
operator|new
name|byte
index|[
name|length
index|]
decl_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|bytes
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|decode
argument_list|(
name|bytes
argument_list|)
return|;
block|}
comment|/** Write a UTF8 encoded string to out    */
DECL|method|writeString (DataOutput out, String s)
specifier|public
specifier|static
name|int
name|writeString
parameter_list|(
name|DataOutput
name|out
parameter_list|,
name|String
name|s
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteBuffer
name|bytes
init|=
name|encode
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|int
name|length
init|=
name|bytes
operator|.
name|limit
argument_list|()
decl_stmt|;
name|WritableUtils
operator|.
name|writeVInt
argument_list|(
name|out
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|bytes
operator|.
name|array
argument_list|()
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
comment|/** Write a UTF8 encoded string with a maximum size to out    */
DECL|method|writeString (DataOutput out, String s, int maxLength)
specifier|public
specifier|static
name|int
name|writeString
parameter_list|(
name|DataOutput
name|out
parameter_list|,
name|String
name|s
parameter_list|,
name|int
name|maxLength
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteBuffer
name|bytes
init|=
name|encode
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|int
name|length
init|=
name|bytes
operator|.
name|limit
argument_list|()
decl_stmt|;
if|if
condition|(
name|length
operator|>
name|maxLength
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"string was too long to write!  Expected "
operator|+
literal|"less than or equal to "
operator|+
name|maxLength
operator|+
literal|" bytes, but got "
operator|+
name|length
operator|+
literal|" bytes."
argument_list|)
throw|;
block|}
name|WritableUtils
operator|.
name|writeVInt
argument_list|(
name|out
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|bytes
operator|.
name|array
argument_list|()
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
comment|////// states for validateUTF8
DECL|field|LEAD_BYTE
specifier|private
specifier|static
specifier|final
name|int
name|LEAD_BYTE
init|=
literal|0
decl_stmt|;
DECL|field|TRAIL_BYTE_1
specifier|private
specifier|static
specifier|final
name|int
name|TRAIL_BYTE_1
init|=
literal|1
decl_stmt|;
DECL|field|TRAIL_BYTE
specifier|private
specifier|static
specifier|final
name|int
name|TRAIL_BYTE
init|=
literal|2
decl_stmt|;
comment|/**     * Check if a byte array contains valid utf-8    * @param utf8 byte array    * @throws MalformedInputException if the byte array contains invalid utf-8    */
DECL|method|validateUTF8 (byte[] utf8)
specifier|public
specifier|static
name|void
name|validateUTF8
parameter_list|(
name|byte
index|[]
name|utf8
parameter_list|)
throws|throws
name|MalformedInputException
block|{
name|validateUTF8
argument_list|(
name|utf8
argument_list|,
literal|0
argument_list|,
name|utf8
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**    * Check to see if a byte array is valid utf-8    * @param utf8 the array of bytes    * @param start the offset of the first byte in the array    * @param len the length of the byte sequence    * @throws MalformedInputException if the byte array contains invalid bytes    */
DECL|method|validateUTF8 (byte[] utf8, int start, int len)
specifier|public
specifier|static
name|void
name|validateUTF8
parameter_list|(
name|byte
index|[]
name|utf8
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|MalformedInputException
block|{
name|int
name|count
init|=
name|start
decl_stmt|;
name|int
name|leadByte
init|=
literal|0
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
name|int
name|state
init|=
name|LEAD_BYTE
decl_stmt|;
while|while
condition|(
name|count
operator|<
name|start
operator|+
name|len
condition|)
block|{
name|int
name|aByte
init|=
name|utf8
index|[
name|count
index|]
operator|&
literal|0xFF
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|LEAD_BYTE
case|:
name|leadByte
operator|=
name|aByte
expr_stmt|;
name|length
operator|=
name|bytesFromUTF8
index|[
name|aByte
index|]
expr_stmt|;
switch|switch
condition|(
name|length
condition|)
block|{
case|case
literal|0
case|:
comment|// check for ASCII
if|if
condition|(
name|leadByte
operator|>
literal|0x7F
condition|)
throw|throw
operator|new
name|MalformedInputException
argument_list|(
name|count
argument_list|)
throw|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|leadByte
argument_list|<
literal|0xC2
operator|||
name|leadByte
argument_list|>
literal|0xDF
condition|)
throw|throw
operator|new
name|MalformedInputException
argument_list|(
name|count
argument_list|)
throw|;
name|state
operator|=
name|TRAIL_BYTE_1
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|leadByte
argument_list|<
literal|0xE0
operator|||
name|leadByte
argument_list|>
literal|0xEF
condition|)
throw|throw
operator|new
name|MalformedInputException
argument_list|(
name|count
argument_list|)
throw|;
name|state
operator|=
name|TRAIL_BYTE_1
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|leadByte
argument_list|<
literal|0xF0
operator|||
name|leadByte
argument_list|>
literal|0xF4
condition|)
throw|throw
operator|new
name|MalformedInputException
argument_list|(
name|count
argument_list|)
throw|;
name|state
operator|=
name|TRAIL_BYTE_1
expr_stmt|;
break|break;
default|default:
comment|// too long! Longest valid UTF-8 is 4 bytes (lead + three)
comment|// or if< 0 we got a trail byte in the lead byte position
throw|throw
operator|new
name|MalformedInputException
argument_list|(
name|count
argument_list|)
throw|;
block|}
comment|// switch (length)
break|break;
case|case
name|TRAIL_BYTE_1
case|:
if|if
condition|(
name|leadByte
operator|==
literal|0xF0
operator|&&
name|aByte
operator|<
literal|0x90
condition|)
throw|throw
operator|new
name|MalformedInputException
argument_list|(
name|count
argument_list|)
throw|;
if|if
condition|(
name|leadByte
operator|==
literal|0xF4
operator|&&
name|aByte
operator|>
literal|0x8F
condition|)
throw|throw
operator|new
name|MalformedInputException
argument_list|(
name|count
argument_list|)
throw|;
if|if
condition|(
name|leadByte
operator|==
literal|0xE0
operator|&&
name|aByte
operator|<
literal|0xA0
condition|)
throw|throw
operator|new
name|MalformedInputException
argument_list|(
name|count
argument_list|)
throw|;
if|if
condition|(
name|leadByte
operator|==
literal|0xED
operator|&&
name|aByte
operator|>
literal|0x9F
condition|)
throw|throw
operator|new
name|MalformedInputException
argument_list|(
name|count
argument_list|)
throw|;
comment|// falls through to regular trail-byte test!!
case|case
name|TRAIL_BYTE
case|:
if|if
condition|(
name|aByte
argument_list|<
literal|0x80
operator|||
name|aByte
argument_list|>
literal|0xBF
condition|)
throw|throw
operator|new
name|MalformedInputException
argument_list|(
name|count
argument_list|)
throw|;
if|if
condition|(
operator|--
name|length
operator|==
literal|0
condition|)
block|{
name|state
operator|=
name|LEAD_BYTE
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|TRAIL_BYTE
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
comment|// switch (state)
name|count
operator|++
expr_stmt|;
block|}
block|}
comment|/**    * Magic numbers for UTF-8. These are the number of bytes    * that<em>follow</em> a given lead byte. Trailing bytes    * have the value -1. The values 4 and 5 are presented in    * this table, even though valid UTF-8 cannot include the    * five and six byte sequences.    */
DECL|field|bytesFromUTF8
specifier|static
specifier|final
name|int
index|[]
name|bytesFromUTF8
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|// trail bytes
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|}
decl_stmt|;
comment|/**    * Returns the next code point at the current position in    * the buffer. The buffer's position will be incremented.    * Any mark set on this buffer will be changed by this method!    */
DECL|method|bytesToCodePoint (ByteBuffer bytes)
specifier|public
specifier|static
name|int
name|bytesToCodePoint
parameter_list|(
name|ByteBuffer
name|bytes
parameter_list|)
block|{
name|bytes
operator|.
name|mark
argument_list|()
expr_stmt|;
name|byte
name|b
init|=
name|bytes
operator|.
name|get
argument_list|()
decl_stmt|;
name|bytes
operator|.
name|reset
argument_list|()
expr_stmt|;
name|int
name|extraBytesToRead
init|=
name|bytesFromUTF8
index|[
operator|(
name|b
operator|&
literal|0xFF
operator|)
index|]
decl_stmt|;
if|if
condition|(
name|extraBytesToRead
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|// trailing byte!
name|int
name|ch
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|extraBytesToRead
condition|)
block|{
case|case
literal|5
case|:
name|ch
operator|+=
operator|(
name|bytes
operator|.
name|get
argument_list|()
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|ch
operator|<<=
literal|6
expr_stmt|;
comment|/* remember, illegal UTF-8 */
case|case
literal|4
case|:
name|ch
operator|+=
operator|(
name|bytes
operator|.
name|get
argument_list|()
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|ch
operator|<<=
literal|6
expr_stmt|;
comment|/* remember, illegal UTF-8 */
case|case
literal|3
case|:
name|ch
operator|+=
operator|(
name|bytes
operator|.
name|get
argument_list|()
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|ch
operator|<<=
literal|6
expr_stmt|;
case|case
literal|2
case|:
name|ch
operator|+=
operator|(
name|bytes
operator|.
name|get
argument_list|()
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|ch
operator|<<=
literal|6
expr_stmt|;
case|case
literal|1
case|:
name|ch
operator|+=
operator|(
name|bytes
operator|.
name|get
argument_list|()
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|ch
operator|<<=
literal|6
expr_stmt|;
case|case
literal|0
case|:
name|ch
operator|+=
operator|(
name|bytes
operator|.
name|get
argument_list|()
operator|&
literal|0xFF
operator|)
expr_stmt|;
block|}
name|ch
operator|-=
name|offsetsFromUTF8
index|[
name|extraBytesToRead
index|]
expr_stmt|;
return|return
name|ch
return|;
block|}
DECL|field|offsetsFromUTF8
specifier|static
specifier|final
name|int
name|offsetsFromUTF8
index|[]
init|=
block|{
literal|0x00000000
block|,
literal|0x00003080
block|,
literal|0x000E2080
block|,
literal|0x03C82080
block|,
literal|0xFA082080
block|,
literal|0x82082080
block|}
decl_stmt|;
comment|/**    * For the given string, returns the number of UTF-8 bytes    * required to encode the string.    * @param string text to encode    * @return number of UTF-8 bytes required to encode    */
DECL|method|utf8Length (String string)
specifier|public
specifier|static
name|int
name|utf8Length
parameter_list|(
name|String
name|string
parameter_list|)
block|{
name|CharacterIterator
name|iter
init|=
operator|new
name|StringCharacterIterator
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|char
name|ch
init|=
name|iter
operator|.
name|first
argument_list|()
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|ch
operator|!=
name|CharacterIterator
operator|.
name|DONE
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|>=
literal|0xD800
operator|)
operator|&&
operator|(
name|ch
operator|<
literal|0xDC00
operator|)
condition|)
block|{
comment|// surrogate pair?
name|char
name|trail
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|trail
operator|>
literal|0xDBFF
operator|)
operator|&&
operator|(
name|trail
operator|<
literal|0xE000
operator|)
condition|)
block|{
comment|// valid pair
name|size
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|// invalid pair
name|size
operator|+=
literal|3
expr_stmt|;
name|iter
operator|.
name|previous
argument_list|()
expr_stmt|;
comment|// rewind one
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|<
literal|0x80
condition|)
block|{
name|size
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|<
literal|0x800
condition|)
block|{
name|size
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|// ch< 0x10000, that is, the largest char value
name|size
operator|+=
literal|3
expr_stmt|;
block|}
name|ch
operator|=
name|iter
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
block|}
end_class

end_unit

