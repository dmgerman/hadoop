begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.crypto
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileDescriptor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ReadableByteChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|GeneralSecurityException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentLinkedQueue
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ByteBufferPositionedReadable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ByteBufferReadable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CanSetDropBehind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CanSetReadahead
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CanUnbuffer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FSExceptionMessages
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|HasEnhancedByteBufferAccess
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|HasFileDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PositionedReadable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ReadOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Seekable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StreamCapabilities
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|StreamCapabilitiesPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|ByteBufferPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_comment
comment|/**  * CryptoInputStream decrypts data. It is not thread-safe. AES CTR mode is  * required in order to ensure that the plain text and cipher text have a 1:1  * mapping. The decryption is buffer based. The key points of the decryption  * are (1) calculating the counter and (2) padding through stream position:  *<p>  * counter = base + pos/(algorithm blocksize);   * padding = pos%(algorithm blocksize);   *<p>  * The underlying stream offset is maintained as state.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|CryptoInputStream
specifier|public
class|class
name|CryptoInputStream
extends|extends
name|FilterInputStream
implements|implements
name|Seekable
implements|,
name|PositionedReadable
implements|,
name|ByteBufferReadable
implements|,
name|HasFileDescriptor
implements|,
name|CanSetDropBehind
implements|,
name|CanSetReadahead
implements|,
name|HasEnhancedByteBufferAccess
implements|,
name|ReadableByteChannel
implements|,
name|CanUnbuffer
implements|,
name|StreamCapabilities
implements|,
name|ByteBufferPositionedReadable
block|{
DECL|field|oneByteBuf
specifier|private
specifier|final
name|byte
index|[]
name|oneByteBuf
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
DECL|field|codec
specifier|private
specifier|final
name|CryptoCodec
name|codec
decl_stmt|;
DECL|field|decryptor
specifier|private
specifier|final
name|Decryptor
name|decryptor
decl_stmt|;
DECL|field|bufferSize
specifier|private
specifier|final
name|int
name|bufferSize
decl_stmt|;
comment|/**    * Input data buffer. The data starts at inBuffer.position() and ends at     * to inBuffer.limit().    */
DECL|field|inBuffer
specifier|private
name|ByteBuffer
name|inBuffer
decl_stmt|;
comment|/**    * The decrypted data buffer. The data starts at outBuffer.position() and     * ends at outBuffer.limit();    */
DECL|field|outBuffer
specifier|private
name|ByteBuffer
name|outBuffer
decl_stmt|;
DECL|field|streamOffset
specifier|private
name|long
name|streamOffset
init|=
literal|0
decl_stmt|;
comment|// Underlying stream offset.
comment|/**    * Whether the underlying stream supports     * {@link org.apache.hadoop.fs.ByteBufferReadable}    */
DECL|field|usingByteBufferRead
specifier|private
name|Boolean
name|usingByteBufferRead
init|=
literal|null
decl_stmt|;
comment|/**    * Padding = pos%(algorithm blocksize); Padding is put into {@link #inBuffer}     * before any other data goes in. The purpose of padding is to put the input     * data at proper position.    */
DECL|field|padding
specifier|private
name|byte
name|padding
decl_stmt|;
DECL|field|closed
specifier|private
name|boolean
name|closed
decl_stmt|;
DECL|field|key
specifier|private
specifier|final
name|byte
index|[]
name|key
decl_stmt|;
DECL|field|initIV
specifier|private
specifier|final
name|byte
index|[]
name|initIV
decl_stmt|;
DECL|field|iv
specifier|private
name|byte
index|[]
name|iv
decl_stmt|;
DECL|field|isByteBufferReadable
specifier|private
specifier|final
name|boolean
name|isByteBufferReadable
decl_stmt|;
DECL|field|isReadableByteChannel
specifier|private
specifier|final
name|boolean
name|isReadableByteChannel
decl_stmt|;
comment|/** DirectBuffer pool */
DECL|field|bufferPool
specifier|private
specifier|final
name|Queue
argument_list|<
name|ByteBuffer
argument_list|>
name|bufferPool
init|=
operator|new
name|ConcurrentLinkedQueue
argument_list|<
name|ByteBuffer
argument_list|>
argument_list|()
decl_stmt|;
comment|/** Decryptor pool */
DECL|field|decryptorPool
specifier|private
specifier|final
name|Queue
argument_list|<
name|Decryptor
argument_list|>
name|decryptorPool
init|=
operator|new
name|ConcurrentLinkedQueue
argument_list|<
name|Decryptor
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|CryptoInputStream (InputStream in, CryptoCodec codec, int bufferSize, byte[] key, byte[] iv)
specifier|public
name|CryptoInputStream
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|CryptoCodec
name|codec
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|byte
index|[]
name|iv
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|in
argument_list|,
name|codec
argument_list|,
name|bufferSize
argument_list|,
name|key
argument_list|,
name|iv
argument_list|,
name|CryptoStreamUtils
operator|.
name|getInputStreamOffset
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|CryptoInputStream (InputStream in, CryptoCodec codec, int bufferSize, byte[] key, byte[] iv, long streamOffset)
specifier|public
name|CryptoInputStream
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|CryptoCodec
name|codec
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|byte
index|[]
name|iv
parameter_list|,
name|long
name|streamOffset
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|CryptoStreamUtils
operator|.
name|checkCodec
argument_list|(
name|codec
argument_list|)
expr_stmt|;
name|this
operator|.
name|bufferSize
operator|=
name|CryptoStreamUtils
operator|.
name|checkBufferSize
argument_list|(
name|codec
argument_list|,
name|bufferSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|codec
operator|=
name|codec
expr_stmt|;
name|this
operator|.
name|key
operator|=
name|key
operator|.
name|clone
argument_list|()
expr_stmt|;
name|this
operator|.
name|initIV
operator|=
name|iv
operator|.
name|clone
argument_list|()
expr_stmt|;
name|this
operator|.
name|iv
operator|=
name|iv
operator|.
name|clone
argument_list|()
expr_stmt|;
name|this
operator|.
name|streamOffset
operator|=
name|streamOffset
expr_stmt|;
name|isByteBufferReadable
operator|=
name|in
operator|instanceof
name|ByteBufferReadable
expr_stmt|;
name|isReadableByteChannel
operator|=
name|in
operator|instanceof
name|ReadableByteChannel
expr_stmt|;
name|inBuffer
operator|=
name|ByteBuffer
operator|.
name|allocateDirect
argument_list|(
name|this
operator|.
name|bufferSize
argument_list|)
expr_stmt|;
name|outBuffer
operator|=
name|ByteBuffer
operator|.
name|allocateDirect
argument_list|(
name|this
operator|.
name|bufferSize
argument_list|)
expr_stmt|;
name|decryptor
operator|=
name|getDecryptor
argument_list|()
expr_stmt|;
name|resetStreamOffset
argument_list|(
name|streamOffset
argument_list|)
expr_stmt|;
block|}
DECL|method|CryptoInputStream (InputStream in, CryptoCodec codec, byte[] key, byte[] iv)
specifier|public
name|CryptoInputStream
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|CryptoCodec
name|codec
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|byte
index|[]
name|iv
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|in
argument_list|,
name|codec
argument_list|,
name|CryptoStreamUtils
operator|.
name|getBufferSize
argument_list|(
name|codec
operator|.
name|getConf
argument_list|()
argument_list|)
argument_list|,
name|key
argument_list|,
name|iv
argument_list|)
expr_stmt|;
block|}
DECL|method|getWrappedStream ()
specifier|public
name|InputStream
name|getWrappedStream
parameter_list|()
block|{
return|return
name|in
return|;
block|}
comment|/**    * Decryption is buffer based.    * If there is data in {@link #outBuffer}, then read it out of this buffer.    * If there is no data in {@link #outBuffer}, then read more from the     * underlying stream and do the decryption.    * @param b the buffer into which the decrypted data is read.    * @param off the buffer offset.    * @param len the maximum number of decrypted data bytes to read.    * @return int the total number of decrypted data bytes read into the buffer.    * @throws IOException    */
annotation|@
name|Override
DECL|method|read (byte[] b, int off, int len)
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|checkStream
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
elseif|else
if|if
condition|(
name|off
operator|<
literal|0
operator|||
name|len
argument_list|<
literal|0
operator|||
name|len
argument_list|>
name|b
operator|.
name|length
operator|-
name|off
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|()
throw|;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
specifier|final
name|int
name|remaining
init|=
name|outBuffer
operator|.
name|remaining
argument_list|()
decl_stmt|;
if|if
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
name|int
name|n
init|=
name|Math
operator|.
name|min
argument_list|(
name|len
argument_list|,
name|remaining
argument_list|)
decl_stmt|;
name|outBuffer
operator|.
name|get
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
else|else
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
comment|/*        * Check whether the underlying stream is {@link ByteBufferReadable},        * it can avoid bytes copy.        */
if|if
condition|(
name|usingByteBufferRead
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|isByteBufferReadable
operator|||
name|isReadableByteChannel
condition|)
block|{
try|try
block|{
name|n
operator|=
name|isByteBufferReadable
condition|?
operator|(
operator|(
name|ByteBufferReadable
operator|)
name|in
operator|)
operator|.
name|read
argument_list|(
name|inBuffer
argument_list|)
else|:
operator|(
operator|(
name|ReadableByteChannel
operator|)
name|in
operator|)
operator|.
name|read
argument_list|(
name|inBuffer
argument_list|)
expr_stmt|;
name|usingByteBufferRead
operator|=
name|Boolean
operator|.
name|TRUE
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
name|usingByteBufferRead
operator|=
name|Boolean
operator|.
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
name|usingByteBufferRead
operator|=
name|Boolean
operator|.
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|usingByteBufferRead
condition|)
block|{
name|n
operator|=
name|readFromUnderlyingStream
argument_list|(
name|inBuffer
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|usingByteBufferRead
condition|)
block|{
name|n
operator|=
name|isByteBufferReadable
condition|?
operator|(
operator|(
name|ByteBufferReadable
operator|)
name|in
operator|)
operator|.
name|read
argument_list|(
name|inBuffer
argument_list|)
else|:
operator|(
operator|(
name|ReadableByteChannel
operator|)
name|in
operator|)
operator|.
name|read
argument_list|(
name|inBuffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|readFromUnderlyingStream
argument_list|(
name|inBuffer
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
return|return
name|n
return|;
block|}
name|streamOffset
operator|+=
name|n
expr_stmt|;
comment|// Read n bytes
name|decrypt
argument_list|(
name|decryptor
argument_list|,
name|inBuffer
argument_list|,
name|outBuffer
argument_list|,
name|padding
argument_list|)
expr_stmt|;
name|padding
operator|=
name|afterDecryption
argument_list|(
name|decryptor
argument_list|,
name|inBuffer
argument_list|,
name|streamOffset
argument_list|,
name|iv
argument_list|)
expr_stmt|;
name|n
operator|=
name|Math
operator|.
name|min
argument_list|(
name|len
argument_list|,
name|outBuffer
operator|.
name|remaining
argument_list|()
argument_list|)
expr_stmt|;
name|outBuffer
operator|.
name|get
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
block|}
comment|/** Read data from underlying stream. */
DECL|method|readFromUnderlyingStream (ByteBuffer inBuffer)
specifier|private
name|int
name|readFromUnderlyingStream
parameter_list|(
name|ByteBuffer
name|inBuffer
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|toRead
init|=
name|inBuffer
operator|.
name|remaining
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|tmp
init|=
name|getTmpBuf
argument_list|()
decl_stmt|;
specifier|final
name|int
name|n
init|=
name|in
operator|.
name|read
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
name|toRead
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|inBuffer
operator|.
name|put
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
DECL|field|tmpBuf
specifier|private
name|byte
index|[]
name|tmpBuf
decl_stmt|;
DECL|method|getTmpBuf ()
specifier|private
name|byte
index|[]
name|getTmpBuf
parameter_list|()
block|{
if|if
condition|(
name|tmpBuf
operator|==
literal|null
condition|)
block|{
name|tmpBuf
operator|=
operator|new
name|byte
index|[
name|bufferSize
index|]
expr_stmt|;
block|}
return|return
name|tmpBuf
return|;
block|}
comment|/**    * Do the decryption using inBuffer as input and outBuffer as output.    * Upon return, inBuffer is cleared; the decrypted data starts at     * outBuffer.position() and ends at outBuffer.limit();    */
DECL|method|decrypt (Decryptor decryptor, ByteBuffer inBuffer, ByteBuffer outBuffer, byte padding)
specifier|private
name|void
name|decrypt
parameter_list|(
name|Decryptor
name|decryptor
parameter_list|,
name|ByteBuffer
name|inBuffer
parameter_list|,
name|ByteBuffer
name|outBuffer
parameter_list|,
name|byte
name|padding
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|inBuffer
operator|.
name|position
argument_list|()
operator|>=
name|padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|inBuffer
operator|.
name|position
argument_list|()
operator|==
name|padding
condition|)
block|{
comment|// There is no real data in inBuffer.
return|return;
block|}
name|inBuffer
operator|.
name|flip
argument_list|()
expr_stmt|;
name|outBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|decryptor
operator|.
name|decrypt
argument_list|(
name|inBuffer
argument_list|,
name|outBuffer
argument_list|)
expr_stmt|;
name|inBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|outBuffer
operator|.
name|flip
argument_list|()
expr_stmt|;
if|if
condition|(
name|padding
operator|>
literal|0
condition|)
block|{
comment|/*        * The plain text and cipher text have a 1:1 mapping, they start at the         * same position.        */
name|outBuffer
operator|.
name|position
argument_list|(
name|padding
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * This method is executed immediately after decryption. Check whether     * decryptor should be updated and recalculate padding if needed.     */
DECL|method|afterDecryption (Decryptor decryptor, ByteBuffer inBuffer, long position, byte[] iv)
specifier|private
name|byte
name|afterDecryption
parameter_list|(
name|Decryptor
name|decryptor
parameter_list|,
name|ByteBuffer
name|inBuffer
parameter_list|,
name|long
name|position
parameter_list|,
name|byte
index|[]
name|iv
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
name|padding
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|decryptor
operator|.
name|isContextReset
argument_list|()
condition|)
block|{
comment|/*        * This code is generally not executed since the decryptor usually         * maintains decryption context (e.g. the counter) internally. However,         * some implementations can't maintain context so a re-init is necessary         * after each decryption call.        */
name|updateDecryptor
argument_list|(
name|decryptor
argument_list|,
name|position
argument_list|,
name|iv
argument_list|)
expr_stmt|;
name|padding
operator|=
name|getPadding
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|inBuffer
operator|.
name|position
argument_list|(
name|padding
argument_list|)
expr_stmt|;
block|}
return|return
name|padding
return|;
block|}
DECL|method|getCounter (long position)
specifier|private
name|long
name|getCounter
parameter_list|(
name|long
name|position
parameter_list|)
block|{
return|return
name|position
operator|/
name|codec
operator|.
name|getCipherSuite
argument_list|()
operator|.
name|getAlgorithmBlockSize
argument_list|()
return|;
block|}
DECL|method|getPadding (long position)
specifier|private
name|byte
name|getPadding
parameter_list|(
name|long
name|position
parameter_list|)
block|{
return|return
call|(
name|byte
call|)
argument_list|(
name|position
operator|%
name|codec
operator|.
name|getCipherSuite
argument_list|()
operator|.
name|getAlgorithmBlockSize
argument_list|()
argument_list|)
return|;
block|}
comment|/** Calculate the counter and iv, update the decryptor. */
DECL|method|updateDecryptor (Decryptor decryptor, long position, byte[] iv)
specifier|private
name|void
name|updateDecryptor
parameter_list|(
name|Decryptor
name|decryptor
parameter_list|,
name|long
name|position
parameter_list|,
name|byte
index|[]
name|iv
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|long
name|counter
init|=
name|getCounter
argument_list|(
name|position
argument_list|)
decl_stmt|;
name|codec
operator|.
name|calculateIV
argument_list|(
name|initIV
argument_list|,
name|counter
argument_list|,
name|iv
argument_list|)
expr_stmt|;
name|decryptor
operator|.
name|init
argument_list|(
name|key
argument_list|,
name|iv
argument_list|)
expr_stmt|;
block|}
comment|/**    * Reset the underlying stream offset; clear {@link #inBuffer} and     * {@link #outBuffer}. This Typically happens during {@link #seek(long)}     * or {@link #skip(long)}.    */
DECL|method|resetStreamOffset (long offset)
specifier|private
name|void
name|resetStreamOffset
parameter_list|(
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|streamOffset
operator|=
name|offset
expr_stmt|;
name|inBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|outBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|outBuffer
operator|.
name|limit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|updateDecryptor
argument_list|(
name|decryptor
argument_list|,
name|offset
argument_list|,
name|iv
argument_list|)
expr_stmt|;
name|padding
operator|=
name|getPadding
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|inBuffer
operator|.
name|position
argument_list|(
name|padding
argument_list|)
expr_stmt|;
comment|// Set proper position for input data.
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|closed
condition|)
block|{
return|return;
block|}
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
name|freeBuffers
argument_list|()
expr_stmt|;
name|codec
operator|.
name|close
argument_list|()
expr_stmt|;
name|closed
operator|=
literal|true
expr_stmt|;
block|}
comment|/** Positioned read. It is thread-safe */
annotation|@
name|Override
DECL|method|read (long position, byte[] buffer, int offset, int length)
specifier|public
name|int
name|read
parameter_list|(
name|long
name|position
parameter_list|,
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|checkStream
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|in
operator|instanceof
name|PositionedReadable
operator|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This stream does not support "
operator|+
literal|"positioned read."
argument_list|)
throw|;
block|}
specifier|final
name|int
name|n
init|=
operator|(
operator|(
name|PositionedReadable
operator|)
name|in
operator|)
operator|.
name|read
argument_list|(
name|position
argument_list|,
name|buffer
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
comment|// This operation does not change the current offset of the file
name|decrypt
argument_list|(
name|position
argument_list|,
name|buffer
argument_list|,
name|offset
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
comment|/**    * Positioned read using {@link ByteBuffer}s. This method is thread-safe.    */
annotation|@
name|Override
DECL|method|read (long position, final ByteBuffer buf)
specifier|public
name|int
name|read
parameter_list|(
name|long
name|position
parameter_list|,
specifier|final
name|ByteBuffer
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|checkStream
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|in
operator|instanceof
name|ByteBufferPositionedReadable
operator|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This stream does not support "
operator|+
literal|"positioned reads with byte buffers."
argument_list|)
throw|;
block|}
name|int
name|bufPos
init|=
name|buf
operator|.
name|position
argument_list|()
decl_stmt|;
specifier|final
name|int
name|n
init|=
operator|(
operator|(
name|ByteBufferPositionedReadable
operator|)
name|in
operator|)
operator|.
name|read
argument_list|(
name|position
argument_list|,
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
comment|// This operation does not change the current offset of the file
name|decrypt
argument_list|(
name|position
argument_list|,
name|buf
argument_list|,
name|n
argument_list|,
name|bufPos
argument_list|)
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
comment|/**    * Decrypt length bytes in buffer starting at offset. Output is also put     * into buffer starting at offset. It is thread-safe.    */
DECL|method|decrypt (long position, byte[] buffer, int offset, int length)
specifier|private
name|void
name|decrypt
parameter_list|(
name|long
name|position
parameter_list|,
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteBuffer
name|localInBuffer
init|=
literal|null
decl_stmt|;
name|ByteBuffer
name|localOutBuffer
init|=
literal|null
decl_stmt|;
name|Decryptor
name|decryptor
init|=
literal|null
decl_stmt|;
try|try
block|{
name|localInBuffer
operator|=
name|getBuffer
argument_list|()
expr_stmt|;
name|localOutBuffer
operator|=
name|getBuffer
argument_list|()
expr_stmt|;
name|decryptor
operator|=
name|getDecryptor
argument_list|()
expr_stmt|;
name|byte
index|[]
name|iv
init|=
name|initIV
operator|.
name|clone
argument_list|()
decl_stmt|;
name|updateDecryptor
argument_list|(
name|decryptor
argument_list|,
name|position
argument_list|,
name|iv
argument_list|)
expr_stmt|;
name|byte
name|padding
init|=
name|getPadding
argument_list|(
name|position
argument_list|)
decl_stmt|;
name|localInBuffer
operator|.
name|position
argument_list|(
name|padding
argument_list|)
expr_stmt|;
comment|// Set proper position for input data.
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|n
operator|<
name|length
condition|)
block|{
name|int
name|toDecrypt
init|=
name|Math
operator|.
name|min
argument_list|(
name|length
operator|-
name|n
argument_list|,
name|localInBuffer
operator|.
name|remaining
argument_list|()
argument_list|)
decl_stmt|;
name|localInBuffer
operator|.
name|put
argument_list|(
name|buffer
argument_list|,
name|offset
operator|+
name|n
argument_list|,
name|toDecrypt
argument_list|)
expr_stmt|;
comment|// Do decryption
name|decrypt
argument_list|(
name|decryptor
argument_list|,
name|localInBuffer
argument_list|,
name|localOutBuffer
argument_list|,
name|padding
argument_list|)
expr_stmt|;
name|localOutBuffer
operator|.
name|get
argument_list|(
name|buffer
argument_list|,
name|offset
operator|+
name|n
argument_list|,
name|toDecrypt
argument_list|)
expr_stmt|;
name|n
operator|+=
name|toDecrypt
expr_stmt|;
name|padding
operator|=
name|afterDecryption
argument_list|(
name|decryptor
argument_list|,
name|localInBuffer
argument_list|,
name|position
operator|+
name|n
argument_list|,
name|iv
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|returnBuffer
argument_list|(
name|localInBuffer
argument_list|)
expr_stmt|;
name|returnBuffer
argument_list|(
name|localOutBuffer
argument_list|)
expr_stmt|;
name|returnDecryptor
argument_list|(
name|decryptor
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Decrypts the given {@link ByteBuffer} in place. {@code length} bytes are    * decrypted from {@code buf} starting at {@code start}.    * {@code buf.position()} and {@code buf.limit()} are unchanged after this    * method returns. This method is thread-safe.    *    *<p>    *   This method decrypts the input buf chunk-by-chunk and writes the    *   decrypted output back into the input buf. It uses two local buffers    *   taken from the {@link #bufferPool} to assist in this process: one is    *   designated as the input buffer and it stores a single chunk of the    *   given buf, the other is designated as the output buffer, which stores    *   the output of decrypting the input buffer. Both buffers are of size    *   {@link #bufferSize}.    *</p>    *    *<p>    *   Decryption is done by using a {@link Decryptor} and the    *   {@link #decrypt(Decryptor, ByteBuffer, ByteBuffer, byte)} method. Once    *   the decrypted data is written into the output buffer, is is copied back    *   into buf. Both buffers are returned back into the pool once the entire    *   buf is decrypted.    *</p>    *    * @param filePosition the current position of the file being read    * @param buf the {@link ByteBuffer} to decrypt    * @param length the number of bytes in {@code buf} to decrypt    * @param start the position in {@code buf} to start decrypting data from    */
DECL|method|decrypt (long filePosition, ByteBuffer buf, int length, int start)
specifier|private
name|void
name|decrypt
parameter_list|(
name|long
name|filePosition
parameter_list|,
name|ByteBuffer
name|buf
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|start
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteBuffer
name|localInBuffer
init|=
literal|null
decl_stmt|;
name|ByteBuffer
name|localOutBuffer
init|=
literal|null
decl_stmt|;
comment|// Duplicate the buffer so we don't have to worry about resetting the
comment|// original position and limit at the end of the method
name|buf
operator|=
name|buf
operator|.
name|duplicate
argument_list|()
expr_stmt|;
name|int
name|decryptedBytes
init|=
literal|0
decl_stmt|;
name|Decryptor
name|localDecryptor
init|=
literal|null
decl_stmt|;
try|try
block|{
name|localInBuffer
operator|=
name|getBuffer
argument_list|()
expr_stmt|;
name|localOutBuffer
operator|=
name|getBuffer
argument_list|()
expr_stmt|;
name|localDecryptor
operator|=
name|getDecryptor
argument_list|()
expr_stmt|;
name|byte
index|[]
name|localIV
init|=
name|initIV
operator|.
name|clone
argument_list|()
decl_stmt|;
name|updateDecryptor
argument_list|(
name|localDecryptor
argument_list|,
name|filePosition
argument_list|,
name|localIV
argument_list|)
expr_stmt|;
name|byte
name|localPadding
init|=
name|getPadding
argument_list|(
name|filePosition
argument_list|)
decl_stmt|;
comment|// Set proper filePosition for inputdata.
name|localInBuffer
operator|.
name|position
argument_list|(
name|localPadding
argument_list|)
expr_stmt|;
while|while
condition|(
name|decryptedBytes
operator|<
name|length
condition|)
block|{
name|buf
operator|.
name|position
argument_list|(
name|start
operator|+
name|decryptedBytes
argument_list|)
expr_stmt|;
name|buf
operator|.
name|limit
argument_list|(
name|start
operator|+
name|decryptedBytes
operator|+
name|Math
operator|.
name|min
argument_list|(
name|length
operator|-
name|decryptedBytes
argument_list|,
name|localInBuffer
operator|.
name|remaining
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|localInBuffer
operator|.
name|put
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|// Do decryption
try|try
block|{
name|decrypt
argument_list|(
name|localDecryptor
argument_list|,
name|localInBuffer
argument_list|,
name|localOutBuffer
argument_list|,
name|localPadding
argument_list|)
expr_stmt|;
name|buf
operator|.
name|position
argument_list|(
name|start
operator|+
name|decryptedBytes
argument_list|)
expr_stmt|;
name|buf
operator|.
name|limit
argument_list|(
name|start
operator|+
name|length
argument_list|)
expr_stmt|;
name|decryptedBytes
operator|+=
name|localOutBuffer
operator|.
name|remaining
argument_list|()
expr_stmt|;
name|buf
operator|.
name|put
argument_list|(
name|localOutBuffer
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|localPadding
operator|=
name|afterDecryption
argument_list|(
name|localDecryptor
argument_list|,
name|localInBuffer
argument_list|,
name|filePosition
operator|+
name|length
argument_list|,
name|localIV
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|returnBuffer
argument_list|(
name|localInBuffer
argument_list|)
expr_stmt|;
name|returnBuffer
argument_list|(
name|localOutBuffer
argument_list|)
expr_stmt|;
name|returnDecryptor
argument_list|(
name|localDecryptor
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Positioned read fully. It is thread-safe */
annotation|@
name|Override
DECL|method|readFully (long position, byte[] buffer, int offset, int length)
specifier|public
name|void
name|readFully
parameter_list|(
name|long
name|position
parameter_list|,
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|checkStream
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|in
operator|instanceof
name|PositionedReadable
operator|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This stream does not support "
operator|+
literal|"positioned readFully."
argument_list|)
throw|;
block|}
operator|(
operator|(
name|PositionedReadable
operator|)
name|in
operator|)
operator|.
name|readFully
argument_list|(
name|position
argument_list|,
name|buffer
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
comment|// This operation does not change the current offset of the file
name|decrypt
argument_list|(
name|position
argument_list|,
name|buffer
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|readFully (long position, byte[] buffer)
specifier|public
name|void
name|readFully
parameter_list|(
name|long
name|position
parameter_list|,
name|byte
index|[]
name|buffer
parameter_list|)
throws|throws
name|IOException
block|{
name|readFully
argument_list|(
name|position
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|buffer
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/** Seek to a position. */
annotation|@
name|Override
DECL|method|seek (long pos)
specifier|public
name|void
name|seek
parameter_list|(
name|long
name|pos
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
name|FSExceptionMessages
operator|.
name|NEGATIVE_SEEK
argument_list|)
throw|;
block|}
name|checkStream
argument_list|()
expr_stmt|;
comment|/*      * If data of target pos in the underlying stream has already been read      * and decrypted in outBuffer, we just need to re-position outBuffer.      */
if|if
condition|(
name|pos
operator|<=
name|streamOffset
operator|&&
name|pos
operator|>=
operator|(
name|streamOffset
operator|-
name|outBuffer
operator|.
name|remaining
argument_list|()
operator|)
condition|)
block|{
name|int
name|forward
init|=
call|(
name|int
call|)
argument_list|(
name|pos
operator|-
operator|(
name|streamOffset
operator|-
name|outBuffer
operator|.
name|remaining
argument_list|()
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|forward
operator|>
literal|0
condition|)
block|{
name|outBuffer
operator|.
name|position
argument_list|(
name|outBuffer
operator|.
name|position
argument_list|()
operator|+
name|forward
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|in
operator|instanceof
name|Seekable
operator|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This stream does not "
operator|+
literal|"support seek."
argument_list|)
throw|;
block|}
operator|(
operator|(
name|Seekable
operator|)
name|in
operator|)
operator|.
name|seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|resetStreamOffset
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Skip n bytes */
annotation|@
name|Override
DECL|method|skip (long n)
specifier|public
name|long
name|skip
parameter_list|(
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|n
operator|>=
literal|0
argument_list|,
literal|"Negative skip length."
argument_list|)
expr_stmt|;
name|checkStream
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|<=
name|outBuffer
operator|.
name|remaining
argument_list|()
condition|)
block|{
name|int
name|pos
init|=
name|outBuffer
operator|.
name|position
argument_list|()
operator|+
operator|(
name|int
operator|)
name|n
decl_stmt|;
name|outBuffer
operator|.
name|position
argument_list|(
name|pos
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
else|else
block|{
comment|/*        * Subtract outBuffer.remaining() to see how many bytes we need to         * skip in the underlying stream. Add outBuffer.remaining() to the         * actual number of skipped bytes in the underlying stream to get the         * number of skipped bytes from the user's point of view.        */
name|n
operator|-=
name|outBuffer
operator|.
name|remaining
argument_list|()
expr_stmt|;
name|long
name|skipped
init|=
name|in
operator|.
name|skip
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|skipped
operator|<
literal|0
condition|)
block|{
name|skipped
operator|=
literal|0
expr_stmt|;
block|}
name|long
name|pos
init|=
name|streamOffset
operator|+
name|skipped
decl_stmt|;
name|skipped
operator|+=
name|outBuffer
operator|.
name|remaining
argument_list|()
expr_stmt|;
name|resetStreamOffset
argument_list|(
name|pos
argument_list|)
expr_stmt|;
return|return
name|skipped
return|;
block|}
block|}
comment|/** Get underlying stream position. */
annotation|@
name|Override
DECL|method|getPos ()
specifier|public
name|long
name|getPos
parameter_list|()
throws|throws
name|IOException
block|{
name|checkStream
argument_list|()
expr_stmt|;
comment|// Equals: ((Seekable) in).getPos() - outBuffer.remaining()
return|return
name|streamOffset
operator|-
name|outBuffer
operator|.
name|remaining
argument_list|()
return|;
block|}
comment|/** ByteBuffer read. */
annotation|@
name|Override
DECL|method|read (ByteBuffer buf)
specifier|public
name|int
name|read
parameter_list|(
name|ByteBuffer
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|checkStream
argument_list|()
expr_stmt|;
if|if
condition|(
name|isByteBufferReadable
operator|||
name|isReadableByteChannel
condition|)
block|{
specifier|final
name|int
name|unread
init|=
name|outBuffer
operator|.
name|remaining
argument_list|()
decl_stmt|;
if|if
condition|(
name|unread
operator|>
literal|0
condition|)
block|{
comment|// Have unread decrypted data in buffer.
name|int
name|toRead
init|=
name|buf
operator|.
name|remaining
argument_list|()
decl_stmt|;
if|if
condition|(
name|toRead
operator|<=
name|unread
condition|)
block|{
specifier|final
name|int
name|limit
init|=
name|outBuffer
operator|.
name|limit
argument_list|()
decl_stmt|;
name|outBuffer
operator|.
name|limit
argument_list|(
name|outBuffer
operator|.
name|position
argument_list|()
operator|+
name|toRead
argument_list|)
expr_stmt|;
name|buf
operator|.
name|put
argument_list|(
name|outBuffer
argument_list|)
expr_stmt|;
name|outBuffer
operator|.
name|limit
argument_list|(
name|limit
argument_list|)
expr_stmt|;
return|return
name|toRead
return|;
block|}
else|else
block|{
name|buf
operator|.
name|put
argument_list|(
name|outBuffer
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|int
name|pos
init|=
name|buf
operator|.
name|position
argument_list|()
decl_stmt|;
specifier|final
name|int
name|n
init|=
name|isByteBufferReadable
condition|?
operator|(
operator|(
name|ByteBufferReadable
operator|)
name|in
operator|)
operator|.
name|read
argument_list|(
name|buf
argument_list|)
else|:
operator|(
operator|(
name|ReadableByteChannel
operator|)
name|in
operator|)
operator|.
name|read
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|streamOffset
operator|+=
name|n
expr_stmt|;
comment|// Read n bytes
name|decrypt
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
return|return
name|unread
operator|+
name|n
return|;
block|}
else|else
block|{
if|if
condition|(
name|unread
operator|==
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
name|unread
return|;
block|}
block|}
block|}
else|else
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|buf
operator|.
name|hasArray
argument_list|()
condition|)
block|{
name|n
operator|=
name|read
argument_list|(
name|buf
operator|.
name|array
argument_list|()
argument_list|,
name|buf
operator|.
name|position
argument_list|()
argument_list|,
name|buf
operator|.
name|remaining
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|position
argument_list|(
name|buf
operator|.
name|position
argument_list|()
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|byte
index|[]
name|tmp
init|=
operator|new
name|byte
index|[
name|buf
operator|.
name|remaining
argument_list|()
index|]
decl_stmt|;
name|n
operator|=
name|read
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|put
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|n
return|;
block|}
block|}
comment|/**    * Decrypts the given {@link ByteBuffer} in place. {@code length} bytes are    * decrypted from {@code buf} starting at {@code start}.    * {@code buf.position()} and {@code buf.limit()} are unchanged after this    * method returns.    *    * @see #decrypt(long, ByteBuffer, int, int)    */
DECL|method|decrypt (ByteBuffer buf, int length, int start)
specifier|private
name|void
name|decrypt
parameter_list|(
name|ByteBuffer
name|buf
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|start
parameter_list|)
throws|throws
name|IOException
block|{
name|buf
operator|=
name|buf
operator|.
name|duplicate
argument_list|()
expr_stmt|;
name|int
name|decryptedBytes
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|decryptedBytes
operator|<
name|length
condition|)
block|{
name|buf
operator|.
name|position
argument_list|(
name|start
operator|+
name|decryptedBytes
argument_list|)
expr_stmt|;
name|buf
operator|.
name|limit
argument_list|(
name|start
operator|+
name|decryptedBytes
operator|+
name|Math
operator|.
name|min
argument_list|(
name|length
operator|-
name|decryptedBytes
argument_list|,
name|inBuffer
operator|.
name|remaining
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|inBuffer
operator|.
name|put
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|// Do decryption
try|try
block|{
name|decrypt
argument_list|(
name|decryptor
argument_list|,
name|inBuffer
argument_list|,
name|outBuffer
argument_list|,
name|padding
argument_list|)
expr_stmt|;
name|buf
operator|.
name|position
argument_list|(
name|start
operator|+
name|decryptedBytes
argument_list|)
expr_stmt|;
name|buf
operator|.
name|limit
argument_list|(
name|start
operator|+
name|length
argument_list|)
expr_stmt|;
name|decryptedBytes
operator|+=
name|outBuffer
operator|.
name|remaining
argument_list|()
expr_stmt|;
name|buf
operator|.
name|put
argument_list|(
name|outBuffer
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|padding
operator|=
name|afterDecryption
argument_list|(
name|decryptor
argument_list|,
name|inBuffer
argument_list|,
name|streamOffset
operator|-
operator|(
name|length
operator|-
name|decryptedBytes
operator|)
argument_list|,
name|iv
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|available ()
specifier|public
name|int
name|available
parameter_list|()
throws|throws
name|IOException
block|{
name|checkStream
argument_list|()
expr_stmt|;
return|return
name|in
operator|.
name|available
argument_list|()
operator|+
name|outBuffer
operator|.
name|remaining
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|markSupported ()
specifier|public
name|boolean
name|markSupported
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|mark (int readLimit)
specifier|public
name|void
name|mark
parameter_list|(
name|int
name|readLimit
parameter_list|)
block|{   }
annotation|@
name|Override
DECL|method|reset ()
specifier|public
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mark/reset not supported"
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|seekToNewSource (long targetPos)
specifier|public
name|boolean
name|seekToNewSource
parameter_list|(
name|long
name|targetPos
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|targetPos
operator|>=
literal|0
argument_list|,
literal|"Cannot seek to negative offset."
argument_list|)
expr_stmt|;
name|checkStream
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|in
operator|instanceof
name|Seekable
operator|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This stream does not support "
operator|+
literal|"seekToNewSource."
argument_list|)
throw|;
block|}
name|boolean
name|result
init|=
operator|(
operator|(
name|Seekable
operator|)
name|in
operator|)
operator|.
name|seekToNewSource
argument_list|(
name|targetPos
argument_list|)
decl_stmt|;
name|resetStreamOffset
argument_list|(
name|targetPos
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|read (ByteBufferPool bufferPool, int maxLength, EnumSet<ReadOption> opts)
specifier|public
name|ByteBuffer
name|read
parameter_list|(
name|ByteBufferPool
name|bufferPool
parameter_list|,
name|int
name|maxLength
parameter_list|,
name|EnumSet
argument_list|<
name|ReadOption
argument_list|>
name|opts
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnsupportedOperationException
block|{
name|checkStream
argument_list|()
expr_stmt|;
if|if
condition|(
name|outBuffer
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|in
operator|instanceof
name|Seekable
operator|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This stream does not "
operator|+
literal|"support seek."
argument_list|)
throw|;
block|}
comment|// Have some decrypted data unread, need to reset.
operator|(
operator|(
name|Seekable
operator|)
name|in
operator|)
operator|.
name|seek
argument_list|(
name|getPos
argument_list|()
argument_list|)
expr_stmt|;
name|resetStreamOffset
argument_list|(
name|getPos
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|in
operator|instanceof
name|HasEnhancedByteBufferAccess
operator|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This stream does not support "
operator|+
literal|"enhanced byte buffer access."
argument_list|)
throw|;
block|}
specifier|final
name|ByteBuffer
name|buffer
init|=
operator|(
operator|(
name|HasEnhancedByteBufferAccess
operator|)
name|in
operator|)
operator|.
name|read
argument_list|(
name|bufferPool
argument_list|,
name|maxLength
argument_list|,
name|opts
argument_list|)
decl_stmt|;
if|if
condition|(
name|buffer
operator|!=
literal|null
condition|)
block|{
specifier|final
name|int
name|n
init|=
name|buffer
operator|.
name|remaining
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|streamOffset
operator|+=
name|buffer
operator|.
name|remaining
argument_list|()
expr_stmt|;
comment|// Read n bytes
specifier|final
name|int
name|pos
init|=
name|buffer
operator|.
name|position
argument_list|()
decl_stmt|;
name|decrypt
argument_list|(
name|buffer
argument_list|,
name|n
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buffer
return|;
block|}
annotation|@
name|Override
DECL|method|releaseBuffer (ByteBuffer buffer)
specifier|public
name|void
name|releaseBuffer
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|in
operator|instanceof
name|HasEnhancedByteBufferAccess
operator|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This stream does not support "
operator|+
literal|"release buffer."
argument_list|)
throw|;
block|}
operator|(
operator|(
name|HasEnhancedByteBufferAccess
operator|)
name|in
operator|)
operator|.
name|releaseBuffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setReadahead (Long readahead)
specifier|public
name|void
name|setReadahead
parameter_list|(
name|Long
name|readahead
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnsupportedOperationException
block|{
if|if
condition|(
operator|!
operator|(
name|in
operator|instanceof
name|CanSetReadahead
operator|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This stream does not support "
operator|+
literal|"setting the readahead caching strategy."
argument_list|)
throw|;
block|}
operator|(
operator|(
name|CanSetReadahead
operator|)
name|in
operator|)
operator|.
name|setReadahead
argument_list|(
name|readahead
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|setDropBehind (Boolean dropCache)
specifier|public
name|void
name|setDropBehind
parameter_list|(
name|Boolean
name|dropCache
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnsupportedOperationException
block|{
if|if
condition|(
operator|!
operator|(
name|in
operator|instanceof
name|CanSetReadahead
operator|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This stream does not "
operator|+
literal|"support setting the drop-behind caching setting."
argument_list|)
throw|;
block|}
operator|(
operator|(
name|CanSetDropBehind
operator|)
name|in
operator|)
operator|.
name|setDropBehind
argument_list|(
name|dropCache
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getFileDescriptor ()
specifier|public
name|FileDescriptor
name|getFileDescriptor
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|in
operator|instanceof
name|HasFileDescriptor
condition|)
block|{
return|return
operator|(
operator|(
name|HasFileDescriptor
operator|)
name|in
operator|)
operator|.
name|getFileDescriptor
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|in
operator|instanceof
name|FileInputStream
condition|)
block|{
return|return
operator|(
operator|(
name|FileInputStream
operator|)
name|in
operator|)
operator|.
name|getFD
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|read ()
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|(
name|read
argument_list|(
name|oneByteBuf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
name|oneByteBuf
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
return|;
block|}
DECL|method|checkStream ()
specifier|private
name|void
name|checkStream
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|closed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stream closed"
argument_list|)
throw|;
block|}
block|}
comment|/** Get direct buffer from pool */
DECL|method|getBuffer ()
specifier|private
name|ByteBuffer
name|getBuffer
parameter_list|()
block|{
name|ByteBuffer
name|buffer
init|=
name|bufferPool
operator|.
name|poll
argument_list|()
decl_stmt|;
if|if
condition|(
name|buffer
operator|==
literal|null
condition|)
block|{
name|buffer
operator|=
name|ByteBuffer
operator|.
name|allocateDirect
argument_list|(
name|bufferSize
argument_list|)
expr_stmt|;
block|}
return|return
name|buffer
return|;
block|}
comment|/** Return direct buffer to pool */
DECL|method|returnBuffer (ByteBuffer buf)
specifier|private
name|void
name|returnBuffer
parameter_list|(
name|ByteBuffer
name|buf
parameter_list|)
block|{
if|if
condition|(
name|buf
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|clear
argument_list|()
expr_stmt|;
name|bufferPool
operator|.
name|add
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Forcibly free the direct buffers. */
DECL|method|freeBuffers ()
specifier|private
name|void
name|freeBuffers
parameter_list|()
block|{
name|CryptoStreamUtils
operator|.
name|freeDB
argument_list|(
name|inBuffer
argument_list|)
expr_stmt|;
name|CryptoStreamUtils
operator|.
name|freeDB
argument_list|(
name|outBuffer
argument_list|)
expr_stmt|;
name|cleanBufferPool
argument_list|()
expr_stmt|;
block|}
comment|/** Clean direct buffer pool */
DECL|method|cleanBufferPool ()
specifier|private
name|void
name|cleanBufferPool
parameter_list|()
block|{
name|ByteBuffer
name|buf
decl_stmt|;
while|while
condition|(
operator|(
name|buf
operator|=
name|bufferPool
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|CryptoStreamUtils
operator|.
name|freeDB
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Get decryptor from pool */
DECL|method|getDecryptor ()
specifier|private
name|Decryptor
name|getDecryptor
parameter_list|()
throws|throws
name|IOException
block|{
name|Decryptor
name|decryptor
init|=
name|decryptorPool
operator|.
name|poll
argument_list|()
decl_stmt|;
if|if
condition|(
name|decryptor
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|decryptor
operator|=
name|codec
operator|.
name|createDecryptor
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|GeneralSecurityException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|decryptor
return|;
block|}
comment|/** Return decryptor to pool */
DECL|method|returnDecryptor (Decryptor decryptor)
specifier|private
name|void
name|returnDecryptor
parameter_list|(
name|Decryptor
name|decryptor
parameter_list|)
block|{
if|if
condition|(
name|decryptor
operator|!=
literal|null
condition|)
block|{
name|decryptorPool
operator|.
name|add
argument_list|(
name|decryptor
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|isOpen ()
specifier|public
name|boolean
name|isOpen
parameter_list|()
block|{
return|return
operator|!
name|closed
return|;
block|}
DECL|method|cleanDecryptorPool ()
specifier|private
name|void
name|cleanDecryptorPool
parameter_list|()
block|{
name|decryptorPool
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|unbuffer ()
specifier|public
name|void
name|unbuffer
parameter_list|()
block|{
name|cleanBufferPool
argument_list|()
expr_stmt|;
name|cleanDecryptorPool
argument_list|()
expr_stmt|;
name|StreamCapabilitiesPolicy
operator|.
name|unbuffer
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasCapability (String capability)
specifier|public
name|boolean
name|hasCapability
parameter_list|(
name|String
name|capability
parameter_list|)
block|{
switch|switch
condition|(
name|StringUtils
operator|.
name|toLowerCase
argument_list|(
name|capability
argument_list|)
condition|)
block|{
case|case
name|StreamCapabilities
operator|.
name|UNBUFFER
case|:
return|return
literal|true
return|;
case|case
name|StreamCapabilities
operator|.
name|READAHEAD
case|:
case|case
name|StreamCapabilities
operator|.
name|DROPBEHIND
case|:
case|case
name|StreamCapabilities
operator|.
name|READBYTEBUFFER
case|:
case|case
name|StreamCapabilities
operator|.
name|PREADBYTEBUFFER
case|:
if|if
condition|(
operator|!
operator|(
name|in
operator|instanceof
name|StreamCapabilities
operator|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This stream does not expose "
operator|+
literal|"its stream capabilities."
argument_list|)
throw|;
block|}
return|return
operator|(
operator|(
name|StreamCapabilities
operator|)
name|in
operator|)
operator|.
name|hasCapability
argument_list|(
name|capability
argument_list|)
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
block|}
end_class

end_unit

