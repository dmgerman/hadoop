begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.crypto
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|crypto
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileDescriptor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|GeneralSecurityException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ByteBufferReadable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CanSetDropBehind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CanSetReadahead
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|HasEnhancedByteBufferAccess
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|HasFileDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|PositionedReadable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|ReadOption
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Seekable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|ByteBufferPool
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_SECURITY_CRYPTO_BUFFER_SIZE_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|HADOOP_SECURITY_CRYPTO_BUFFER_SIZE_DEFAULT
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_comment
comment|/**  * CryptoInputStream decrypts data. It is not thread-safe. AES CTR mode is  * required in order to ensure that the plain text and cipher text have a 1:1  * mapping. The decryption is buffer based. The key points of the decryption  * are (1) calculating the counter and (2) padding through stream position:  *<p/>  * counter = base + pos/(algorithm blocksize);   * padding = pos%(algorithm blocksize);   *<p/>  * The underlying stream offset is maintained as state.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|CryptoInputStream
specifier|public
class|class
name|CryptoInputStream
extends|extends
name|FilterInputStream
implements|implements
name|Seekable
implements|,
name|PositionedReadable
implements|,
name|ByteBufferReadable
implements|,
name|HasFileDescriptor
implements|,
name|CanSetDropBehind
implements|,
name|CanSetReadahead
implements|,
name|HasEnhancedByteBufferAccess
block|{
DECL|field|MIN_BUFFER_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|MIN_BUFFER_SIZE
init|=
literal|512
decl_stmt|;
DECL|field|oneByteBuf
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|oneByteBuf
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
DECL|field|codec
specifier|private
specifier|final
name|CryptoCodec
name|codec
decl_stmt|;
DECL|field|decryptor
specifier|private
specifier|final
name|Decryptor
name|decryptor
decl_stmt|;
comment|/**    * Input data buffer. The data starts at inBuffer.position() and ends at     * to inBuffer.limit().    */
DECL|field|inBuffer
specifier|private
name|ByteBuffer
name|inBuffer
decl_stmt|;
comment|/**    * The decrypted data buffer. The data starts at outBuffer.position() and     * ends at outBuffer.limit();    */
DECL|field|outBuffer
specifier|private
name|ByteBuffer
name|outBuffer
decl_stmt|;
DECL|field|streamOffset
specifier|private
name|long
name|streamOffset
init|=
literal|0
decl_stmt|;
comment|// Underlying stream offset.
comment|/**    * Whether underlying stream supports     * {@link #org.apache.hadoop.fs.ByteBufferReadable}    */
DECL|field|usingByteBufferRead
specifier|private
name|Boolean
name|usingByteBufferRead
init|=
literal|null
decl_stmt|;
comment|/**    * Padding = pos%(algorithm blocksize); Padding is put into {@link #inBuffer}     * before any other data goes in. The purpose of padding is to put input data    * at proper position.    */
DECL|field|padding
specifier|private
name|byte
name|padding
decl_stmt|;
DECL|field|closed
specifier|private
name|boolean
name|closed
decl_stmt|;
DECL|field|key
specifier|private
specifier|final
name|byte
index|[]
name|key
decl_stmt|;
DECL|field|initIV
specifier|private
specifier|final
name|byte
index|[]
name|initIV
decl_stmt|;
DECL|field|iv
specifier|private
name|byte
index|[]
name|iv
decl_stmt|;
DECL|method|CryptoInputStream (InputStream in, CryptoCodec codec, int bufferSize, byte[] key, byte[] iv)
specifier|public
name|CryptoInputStream
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|CryptoCodec
name|codec
parameter_list|,
name|int
name|bufferSize
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|byte
index|[]
name|iv
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|bufferSize
operator|>=
name|MIN_BUFFER_SIZE
argument_list|,
literal|"Minimum value of buffer size is 512."
argument_list|)
expr_stmt|;
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|initIV
operator|=
name|iv
expr_stmt|;
name|this
operator|.
name|iv
operator|=
name|iv
operator|.
name|clone
argument_list|()
expr_stmt|;
name|inBuffer
operator|=
name|ByteBuffer
operator|.
name|allocateDirect
argument_list|(
name|bufferSize
argument_list|)
expr_stmt|;
name|outBuffer
operator|=
name|ByteBuffer
operator|.
name|allocateDirect
argument_list|(
name|bufferSize
argument_list|)
expr_stmt|;
name|outBuffer
operator|.
name|limit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|this
operator|.
name|codec
operator|=
name|codec
expr_stmt|;
try|try
block|{
name|decryptor
operator|=
name|codec
operator|.
name|getDecryptor
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|GeneralSecurityException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|in
operator|instanceof
name|Seekable
condition|)
block|{
name|streamOffset
operator|=
operator|(
operator|(
name|Seekable
operator|)
name|in
operator|)
operator|.
name|getPos
argument_list|()
expr_stmt|;
block|}
name|updateDecryptor
argument_list|()
expr_stmt|;
block|}
DECL|method|CryptoInputStream (InputStream in, CryptoCodec codec, byte[] key, byte[] iv)
specifier|public
name|CryptoInputStream
parameter_list|(
name|InputStream
name|in
parameter_list|,
name|CryptoCodec
name|codec
parameter_list|,
name|byte
index|[]
name|key
parameter_list|,
name|byte
index|[]
name|iv
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|in
argument_list|,
name|codec
argument_list|,
name|getBufferSize
argument_list|(
name|codec
operator|.
name|getConf
argument_list|()
argument_list|)
argument_list|,
name|key
argument_list|,
name|iv
argument_list|)
expr_stmt|;
block|}
DECL|method|getWrappedStream ()
specifier|public
name|InputStream
name|getWrappedStream
parameter_list|()
block|{
return|return
name|in
return|;
block|}
comment|/**    * Decryption is buffer based.    * If there is data in {@link #outBuffer}, then read it out of this buffer.    * If there is no data in {@link #outBuffer}, then read more from the     * underlying stream and do the decryption.    * @param b the buffer into which the decrypted data is read.    * @param off the buffer offset.    * @param len the maximum number of decrypted data bytes to read.    * @return int the total number of decrypted data bytes read into the buffer.    * @throws IOException    */
annotation|@
name|Override
DECL|method|read (byte[] b, int off, int len)
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|checkStream
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
elseif|else
if|if
condition|(
name|off
operator|<
literal|0
operator|||
name|len
argument_list|<
literal|0
operator|||
name|len
argument_list|>
name|b
operator|.
name|length
operator|-
name|off
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|()
throw|;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|remaining
init|=
name|outBuffer
operator|.
name|remaining
argument_list|()
decl_stmt|;
if|if
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
name|int
name|n
init|=
name|Math
operator|.
name|min
argument_list|(
name|len
argument_list|,
name|remaining
argument_list|)
decl_stmt|;
name|outBuffer
operator|.
name|get
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
else|else
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
comment|/**        * Check whether the underlying stream is {@link ByteBufferReadable},        * it can avoid bytes copy.        */
if|if
condition|(
name|usingByteBufferRead
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|in
operator|instanceof
name|ByteBufferReadable
condition|)
block|{
try|try
block|{
name|n
operator|=
operator|(
operator|(
name|ByteBufferReadable
operator|)
name|in
operator|)
operator|.
name|read
argument_list|(
name|inBuffer
argument_list|)
expr_stmt|;
name|usingByteBufferRead
operator|=
name|Boolean
operator|.
name|TRUE
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
name|usingByteBufferRead
operator|=
name|Boolean
operator|.
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|usingByteBufferRead
operator|.
name|booleanValue
argument_list|()
condition|)
block|{
name|n
operator|=
name|readFromUnderlyingStream
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|usingByteBufferRead
operator|.
name|booleanValue
argument_list|()
condition|)
block|{
name|n
operator|=
operator|(
operator|(
name|ByteBufferReadable
operator|)
name|in
operator|)
operator|.
name|read
argument_list|(
name|inBuffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|readFromUnderlyingStream
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
return|return
name|n
return|;
block|}
name|streamOffset
operator|+=
name|n
expr_stmt|;
comment|// Read n bytes
name|decrypt
argument_list|()
expr_stmt|;
name|n
operator|=
name|Math
operator|.
name|min
argument_list|(
name|len
argument_list|,
name|outBuffer
operator|.
name|remaining
argument_list|()
argument_list|)
expr_stmt|;
name|outBuffer
operator|.
name|get
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
block|}
comment|// Read data from underlying stream.
DECL|method|readFromUnderlyingStream ()
specifier|private
name|int
name|readFromUnderlyingStream
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|toRead
init|=
name|inBuffer
operator|.
name|remaining
argument_list|()
decl_stmt|;
name|byte
index|[]
name|tmp
init|=
name|getTmpBuf
argument_list|()
decl_stmt|;
name|int
name|n
init|=
name|in
operator|.
name|read
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
name|toRead
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|inBuffer
operator|.
name|put
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
DECL|field|tmpBuf
specifier|private
name|byte
index|[]
name|tmpBuf
decl_stmt|;
DECL|method|getTmpBuf ()
specifier|private
name|byte
index|[]
name|getTmpBuf
parameter_list|()
block|{
if|if
condition|(
name|tmpBuf
operator|==
literal|null
condition|)
block|{
name|tmpBuf
operator|=
operator|new
name|byte
index|[
name|inBuffer
operator|.
name|capacity
argument_list|()
index|]
expr_stmt|;
block|}
return|return
name|tmpBuf
return|;
block|}
comment|/**    * Do the decryption using {@link #inBuffer} as input and {@link #outBuffer}     * as output.    */
DECL|method|decrypt ()
specifier|private
name|void
name|decrypt
parameter_list|()
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|inBuffer
operator|.
name|position
argument_list|()
operator|>=
name|padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|inBuffer
operator|.
name|position
argument_list|()
operator|==
name|padding
condition|)
block|{
comment|// There is no real data in inBuffer.
return|return;
block|}
name|inBuffer
operator|.
name|flip
argument_list|()
expr_stmt|;
name|outBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|decryptor
operator|.
name|decrypt
argument_list|(
name|inBuffer
argument_list|,
name|outBuffer
argument_list|)
expr_stmt|;
name|inBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|outBuffer
operator|.
name|flip
argument_list|()
expr_stmt|;
if|if
condition|(
name|padding
operator|>
literal|0
condition|)
block|{
comment|/**        * The plain text and cipher text have 1:1 mapping, they start at same         * position.        */
name|outBuffer
operator|.
name|position
argument_list|(
name|padding
argument_list|)
expr_stmt|;
name|padding
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|decryptor
operator|.
name|isContextReset
argument_list|()
condition|)
block|{
comment|/**        * Typically we will not get here. To improve performance in CTR mode,        * we rely on the decryptor maintaining context, for example calculating         * the counter. Unfortunately, some bad implementations can't maintain         * context so we need to re-init after doing decryption.        */
name|updateDecryptor
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Update the {@link #decryptor}. Calculate the counter and {@link #padding}.    */
DECL|method|updateDecryptor ()
specifier|private
name|void
name|updateDecryptor
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|counter
init|=
name|streamOffset
operator|/
name|codec
operator|.
name|getAlgorithmBlockSize
argument_list|()
decl_stmt|;
name|padding
operator|=
call|(
name|byte
call|)
argument_list|(
name|streamOffset
operator|%
name|codec
operator|.
name|getAlgorithmBlockSize
argument_list|()
argument_list|)
expr_stmt|;
name|inBuffer
operator|.
name|position
argument_list|(
name|padding
argument_list|)
expr_stmt|;
comment|// Set proper position for input data.
name|codec
operator|.
name|calculateIV
argument_list|(
name|initIV
argument_list|,
name|counter
argument_list|,
name|iv
argument_list|)
expr_stmt|;
name|decryptor
operator|.
name|init
argument_list|(
name|key
argument_list|,
name|iv
argument_list|)
expr_stmt|;
block|}
comment|/**    * Reset the underlying stream offset; and clear {@link #inBuffer} and     * {@link #outBuffer}. Typically this happens when doing {@link #seek(long)}     * or {@link #skip(long)}.    */
DECL|method|resetStreamOffset (long offset)
specifier|private
name|void
name|resetStreamOffset
parameter_list|(
name|long
name|offset
parameter_list|)
throws|throws
name|IOException
block|{
name|streamOffset
operator|=
name|offset
expr_stmt|;
name|inBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|outBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|outBuffer
operator|.
name|limit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|updateDecryptor
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|closed
condition|)
block|{
return|return;
block|}
name|super
operator|.
name|close
argument_list|()
expr_stmt|;
name|freeBuffers
argument_list|()
expr_stmt|;
name|closed
operator|=
literal|true
expr_stmt|;
block|}
comment|/**    * Free the direct buffer manually.    */
DECL|method|freeBuffers ()
specifier|private
name|void
name|freeBuffers
parameter_list|()
block|{
name|sun
operator|.
name|misc
operator|.
name|Cleaner
name|inBufferCleaner
init|=
operator|(
operator|(
name|sun
operator|.
name|nio
operator|.
name|ch
operator|.
name|DirectBuffer
operator|)
name|inBuffer
operator|)
operator|.
name|cleaner
argument_list|()
decl_stmt|;
name|inBufferCleaner
operator|.
name|clean
argument_list|()
expr_stmt|;
name|sun
operator|.
name|misc
operator|.
name|Cleaner
name|outBufferCleaner
init|=
operator|(
operator|(
name|sun
operator|.
name|nio
operator|.
name|ch
operator|.
name|DirectBuffer
operator|)
name|outBuffer
operator|)
operator|.
name|cleaner
argument_list|()
decl_stmt|;
name|outBufferCleaner
operator|.
name|clean
argument_list|()
expr_stmt|;
block|}
comment|// Positioned read.
annotation|@
name|Override
DECL|method|read (long position, byte[] buffer, int offset, int length)
specifier|public
name|int
name|read
parameter_list|(
name|long
name|position
parameter_list|,
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|checkStream
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|n
init|=
operator|(
operator|(
name|PositionedReadable
operator|)
name|in
operator|)
operator|.
name|read
argument_list|(
name|position
argument_list|,
name|buffer
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
comment|/**           * Since this operation does not change the current offset of a file,           * streamOffset should be not changed and we need to restore the           * decryptor and outBuffer after decryption.          */
name|decrypt
argument_list|(
name|position
argument_list|,
name|buffer
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This stream does not support "
operator|+
literal|"positioned read."
argument_list|)
throw|;
block|}
block|}
comment|/**    * Decrypt given length of data in buffer: start from offset.    * Output is also buffer and start from same offset. Restore the     * {@link #decryptor} and {@link #outBuffer} after decryption.    */
DECL|method|decrypt (long position, byte[] buffer, int offset, int length)
specifier|private
name|void
name|decrypt
parameter_list|(
name|long
name|position
parameter_list|,
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
index|[]
name|tmp
init|=
name|getTmpBuf
argument_list|()
decl_stmt|;
name|int
name|unread
init|=
name|outBuffer
operator|.
name|remaining
argument_list|()
decl_stmt|;
if|if
condition|(
name|unread
operator|>
literal|0
condition|)
block|{
comment|// Cache outBuffer
name|outBuffer
operator|.
name|get
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
name|unread
argument_list|)
expr_stmt|;
block|}
name|long
name|curOffset
init|=
name|streamOffset
decl_stmt|;
name|resetStreamOffset
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|n
operator|<
name|length
condition|)
block|{
name|int
name|toDecrypt
init|=
name|Math
operator|.
name|min
argument_list|(
name|length
operator|-
name|n
argument_list|,
name|inBuffer
operator|.
name|remaining
argument_list|()
argument_list|)
decl_stmt|;
name|inBuffer
operator|.
name|put
argument_list|(
name|buffer
argument_list|,
name|offset
operator|+
name|n
argument_list|,
name|toDecrypt
argument_list|)
expr_stmt|;
comment|// Do decryption
name|decrypt
argument_list|()
expr_stmt|;
name|outBuffer
operator|.
name|get
argument_list|(
name|buffer
argument_list|,
name|offset
operator|+
name|n
argument_list|,
name|toDecrypt
argument_list|)
expr_stmt|;
name|n
operator|+=
name|toDecrypt
expr_stmt|;
block|}
comment|// After decryption
name|resetStreamOffset
argument_list|(
name|curOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|unread
operator|>
literal|0
condition|)
block|{
comment|// Restore outBuffer
name|outBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|outBuffer
operator|.
name|put
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
name|unread
argument_list|)
expr_stmt|;
name|outBuffer
operator|.
name|flip
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Positioned read fully.
annotation|@
name|Override
DECL|method|readFully (long position, byte[] buffer, int offset, int length)
specifier|public
name|void
name|readFully
parameter_list|(
name|long
name|position
parameter_list|,
name|byte
index|[]
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|checkStream
argument_list|()
expr_stmt|;
try|try
block|{
operator|(
operator|(
name|PositionedReadable
operator|)
name|in
operator|)
operator|.
name|readFully
argument_list|(
name|position
argument_list|,
name|buffer
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
comment|/**           * Since this operation does not change the current offset of a file,           * streamOffset should be not changed and we need to restore the decryptor           * and outBuffer after decryption.          */
name|decrypt
argument_list|(
name|position
argument_list|,
name|buffer
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This stream does not support "
operator|+
literal|"positioned readFully."
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|readFully (long position, byte[] buffer)
specifier|public
name|void
name|readFully
parameter_list|(
name|long
name|position
parameter_list|,
name|byte
index|[]
name|buffer
parameter_list|)
throws|throws
name|IOException
block|{
name|readFully
argument_list|(
name|position
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|buffer
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|// Seek to a position.
annotation|@
name|Override
DECL|method|seek (long pos)
specifier|public
name|void
name|seek
parameter_list|(
name|long
name|pos
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|pos
operator|>=
literal|0
argument_list|,
literal|"Cannot seek to negative offset."
argument_list|)
expr_stmt|;
name|checkStream
argument_list|()
expr_stmt|;
try|try
block|{
comment|// If target pos we have already read and decrypt.
if|if
condition|(
name|pos
operator|<=
name|streamOffset
operator|&&
name|pos
operator|>=
operator|(
name|streamOffset
operator|-
name|outBuffer
operator|.
name|remaining
argument_list|()
operator|)
condition|)
block|{
name|int
name|forward
init|=
call|(
name|int
call|)
argument_list|(
name|pos
operator|-
operator|(
name|streamOffset
operator|-
name|outBuffer
operator|.
name|remaining
argument_list|()
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|forward
operator|>
literal|0
condition|)
block|{
name|outBuffer
operator|.
name|position
argument_list|(
name|outBuffer
operator|.
name|position
argument_list|()
operator|+
name|forward
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
operator|(
name|Seekable
operator|)
name|in
operator|)
operator|.
name|seek
argument_list|(
name|pos
argument_list|)
expr_stmt|;
name|resetStreamOffset
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This stream does not support "
operator|+
literal|"seek."
argument_list|)
throw|;
block|}
block|}
comment|// Skip n bytes
annotation|@
name|Override
DECL|method|skip (long n)
specifier|public
name|long
name|skip
parameter_list|(
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|n
operator|>=
literal|0
argument_list|,
literal|"Negative skip length."
argument_list|)
expr_stmt|;
name|checkStream
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|<=
name|outBuffer
operator|.
name|remaining
argument_list|()
condition|)
block|{
name|int
name|pos
init|=
name|outBuffer
operator|.
name|position
argument_list|()
operator|+
operator|(
name|int
operator|)
name|n
decl_stmt|;
name|outBuffer
operator|.
name|position
argument_list|(
name|pos
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
else|else
block|{
comment|/**        * Subtract outBuffer.remaining() to see how many bytes we need to         * skip in underlying stream. We get real skipped bytes number of         * underlying stream then add outBuffer.remaining() to get skipped        * bytes number from user's view.        */
name|n
operator|-=
name|outBuffer
operator|.
name|remaining
argument_list|()
expr_stmt|;
name|long
name|skipped
init|=
name|in
operator|.
name|skip
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|skipped
operator|<
literal|0
condition|)
block|{
name|skipped
operator|=
literal|0
expr_stmt|;
block|}
name|long
name|pos
init|=
name|streamOffset
operator|+
name|skipped
decl_stmt|;
name|skipped
operator|+=
name|outBuffer
operator|.
name|remaining
argument_list|()
expr_stmt|;
name|resetStreamOffset
argument_list|(
name|pos
argument_list|)
expr_stmt|;
return|return
name|skipped
return|;
block|}
block|}
comment|// Get underlying stream position.
annotation|@
name|Override
DECL|method|getPos ()
specifier|public
name|long
name|getPos
parameter_list|()
throws|throws
name|IOException
block|{
name|checkStream
argument_list|()
expr_stmt|;
comment|// Equals: ((Seekable) in).getPos() - outBuffer.remaining()
return|return
name|streamOffset
operator|-
name|outBuffer
operator|.
name|remaining
argument_list|()
return|;
block|}
comment|// ByteBuffer read.
annotation|@
name|Override
DECL|method|read (ByteBuffer buf)
specifier|public
name|int
name|read
parameter_list|(
name|ByteBuffer
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|checkStream
argument_list|()
expr_stmt|;
if|if
condition|(
name|in
operator|instanceof
name|ByteBufferReadable
condition|)
block|{
name|int
name|unread
init|=
name|outBuffer
operator|.
name|remaining
argument_list|()
decl_stmt|;
if|if
condition|(
name|unread
operator|>
literal|0
condition|)
block|{
comment|// Have unread decrypted data in buffer.
name|int
name|toRead
init|=
name|buf
operator|.
name|remaining
argument_list|()
decl_stmt|;
if|if
condition|(
name|toRead
operator|<=
name|unread
condition|)
block|{
name|int
name|limit
init|=
name|outBuffer
operator|.
name|limit
argument_list|()
decl_stmt|;
name|outBuffer
operator|.
name|limit
argument_list|(
name|outBuffer
operator|.
name|position
argument_list|()
operator|+
name|toRead
argument_list|)
expr_stmt|;
name|buf
operator|.
name|put
argument_list|(
name|outBuffer
argument_list|)
expr_stmt|;
name|outBuffer
operator|.
name|limit
argument_list|(
name|limit
argument_list|)
expr_stmt|;
return|return
name|toRead
return|;
block|}
else|else
block|{
name|buf
operator|.
name|put
argument_list|(
name|outBuffer
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|pos
init|=
name|buf
operator|.
name|position
argument_list|()
decl_stmt|;
name|int
name|n
init|=
operator|(
operator|(
name|ByteBufferReadable
operator|)
name|in
operator|)
operator|.
name|read
argument_list|(
name|buf
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|streamOffset
operator|+=
name|n
expr_stmt|;
comment|// Read n bytes
name|decrypt
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"ByteBuffer read unsupported "
operator|+
literal|"by input stream."
argument_list|)
throw|;
block|}
comment|/**    * Decrypt all data in buf: total n bytes from given start position.    * Output is also buf and same start position.    * buf.position() and buf.limit() should be unchanged after decryption.    */
DECL|method|decrypt (ByteBuffer buf, int n, int start)
specifier|private
name|void
name|decrypt
parameter_list|(
name|ByteBuffer
name|buf
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|start
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|pos
init|=
name|buf
operator|.
name|position
argument_list|()
decl_stmt|;
name|int
name|limit
init|=
name|buf
operator|.
name|limit
argument_list|()
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|<
name|n
condition|)
block|{
name|buf
operator|.
name|position
argument_list|(
name|start
operator|+
name|len
argument_list|)
expr_stmt|;
name|buf
operator|.
name|limit
argument_list|(
name|start
operator|+
name|len
operator|+
name|Math
operator|.
name|min
argument_list|(
name|n
operator|-
name|len
argument_list|,
name|inBuffer
operator|.
name|remaining
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|inBuffer
operator|.
name|put
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|// Do decryption
name|decrypt
argument_list|()
expr_stmt|;
name|buf
operator|.
name|position
argument_list|(
name|start
operator|+
name|len
argument_list|)
expr_stmt|;
name|buf
operator|.
name|limit
argument_list|(
name|limit
argument_list|)
expr_stmt|;
name|len
operator|+=
name|outBuffer
operator|.
name|remaining
argument_list|()
expr_stmt|;
name|buf
operator|.
name|put
argument_list|(
name|outBuffer
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|position
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|available ()
specifier|public
name|int
name|available
parameter_list|()
throws|throws
name|IOException
block|{
name|checkStream
argument_list|()
expr_stmt|;
return|return
name|in
operator|.
name|available
argument_list|()
operator|+
name|outBuffer
operator|.
name|remaining
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|markSupported ()
specifier|public
name|boolean
name|markSupported
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|mark (int readLimit)
specifier|public
name|void
name|mark
parameter_list|(
name|int
name|readLimit
parameter_list|)
block|{   }
annotation|@
name|Override
DECL|method|reset ()
specifier|public
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Mark/reset not supported"
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|seekToNewSource (long targetPos)
specifier|public
name|boolean
name|seekToNewSource
parameter_list|(
name|long
name|targetPos
parameter_list|)
throws|throws
name|IOException
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|targetPos
operator|>=
literal|0
argument_list|,
literal|"Cannot seek to negative offset."
argument_list|)
expr_stmt|;
name|checkStream
argument_list|()
expr_stmt|;
try|try
block|{
name|boolean
name|result
init|=
operator|(
operator|(
name|Seekable
operator|)
name|in
operator|)
operator|.
name|seekToNewSource
argument_list|(
name|targetPos
argument_list|)
decl_stmt|;
name|resetStreamOffset
argument_list|(
name|targetPos
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This stream does not support "
operator|+
literal|"seekToNewSource."
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|read (ByteBufferPool bufferPool, int maxLength, EnumSet<ReadOption> opts)
specifier|public
name|ByteBuffer
name|read
parameter_list|(
name|ByteBufferPool
name|bufferPool
parameter_list|,
name|int
name|maxLength
parameter_list|,
name|EnumSet
argument_list|<
name|ReadOption
argument_list|>
name|opts
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnsupportedOperationException
block|{
name|checkStream
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|outBuffer
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// Have some decrypted data unread, need to reset.
operator|(
operator|(
name|Seekable
operator|)
name|in
operator|)
operator|.
name|seek
argument_list|(
name|getPos
argument_list|()
argument_list|)
expr_stmt|;
name|resetStreamOffset
argument_list|(
name|getPos
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ByteBuffer
name|buffer
init|=
operator|(
operator|(
name|HasEnhancedByteBufferAccess
operator|)
name|in
operator|)
operator|.
name|read
argument_list|(
name|bufferPool
argument_list|,
name|maxLength
argument_list|,
name|opts
argument_list|)
decl_stmt|;
if|if
condition|(
name|buffer
operator|!=
literal|null
condition|)
block|{
name|int
name|n
init|=
name|buffer
operator|.
name|remaining
argument_list|()
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|streamOffset
operator|+=
name|buffer
operator|.
name|remaining
argument_list|()
expr_stmt|;
comment|// Read n bytes
name|int
name|pos
init|=
name|buffer
operator|.
name|position
argument_list|()
decl_stmt|;
name|decrypt
argument_list|(
name|buffer
argument_list|,
name|n
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buffer
return|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This stream does not support "
operator|+
literal|"enhanced byte buffer access."
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|releaseBuffer (ByteBuffer buffer)
specifier|public
name|void
name|releaseBuffer
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|)
block|{
try|try
block|{
operator|(
operator|(
name|HasEnhancedByteBufferAccess
operator|)
name|in
operator|)
operator|.
name|releaseBuffer
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This stream does not support "
operator|+
literal|"release buffer."
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|setReadahead (Long readahead)
specifier|public
name|void
name|setReadahead
parameter_list|(
name|Long
name|readahead
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnsupportedOperationException
block|{
try|try
block|{
operator|(
operator|(
name|CanSetReadahead
operator|)
name|in
operator|)
operator|.
name|setReadahead
argument_list|(
name|readahead
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This stream does not support "
operator|+
literal|"setting the readahead caching strategy."
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|setDropBehind (Boolean dropCache)
specifier|public
name|void
name|setDropBehind
parameter_list|(
name|Boolean
name|dropCache
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnsupportedOperationException
block|{
try|try
block|{
operator|(
operator|(
name|CanSetDropBehind
operator|)
name|in
operator|)
operator|.
name|setDropBehind
argument_list|(
name|dropCache
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This stream does not "
operator|+
literal|"support setting the drop-behind caching setting."
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|getFileDescriptor ()
specifier|public
name|FileDescriptor
name|getFileDescriptor
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|in
operator|instanceof
name|HasFileDescriptor
condition|)
block|{
return|return
operator|(
operator|(
name|HasFileDescriptor
operator|)
name|in
operator|)
operator|.
name|getFileDescriptor
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|in
operator|instanceof
name|FileInputStream
condition|)
block|{
return|return
operator|(
operator|(
name|FileInputStream
operator|)
name|in
operator|)
operator|.
name|getFD
argument_list|()
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|read ()
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|(
name|read
argument_list|(
name|oneByteBuf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
name|oneByteBuf
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
return|;
block|}
DECL|method|checkStream ()
specifier|private
name|void
name|checkStream
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|closed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stream closed"
argument_list|)
throw|;
block|}
block|}
DECL|method|getBufferSize (Configuration conf)
specifier|private
specifier|static
name|int
name|getBufferSize
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getInt
argument_list|(
name|HADOOP_SECURITY_CRYPTO_BUFFER_SIZE_KEY
argument_list|,
name|HADOOP_SECURITY_CRYPTO_BUFFER_SIZE_DEFAULT
argument_list|)
return|;
block|}
block|}
end_class

end_unit

