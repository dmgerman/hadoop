begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.ipc
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|WeakReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Timer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TimerTask
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|metrics2
operator|.
name|util
operator|.
name|MBeans
import|;
end_import

begin_import
import|import
name|org
operator|.
name|codehaus
operator|.
name|jackson
operator|.
name|map
operator|.
name|ObjectMapper
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * The decay RPC scheduler counts incoming requests in a map, then  * decays the counts at a fixed time interval. The scheduler is optimized  * for large periods (on the order of seconds), as it offloads work to the  * decay sweep.  */
end_comment

begin_class
DECL|class|DecayRpcScheduler
specifier|public
class|class
name|DecayRpcScheduler
implements|implements
name|RpcScheduler
implements|,
name|DecayRpcSchedulerMXBean
block|{
comment|/**    * Period controls how many milliseconds between each decay sweep.    */
DECL|field|IPC_CALLQUEUE_DECAYSCHEDULER_PERIOD_KEY
specifier|public
specifier|static
specifier|final
name|String
name|IPC_CALLQUEUE_DECAYSCHEDULER_PERIOD_KEY
init|=
literal|"faircallqueue.decay-scheduler.period-ms"
decl_stmt|;
DECL|field|IPC_CALLQUEUE_DECAYSCHEDULER_PERIOD_DEFAULT
specifier|public
specifier|static
specifier|final
name|long
name|IPC_CALLQUEUE_DECAYSCHEDULER_PERIOD_DEFAULT
init|=
literal|5000L
decl_stmt|;
comment|/**    * Decay factor controls how much each count is suppressed by on each sweep.    * Valid numbers are> 0 and< 1. Decay factor works in tandem with period    * to control how long the scheduler remembers an identity.    */
DECL|field|IPC_CALLQUEUE_DECAYSCHEDULER_FACTOR_KEY
specifier|public
specifier|static
specifier|final
name|String
name|IPC_CALLQUEUE_DECAYSCHEDULER_FACTOR_KEY
init|=
literal|"faircallqueue.decay-scheduler.decay-factor"
decl_stmt|;
DECL|field|IPC_CALLQUEUE_DECAYSCHEDULER_FACTOR_DEFAULT
specifier|public
specifier|static
specifier|final
name|double
name|IPC_CALLQUEUE_DECAYSCHEDULER_FACTOR_DEFAULT
init|=
literal|0.5
decl_stmt|;
comment|/**    * Thresholds are specified as integer percentages, and specify which usage    * range each queue will be allocated to. For instance, specifying the list    *  10, 40, 80    * implies 4 queues, with    * - q3 from 80% up    * - q2 from 40 up to 80    * - q1 from 10 up to 40    * - q0 otherwise.    */
DECL|field|IPC_CALLQUEUE_DECAYSCHEDULER_THRESHOLDS_KEY
specifier|public
specifier|static
specifier|final
name|String
name|IPC_CALLQUEUE_DECAYSCHEDULER_THRESHOLDS_KEY
init|=
literal|"faircallqueue.decay-scheduler.thresholds"
decl_stmt|;
comment|// Specifies the identity to use when the IdentityProvider cannot handle
comment|// a schedulable.
DECL|field|DECAYSCHEDULER_UNKNOWN_IDENTITY
specifier|public
specifier|static
specifier|final
name|String
name|DECAYSCHEDULER_UNKNOWN_IDENTITY
init|=
literal|"IdentityProvider.Unknown"
decl_stmt|;
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|DecayRpcScheduler
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Track the number of calls for each schedulable identity
DECL|field|callCounts
specifier|private
specifier|final
name|ConcurrentHashMap
argument_list|<
name|Object
argument_list|,
name|AtomicLong
argument_list|>
name|callCounts
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|Object
argument_list|,
name|AtomicLong
argument_list|>
argument_list|()
decl_stmt|;
comment|// Should be the sum of all AtomicLongs in callCounts
DECL|field|totalCalls
specifier|private
specifier|final
name|AtomicLong
name|totalCalls
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
comment|// Pre-computed scheduling decisions during the decay sweep are
comment|// atomically swapped in as a read-only map
DECL|field|scheduleCacheRef
specifier|private
specifier|final
name|AtomicReference
argument_list|<
name|Map
argument_list|<
name|Object
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|scheduleCacheRef
init|=
operator|new
name|AtomicReference
argument_list|<
name|Map
argument_list|<
name|Object
argument_list|,
name|Integer
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|// Tune the behavior of the scheduler
DECL|field|decayPeriodMillis
specifier|private
specifier|final
name|long
name|decayPeriodMillis
decl_stmt|;
comment|// How long between each tick
DECL|field|decayFactor
specifier|private
specifier|final
name|double
name|decayFactor
decl_stmt|;
comment|// nextCount = currentCount / decayFactor
DECL|field|numQueues
specifier|private
specifier|final
name|int
name|numQueues
decl_stmt|;
comment|// affects scheduling decisions, from 0 to numQueues - 1
DECL|field|thresholds
specifier|private
specifier|final
name|double
index|[]
name|thresholds
decl_stmt|;
DECL|field|identityProvider
specifier|private
specifier|final
name|IdentityProvider
name|identityProvider
decl_stmt|;
comment|/**    * This TimerTask will call decayCurrentCounts until    * the scheduler has been garbage collected.    */
DECL|class|DecayTask
specifier|public
specifier|static
class|class
name|DecayTask
extends|extends
name|TimerTask
block|{
DECL|field|schedulerRef
specifier|private
name|WeakReference
argument_list|<
name|DecayRpcScheduler
argument_list|>
name|schedulerRef
decl_stmt|;
DECL|field|timer
specifier|private
name|Timer
name|timer
decl_stmt|;
DECL|method|DecayTask (DecayRpcScheduler scheduler, Timer timer)
specifier|public
name|DecayTask
parameter_list|(
name|DecayRpcScheduler
name|scheduler
parameter_list|,
name|Timer
name|timer
parameter_list|)
block|{
name|this
operator|.
name|schedulerRef
operator|=
operator|new
name|WeakReference
argument_list|<
name|DecayRpcScheduler
argument_list|>
argument_list|(
name|scheduler
argument_list|)
expr_stmt|;
name|this
operator|.
name|timer
operator|=
name|timer
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
name|DecayRpcScheduler
name|sched
init|=
name|schedulerRef
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|sched
operator|!=
literal|null
condition|)
block|{
name|sched
operator|.
name|decayCurrentCounts
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Our scheduler was garbage collected since it is no longer in use,
comment|// so we should terminate the timer as well
name|timer
operator|.
name|cancel
argument_list|()
expr_stmt|;
name|timer
operator|.
name|purge
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Create a decay scheduler.    * @param numQueues number of queues to schedule for    * @param ns config prefix, so that we can configure multiple schedulers    *           in a single instance.    * @param conf configuration to use.    */
DECL|method|DecayRpcScheduler (int numQueues, String ns, Configuration conf)
specifier|public
name|DecayRpcScheduler
parameter_list|(
name|int
name|numQueues
parameter_list|,
name|String
name|ns
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
if|if
condition|(
name|numQueues
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"number of queues must be> 0"
argument_list|)
throw|;
block|}
name|this
operator|.
name|numQueues
operator|=
name|numQueues
expr_stmt|;
name|this
operator|.
name|decayFactor
operator|=
name|parseDecayFactor
argument_list|(
name|ns
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|decayPeriodMillis
operator|=
name|parseDecayPeriodMillis
argument_list|(
name|ns
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|identityProvider
operator|=
name|this
operator|.
name|parseIdentityProvider
argument_list|(
name|ns
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|this
operator|.
name|thresholds
operator|=
name|parseThresholds
argument_list|(
name|ns
argument_list|,
name|conf
argument_list|,
name|numQueues
argument_list|)
expr_stmt|;
comment|// Setup delay timer
name|Timer
name|timer
init|=
operator|new
name|Timer
argument_list|()
decl_stmt|;
name|DecayTask
name|task
init|=
operator|new
name|DecayTask
argument_list|(
name|this
argument_list|,
name|timer
argument_list|)
decl_stmt|;
name|timer
operator|.
name|scheduleAtFixedRate
argument_list|(
name|task
argument_list|,
name|decayPeriodMillis
argument_list|,
name|decayPeriodMillis
argument_list|)
expr_stmt|;
name|MetricsProxy
name|prox
init|=
name|MetricsProxy
operator|.
name|getInstance
argument_list|(
name|ns
argument_list|)
decl_stmt|;
name|prox
operator|.
name|setDelegate
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|// Load configs
DECL|method|parseIdentityProvider (String ns, Configuration conf)
specifier|private
name|IdentityProvider
name|parseIdentityProvider
parameter_list|(
name|String
name|ns
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|List
argument_list|<
name|IdentityProvider
argument_list|>
name|providers
init|=
name|conf
operator|.
name|getInstances
argument_list|(
name|ns
operator|+
literal|"."
operator|+
name|CommonConfigurationKeys
operator|.
name|IPC_CALLQUEUE_IDENTITY_PROVIDER_KEY
argument_list|,
name|IdentityProvider
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|providers
operator|.
name|size
argument_list|()
operator|<
literal|1
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"IdentityProvider not specified, "
operator|+
literal|"defaulting to UserIdentityProvider"
argument_list|)
expr_stmt|;
return|return
operator|new
name|UserIdentityProvider
argument_list|()
return|;
block|}
return|return
name|providers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
comment|// use the first
block|}
DECL|method|parseDecayFactor (String ns, Configuration conf)
specifier|private
specifier|static
name|double
name|parseDecayFactor
parameter_list|(
name|String
name|ns
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|double
name|factor
init|=
name|conf
operator|.
name|getDouble
argument_list|(
name|ns
operator|+
literal|"."
operator|+
name|IPC_CALLQUEUE_DECAYSCHEDULER_FACTOR_KEY
argument_list|,
name|IPC_CALLQUEUE_DECAYSCHEDULER_FACTOR_DEFAULT
argument_list|)
decl_stmt|;
if|if
condition|(
name|factor
operator|<=
literal|0
operator|||
name|factor
operator|>=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Decay Factor "
operator|+
literal|"must be between 0 and 1"
argument_list|)
throw|;
block|}
return|return
name|factor
return|;
block|}
DECL|method|parseDecayPeriodMillis (String ns, Configuration conf)
specifier|private
specifier|static
name|long
name|parseDecayPeriodMillis
parameter_list|(
name|String
name|ns
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|long
name|period
init|=
name|conf
operator|.
name|getLong
argument_list|(
name|ns
operator|+
literal|"."
operator|+
name|IPC_CALLQUEUE_DECAYSCHEDULER_PERIOD_KEY
argument_list|,
name|IPC_CALLQUEUE_DECAYSCHEDULER_PERIOD_DEFAULT
argument_list|)
decl_stmt|;
if|if
condition|(
name|period
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Period millis must be>= 0"
argument_list|)
throw|;
block|}
return|return
name|period
return|;
block|}
DECL|method|parseThresholds (String ns, Configuration conf, int numQueues)
specifier|private
specifier|static
name|double
index|[]
name|parseThresholds
parameter_list|(
name|String
name|ns
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|int
name|numQueues
parameter_list|)
block|{
name|int
index|[]
name|percentages
init|=
name|conf
operator|.
name|getInts
argument_list|(
name|ns
operator|+
literal|"."
operator|+
name|IPC_CALLQUEUE_DECAYSCHEDULER_THRESHOLDS_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|percentages
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
name|getDefaultThresholds
argument_list|(
name|numQueues
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|percentages
operator|.
name|length
operator|!=
name|numQueues
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Number of thresholds should be "
operator|+
operator|(
name|numQueues
operator|-
literal|1
operator|)
operator|+
literal|". Was: "
operator|+
name|percentages
operator|.
name|length
argument_list|)
throw|;
block|}
comment|// Convert integer percentages to decimals
name|double
index|[]
name|decimals
init|=
operator|new
name|double
index|[
name|percentages
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|percentages
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|decimals
index|[
name|i
index|]
operator|=
name|percentages
index|[
name|i
index|]
operator|/
literal|100.0
expr_stmt|;
block|}
return|return
name|decimals
return|;
block|}
comment|/**    * Generate default thresholds if user did not specify. Strategy is    * to halve each time, since queue usage tends to be exponential.    * So if numQueues is 4, we would generate: double[]{0.125, 0.25, 0.5}    * which specifies the boundaries between each queue's usage.    * @param numQueues number of queues to compute for    * @return array of boundaries of length numQueues - 1    */
DECL|method|getDefaultThresholds (int numQueues)
specifier|private
specifier|static
name|double
index|[]
name|getDefaultThresholds
parameter_list|(
name|int
name|numQueues
parameter_list|)
block|{
name|double
index|[]
name|ret
init|=
operator|new
name|double
index|[
name|numQueues
operator|-
literal|1
index|]
decl_stmt|;
name|double
name|div
init|=
name|Math
operator|.
name|pow
argument_list|(
literal|2
argument_list|,
name|numQueues
operator|-
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ret
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ret
index|[
name|i
index|]
operator|=
name|Math
operator|.
name|pow
argument_list|(
literal|2
argument_list|,
name|i
argument_list|)
operator|/
name|div
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**    * Decay the stored counts for each user and clean as necessary.    * This method should be called periodically in order to keep    * counts current.    */
DECL|method|decayCurrentCounts ()
specifier|private
name|void
name|decayCurrentCounts
parameter_list|()
block|{
name|long
name|total
init|=
literal|0
decl_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|AtomicLong
argument_list|>
argument_list|>
name|it
init|=
name|callCounts
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|AtomicLong
argument_list|>
name|entry
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|AtomicLong
name|count
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
comment|// Compute the next value by reducing it by the decayFactor
name|long
name|currentValue
init|=
name|count
operator|.
name|get
argument_list|()
decl_stmt|;
name|long
name|nextValue
init|=
call|(
name|long
call|)
argument_list|(
name|currentValue
operator|*
name|decayFactor
argument_list|)
decl_stmt|;
name|total
operator|+=
name|nextValue
expr_stmt|;
name|count
operator|.
name|set
argument_list|(
name|nextValue
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextValue
operator|==
literal|0
condition|)
block|{
comment|// We will clean up unused keys here. An interesting optimization might
comment|// be to have an upper bound on keyspace in callCounts and only
comment|// clean once we pass it.
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
comment|// Update the total so that we remain in sync
name|totalCalls
operator|.
name|set
argument_list|(
name|total
argument_list|)
expr_stmt|;
comment|// Now refresh the cache of scheduling decisions
name|recomputeScheduleCache
argument_list|()
expr_stmt|;
block|}
comment|/**    * Update the scheduleCache to match current conditions in callCounts.    */
DECL|method|recomputeScheduleCache ()
specifier|private
name|void
name|recomputeScheduleCache
parameter_list|()
block|{
name|Map
argument_list|<
name|Object
argument_list|,
name|Integer
argument_list|>
name|nextCache
init|=
operator|new
name|HashMap
argument_list|<
name|Object
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|AtomicLong
argument_list|>
name|entry
range|:
name|callCounts
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Object
name|id
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|AtomicLong
name|value
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|long
name|snapshot
init|=
name|value
operator|.
name|get
argument_list|()
decl_stmt|;
name|int
name|computedLevel
init|=
name|computePriorityLevel
argument_list|(
name|snapshot
argument_list|)
decl_stmt|;
name|nextCache
operator|.
name|put
argument_list|(
name|id
argument_list|,
name|computedLevel
argument_list|)
expr_stmt|;
block|}
comment|// Swap in to activate
name|scheduleCacheRef
operator|.
name|set
argument_list|(
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|nextCache
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the number of occurrences and increment atomically.    * @param identity the identity of the user to increment    * @return the value before incrementation    */
DECL|method|getAndIncrement (Object identity)
specifier|private
name|long
name|getAndIncrement
parameter_list|(
name|Object
name|identity
parameter_list|)
throws|throws
name|InterruptedException
block|{
comment|// We will increment the count, or create it if no such count exists
name|AtomicLong
name|count
init|=
name|this
operator|.
name|callCounts
operator|.
name|get
argument_list|(
name|identity
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|null
condition|)
block|{
comment|// Create the count since no such count exists.
name|count
operator|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// Put it in, or get the AtomicInteger that was put in by another thread
name|AtomicLong
name|otherCount
init|=
name|callCounts
operator|.
name|putIfAbsent
argument_list|(
name|identity
argument_list|,
name|count
argument_list|)
decl_stmt|;
if|if
condition|(
name|otherCount
operator|!=
literal|null
condition|)
block|{
name|count
operator|=
name|otherCount
expr_stmt|;
block|}
block|}
comment|// Update the total
name|totalCalls
operator|.
name|getAndIncrement
argument_list|()
expr_stmt|;
comment|// At this point value is guaranteed to be not null. It may however have
comment|// been clobbered from callCounts. Nonetheless, we return what
comment|// we have.
return|return
name|count
operator|.
name|getAndIncrement
argument_list|()
return|;
block|}
comment|/**    * Given the number of occurrences, compute a scheduling decision.    * @param occurrences how many occurrences    * @return scheduling decision from 0 to numQueues - 1    */
DECL|method|computePriorityLevel (long occurrences)
specifier|private
name|int
name|computePriorityLevel
parameter_list|(
name|long
name|occurrences
parameter_list|)
block|{
name|long
name|totalCallSnapshot
init|=
name|totalCalls
operator|.
name|get
argument_list|()
decl_stmt|;
name|double
name|proportion
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|totalCallSnapshot
operator|>
literal|0
condition|)
block|{
name|proportion
operator|=
operator|(
name|double
operator|)
name|occurrences
operator|/
name|totalCallSnapshot
expr_stmt|;
block|}
comment|// Start with low priority queues, since they will be most common
for|for
control|(
name|int
name|i
init|=
operator|(
name|numQueues
operator|-
literal|1
operator|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|proportion
operator|>=
name|this
operator|.
name|thresholds
index|[
name|i
operator|-
literal|1
index|]
condition|)
block|{
return|return
name|i
return|;
comment|// We've found our queue number
block|}
block|}
comment|// If we get this far, we're at queue 0
return|return
literal|0
return|;
block|}
comment|/**    * Returns the priority level for a given identity by first trying the cache,    * then computing it.    * @param identity an object responding to toString and hashCode    * @return integer scheduling decision from 0 to numQueues - 1    */
DECL|method|cachedOrComputedPriorityLevel (Object identity)
specifier|private
name|int
name|cachedOrComputedPriorityLevel
parameter_list|(
name|Object
name|identity
parameter_list|)
block|{
try|try
block|{
name|long
name|occurrences
init|=
name|this
operator|.
name|getAndIncrement
argument_list|(
name|identity
argument_list|)
decl_stmt|;
comment|// Try the cache
name|Map
argument_list|<
name|Object
argument_list|,
name|Integer
argument_list|>
name|scheduleCache
init|=
name|scheduleCacheRef
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|scheduleCache
operator|!=
literal|null
condition|)
block|{
name|Integer
name|priority
init|=
name|scheduleCache
operator|.
name|get
argument_list|(
name|identity
argument_list|)
decl_stmt|;
if|if
condition|(
name|priority
operator|!=
literal|null
condition|)
block|{
return|return
name|priority
return|;
block|}
block|}
comment|// Cache was no good, compute it
return|return
name|computePriorityLevel
argument_list|(
name|occurrences
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Caught InterruptedException, returning low priority queue"
argument_list|)
expr_stmt|;
return|return
name|numQueues
operator|-
literal|1
return|;
block|}
block|}
comment|/**    * Compute the appropriate priority for a schedulable based on past requests.    * @param obj the schedulable obj to query and remember    * @return the queue index which we recommend scheduling in    */
annotation|@
name|Override
DECL|method|getPriorityLevel (Schedulable obj)
specifier|public
name|int
name|getPriorityLevel
parameter_list|(
name|Schedulable
name|obj
parameter_list|)
block|{
comment|// First get the identity
name|String
name|identity
init|=
name|this
operator|.
name|identityProvider
operator|.
name|makeIdentity
argument_list|(
name|obj
argument_list|)
decl_stmt|;
if|if
condition|(
name|identity
operator|==
literal|null
condition|)
block|{
comment|// Identity provider did not handle this
name|identity
operator|=
name|DECAYSCHEDULER_UNKNOWN_IDENTITY
expr_stmt|;
block|}
return|return
name|cachedOrComputedPriorityLevel
argument_list|(
name|identity
argument_list|)
return|;
block|}
comment|// For testing
annotation|@
name|VisibleForTesting
DECL|method|getDecayFactor ()
specifier|public
name|double
name|getDecayFactor
parameter_list|()
block|{
return|return
name|decayFactor
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getDecayPeriodMillis ()
specifier|public
name|long
name|getDecayPeriodMillis
parameter_list|()
block|{
return|return
name|decayPeriodMillis
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getThresholds ()
specifier|public
name|double
index|[]
name|getThresholds
parameter_list|()
block|{
return|return
name|thresholds
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|forceDecay ()
specifier|public
name|void
name|forceDecay
parameter_list|()
block|{
name|decayCurrentCounts
argument_list|()
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getCallCountSnapshot ()
specifier|public
name|Map
argument_list|<
name|Object
argument_list|,
name|Long
argument_list|>
name|getCallCountSnapshot
parameter_list|()
block|{
name|HashMap
argument_list|<
name|Object
argument_list|,
name|Long
argument_list|>
name|snapshot
init|=
operator|new
name|HashMap
argument_list|<
name|Object
argument_list|,
name|Long
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Object
argument_list|,
name|AtomicLong
argument_list|>
name|entry
range|:
name|callCounts
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|snapshot
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|snapshot
argument_list|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getTotalCallSnapshot ()
specifier|public
name|long
name|getTotalCallSnapshot
parameter_list|()
block|{
return|return
name|totalCalls
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * MetricsProxy is a singleton because we may init multiple schedulers and we    * want to clean up resources when a new scheduler replaces the old one.    */
DECL|class|MetricsProxy
specifier|private
specifier|static
specifier|final
class|class
name|MetricsProxy
implements|implements
name|DecayRpcSchedulerMXBean
block|{
comment|// One singleton per namespace
DECL|field|INSTANCES
specifier|private
specifier|static
specifier|final
name|HashMap
argument_list|<
name|String
argument_list|,
name|MetricsProxy
argument_list|>
name|INSTANCES
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|MetricsProxy
argument_list|>
argument_list|()
decl_stmt|;
comment|// Weakref for delegate, so we don't retain it forever if it can be GC'd
DECL|field|delegate
specifier|private
name|WeakReference
argument_list|<
name|DecayRpcScheduler
argument_list|>
name|delegate
decl_stmt|;
DECL|method|MetricsProxy (String namespace)
specifier|private
name|MetricsProxy
parameter_list|(
name|String
name|namespace
parameter_list|)
block|{
name|MBeans
operator|.
name|register
argument_list|(
name|namespace
argument_list|,
literal|"DecayRpcScheduler"
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|getInstance (String namespace)
specifier|public
specifier|static
specifier|synchronized
name|MetricsProxy
name|getInstance
parameter_list|(
name|String
name|namespace
parameter_list|)
block|{
name|MetricsProxy
name|mp
init|=
name|INSTANCES
operator|.
name|get
argument_list|(
name|namespace
argument_list|)
decl_stmt|;
if|if
condition|(
name|mp
operator|==
literal|null
condition|)
block|{
comment|// We must create one
name|mp
operator|=
operator|new
name|MetricsProxy
argument_list|(
name|namespace
argument_list|)
expr_stmt|;
name|INSTANCES
operator|.
name|put
argument_list|(
name|namespace
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
return|return
name|mp
return|;
block|}
DECL|method|setDelegate (DecayRpcScheduler obj)
specifier|public
name|void
name|setDelegate
parameter_list|(
name|DecayRpcScheduler
name|obj
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
operator|new
name|WeakReference
argument_list|<
name|DecayRpcScheduler
argument_list|>
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getSchedulingDecisionSummary ()
specifier|public
name|String
name|getSchedulingDecisionSummary
parameter_list|()
block|{
name|DecayRpcScheduler
name|scheduler
init|=
name|delegate
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|scheduler
operator|==
literal|null
condition|)
block|{
return|return
literal|"No Active Scheduler"
return|;
block|}
else|else
block|{
return|return
name|scheduler
operator|.
name|getSchedulingDecisionSummary
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|getCallVolumeSummary ()
specifier|public
name|String
name|getCallVolumeSummary
parameter_list|()
block|{
name|DecayRpcScheduler
name|scheduler
init|=
name|delegate
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|scheduler
operator|==
literal|null
condition|)
block|{
return|return
literal|"No Active Scheduler"
return|;
block|}
else|else
block|{
return|return
name|scheduler
operator|.
name|getCallVolumeSummary
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|getUniqueIdentityCount ()
specifier|public
name|int
name|getUniqueIdentityCount
parameter_list|()
block|{
name|DecayRpcScheduler
name|scheduler
init|=
name|delegate
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|scheduler
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
name|scheduler
operator|.
name|getUniqueIdentityCount
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|getTotalCallVolume ()
specifier|public
name|long
name|getTotalCallVolume
parameter_list|()
block|{
name|DecayRpcScheduler
name|scheduler
init|=
name|delegate
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|scheduler
operator|==
literal|null
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
name|scheduler
operator|.
name|getTotalCallVolume
argument_list|()
return|;
block|}
block|}
block|}
DECL|method|getUniqueIdentityCount ()
specifier|public
name|int
name|getUniqueIdentityCount
parameter_list|()
block|{
return|return
name|callCounts
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|getTotalCallVolume ()
specifier|public
name|long
name|getTotalCallVolume
parameter_list|()
block|{
return|return
name|totalCalls
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|getSchedulingDecisionSummary ()
specifier|public
name|String
name|getSchedulingDecisionSummary
parameter_list|()
block|{
name|Map
argument_list|<
name|Object
argument_list|,
name|Integer
argument_list|>
name|decisions
init|=
name|scheduleCacheRef
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|decisions
operator|==
literal|null
condition|)
block|{
return|return
literal|"{}"
return|;
block|}
else|else
block|{
try|try
block|{
name|ObjectMapper
name|om
init|=
operator|new
name|ObjectMapper
argument_list|()
decl_stmt|;
return|return
name|om
operator|.
name|writeValueAsString
argument_list|(
name|decisions
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
literal|"Error: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
return|;
block|}
block|}
block|}
DECL|method|getCallVolumeSummary ()
specifier|public
name|String
name|getCallVolumeSummary
parameter_list|()
block|{
try|try
block|{
name|ObjectMapper
name|om
init|=
operator|new
name|ObjectMapper
argument_list|()
decl_stmt|;
return|return
name|om
operator|.
name|writeValueAsString
argument_list|(
name|callCounts
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
return|return
literal|"Error: "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

