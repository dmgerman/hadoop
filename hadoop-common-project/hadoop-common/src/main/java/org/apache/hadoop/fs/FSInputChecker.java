begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|EOFException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|Checksum
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|IntBuffer
import|;
end_import

begin_comment
comment|/**  * This is a generic input stream for verifying checksums for  * data before it is read by a user.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|}
argument_list|)
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|FSInputChecker
specifier|abstract
specifier|public
class|class
name|FSInputChecker
extends|extends
name|FSInputStream
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|FSInputChecker
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** The file name from which data is read from */
DECL|field|file
specifier|protected
name|Path
name|file
decl_stmt|;
DECL|field|sum
specifier|private
name|Checksum
name|sum
decl_stmt|;
DECL|field|verifyChecksum
specifier|private
name|boolean
name|verifyChecksum
init|=
literal|true
decl_stmt|;
DECL|field|maxChunkSize
specifier|private
name|int
name|maxChunkSize
decl_stmt|;
comment|// data bytes for checksum (eg 512)
DECL|field|buf
specifier|private
name|byte
index|[]
name|buf
decl_stmt|;
comment|// buffer for non-chunk-aligned reading
DECL|field|checksum
specifier|private
name|byte
index|[]
name|checksum
decl_stmt|;
DECL|field|checksumInts
specifier|private
name|IntBuffer
name|checksumInts
decl_stmt|;
comment|// wrapper on checksum buffer
DECL|field|pos
specifier|private
name|int
name|pos
decl_stmt|;
comment|// the position of the reader inside buf
DECL|field|count
specifier|private
name|int
name|count
decl_stmt|;
comment|// the number of bytes currently in buf
DECL|field|numOfRetries
specifier|private
name|int
name|numOfRetries
decl_stmt|;
comment|// cached file position
comment|// this should always be a multiple of maxChunkSize
DECL|field|chunkPos
specifier|private
name|long
name|chunkPos
init|=
literal|0
decl_stmt|;
comment|// Number of checksum chunks that can be read at once into a user
comment|// buffer. Chosen by benchmarks - higher values do not reduce
comment|// CPU usage. The size of the data reads made to the underlying stream
comment|// will be CHUNKS_PER_READ * maxChunkSize.
DECL|field|CHUNKS_PER_READ
specifier|private
specifier|static
specifier|final
name|int
name|CHUNKS_PER_READ
init|=
literal|32
decl_stmt|;
DECL|field|CHECKSUM_SIZE
specifier|protected
specifier|static
specifier|final
name|int
name|CHECKSUM_SIZE
init|=
literal|4
decl_stmt|;
comment|// 32-bit checksum
comment|/** Constructor    *     * @param file The name of the file to be read    * @param numOfRetries Number of read retries when ChecksumError occurs    */
DECL|method|FSInputChecker ( Path file, int numOfRetries)
specifier|protected
name|FSInputChecker
parameter_list|(
name|Path
name|file
parameter_list|,
name|int
name|numOfRetries
parameter_list|)
block|{
name|this
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|this
operator|.
name|numOfRetries
operator|=
name|numOfRetries
expr_stmt|;
block|}
comment|/** Constructor    *     * @param file The name of the file to be read    * @param numOfRetries Number of read retries when ChecksumError occurs    * @param sum the type of Checksum engine    * @param chunkSize maximun chunk size    * @param checksumSize the number byte of each checksum    */
DECL|method|FSInputChecker ( Path file, int numOfRetries, boolean verifyChecksum, Checksum sum, int chunkSize, int checksumSize )
specifier|protected
name|FSInputChecker
parameter_list|(
name|Path
name|file
parameter_list|,
name|int
name|numOfRetries
parameter_list|,
name|boolean
name|verifyChecksum
parameter_list|,
name|Checksum
name|sum
parameter_list|,
name|int
name|chunkSize
parameter_list|,
name|int
name|checksumSize
parameter_list|)
block|{
name|this
argument_list|(
name|file
argument_list|,
name|numOfRetries
argument_list|)
expr_stmt|;
name|set
argument_list|(
name|verifyChecksum
argument_list|,
name|sum
argument_list|,
name|chunkSize
argument_list|,
name|checksumSize
argument_list|)
expr_stmt|;
block|}
comment|/**    * Reads in checksum chunks into<code>buf</code> at<code>offset</code>    * and checksum into<code>checksum</code>.    * Since checksums can be disabled, there are two cases implementors need    * to worry about:    *    *  (a) needChecksum() will return false:    *     - len can be any positive value    *     - checksum will be null    *     Implementors should simply pass through to the underlying data stream.    * or    *  (b) needChecksum() will return true:    *    - len>= maxChunkSize    *    - checksum.length is a multiple of CHECKSUM_SIZE    *    Implementors should read an integer number of data chunks into    *    buf. The amount read should be bounded by len or by     *    checksum.length / CHECKSUM_SIZE * maxChunkSize. Note that len may    *    be a value that is not a multiple of maxChunkSize, in which case    *    the implementation may return less than len.    *    * The method is used for implementing read, therefore, it should be optimized    * for sequential reading.    *    * @param pos chunkPos    * @param buf destination buffer    * @param offset offset in buf at which to store data    * @param len maximum number of bytes to read    * @param checksum the data buffer into which to write checksums    * @return number of bytes read    */
DECL|method|readChunk (long pos, byte[] buf, int offset, int len, byte[] checksum)
specifier|abstract
specifier|protected
name|int
name|readChunk
parameter_list|(
name|long
name|pos
parameter_list|,
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|,
name|byte
index|[]
name|checksum
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Return position of beginning of chunk containing pos.     *    * @param pos a position in the file    * @return the starting position of the chunk which contains the byte    */
DECL|method|getChunkPosition (long pos)
specifier|abstract
specifier|protected
name|long
name|getChunkPosition
parameter_list|(
name|long
name|pos
parameter_list|)
function_decl|;
comment|/** Return true if there is a need for checksum verification */
DECL|method|needChecksum ()
specifier|protected
specifier|synchronized
name|boolean
name|needChecksum
parameter_list|()
block|{
return|return
name|verifyChecksum
operator|&&
name|sum
operator|!=
literal|null
return|;
block|}
comment|/**    * Read one checksum-verified byte    *     * @return     the next byte of data, or<code>-1</code> if the end of the    *             stream is reached.    * @exception  IOException  if an I/O error occurs.    */
annotation|@
name|Override
DECL|method|read ()
specifier|public
specifier|synchronized
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|pos
operator|>=
name|count
condition|)
block|{
name|fill
argument_list|()
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|count
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
name|buf
index|[
name|pos
operator|++
index|]
operator|&
literal|0xff
return|;
block|}
comment|/**    * Read checksum verified bytes from this byte-input stream into     * the specified byte array, starting at the given offset.    *    *<p> This method implements the general contract of the corresponding    *<code>{@link InputStream#read(byte[], int, int) read}</code> method of    * the<code>{@link InputStream}</code> class.  As an additional    * convenience, it attempts to read as many bytes as possible by repeatedly    * invoking the<code>read</code> method of the underlying stream.  This    * iterated<code>read</code> continues until one of the following    * conditions becomes true:<ul>    *    *<li> The specified number of bytes have been read,    *    *<li> The<code>read</code> method of the underlying stream returns    *<code>-1</code>, indicating end-of-file.    *    *</ul> If the first<code>read</code> on the underlying stream returns    *<code>-1</code> to indicate end-of-file then this method returns    *<code>-1</code>.  Otherwise this method returns the number of bytes    * actually read.    *    * @param      b     destination buffer.    * @param      off   offset at which to start storing bytes.    * @param      len   maximum number of bytes to read.    * @return     the number of bytes read, or<code>-1</code> if the end of    *             the stream has been reached.    * @exception  IOException  if an I/O error occurs.    *             ChecksumException if any checksum error occurs    */
annotation|@
name|Override
DECL|method|read (byte[] b, int off, int len)
specifier|public
specifier|synchronized
name|int
name|read
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
comment|// parameter check
if|if
condition|(
operator|(
name|off
operator||
name|len
operator||
operator|(
name|off
operator|+
name|len
operator|)
operator||
operator|(
name|b
operator|.
name|length
operator|-
operator|(
name|off
operator|+
name|len
operator|)
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|()
throw|;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|nread
init|=
name|read1
argument_list|(
name|b
argument_list|,
name|off
operator|+
name|n
argument_list|,
name|len
operator|-
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|nread
operator|<=
literal|0
condition|)
return|return
operator|(
name|n
operator|==
literal|0
operator|)
condition|?
name|nread
else|:
name|n
return|;
name|n
operator|+=
name|nread
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|len
condition|)
return|return
name|n
return|;
block|}
block|}
comment|/**    * Fills the buffer with a chunk data.     * No mark is supported.    * This method assumes that all data in the buffer has already been read in,    * hence pos> count.    */
DECL|method|fill ( )
specifier|private
name|void
name|fill
parameter_list|(  )
throws|throws
name|IOException
block|{
assert|assert
operator|(
name|pos
operator|>=
name|count
operator|)
assert|;
comment|// fill internal buffer
name|count
operator|=
name|readChecksumChunk
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|maxChunkSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|count
operator|=
literal|0
expr_stmt|;
block|}
comment|/**    * Like read(byte[], int, int), but does not provide a dest buffer,    * so the read data is discarded.    * @param      len maximum number of bytes to read.    * @return     the number of bytes read.    * @throws     IOException  if an I/O error occurs.    */
DECL|method|readAndDiscard (int len)
specifier|final
specifier|protected
specifier|synchronized
name|int
name|readAndDiscard
parameter_list|(
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|total
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|total
operator|<
name|len
condition|)
block|{
if|if
condition|(
name|pos
operator|>=
name|count
condition|)
block|{
name|count
operator|=
name|readChecksumChunk
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|maxChunkSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
block|{
break|break;
block|}
block|}
name|int
name|rd
init|=
name|Math
operator|.
name|min
argument_list|(
name|count
operator|-
name|pos
argument_list|,
name|len
operator|-
name|total
argument_list|)
decl_stmt|;
name|pos
operator|+=
name|rd
expr_stmt|;
name|total
operator|+=
name|rd
expr_stmt|;
block|}
return|return
name|total
return|;
block|}
comment|/*    * Read characters into a portion of an array, reading from the underlying    * stream at most once if necessary.    */
DECL|method|read1 (byte b[], int off, int len)
specifier|private
name|int
name|read1
parameter_list|(
name|byte
name|b
index|[]
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|avail
init|=
name|count
operator|-
name|pos
decl_stmt|;
if|if
condition|(
name|avail
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|>=
name|maxChunkSize
condition|)
block|{
comment|// read a chunk to user buffer directly; avoid one copy
name|int
name|nread
init|=
name|readChecksumChunk
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
decl_stmt|;
return|return
name|nread
return|;
block|}
else|else
block|{
comment|// read a chunk into the local buffer
name|fill
argument_list|()
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|avail
operator|=
name|count
expr_stmt|;
block|}
block|}
block|}
comment|// copy content of the local buffer to the user buffer
name|int
name|cnt
init|=
operator|(
name|avail
operator|<
name|len
operator|)
condition|?
name|avail
else|:
name|len
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|buf
argument_list|,
name|pos
argument_list|,
name|b
argument_list|,
name|off
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|cnt
expr_stmt|;
return|return
name|cnt
return|;
block|}
comment|/* Read up one or more checksum chunk to array<i>b</i> at pos<i>off</i>    * It requires at least one checksum chunk boundary    * in between<cur_pos, cur_pos+len>     * and it stops reading at the last boundary or at the end of the stream;    * Otherwise an IllegalArgumentException is thrown.    * This makes sure that all data read are checksum verified.    *     * @param b   the buffer into which the data is read.    * @param off the start offset in array<code>b</code>    *            at which the data is written.    * @param len the maximum number of bytes to read.    * @return    the total number of bytes read into the buffer, or    *<code>-1</code> if there is no more data because the end of    *            the stream has been reached.    * @throws IOException if an I/O error occurs.    */
DECL|method|readChecksumChunk (byte b[], final int off, final int len)
specifier|private
name|int
name|readChecksumChunk
parameter_list|(
name|byte
name|b
index|[]
parameter_list|,
specifier|final
name|int
name|off
parameter_list|,
specifier|final
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
comment|// invalidate buffer
name|count
operator|=
name|pos
operator|=
literal|0
expr_stmt|;
name|int
name|read
init|=
literal|0
decl_stmt|;
name|boolean
name|retry
init|=
literal|true
decl_stmt|;
name|int
name|retriesLeft
init|=
name|numOfRetries
decl_stmt|;
do|do
block|{
name|retriesLeft
operator|--
expr_stmt|;
try|try
block|{
name|read
operator|=
name|readChunk
argument_list|(
name|chunkPos
argument_list|,
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|needChecksum
argument_list|()
condition|)
block|{
name|verifySums
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|read
argument_list|)
expr_stmt|;
block|}
name|chunkPos
operator|+=
name|read
expr_stmt|;
block|}
name|retry
operator|=
literal|false
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ChecksumException
name|ce
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Found checksum error: b["
operator|+
name|off
operator|+
literal|", "
operator|+
operator|(
name|off
operator|+
name|read
operator|)
operator|+
literal|"]="
operator|+
name|StringUtils
operator|.
name|byteToHexString
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|off
operator|+
name|read
argument_list|)
argument_list|,
name|ce
argument_list|)
expr_stmt|;
if|if
condition|(
name|retriesLeft
operator|==
literal|0
condition|)
block|{
throw|throw
name|ce
throw|;
block|}
comment|// try a new replica
if|if
condition|(
name|seekToNewSource
argument_list|(
name|chunkPos
argument_list|)
condition|)
block|{
comment|// Since at least one of the sources is different,
comment|// the read might succeed, so we'll retry.
name|seek
argument_list|(
name|chunkPos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Neither the data stream nor the checksum stream are being read
comment|// from different sources, meaning we'll still get a checksum error
comment|// if we try to do the read again.  We throw an exception instead.
throw|throw
name|ce
throw|;
block|}
block|}
block|}
do|while
condition|(
name|retry
condition|)
do|;
return|return
name|read
return|;
block|}
DECL|method|verifySums (final byte b[], final int off, int read)
specifier|private
name|void
name|verifySums
parameter_list|(
specifier|final
name|byte
name|b
index|[]
parameter_list|,
specifier|final
name|int
name|off
parameter_list|,
name|int
name|read
parameter_list|)
throws|throws
name|ChecksumException
block|{
name|int
name|leftToVerify
init|=
name|read
decl_stmt|;
name|int
name|verifyOff
init|=
literal|0
decl_stmt|;
name|checksumInts
operator|.
name|rewind
argument_list|()
expr_stmt|;
name|checksumInts
operator|.
name|limit
argument_list|(
operator|(
name|read
operator|-
literal|1
operator|)
operator|/
name|maxChunkSize
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|leftToVerify
operator|>
literal|0
condition|)
block|{
name|sum
operator|.
name|update
argument_list|(
name|b
argument_list|,
name|off
operator|+
name|verifyOff
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|leftToVerify
argument_list|,
name|maxChunkSize
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|expected
init|=
name|checksumInts
operator|.
name|get
argument_list|()
decl_stmt|;
name|int
name|calculated
init|=
operator|(
name|int
operator|)
name|sum
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|sum
operator|.
name|reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|expected
operator|!=
name|calculated
condition|)
block|{
name|long
name|errPos
init|=
name|chunkPos
operator|+
name|verifyOff
decl_stmt|;
throw|throw
operator|new
name|ChecksumException
argument_list|(
literal|"Checksum error: "
operator|+
name|file
operator|+
literal|" at "
operator|+
name|errPos
operator|+
literal|" exp: "
operator|+
name|expected
operator|+
literal|" got: "
operator|+
name|calculated
argument_list|,
name|errPos
argument_list|)
throw|;
block|}
name|leftToVerify
operator|-=
name|maxChunkSize
expr_stmt|;
name|verifyOff
operator|+=
name|maxChunkSize
expr_stmt|;
block|}
block|}
comment|/**    * Convert a checksum byte array to a long    * This is deprecated since 0.22 since it is no longer in use    * by this class.    */
annotation|@
name|Deprecated
DECL|method|checksum2long (byte[] checksum)
specifier|static
specifier|public
name|long
name|checksum2long
parameter_list|(
name|byte
index|[]
name|checksum
parameter_list|)
block|{
name|long
name|crc
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|checksum
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|crc
operator||=
operator|(
literal|0xffL
operator|&
operator|(
name|long
operator|)
name|checksum
index|[
name|i
index|]
operator|)
operator|<<
operator|(
operator|(
name|checksum
operator|.
name|length
operator|-
name|i
operator|-
literal|1
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
block|}
return|return
name|crc
return|;
block|}
annotation|@
name|Override
DECL|method|getPos ()
specifier|public
specifier|synchronized
name|long
name|getPos
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|chunkPos
operator|-
name|Math
operator|.
name|max
argument_list|(
literal|0L
argument_list|,
name|count
operator|-
name|pos
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|available ()
specifier|public
specifier|synchronized
name|int
name|available
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|count
operator|-
name|pos
argument_list|)
return|;
block|}
comment|/**    * Skips over and discards<code>n</code> bytes of data from the    * input stream.    *    *<p>This method may skip more bytes than are remaining in the backing    * file. This produces no exception and the number of bytes skipped    * may include some number of bytes that were beyond the EOF of the    * backing file. Attempting to read from the stream after skipping past    * the end will result in -1 indicating the end of the file.    *    *<p>If<code>n</code> is negative, no bytes are skipped.    *    * @param      n   the number of bytes to be skipped.    * @return     the actual number of bytes skipped.    * @exception  IOException  if an I/O error occurs.    *             ChecksumException if the chunk to skip to is corrupted    */
annotation|@
name|Override
DECL|method|skip (long n)
specifier|public
specifier|synchronized
name|long
name|skip
parameter_list|(
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|seek
argument_list|(
name|getPos
argument_list|()
operator|+
name|n
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
comment|/**    * Seek to the given position in the stream.    * The next read() will be from that position.    *     *<p>This method may seek past the end of the file.    * This produces no exception and an attempt to read from    * the stream will result in -1 indicating the end of the file.    *    * @param      pos   the position to seek to.    * @exception  IOException  if an I/O error occurs.    *             ChecksumException if the chunk to seek to is corrupted    */
annotation|@
name|Override
DECL|method|seek (long pos)
specifier|public
specifier|synchronized
name|void
name|seek
parameter_list|(
name|long
name|pos
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
name|FSExceptionMessages
operator|.
name|NEGATIVE_SEEK
argument_list|)
throw|;
block|}
comment|// optimize: check if the pos is in the buffer
name|long
name|start
init|=
name|chunkPos
operator|-
name|this
operator|.
name|count
decl_stmt|;
if|if
condition|(
name|pos
operator|>=
name|start
operator|&&
name|pos
operator|<
name|chunkPos
condition|)
block|{
name|this
operator|.
name|pos
operator|=
call|(
name|int
call|)
argument_list|(
name|pos
operator|-
name|start
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// reset the current state
name|resetState
argument_list|()
expr_stmt|;
comment|// seek to a checksum boundary
name|chunkPos
operator|=
name|getChunkPosition
argument_list|(
name|pos
argument_list|)
expr_stmt|;
comment|// scan to the desired position
name|int
name|delta
init|=
call|(
name|int
call|)
argument_list|(
name|pos
operator|-
name|chunkPos
argument_list|)
decl_stmt|;
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
block|{
name|readFully
argument_list|(
name|this
argument_list|,
operator|new
name|byte
index|[
name|delta
index|]
argument_list|,
literal|0
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * A utility function that tries to read up to<code>len</code> bytes from    *<code>stm</code>    *     * @param stm    an input stream    * @param buf    destination buffer    * @param offset offset at which to store data    * @param len    number of bytes to read    * @return actual number of bytes read    * @throws IOException if there is any IO error    */
DECL|method|readFully (InputStream stm, byte[] buf, int offset, int len)
specifier|protected
specifier|static
name|int
name|readFully
parameter_list|(
name|InputStream
name|stm
parameter_list|,
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|nread
init|=
name|stm
operator|.
name|read
argument_list|(
name|buf
argument_list|,
name|offset
operator|+
name|n
argument_list|,
name|len
operator|-
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|nread
operator|<=
literal|0
condition|)
return|return
operator|(
name|n
operator|==
literal|0
operator|)
condition|?
name|nread
else|:
name|n
return|;
name|n
operator|+=
name|nread
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|len
condition|)
return|return
name|n
return|;
block|}
block|}
comment|/**    * Set the checksum related parameters    * @param verifyChecksum whether to verify checksum    * @param sum which type of checksum to use    * @param maxChunkSize maximun chunk size    * @param checksumSize checksum size    */
DECL|method|set (boolean verifyChecksum, Checksum sum, int maxChunkSize, int checksumSize)
specifier|final
specifier|protected
specifier|synchronized
name|void
name|set
parameter_list|(
name|boolean
name|verifyChecksum
parameter_list|,
name|Checksum
name|sum
parameter_list|,
name|int
name|maxChunkSize
parameter_list|,
name|int
name|checksumSize
parameter_list|)
block|{
comment|// The code makes assumptions that checksums are always 32-bit.
assert|assert
operator|!
name|verifyChecksum
operator|||
name|sum
operator|==
literal|null
operator|||
name|checksumSize
operator|==
name|CHECKSUM_SIZE
assert|;
name|this
operator|.
name|maxChunkSize
operator|=
name|maxChunkSize
expr_stmt|;
name|this
operator|.
name|verifyChecksum
operator|=
name|verifyChecksum
expr_stmt|;
name|this
operator|.
name|sum
operator|=
name|sum
expr_stmt|;
name|this
operator|.
name|buf
operator|=
operator|new
name|byte
index|[
name|maxChunkSize
index|]
expr_stmt|;
comment|// The size of the checksum array here determines how much we can
comment|// read in a single call to readChunk
name|this
operator|.
name|checksum
operator|=
operator|new
name|byte
index|[
name|CHUNKS_PER_READ
operator|*
name|checksumSize
index|]
expr_stmt|;
name|this
operator|.
name|checksumInts
operator|=
name|ByteBuffer
operator|.
name|wrap
argument_list|(
name|checksum
argument_list|)
operator|.
name|asIntBuffer
argument_list|()
expr_stmt|;
name|this
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|markSupported ()
specifier|final
specifier|public
name|boolean
name|markSupported
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|mark (int readlimit)
specifier|final
specifier|public
name|void
name|mark
parameter_list|(
name|int
name|readlimit
parameter_list|)
block|{   }
annotation|@
name|Override
DECL|method|reset ()
specifier|final
specifier|public
name|void
name|reset
parameter_list|()
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"mark/reset not supported"
argument_list|)
throw|;
block|}
comment|/* reset this FSInputChecker's state */
DECL|method|resetState ()
specifier|private
name|void
name|resetState
parameter_list|()
block|{
comment|// invalidate buffer
name|count
operator|=
literal|0
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
comment|// reset Checksum
if|if
condition|(
name|sum
operator|!=
literal|null
condition|)
block|{
name|sum
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

