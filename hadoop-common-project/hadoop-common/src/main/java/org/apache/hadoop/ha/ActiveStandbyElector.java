begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.ha
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|HadoopIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|ACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Watcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|WatchedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|ZooKeeper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|CreateMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|AsyncCallback
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Stat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
operator|.
name|Code
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  *   * This class implements a simple library to perform leader election on top of  * Apache Zookeeper. Using Zookeeper as a coordination service, leader election  * can be performed by atomically creating an ephemeral lock file (znode) on  * Zookeeper. The service instance that successfully creates the znode becomes  * active and the rest become standbys.<br/>  * This election mechanism is only efficient for small number of election  * candidates (order of 10's) because contention on single znode by a large  * number of candidates can result in Zookeeper overload.<br/>  * The elector does not guarantee fencing (protection of shared resources) among  * service instances. After it has notified an instance about becoming a leader,  * then that instance must ensure that it meets the service consistency  * requirements. If it cannot do so, then it is recommended to quit the  * election. The application implements the {@link ActiveStandbyElectorCallback}  * to interact with the elector  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|ActiveStandbyElector
specifier|public
class|class
name|ActiveStandbyElector
implements|implements
name|Watcher
implements|,
name|StringCallback
implements|,
name|StatCallback
block|{
comment|/**    * Callback interface to interact with the ActiveStandbyElector object.<br/>    * The application will be notified with a callback only on state changes    * (i.e. there will never be successive calls to becomeActive without an    * intermediate call to enterNeutralMode).<br/>    * The callbacks will be running on Zookeeper client library threads. The    * application should return from these callbacks quickly so as not to impede    * Zookeeper client library performance and notifications. The app will    * typically remember the state change and return from the callback. It will    * then proceed with implementing actions around that state change. It is    * possible to be called back again while these actions are in flight and the    * app should handle this scenario.    */
DECL|interface|ActiveStandbyElectorCallback
specifier|public
interface|interface
name|ActiveStandbyElectorCallback
block|{
comment|/**      * This method is called when the app becomes the active leader      */
DECL|method|becomeActive ()
name|void
name|becomeActive
parameter_list|()
function_decl|;
comment|/**      * This method is called when the app becomes a standby      */
DECL|method|becomeStandby ()
name|void
name|becomeStandby
parameter_list|()
function_decl|;
comment|/**      * If the elector gets disconnected from Zookeeper and does not know about      * the lock state, then it will notify the service via the enterNeutralMode      * interface. The service may choose to ignore this or stop doing state      * changing operations. Upon reconnection, the elector verifies the leader      * status and calls back on the becomeActive and becomeStandby app      * interfaces.<br/>      * Zookeeper disconnects can happen due to network issues or loss of      * Zookeeper quorum. Thus enterNeutralMode can be used to guard against      * split-brain issues. In such situations it might be prudent to call      * becomeStandby too. However, such state change operations might be      * expensive and enterNeutralMode can help guard against doing that for      * transient issues.      */
DECL|method|enterNeutralMode ()
name|void
name|enterNeutralMode
parameter_list|()
function_decl|;
comment|/**      * If there is any fatal error (e.g. wrong ACL's, unexpected Zookeeper      * errors or Zookeeper persistent unavailability) then notifyFatalError is      * called to notify the app about it.      */
DECL|method|notifyFatalError (String errorMessage)
name|void
name|notifyFatalError
parameter_list|(
name|String
name|errorMessage
parameter_list|)
function_decl|;
block|}
comment|/**    * Name of the lock znode used by the library. Protected for access in test    * classes    */
annotation|@
name|VisibleForTesting
DECL|field|LOCKFILENAME
specifier|protected
specifier|static
specifier|final
name|String
name|LOCKFILENAME
init|=
literal|"ActiveStandbyElectorLock"
decl_stmt|;
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ActiveStandbyElector
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|NUM_RETRIES
specifier|private
specifier|static
specifier|final
name|int
name|NUM_RETRIES
init|=
literal|3
decl_stmt|;
DECL|enum|ConnectionState
specifier|private
enum|enum
name|ConnectionState
block|{
DECL|enumConstant|DISCONNECTED
DECL|enumConstant|CONNECTED
DECL|enumConstant|TERMINATED
name|DISCONNECTED
block|,
name|CONNECTED
block|,
name|TERMINATED
block|}
empty_stmt|;
DECL|enum|State
specifier|private
enum|enum
name|State
block|{
DECL|enumConstant|INIT
DECL|enumConstant|ACTIVE
DECL|enumConstant|STANDBY
DECL|enumConstant|NEUTRAL
name|INIT
block|,
name|ACTIVE
block|,
name|STANDBY
block|,
name|NEUTRAL
block|}
empty_stmt|;
DECL|field|state
specifier|private
name|State
name|state
init|=
name|State
operator|.
name|INIT
decl_stmt|;
DECL|field|createRetryCount
specifier|private
name|int
name|createRetryCount
init|=
literal|0
decl_stmt|;
DECL|field|statRetryCount
specifier|private
name|int
name|statRetryCount
init|=
literal|0
decl_stmt|;
DECL|field|zkClient
specifier|private
name|ZooKeeper
name|zkClient
decl_stmt|;
DECL|field|zkConnectionState
specifier|private
name|ConnectionState
name|zkConnectionState
init|=
name|ConnectionState
operator|.
name|TERMINATED
decl_stmt|;
DECL|field|appClient
specifier|private
specifier|final
name|ActiveStandbyElectorCallback
name|appClient
decl_stmt|;
DECL|field|zkHostPort
specifier|private
specifier|final
name|String
name|zkHostPort
decl_stmt|;
DECL|field|zkSessionTimeout
specifier|private
specifier|final
name|int
name|zkSessionTimeout
decl_stmt|;
DECL|field|zkAcl
specifier|private
specifier|final
name|List
argument_list|<
name|ACL
argument_list|>
name|zkAcl
decl_stmt|;
DECL|field|appData
specifier|private
name|byte
index|[]
name|appData
decl_stmt|;
DECL|field|zkLockFilePath
specifier|private
specifier|final
name|String
name|zkLockFilePath
decl_stmt|;
DECL|field|znodeWorkingDir
specifier|private
specifier|final
name|String
name|znodeWorkingDir
decl_stmt|;
comment|/**    * Create a new ActiveStandbyElector object<br/>    * The elector is created by providing to it the Zookeeper configuration, the    * parent znode under which to create the znode and a reference to the    * callback interface.<br/>    * The parent znode name must be the same for all service instances and    * different across services.<br/>    * After the leader has been lost, a new leader will be elected after the    * session timeout expires. Hence, the app must set this parameter based on    * its needs for failure response time. The session timeout must be greater    * than the Zookeeper disconnect timeout and is recommended to be 3X that    * value to enable Zookeeper to retry transient disconnections. Setting a very    * short session timeout may result in frequent transitions between active and    * standby states during issues like network outages/GS pauses.    *     * @param zookeeperHostPorts    *          ZooKeeper hostPort for all ZooKeeper servers    * @param zookeeperSessionTimeout    *          ZooKeeper session timeout    * @param parentZnodeName    *          znode under which to create the lock    * @param acl    *          ZooKeeper ACL's    * @param app    *          reference to callback interface object    * @throws IOException    * @throws HadoopIllegalArgumentException    */
DECL|method|ActiveStandbyElector (String zookeeperHostPorts, int zookeeperSessionTimeout, String parentZnodeName, List<ACL> acl, ActiveStandbyElectorCallback app)
specifier|public
name|ActiveStandbyElector
parameter_list|(
name|String
name|zookeeperHostPorts
parameter_list|,
name|int
name|zookeeperSessionTimeout
parameter_list|,
name|String
name|parentZnodeName
parameter_list|,
name|List
argument_list|<
name|ACL
argument_list|>
name|acl
parameter_list|,
name|ActiveStandbyElectorCallback
name|app
parameter_list|)
throws|throws
name|IOException
throws|,
name|HadoopIllegalArgumentException
block|{
if|if
condition|(
name|app
operator|==
literal|null
operator|||
name|acl
operator|==
literal|null
operator|||
name|parentZnodeName
operator|==
literal|null
operator|||
name|zookeeperHostPorts
operator|==
literal|null
operator|||
name|zookeeperSessionTimeout
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Invalid argument"
argument_list|)
throw|;
block|}
name|zkHostPort
operator|=
name|zookeeperHostPorts
expr_stmt|;
name|zkSessionTimeout
operator|=
name|zookeeperSessionTimeout
expr_stmt|;
name|zkAcl
operator|=
name|acl
expr_stmt|;
name|appClient
operator|=
name|app
expr_stmt|;
name|znodeWorkingDir
operator|=
name|parentZnodeName
expr_stmt|;
name|zkLockFilePath
operator|=
name|znodeWorkingDir
operator|+
literal|"/"
operator|+
name|LOCKFILENAME
expr_stmt|;
comment|// createConnection for future API calls
name|createConnection
argument_list|()
expr_stmt|;
block|}
comment|/**    * To participate in election, the app will call joinElection. The result will    * be notified by a callback on either the becomeActive or becomeStandby app    * interfaces.<br/>    * After this the elector will automatically monitor the leader status and    * perform re-election if necessary<br/>    * The app could potentially start off in standby mode and ignore the    * becomeStandby call.    *     * @param data    *          to be set by the app. non-null data must be set.    * @throws HadoopIllegalArgumentException    *           if valid data is not supplied    */
DECL|method|joinElection (byte[] data)
specifier|public
specifier|synchronized
name|void
name|joinElection
parameter_list|(
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|HadoopIllegalArgumentException
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting active election"
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"data cannot be null"
argument_list|)
throw|;
block|}
name|appData
operator|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|appData
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|joinElectionInternal
argument_list|()
expr_stmt|;
block|}
comment|/**    * Any service instance can drop out of the election by calling quitElection.     *<br/>    * This will lose any leader status, if held, and stop monitoring of the lock    * node.<br/>    * If the instance wants to participate in election again, then it needs to    * call joinElection().<br/>    * This allows service instances to take themselves out of rotation for known    * impending unavailable states (e.g. long GC pause or software upgrade).    */
DECL|method|quitElection ()
specifier|public
specifier|synchronized
name|void
name|quitElection
parameter_list|()
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Yielding from election"
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
block|}
comment|/**    * Exception thrown when there is no active leader    */
DECL|class|ActiveNotFoundException
specifier|public
class|class
name|ActiveNotFoundException
extends|extends
name|Exception
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|3505396722342846462L
decl_stmt|;
block|}
comment|/**    * get data set by the active leader    *     * @return data set by the active instance    * @throws ActiveNotFoundException    *           when there is no active leader    * @throws KeeperException    *           other zookeeper operation errors    * @throws InterruptedException    * @throws IOException    *           when ZooKeeper connection could not be established    */
DECL|method|getActiveData ()
specifier|public
specifier|synchronized
name|byte
index|[]
name|getActiveData
parameter_list|()
throws|throws
name|ActiveNotFoundException
throws|,
name|KeeperException
throws|,
name|InterruptedException
throws|,
name|IOException
block|{
try|try
block|{
if|if
condition|(
name|zkClient
operator|==
literal|null
condition|)
block|{
name|createConnection
argument_list|()
expr_stmt|;
block|}
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
return|return
name|zkClient
operator|.
name|getData
argument_list|(
name|zkLockFilePath
argument_list|,
literal|false
argument_list|,
name|stat
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|Code
name|code
init|=
name|e
operator|.
name|code
argument_list|()
decl_stmt|;
if|if
condition|(
name|operationNodeDoesNotExist
argument_list|(
name|code
argument_list|)
condition|)
block|{
comment|// handle the commonly expected cases that make sense for us
throw|throw
operator|new
name|ActiveNotFoundException
argument_list|()
throw|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
block|}
comment|/**    * interface implementation of Zookeeper callback for create    */
annotation|@
name|Override
DECL|method|processResult (int rc, String path, Object ctx, String name)
specifier|public
specifier|synchronized
name|void
name|processResult
parameter_list|(
name|int
name|rc
parameter_list|,
name|String
name|path
parameter_list|,
name|Object
name|ctx
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"CreateNode result: "
operator|+
name|rc
operator|+
literal|" for path: "
operator|+
name|path
operator|+
literal|" connectionState: "
operator|+
name|zkConnectionState
argument_list|)
expr_stmt|;
if|if
condition|(
name|zkClient
operator|==
literal|null
condition|)
block|{
comment|// zkClient is nulled before closing the connection
comment|// this is the callback with session expired after we closed the session
return|return;
block|}
name|Code
name|code
init|=
name|Code
operator|.
name|get
argument_list|(
name|rc
argument_list|)
decl_stmt|;
if|if
condition|(
name|operationSuccess
argument_list|(
name|code
argument_list|)
condition|)
block|{
comment|// we successfully created the znode. we are the leader. start monitoring
name|becomeActive
argument_list|()
expr_stmt|;
name|monitorActiveStatus
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|operationNodeExists
argument_list|(
name|code
argument_list|)
condition|)
block|{
if|if
condition|(
name|createRetryCount
operator|==
literal|0
condition|)
block|{
comment|// znode exists and we did not retry the operation. so a different
comment|// instance has created it. become standby and monitor lock.
name|becomeStandby
argument_list|()
expr_stmt|;
block|}
comment|// if we had retried then the znode could have been created by our first
comment|// attempt to the server (that we lost) and this node exists response is
comment|// for the second attempt. verify this case via ephemeral node owner. this
comment|// will happen on the callback for monitoring the lock.
name|monitorActiveStatus
argument_list|()
expr_stmt|;
return|return;
block|}
name|String
name|errorMessage
init|=
literal|"Received create error from Zookeeper. code:"
operator|+
name|code
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
if|if
condition|(
name|operationRetry
argument_list|(
name|code
argument_list|)
condition|)
block|{
if|if
condition|(
name|createRetryCount
operator|<
name|NUM_RETRIES
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Retrying createNode createRetryCount: "
operator|+
name|createRetryCount
argument_list|)
expr_stmt|;
operator|++
name|createRetryCount
expr_stmt|;
name|createNode
argument_list|()
expr_stmt|;
return|return;
block|}
name|errorMessage
operator|=
name|errorMessage
operator|+
literal|". Not retrying further znode create connection errors."
expr_stmt|;
block|}
name|fatalError
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
block|}
comment|/**    * interface implementation of Zookeeper callback for monitor (exists)    */
annotation|@
name|Override
DECL|method|processResult (int rc, String path, Object ctx, Stat stat)
specifier|public
specifier|synchronized
name|void
name|processResult
parameter_list|(
name|int
name|rc
parameter_list|,
name|String
name|path
parameter_list|,
name|Object
name|ctx
parameter_list|,
name|Stat
name|stat
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"StatNode result: "
operator|+
name|rc
operator|+
literal|" for path: "
operator|+
name|path
operator|+
literal|" connectionState: "
operator|+
name|zkConnectionState
argument_list|)
expr_stmt|;
if|if
condition|(
name|zkClient
operator|==
literal|null
condition|)
block|{
comment|// zkClient is nulled before closing the connection
comment|// this is the callback with session expired after we closed the session
return|return;
block|}
name|Code
name|code
init|=
name|Code
operator|.
name|get
argument_list|(
name|rc
argument_list|)
decl_stmt|;
if|if
condition|(
name|operationSuccess
argument_list|(
name|code
argument_list|)
condition|)
block|{
comment|// the following owner check completes verification in case the lock znode
comment|// creation was retried
if|if
condition|(
name|stat
operator|.
name|getEphemeralOwner
argument_list|()
operator|==
name|zkClient
operator|.
name|getSessionId
argument_list|()
condition|)
block|{
comment|// we own the lock znode. so we are the leader
name|becomeActive
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// we dont own the lock znode. so we are a standby.
name|becomeStandby
argument_list|()
expr_stmt|;
block|}
comment|// the watch set by us will notify about changes
return|return;
block|}
if|if
condition|(
name|operationNodeDoesNotExist
argument_list|(
name|code
argument_list|)
condition|)
block|{
comment|// the lock znode disappeared before we started monitoring it
name|enterNeutralMode
argument_list|()
expr_stmt|;
name|joinElectionInternal
argument_list|()
expr_stmt|;
return|return;
block|}
name|String
name|errorMessage
init|=
literal|"Received stat error from Zookeeper. code:"
operator|+
name|code
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
if|if
condition|(
name|operationRetry
argument_list|(
name|code
argument_list|)
condition|)
block|{
if|if
condition|(
name|statRetryCount
operator|<
name|NUM_RETRIES
condition|)
block|{
operator|++
name|statRetryCount
expr_stmt|;
name|monitorNode
argument_list|()
expr_stmt|;
return|return;
block|}
name|errorMessage
operator|=
name|errorMessage
operator|+
literal|". Not retrying further znode monitoring connection errors."
expr_stmt|;
block|}
name|fatalError
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
block|}
comment|/**    * interface implementation of Zookeeper watch events (connection and node)    */
annotation|@
name|Override
DECL|method|process (WatchedEvent event)
specifier|public
specifier|synchronized
name|void
name|process
parameter_list|(
name|WatchedEvent
name|event
parameter_list|)
block|{
name|Event
operator|.
name|EventType
name|eventType
init|=
name|event
operator|.
name|getType
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Watcher event type: "
operator|+
name|eventType
operator|+
literal|" with state:"
operator|+
name|event
operator|.
name|getState
argument_list|()
operator|+
literal|" for path:"
operator|+
name|event
operator|.
name|getPath
argument_list|()
operator|+
literal|" connectionState: "
operator|+
name|zkConnectionState
argument_list|)
expr_stmt|;
if|if
condition|(
name|zkClient
operator|==
literal|null
condition|)
block|{
comment|// zkClient is nulled before closing the connection
comment|// this is the callback with session expired after we closed the session
return|return;
block|}
if|if
condition|(
name|eventType
operator|==
name|Event
operator|.
name|EventType
operator|.
name|None
condition|)
block|{
comment|// the connection state has changed
switch|switch
condition|(
name|event
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|SyncConnected
case|:
comment|// if the listener was asked to move to safe state then it needs to
comment|// be undone
name|ConnectionState
name|prevConnectionState
init|=
name|zkConnectionState
decl_stmt|;
name|zkConnectionState
operator|=
name|ConnectionState
operator|.
name|CONNECTED
expr_stmt|;
if|if
condition|(
name|prevConnectionState
operator|==
name|ConnectionState
operator|.
name|DISCONNECTED
condition|)
block|{
name|monitorActiveStatus
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|Disconnected
case|:
comment|// ask the app to move to safe state because zookeeper connection
comment|// is not active and we dont know our state
name|zkConnectionState
operator|=
name|ConnectionState
operator|.
name|DISCONNECTED
expr_stmt|;
name|enterNeutralMode
argument_list|()
expr_stmt|;
break|break;
case|case
name|Expired
case|:
comment|// the connection got terminated because of session timeout
comment|// call listener to reconnect
name|enterNeutralMode
argument_list|()
expr_stmt|;
name|reJoinElection
argument_list|()
expr_stmt|;
break|break;
default|default:
name|fatalError
argument_list|(
literal|"Unexpected Zookeeper watch event state: "
operator|+
name|event
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
comment|// a watch on lock path in zookeeper has fired. so something has changed on
comment|// the lock. ideally we should check that the path is the same as the lock
comment|// path but trusting zookeeper for now
name|String
name|path
init|=
name|event
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|path
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|eventType
condition|)
block|{
case|case
name|NodeDeleted
case|:
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|ACTIVE
condition|)
block|{
name|enterNeutralMode
argument_list|()
expr_stmt|;
block|}
name|joinElectionInternal
argument_list|()
expr_stmt|;
break|break;
case|case
name|NodeDataChanged
case|:
name|monitorActiveStatus
argument_list|()
expr_stmt|;
break|break;
default|default:
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unexpected node event: "
operator|+
name|eventType
operator|+
literal|" for path: "
operator|+
name|path
argument_list|)
expr_stmt|;
name|monitorActiveStatus
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
comment|// some unexpected error has occurred
name|fatalError
argument_list|(
literal|"Unexpected watch error from Zookeeper"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get a new zookeeper client instance. protected so that test class can    * inherit and pass in a mock object for zookeeper    *     * @return new zookeeper client instance    * @throws IOException    */
DECL|method|getNewZooKeeper ()
specifier|protected
specifier|synchronized
name|ZooKeeper
name|getNewZooKeeper
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|new
name|ZooKeeper
argument_list|(
name|zkHostPort
argument_list|,
name|zkSessionTimeout
argument_list|,
name|this
argument_list|)
return|;
block|}
DECL|method|fatalError (String errorMessage)
specifier|private
name|void
name|fatalError
parameter_list|(
name|String
name|errorMessage
parameter_list|)
block|{
name|reset
argument_list|()
expr_stmt|;
name|appClient
operator|.
name|notifyFatalError
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
block|}
DECL|method|monitorActiveStatus ()
specifier|private
name|void
name|monitorActiveStatus
parameter_list|()
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Monitoring active leader"
argument_list|)
expr_stmt|;
name|statRetryCount
operator|=
literal|0
expr_stmt|;
name|monitorNode
argument_list|()
expr_stmt|;
block|}
DECL|method|joinElectionInternal ()
specifier|private
name|void
name|joinElectionInternal
parameter_list|()
block|{
if|if
condition|(
name|zkClient
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|reEstablishSession
argument_list|()
condition|)
block|{
name|fatalError
argument_list|(
literal|"Failed to reEstablish connection with ZooKeeper"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|createRetryCount
operator|=
literal|0
expr_stmt|;
name|createNode
argument_list|()
expr_stmt|;
block|}
DECL|method|reJoinElection ()
specifier|private
name|void
name|reJoinElection
parameter_list|()
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Trying to re-establish ZK session"
argument_list|)
expr_stmt|;
name|terminateConnection
argument_list|()
expr_stmt|;
name|joinElectionInternal
argument_list|()
expr_stmt|;
block|}
DECL|method|reEstablishSession ()
specifier|private
name|boolean
name|reEstablishSession
parameter_list|()
block|{
name|int
name|connectionRetryCount
init|=
literal|0
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|success
operator|&&
name|connectionRetryCount
operator|<
name|NUM_RETRIES
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Establishing zookeeper connection"
argument_list|)
expr_stmt|;
try|try
block|{
name|createConnection
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e1
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e1
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|connectionRetryCount
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
DECL|method|createConnection ()
specifier|private
name|void
name|createConnection
parameter_list|()
throws|throws
name|IOException
block|{
name|zkClient
operator|=
name|getNewZooKeeper
argument_list|()
expr_stmt|;
block|}
DECL|method|terminateConnection ()
specifier|private
name|void
name|terminateConnection
parameter_list|()
block|{
if|if
condition|(
name|zkClient
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Terminating ZK connection"
argument_list|)
expr_stmt|;
name|ZooKeeper
name|tempZk
init|=
name|zkClient
decl_stmt|;
name|zkClient
operator|=
literal|null
expr_stmt|;
try|try
block|{
name|tempZk
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|zkConnectionState
operator|=
name|ConnectionState
operator|.
name|TERMINATED
expr_stmt|;
block|}
DECL|method|reset ()
specifier|private
name|void
name|reset
parameter_list|()
block|{
name|state
operator|=
name|State
operator|.
name|INIT
expr_stmt|;
name|terminateConnection
argument_list|()
expr_stmt|;
block|}
DECL|method|becomeActive ()
specifier|private
name|void
name|becomeActive
parameter_list|()
block|{
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|ACTIVE
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Becoming active"
argument_list|)
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|ACTIVE
expr_stmt|;
name|appClient
operator|.
name|becomeActive
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|becomeStandby ()
specifier|private
name|void
name|becomeStandby
parameter_list|()
block|{
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|STANDBY
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Becoming standby"
argument_list|)
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|STANDBY
expr_stmt|;
name|appClient
operator|.
name|becomeStandby
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|enterNeutralMode ()
specifier|private
name|void
name|enterNeutralMode
parameter_list|()
block|{
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|NEUTRAL
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Entering neutral mode"
argument_list|)
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|NEUTRAL
expr_stmt|;
name|appClient
operator|.
name|enterNeutralMode
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|createNode ()
specifier|private
name|void
name|createNode
parameter_list|()
block|{
name|zkClient
operator|.
name|create
argument_list|(
name|zkLockFilePath
argument_list|,
name|appData
argument_list|,
name|zkAcl
argument_list|,
name|CreateMode
operator|.
name|EPHEMERAL
argument_list|,
name|this
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|monitorNode ()
specifier|private
name|void
name|monitorNode
parameter_list|()
block|{
name|zkClient
operator|.
name|exists
argument_list|(
name|zkLockFilePath
argument_list|,
literal|true
argument_list|,
name|this
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|operationSuccess (Code code)
specifier|private
name|boolean
name|operationSuccess
parameter_list|(
name|Code
name|code
parameter_list|)
block|{
return|return
operator|(
name|code
operator|==
name|Code
operator|.
name|OK
operator|)
return|;
block|}
DECL|method|operationNodeExists (Code code)
specifier|private
name|boolean
name|operationNodeExists
parameter_list|(
name|Code
name|code
parameter_list|)
block|{
return|return
operator|(
name|code
operator|==
name|Code
operator|.
name|NODEEXISTS
operator|)
return|;
block|}
DECL|method|operationNodeDoesNotExist (Code code)
specifier|private
name|boolean
name|operationNodeDoesNotExist
parameter_list|(
name|Code
name|code
parameter_list|)
block|{
return|return
operator|(
name|code
operator|==
name|Code
operator|.
name|NONODE
operator|)
return|;
block|}
DECL|method|operationRetry (Code code)
specifier|private
name|boolean
name|operationRetry
parameter_list|(
name|Code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONNECTIONLOSS
case|:
case|case
name|OPERATIONTIMEOUT
case|:
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
block|}
end_class

end_unit

