begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.ha
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ha
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|HadoopIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ZKUtil
operator|.
name|ZKAuthInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|ACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Watcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|WatchedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|Watcher
operator|.
name|Event
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|ZKUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|ZooKeeper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|CreateMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|AsyncCallback
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Stat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
operator|.
name|Code
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_comment
comment|/**  *   * This class implements a simple library to perform leader election on top of  * Apache Zookeeper. Using Zookeeper as a coordination service, leader election  * can be performed by atomically creating an ephemeral lock file (znode) on  * Zookeeper. The service instance that successfully creates the znode becomes  * active and the rest become standbys.<br/>  * This election mechanism is only efficient for small number of election  * candidates (order of 10's) because contention on single znode by a large  * number of candidates can result in Zookeeper overload.<br/>  * The elector does not guarantee fencing (protection of shared resources) among  * service instances. After it has notified an instance about becoming a leader,  * then that instance must ensure that it meets the service consistency  * requirements. If it cannot do so, then it is recommended to quit the  * election. The application implements the {@link ActiveStandbyElectorCallback}  * to interact with the elector  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|ActiveStandbyElector
specifier|public
class|class
name|ActiveStandbyElector
implements|implements
name|StatCallback
implements|,
name|StringCallback
block|{
comment|/**    * Callback interface to interact with the ActiveStandbyElector object.<br/>    * The application will be notified with a callback only on state changes    * (i.e. there will never be successive calls to becomeActive without an    * intermediate call to enterNeutralMode).<br/>    * The callbacks will be running on Zookeeper client library threads. The    * application should return from these callbacks quickly so as not to impede    * Zookeeper client library performance and notifications. The app will    * typically remember the state change and return from the callback. It will    * then proceed with implementing actions around that state change. It is    * possible to be called back again while these actions are in flight and the    * app should handle this scenario.    */
DECL|interface|ActiveStandbyElectorCallback
specifier|public
interface|interface
name|ActiveStandbyElectorCallback
block|{
comment|/**      * This method is called when the app becomes the active leader.      * If the service fails to become active, it should throw      * ServiceFailedException. This will cause the elector to      * sleep for a short period, then re-join the election.      *       * Callback implementations are expected to manage their own      * timeouts (e.g. when making an RPC to a remote node).      */
DECL|method|becomeActive ()
name|void
name|becomeActive
parameter_list|()
throws|throws
name|ServiceFailedException
function_decl|;
comment|/**      * This method is called when the app becomes a standby      */
DECL|method|becomeStandby ()
name|void
name|becomeStandby
parameter_list|()
function_decl|;
comment|/**      * If the elector gets disconnected from Zookeeper and does not know about      * the lock state, then it will notify the service via the enterNeutralMode      * interface. The service may choose to ignore this or stop doing state      * changing operations. Upon reconnection, the elector verifies the leader      * status and calls back on the becomeActive and becomeStandby app      * interfaces.<br/>      * Zookeeper disconnects can happen due to network issues or loss of      * Zookeeper quorum. Thus enterNeutralMode can be used to guard against      * split-brain issues. In such situations it might be prudent to call      * becomeStandby too. However, such state change operations might be      * expensive and enterNeutralMode can help guard against doing that for      * transient issues.      */
DECL|method|enterNeutralMode ()
name|void
name|enterNeutralMode
parameter_list|()
function_decl|;
comment|/**      * If there is any fatal error (e.g. wrong ACL's, unexpected Zookeeper      * errors or Zookeeper persistent unavailability) then notifyFatalError is      * called to notify the app about it.      */
DECL|method|notifyFatalError (String errorMessage)
name|void
name|notifyFatalError
parameter_list|(
name|String
name|errorMessage
parameter_list|)
function_decl|;
comment|/**      * If an old active has failed, rather than exited gracefully, then      * the new active may need to take some fencing actions against it      * before proceeding with failover.      *       * @param oldActiveData the application data provided by the prior active      */
DECL|method|fenceOldActive (byte[] oldActiveData)
name|void
name|fenceOldActive
parameter_list|(
name|byte
index|[]
name|oldActiveData
parameter_list|)
function_decl|;
block|}
comment|/**    * Name of the lock znode used by the library. Protected for access in test    * classes    */
annotation|@
name|VisibleForTesting
DECL|field|LOCK_FILENAME
specifier|protected
specifier|static
specifier|final
name|String
name|LOCK_FILENAME
init|=
literal|"ActiveStandbyElectorLock"
decl_stmt|;
annotation|@
name|VisibleForTesting
DECL|field|BREADCRUMB_FILENAME
specifier|protected
specifier|static
specifier|final
name|String
name|BREADCRUMB_FILENAME
init|=
literal|"ActiveBreadCrumb"
decl_stmt|;
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|ActiveStandbyElector
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|NUM_RETRIES
specifier|static
name|int
name|NUM_RETRIES
init|=
literal|3
decl_stmt|;
DECL|field|SLEEP_AFTER_FAILURE_TO_BECOME_ACTIVE
specifier|private
specifier|static
specifier|final
name|int
name|SLEEP_AFTER_FAILURE_TO_BECOME_ACTIVE
init|=
literal|1000
decl_stmt|;
DECL|enum|ConnectionState
specifier|private
specifier|static
enum|enum
name|ConnectionState
block|{
DECL|enumConstant|DISCONNECTED
DECL|enumConstant|CONNECTED
DECL|enumConstant|TERMINATED
name|DISCONNECTED
block|,
name|CONNECTED
block|,
name|TERMINATED
block|}
empty_stmt|;
DECL|enum|State
specifier|static
enum|enum
name|State
block|{
DECL|enumConstant|INIT
DECL|enumConstant|ACTIVE
DECL|enumConstant|STANDBY
DECL|enumConstant|NEUTRAL
name|INIT
block|,
name|ACTIVE
block|,
name|STANDBY
block|,
name|NEUTRAL
block|}
empty_stmt|;
DECL|field|state
specifier|private
name|State
name|state
init|=
name|State
operator|.
name|INIT
decl_stmt|;
DECL|field|createRetryCount
specifier|private
name|int
name|createRetryCount
init|=
literal|0
decl_stmt|;
DECL|field|statRetryCount
specifier|private
name|int
name|statRetryCount
init|=
literal|0
decl_stmt|;
DECL|field|zkClient
specifier|private
name|ZooKeeper
name|zkClient
decl_stmt|;
DECL|field|watcher
specifier|private
name|WatcherWithClientRef
name|watcher
decl_stmt|;
DECL|field|zkConnectionState
specifier|private
name|ConnectionState
name|zkConnectionState
init|=
name|ConnectionState
operator|.
name|TERMINATED
decl_stmt|;
DECL|field|appClient
specifier|private
specifier|final
name|ActiveStandbyElectorCallback
name|appClient
decl_stmt|;
DECL|field|zkHostPort
specifier|private
specifier|final
name|String
name|zkHostPort
decl_stmt|;
DECL|field|zkSessionTimeout
specifier|private
specifier|final
name|int
name|zkSessionTimeout
decl_stmt|;
DECL|field|zkAcl
specifier|private
specifier|final
name|List
argument_list|<
name|ACL
argument_list|>
name|zkAcl
decl_stmt|;
DECL|field|zkAuthInfo
specifier|private
specifier|final
name|List
argument_list|<
name|ZKAuthInfo
argument_list|>
name|zkAuthInfo
decl_stmt|;
DECL|field|appData
specifier|private
name|byte
index|[]
name|appData
decl_stmt|;
DECL|field|zkLockFilePath
specifier|private
specifier|final
name|String
name|zkLockFilePath
decl_stmt|;
DECL|field|zkBreadCrumbPath
specifier|private
specifier|final
name|String
name|zkBreadCrumbPath
decl_stmt|;
DECL|field|znodeWorkingDir
specifier|private
specifier|final
name|String
name|znodeWorkingDir
decl_stmt|;
DECL|field|sessionReestablishLockForTests
specifier|private
name|Lock
name|sessionReestablishLockForTests
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
DECL|field|wantToBeInElection
specifier|private
name|boolean
name|wantToBeInElection
decl_stmt|;
comment|/**    * Create a new ActiveStandbyElector object<br/>    * The elector is created by providing to it the Zookeeper configuration, the    * parent znode under which to create the znode and a reference to the    * callback interface.<br/>    * The parent znode name must be the same for all service instances and    * different across services.<br/>    * After the leader has been lost, a new leader will be elected after the    * session timeout expires. Hence, the app must set this parameter based on    * its needs for failure response time. The session timeout must be greater    * than the Zookeeper disconnect timeout and is recommended to be 3X that    * value to enable Zookeeper to retry transient disconnections. Setting a very    * short session timeout may result in frequent transitions between active and    * standby states during issues like network outages/GS pauses.    *     * @param zookeeperHostPorts    *          ZooKeeper hostPort for all ZooKeeper servers    * @param zookeeperSessionTimeout    *          ZooKeeper session timeout    * @param parentZnodeName    *          znode under which to create the lock    * @param acl    *          ZooKeeper ACL's    * @param authInfo a list of authentication credentials to add to the    *                 ZK connection    * @param app    *          reference to callback interface object    * @throws IOException    * @throws HadoopIllegalArgumentException    */
DECL|method|ActiveStandbyElector (String zookeeperHostPorts, int zookeeperSessionTimeout, String parentZnodeName, List<ACL> acl, List<ZKAuthInfo> authInfo, ActiveStandbyElectorCallback app)
specifier|public
name|ActiveStandbyElector
parameter_list|(
name|String
name|zookeeperHostPorts
parameter_list|,
name|int
name|zookeeperSessionTimeout
parameter_list|,
name|String
name|parentZnodeName
parameter_list|,
name|List
argument_list|<
name|ACL
argument_list|>
name|acl
parameter_list|,
name|List
argument_list|<
name|ZKAuthInfo
argument_list|>
name|authInfo
parameter_list|,
name|ActiveStandbyElectorCallback
name|app
parameter_list|)
throws|throws
name|IOException
throws|,
name|HadoopIllegalArgumentException
throws|,
name|KeeperException
block|{
if|if
condition|(
name|app
operator|==
literal|null
operator|||
name|acl
operator|==
literal|null
operator|||
name|parentZnodeName
operator|==
literal|null
operator|||
name|zookeeperHostPorts
operator|==
literal|null
operator|||
name|zookeeperSessionTimeout
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Invalid argument"
argument_list|)
throw|;
block|}
name|zkHostPort
operator|=
name|zookeeperHostPorts
expr_stmt|;
name|zkSessionTimeout
operator|=
name|zookeeperSessionTimeout
expr_stmt|;
name|zkAcl
operator|=
name|acl
expr_stmt|;
name|zkAuthInfo
operator|=
name|authInfo
expr_stmt|;
name|appClient
operator|=
name|app
expr_stmt|;
name|znodeWorkingDir
operator|=
name|parentZnodeName
expr_stmt|;
name|zkLockFilePath
operator|=
name|znodeWorkingDir
operator|+
literal|"/"
operator|+
name|LOCK_FILENAME
expr_stmt|;
name|zkBreadCrumbPath
operator|=
name|znodeWorkingDir
operator|+
literal|"/"
operator|+
name|BREADCRUMB_FILENAME
expr_stmt|;
comment|// createConnection for future API calls
name|createConnection
argument_list|()
expr_stmt|;
block|}
comment|/**    * To participate in election, the app will call joinElection. The result will    * be notified by a callback on either the becomeActive or becomeStandby app    * interfaces.<br/>    * After this the elector will automatically monitor the leader status and    * perform re-election if necessary<br/>    * The app could potentially start off in standby mode and ignore the    * becomeStandby call.    *     * @param data    *          to be set by the app. non-null data must be set.    * @throws HadoopIllegalArgumentException    *           if valid data is not supplied    */
DECL|method|joinElection (byte[] data)
specifier|public
specifier|synchronized
name|void
name|joinElection
parameter_list|(
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|HadoopIllegalArgumentException
block|{
if|if
condition|(
name|data
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"data cannot be null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|wantToBeInElection
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Already in election. Not re-connecting."
argument_list|)
expr_stmt|;
return|return;
block|}
name|appData
operator|=
operator|new
name|byte
index|[
name|data
operator|.
name|length
index|]
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|appData
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempting active election for "
operator|+
name|this
argument_list|)
expr_stmt|;
name|joinElectionInternal
argument_list|()
expr_stmt|;
block|}
comment|/**    * @return true if the configured parent znode exists    */
DECL|method|parentZNodeExists ()
specifier|public
specifier|synchronized
name|boolean
name|parentZNodeExists
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|zkClient
operator|!=
literal|null
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|zkClient
operator|.
name|exists
argument_list|(
name|znodeWorkingDir
argument_list|,
literal|false
argument_list|)
operator|!=
literal|null
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Couldn't determine existence of znode '"
operator|+
name|znodeWorkingDir
operator|+
literal|"'"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**    * Utility function to ensure that the configured base znode exists.    * This recursively creates the znode as well as all of its parents.    */
DECL|method|ensureParentZNode ()
specifier|public
specifier|synchronized
name|void
name|ensureParentZNode
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|wantToBeInElection
argument_list|,
literal|"ensureParentZNode() may not be called while in the election"
argument_list|)
expr_stmt|;
name|String
name|pathParts
index|[]
init|=
name|znodeWorkingDir
operator|.
name|split
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|pathParts
operator|.
name|length
operator|>=
literal|1
operator|&&
name|pathParts
index|[
literal|0
index|]
operator|.
name|isEmpty
argument_list|()
argument_list|,
literal|"Invalid path: %s"
argument_list|,
name|znodeWorkingDir
argument_list|)
expr_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|pathParts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"/"
argument_list|)
operator|.
name|append
argument_list|(
name|pathParts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|String
name|prefixPath
init|=
name|sb
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Ensuring existence of "
operator|+
name|prefixPath
argument_list|)
expr_stmt|;
try|try
block|{
name|createWithRetries
argument_list|(
name|prefixPath
argument_list|,
operator|new
name|byte
index|[]
block|{}
argument_list|,
name|zkAcl
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isNodeExists
argument_list|(
name|e
operator|.
name|code
argument_list|()
argument_list|)
condition|)
block|{
comment|// This is OK - just ensuring existence.
continue|continue;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Couldn't create "
operator|+
name|prefixPath
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Successfully created "
operator|+
name|znodeWorkingDir
operator|+
literal|" in ZK."
argument_list|)
expr_stmt|;
block|}
comment|/**    * Clear all of the state held within the parent ZNode.    * This recursively deletes everything within the znode as well as the    * parent znode itself. It should only be used when it's certain that    * no electors are currently participating in the election.    */
DECL|method|clearParentZNode ()
specifier|public
specifier|synchronized
name|void
name|clearParentZNode
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
operator|!
name|wantToBeInElection
argument_list|,
literal|"clearParentZNode() may not be called while in the election"
argument_list|)
expr_stmt|;
try|try
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Recursively deleting "
operator|+
name|znodeWorkingDir
operator|+
literal|" from ZK..."
argument_list|)
expr_stmt|;
name|zkDoWithRetries
argument_list|(
operator|new
name|ZKAction
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|run
parameter_list|()
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
name|ZKUtil
operator|.
name|deleteRecursive
argument_list|(
name|zkClient
argument_list|,
name|znodeWorkingDir
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Couldn't clear parent znode "
operator|+
name|znodeWorkingDir
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Successfully deleted "
operator|+
name|znodeWorkingDir
operator|+
literal|" from ZK."
argument_list|)
expr_stmt|;
block|}
comment|/**    * Any service instance can drop out of the election by calling quitElection.     *<br/>    * This will lose any leader status, if held, and stop monitoring of the lock    * node.<br/>    * If the instance wants to participate in election again, then it needs to    * call joinElection().<br/>    * This allows service instances to take themselves out of rotation for known    * impending unavailable states (e.g. long GC pause or software upgrade).    *     * @param needFence true if the underlying daemon may need to be fenced    * if a failover occurs due to dropping out of the election.    */
DECL|method|quitElection (boolean needFence)
specifier|public
specifier|synchronized
name|void
name|quitElection
parameter_list|(
name|boolean
name|needFence
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Yielding from election"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|needFence
operator|&&
name|state
operator|==
name|State
operator|.
name|ACTIVE
condition|)
block|{
comment|// If active is gracefully going back to standby mode, remove
comment|// our permanent znode so no one fences us.
name|tryDeleteOwnBreadCrumbNode
argument_list|()
expr_stmt|;
block|}
name|reset
argument_list|()
expr_stmt|;
name|wantToBeInElection
operator|=
literal|false
expr_stmt|;
block|}
comment|/**    * Exception thrown when there is no active leader    */
DECL|class|ActiveNotFoundException
specifier|public
specifier|static
class|class
name|ActiveNotFoundException
extends|extends
name|Exception
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|3505396722342846462L
decl_stmt|;
block|}
comment|/**    * get data set by the active leader    *     * @return data set by the active instance    * @throws ActiveNotFoundException    *           when there is no active leader    * @throws KeeperException    *           other zookeeper operation errors    * @throws InterruptedException    * @throws IOException    *           when ZooKeeper connection could not be established    */
DECL|method|getActiveData ()
specifier|public
specifier|synchronized
name|byte
index|[]
name|getActiveData
parameter_list|()
throws|throws
name|ActiveNotFoundException
throws|,
name|KeeperException
throws|,
name|InterruptedException
throws|,
name|IOException
block|{
try|try
block|{
if|if
condition|(
name|zkClient
operator|==
literal|null
condition|)
block|{
name|createConnection
argument_list|()
expr_stmt|;
block|}
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
return|return
name|getDataWithRetries
argument_list|(
name|zkLockFilePath
argument_list|,
literal|false
argument_list|,
name|stat
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|Code
name|code
init|=
name|e
operator|.
name|code
argument_list|()
decl_stmt|;
if|if
condition|(
name|isNodeDoesNotExist
argument_list|(
name|code
argument_list|)
condition|)
block|{
comment|// handle the commonly expected cases that make sense for us
throw|throw
operator|new
name|ActiveNotFoundException
argument_list|()
throw|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
block|}
comment|/**    * interface implementation of Zookeeper callback for create    */
annotation|@
name|Override
DECL|method|processResult (int rc, String path, Object ctx, String name)
specifier|public
specifier|synchronized
name|void
name|processResult
parameter_list|(
name|int
name|rc
parameter_list|,
name|String
name|path
parameter_list|,
name|Object
name|ctx
parameter_list|,
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|isStaleClient
argument_list|(
name|ctx
argument_list|)
condition|)
return|return;
name|LOG
operator|.
name|debug
argument_list|(
literal|"CreateNode result: "
operator|+
name|rc
operator|+
literal|" for path: "
operator|+
name|path
operator|+
literal|" connectionState: "
operator|+
name|zkConnectionState
operator|+
literal|"  for "
operator|+
name|this
argument_list|)
expr_stmt|;
name|Code
name|code
init|=
name|Code
operator|.
name|get
argument_list|(
name|rc
argument_list|)
decl_stmt|;
if|if
condition|(
name|isSuccess
argument_list|(
name|code
argument_list|)
condition|)
block|{
comment|// we successfully created the znode. we are the leader. start monitoring
if|if
condition|(
name|becomeActive
argument_list|()
condition|)
block|{
name|monitorActiveStatus
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|reJoinElectionAfterFailureToBecomeActive
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|isNodeExists
argument_list|(
name|code
argument_list|)
condition|)
block|{
if|if
condition|(
name|createRetryCount
operator|==
literal|0
condition|)
block|{
comment|// znode exists and we did not retry the operation. so a different
comment|// instance has created it. become standby and monitor lock.
name|becomeStandby
argument_list|()
expr_stmt|;
block|}
comment|// if we had retried then the znode could have been created by our first
comment|// attempt to the server (that we lost) and this node exists response is
comment|// for the second attempt. verify this case via ephemeral node owner. this
comment|// will happen on the callback for monitoring the lock.
name|monitorActiveStatus
argument_list|()
expr_stmt|;
return|return;
block|}
name|String
name|errorMessage
init|=
literal|"Received create error from Zookeeper. code:"
operator|+
name|code
operator|.
name|toString
argument_list|()
operator|+
literal|" for path "
operator|+
name|path
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldRetry
argument_list|(
name|code
argument_list|)
condition|)
block|{
if|if
condition|(
name|createRetryCount
operator|<
name|NUM_RETRIES
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Retrying createNode createRetryCount: "
operator|+
name|createRetryCount
argument_list|)
expr_stmt|;
operator|++
name|createRetryCount
expr_stmt|;
name|createLockNodeAsync
argument_list|()
expr_stmt|;
return|return;
block|}
name|errorMessage
operator|=
name|errorMessage
operator|+
literal|". Not retrying further znode create connection errors."
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isSessionExpired
argument_list|(
name|code
argument_list|)
condition|)
block|{
comment|// This isn't fatal - the client Watcher will re-join the election
name|LOG
operator|.
name|warn
argument_list|(
literal|"Lock acquisition failed because session was lost"
argument_list|)
expr_stmt|;
return|return;
block|}
name|fatalError
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
block|}
comment|/**    * interface implementation of Zookeeper callback for monitor (exists)    */
annotation|@
name|Override
DECL|method|processResult (int rc, String path, Object ctx, Stat stat)
specifier|public
specifier|synchronized
name|void
name|processResult
parameter_list|(
name|int
name|rc
parameter_list|,
name|String
name|path
parameter_list|,
name|Object
name|ctx
parameter_list|,
name|Stat
name|stat
parameter_list|)
block|{
if|if
condition|(
name|isStaleClient
argument_list|(
name|ctx
argument_list|)
condition|)
return|return;
assert|assert
name|wantToBeInElection
operator|:
literal|"Got a StatNode result after quitting election"
assert|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"StatNode result: "
operator|+
name|rc
operator|+
literal|" for path: "
operator|+
name|path
operator|+
literal|" connectionState: "
operator|+
name|zkConnectionState
operator|+
literal|" for "
operator|+
name|this
argument_list|)
expr_stmt|;
name|Code
name|code
init|=
name|Code
operator|.
name|get
argument_list|(
name|rc
argument_list|)
decl_stmt|;
if|if
condition|(
name|isSuccess
argument_list|(
name|code
argument_list|)
condition|)
block|{
comment|// the following owner check completes verification in case the lock znode
comment|// creation was retried
if|if
condition|(
name|stat
operator|.
name|getEphemeralOwner
argument_list|()
operator|==
name|zkClient
operator|.
name|getSessionId
argument_list|()
condition|)
block|{
comment|// we own the lock znode. so we are the leader
if|if
condition|(
operator|!
name|becomeActive
argument_list|()
condition|)
block|{
name|reJoinElectionAfterFailureToBecomeActive
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// we dont own the lock znode. so we are a standby.
name|becomeStandby
argument_list|()
expr_stmt|;
block|}
comment|// the watch set by us will notify about changes
return|return;
block|}
if|if
condition|(
name|isNodeDoesNotExist
argument_list|(
name|code
argument_list|)
condition|)
block|{
comment|// the lock znode disappeared before we started monitoring it
name|enterNeutralMode
argument_list|()
expr_stmt|;
name|joinElectionInternal
argument_list|()
expr_stmt|;
return|return;
block|}
name|String
name|errorMessage
init|=
literal|"Received stat error from Zookeeper. code:"
operator|+
name|code
operator|.
name|toString
argument_list|()
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
if|if
condition|(
name|shouldRetry
argument_list|(
name|code
argument_list|)
condition|)
block|{
if|if
condition|(
name|statRetryCount
operator|<
name|NUM_RETRIES
condition|)
block|{
operator|++
name|statRetryCount
expr_stmt|;
name|monitorLockNodeAsync
argument_list|()
expr_stmt|;
return|return;
block|}
name|errorMessage
operator|=
name|errorMessage
operator|+
literal|". Not retrying further znode monitoring connection errors."
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isSessionExpired
argument_list|(
name|code
argument_list|)
condition|)
block|{
comment|// This isn't fatal - the client Watcher will re-join the election
name|LOG
operator|.
name|warn
argument_list|(
literal|"Lock monitoring failed because session was lost"
argument_list|)
expr_stmt|;
return|return;
block|}
name|fatalError
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
block|}
comment|/**    * We failed to become active. Re-join the election, but    * sleep for a few seconds after terminating our existing    * session, so that other nodes have a chance to become active.    * The failure to become active is already logged inside    * becomeActive().    */
DECL|method|reJoinElectionAfterFailureToBecomeActive ()
specifier|private
name|void
name|reJoinElectionAfterFailureToBecomeActive
parameter_list|()
block|{
name|reJoinElection
argument_list|(
name|SLEEP_AFTER_FAILURE_TO_BECOME_ACTIVE
argument_list|)
expr_stmt|;
block|}
comment|/**    * interface implementation of Zookeeper watch events (connection and node),    * proxied by {@link WatcherWithClientRef}.    */
DECL|method|processWatchEvent (ZooKeeper zk, WatchedEvent event)
specifier|synchronized
name|void
name|processWatchEvent
parameter_list|(
name|ZooKeeper
name|zk
parameter_list|,
name|WatchedEvent
name|event
parameter_list|)
block|{
name|Event
operator|.
name|EventType
name|eventType
init|=
name|event
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|isStaleClient
argument_list|(
name|zk
argument_list|)
condition|)
return|return;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Watcher event type: "
operator|+
name|eventType
operator|+
literal|" with state:"
operator|+
name|event
operator|.
name|getState
argument_list|()
operator|+
literal|" for path:"
operator|+
name|event
operator|.
name|getPath
argument_list|()
operator|+
literal|" connectionState: "
operator|+
name|zkConnectionState
operator|+
literal|" for "
operator|+
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|eventType
operator|==
name|Event
operator|.
name|EventType
operator|.
name|None
condition|)
block|{
comment|// the connection state has changed
switch|switch
condition|(
name|event
operator|.
name|getState
argument_list|()
condition|)
block|{
case|case
name|SyncConnected
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Session connected."
argument_list|)
expr_stmt|;
comment|// if the listener was asked to move to safe state then it needs to
comment|// be undone
name|ConnectionState
name|prevConnectionState
init|=
name|zkConnectionState
decl_stmt|;
name|zkConnectionState
operator|=
name|ConnectionState
operator|.
name|CONNECTED
expr_stmt|;
if|if
condition|(
name|prevConnectionState
operator|==
name|ConnectionState
operator|.
name|DISCONNECTED
operator|&&
name|wantToBeInElection
condition|)
block|{
name|monitorActiveStatus
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|Disconnected
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Session disconnected. Entering neutral mode..."
argument_list|)
expr_stmt|;
comment|// ask the app to move to safe state because zookeeper connection
comment|// is not active and we dont know our state
name|zkConnectionState
operator|=
name|ConnectionState
operator|.
name|DISCONNECTED
expr_stmt|;
name|enterNeutralMode
argument_list|()
expr_stmt|;
break|break;
case|case
name|Expired
case|:
comment|// the connection got terminated because of session timeout
comment|// call listener to reconnect
name|LOG
operator|.
name|info
argument_list|(
literal|"Session expired. Entering neutral mode and rejoining..."
argument_list|)
expr_stmt|;
name|enterNeutralMode
argument_list|()
expr_stmt|;
name|reJoinElection
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SaslAuthenticated
case|:
name|LOG
operator|.
name|info
argument_list|(
literal|"Successfully authenticated to ZooKeeper using SASL."
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatalError
argument_list|(
literal|"Unexpected Zookeeper watch event state: "
operator|+
name|event
operator|.
name|getState
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
comment|// a watch on lock path in zookeeper has fired. so something has changed on
comment|// the lock. ideally we should check that the path is the same as the lock
comment|// path but trusting zookeeper for now
name|String
name|path
init|=
name|event
operator|.
name|getPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|path
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|eventType
condition|)
block|{
case|case
name|NodeDeleted
case|:
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|ACTIVE
condition|)
block|{
name|enterNeutralMode
argument_list|()
expr_stmt|;
block|}
name|joinElectionInternal
argument_list|()
expr_stmt|;
break|break;
case|case
name|NodeDataChanged
case|:
name|monitorActiveStatus
argument_list|()
expr_stmt|;
break|break;
default|default:
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unexpected node event: "
operator|+
name|eventType
operator|+
literal|" for path: "
operator|+
name|path
argument_list|)
expr_stmt|;
name|monitorActiveStatus
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
comment|// some unexpected error has occurred
name|fatalError
argument_list|(
literal|"Unexpected watch error from Zookeeper"
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get a new zookeeper client instance. protected so that test class can    * inherit and pass in a mock object for zookeeper    *     * @return new zookeeper client instance    * @throws IOException    * @throws KeeperException zookeeper connectionloss exception    */
DECL|method|getNewZooKeeper ()
specifier|protected
specifier|synchronized
name|ZooKeeper
name|getNewZooKeeper
parameter_list|()
throws|throws
name|IOException
throws|,
name|KeeperException
block|{
comment|// Unfortunately, the ZooKeeper constructor connects to ZooKeeper and
comment|// may trigger the Connected event immediately. So, if we register the
comment|// watcher after constructing ZooKeeper, we may miss that event. Instead,
comment|// we construct the watcher first, and have it block any events it receives
comment|// before we can set its ZooKeeper reference.
name|watcher
operator|=
operator|new
name|WatcherWithClientRef
argument_list|()
expr_stmt|;
name|ZooKeeper
name|zk
init|=
operator|new
name|ZooKeeper
argument_list|(
name|zkHostPort
argument_list|,
name|zkSessionTimeout
argument_list|,
name|watcher
argument_list|)
decl_stmt|;
name|watcher
operator|.
name|setZooKeeperRef
argument_list|(
name|zk
argument_list|)
expr_stmt|;
comment|// Wait for the asynchronous success/failure. This may throw an exception
comment|// if we don't connect within the session timeout.
name|watcher
operator|.
name|waitForZKConnectionEvent
argument_list|(
name|zkSessionTimeout
argument_list|)
expr_stmt|;
for|for
control|(
name|ZKAuthInfo
name|auth
range|:
name|zkAuthInfo
control|)
block|{
name|zk
operator|.
name|addAuthInfo
argument_list|(
name|auth
operator|.
name|getScheme
argument_list|()
argument_list|,
name|auth
operator|.
name|getAuth
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|zk
return|;
block|}
DECL|method|fatalError (String errorMessage)
specifier|private
name|void
name|fatalError
parameter_list|(
name|String
name|errorMessage
parameter_list|)
block|{
name|LOG
operator|.
name|fatal
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
name|appClient
operator|.
name|notifyFatalError
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
block|}
DECL|method|monitorActiveStatus ()
specifier|private
name|void
name|monitorActiveStatus
parameter_list|()
block|{
assert|assert
name|wantToBeInElection
assert|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Monitoring active leader for "
operator|+
name|this
argument_list|)
expr_stmt|;
name|statRetryCount
operator|=
literal|0
expr_stmt|;
name|monitorLockNodeAsync
argument_list|()
expr_stmt|;
block|}
DECL|method|joinElectionInternal ()
specifier|private
name|void
name|joinElectionInternal
parameter_list|()
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|appData
operator|!=
literal|null
argument_list|,
literal|"trying to join election without any app data"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zkClient
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|reEstablishSession
argument_list|()
condition|)
block|{
name|fatalError
argument_list|(
literal|"Failed to reEstablish connection with ZooKeeper"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|createRetryCount
operator|=
literal|0
expr_stmt|;
name|wantToBeInElection
operator|=
literal|true
expr_stmt|;
name|createLockNodeAsync
argument_list|()
expr_stmt|;
block|}
DECL|method|reJoinElection (int sleepTime)
specifier|private
name|void
name|reJoinElection
parameter_list|(
name|int
name|sleepTime
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Trying to re-establish ZK session"
argument_list|)
expr_stmt|;
comment|// Some of the test cases rely on expiring the ZK sessions and
comment|// ensuring that the other node takes over. But, there's a race
comment|// where the original lease holder could reconnect faster than the other
comment|// thread manages to take the lock itself. This lock allows the
comment|// tests to block the reconnection. It's a shame that this leaked
comment|// into non-test code, but the lock is only acquired here so will never
comment|// be contended.
name|sessionReestablishLockForTests
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|terminateConnection
argument_list|()
expr_stmt|;
name|sleepFor
argument_list|(
name|sleepTime
argument_list|)
expr_stmt|;
comment|// Should not join election even before the SERVICE is reported
comment|// as HEALTHY from ZKFC monitoring.
if|if
condition|(
name|appData
operator|!=
literal|null
condition|)
block|{
name|joinElectionInternal
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Not joining election since service has not yet been "
operator|+
literal|"reported as healthy."
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|sessionReestablishLockForTests
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Sleep for the given number of milliseconds.    * This is non-static, and separated out, so that unit tests    * can override the behavior not to sleep.    */
annotation|@
name|VisibleForTesting
DECL|method|sleepFor (int sleepMs)
specifier|protected
name|void
name|sleepFor
parameter_list|(
name|int
name|sleepMs
parameter_list|)
block|{
if|if
condition|(
name|sleepMs
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|sleepMs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|preventSessionReestablishmentForTests ()
name|void
name|preventSessionReestablishmentForTests
parameter_list|()
block|{
name|sessionReestablishLockForTests
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|allowSessionReestablishmentForTests ()
name|void
name|allowSessionReestablishmentForTests
parameter_list|()
block|{
name|sessionReestablishLockForTests
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getZKSessionIdForTests ()
specifier|synchronized
name|long
name|getZKSessionIdForTests
parameter_list|()
block|{
if|if
condition|(
name|zkClient
operator|!=
literal|null
condition|)
block|{
return|return
name|zkClient
operator|.
name|getSessionId
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
annotation|@
name|VisibleForTesting
DECL|method|getStateForTests ()
specifier|synchronized
name|State
name|getStateForTests
parameter_list|()
block|{
return|return
name|state
return|;
block|}
DECL|method|reEstablishSession ()
specifier|private
name|boolean
name|reEstablishSession
parameter_list|()
block|{
name|int
name|connectionRetryCount
init|=
literal|0
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|success
operator|&&
name|connectionRetryCount
operator|<
name|NUM_RETRIES
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Establishing zookeeper connection for "
operator|+
name|this
argument_list|)
expr_stmt|;
try|try
block|{
name|createConnection
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|sleepFor
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|sleepFor
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
block|}
operator|++
name|connectionRetryCount
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
DECL|method|createConnection ()
specifier|private
name|void
name|createConnection
parameter_list|()
throws|throws
name|IOException
throws|,
name|KeeperException
block|{
if|if
condition|(
name|zkClient
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|zkClient
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Interrupted while closing ZK"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|zkClient
operator|=
literal|null
expr_stmt|;
name|watcher
operator|=
literal|null
expr_stmt|;
block|}
name|zkClient
operator|=
name|getNewZooKeeper
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Created new connection for "
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|method|terminateConnection ()
specifier|public
name|void
name|terminateConnection
parameter_list|()
block|{
if|if
condition|(
name|zkClient
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|LOG
operator|.
name|debug
argument_list|(
literal|"Terminating ZK connection for "
operator|+
name|this
argument_list|)
expr_stmt|;
name|ZooKeeper
name|tempZk
init|=
name|zkClient
decl_stmt|;
name|zkClient
operator|=
literal|null
expr_stmt|;
name|watcher
operator|=
literal|null
expr_stmt|;
try|try
block|{
name|tempZk
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|zkConnectionState
operator|=
name|ConnectionState
operator|.
name|TERMINATED
expr_stmt|;
name|wantToBeInElection
operator|=
literal|false
expr_stmt|;
block|}
DECL|method|reset ()
specifier|private
name|void
name|reset
parameter_list|()
block|{
name|state
operator|=
name|State
operator|.
name|INIT
expr_stmt|;
name|terminateConnection
argument_list|()
expr_stmt|;
block|}
DECL|method|becomeActive ()
specifier|private
name|boolean
name|becomeActive
parameter_list|()
block|{
assert|assert
name|wantToBeInElection
assert|;
if|if
condition|(
name|state
operator|==
name|State
operator|.
name|ACTIVE
condition|)
block|{
comment|// already active
return|return
literal|true
return|;
block|}
try|try
block|{
name|Stat
name|oldBreadcrumbStat
init|=
name|fenceOldActive
argument_list|()
decl_stmt|;
name|writeBreadCrumbNode
argument_list|(
name|oldBreadcrumbStat
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Becoming active for "
operator|+
name|this
argument_list|)
expr_stmt|;
name|appClient
operator|.
name|becomeActive
argument_list|()
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|ACTIVE
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception handling the winning of election"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// Caller will handle quitting and rejoining the election.
return|return
literal|false
return|;
block|}
block|}
comment|/**    * Write the "ActiveBreadCrumb" node, indicating that this node may need    * to be fenced on failover.    * @param oldBreadcrumbStat     */
DECL|method|writeBreadCrumbNode (Stat oldBreadcrumbStat)
specifier|private
name|void
name|writeBreadCrumbNode
parameter_list|(
name|Stat
name|oldBreadcrumbStat
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|appData
operator|!=
literal|null
argument_list|,
literal|"no appdata"
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Writing znode "
operator|+
name|zkBreadCrumbPath
operator|+
literal|" to indicate that the local node is the most recent active..."
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldBreadcrumbStat
operator|==
literal|null
condition|)
block|{
comment|// No previous active, just create the node
name|createWithRetries
argument_list|(
name|zkBreadCrumbPath
argument_list|,
name|appData
argument_list|,
name|zkAcl
argument_list|,
name|CreateMode
operator|.
name|PERSISTENT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// There was a previous active, update the node
name|setDataWithRetries
argument_list|(
name|zkBreadCrumbPath
argument_list|,
name|appData
argument_list|,
name|oldBreadcrumbStat
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Try to delete the "ActiveBreadCrumb" node when gracefully giving up    * active status.    * If this fails, it will simply warn, since the graceful release behavior    * is only an optimization.    */
DECL|method|tryDeleteOwnBreadCrumbNode ()
specifier|private
name|void
name|tryDeleteOwnBreadCrumbNode
parameter_list|()
block|{
assert|assert
name|state
operator|==
name|State
operator|.
name|ACTIVE
assert|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Deleting bread-crumb of active node..."
argument_list|)
expr_stmt|;
comment|// Sanity check the data. This shouldn't be strictly necessary,
comment|// but better to play it safe.
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
name|byte
index|[]
name|data
init|=
literal|null
decl_stmt|;
try|try
block|{
name|data
operator|=
name|zkClient
operator|.
name|getData
argument_list|(
name|zkBreadCrumbPath
argument_list|,
literal|false
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|data
argument_list|,
name|appData
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"We thought we were active, but in fact "
operator|+
literal|"the active znode had the wrong data: "
operator|+
name|StringUtils
operator|.
name|byteToHexString
argument_list|(
name|data
argument_list|)
operator|+
literal|" (stat="
operator|+
name|stat
operator|+
literal|")"
argument_list|)
throw|;
block|}
name|deleteWithRetries
argument_list|(
name|zkBreadCrumbPath
argument_list|,
name|stat
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to delete our own bread-crumb of being active at "
operator|+
name|zkBreadCrumbPath
operator|+
literal|": "
operator|+
name|e
operator|.
name|getLocalizedMessage
argument_list|()
operator|+
literal|". "
operator|+
literal|"Expecting to be fenced by the next active."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * If there is a breadcrumb node indicating that another node may need    * fencing, try to fence that node.    * @return the Stat of the breadcrumb node that was read, or null    * if no breadcrumb node existed    */
DECL|method|fenceOldActive ()
specifier|private
name|Stat
name|fenceOldActive
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|KeeperException
block|{
specifier|final
name|Stat
name|stat
init|=
operator|new
name|Stat
argument_list|()
decl_stmt|;
name|byte
index|[]
name|data
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Checking for any old active which needs to be fenced..."
argument_list|)
expr_stmt|;
try|try
block|{
name|data
operator|=
name|zkDoWithRetries
argument_list|(
operator|new
name|ZKAction
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|run
parameter_list|()
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
return|return
name|zkClient
operator|.
name|getData
argument_list|(
name|zkBreadCrumbPath
argument_list|,
literal|false
argument_list|,
name|stat
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|ke
parameter_list|)
block|{
if|if
condition|(
name|isNodeDoesNotExist
argument_list|(
name|ke
operator|.
name|code
argument_list|()
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"No old node to fence"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// If we failed to read for any other reason, then likely we lost
comment|// our session, or we don't have permissions, etc. In any case,
comment|// we probably shouldn't become active, and failing the whole
comment|// thing is the best bet.
throw|throw
name|ke
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Old node exists: "
operator|+
name|StringUtils
operator|.
name|byteToHexString
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Arrays
operator|.
name|equals
argument_list|(
name|data
argument_list|,
name|appData
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"But old node has our own data, so don't need to fence it."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|appClient
operator|.
name|fenceOldActive
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|stat
return|;
block|}
DECL|method|becomeStandby ()
specifier|private
name|void
name|becomeStandby
parameter_list|()
block|{
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|STANDBY
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Becoming standby for "
operator|+
name|this
argument_list|)
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|STANDBY
expr_stmt|;
name|appClient
operator|.
name|becomeStandby
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|enterNeutralMode ()
specifier|private
name|void
name|enterNeutralMode
parameter_list|()
block|{
if|if
condition|(
name|state
operator|!=
name|State
operator|.
name|NEUTRAL
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Entering neutral mode for "
operator|+
name|this
argument_list|)
expr_stmt|;
name|state
operator|=
name|State
operator|.
name|NEUTRAL
expr_stmt|;
name|appClient
operator|.
name|enterNeutralMode
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|createLockNodeAsync ()
specifier|private
name|void
name|createLockNodeAsync
parameter_list|()
block|{
name|zkClient
operator|.
name|create
argument_list|(
name|zkLockFilePath
argument_list|,
name|appData
argument_list|,
name|zkAcl
argument_list|,
name|CreateMode
operator|.
name|EPHEMERAL
argument_list|,
name|this
argument_list|,
name|zkClient
argument_list|)
expr_stmt|;
block|}
DECL|method|monitorLockNodeAsync ()
specifier|private
name|void
name|monitorLockNodeAsync
parameter_list|()
block|{
name|zkClient
operator|.
name|exists
argument_list|(
name|zkLockFilePath
argument_list|,
name|watcher
argument_list|,
name|this
argument_list|,
name|zkClient
argument_list|)
expr_stmt|;
block|}
DECL|method|createWithRetries (final String path, final byte[] data, final List<ACL> acl, final CreateMode mode)
specifier|private
name|String
name|createWithRetries
parameter_list|(
specifier|final
name|String
name|path
parameter_list|,
specifier|final
name|byte
index|[]
name|data
parameter_list|,
specifier|final
name|List
argument_list|<
name|ACL
argument_list|>
name|acl
parameter_list|,
specifier|final
name|CreateMode
name|mode
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|KeeperException
block|{
return|return
name|zkDoWithRetries
argument_list|(
operator|new
name|ZKAction
argument_list|<
name|String
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|String
name|run
parameter_list|()
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
return|return
name|zkClient
operator|.
name|create
argument_list|(
name|path
argument_list|,
name|data
argument_list|,
name|acl
argument_list|,
name|mode
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
DECL|method|getDataWithRetries (final String path, final boolean watch, final Stat stat)
specifier|private
name|byte
index|[]
name|getDataWithRetries
parameter_list|(
specifier|final
name|String
name|path
parameter_list|,
specifier|final
name|boolean
name|watch
parameter_list|,
specifier|final
name|Stat
name|stat
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|KeeperException
block|{
return|return
name|zkDoWithRetries
argument_list|(
operator|new
name|ZKAction
argument_list|<
name|byte
index|[]
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|run
parameter_list|()
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
return|return
name|zkClient
operator|.
name|getData
argument_list|(
name|path
argument_list|,
name|watch
argument_list|,
name|stat
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
DECL|method|setDataWithRetries (final String path, final byte[] data, final int version)
specifier|private
name|Stat
name|setDataWithRetries
parameter_list|(
specifier|final
name|String
name|path
parameter_list|,
specifier|final
name|byte
index|[]
name|data
parameter_list|,
specifier|final
name|int
name|version
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|KeeperException
block|{
return|return
name|zkDoWithRetries
argument_list|(
operator|new
name|ZKAction
argument_list|<
name|Stat
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Stat
name|run
parameter_list|()
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
return|return
name|zkClient
operator|.
name|setData
argument_list|(
name|path
argument_list|,
name|data
argument_list|,
name|version
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
DECL|method|deleteWithRetries (final String path, final int version)
specifier|private
name|void
name|deleteWithRetries
parameter_list|(
specifier|final
name|String
name|path
parameter_list|,
specifier|final
name|int
name|version
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
name|zkDoWithRetries
argument_list|(
operator|new
name|ZKAction
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|run
parameter_list|()
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
name|zkClient
operator|.
name|delete
argument_list|(
name|path
argument_list|,
name|version
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|zkDoWithRetries (ZKAction<T> action)
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|zkDoWithRetries
parameter_list|(
name|ZKAction
argument_list|<
name|T
argument_list|>
name|action
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|InterruptedException
block|{
name|int
name|retry
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
return|return
name|action
operator|.
name|run
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
name|ke
parameter_list|)
block|{
if|if
condition|(
name|shouldRetry
argument_list|(
name|ke
operator|.
name|code
argument_list|()
argument_list|)
operator|&&
operator|++
name|retry
operator|<
name|NUM_RETRIES
condition|)
block|{
continue|continue;
block|}
throw|throw
name|ke
throw|;
block|}
block|}
block|}
DECL|interface|ZKAction
specifier|private
interface|interface
name|ZKAction
parameter_list|<
name|T
parameter_list|>
block|{
DECL|method|run ()
name|T
name|run
parameter_list|()
throws|throws
name|KeeperException
throws|,
name|InterruptedException
function_decl|;
block|}
comment|/**    * The callbacks and watchers pass a reference to the ZK client    * which made the original call. We don't want to take action    * based on any callbacks from prior clients after we quit    * the election.    * @param ctx the ZK client passed into the watcher    * @return true if it matches the current client    */
DECL|method|isStaleClient (Object ctx)
specifier|private
specifier|synchronized
name|boolean
name|isStaleClient
parameter_list|(
name|Object
name|ctx
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|zkClient
operator|!=
operator|(
name|ZooKeeper
operator|)
name|ctx
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Ignoring stale result from old client with sessionId "
operator|+
name|String
operator|.
name|format
argument_list|(
literal|"0x%08x"
argument_list|,
operator|(
operator|(
name|ZooKeeper
operator|)
name|ctx
operator|)
operator|.
name|getSessionId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**    * Watcher implementation which keeps a reference around to the    * original ZK connection, and passes it back along with any    * events.    */
DECL|class|WatcherWithClientRef
specifier|private
specifier|final
class|class
name|WatcherWithClientRef
implements|implements
name|Watcher
block|{
DECL|field|zk
specifier|private
name|ZooKeeper
name|zk
decl_stmt|;
comment|/**      * Latch fired whenever any event arrives. This is used in order      * to wait for the Connected event when the client is first created.      */
DECL|field|hasReceivedEvent
specifier|private
name|CountDownLatch
name|hasReceivedEvent
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|/**      * Latch used to wait until the reference to ZooKeeper is set.      */
DECL|field|hasSetZooKeeper
specifier|private
name|CountDownLatch
name|hasSetZooKeeper
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|/**      * Waits for the next event from ZooKeeper to arrive.      *       * @param connectionTimeoutMs zookeeper connection timeout in milliseconds      * @throws KeeperException if the connection attempt times out. This will      * be a ZooKeeper ConnectionLoss exception code.      * @throws IOException if interrupted while connecting to ZooKeeper      */
DECL|method|waitForZKConnectionEvent (int connectionTimeoutMs)
specifier|private
name|void
name|waitForZKConnectionEvent
parameter_list|(
name|int
name|connectionTimeoutMs
parameter_list|)
throws|throws
name|KeeperException
throws|,
name|IOException
block|{
try|try
block|{
if|if
condition|(
operator|!
name|hasReceivedEvent
operator|.
name|await
argument_list|(
name|connectionTimeoutMs
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Connection timed out: couldn't connect to ZooKeeper in "
operator|+
name|connectionTimeoutMs
operator|+
literal|" milliseconds"
argument_list|)
expr_stmt|;
name|zk
operator|.
name|close
argument_list|()
expr_stmt|;
throw|throw
name|KeeperException
operator|.
name|create
argument_list|(
name|Code
operator|.
name|CONNECTIONLOSS
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Interrupted when connecting to zookeeper server"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|setZooKeeperRef (ZooKeeper zk)
specifier|private
name|void
name|setZooKeeperRef
parameter_list|(
name|ZooKeeper
name|zk
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkState
argument_list|(
name|this
operator|.
name|zk
operator|==
literal|null
argument_list|,
literal|"zk already set -- must be set exactly once"
argument_list|)
expr_stmt|;
name|this
operator|.
name|zk
operator|=
name|zk
expr_stmt|;
name|hasSetZooKeeper
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|process (WatchedEvent event)
specifier|public
name|void
name|process
parameter_list|(
name|WatchedEvent
name|event
parameter_list|)
block|{
name|hasReceivedEvent
operator|.
name|countDown
argument_list|()
expr_stmt|;
try|try
block|{
name|hasSetZooKeeper
operator|.
name|await
argument_list|(
name|zkSessionTimeout
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
name|ActiveStandbyElector
operator|.
name|this
operator|.
name|processWatchEvent
argument_list|(
name|zk
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|fatalError
argument_list|(
literal|"Failed to process watcher event "
operator|+
name|event
operator|+
literal|": "
operator|+
name|StringUtils
operator|.
name|stringifyException
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|isSuccess (Code code)
specifier|private
specifier|static
name|boolean
name|isSuccess
parameter_list|(
name|Code
name|code
parameter_list|)
block|{
return|return
operator|(
name|code
operator|==
name|Code
operator|.
name|OK
operator|)
return|;
block|}
DECL|method|isNodeExists (Code code)
specifier|private
specifier|static
name|boolean
name|isNodeExists
parameter_list|(
name|Code
name|code
parameter_list|)
block|{
return|return
operator|(
name|code
operator|==
name|Code
operator|.
name|NODEEXISTS
operator|)
return|;
block|}
DECL|method|isNodeDoesNotExist (Code code)
specifier|private
specifier|static
name|boolean
name|isNodeDoesNotExist
parameter_list|(
name|Code
name|code
parameter_list|)
block|{
return|return
operator|(
name|code
operator|==
name|Code
operator|.
name|NONODE
operator|)
return|;
block|}
DECL|method|isSessionExpired (Code code)
specifier|private
specifier|static
name|boolean
name|isSessionExpired
parameter_list|(
name|Code
name|code
parameter_list|)
block|{
return|return
operator|(
name|code
operator|==
name|Code
operator|.
name|SESSIONEXPIRED
operator|)
return|;
block|}
DECL|method|shouldRetry (Code code)
specifier|private
specifier|static
name|boolean
name|shouldRetry
parameter_list|(
name|Code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONNECTIONLOSS
case|:
case|case
name|OPERATIONTIMEOUT
case|:
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"elector id="
operator|+
name|System
operator|.
name|identityHashCode
argument_list|(
name|this
argument_list|)
operator|+
literal|" appData="
operator|+
operator|(
operator|(
name|appData
operator|==
literal|null
operator|)
condition|?
literal|"null"
else|:
name|StringUtils
operator|.
name|byteToHexString
argument_list|(
name|appData
argument_list|)
operator|)
operator|+
literal|" cb="
operator|+
name|appClient
return|;
block|}
block|}
end_class

end_unit

