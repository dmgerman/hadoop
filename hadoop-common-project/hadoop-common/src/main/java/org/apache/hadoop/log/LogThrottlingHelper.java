begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.log
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|log
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|math3
operator|.
name|stat
operator|.
name|descriptive
operator|.
name|SummaryStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Timer
import|;
end_import

begin_comment
comment|/**  * This is a class to help easily throttle log statements, so that they will  * not be emitted more frequently than a certain rate. It is useful to help  * prevent flooding the application logs with redundant messages.  *  * The instantiator specifies a minimum period at which statements should be  * logged. When {@link #record(double...)} is called, if enough time has elapsed  * since the last time it was called, the return value will indicate to the  * caller that it should write to its actual log. Note that this class does not  * write to any actual log; it only records information about how many times  * {@code record} has been called and with what arguments, and indicates to the  * caller whether or not it should write to its log. If not enough time has yet  * elapsed, this class records the arguments and updates its summary  * information, and indicates to the caller that it should not log.  *  * For example, say that you want to know whenever too large of a request is  * received, but want to avoid flooding the logs if many such requests are  * received.  *<pre>{@code  *   // Helper with a minimum period of 5 seconds  *   private LogThrottlingHelper helper = new LogThrottlingHelper(5000);  *  *   public void receiveRequest(int requestedObjects) {  *     if (requestedObjects> MAXIMUM_REQUEST_SIZE) {  *       LogAction logAction = helper.record(requestedObjects);  *       if (logAction.shouldLog()) {  *         LOG.warn("Received {} large request(s) with a total of {} objects " +  *             "requested; maximum objects requested was {}",  *             logAction.getCount(), logAction.getStats(0).getSum(),  *             logAction.getStats(0).getMax());  *       }  *     }  *   }  * }</pre>  * The above snippet allows you to record extraneous events, but if they become  * frequent, to limit their presence in the log to only every 5 seconds while  * still maintaining overall information about how many large requests were  * received.  *  *<p>This class can also be used to coordinate multiple logging points; see  * {@link #record(String, long, double...)} for more details.  *  *<p>This class is not thread-safe.  */
end_comment

begin_class
DECL|class|LogThrottlingHelper
specifier|public
class|class
name|LogThrottlingHelper
block|{
comment|/**    * An indication of what action the caller should take. If    * {@link #shouldLog()} is false, no other action should be taken, and it is    * an error to try to access any of the summary information. If    * {@link #shouldLog()} is true, then the caller should write to its log, and    * can use the {@link #getCount()} and {@link #getStats(int)} methods to    * determine summary information about what has been recorded into this    * helper.    *    * All summary information in this action only represents    * {@link #record(double...)} statements which were called<i>after</i> the    * last time the caller logged something; that is, since the last time a log    * action was returned with a true value for {@link #shouldLog()}. Information    * about the {@link #record(double...)} statement which created this log    * action is included.    */
DECL|interface|LogAction
specifier|public
interface|interface
name|LogAction
block|{
comment|/**      * Return the number of records encapsulated in this action; that is, the      * number of times {@code record} was called to produce this action,      * including the current one.      */
DECL|method|getCount ()
name|int
name|getCount
parameter_list|()
function_decl|;
comment|/**      * Return summary information for the value that was recorded at index      * {@code idx}. Corresponds to the ordering of values passed to      * {@link #record(double...)}.      */
DECL|method|getStats (int idx)
name|SummaryStatistics
name|getStats
parameter_list|(
name|int
name|idx
parameter_list|)
function_decl|;
comment|/**      * If this is true, the caller should write to its log. Otherwise, the      * caller should take no action, and it is an error to call other methods      * on this object.      */
DECL|method|shouldLog ()
name|boolean
name|shouldLog
parameter_list|()
function_decl|;
block|}
comment|/**    * A {@link LogAction} representing a state that should not yet be logged.    * If any attempt is made to extract information from this, it will throw    * an {@link IllegalStateException}.    */
DECL|field|DO_NOT_LOG
specifier|public
specifier|static
specifier|final
name|LogAction
name|DO_NOT_LOG
init|=
operator|new
name|NoLogAction
argument_list|()
decl_stmt|;
DECL|field|DEFAULT_RECORDER_NAME
specifier|private
specifier|static
specifier|final
name|String
name|DEFAULT_RECORDER_NAME
init|=
literal|"__DEFAULT_RECORDER_NAME__"
decl_stmt|;
comment|/**    * This throttler will not trigger log statements more frequently than this    * period.    */
DECL|field|minLogPeriodMs
specifier|private
specifier|final
name|long
name|minLogPeriodMs
decl_stmt|;
comment|/**    * The name of the recorder treated as the primary; this is the only one which    * will trigger logging. Other recorders are dependent on the state of this    * recorder. This may be null, in which case a primary has not yet been set.    */
DECL|field|primaryRecorderName
specifier|private
name|String
name|primaryRecorderName
decl_stmt|;
DECL|field|timer
specifier|private
specifier|final
name|Timer
name|timer
decl_stmt|;
DECL|field|currentLogs
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|LoggingAction
argument_list|>
name|currentLogs
decl_stmt|;
DECL|field|lastLogTimestampMs
specifier|private
name|long
name|lastLogTimestampMs
init|=
name|Long
operator|.
name|MIN_VALUE
decl_stmt|;
comment|/**    * Create a log helper without any primary recorder.    *    * @see #LogThrottlingHelper(long, String)    */
DECL|method|LogThrottlingHelper (long minLogPeriodMs)
specifier|public
name|LogThrottlingHelper
parameter_list|(
name|long
name|minLogPeriodMs
parameter_list|)
block|{
name|this
argument_list|(
name|minLogPeriodMs
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**    * Create a log helper with a specified primary recorder name; this can be    * used in conjunction with {@link #record(String, long, double...)} to set up    * primary and dependent recorders. See    * {@link #record(String, long, double...)} for more details.    *    * @param minLogPeriodMs The minimum period with which to log; do not log    *                       more frequently than this.    * @param primaryRecorderName The name of the primary recorder.    */
DECL|method|LogThrottlingHelper (long minLogPeriodMs, String primaryRecorderName)
specifier|public
name|LogThrottlingHelper
parameter_list|(
name|long
name|minLogPeriodMs
parameter_list|,
name|String
name|primaryRecorderName
parameter_list|)
block|{
name|this
argument_list|(
name|minLogPeriodMs
argument_list|,
name|primaryRecorderName
argument_list|,
operator|new
name|Timer
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|LogThrottlingHelper (long minLogPeriodMs, String primaryRecorderName, Timer timer)
name|LogThrottlingHelper
parameter_list|(
name|long
name|minLogPeriodMs
parameter_list|,
name|String
name|primaryRecorderName
parameter_list|,
name|Timer
name|timer
parameter_list|)
block|{
name|this
operator|.
name|minLogPeriodMs
operator|=
name|minLogPeriodMs
expr_stmt|;
name|this
operator|.
name|primaryRecorderName
operator|=
name|primaryRecorderName
expr_stmt|;
name|this
operator|.
name|timer
operator|=
name|timer
expr_stmt|;
name|this
operator|.
name|currentLogs
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
comment|/**    * Record some set of values at the current time into this helper. Note that    * this does<i>not</i> actually write information to any log. Instead, this    * will return a LogAction indicating whether or not the caller should write    * to its own log. The LogAction will additionally contain summary information    * about the values specified since the last time the caller was expected to    * write to its log.    *    *<p>Specifying multiple values will maintain separate summary statistics    * about each value. For example:    *<pre>{@code    *   helper.record(1, 0);    *   LogAction action = helper.record(3, 100);    *   action.getStats(0); // == 2    *   action.getStats(1); // == 50    * }</pre>    *    * @param values The values about which to maintain summary information. Every    *               time this method is called, the same number of values must    *               be specified.    * @return A LogAction indicating whether or not the caller should write to    *         its log.    */
DECL|method|record (double... values)
specifier|public
name|LogAction
name|record
parameter_list|(
name|double
modifier|...
name|values
parameter_list|)
block|{
return|return
name|record
argument_list|(
name|DEFAULT_RECORDER_NAME
argument_list|,
name|timer
operator|.
name|monotonicNow
argument_list|()
argument_list|,
name|values
argument_list|)
return|;
block|}
comment|/**    * Record some set of values at the specified time into this helper. This can    * be useful to avoid fetching the current time twice if the caller has    * already done so for other purposes. This additionally allows the caller to    * specify a name for this recorder. When multiple names are used, one is    * denoted as the primary recorder. Only recorders named as the primary    * will trigger logging; other names not matching the primary can<i>only</i>    * be triggered by following the primary. This is used to coordinate multiple    * logging points. A primary can be set via the    * {@link #LogThrottlingHelper(long, String)} constructor. If no primary    * is set in the constructor, then the first recorder name used becomes the    * primary.    *    * If multiple names are used, they maintain entirely different sets of values    * and summary information. For example:    *<pre>{@code    *   // Initialize "pre" as the primary recorder name    *   LogThrottlingHelper helper = new LogThrottlingHelper(1000, "pre");    *   LogAction preLog = helper.record("pre", Time.monotonicNow());    *   if (preLog.shouldLog()) {    *     // ...    *   }    *   double eventsProcessed = ... // perform some action    *   LogAction postLog =    *       helper.record("post", Time.monotonicNow(), eventsProcessed);    *   if (postLog.shouldLog()) {    *     // ...    *     // Can use postLog.getStats(0) to access eventsProcessed information    *   }    * }</pre>    * Since "pre" is the primary recorder name, logging to "pre" will trigger a    * log action if enough time has elapsed. This will indicate that "post"    * should log as well. This ensures that "post" is always logged in the same    * iteration as "pre", yet each one is able to maintain its own summary    * information.    *    *<p>Other behavior is the same as {@link #record(double...)}.    *    * @param recorderName The name of the recorder. This is used to check if the    *                     current recorder is the primary. Other names are    *                     arbitrary and are only used to differentiate between    *                     distinct recorders.    * @param currentTimeMs The current time.    * @param values The values to log.    * @return The LogAction for the specified recorder.    *    * @see #record(double...)    */
DECL|method|record (String recorderName, long currentTimeMs, double... values)
specifier|public
name|LogAction
name|record
parameter_list|(
name|String
name|recorderName
parameter_list|,
name|long
name|currentTimeMs
parameter_list|,
name|double
modifier|...
name|values
parameter_list|)
block|{
if|if
condition|(
name|primaryRecorderName
operator|==
literal|null
condition|)
block|{
name|primaryRecorderName
operator|=
name|recorderName
expr_stmt|;
block|}
name|LoggingAction
name|currentLog
init|=
name|currentLogs
operator|.
name|get
argument_list|(
name|recorderName
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentLog
operator|==
literal|null
operator|||
name|currentLog
operator|.
name|hasLogged
argument_list|()
condition|)
block|{
name|currentLog
operator|=
operator|new
name|LoggingAction
argument_list|(
name|values
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|currentLogs
operator|.
name|containsKey
argument_list|(
name|recorderName
argument_list|)
condition|)
block|{
comment|// Always log newly created loggers
name|currentLog
operator|.
name|setShouldLog
argument_list|()
expr_stmt|;
block|}
name|currentLogs
operator|.
name|put
argument_list|(
name|recorderName
argument_list|,
name|currentLog
argument_list|)
expr_stmt|;
block|}
name|currentLog
operator|.
name|recordValues
argument_list|(
name|values
argument_list|)
expr_stmt|;
if|if
condition|(
name|primaryRecorderName
operator|.
name|equals
argument_list|(
name|recorderName
argument_list|)
operator|&&
name|currentTimeMs
operator|-
name|minLogPeriodMs
operator|>=
name|lastLogTimestampMs
condition|)
block|{
name|lastLogTimestampMs
operator|=
name|currentTimeMs
expr_stmt|;
for|for
control|(
name|LoggingAction
name|log
range|:
name|currentLogs
operator|.
name|values
argument_list|()
control|)
block|{
name|log
operator|.
name|setShouldLog
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|currentLog
operator|.
name|shouldLog
argument_list|()
condition|)
block|{
name|currentLog
operator|.
name|setHasLogged
argument_list|()
expr_stmt|;
return|return
name|currentLog
return|;
block|}
else|else
block|{
return|return
name|DO_NOT_LOG
return|;
block|}
block|}
comment|/**    * Return the summary information for given index.    *    * @param recorderName The name of the recorder.    * @param idx The index value.    * @return The summary information.    */
DECL|method|getCurrentStats (String recorderName, int idx)
specifier|public
name|SummaryStatistics
name|getCurrentStats
parameter_list|(
name|String
name|recorderName
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|LoggingAction
name|currentLog
init|=
name|currentLogs
operator|.
name|get
argument_list|(
name|recorderName
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentLog
operator|!=
literal|null
condition|)
block|{
return|return
name|currentLog
operator|.
name|getStats
argument_list|(
name|idx
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**    * Helper function to create a message about how many log statements were    * suppressed in the provided log action. If no statements were suppressed,    * this returns an empty string. The message has the format (without quotes):    *    *<p/>' (suppressed logging<i>{suppression_count}</i> times)'    *    * @param action The log action to produce a message about.    * @return A message about suppression within this action.    */
DECL|method|getLogSupressionMessage (LogAction action)
specifier|public
specifier|static
name|String
name|getLogSupressionMessage
parameter_list|(
name|LogAction
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|.
name|getCount
argument_list|()
operator|>
literal|1
condition|)
block|{
return|return
literal|" (suppressed logging "
operator|+
operator|(
name|action
operator|.
name|getCount
argument_list|()
operator|-
literal|1
operator|)
operator|+
literal|" times)"
return|;
block|}
else|else
block|{
return|return
literal|""
return|;
block|}
block|}
comment|/**    * A standard log action which keeps track of all of the values which have    * been logged. This is also used for internal bookkeeping via its private    * fields and methods; it will maintain whether or not it is ready to be    * logged ({@link #shouldLog()}) as well as whether or not it has been    * returned for logging yet ({@link #hasLogged()}).    */
DECL|class|LoggingAction
specifier|private
specifier|static
class|class
name|LoggingAction
implements|implements
name|LogAction
block|{
DECL|field|count
specifier|private
name|int
name|count
init|=
literal|0
decl_stmt|;
DECL|field|stats
specifier|private
specifier|final
name|SummaryStatistics
index|[]
name|stats
decl_stmt|;
DECL|field|shouldLog
specifier|private
name|boolean
name|shouldLog
init|=
literal|false
decl_stmt|;
DECL|field|hasLogged
specifier|private
name|boolean
name|hasLogged
init|=
literal|false
decl_stmt|;
DECL|method|LoggingAction (int valueCount)
name|LoggingAction
parameter_list|(
name|int
name|valueCount
parameter_list|)
block|{
name|stats
operator|=
operator|new
name|SummaryStatistics
index|[
name|valueCount
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stats
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|stats
index|[
name|i
index|]
operator|=
operator|new
name|SummaryStatistics
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getCount ()
specifier|public
name|int
name|getCount
parameter_list|()
block|{
return|return
name|count
return|;
block|}
DECL|method|getStats (int idx)
specifier|public
name|SummaryStatistics
name|getStats
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>=
name|stats
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Requested stats at idx "
operator|+
name|idx
operator|+
literal|" but this log only maintains "
operator|+
name|stats
operator|.
name|length
operator|+
literal|" stats"
argument_list|)
throw|;
block|}
return|return
name|stats
index|[
name|idx
index|]
return|;
block|}
DECL|method|shouldLog ()
specifier|public
name|boolean
name|shouldLog
parameter_list|()
block|{
return|return
name|shouldLog
return|;
block|}
DECL|method|setShouldLog ()
specifier|private
name|void
name|setShouldLog
parameter_list|()
block|{
name|shouldLog
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|hasLogged ()
specifier|private
name|boolean
name|hasLogged
parameter_list|()
block|{
return|return
name|hasLogged
return|;
block|}
DECL|method|setHasLogged ()
specifier|private
name|void
name|setHasLogged
parameter_list|()
block|{
name|hasLogged
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|recordValues (double... values)
specifier|private
name|void
name|recordValues
parameter_list|(
name|double
modifier|...
name|values
parameter_list|)
block|{
if|if
condition|(
name|values
operator|.
name|length
operator|!=
name|stats
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"received "
operator|+
name|values
operator|.
name|length
operator|+
literal|" values but expected "
operator|+
name|stats
operator|.
name|length
argument_list|)
throw|;
block|}
name|count
operator|++
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|stats
index|[
name|i
index|]
operator|.
name|addValue
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * A non-logging action.    *    * @see #DO_NOT_LOG    */
DECL|class|NoLogAction
specifier|private
specifier|static
class|class
name|NoLogAction
implements|implements
name|LogAction
block|{
DECL|method|getCount ()
specifier|public
name|int
name|getCount
parameter_list|()
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cannot be logged yet!"
argument_list|)
throw|;
block|}
DECL|method|getStats (int idx)
specifier|public
name|SummaryStatistics
name|getStats
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Cannot be logged yet!"
argument_list|)
throw|;
block|}
DECL|method|shouldLog ()
specifier|public
name|boolean
name|shouldLog
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
end_class

end_unit

