begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.security.token.delegation
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|DataOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|AppConfigurationEntry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|ensemble
operator|.
name|fixed
operator|.
name|FixedEnsembleProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|CuratorFramework
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|CuratorFrameworkFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|CuratorFrameworkFactory
operator|.
name|Builder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|api
operator|.
name|ACLProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|imps
operator|.
name|DefaultACLProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|recipes
operator|.
name|cache
operator|.
name|ChildData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|recipes
operator|.
name|cache
operator|.
name|PathChildrenCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|recipes
operator|.
name|cache
operator|.
name|PathChildrenCache
operator|.
name|StartMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|recipes
operator|.
name|cache
operator|.
name|PathChildrenCacheEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|recipes
operator|.
name|cache
operator|.
name|PathChildrenCacheListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|recipes
operator|.
name|shared
operator|.
name|SharedCount
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|framework
operator|.
name|recipes
operator|.
name|shared
operator|.
name|VersionedValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|retry
operator|.
name|RetryNTimes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|curator
operator|.
name|utils
operator|.
name|EnsurePath
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|Private
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
operator|.
name|Unstable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|delegation
operator|.
name|web
operator|.
name|DelegationTokenManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|CreateMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|KeeperException
operator|.
name|NoNodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|ZooDefs
operator|.
name|Perms
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|client
operator|.
name|ZooKeeperSaslClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|ACL
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|zookeeper
operator|.
name|data
operator|.
name|Id
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_comment
comment|/**  * An implementation of {@link AbstractDelegationTokenSecretManager} that  * persists TokenIdentifiers and DelegationKeys in Zookeeper. This class can  * be used by HA (Highly available) services that consists of multiple nodes.  * This class ensures that Identifiers and Keys are replicated to all nodes of  * the service.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|ZKDelegationTokenSecretManager
specifier|public
specifier|abstract
class|class
name|ZKDelegationTokenSecretManager
parameter_list|<
name|TokenIdent
extends|extends
name|AbstractDelegationTokenIdentifier
parameter_list|>
extends|extends
name|AbstractDelegationTokenSecretManager
argument_list|<
name|TokenIdent
argument_list|>
block|{
DECL|field|ZK_CONF_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|ZK_CONF_PREFIX
init|=
literal|"zk-dt-secret-manager."
decl_stmt|;
DECL|field|ZK_DTSM_ZK_NUM_RETRIES
specifier|public
specifier|static
specifier|final
name|String
name|ZK_DTSM_ZK_NUM_RETRIES
init|=
name|ZK_CONF_PREFIX
operator|+
literal|"zkNumRetries"
decl_stmt|;
DECL|field|ZK_DTSM_ZK_SESSION_TIMEOUT
specifier|public
specifier|static
specifier|final
name|String
name|ZK_DTSM_ZK_SESSION_TIMEOUT
init|=
name|ZK_CONF_PREFIX
operator|+
literal|"zkSessionTimeout"
decl_stmt|;
DECL|field|ZK_DTSM_ZK_CONNECTION_TIMEOUT
specifier|public
specifier|static
specifier|final
name|String
name|ZK_DTSM_ZK_CONNECTION_TIMEOUT
init|=
name|ZK_CONF_PREFIX
operator|+
literal|"zkConnectionTimeout"
decl_stmt|;
DECL|field|ZK_DTSM_ZK_SHUTDOWN_TIMEOUT
specifier|public
specifier|static
specifier|final
name|String
name|ZK_DTSM_ZK_SHUTDOWN_TIMEOUT
init|=
name|ZK_CONF_PREFIX
operator|+
literal|"zkShutdownTimeout"
decl_stmt|;
DECL|field|ZK_DTSM_ZNODE_WORKING_PATH
specifier|public
specifier|static
specifier|final
name|String
name|ZK_DTSM_ZNODE_WORKING_PATH
init|=
name|ZK_CONF_PREFIX
operator|+
literal|"znodeWorkingPath"
decl_stmt|;
DECL|field|ZK_DTSM_ZK_AUTH_TYPE
specifier|public
specifier|static
specifier|final
name|String
name|ZK_DTSM_ZK_AUTH_TYPE
init|=
name|ZK_CONF_PREFIX
operator|+
literal|"zkAuthType"
decl_stmt|;
DECL|field|ZK_DTSM_ZK_CONNECTION_STRING
specifier|public
specifier|static
specifier|final
name|String
name|ZK_DTSM_ZK_CONNECTION_STRING
init|=
name|ZK_CONF_PREFIX
operator|+
literal|"zkConnectionString"
decl_stmt|;
DECL|field|ZK_DTSM_ZK_KERBEROS_KEYTAB
specifier|public
specifier|static
specifier|final
name|String
name|ZK_DTSM_ZK_KERBEROS_KEYTAB
init|=
name|ZK_CONF_PREFIX
operator|+
literal|"kerberos.keytab"
decl_stmt|;
DECL|field|ZK_DTSM_ZK_KERBEROS_PRINCIPAL
specifier|public
specifier|static
specifier|final
name|String
name|ZK_DTSM_ZK_KERBEROS_PRINCIPAL
init|=
name|ZK_CONF_PREFIX
operator|+
literal|"kerberos.principal"
decl_stmt|;
DECL|field|ZK_DTSM_ZK_NUM_RETRIES_DEFAULT
specifier|public
specifier|static
specifier|final
name|int
name|ZK_DTSM_ZK_NUM_RETRIES_DEFAULT
init|=
literal|3
decl_stmt|;
DECL|field|ZK_DTSM_ZK_SESSION_TIMEOUT_DEFAULT
specifier|public
specifier|static
specifier|final
name|int
name|ZK_DTSM_ZK_SESSION_TIMEOUT_DEFAULT
init|=
literal|10000
decl_stmt|;
DECL|field|ZK_DTSM_ZK_CONNECTION_TIMEOUT_DEFAULT
specifier|public
specifier|static
specifier|final
name|int
name|ZK_DTSM_ZK_CONNECTION_TIMEOUT_DEFAULT
init|=
literal|10000
decl_stmt|;
DECL|field|ZK_DTSM_ZK_SHUTDOWN_TIMEOUT_DEFAULT
specifier|public
specifier|static
specifier|final
name|int
name|ZK_DTSM_ZK_SHUTDOWN_TIMEOUT_DEFAULT
init|=
literal|10000
decl_stmt|;
DECL|field|ZK_DTSM_ZNODE_WORKING_PATH_DEAFULT
specifier|public
specifier|static
specifier|final
name|String
name|ZK_DTSM_ZNODE_WORKING_PATH_DEAFULT
init|=
literal|"zkdtsm"
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|ZKDelegationTokenSecretManager
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|JAAS_LOGIN_ENTRY_NAME
specifier|private
specifier|static
specifier|final
name|String
name|JAAS_LOGIN_ENTRY_NAME
init|=
literal|"ZKDelegationTokenSecretManagerClient"
decl_stmt|;
DECL|field|ZK_DTSM_NAMESPACE
specifier|private
specifier|static
specifier|final
name|String
name|ZK_DTSM_NAMESPACE
init|=
literal|"ZKDTSMRoot"
decl_stmt|;
DECL|field|ZK_DTSM_SEQNUM_ROOT
specifier|private
specifier|static
specifier|final
name|String
name|ZK_DTSM_SEQNUM_ROOT
init|=
literal|"/ZKDTSMSeqNumRoot"
decl_stmt|;
DECL|field|ZK_DTSM_KEYID_ROOT
specifier|private
specifier|static
specifier|final
name|String
name|ZK_DTSM_KEYID_ROOT
init|=
literal|"/ZKDTSMKeyIdRoot"
decl_stmt|;
DECL|field|ZK_DTSM_TOKENS_ROOT
specifier|private
specifier|static
specifier|final
name|String
name|ZK_DTSM_TOKENS_ROOT
init|=
literal|"/ZKDTSMTokensRoot"
decl_stmt|;
DECL|field|ZK_DTSM_MASTER_KEY_ROOT
specifier|private
specifier|static
specifier|final
name|String
name|ZK_DTSM_MASTER_KEY_ROOT
init|=
literal|"/ZKDTSMMasterKeyRoot"
decl_stmt|;
DECL|field|DELEGATION_KEY_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|DELEGATION_KEY_PREFIX
init|=
literal|"DK_"
decl_stmt|;
DECL|field|DELEGATION_TOKEN_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|DELEGATION_TOKEN_PREFIX
init|=
literal|"DT_"
decl_stmt|;
DECL|field|CURATOR_TL
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|CuratorFramework
argument_list|>
name|CURATOR_TL
init|=
operator|new
name|ThreadLocal
argument_list|<
name|CuratorFramework
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|setCurator (CuratorFramework curator)
specifier|public
specifier|static
name|void
name|setCurator
parameter_list|(
name|CuratorFramework
name|curator
parameter_list|)
block|{
name|CURATOR_TL
operator|.
name|set
argument_list|(
name|curator
argument_list|)
expr_stmt|;
block|}
DECL|field|isExternalClient
specifier|private
specifier|final
name|boolean
name|isExternalClient
decl_stmt|;
DECL|field|zkClient
specifier|private
specifier|final
name|CuratorFramework
name|zkClient
decl_stmt|;
DECL|field|delTokSeqCounter
specifier|private
name|SharedCount
name|delTokSeqCounter
decl_stmt|;
DECL|field|keyIdSeqCounter
specifier|private
name|SharedCount
name|keyIdSeqCounter
decl_stmt|;
DECL|field|keyCache
specifier|private
name|PathChildrenCache
name|keyCache
decl_stmt|;
DECL|field|tokenCache
specifier|private
name|PathChildrenCache
name|tokenCache
decl_stmt|;
DECL|field|listenerThreadPool
specifier|private
name|ExecutorService
name|listenerThreadPool
decl_stmt|;
DECL|field|shutdownTimeout
specifier|private
specifier|final
name|long
name|shutdownTimeout
decl_stmt|;
DECL|method|ZKDelegationTokenSecretManager (Configuration conf)
specifier|public
name|ZKDelegationTokenSecretManager
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|super
argument_list|(
name|conf
operator|.
name|getLong
argument_list|(
name|DelegationTokenManager
operator|.
name|UPDATE_INTERVAL
argument_list|,
name|DelegationTokenManager
operator|.
name|UPDATE_INTERVAL_DEFAULT
argument_list|)
operator|*
literal|1000
argument_list|,
name|conf
operator|.
name|getLong
argument_list|(
name|DelegationTokenManager
operator|.
name|MAX_LIFETIME
argument_list|,
name|DelegationTokenManager
operator|.
name|MAX_LIFETIME_DEFAULT
argument_list|)
operator|*
literal|1000
argument_list|,
name|conf
operator|.
name|getLong
argument_list|(
name|DelegationTokenManager
operator|.
name|RENEW_INTERVAL
argument_list|,
name|DelegationTokenManager
operator|.
name|RENEW_INTERVAL_DEFAULT
argument_list|)
operator|*
literal|1000
argument_list|,
name|conf
operator|.
name|getLong
argument_list|(
name|DelegationTokenManager
operator|.
name|REMOVAL_SCAN_INTERVAL
argument_list|,
name|DelegationTokenManager
operator|.
name|REMOVAL_SCAN_INTERVAL_DEFAULT
argument_list|)
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|shutdownTimeout
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|ZK_DTSM_ZK_SHUTDOWN_TIMEOUT
argument_list|,
name|ZK_DTSM_ZK_SHUTDOWN_TIMEOUT_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|CURATOR_TL
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|zkClient
operator|=
name|CURATOR_TL
operator|.
name|get
argument_list|()
operator|.
name|usingNamespace
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|ZK_DTSM_ZNODE_WORKING_PATH
argument_list|,
name|ZK_DTSM_ZNODE_WORKING_PATH_DEAFULT
argument_list|)
operator|+
literal|"/"
operator|+
name|ZK_DTSM_NAMESPACE
argument_list|)
expr_stmt|;
name|isExternalClient
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|String
name|connString
init|=
name|conf
operator|.
name|get
argument_list|(
name|ZK_DTSM_ZK_CONNECTION_STRING
argument_list|)
decl_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|connString
argument_list|,
literal|"Zookeeper connection string cannot be null"
argument_list|)
expr_stmt|;
name|String
name|authType
init|=
name|conf
operator|.
name|get
argument_list|(
name|ZK_DTSM_ZK_AUTH_TYPE
argument_list|)
decl_stmt|;
comment|// AuthType has to be explicitly set to 'none' or 'sasl'
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|authType
argument_list|,
literal|"Zookeeper authType cannot be null !!"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|authType
operator|.
name|equals
argument_list|(
literal|"sasl"
argument_list|)
operator|||
name|authType
operator|.
name|equals
argument_list|(
literal|"none"
argument_list|)
argument_list|,
literal|"Zookeeper authType must be one of [none, sasl]"
argument_list|)
expr_stmt|;
name|Builder
name|builder
init|=
literal|null
decl_stmt|;
try|try
block|{
name|ACLProvider
name|aclProvider
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|authType
operator|.
name|equals
argument_list|(
literal|"sasl"
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Connecting to ZooKeeper with SASL/Kerberos"
operator|+
literal|"and using 'sasl' ACLs"
argument_list|)
expr_stmt|;
name|String
name|principal
init|=
name|setJaasConfiguration
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
name|ZooKeeperSaslClient
operator|.
name|LOGIN_CONTEXT_NAME_KEY
argument_list|,
name|JAAS_LOGIN_ENTRY_NAME
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
literal|"zookeeper.authProvider.1"
argument_list|,
literal|"org.apache.zookeeper.server.auth.SASLAuthenticationProvider"
argument_list|)
expr_stmt|;
name|aclProvider
operator|=
operator|new
name|SASLOwnerACLProvider
argument_list|(
name|principal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// "none"
name|LOG
operator|.
name|info
argument_list|(
literal|"Connecting to ZooKeeper without authentication"
argument_list|)
expr_stmt|;
name|aclProvider
operator|=
operator|new
name|DefaultACLProvider
argument_list|()
expr_stmt|;
comment|// open to everyone
block|}
name|int
name|sessionT
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|ZK_DTSM_ZK_SESSION_TIMEOUT
argument_list|,
name|ZK_DTSM_ZK_SESSION_TIMEOUT_DEFAULT
argument_list|)
decl_stmt|;
name|int
name|numRetries
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|ZK_DTSM_ZK_NUM_RETRIES
argument_list|,
name|ZK_DTSM_ZK_NUM_RETRIES_DEFAULT
argument_list|)
decl_stmt|;
name|builder
operator|=
name|CuratorFrameworkFactory
operator|.
name|builder
argument_list|()
operator|.
name|aclProvider
argument_list|(
name|aclProvider
argument_list|)
operator|.
name|namespace
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|ZK_DTSM_ZNODE_WORKING_PATH
argument_list|,
name|ZK_DTSM_ZNODE_WORKING_PATH_DEAFULT
argument_list|)
operator|+
literal|"/"
operator|+
name|ZK_DTSM_NAMESPACE
argument_list|)
operator|.
name|sessionTimeoutMs
argument_list|(
name|sessionT
argument_list|)
operator|.
name|connectionTimeoutMs
argument_list|(
name|conf
operator|.
name|getInt
argument_list|(
name|ZK_DTSM_ZK_CONNECTION_TIMEOUT
argument_list|,
name|ZK_DTSM_ZK_CONNECTION_TIMEOUT_DEFAULT
argument_list|)
argument_list|)
operator|.
name|retryPolicy
argument_list|(
operator|new
name|RetryNTimes
argument_list|(
name|numRetries
argument_list|,
name|sessionT
operator|/
name|numRetries
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not Load ZK acls or auth: "
operator|+
name|ex
argument_list|,
name|ex
argument_list|)
throw|;
block|}
name|zkClient
operator|=
name|builder
operator|.
name|ensembleProvider
argument_list|(
operator|new
name|FixedEnsembleProvider
argument_list|(
name|connString
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
name|isExternalClient
operator|=
literal|false
expr_stmt|;
block|}
block|}
DECL|method|setJaasConfiguration (Configuration config)
specifier|private
name|String
name|setJaasConfiguration
parameter_list|(
name|Configuration
name|config
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|keytabFile
init|=
name|config
operator|.
name|get
argument_list|(
name|ZK_DTSM_ZK_KERBEROS_KEYTAB
argument_list|,
literal|""
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|keytabFile
operator|==
literal|null
operator|||
name|keytabFile
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|ZK_DTSM_ZK_KERBEROS_KEYTAB
operator|+
literal|" must be specified"
argument_list|)
throw|;
block|}
name|String
name|principal
init|=
name|config
operator|.
name|get
argument_list|(
name|ZK_DTSM_ZK_KERBEROS_PRINCIPAL
argument_list|,
literal|""
argument_list|)
operator|.
name|trim
argument_list|()
decl_stmt|;
if|if
condition|(
name|principal
operator|==
literal|null
operator|||
name|principal
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|ZK_DTSM_ZK_KERBEROS_PRINCIPAL
operator|+
literal|" must be specified"
argument_list|)
throw|;
block|}
name|JaasConfiguration
name|jConf
init|=
operator|new
name|JaasConfiguration
argument_list|(
name|JAAS_LOGIN_ENTRY_NAME
argument_list|,
name|principal
argument_list|,
name|keytabFile
argument_list|)
decl_stmt|;
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
operator|.
name|setConfiguration
argument_list|(
name|jConf
argument_list|)
expr_stmt|;
return|return
name|principal
operator|.
name|split
argument_list|(
literal|"[/@]"
argument_list|)
index|[
literal|0
index|]
return|;
block|}
comment|/**    * Creates a programmatic version of a jaas.conf file. This can be used    * instead of writing a jaas.conf file and setting the system property,    * "java.security.auth.login.config", to point to that file. It is meant to be    * used for connecting to ZooKeeper.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|JaasConfiguration
specifier|public
specifier|static
class|class
name|JaasConfiguration
extends|extends
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
block|{
DECL|field|baseConfig
specifier|private
specifier|final
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
name|baseConfig
init|=
name|javax
operator|.
name|security
operator|.
name|auth
operator|.
name|login
operator|.
name|Configuration
operator|.
name|getConfiguration
argument_list|()
decl_stmt|;
DECL|field|entry
specifier|private
specifier|static
name|AppConfigurationEntry
index|[]
name|entry
decl_stmt|;
DECL|field|entryName
specifier|private
name|String
name|entryName
decl_stmt|;
comment|/**      * Add an entry to the jaas configuration with the passed in name,      * principal, and keytab. The other necessary options will be set for you.      *      * @param entryName      *          The name of the entry (e.g. "Client")      * @param principal      *          The principal of the user      * @param keytab      *          The location of the keytab      */
DECL|method|JaasConfiguration (String entryName, String principal, String keytab)
specifier|public
name|JaasConfiguration
parameter_list|(
name|String
name|entryName
parameter_list|,
name|String
name|principal
parameter_list|,
name|String
name|keytab
parameter_list|)
block|{
name|this
operator|.
name|entryName
operator|=
name|entryName
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|options
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|options
operator|.
name|put
argument_list|(
literal|"keyTab"
argument_list|,
name|keytab
argument_list|)
expr_stmt|;
name|options
operator|.
name|put
argument_list|(
literal|"principal"
argument_list|,
name|principal
argument_list|)
expr_stmt|;
name|options
operator|.
name|put
argument_list|(
literal|"useKeyTab"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|options
operator|.
name|put
argument_list|(
literal|"storeKey"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|options
operator|.
name|put
argument_list|(
literal|"useTicketCache"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|options
operator|.
name|put
argument_list|(
literal|"refreshKrb5Config"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
name|String
name|jaasEnvVar
init|=
name|System
operator|.
name|getenv
argument_list|(
literal|"HADOOP_JAAS_DEBUG"
argument_list|)
decl_stmt|;
if|if
condition|(
name|jaasEnvVar
operator|!=
literal|null
operator|&&
literal|"true"
operator|.
name|equalsIgnoreCase
argument_list|(
name|jaasEnvVar
argument_list|)
condition|)
block|{
name|options
operator|.
name|put
argument_list|(
literal|"debug"
argument_list|,
literal|"true"
argument_list|)
expr_stmt|;
block|}
name|entry
operator|=
operator|new
name|AppConfigurationEntry
index|[]
block|{
operator|new
name|AppConfigurationEntry
argument_list|(
name|getKrb5LoginModuleName
argument_list|()
argument_list|,
name|AppConfigurationEntry
operator|.
name|LoginModuleControlFlag
operator|.
name|REQUIRED
argument_list|,
name|options
argument_list|)
block|}
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getAppConfigurationEntry (String name)
specifier|public
name|AppConfigurationEntry
index|[]
name|getAppConfigurationEntry
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
operator|(
name|entryName
operator|.
name|equals
argument_list|(
name|name
argument_list|)
operator|)
condition|?
name|entry
else|:
operator|(
operator|(
name|baseConfig
operator|!=
literal|null
operator|)
condition|?
name|baseConfig
operator|.
name|getAppConfigurationEntry
argument_list|(
name|name
argument_list|)
else|:
literal|null
operator|)
return|;
block|}
DECL|method|getKrb5LoginModuleName ()
specifier|private
name|String
name|getKrb5LoginModuleName
parameter_list|()
block|{
name|String
name|krb5LoginModuleName
decl_stmt|;
if|if
condition|(
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.vendor"
argument_list|)
operator|.
name|contains
argument_list|(
literal|"IBM"
argument_list|)
condition|)
block|{
name|krb5LoginModuleName
operator|=
literal|"com.ibm.security.auth.module.Krb5LoginModule"
expr_stmt|;
block|}
else|else
block|{
name|krb5LoginModuleName
operator|=
literal|"com.sun.security.auth.module.Krb5LoginModule"
expr_stmt|;
block|}
return|return
name|krb5LoginModuleName
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|startThreads ()
specifier|public
name|void
name|startThreads
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isExternalClient
condition|)
block|{
try|try
block|{
name|zkClient
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not start Curator Framework"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// If namespace parents are implicitly created, they won't have ACLs.
comment|// So, let's explicitly create them.
name|CuratorFramework
name|nullNsFw
init|=
name|zkClient
operator|.
name|usingNamespace
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|EnsurePath
name|ensureNs
init|=
name|nullNsFw
operator|.
name|newNamespaceAwareEnsurePath
argument_list|(
literal|"/"
operator|+
name|zkClient
operator|.
name|getNamespace
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|ensureNs
operator|.
name|ensure
argument_list|(
name|nullNsFw
operator|.
name|getZookeeperClient
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not create namespace"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|listenerThreadPool
operator|=
name|Executors
operator|.
name|newSingleThreadExecutor
argument_list|()
expr_stmt|;
try|try
block|{
name|delTokSeqCounter
operator|=
operator|new
name|SharedCount
argument_list|(
name|zkClient
argument_list|,
name|ZK_DTSM_SEQNUM_ROOT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|delTokSeqCounter
operator|!=
literal|null
condition|)
block|{
name|delTokSeqCounter
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not start Sequence Counter"
argument_list|,
name|e
argument_list|)
throw|;
block|}
try|try
block|{
name|keyIdSeqCounter
operator|=
operator|new
name|SharedCount
argument_list|(
name|zkClient
argument_list|,
name|ZK_DTSM_KEYID_ROOT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyIdSeqCounter
operator|!=
literal|null
condition|)
block|{
name|keyIdSeqCounter
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not start KeyId Counter"
argument_list|,
name|e
argument_list|)
throw|;
block|}
try|try
block|{
name|createPersistentNode
argument_list|(
name|ZK_DTSM_MASTER_KEY_ROOT
argument_list|)
expr_stmt|;
name|createPersistentNode
argument_list|(
name|ZK_DTSM_TOKENS_ROOT
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not create ZK paths"
argument_list|)
throw|;
block|}
try|try
block|{
name|keyCache
operator|=
operator|new
name|PathChildrenCache
argument_list|(
name|zkClient
argument_list|,
name|ZK_DTSM_MASTER_KEY_ROOT
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyCache
operator|!=
literal|null
condition|)
block|{
name|keyCache
operator|.
name|start
argument_list|(
name|StartMode
operator|.
name|BUILD_INITIAL_CACHE
argument_list|)
expr_stmt|;
name|keyCache
operator|.
name|getListenable
argument_list|()
operator|.
name|addListener
argument_list|(
operator|new
name|PathChildrenCacheListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|childEvent
parameter_list|(
name|CuratorFramework
name|client
parameter_list|,
name|PathChildrenCacheEvent
name|event
parameter_list|)
throws|throws
name|Exception
block|{
switch|switch
condition|(
name|event
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|CHILD_ADDED
case|:
name|processKeyAddOrUpdate
argument_list|(
name|event
operator|.
name|getData
argument_list|()
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHILD_UPDATED
case|:
name|processKeyAddOrUpdate
argument_list|(
name|event
operator|.
name|getData
argument_list|()
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHILD_REMOVED
case|:
name|processKeyRemoved
argument_list|(
name|event
operator|.
name|getData
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
argument_list|,
name|listenerThreadPool
argument_list|)
expr_stmt|;
name|loadFromZKCache
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not start PathChildrenCache for keys"
argument_list|,
name|e
argument_list|)
throw|;
block|}
try|try
block|{
name|tokenCache
operator|=
operator|new
name|PathChildrenCache
argument_list|(
name|zkClient
argument_list|,
name|ZK_DTSM_TOKENS_ROOT
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokenCache
operator|!=
literal|null
condition|)
block|{
name|tokenCache
operator|.
name|start
argument_list|(
name|StartMode
operator|.
name|BUILD_INITIAL_CACHE
argument_list|)
expr_stmt|;
name|tokenCache
operator|.
name|getListenable
argument_list|()
operator|.
name|addListener
argument_list|(
operator|new
name|PathChildrenCacheListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|childEvent
parameter_list|(
name|CuratorFramework
name|client
parameter_list|,
name|PathChildrenCacheEvent
name|event
parameter_list|)
throws|throws
name|Exception
block|{
switch|switch
condition|(
name|event
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|CHILD_ADDED
case|:
name|processTokenAddOrUpdate
argument_list|(
name|event
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHILD_UPDATED
case|:
name|processTokenAddOrUpdate
argument_list|(
name|event
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHILD_REMOVED
case|:
name|processTokenRemoved
argument_list|(
name|event
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
argument_list|,
name|listenerThreadPool
argument_list|)
expr_stmt|;
name|loadFromZKCache
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not start PathChildrenCache for tokens"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|super
operator|.
name|startThreads
argument_list|()
expr_stmt|;
block|}
comment|/**    * Load the PathChildrenCache into the in-memory map. Possible caches to be    * loaded are keyCache and tokenCache.    *    * @param isTokenCache true if loading tokenCache, false if loading keyCache.    */
DECL|method|loadFromZKCache (final boolean isTokenCache)
specifier|private
name|void
name|loadFromZKCache
parameter_list|(
specifier|final
name|boolean
name|isTokenCache
parameter_list|)
block|{
specifier|final
name|String
name|cacheName
init|=
name|isTokenCache
condition|?
literal|"token"
else|:
literal|"key"
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Starting to load {} cache."
argument_list|,
name|cacheName
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|ChildData
argument_list|>
name|children
decl_stmt|;
if|if
condition|(
name|isTokenCache
condition|)
block|{
name|children
operator|=
name|tokenCache
operator|.
name|getCurrentData
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|children
operator|=
name|keyCache
operator|.
name|getCurrentData
argument_list|()
expr_stmt|;
block|}
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ChildData
name|child
range|:
name|children
control|)
block|{
try|try
block|{
if|if
condition|(
name|isTokenCache
condition|)
block|{
name|processTokenAddOrUpdate
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|processKeyAddOrUpdate
argument_list|(
name|child
operator|.
name|getData
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Ignoring node {} because it failed to load."
argument_list|,
name|child
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failure exception:"
argument_list|,
name|e
argument_list|)
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Ignored {} nodes while loading {} cache."
argument_list|,
name|count
argument_list|,
name|cacheName
argument_list|)
expr_stmt|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Loaded {} cache."
argument_list|,
name|cacheName
argument_list|)
expr_stmt|;
block|}
DECL|method|processKeyAddOrUpdate (byte[] data)
specifier|private
name|void
name|processKeyAddOrUpdate
parameter_list|(
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteArrayInputStream
name|bin
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|DataInputStream
name|din
init|=
operator|new
name|DataInputStream
argument_list|(
name|bin
argument_list|)
decl_stmt|;
name|DelegationKey
name|key
init|=
operator|new
name|DelegationKey
argument_list|()
decl_stmt|;
name|key
operator|.
name|readFields
argument_list|(
name|din
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|allKeys
operator|.
name|put
argument_list|(
name|key
operator|.
name|getKeyId
argument_list|()
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|processKeyRemoved (String path)
specifier|private
name|void
name|processKeyRemoved
parameter_list|(
name|String
name|path
parameter_list|)
block|{
name|int
name|i
init|=
name|path
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|String
name|tokSeg
init|=
name|path
operator|.
name|substring
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|j
init|=
name|tokSeg
operator|.
name|indexOf
argument_list|(
literal|'_'
argument_list|)
decl_stmt|;
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|int
name|keyId
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|tokSeg
operator|.
name|substring
argument_list|(
name|j
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|allKeys
operator|.
name|remove
argument_list|(
name|keyId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|processTokenAddOrUpdate (ChildData data)
specifier|private
name|void
name|processTokenAddOrUpdate
parameter_list|(
name|ChildData
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteArrayInputStream
name|bin
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|data
operator|.
name|getData
argument_list|()
argument_list|)
decl_stmt|;
name|DataInputStream
name|din
init|=
operator|new
name|DataInputStream
argument_list|(
name|bin
argument_list|)
decl_stmt|;
name|TokenIdent
name|ident
init|=
name|createIdentifier
argument_list|()
decl_stmt|;
name|ident
operator|.
name|readFields
argument_list|(
name|din
argument_list|)
expr_stmt|;
name|long
name|renewDate
init|=
name|din
operator|.
name|readLong
argument_list|()
decl_stmt|;
name|int
name|pwdLen
init|=
name|din
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|byte
index|[]
name|password
init|=
operator|new
name|byte
index|[
name|pwdLen
index|]
decl_stmt|;
name|int
name|numRead
init|=
name|din
operator|.
name|read
argument_list|(
name|password
argument_list|,
literal|0
argument_list|,
name|pwdLen
argument_list|)
decl_stmt|;
if|if
condition|(
name|numRead
operator|>
operator|-
literal|1
condition|)
block|{
name|DelegationTokenInformation
name|tokenInfo
init|=
operator|new
name|DelegationTokenInformation
argument_list|(
name|renewDate
argument_list|,
name|password
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|currentTokens
operator|.
name|put
argument_list|(
name|ident
argument_list|,
name|tokenInfo
argument_list|)
expr_stmt|;
comment|// The cancel task might be waiting
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|processTokenRemoved (ChildData data)
specifier|private
name|void
name|processTokenRemoved
parameter_list|(
name|ChildData
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteArrayInputStream
name|bin
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|data
operator|.
name|getData
argument_list|()
argument_list|)
decl_stmt|;
name|DataInputStream
name|din
init|=
operator|new
name|DataInputStream
argument_list|(
name|bin
argument_list|)
decl_stmt|;
name|TokenIdent
name|ident
init|=
name|createIdentifier
argument_list|()
decl_stmt|;
name|ident
operator|.
name|readFields
argument_list|(
name|din
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|currentTokens
operator|.
name|remove
argument_list|(
name|ident
argument_list|)
expr_stmt|;
comment|// The cancel task might be waiting
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|stopThreads ()
specifier|public
name|void
name|stopThreads
parameter_list|()
block|{
name|super
operator|.
name|stopThreads
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|tokenCache
operator|!=
literal|null
condition|)
block|{
name|tokenCache
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not stop Delegation Token Cache"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|delTokSeqCounter
operator|!=
literal|null
condition|)
block|{
name|delTokSeqCounter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not stop Delegation Token Counter"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|keyIdSeqCounter
operator|!=
literal|null
condition|)
block|{
name|keyIdSeqCounter
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not stop Key Id Counter"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|keyCache
operator|!=
literal|null
condition|)
block|{
name|keyCache
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not stop KeyCache"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
operator|!
name|isExternalClient
operator|&&
operator|(
name|zkClient
operator|!=
literal|null
operator|)
condition|)
block|{
name|zkClient
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Could not stop Curator Framework"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|listenerThreadPool
operator|!=
literal|null
condition|)
block|{
name|listenerThreadPool
operator|.
name|shutdown
argument_list|()
expr_stmt|;
try|try
block|{
comment|// wait for existing tasks to terminate
if|if
condition|(
operator|!
name|listenerThreadPool
operator|.
name|awaitTermination
argument_list|(
name|shutdownTimeout
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Forcing Listener threadPool to shutdown !!"
argument_list|)
expr_stmt|;
name|listenerThreadPool
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|listenerThreadPool
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|createPersistentNode (String nodePath)
specifier|private
name|void
name|createPersistentNode
parameter_list|(
name|String
name|nodePath
parameter_list|)
throws|throws
name|Exception
block|{
try|try
block|{
name|zkClient
operator|.
name|create
argument_list|()
operator|.
name|withMode
argument_list|(
name|CreateMode
operator|.
name|PERSISTENT
argument_list|)
operator|.
name|forPath
argument_list|(
name|nodePath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NodeExistsException
name|ne
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|nodePath
operator|+
literal|" znode already exists !!"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|nodePath
operator|+
literal|" znode could not be created !!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|getDelegationTokenSeqNum ()
specifier|protected
name|int
name|getDelegationTokenSeqNum
parameter_list|()
block|{
return|return
name|delTokSeqCounter
operator|.
name|getCount
argument_list|()
return|;
block|}
DECL|method|incrSharedCount (SharedCount sharedCount)
specifier|private
name|void
name|incrSharedCount
parameter_list|(
name|SharedCount
name|sharedCount
parameter_list|)
throws|throws
name|Exception
block|{
while|while
condition|(
literal|true
condition|)
block|{
comment|// Loop until we successfully increment the counter
name|VersionedValue
argument_list|<
name|Integer
argument_list|>
name|versionedValue
init|=
name|sharedCount
operator|.
name|getVersionedValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|sharedCount
operator|.
name|trySetCount
argument_list|(
name|versionedValue
argument_list|,
name|versionedValue
operator|.
name|getValue
argument_list|()
operator|+
literal|1
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|incrementDelegationTokenSeqNum ()
specifier|protected
name|int
name|incrementDelegationTokenSeqNum
parameter_list|()
block|{
try|try
block|{
name|incrSharedCount
argument_list|(
name|delTokSeqCounter
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// The ExpirationThread is just finishing.. so dont do anything..
name|LOG
operator|.
name|debug
argument_list|(
literal|"Thread interrupted while performing token counter increment"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not increment shared counter !!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|delTokSeqCounter
operator|.
name|getCount
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|setDelegationTokenSeqNum (int seqNum)
specifier|protected
name|void
name|setDelegationTokenSeqNum
parameter_list|(
name|int
name|seqNum
parameter_list|)
block|{
try|try
block|{
name|delTokSeqCounter
operator|.
name|setCount
argument_list|(
name|seqNum
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not set shared counter !!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|getCurrentKeyId ()
specifier|protected
name|int
name|getCurrentKeyId
parameter_list|()
block|{
return|return
name|keyIdSeqCounter
operator|.
name|getCount
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|incrementCurrentKeyId ()
specifier|protected
name|int
name|incrementCurrentKeyId
parameter_list|()
block|{
try|try
block|{
name|incrSharedCount
argument_list|(
name|keyIdSeqCounter
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
comment|// The ExpirationThread is just finishing.. so dont do anything..
name|LOG
operator|.
name|debug
argument_list|(
literal|"Thread interrupted while performing keyId increment"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not increment shared keyId counter !!"
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|keyIdSeqCounter
operator|.
name|getCount
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getDelegationKey (int keyId)
specifier|protected
name|DelegationKey
name|getDelegationKey
parameter_list|(
name|int
name|keyId
parameter_list|)
block|{
comment|// First check if its I already have this key
name|DelegationKey
name|key
init|=
name|allKeys
operator|.
name|get
argument_list|(
name|keyId
argument_list|)
decl_stmt|;
comment|// Then query ZK
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|key
operator|=
name|getKeyFromZK
argument_list|(
name|keyId
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
literal|null
condition|)
block|{
name|allKeys
operator|.
name|put
argument_list|(
name|keyId
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error retrieving key ["
operator|+
name|keyId
operator|+
literal|"] from ZK"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|key
return|;
block|}
DECL|method|getKeyFromZK (int keyId)
specifier|private
name|DelegationKey
name|getKeyFromZK
parameter_list|(
name|int
name|keyId
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|nodePath
init|=
name|getNodePath
argument_list|(
name|ZK_DTSM_MASTER_KEY_ROOT
argument_list|,
name|DELEGATION_KEY_PREFIX
operator|+
name|keyId
argument_list|)
decl_stmt|;
try|try
block|{
name|byte
index|[]
name|data
init|=
name|zkClient
operator|.
name|getData
argument_list|()
operator|.
name|forPath
argument_list|(
name|nodePath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|data
operator|==
literal|null
operator|)
operator|||
operator|(
name|data
operator|.
name|length
operator|==
literal|0
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ByteArrayInputStream
name|bin
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|DataInputStream
name|din
init|=
operator|new
name|DataInputStream
argument_list|(
name|bin
argument_list|)
decl_stmt|;
name|DelegationKey
name|key
init|=
operator|new
name|DelegationKey
argument_list|()
decl_stmt|;
name|key
operator|.
name|readFields
argument_list|(
name|din
argument_list|)
expr_stmt|;
return|return
name|key
return|;
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"No node in path ["
operator|+
name|nodePath
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|getTokenInfo (TokenIdent ident)
specifier|protected
name|DelegationTokenInformation
name|getTokenInfo
parameter_list|(
name|TokenIdent
name|ident
parameter_list|)
block|{
comment|// First check if I have this..
name|DelegationTokenInformation
name|tokenInfo
init|=
name|currentTokens
operator|.
name|get
argument_list|(
name|ident
argument_list|)
decl_stmt|;
comment|// Then query ZK
if|if
condition|(
name|tokenInfo
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|tokenInfo
operator|=
name|getTokenInfoFromZK
argument_list|(
name|ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokenInfo
operator|!=
literal|null
condition|)
block|{
name|currentTokens
operator|.
name|put
argument_list|(
name|ident
argument_list|,
name|tokenInfo
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error retrieving tokenInfo ["
operator|+
name|ident
operator|.
name|getSequenceNumber
argument_list|()
operator|+
literal|"] from ZK"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tokenInfo
return|;
block|}
comment|/**    * This method synchronizes the state of a delegation token information in    * local cache with its actual value in Zookeeper.    *    * @param ident Identifier of the token    */
DECL|method|syncLocalCacheWithZk (TokenIdent ident)
specifier|private
specifier|synchronized
name|void
name|syncLocalCacheWithZk
parameter_list|(
name|TokenIdent
name|ident
parameter_list|)
block|{
try|try
block|{
name|DelegationTokenInformation
name|tokenInfo
init|=
name|getTokenInfoFromZK
argument_list|(
name|ident
argument_list|)
decl_stmt|;
if|if
condition|(
name|tokenInfo
operator|!=
literal|null
operator|&&
operator|!
name|currentTokens
operator|.
name|containsKey
argument_list|(
name|ident
argument_list|)
condition|)
block|{
name|currentTokens
operator|.
name|put
argument_list|(
name|ident
argument_list|,
name|tokenInfo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tokenInfo
operator|==
literal|null
operator|&&
name|currentTokens
operator|.
name|containsKey
argument_list|(
name|ident
argument_list|)
condition|)
block|{
name|currentTokens
operator|.
name|remove
argument_list|(
name|ident
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Error retrieving tokenInfo ["
operator|+
name|ident
operator|.
name|getSequenceNumber
argument_list|()
operator|+
literal|"] from ZK"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getTokenInfoFromZK (TokenIdent ident)
specifier|private
name|DelegationTokenInformation
name|getTokenInfoFromZK
parameter_list|(
name|TokenIdent
name|ident
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getTokenInfoFromZK
argument_list|(
name|ident
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|getTokenInfoFromZK (TokenIdent ident, boolean quiet)
specifier|private
name|DelegationTokenInformation
name|getTokenInfoFromZK
parameter_list|(
name|TokenIdent
name|ident
parameter_list|,
name|boolean
name|quiet
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|nodePath
init|=
name|getNodePath
argument_list|(
name|ZK_DTSM_TOKENS_ROOT
argument_list|,
name|DELEGATION_TOKEN_PREFIX
operator|+
name|ident
operator|.
name|getSequenceNumber
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|byte
index|[]
name|data
init|=
name|zkClient
operator|.
name|getData
argument_list|()
operator|.
name|forPath
argument_list|(
name|nodePath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|data
operator|==
literal|null
operator|)
operator|||
operator|(
name|data
operator|.
name|length
operator|==
literal|0
operator|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ByteArrayInputStream
name|bin
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|DataInputStream
name|din
init|=
operator|new
name|DataInputStream
argument_list|(
name|bin
argument_list|)
decl_stmt|;
name|createIdentifier
argument_list|()
operator|.
name|readFields
argument_list|(
name|din
argument_list|)
expr_stmt|;
name|long
name|renewDate
init|=
name|din
operator|.
name|readLong
argument_list|()
decl_stmt|;
name|int
name|pwdLen
init|=
name|din
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|byte
index|[]
name|password
init|=
operator|new
name|byte
index|[
name|pwdLen
index|]
decl_stmt|;
name|int
name|numRead
init|=
name|din
operator|.
name|read
argument_list|(
name|password
argument_list|,
literal|0
argument_list|,
name|pwdLen
argument_list|)
decl_stmt|;
if|if
condition|(
name|numRead
operator|>
operator|-
literal|1
condition|)
block|{
name|DelegationTokenInformation
name|tokenInfo
init|=
operator|new
name|DelegationTokenInformation
argument_list|(
name|renewDate
argument_list|,
name|password
argument_list|)
decl_stmt|;
return|return
name|tokenInfo
return|;
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NoNodeException
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"No node in path ["
operator|+
name|nodePath
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|storeDelegationKey (DelegationKey key)
specifier|protected
name|void
name|storeDelegationKey
parameter_list|(
name|DelegationKey
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|addOrUpdateDelegationKey
argument_list|(
name|key
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|updateDelegationKey (DelegationKey key)
specifier|protected
name|void
name|updateDelegationKey
parameter_list|(
name|DelegationKey
name|key
parameter_list|)
throws|throws
name|IOException
block|{
name|addOrUpdateDelegationKey
argument_list|(
name|key
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|addOrUpdateDelegationKey (DelegationKey key, boolean isUpdate)
specifier|private
name|void
name|addOrUpdateDelegationKey
parameter_list|(
name|DelegationKey
name|key
parameter_list|,
name|boolean
name|isUpdate
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|nodeCreatePath
init|=
name|getNodePath
argument_list|(
name|ZK_DTSM_MASTER_KEY_ROOT
argument_list|,
name|DELEGATION_KEY_PREFIX
operator|+
name|key
operator|.
name|getKeyId
argument_list|()
argument_list|)
decl_stmt|;
name|ByteArrayOutputStream
name|os
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|DataOutputStream
name|fsOut
init|=
operator|new
name|DataOutputStream
argument_list|(
name|os
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Storing ZKDTSMDelegationKey_"
operator|+
name|key
operator|.
name|getKeyId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|key
operator|.
name|write
argument_list|(
name|fsOut
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|zkClient
operator|.
name|checkExists
argument_list|()
operator|.
name|forPath
argument_list|(
name|nodeCreatePath
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|zkClient
operator|.
name|setData
argument_list|()
operator|.
name|forPath
argument_list|(
name|nodeCreatePath
argument_list|,
name|os
operator|.
name|toByteArray
argument_list|()
argument_list|)
operator|.
name|setVersion
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isUpdate
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Key with path ["
operator|+
name|nodeCreatePath
operator|+
literal|"] already exists.. Updating !!"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|zkClient
operator|.
name|create
argument_list|()
operator|.
name|withMode
argument_list|(
name|CreateMode
operator|.
name|PERSISTENT
argument_list|)
operator|.
name|forPath
argument_list|(
name|nodeCreatePath
argument_list|,
name|os
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|isUpdate
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Updating non existent Key path ["
operator|+
name|nodeCreatePath
operator|+
literal|"].. Adding new !!"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|KeeperException
operator|.
name|NodeExistsException
name|ne
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|nodeCreatePath
operator|+
literal|" znode already exists !!"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|os
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|removeStoredMasterKey (DelegationKey key)
specifier|protected
name|void
name|removeStoredMasterKey
parameter_list|(
name|DelegationKey
name|key
parameter_list|)
block|{
name|String
name|nodeRemovePath
init|=
name|getNodePath
argument_list|(
name|ZK_DTSM_MASTER_KEY_ROOT
argument_list|,
name|DELEGATION_KEY_PREFIX
operator|+
name|key
operator|.
name|getKeyId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing ZKDTSMDelegationKey_"
operator|+
name|key
operator|.
name|getKeyId
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|zkClient
operator|.
name|checkExists
argument_list|()
operator|.
name|forPath
argument_list|(
name|nodeRemovePath
argument_list|)
operator|!=
literal|null
condition|)
block|{
while|while
condition|(
name|zkClient
operator|.
name|checkExists
argument_list|()
operator|.
name|forPath
argument_list|(
name|nodeRemovePath
argument_list|)
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|zkClient
operator|.
name|delete
argument_list|()
operator|.
name|guaranteed
argument_list|()
operator|.
name|forPath
argument_list|(
name|nodeRemovePath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoNodeException
name|nne
parameter_list|)
block|{
comment|// It is possible that the node might be deleted between the
comment|// check and the actual delete.. which might lead to an
comment|// exception that can bring down the daemon running this
comment|// SecretManager
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node already deleted by peer "
operator|+
name|nodeRemovePath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempted to delete a non-existing znode "
operator|+
name|nodeRemovePath
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|nodeRemovePath
operator|+
literal|" znode could not be removed!!"
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|storeToken (TokenIdent ident, DelegationTokenInformation tokenInfo)
specifier|protected
name|void
name|storeToken
parameter_list|(
name|TokenIdent
name|ident
parameter_list|,
name|DelegationTokenInformation
name|tokenInfo
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
name|addOrUpdateToken
argument_list|(
name|ident
argument_list|,
name|tokenInfo
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|updateToken (TokenIdent ident, DelegationTokenInformation tokenInfo)
specifier|protected
name|void
name|updateToken
parameter_list|(
name|TokenIdent
name|ident
parameter_list|,
name|DelegationTokenInformation
name|tokenInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|nodeRemovePath
init|=
name|getNodePath
argument_list|(
name|ZK_DTSM_TOKENS_ROOT
argument_list|,
name|DELEGATION_TOKEN_PREFIX
operator|+
name|ident
operator|.
name|getSequenceNumber
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|zkClient
operator|.
name|checkExists
argument_list|()
operator|.
name|forPath
argument_list|(
name|nodeRemovePath
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|addOrUpdateToken
argument_list|(
name|ident
argument_list|,
name|tokenInfo
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addOrUpdateToken
argument_list|(
name|ident
argument_list|,
name|tokenInfo
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempted to update a non-existing znode "
operator|+
name|nodeRemovePath
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not update Stored Token ZKDTSMDelegationToken_"
operator|+
name|ident
operator|.
name|getSequenceNumber
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|removeStoredToken (TokenIdent ident)
specifier|protected
name|void
name|removeStoredToken
parameter_list|(
name|TokenIdent
name|ident
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|nodeRemovePath
init|=
name|getNodePath
argument_list|(
name|ZK_DTSM_TOKENS_ROOT
argument_list|,
name|DELEGATION_TOKEN_PREFIX
operator|+
name|ident
operator|.
name|getSequenceNumber
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Removing ZKDTSMDelegationToken_"
operator|+
name|ident
operator|.
name|getSequenceNumber
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|zkClient
operator|.
name|checkExists
argument_list|()
operator|.
name|forPath
argument_list|(
name|nodeRemovePath
argument_list|)
operator|!=
literal|null
condition|)
block|{
while|while
condition|(
name|zkClient
operator|.
name|checkExists
argument_list|()
operator|.
name|forPath
argument_list|(
name|nodeRemovePath
argument_list|)
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|zkClient
operator|.
name|delete
argument_list|()
operator|.
name|guaranteed
argument_list|()
operator|.
name|forPath
argument_list|(
name|nodeRemovePath
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoNodeException
name|nne
parameter_list|)
block|{
comment|// It is possible that the node might be deleted between the
comment|// check and the actual delete.. which might lead to an
comment|// exception that can bring down the daemon running this
comment|// SecretManager
name|LOG
operator|.
name|debug
argument_list|(
literal|"Node already deleted by peer "
operator|+
name|nodeRemovePath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Attempted to remove a non-existing znode "
operator|+
name|nodeRemovePath
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not remove Stored Token ZKDTSMDelegationToken_"
operator|+
name|ident
operator|.
name|getSequenceNumber
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|cancelToken (Token<TokenIdent> token, String canceller)
specifier|public
specifier|synchronized
name|TokenIdent
name|cancelToken
parameter_list|(
name|Token
argument_list|<
name|TokenIdent
argument_list|>
name|token
parameter_list|,
name|String
name|canceller
parameter_list|)
throws|throws
name|IOException
block|{
name|ByteArrayInputStream
name|buf
init|=
operator|new
name|ByteArrayInputStream
argument_list|(
name|token
operator|.
name|getIdentifier
argument_list|()
argument_list|)
decl_stmt|;
name|DataInputStream
name|in
init|=
operator|new
name|DataInputStream
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|TokenIdent
name|id
init|=
name|createIdentifier
argument_list|()
decl_stmt|;
name|id
operator|.
name|readFields
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|syncLocalCacheWithZk
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return
name|super
operator|.
name|cancelToken
argument_list|(
name|token
argument_list|,
name|canceller
argument_list|)
return|;
block|}
DECL|method|addOrUpdateToken (TokenIdent ident, DelegationTokenInformation info, boolean isUpdate)
specifier|private
name|void
name|addOrUpdateToken
parameter_list|(
name|TokenIdent
name|ident
parameter_list|,
name|DelegationTokenInformation
name|info
parameter_list|,
name|boolean
name|isUpdate
parameter_list|)
throws|throws
name|Exception
block|{
name|String
name|nodeCreatePath
init|=
name|getNodePath
argument_list|(
name|ZK_DTSM_TOKENS_ROOT
argument_list|,
name|DELEGATION_TOKEN_PREFIX
operator|+
name|ident
operator|.
name|getSequenceNumber
argument_list|()
argument_list|)
decl_stmt|;
try|try
init|(
name|ByteArrayOutputStream
name|tokenOs
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
init|;
name|DataOutputStream
name|tokenOut
operator|=
operator|new
name|DataOutputStream
argument_list|(
name|tokenOs
argument_list|)
init|)
block|{
name|ident
operator|.
name|write
argument_list|(
name|tokenOut
argument_list|)
expr_stmt|;
name|tokenOut
operator|.
name|writeLong
argument_list|(
name|info
operator|.
name|getRenewDate
argument_list|()
argument_list|)
expr_stmt|;
name|tokenOut
operator|.
name|writeInt
argument_list|(
name|info
operator|.
name|getPassword
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
name|tokenOut
operator|.
name|write
argument_list|(
name|info
operator|.
name|getPassword
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
operator|(
name|isUpdate
condition|?
literal|"Updating "
else|:
literal|"Storing "
operator|)
operator|+
literal|"ZKDTSMDelegationToken_"
operator|+
name|ident
operator|.
name|getSequenceNumber
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isUpdate
condition|)
block|{
name|zkClient
operator|.
name|setData
argument_list|()
operator|.
name|forPath
argument_list|(
name|nodeCreatePath
argument_list|,
name|tokenOs
operator|.
name|toByteArray
argument_list|()
argument_list|)
operator|.
name|setVersion
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zkClient
operator|.
name|create
argument_list|()
operator|.
name|withMode
argument_list|(
name|CreateMode
operator|.
name|PERSISTENT
argument_list|)
operator|.
name|forPath
argument_list|(
name|nodeCreatePath
argument_list|,
name|tokenOs
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Simple implementation of an {@link ACLProvider} that simply returns an ACL    * that gives all permissions only to a single principal.    */
DECL|class|SASLOwnerACLProvider
specifier|private
specifier|static
class|class
name|SASLOwnerACLProvider
implements|implements
name|ACLProvider
block|{
DECL|field|saslACL
specifier|private
specifier|final
name|List
argument_list|<
name|ACL
argument_list|>
name|saslACL
decl_stmt|;
DECL|method|SASLOwnerACLProvider (String principal)
specifier|private
name|SASLOwnerACLProvider
parameter_list|(
name|String
name|principal
parameter_list|)
block|{
name|this
operator|.
name|saslACL
operator|=
name|Collections
operator|.
name|singletonList
argument_list|(
operator|new
name|ACL
argument_list|(
name|Perms
operator|.
name|ALL
argument_list|,
operator|new
name|Id
argument_list|(
literal|"sasl"
argument_list|,
name|principal
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getDefaultAcl ()
specifier|public
name|List
argument_list|<
name|ACL
argument_list|>
name|getDefaultAcl
parameter_list|()
block|{
return|return
name|saslACL
return|;
block|}
annotation|@
name|Override
DECL|method|getAclForPath (String path)
specifier|public
name|List
argument_list|<
name|ACL
argument_list|>
name|getAclForPath
parameter_list|(
name|String
name|path
parameter_list|)
block|{
return|return
name|saslACL
return|;
block|}
block|}
annotation|@
name|VisibleForTesting
annotation|@
name|Private
annotation|@
name|Unstable
DECL|method|getNodePath (String root, String nodeName)
specifier|static
name|String
name|getNodePath
parameter_list|(
name|String
name|root
parameter_list|,
name|String
name|nodeName
parameter_list|)
block|{
return|return
operator|(
name|root
operator|+
literal|"/"
operator|+
name|nodeName
operator|)
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getListenerThreadPool ()
specifier|public
name|ExecutorService
name|getListenerThreadPool
parameter_list|()
block|{
return|return
name|listenerThreadPool
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getTokenInfoFromMemory (TokenIdent ident)
name|DelegationTokenInformation
name|getTokenInfoFromMemory
parameter_list|(
name|TokenIdent
name|ident
parameter_list|)
block|{
return|return
name|currentTokens
operator|.
name|get
argument_list|(
name|ident
argument_list|)
return|;
block|}
block|}
end_class

end_unit

