begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.fs
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URI
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|HadoopIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|FileSystem
operator|.
name|Statistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|Options
operator|.
name|CreateOpts
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|permission
operator|.
name|FsPermission
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|FS_DEFAULT_NAME_KEY
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
operator|.
name|FS_DEFAULT_NAME_DEFAULT
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RpcClientException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RpcServerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|UnexpectedServerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|InvalidPathException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|AccessControlException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|token
operator|.
name|Token
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ShutdownHookManager
import|;
end_import

begin_comment
comment|/**  * The FileContext class provides an interface for users of the Hadoop  * file system. It exposes a number of file system operations, e.g. create,  * open, list.  *   *<h2>Path Names</h2>  *   * The Hadoop file system supports a URI namespace and URI names. This enables  * multiple types of file systems to be referenced using fully-qualified URIs.  * Two common Hadoop file system implementations are  *<ul>  *<li>the local file system: file:///path  *<li>the HDFS file system: hdfs://nnAddress:nnPort/path  *</ul>  *   * The Hadoop file system also supports additional naming schemes besides URIs.  * Hadoop has the concept of a<i>default file system</i>, which implies a  * default URI scheme and authority. This enables<i>slash-relative names</i>  * relative to the default FS, which are more convenient for users and  * application writers. The default FS is typically set by the user's  * environment, though it can also be manually specified.  *<p>  *   * Hadoop also supports<i>working-directory-relative</i> names, which are paths  * relative to the current working directory (similar to Unix). The working  * directory can be in a different file system than the default FS.  *<p>  * Thus, Hadoop path names can be specified as one of the following:  *<ul>  *<li>a fully-qualified URI: scheme://authority/path (e.g.  * hdfs://nnAddress:nnPort/foo/bar)  *<li>a slash-relative name: path relative to the default file system (e.g.  * /foo/bar)  *<li>a working-directory-relative name: path relative to the working dir (e.g.  * foo/bar)  *</ul>  *  Relative paths with scheme (scheme:foo/bar) are illegal.  *    *<h2>Role of FileContext and Configuration Defaults</h2>  *  * The FileContext is the analogue of per-process file-related state in Unix. It  * contains two properties:  *   *<ul>  *<li>the default file system (for resolving slash-relative names)  *<li>the umask (for file permissions)  *</ul>  * In general, these properties are obtained from the default configuration file  * in the user's environment (see {@link Configuration}).  *   * Further file system properties are specified on the server-side. File system  * operations default to using these server-side defaults unless otherwise  * specified.  *<p>  * The file system related server-side defaults are:  *<ul>  *<li> the home directory (default is "/user/userName")  *<li> the initial wd (only for local fs)  *<li> replication factor  *<li> block size  *<li> buffer size  *<li> encryptDataTransfer   *<li> checksum option. (checksumType and  bytesPerChecksum)  *</ul>  *  *<h2>Example Usage</h2>  *  * Example 1: use the default config read from the $HADOOP_CONFIG/core.xml.  *   Unspecified values come from core-defaults.xml in the release jar.  *<ul>    *<li> myFContext = FileContext.getFileContext(); // uses the default config  *                                                // which has your default FS   *<li>  myFContext.create(path, ...);  *<li>  myFContext.setWorkingDir(path);  *<li>  myFContext.open (path, ...);    *<li>...  *</ul>    * Example 2: Get a FileContext with a specific URI as the default FS  *<ul>    *<li> myFContext = FileContext.getFileContext(URI);  *<li> myFContext.create(path, ...);  *<li>...  *</ul>  * Example 3: FileContext with local file system as the default  *<ul>   *<li> myFContext = FileContext.getLocalFSFileContext();  *<li> myFContext.create(path, ...);  *<li> ...  *</ul>   * Example 4: Use a specific config, ignoring $HADOOP_CONFIG  *  Generally you should not need use a config unless you are doing  *<ul>   *<li> configX = someConfigSomeOnePassedToYou;  *<li> myFContext = getFileContext(configX); // configX is not changed,  *                                              // is passed down   *<li> myFContext.create(path, ...);  *<li>...  *</ul>                                            *      */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
comment|/*Evolving for a release,to be changed to Stable */
DECL|class|FileContext
specifier|public
specifier|final
class|class
name|FileContext
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|FileContext
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**    * Default permission for directory and symlink    * In previous versions, this default permission was also used to    * create files, so files created end up with ugo+x permission.    * See HADOOP-9155 for detail.     * Two new constants are added to solve this, please use     * {@link FileContext#DIR_DEFAULT_PERM} for directory, and use    * {@link FileContext#FILE_DEFAULT_PERM} for file.    * This constant is kept for compatibility.    */
DECL|field|DEFAULT_PERM
specifier|public
specifier|static
specifier|final
name|FsPermission
name|DEFAULT_PERM
init|=
name|FsPermission
operator|.
name|getDefault
argument_list|()
decl_stmt|;
comment|/**    * Default permission for directory    */
DECL|field|DIR_DEFAULT_PERM
specifier|public
specifier|static
specifier|final
name|FsPermission
name|DIR_DEFAULT_PERM
init|=
name|FsPermission
operator|.
name|getDirDefault
argument_list|()
decl_stmt|;
comment|/**    * Default permission for file    */
DECL|field|FILE_DEFAULT_PERM
specifier|public
specifier|static
specifier|final
name|FsPermission
name|FILE_DEFAULT_PERM
init|=
name|FsPermission
operator|.
name|getFileDefault
argument_list|()
decl_stmt|;
comment|/**    * Priority of the FileContext shutdown hook.    */
DECL|field|SHUTDOWN_HOOK_PRIORITY
specifier|public
specifier|static
specifier|final
name|int
name|SHUTDOWN_HOOK_PRIORITY
init|=
literal|20
decl_stmt|;
comment|/**    * List of files that should be deleted on JVM shutdown.    */
DECL|field|DELETE_ON_EXIT
specifier|static
specifier|final
name|Map
argument_list|<
name|FileContext
argument_list|,
name|Set
argument_list|<
name|Path
argument_list|>
argument_list|>
name|DELETE_ON_EXIT
init|=
operator|new
name|IdentityHashMap
argument_list|<
name|FileContext
argument_list|,
name|Set
argument_list|<
name|Path
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/** JVM shutdown hook thread. */
DECL|field|FINALIZER
specifier|static
specifier|final
name|FileContextFinalizer
name|FINALIZER
init|=
operator|new
name|FileContextFinalizer
argument_list|()
decl_stmt|;
DECL|field|DEFAULT_FILTER
specifier|private
specifier|static
specifier|final
name|PathFilter
name|DEFAULT_FILTER
init|=
operator|new
name|PathFilter
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|accept
parameter_list|(
specifier|final
name|Path
name|file
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
decl_stmt|;
comment|/**    * The FileContext is defined by.    *  1) defaultFS (slash)    *  2) wd    *  3) umask    */
DECL|field|defaultFS
specifier|private
specifier|final
name|AbstractFileSystem
name|defaultFS
decl_stmt|;
comment|//default FS for this FileContext.
DECL|field|workingDir
specifier|private
name|Path
name|workingDir
decl_stmt|;
comment|// Fully qualified
DECL|field|umask
specifier|private
name|FsPermission
name|umask
decl_stmt|;
DECL|field|conf
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
DECL|field|ugi
specifier|private
specifier|final
name|UserGroupInformation
name|ugi
decl_stmt|;
DECL|method|FileContext (final AbstractFileSystem defFs, final FsPermission theUmask, final Configuration aConf)
specifier|private
name|FileContext
parameter_list|(
specifier|final
name|AbstractFileSystem
name|defFs
parameter_list|,
specifier|final
name|FsPermission
name|theUmask
parameter_list|,
specifier|final
name|Configuration
name|aConf
parameter_list|)
block|{
name|defaultFS
operator|=
name|defFs
expr_stmt|;
name|umask
operator|=
name|FsPermission
operator|.
name|getUMask
argument_list|(
name|aConf
argument_list|)
expr_stmt|;
name|conf
operator|=
name|aConf
expr_stmt|;
try|try
block|{
name|ugi
operator|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"Exception in getCurrentUser: "
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Failed to get the current user "
operator|+
literal|"while creating a FileContext"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|/*      * Init the wd.      * WorkingDir is implemented at the FileContext layer       * NOT at the AbstractFileSystem layer.       * If the DefaultFS, such as localFilesystem has a notion of      *  builtin WD, we use that as the initial WD.      *  Otherwise the WD is initialized to the home directory.      */
name|workingDir
operator|=
name|defaultFS
operator|.
name|getInitialWorkingDirectory
argument_list|()
expr_stmt|;
if|if
condition|(
name|workingDir
operator|==
literal|null
condition|)
block|{
name|workingDir
operator|=
name|defaultFS
operator|.
name|getHomeDirectory
argument_list|()
expr_stmt|;
block|}
name|util
operator|=
operator|new
name|Util
argument_list|()
expr_stmt|;
comment|// for the inner class
block|}
comment|/*     * Remove relative part - return "absolute":    * If input is relative path ("foo/bar") add wd: ie "/<workingDir>/foo/bar"    * A fully qualified uri ("hdfs://nn:p/foo/bar") or a slash-relative path    * ("/foo/bar") are returned unchanged.    *     * Applications that use FileContext should use #makeQualified() since    * they really want a fully qualified URI.    * Hence this method is not called makeAbsolute() and     * has been deliberately declared private.    */
DECL|method|fixRelativePart (Path p)
specifier|private
name|Path
name|fixRelativePart
parameter_list|(
name|Path
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|.
name|isUriPathAbsolute
argument_list|()
condition|)
block|{
return|return
name|p
return|;
block|}
else|else
block|{
return|return
operator|new
name|Path
argument_list|(
name|workingDir
argument_list|,
name|p
argument_list|)
return|;
block|}
block|}
comment|/**    * Delete all the paths that were marked as delete-on-exit.    */
DECL|method|processDeleteOnExit ()
specifier|static
name|void
name|processDeleteOnExit
parameter_list|()
block|{
synchronized|synchronized
init|(
name|DELETE_ON_EXIT
init|)
block|{
name|Set
argument_list|<
name|Entry
argument_list|<
name|FileContext
argument_list|,
name|Set
argument_list|<
name|Path
argument_list|>
argument_list|>
argument_list|>
name|set
init|=
name|DELETE_ON_EXIT
operator|.
name|entrySet
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|FileContext
argument_list|,
name|Set
argument_list|<
name|Path
argument_list|>
argument_list|>
name|entry
range|:
name|set
control|)
block|{
name|FileContext
name|fc
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Path
argument_list|>
name|paths
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
for|for
control|(
name|Path
name|path
range|:
name|paths
control|)
block|{
try|try
block|{
name|fc
operator|.
name|delete
argument_list|(
name|path
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Ignoring failure to deleteOnExit for path "
operator|+
name|path
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|DELETE_ON_EXIT
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Pathnames with scheme and relative path are illegal.    * @param path to be checked    */
DECL|method|checkNotSchemeWithRelative (final Path path)
specifier|private
specifier|static
name|void
name|checkNotSchemeWithRelative
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|.
name|toUri
argument_list|()
operator|.
name|isAbsolute
argument_list|()
operator|&&
operator|!
name|path
operator|.
name|isUriPathAbsolute
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"Unsupported name: has scheme but relative path-part"
argument_list|)
throw|;
block|}
block|}
comment|/**    * Get the file system of supplied path.    *     * @param absOrFqPath - absolute or fully qualified path    * @return the file system of the path    *     * @throws UnsupportedFileSystemException If the file system for    *<code>absOrFqPath</code> is not supported.    * @throws IOExcepton If the file system for<code>absOrFqPath</code> could    *         not be instantiated.    */
DECL|method|getFSofPath (final Path absOrFqPath)
specifier|private
name|AbstractFileSystem
name|getFSofPath
parameter_list|(
specifier|final
name|Path
name|absOrFqPath
parameter_list|)
throws|throws
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
name|checkNotSchemeWithRelative
argument_list|(
name|absOrFqPath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|absOrFqPath
operator|.
name|isAbsolute
argument_list|()
operator|&&
name|absOrFqPath
operator|.
name|toUri
argument_list|()
operator|.
name|getScheme
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"FileContext Bug: path is relative"
argument_list|)
throw|;
block|}
try|try
block|{
comment|// Is it the default FS for this FileContext?
name|defaultFS
operator|.
name|checkPath
argument_list|(
name|absOrFqPath
argument_list|)
expr_stmt|;
return|return
name|defaultFS
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// it is different FileSystem
return|return
name|getAbstractFileSystem
argument_list|(
name|ugi
argument_list|,
name|absOrFqPath
operator|.
name|toUri
argument_list|()
argument_list|,
name|conf
argument_list|)
return|;
block|}
block|}
DECL|method|getAbstractFileSystem ( UserGroupInformation user, final URI uri, final Configuration conf)
specifier|private
specifier|static
name|AbstractFileSystem
name|getAbstractFileSystem
parameter_list|(
name|UserGroupInformation
name|user
parameter_list|,
specifier|final
name|URI
name|uri
parameter_list|,
specifier|final
name|Configuration
name|conf
parameter_list|)
throws|throws
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
try|try
block|{
return|return
name|user
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|AbstractFileSystem
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|AbstractFileSystem
name|run
parameter_list|()
throws|throws
name|UnsupportedFileSystemException
block|{
return|return
name|AbstractFileSystem
operator|.
name|get
argument_list|(
name|uri
argument_list|,
name|conf
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to get the AbstractFileSystem for path: "
operator|+
name|uri
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
comment|/**    * Protected Static Factory methods for getting a FileContexts    * that take a AbstractFileSystem as input. To be used for testing.    */
comment|/**    * Create a FileContext with specified FS as default using the specified    * config.    *     * @param defFS    * @param aConf    * @return new FileContext with specifed FS as default.    */
DECL|method|getFileContext (final AbstractFileSystem defFS, final Configuration aConf)
specifier|public
specifier|static
name|FileContext
name|getFileContext
parameter_list|(
specifier|final
name|AbstractFileSystem
name|defFS
parameter_list|,
specifier|final
name|Configuration
name|aConf
parameter_list|)
block|{
return|return
operator|new
name|FileContext
argument_list|(
name|defFS
argument_list|,
name|FsPermission
operator|.
name|getUMask
argument_list|(
name|aConf
argument_list|)
argument_list|,
name|aConf
argument_list|)
return|;
block|}
comment|/**    * Create a FileContext for specified file system using the default config.    *     * @param defaultFS    * @return a FileContext with the specified AbstractFileSystem    *                 as the default FS.    */
DECL|method|getFileContext ( final AbstractFileSystem defaultFS)
specifier|protected
specifier|static
name|FileContext
name|getFileContext
parameter_list|(
specifier|final
name|AbstractFileSystem
name|defaultFS
parameter_list|)
block|{
return|return
name|getFileContext
argument_list|(
name|defaultFS
argument_list|,
operator|new
name|Configuration
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Static Factory methods for getting a FileContext.    * Note new file contexts are created for each call.    * The only singleton is the local FS context using the default config.    *     * Methods that use the default config: the default config read from the    * $HADOOP_CONFIG/core.xml,    * Unspecified key-values for config are defaulted from core-defaults.xml    * in the release jar.    *     * The keys relevant to the FileContext layer are extracted at time of    * construction. Changes to the config after the call are ignore    * by the FileContext layer.     * The conf is passed to lower layers like AbstractFileSystem and HDFS which    * pick up their own config variables.    */
comment|/**    * Create a FileContext using the default config read from the    * $HADOOP_CONFIG/core.xml, Unspecified key-values for config are defaulted    * from core-defaults.xml in the release jar.    *     * @throws UnsupportedFileSystemException If the file system from the default    *           configuration is not supported    */
DECL|method|getFileContext ()
specifier|public
specifier|static
name|FileContext
name|getFileContext
parameter_list|()
throws|throws
name|UnsupportedFileSystemException
block|{
return|return
name|getFileContext
argument_list|(
operator|new
name|Configuration
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * @return a FileContext for the local file system using the default config.    * @throws UnsupportedFileSystemException If the file system for    *           {@link FsConstants#LOCAL_FS_URI} is not supported.    */
DECL|method|getLocalFSFileContext ()
specifier|public
specifier|static
name|FileContext
name|getLocalFSFileContext
parameter_list|()
throws|throws
name|UnsupportedFileSystemException
block|{
return|return
name|getFileContext
argument_list|(
name|FsConstants
operator|.
name|LOCAL_FS_URI
argument_list|)
return|;
block|}
comment|/**    * Create a FileContext for specified URI using the default config.    *     * @param defaultFsUri    * @return a FileContext with the specified URI as the default FS.    *     * @throws UnsupportedFileSystemException If the file system for    *<code>defaultFsUri</code> is not supported    */
DECL|method|getFileContext (final URI defaultFsUri)
specifier|public
specifier|static
name|FileContext
name|getFileContext
parameter_list|(
specifier|final
name|URI
name|defaultFsUri
parameter_list|)
throws|throws
name|UnsupportedFileSystemException
block|{
return|return
name|getFileContext
argument_list|(
name|defaultFsUri
argument_list|,
operator|new
name|Configuration
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Create a FileContext for specified default URI using the specified config.    *     * @param defaultFsUri    * @param aConf    * @return new FileContext for specified uri    * @throws UnsupportedFileSystemException If the file system with specified is    *           not supported    * @throws RuntimeException If the file system specified is supported but    *         could not be instantiated, or if login fails.    */
DECL|method|getFileContext (final URI defaultFsUri, final Configuration aConf)
specifier|public
specifier|static
name|FileContext
name|getFileContext
parameter_list|(
specifier|final
name|URI
name|defaultFsUri
parameter_list|,
specifier|final
name|Configuration
name|aConf
parameter_list|)
throws|throws
name|UnsupportedFileSystemException
block|{
name|UserGroupInformation
name|currentUser
init|=
literal|null
decl_stmt|;
name|AbstractFileSystem
name|defaultAfs
init|=
literal|null
decl_stmt|;
try|try
block|{
name|currentUser
operator|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
expr_stmt|;
name|defaultAfs
operator|=
name|getAbstractFileSystem
argument_list|(
name|currentUser
argument_list|,
name|defaultFsUri
argument_list|,
name|aConf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedFileSystemException
name|ex
parameter_list|)
block|{
throw|throw
name|ex
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|LOG
operator|.
name|error
argument_list|(
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
return|return
name|getFileContext
argument_list|(
name|defaultAfs
argument_list|,
name|aConf
argument_list|)
return|;
block|}
comment|/**    * Create a FileContext using the passed config. Generally it is better to use    * {@link #getFileContext(URI, Configuration)} instead of this one.    *     *     * @param aConf    * @return new FileContext    * @throws UnsupportedFileSystemException If file system in the config    *           is not supported    */
DECL|method|getFileContext (final Configuration aConf)
specifier|public
specifier|static
name|FileContext
name|getFileContext
parameter_list|(
specifier|final
name|Configuration
name|aConf
parameter_list|)
throws|throws
name|UnsupportedFileSystemException
block|{
return|return
name|getFileContext
argument_list|(
name|URI
operator|.
name|create
argument_list|(
name|aConf
operator|.
name|get
argument_list|(
name|FS_DEFAULT_NAME_KEY
argument_list|,
name|FS_DEFAULT_NAME_DEFAULT
argument_list|)
argument_list|)
argument_list|,
name|aConf
argument_list|)
return|;
block|}
comment|/**    * @param aConf - from which the FileContext is configured    * @return a FileContext for the local file system using the specified config.    *     * @throws UnsupportedFileSystemException If default file system in the config    *           is not supported    *     */
DECL|method|getLocalFSFileContext (final Configuration aConf)
specifier|public
specifier|static
name|FileContext
name|getLocalFSFileContext
parameter_list|(
specifier|final
name|Configuration
name|aConf
parameter_list|)
throws|throws
name|UnsupportedFileSystemException
block|{
return|return
name|getFileContext
argument_list|(
name|FsConstants
operator|.
name|LOCAL_FS_URI
argument_list|,
name|aConf
argument_list|)
return|;
block|}
comment|/* This method is needed for tests. */
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
comment|/* return type will change to AFS once                                   HADOOP-6223 is completed */
DECL|method|getDefaultFileSystem ()
specifier|public
name|AbstractFileSystem
name|getDefaultFileSystem
parameter_list|()
block|{
return|return
name|defaultFS
return|;
block|}
comment|/**    * Set the working directory for wd-relative names (such a "foo/bar"). Working    * directory feature is provided by simply prefixing relative names with the    * working dir. Note this is different from Unix where the wd is actually set    * to the inode. Hence setWorkingDir does not follow symlinks etc. This works    * better in a distributed environment that has multiple independent roots.    * {@link #getWorkingDirectory()} should return what setWorkingDir() set.    *     * @param newWDir new working directory    * @throws IOException     *<br>    *           NewWdir can be one of:    *<ul>    *<li>relative path: "foo/bar";</li>    *<li>absolute without scheme: "/foo/bar"</li>    *<li>fully qualified with scheme: "xx://auth/foo/bar"</li>    *</ul>    *<br>    *           Illegal WDs:    *<ul>    *<li>relative with scheme: "xx:foo/bar"</li>    *<li>non existent directory</li>    *</ul>    */
DECL|method|setWorkingDirectory (final Path newWDir)
specifier|public
name|void
name|setWorkingDirectory
parameter_list|(
specifier|final
name|Path
name|newWDir
parameter_list|)
throws|throws
name|IOException
block|{
name|checkNotSchemeWithRelative
argument_list|(
name|newWDir
argument_list|)
expr_stmt|;
comment|/* wd is stored as a fully qualified path. We check if the given       * path is not relative first since resolve requires and returns       * an absolute path.      */
specifier|final
name|Path
name|newWorkingDir
init|=
operator|new
name|Path
argument_list|(
name|workingDir
argument_list|,
name|newWDir
argument_list|)
decl_stmt|;
name|FileStatus
name|status
init|=
name|getFileStatus
argument_list|(
name|newWorkingDir
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|.
name|isFile
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|FileNotFoundException
argument_list|(
literal|"Cannot setWD to a file"
argument_list|)
throw|;
block|}
name|workingDir
operator|=
name|newWorkingDir
expr_stmt|;
block|}
comment|/**    * Gets the working directory for wd-relative names (such a "foo/bar").    */
DECL|method|getWorkingDirectory ()
specifier|public
name|Path
name|getWorkingDirectory
parameter_list|()
block|{
return|return
name|workingDir
return|;
block|}
comment|/**    * Gets the ugi in the file-context    * @return UserGroupInformation    */
DECL|method|getUgi ()
specifier|public
name|UserGroupInformation
name|getUgi
parameter_list|()
block|{
return|return
name|ugi
return|;
block|}
comment|/**    * Return the current user's home directory in this file system.    * The default implementation returns "/user/$USER/".    * @return the home directory    */
DECL|method|getHomeDirectory ()
specifier|public
name|Path
name|getHomeDirectory
parameter_list|()
block|{
return|return
name|defaultFS
operator|.
name|getHomeDirectory
argument_list|()
return|;
block|}
comment|/**    *     * @return the umask of this FileContext    */
DECL|method|getUMask ()
specifier|public
name|FsPermission
name|getUMask
parameter_list|()
block|{
return|return
name|umask
return|;
block|}
comment|/**    * Set umask to the supplied parameter.    * @param newUmask  the new umask    */
DECL|method|setUMask (final FsPermission newUmask)
specifier|public
name|void
name|setUMask
parameter_list|(
specifier|final
name|FsPermission
name|newUmask
parameter_list|)
block|{
name|umask
operator|=
name|newUmask
expr_stmt|;
block|}
comment|/**    * Resolve the path following any symlinks or mount points    * @param f to be resolved    * @return fully qualified resolved path    *     * @throws FileNotFoundException  If<code>f</code> does not exist    * @throws AccessControlException if access denied    * @throws IOException If an IO Error occurred    *     * Exceptions applicable to file systems accessed over RPC:    * @throws RpcClientException If an exception occurred in the RPC client    * @throws RpcServerException If an exception occurred in the RPC server    * @throws UnexpectedServerException If server implementation throws    *           undeclared exception to RPC server    *     * RuntimeExceptions:    * @throws InvalidPathException If path<code>f</code> is not valid    */
DECL|method|resolvePath (final Path f)
specifier|public
name|Path
name|resolvePath
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|AccessControlException
throws|,
name|IOException
block|{
return|return
name|resolve
argument_list|(
name|f
argument_list|)
return|;
block|}
comment|/**    * Make the path fully qualified if it is isn't.     * A Fully-qualified path has scheme and authority specified and an absolute    * path.    * Use the default file system and working dir in this FileContext to qualify.    * @param path    * @return qualified path    */
DECL|method|makeQualified (final Path path)
specifier|public
name|Path
name|makeQualified
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|)
block|{
return|return
name|path
operator|.
name|makeQualified
argument_list|(
name|defaultFS
operator|.
name|getUri
argument_list|()
argument_list|,
name|getWorkingDirectory
argument_list|()
argument_list|)
return|;
block|}
comment|/**    * Create or overwrite file on indicated path and returns an output stream for    * writing into the file.    *     * @param f the file name to open    * @param createFlag gives the semantics of create; see {@link CreateFlag}    * @param opts file creation options; see {@link Options.CreateOpts}.    *<ul>    *<li>Progress - to report progress on the operation - default null    *<li>Permission - umask is applied against permisssion: default is    *          FsPermissions:getDefault()    *     *<li>CreateParent - create missing parent path; default is to not    *          to create parents    *<li>The defaults for the following are SS defaults of the file    *          server implementing the target path. Not all parameters make sense    *          for all kinds of file system - eg. localFS ignores Blocksize,    *          replication, checksum    *<ul>    *<li>BufferSize - buffersize used in FSDataOutputStream    *<li>Blocksize - block size for file blocks    *<li>ReplicationFactor - replication for blocks    *<li>ChecksumParam - Checksum parameters. server default is used    *          if not specified.    *</ul>    *</ul>    *     * @return {@link FSDataOutputStream} for created file    *     * @throws AccessControlException If access is denied    * @throws FileAlreadyExistsException If file<code>f</code> already exists    * @throws FileNotFoundException If parent of<code>f</code> does not exist    *           and<code>createParent</code> is false    * @throws ParentNotDirectoryException If parent of<code>f</code> is not a    *           directory.    * @throws UnsupportedFileSystemException If file system for<code>f</code> is    *           not supported    * @throws IOException If an I/O error occurred    *     * Exceptions applicable to file systems accessed over RPC:    * @throws RpcClientException If an exception occurred in the RPC client    * @throws RpcServerException If an exception occurred in the RPC server    * @throws UnexpectedServerException If server implementation throws    *           undeclared exception to RPC server    *     * RuntimeExceptions:    * @throws InvalidPathException If path<code>f</code> is not valid    */
DECL|method|create (final Path f, final EnumSet<CreateFlag> createFlag, Options.CreateOpts... opts)
specifier|public
name|FSDataOutputStream
name|create
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|createFlag
parameter_list|,
name|Options
operator|.
name|CreateOpts
modifier|...
name|opts
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileAlreadyExistsException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
comment|// If one of the options is a permission, extract it& apply umask
comment|// If not, add a default Perms and apply umask;
comment|// AbstractFileSystem#create
name|CreateOpts
operator|.
name|Perms
name|permOpt
init|=
operator|(
name|CreateOpts
operator|.
name|Perms
operator|)
name|CreateOpts
operator|.
name|getOpt
argument_list|(
name|CreateOpts
operator|.
name|Perms
operator|.
name|class
argument_list|,
name|opts
argument_list|)
decl_stmt|;
name|FsPermission
name|permission
init|=
operator|(
name|permOpt
operator|!=
literal|null
operator|)
condition|?
name|permOpt
operator|.
name|getValue
argument_list|()
else|:
name|FILE_DEFAULT_PERM
decl_stmt|;
name|permission
operator|=
name|permission
operator|.
name|applyUMask
argument_list|(
name|umask
argument_list|)
expr_stmt|;
specifier|final
name|CreateOpts
index|[]
name|updatedOpts
init|=
name|CreateOpts
operator|.
name|setOpt
argument_list|(
name|CreateOpts
operator|.
name|perms
argument_list|(
name|permission
argument_list|)
argument_list|,
name|opts
argument_list|)
decl_stmt|;
return|return
operator|new
name|FSLinkResolver
argument_list|<
name|FSDataOutputStream
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FSDataOutputStream
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|fs
operator|.
name|create
argument_list|(
name|p
argument_list|,
name|createFlag
argument_list|,
name|updatedOpts
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * Make(create) a directory and all the non-existent parents.    *     * @param dir - the dir to make    * @param permission - permissions is set permission&~umask    * @param createParent - if true then missing parent dirs are created if false    *          then parent must exist    *     * @throws AccessControlException If access is denied    * @throws FileAlreadyExistsException If directory<code>dir</code> already    *           exists    * @throws FileNotFoundException If parent of<code>dir</code> does not exist    *           and<code>createParent</code> is false    * @throws ParentNotDirectoryException If parent of<code>dir</code> is not a    *           directory    * @throws UnsupportedFileSystemException If file system for<code>dir</code>    *         is not supported    * @throws IOException If an I/O error occurred    *     * Exceptions applicable to file systems accessed over RPC:    * @throws RpcClientException If an exception occurred in the RPC client    * @throws UnexpectedServerException If server implementation throws     *           undeclared exception to RPC server    *     * RuntimeExceptions:    * @throws InvalidPathException If path<code>dir</code> is not valid    */
DECL|method|mkdir (final Path dir, final FsPermission permission, final boolean createParent)
specifier|public
name|void
name|mkdir
parameter_list|(
specifier|final
name|Path
name|dir
parameter_list|,
specifier|final
name|FsPermission
name|permission
parameter_list|,
specifier|final
name|boolean
name|createParent
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileAlreadyExistsException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
specifier|final
name|Path
name|absDir
init|=
name|fixRelativePart
argument_list|(
name|dir
argument_list|)
decl_stmt|;
specifier|final
name|FsPermission
name|absFerms
init|=
operator|(
name|permission
operator|==
literal|null
condition|?
name|FsPermission
operator|.
name|getDirDefault
argument_list|()
else|:
name|permission
operator|)
operator|.
name|applyUMask
argument_list|(
name|umask
argument_list|)
decl_stmt|;
operator|new
name|FSLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|fs
operator|.
name|mkdir
argument_list|(
name|p
argument_list|,
name|absFerms
argument_list|,
name|createParent
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absDir
argument_list|)
expr_stmt|;
block|}
comment|/**    * Delete a file.    * @param f the path to delete.    * @param recursive if path is a directory and set to     * true, the directory is deleted else throws an exception. In    * case of a file the recursive can be set to either true or false.    *    * @throws AccessControlException If access is denied    * @throws FileNotFoundException If<code>f</code> does not exist    * @throws UnsupportedFileSystemException If file system for<code>f</code> is    *           not supported    * @throws IOException If an I/O error occurred    *     * Exceptions applicable to file systems accessed over RPC:    * @throws RpcClientException If an exception occurred in the RPC client    * @throws RpcServerException If an exception occurred in the RPC server    * @throws UnexpectedServerException If server implementation throws     *           undeclared exception to RPC server    *     * RuntimeExceptions:    * @throws InvalidPathException If path<code>f</code> is invalid    */
DECL|method|delete (final Path f, final boolean recursive)
specifier|public
name|boolean
name|delete
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|boolean
name|recursive
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FSLinkResolver
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|fs
operator|.
name|delete
argument_list|(
name|p
argument_list|,
name|recursive
argument_list|)
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * Opens an FSDataInputStream at the indicated Path using    * default buffersize.    * @param f the file name to open    *    * @throws AccessControlException If access is denied    * @throws FileNotFoundException If file<code>f</code> does not exist    * @throws UnsupportedFileSystemException If file system for<code>f</code>    *         is not supported    * @throws IOException If an I/O error occurred    *     * Exceptions applicable to file systems accessed over RPC:    * @throws RpcClientException If an exception occurred in the RPC client    * @throws RpcServerException If an exception occurred in the RPC server    * @throws UnexpectedServerException If server implementation throws     *           undeclared exception to RPC server    */
DECL|method|open (final Path f)
specifier|public
name|FSDataInputStream
name|open
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FSLinkResolver
argument_list|<
name|FSDataInputStream
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FSDataInputStream
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
return|return
name|fs
operator|.
name|open
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * Opens an FSDataInputStream at the indicated Path.    *     * @param f the file name to open    * @param bufferSize the size of the buffer to be used.    *     * @throws AccessControlException If access is denied    * @throws FileNotFoundException If file<code>f</code> does not exist    * @throws UnsupportedFileSystemException If file system for<code>f</code> is    *           not supported    * @throws IOException If an I/O error occurred    *     * Exceptions applicable to file systems accessed over RPC:    * @throws RpcClientException If an exception occurred in the RPC client    * @throws RpcServerException If an exception occurred in the RPC server    * @throws UnexpectedServerException If server implementation throws     *           undeclared exception to RPC server    */
DECL|method|open (final Path f, final int bufferSize)
specifier|public
name|FSDataInputStream
name|open
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|int
name|bufferSize
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FSLinkResolver
argument_list|<
name|FSDataInputStream
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FSDataInputStream
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
return|return
name|fs
operator|.
name|open
argument_list|(
name|p
argument_list|,
name|bufferSize
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * Set replication for an existing file.    *     * @param f file name    * @param replication new replication    *    * @return true if successful    *    * @throws AccessControlException If access is denied    * @throws FileNotFoundException If file<code>f</code> does not exist    * @throws IOException If an I/O error occurred    *     * Exceptions applicable to file systems accessed over RPC:    * @throws RpcClientException If an exception occurred in the RPC client    * @throws RpcServerException If an exception occurred in the RPC server    * @throws UnexpectedServerException If server implementation throws     *           undeclared exception to RPC server    */
DECL|method|setReplication (final Path f, final short replication)
specifier|public
name|boolean
name|setReplication
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|short
name|replication
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FSLinkResolver
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Boolean
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|fs
operator|.
name|setReplication
argument_list|(
name|p
argument_list|,
name|replication
argument_list|)
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * Renames Path src to Path dst    *<ul>    *<li    *<li>Fails if src is a file and dst is a directory.    *<li>Fails if src is a directory and dst is a file.    *<li>Fails if the parent of dst does not exist or is a file.    *</ul>    *<p>    * If OVERWRITE option is not passed as an argument, rename fails if the dst    * already exists.    *<p>    * If OVERWRITE option is passed as an argument, rename overwrites the dst if    * it is a file or an empty directory. Rename fails if dst is a non-empty    * directory.    *<p>    * Note that atomicity of rename is dependent on the file system    * implementation. Please refer to the file system documentation for details    *<p>    *     * @param src path to be renamed    * @param dst new path after rename    *     * @throws AccessControlException If access is denied    * @throws FileAlreadyExistsException If<code>dst</code> already exists and    *<code>options</options> has {@link Options.Rename#OVERWRITE}     *           option false.    * @throws FileNotFoundException If<code>src</code> does not exist    * @throws ParentNotDirectoryException If parent of<code>dst</code> is not a    *           directory    * @throws UnsupportedFileSystemException If file system for<code>src</code>    *           and<code>dst</code> is not supported    * @throws IOException If an I/O error occurred    *     * Exceptions applicable to file systems accessed over RPC:    * @throws RpcClientException If an exception occurred in the RPC client    * @throws RpcServerException If an exception occurred in the RPC server    * @throws UnexpectedServerException If server implementation throws    *           undeclared exception to RPC server    */
DECL|method|rename (final Path src, final Path dst, final Options.Rename... options)
specifier|public
name|void
name|rename
parameter_list|(
specifier|final
name|Path
name|src
parameter_list|,
specifier|final
name|Path
name|dst
parameter_list|,
specifier|final
name|Options
operator|.
name|Rename
modifier|...
name|options
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileAlreadyExistsException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
specifier|final
name|Path
name|absSrc
init|=
name|fixRelativePart
argument_list|(
name|src
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|absDst
init|=
name|fixRelativePart
argument_list|(
name|dst
argument_list|)
decl_stmt|;
name|AbstractFileSystem
name|srcFS
init|=
name|getFSofPath
argument_list|(
name|absSrc
argument_list|)
decl_stmt|;
name|AbstractFileSystem
name|dstFS
init|=
name|getFSofPath
argument_list|(
name|absDst
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|srcFS
operator|.
name|getUri
argument_list|()
operator|.
name|equals
argument_list|(
name|dstFS
operator|.
name|getUri
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Renames across AbstractFileSystems not supported"
argument_list|)
throw|;
block|}
try|try
block|{
name|srcFS
operator|.
name|rename
argument_list|(
name|absSrc
argument_list|,
name|absDst
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnresolvedLinkException
name|e
parameter_list|)
block|{
comment|/* We do not know whether the source or the destination path        * was unresolved. Resolve the source path up until the final        * path component, then fully resolve the destination.         */
specifier|final
name|Path
name|source
init|=
name|resolveIntermediate
argument_list|(
name|absSrc
argument_list|)
decl_stmt|;
operator|new
name|FSLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|fs
operator|.
name|rename
argument_list|(
name|source
argument_list|,
name|p
argument_list|,
name|options
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absDst
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Set permission of a path.    * @param f    * @param permission - the new absolute permission (umask is not applied)    *    * @throws AccessControlException If access is denied    * @throws FileNotFoundException If<code>f</code> does not exist    * @throws UnsupportedFileSystemException If file system for<code>f</code>    *         is not supported    * @throws IOException If an I/O error occurred    *     * Exceptions applicable to file systems accessed over RPC:    * @throws RpcClientException If an exception occurred in the RPC client    * @throws RpcServerException If an exception occurred in the RPC server    * @throws UnexpectedServerException If server implementation throws     *           undeclared exception to RPC server    */
DECL|method|setPermission (final Path f, final FsPermission permission)
specifier|public
name|void
name|setPermission
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|FsPermission
name|permission
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
operator|new
name|FSLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|fs
operator|.
name|setPermission
argument_list|(
name|p
argument_list|,
name|permission
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set owner of a path (i.e. a file or a directory). The parameters username    * and groupname cannot both be null.    *     * @param f The path    * @param username If it is null, the original username remains unchanged.    * @param groupname If it is null, the original groupname remains unchanged.    *     * @throws AccessControlException If access is denied    * @throws FileNotFoundException If<code>f</code> does not exist    * @throws UnsupportedFileSystemException If file system for<code>f</code> is    *           not supported    * @throws IOException If an I/O error occurred    *     * Exceptions applicable to file systems accessed over RPC:    * @throws RpcClientException If an exception occurred in the RPC client    * @throws RpcServerException If an exception occurred in the RPC server    * @throws UnexpectedServerException If server implementation throws     *           undeclared exception to RPC server    *     * RuntimeExceptions:    * @throws HadoopIllegalArgumentException If<code>username</code> or    *<code>groupname</code> is invalid.    */
DECL|method|setOwner (final Path f, final String username, final String groupname)
specifier|public
name|void
name|setOwner
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|String
name|username
parameter_list|,
specifier|final
name|String
name|groupname
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|UnsupportedFileSystemException
throws|,
name|FileNotFoundException
throws|,
name|IOException
block|{
if|if
condition|(
operator|(
name|username
operator|==
literal|null
operator|)
operator|&&
operator|(
name|groupname
operator|==
literal|null
operator|)
condition|)
block|{
throw|throw
operator|new
name|HadoopIllegalArgumentException
argument_list|(
literal|"username and groupname cannot both be null"
argument_list|)
throw|;
block|}
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
operator|new
name|FSLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|fs
operator|.
name|setOwner
argument_list|(
name|p
argument_list|,
name|username
argument_list|,
name|groupname
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
comment|/**    * Set access time of a file.    * @param f The path    * @param mtime Set the modification time of this file.    *        The number of milliseconds since epoch (Jan 1, 1970).     *        A value of -1 means that this call should not set modification time.    * @param atime Set the access time of this file.    *        The number of milliseconds since Jan 1, 1970.     *        A value of -1 means that this call should not set access time.    *    * @throws AccessControlException If access is denied    * @throws FileNotFoundException If<code>f</code> does not exist    * @throws UnsupportedFileSystemException If file system for<code>f</code> is    *           not supported    * @throws IOException If an I/O error occurred    *     * Exceptions applicable to file systems accessed over RPC:    * @throws RpcClientException If an exception occurred in the RPC client    * @throws RpcServerException If an exception occurred in the RPC server    * @throws UnexpectedServerException If server implementation throws     *           undeclared exception to RPC server    */
DECL|method|setTimes (final Path f, final long mtime, final long atime)
specifier|public
name|void
name|setTimes
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|long
name|mtime
parameter_list|,
specifier|final
name|long
name|atime
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
operator|new
name|FSLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|fs
operator|.
name|setTimes
argument_list|(
name|p
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the checksum of a file.    *    * @param f file path    *    * @return The file checksum.  The default return value is null,    *  which indicates that no checksum algorithm is implemented    *  in the corresponding FileSystem.    *    * @throws AccessControlException If access is denied    * @throws FileNotFoundException If<code>f</code> does not exist    * @throws IOException If an I/O error occurred    *     * Exceptions applicable to file systems accessed over RPC:    * @throws RpcClientException If an exception occurred in the RPC client    * @throws RpcServerException If an exception occurred in the RPC server    * @throws UnexpectedServerException If server implementation throws     *           undeclared exception to RPC server    */
DECL|method|getFileChecksum (final Path f)
specifier|public
name|FileChecksum
name|getFileChecksum
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FSLinkResolver
argument_list|<
name|FileChecksum
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileChecksum
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
return|return
name|fs
operator|.
name|getFileChecksum
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * Set the verify checksum flag for the  file system denoted by the path.    * This is only applicable if the     * corresponding FileSystem supports checksum. By default doesn't do anything.    * @param verifyChecksum    * @param f set the verifyChecksum for the Filesystem containing this path    *    * @throws AccessControlException If access is denied    * @throws FileNotFoundException If<code>f</code> does not exist    * @throws UnsupportedFileSystemException If file system for<code>f</code> is    *           not supported    * @throws IOException If an I/O error occurred    *     * Exceptions applicable to file systems accessed over RPC:    * @throws RpcClientException If an exception occurred in the RPC client    * @throws RpcServerException If an exception occurred in the RPC server    * @throws UnexpectedServerException If server implementation throws     *           undeclared exception to RPC server    */
DECL|method|setVerifyChecksum (final boolean verifyChecksum, final Path f)
specifier|public
name|void
name|setVerifyChecksum
parameter_list|(
specifier|final
name|boolean
name|verifyChecksum
parameter_list|,
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|resolve
argument_list|(
name|fixRelativePart
argument_list|(
name|f
argument_list|)
argument_list|)
decl_stmt|;
name|getFSofPath
argument_list|(
name|absF
argument_list|)
operator|.
name|setVerifyChecksum
argument_list|(
name|verifyChecksum
argument_list|)
expr_stmt|;
block|}
comment|/**    * Return a file status object that represents the path.    * @param f The path we want information from    *    * @return a FileStatus object    *    * @throws AccessControlException If access is denied    * @throws FileNotFoundException If<code>f</code> does not exist    * @throws UnsupportedFileSystemException If file system for<code>f</code> is    *           not supported    * @throws IOException If an I/O error occurred    *     * Exceptions applicable to file systems accessed over RPC:    * @throws RpcClientException If an exception occurred in the RPC client    * @throws RpcServerException If an exception occurred in the RPC server    * @throws UnexpectedServerException If server implementation throws     *           undeclared exception to RPC server    */
DECL|method|getFileStatus (final Path f)
specifier|public
name|FileStatus
name|getFileStatus
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FSLinkResolver
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileStatus
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
return|return
name|fs
operator|.
name|getFileStatus
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * Return a fully qualified version of the given symlink target if it    * has no scheme and authority. Partially and fully qualified paths     * are returned unmodified.    * @param pathFS The AbstractFileSystem of the path    * @param pathWithLink Path that contains the symlink    * @param target The symlink's absolute target    * @return Fully qualified version of the target.    */
DECL|method|qualifySymlinkTarget (final AbstractFileSystem pathFS, Path pathWithLink, Path target)
specifier|private
specifier|static
name|Path
name|qualifySymlinkTarget
parameter_list|(
specifier|final
name|AbstractFileSystem
name|pathFS
parameter_list|,
name|Path
name|pathWithLink
parameter_list|,
name|Path
name|target
parameter_list|)
block|{
comment|// NB: makeQualified uses the target's scheme and authority, if
comment|// specified, and the scheme and authority of pathFS, if not.
specifier|final
name|String
name|scheme
init|=
name|target
operator|.
name|toUri
argument_list|()
operator|.
name|getScheme
argument_list|()
decl_stmt|;
specifier|final
name|String
name|auth
init|=
name|target
operator|.
name|toUri
argument_list|()
operator|.
name|getAuthority
argument_list|()
decl_stmt|;
return|return
operator|(
name|scheme
operator|==
literal|null
operator|&&
name|auth
operator|==
literal|null
operator|)
condition|?
name|target
operator|.
name|makeQualified
argument_list|(
name|pathFS
operator|.
name|getUri
argument_list|()
argument_list|,
name|pathWithLink
operator|.
name|getParent
argument_list|()
argument_list|)
else|:
name|target
return|;
block|}
comment|/**    * Return a file status object that represents the path. If the path     * refers to a symlink then the FileStatus of the symlink is returned.    * The behavior is equivalent to #getFileStatus() if the underlying    * file system does not support symbolic links.    * @param  f The path we want information from.    * @return A FileStatus object    *     * @throws AccessControlException If access is denied    * @throws FileNotFoundException If<code>f</code> does not exist    * @throws UnsupportedFileSystemException If file system for<code>f</code> is    *           not supported    * @throws IOException If an I/O error occurred    */
DECL|method|getFileLinkStatus (final Path f)
specifier|public
name|FileStatus
name|getFileLinkStatus
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FSLinkResolver
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileStatus
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|FileStatus
name|fi
init|=
name|fs
operator|.
name|getFileLinkStatus
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|fi
operator|.
name|isSymlink
argument_list|()
condition|)
block|{
name|fi
operator|.
name|setSymlink
argument_list|(
name|qualifySymlinkTarget
argument_list|(
name|fs
argument_list|,
name|p
argument_list|,
name|fi
operator|.
name|getSymlink
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|fi
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * Returns the target of the given symbolic link as it was specified    * when the link was created.  Links in the path leading up to the    * final path component are resolved transparently.    *    * @param f the path to return the target of    * @return The un-interpreted target of the symbolic link.    *     * @throws AccessControlException If access is denied    * @throws FileNotFoundException If path<code>f</code> does not exist    * @throws UnsupportedFileSystemException If file system for<code>f</code> is    *           not supported    * @throws IOException If the given path does not refer to a symlink    *           or an I/O error occurred    */
DECL|method|getLinkTarget (final Path f)
specifier|public
name|Path
name|getLinkTarget
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FSLinkResolver
argument_list|<
name|Path
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Path
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|FileStatus
name|fi
init|=
name|fs
operator|.
name|getFileLinkStatus
argument_list|(
name|p
argument_list|)
decl_stmt|;
return|return
name|fi
operator|.
name|getSymlink
argument_list|()
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * Return blockLocation of the given file for the given offset and len.    *  For a nonexistent file or regions, null will be returned.    *    * This call is most helpful with DFS, where it returns     * hostnames of machines that contain the given file.    *     * @param f - get blocklocations of this file    * @param start position (byte offset)    * @param len (in bytes)    *    * @return block locations for given file at specified offset of len    *    * @throws AccessControlException If access is denied    * @throws FileNotFoundException If<code>f</code> does not exist    * @throws UnsupportedFileSystemException If file system for<code>f</code> is    *           not supported    * @throws IOException If an I/O error occurred    *     * Exceptions applicable to file systems accessed over RPC:    * @throws RpcClientException If an exception occurred in the RPC client    * @throws RpcServerException If an exception occurred in the RPC server    * @throws UnexpectedServerException If server implementation throws     *           undeclared exception to RPC server    *     * RuntimeExceptions:    * @throws InvalidPathException If path<code>f</code> is invalid    */
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|,
literal|"MapReduce"
block|}
argument_list|)
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|method|getFileBlockLocations (final Path f, final long start, final long len)
specifier|public
name|BlockLocation
index|[]
name|getFileBlockLocations
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|long
name|start
parameter_list|,
specifier|final
name|long
name|len
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FSLinkResolver
argument_list|<
name|BlockLocation
index|[]
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|BlockLocation
index|[]
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
return|return
name|fs
operator|.
name|getFileBlockLocations
argument_list|(
name|p
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * Returns a status object describing the use and capacity of the    * file system denoted by the Parh argument p.    * If the file system has multiple partitions, the    * use and capacity of the partition pointed to by the specified    * path is reflected.    *     * @param f Path for which status should be obtained. null means the    * root partition of the default file system.     *    * @return a FsStatus object    *    * @throws AccessControlException If access is denied    * @throws FileNotFoundException If<code>f</code> does not exist    * @throws UnsupportedFileSystemException If file system for<code>f</code> is    *           not supported    * @throws IOException If an I/O error occurred    *     * Exceptions applicable to file systems accessed over RPC:    * @throws RpcClientException If an exception occurred in the RPC client    * @throws RpcServerException If an exception occurred in the RPC server    * @throws UnexpectedServerException If server implementation throws     *           undeclared exception to RPC server    */
DECL|method|getFsStatus (final Path f)
specifier|public
name|FsStatus
name|getFsStatus
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
if|if
condition|(
name|f
operator|==
literal|null
condition|)
block|{
return|return
name|defaultFS
operator|.
name|getFsStatus
argument_list|()
return|;
block|}
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FSLinkResolver
argument_list|<
name|FsStatus
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FsStatus
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
return|return
name|fs
operator|.
name|getFsStatus
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * Creates a symbolic link to an existing file. An exception is thrown if     * the symlink exits, the user does not have permission to create symlink,    * or the underlying file system does not support symlinks.    *     * Symlink permissions are ignored, access to a symlink is determined by    * the permissions of the symlink target.    *     * Symlinks in paths leading up to the final path component are resolved     * transparently. If the final path component refers to a symlink some     * functions operate on the symlink itself, these are:    * - delete(f) and deleteOnExit(f) - Deletes the symlink.    * - rename(src, dst) - If src refers to a symlink, the symlink is     *   renamed. If dst refers to a symlink, the symlink is over-written.    * - getLinkTarget(f) - Returns the target of the symlink.     * - getFileLinkStatus(f) - Returns a FileStatus object describing    *   the symlink.    * Some functions, create() and mkdir(), expect the final path component    * does not exist. If they are given a path that refers to a symlink that     * does exist they behave as if the path referred to an existing file or     * directory. All other functions fully resolve, ie follow, the symlink.     * These are: open, setReplication, setOwner, setTimes, setWorkingDirectory,    * setPermission, getFileChecksum, setVerifyChecksum, getFileBlockLocations,    * getFsStatus, getFileStatus, exists, and listStatus.    *     * Symlink targets are stored as given to createSymlink, assuming the     * underlying file system is capable of storing a fully qualified URI.    * Dangling symlinks are permitted. FileContext supports four types of     * symlink targets, and resolves them as follows    *<pre>    * Given a path referring to a symlink of form:    *     *<---X--->     *   fs://host/A/B/link     *<-----Y----->    *     * In this path X is the scheme and authority that identify the file system,    * and Y is the path leading up to the final path component "link". If Y is    * a symlink  itself then let Y' be the target of Y and X' be the scheme and    * authority of Y'. Symlink targets may:    *     * 1. Fully qualified URIs    *     * fs://hostX/A/B/file  Resolved according to the target file system.    *     * 2. Partially qualified URIs (eg scheme but no host)    *     * fs:///A/B/file  Resolved according to the target file sytem. Eg resolving    *                 a symlink to hdfs:///A results in an exception because    *                 HDFS URIs must be fully qualified, while a symlink to     *                 file:///A will not since Hadoop's local file systems     *                 require partially qualified URIs.    *     * 3. Relative paths    *     * path  Resolves to [Y'][path]. Eg if Y resolves to hdfs://host/A and path     *       is "../B/file" then [Y'][path] is hdfs://host/B/file    *     * 4. Absolute paths    *     * path  Resolves to [X'][path]. Eg if Y resolves hdfs://host/A/B and path    *       is "/file" then [X][path] is hdfs://host/file    *</pre>    *     * @param target the target of the symbolic link    * @param link the path to be created that points to target    * @param createParent if true then missing parent dirs are created if     *                     false then parent must exist    *    *    * @throws AccessControlException If access is denied    * @throws FileAlreadyExistsException If file<code>linkcode> already exists    * @throws FileNotFoundException If<code>target</code> does not exist    * @throws ParentNotDirectoryException If parent of<code>link</code> is not a    *           directory.    * @throws UnsupportedFileSystemException If file system for     *<code>target</code> or<code>link</code> is not supported    * @throws IOException If an I/O error occurred    */
DECL|method|createSymlink (final Path target, final Path link, final boolean createParent)
specifier|public
name|void
name|createSymlink
parameter_list|(
specifier|final
name|Path
name|target
parameter_list|,
specifier|final
name|Path
name|link
parameter_list|,
specifier|final
name|boolean
name|createParent
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileAlreadyExistsException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
specifier|final
name|Path
name|nonRelLink
init|=
name|fixRelativePart
argument_list|(
name|link
argument_list|)
decl_stmt|;
operator|new
name|FSLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|fs
operator|.
name|createSymlink
argument_list|(
name|target
argument_list|,
name|p
argument_list|,
name|createParent
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|nonRelLink
argument_list|)
expr_stmt|;
block|}
comment|/**    * List the statuses of the files/directories in the given path if the path is    * a directory.    *     * @param f is the path    *    * @return an iterator that traverses statuses of the files/directories     *         in the given path    *    * @throws AccessControlException If access is denied    * @throws FileNotFoundException If<code>f</code> does not exist    * @throws UnsupportedFileSystemException If file system for<code>f</code> is    *           not supported    * @throws IOException If an I/O error occurred    *     * Exceptions applicable to file systems accessed over RPC:    * @throws RpcClientException If an exception occurred in the RPC client    * @throws RpcServerException If an exception occurred in the RPC server    * @throws UnexpectedServerException If server implementation throws     *           undeclared exception to RPC server    */
DECL|method|listStatus (final Path f)
specifier|public
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|listStatus
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FSLinkResolver
argument_list|<
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
return|return
name|fs
operator|.
name|listStatusIterator
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * @return an iterator over the corrupt files under the given path    * (may contain duplicates if a file has more than one corrupt block)    * @throws IOException    */
DECL|method|listCorruptFileBlocks (Path path)
specifier|public
name|RemoteIterator
argument_list|<
name|Path
argument_list|>
name|listCorruptFileBlocks
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|path
argument_list|)
decl_stmt|;
return|return
operator|new
name|FSLinkResolver
argument_list|<
name|RemoteIterator
argument_list|<
name|Path
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RemoteIterator
argument_list|<
name|Path
argument_list|>
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
return|return
name|fs
operator|.
name|listCorruptFileBlocks
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * List the statuses of the files/directories in the given path if the path is    * a directory.     * Return the file's status and block locations If the path is a file.    *     * If a returned status is a file, it contains the file's block locations.    *     * @param f is the path    *    * @return an iterator that traverses statuses of the files/directories     *         in the given path    * If any IO exception (for example the input directory gets deleted while    * listing is being executed), next() or hasNext() of the returned iterator    * may throw a RuntimeException with the io exception as the cause.    *    * @throws AccessControlException If access is denied    * @throws FileNotFoundException If<code>f</code> does not exist    * @throws UnsupportedFileSystemException If file system for<code>f</code> is    *           not supported    * @throws IOException If an I/O error occurred    *     * Exceptions applicable to file systems accessed over RPC:    * @throws RpcClientException If an exception occurred in the RPC client    * @throws RpcServerException If an exception occurred in the RPC server    * @throws UnexpectedServerException If server implementation throws     *           undeclared exception to RPC server    */
DECL|method|listLocatedStatus ( final Path f)
specifier|public
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|listLocatedStatus
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FSLinkResolver
argument_list|<
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
return|return
name|fs
operator|.
name|listLocatedStatus
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**    * Mark a path to be deleted on JVM shutdown.    *     * @param f the existing path to delete.    *    * @return  true if deleteOnExit is successful, otherwise false.    *    * @throws AccessControlException If access is denied    * @throws UnsupportedFileSystemException If file system for<code>f</code> is    *           not supported    * @throws IOException If an I/O error occurred    *     * Exceptions applicable to file systems accessed over RPC:    * @throws RpcClientException If an exception occurred in the RPC client    * @throws RpcServerException If an exception occurred in the RPC server    * @throws UnexpectedServerException If server implementation throws     *           undeclared exception to RPC server    */
DECL|method|deleteOnExit (Path f)
specifier|public
name|boolean
name|deleteOnExit
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|IOException
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|util
argument_list|()
operator|.
name|exists
argument_list|(
name|f
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
synchronized|synchronized
init|(
name|DELETE_ON_EXIT
init|)
block|{
if|if
condition|(
name|DELETE_ON_EXIT
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ShutdownHookManager
operator|.
name|get
argument_list|()
operator|.
name|addShutdownHook
argument_list|(
name|FINALIZER
argument_list|,
name|SHUTDOWN_HOOK_PRIORITY
argument_list|)
expr_stmt|;
block|}
name|Set
argument_list|<
name|Path
argument_list|>
name|set
init|=
name|DELETE_ON_EXIT
operator|.
name|get
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|set
operator|==
literal|null
condition|)
block|{
name|set
operator|=
operator|new
name|TreeSet
argument_list|<
name|Path
argument_list|>
argument_list|()
expr_stmt|;
name|DELETE_ON_EXIT
operator|.
name|put
argument_list|(
name|this
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
name|set
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|field|util
specifier|private
specifier|final
name|Util
name|util
decl_stmt|;
DECL|method|util ()
specifier|public
name|Util
name|util
parameter_list|()
block|{
return|return
name|util
return|;
block|}
comment|/**    * Utility/library methods built over the basic FileContext methods.    * Since this are library functions, the oprtation are not atomic    * and some of them may partially complete if other threads are making    * changes to the same part of the name space.    */
DECL|class|Util
specifier|public
class|class
name|Util
block|{
comment|/**      * Does the file exist?      * Note: Avoid using this method if you already have FileStatus in hand.      * Instead reuse the FileStatus       * @param f the  file or dir to be checked      *      * @throws AccessControlException If access is denied      * @throws IOException If an I/O error occurred      * @throws UnsupportedFileSystemException If file system for<code>f</code> is      *           not supported      *       * Exceptions applicable to file systems accessed over RPC:      * @throws RpcClientException If an exception occurred in the RPC client      * @throws RpcServerException If an exception occurred in the RPC server      * @throws UnexpectedServerException If server implementation throws       *           undeclared exception to RPC server      */
DECL|method|exists (final Path f)
specifier|public
name|boolean
name|exists
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
try|try
block|{
name|FileStatus
name|fs
init|=
name|FileContext
operator|.
name|this
operator|.
name|getFileStatus
argument_list|(
name|f
argument_list|)
decl_stmt|;
assert|assert
name|fs
operator|!=
literal|null
assert|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Return a list of file status objects that corresponds to supplied paths      * excluding those non-existent paths.      *       * @param paths list of paths we want information from      *      * @return a list of FileStatus objects      *      * @throws AccessControlException If access is denied      * @throws IOException If an I/O error occurred      *       * Exceptions applicable to file systems accessed over RPC:      * @throws RpcClientException If an exception occurred in the RPC client      * @throws RpcServerException If an exception occurred in the RPC server      * @throws UnexpectedServerException If server implementation throws       *           undeclared exception to RPC server      */
DECL|method|getFileStatus (Path[] paths)
specifier|private
name|FileStatus
index|[]
name|getFileStatus
parameter_list|(
name|Path
index|[]
name|paths
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|IOException
block|{
if|if
condition|(
name|paths
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
argument_list|(
name|paths
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paths
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
try|try
block|{
name|results
operator|.
name|add
argument_list|(
name|FileContext
operator|.
name|this
operator|.
name|getFileStatus
argument_list|(
name|paths
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|fnfe
parameter_list|)
block|{
comment|// ignoring
block|}
block|}
return|return
name|results
operator|.
name|toArray
argument_list|(
operator|new
name|FileStatus
index|[
name|results
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**      * Return the {@link ContentSummary} of path f.      * @param f path      *      * @return the {@link ContentSummary} of path f.      *      * @throws AccessControlException If access is denied      * @throws FileNotFoundException If<code>f</code> does not exist      * @throws UnsupportedFileSystemException If file system for       *<code>f</code> is not supported      * @throws IOException If an I/O error occurred      *       * Exceptions applicable to file systems accessed over RPC:      * @throws RpcClientException If an exception occurred in the RPC client      * @throws RpcServerException If an exception occurred in the RPC server      * @throws UnexpectedServerException If server implementation throws       *           undeclared exception to RPC server      */
DECL|method|getContentSummary (Path f)
specifier|public
name|ContentSummary
name|getContentSummary
parameter_list|(
name|Path
name|f
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
name|FileStatus
name|status
init|=
name|FileContext
operator|.
name|this
operator|.
name|getFileStatus
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|.
name|isFile
argument_list|()
condition|)
block|{
return|return
operator|new
name|ContentSummary
argument_list|(
name|status
operator|.
name|getLen
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|long
index|[]
name|summary
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
name|RemoteIterator
argument_list|<
name|FileStatus
argument_list|>
name|statusIterator
init|=
name|FileContext
operator|.
name|this
operator|.
name|listStatus
argument_list|(
name|f
argument_list|)
decl_stmt|;
while|while
condition|(
name|statusIterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|FileStatus
name|s
init|=
name|statusIterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|ContentSummary
name|c
init|=
name|s
operator|.
name|isDirectory
argument_list|()
condition|?
name|getContentSummary
argument_list|(
name|s
operator|.
name|getPath
argument_list|()
argument_list|)
else|:
operator|new
name|ContentSummary
argument_list|(
name|s
operator|.
name|getLen
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|summary
index|[
literal|0
index|]
operator|+=
name|c
operator|.
name|getLength
argument_list|()
expr_stmt|;
name|summary
index|[
literal|1
index|]
operator|+=
name|c
operator|.
name|getFileCount
argument_list|()
expr_stmt|;
name|summary
index|[
literal|2
index|]
operator|+=
name|c
operator|.
name|getDirectoryCount
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|ContentSummary
argument_list|(
name|summary
index|[
literal|0
index|]
argument_list|,
name|summary
index|[
literal|1
index|]
argument_list|,
name|summary
index|[
literal|2
index|]
argument_list|)
return|;
block|}
comment|/**      * See {@link #listStatus(Path[], PathFilter)}      */
DECL|method|listStatus (Path[] files)
specifier|public
name|FileStatus
index|[]
name|listStatus
parameter_list|(
name|Path
index|[]
name|files
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|IOException
block|{
return|return
name|listStatus
argument_list|(
name|files
argument_list|,
name|DEFAULT_FILTER
argument_list|)
return|;
block|}
comment|/**      * Filter files/directories in the given path using the user-supplied path      * filter.      *       * @param f is the path name      * @param filter is the user-supplied path filter      *      * @return an array of FileStatus objects for the files under the given path      *         after applying the filter      *      * @throws AccessControlException If access is denied      * @throws FileNotFoundException If<code>f</code> does not exist      * @throws UnsupportedFileSystemException If file system for       *<code>pathPattern</code> is not supported      * @throws IOException If an I/O error occurred      *       * Exceptions applicable to file systems accessed over RPC:      * @throws RpcClientException If an exception occurred in the RPC client      * @throws RpcServerException If an exception occurred in the RPC server      * @throws UnexpectedServerException If server implementation throws       *           undeclared exception to RPC server      */
DECL|method|listStatus (Path f, PathFilter filter)
specifier|public
name|FileStatus
index|[]
name|listStatus
parameter_list|(
name|Path
name|f
parameter_list|,
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
decl_stmt|;
name|listStatus
argument_list|(
name|results
argument_list|,
name|f
argument_list|,
name|filter
argument_list|)
expr_stmt|;
return|return
name|results
operator|.
name|toArray
argument_list|(
operator|new
name|FileStatus
index|[
name|results
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**      * Filter files/directories in the given list of paths using user-supplied      * path filter.      *       * @param files is a list of paths      * @param filter is the filter      *      * @return a list of statuses for the files under the given paths after      *         applying the filter      *      * @throws AccessControlException If access is denied      * @throws FileNotFoundException If a file in<code>files</code> does not       *           exist      * @throws IOException If an I/O error occurred      *       * Exceptions applicable to file systems accessed over RPC:      * @throws RpcClientException If an exception occurred in the RPC client      * @throws RpcServerException If an exception occurred in the RPC server      * @throws UnexpectedServerException If server implementation throws       *           undeclared exception to RPC server      */
DECL|method|listStatus (Path[] files, PathFilter filter)
specifier|public
name|FileStatus
index|[]
name|listStatus
parameter_list|(
name|Path
index|[]
name|files
parameter_list|,
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|IOException
block|{
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|files
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|listStatus
argument_list|(
name|results
argument_list|,
name|files
index|[
name|i
index|]
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
return|return
name|results
operator|.
name|toArray
argument_list|(
operator|new
name|FileStatus
index|[
name|results
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/*      * Filter files/directories in the given path using the user-supplied path      * filter. Results are added to the given array<code>results</code>.      */
DECL|method|listStatus (ArrayList<FileStatus> results, Path f, PathFilter filter)
specifier|private
name|void
name|listStatus
parameter_list|(
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
name|results
parameter_list|,
name|Path
name|f
parameter_list|,
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|IOException
block|{
name|FileStatus
index|[]
name|listing
init|=
name|listStatus
argument_list|(
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|listing
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|listing
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|filter
operator|.
name|accept
argument_list|(
name|listing
index|[
name|i
index|]
operator|.
name|getPath
argument_list|()
argument_list|)
condition|)
block|{
name|results
operator|.
name|add
argument_list|(
name|listing
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * List the statuses of the files/directories in the given path       * if the path is a directory.      *       * @param f is the path      *      * @return an array that contains statuses of the files/directories       *         in the given path      *      * @throws AccessControlException If access is denied      * @throws FileNotFoundException If<code>f</code> does not exist      * @throws UnsupportedFileSystemException If file system for<code>f</code> is      *           not supported      * @throws IOException If an I/O error occurred      *       * Exceptions applicable to file systems accessed over RPC:      * @throws RpcClientException If an exception occurred in the RPC client      * @throws RpcServerException If an exception occurred in the RPC server      * @throws UnexpectedServerException If server implementation throws       *           undeclared exception to RPC server      */
DECL|method|listStatus (final Path f)
specifier|public
name|FileStatus
index|[]
name|listStatus
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
return|return
operator|new
name|FSLinkResolver
argument_list|<
name|FileStatus
index|[]
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileStatus
index|[]
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
return|return
name|fs
operator|.
name|listStatus
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|FileContext
operator|.
name|this
argument_list|,
name|absF
argument_list|)
return|;
block|}
comment|/**      * List the statuses and block locations of the files in the given path.      *       * If the path is a directory,       *   if recursive is false, returns files in the directory;      *   if recursive is true, return files in the subtree rooted at the path.      *   The subtree is traversed in the depth-first order.      * If the path is a file, return the file's status and block locations.      * Files across symbolic links are also returned.      *       * @param f is the path      * @param recursive if the subdirectories need to be traversed recursively      *      * @return an iterator that traverses statuses of the files      * If any IO exception (for example a sub-directory gets deleted while      * listing is being executed), next() or hasNext() of the returned iterator      * may throw a RuntimeException with the IO exception as the cause.      *      * @throws AccessControlException If access is denied      * @throws FileNotFoundException If<code>f</code> does not exist      * @throws UnsupportedFileSystemException If file system for<code>f</code>      *         is not supported      * @throws IOException If an I/O error occurred      *       * Exceptions applicable to file systems accessed over RPC:      * @throws RpcClientException If an exception occurred in the RPC client      * @throws RpcServerException If an exception occurred in the RPC server      * @throws UnexpectedServerException If server implementation throws       *           undeclared exception to RPC server      */
DECL|method|listFiles ( final Path f, final boolean recursive)
specifier|public
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|listFiles
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|,
specifier|final
name|boolean
name|recursive
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
return|return
operator|new
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
argument_list|()
block|{
specifier|private
name|Stack
argument_list|<
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
argument_list|>
name|itors
init|=
operator|new
name|Stack
argument_list|<
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
name|RemoteIterator
argument_list|<
name|LocatedFileStatus
argument_list|>
name|curItor
init|=
name|listLocatedStatus
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|LocatedFileStatus
name|curFile
decl_stmt|;
comment|/**          * Returns<tt>true</tt> if the iterator has more files.          *          * @return<tt>true</tt> if the iterator has more files.          * @throws AccessControlException if not allowed to access next          *                                file's status or locations          * @throws FileNotFoundException if next file does not exist any more          * @throws UnsupportedFileSystemException if next file's           *                                        fs is unsupported          * @throws IOException for all other IO errors          *                     for example, NameNode is not avaialbe or          *                     NameNode throws IOException due to an error          *                     while getting the status or block locations          */
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
throws|throws
name|IOException
block|{
while|while
condition|(
name|curFile
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|curItor
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|handleFileStat
argument_list|(
name|curItor
operator|.
name|next
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|itors
operator|.
name|empty
argument_list|()
condition|)
block|{
name|curItor
operator|=
name|itors
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**          * Process the input stat.          * If it is a file, return the file stat.          * If it is a directory, traverse the directory if recursive is true;          * ignore it if recursive is false.          * If it is a symlink, resolve the symlink first and then process it          * depending on if it is a file or directory.          * @param stat input status          * @throws AccessControlException if access is denied          * @throws FileNotFoundException if file is not found          * @throws UnsupportedFileSystemException if fs is not supported          * @throws IOException for all other IO errors          */
specifier|private
name|void
name|handleFileStat
parameter_list|(
name|LocatedFileStatus
name|stat
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|stat
operator|.
name|isFile
argument_list|()
condition|)
block|{
comment|// file
name|curFile
operator|=
name|stat
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stat
operator|.
name|isSymlink
argument_list|()
condition|)
block|{
comment|// symbolic link
comment|// resolve symbolic link
name|FileStatus
name|symstat
init|=
name|FileContext
operator|.
name|this
operator|.
name|getFileStatus
argument_list|(
name|stat
operator|.
name|getSymlink
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|symstat
operator|.
name|isFile
argument_list|()
operator|||
operator|(
name|recursive
operator|&&
name|symstat
operator|.
name|isDirectory
argument_list|()
operator|)
condition|)
block|{
name|itors
operator|.
name|push
argument_list|(
name|curItor
argument_list|)
expr_stmt|;
name|curItor
operator|=
name|listLocatedStatus
argument_list|(
name|stat
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|recursive
condition|)
block|{
comment|// directory
name|itors
operator|.
name|push
argument_list|(
name|curItor
argument_list|)
expr_stmt|;
name|curItor
operator|=
name|listLocatedStatus
argument_list|(
name|stat
operator|.
name|getPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Returns the next file's status with its block locations          *          * @throws AccessControlException if not allowed to access next          *                                file's status or locations          * @throws FileNotFoundException if next file does not exist any more          * @throws UnsupportedFileSystemException if next file's           *                                        fs is unsupported          * @throws IOException for all other IO errors          *                     for example, NameNode is not avaialbe or          *                     NameNode throws IOException due to an error          *                     while getting the status or block locations          */
annotation|@
name|Override
specifier|public
name|LocatedFileStatus
name|next
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|hasNext
argument_list|()
condition|)
block|{
name|LocatedFileStatus
name|result
init|=
name|curFile
decl_stmt|;
name|curFile
operator|=
literal|null
expr_stmt|;
return|return
name|result
return|;
block|}
throw|throw
operator|new
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
argument_list|(
literal|"No more entry in "
operator|+
name|f
argument_list|)
throw|;
block|}
block|}
return|;
block|}
comment|/**      *<p>Return all the files that match filePattern and are not checksum      * files. Results are sorted by their names.      *       *<p>      * A filename pattern is composed of<i>regular</i> characters and      *<i>special pattern matching</i> characters, which are:      *      *<dl>      *<dd>      *<dl>      *<p>      *<dt><tt> ?</tt>      *<dd> Matches any single character.      *      *<p>      *<dt><tt> *</tt>      *<dd> Matches zero or more characters.      *      *<p>      *<dt><tt> [<i>abc</i>]</tt>      *<dd> Matches a single character from character set      *<tt>{<i>a,b,c</i>}</tt>.      *      *<p>      *<dt><tt> [<i>a</i>-<i>b</i>]</tt>      *<dd> Matches a single character from the character range      *<tt>{<i>a...b</i>}</tt>. Note: character<tt><i>a</i></tt> must be      *     lexicographically less than or equal to character<tt><i>b</i></tt>.      *      *<p>      *<dt><tt> [^<i>a</i>]</tt>      *<dd> Matches a single char that is not from character set or range      *<tt>{<i>a</i>}</tt>.  Note that the<tt>^</tt> character must occur      *     immediately to the right of the opening bracket.      *      *<p>      *<dt><tt> \<i>c</i></tt>      *<dd> Removes (escapes) any special meaning of character<i>c</i>.      *      *<p>      *<dt><tt> {ab,cd}</tt>      *<dd> Matches a string from the string set<tt>{<i>ab, cd</i>}</tt>      *          *<p>      *<dt><tt> {ab,c{de,fh}}</tt>      *<dd> Matches a string from string set<tt>{<i>ab, cde, cfh</i>}</tt>      *      *</dl>      *</dd>      *</dl>      *      * @param pathPattern a regular expression specifying a pth pattern      *      * @return an array of paths that match the path pattern      *      * @throws AccessControlException If access is denied      * @throws UnsupportedFileSystemException If file system for       *<code>pathPattern</code> is not supported      * @throws IOException If an I/O error occurred      *       * Exceptions applicable to file systems accessed over RPC:      * @throws RpcClientException If an exception occurred in the RPC client      * @throws RpcServerException If an exception occurred in the RPC server      * @throws UnexpectedServerException If server implementation throws       *           undeclared exception to RPC server      */
DECL|method|globStatus (Path pathPattern)
specifier|public
name|FileStatus
index|[]
name|globStatus
parameter_list|(
name|Path
name|pathPattern
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
return|return
name|globStatus
argument_list|(
name|pathPattern
argument_list|,
name|DEFAULT_FILTER
argument_list|)
return|;
block|}
comment|/**      * Return an array of FileStatus objects whose path names match pathPattern      * and is accepted by the user-supplied path filter. Results are sorted by      * their path names.      * Return null if pathPattern has no glob and the path does not exist.      * Return an empty array if pathPattern has a glob and no path matches it.       *       * @param pathPattern regular expression specifying the path pattern      * @param filter user-supplied path filter      *      * @return an array of FileStatus objects      *      * @throws AccessControlException If access is denied      * @throws UnsupportedFileSystemException If file system for       *<code>pathPattern</code> is not supported      * @throws IOException If an I/O error occurred      *       * Exceptions applicable to file systems accessed over RPC:      * @throws RpcClientException If an exception occurred in the RPC client      * @throws RpcServerException If an exception occurred in the RPC server      * @throws UnexpectedServerException If server implementation throws       *           undeclared exception to RPC server      */
DECL|method|globStatus (final Path pathPattern, final PathFilter filter)
specifier|public
name|FileStatus
index|[]
name|globStatus
parameter_list|(
specifier|final
name|Path
name|pathPattern
parameter_list|,
specifier|final
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
name|URI
name|uri
init|=
name|getFSofPath
argument_list|(
name|fixRelativePart
argument_list|(
name|pathPattern
argument_list|)
argument_list|)
operator|.
name|getUri
argument_list|()
decl_stmt|;
name|String
name|filename
init|=
name|pathPattern
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|filePatterns
init|=
name|GlobExpander
operator|.
name|expand
argument_list|(
name|filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|filePatterns
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|Path
name|absPathPattern
init|=
name|fixRelativePart
argument_list|(
name|pathPattern
argument_list|)
decl_stmt|;
return|return
name|globStatusInternal
argument_list|(
name|uri
argument_list|,
operator|new
name|Path
argument_list|(
name|absPathPattern
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|,
name|filter
argument_list|)
return|;
block|}
else|else
block|{
name|List
argument_list|<
name|FileStatus
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|iFilePattern
range|:
name|filePatterns
control|)
block|{
name|Path
name|iAbsFilePattern
init|=
name|fixRelativePart
argument_list|(
operator|new
name|Path
argument_list|(
name|iFilePattern
argument_list|)
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|files
init|=
name|globStatusInternal
argument_list|(
name|uri
argument_list|,
name|iAbsFilePattern
argument_list|,
name|filter
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|file
range|:
name|files
control|)
block|{
name|results
operator|.
name|add
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|results
operator|.
name|toArray
argument_list|(
operator|new
name|FileStatus
index|[
name|results
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
block|}
comment|/**      *       * @param uri for all the inPathPattern      * @param inPathPattern - without the scheme& authority (take from uri)      * @param filter      *      * @return an array of FileStatus objects      *      * @throws AccessControlException If access is denied      * @throws IOException If an I/O error occurred      */
DECL|method|globStatusInternal (final URI uri, final Path inPathPattern, final PathFilter filter)
specifier|private
name|FileStatus
index|[]
name|globStatusInternal
parameter_list|(
specifier|final
name|URI
name|uri
parameter_list|,
specifier|final
name|Path
name|inPathPattern
parameter_list|,
specifier|final
name|PathFilter
name|filter
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|IOException
block|{
name|Path
index|[]
name|parents
init|=
operator|new
name|Path
index|[
literal|1
index|]
decl_stmt|;
name|int
name|level
init|=
literal|0
decl_stmt|;
assert|assert
operator|(
name|inPathPattern
operator|.
name|toUri
argument_list|()
operator|.
name|getScheme
argument_list|()
operator|==
literal|null
operator|&&
name|inPathPattern
operator|.
name|toUri
argument_list|()
operator|.
name|getAuthority
argument_list|()
operator|==
literal|null
operator|&&
name|inPathPattern
operator|.
name|isUriPathAbsolute
argument_list|()
operator|)
assert|;
name|String
name|filename
init|=
name|inPathPattern
operator|.
name|toUri
argument_list|()
operator|.
name|getPath
argument_list|()
decl_stmt|;
comment|// path has only zero component
if|if
condition|(
name|filename
operator|.
name|isEmpty
argument_list|()
operator|||
name|Path
operator|.
name|SEPARATOR
operator|.
name|equals
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|Path
name|p
init|=
name|inPathPattern
operator|.
name|makeQualified
argument_list|(
name|uri
argument_list|,
literal|null
argument_list|)
decl_stmt|;
return|return
name|getFileStatus
argument_list|(
operator|new
name|Path
index|[]
block|{
name|p
block|}
argument_list|)
return|;
block|}
comment|// path has at least one component
name|String
index|[]
name|components
init|=
name|filename
operator|.
name|split
argument_list|(
name|Path
operator|.
name|SEPARATOR
argument_list|)
decl_stmt|;
comment|// Path is absolute, first component is "/" hence first component
comment|// is the uri root
name|parents
index|[
literal|0
index|]
operator|=
operator|new
name|Path
argument_list|(
operator|new
name|Path
argument_list|(
name|uri
argument_list|)
argument_list|,
operator|new
name|Path
argument_list|(
literal|"/"
argument_list|)
argument_list|)
expr_stmt|;
name|level
operator|=
literal|1
expr_stmt|;
comment|// glob the paths that match the parent path, ie. [0, components.length-1]
name|boolean
index|[]
name|hasGlob
init|=
operator|new
name|boolean
index|[]
block|{
literal|false
block|}
decl_stmt|;
name|Path
index|[]
name|relParentPaths
init|=
name|globPathsLevel
argument_list|(
name|parents
argument_list|,
name|components
argument_list|,
name|level
argument_list|,
name|hasGlob
argument_list|)
decl_stmt|;
name|FileStatus
index|[]
name|results
decl_stmt|;
if|if
condition|(
name|relParentPaths
operator|==
literal|null
operator|||
name|relParentPaths
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|results
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
comment|// fix the pathes to be abs
name|Path
index|[]
name|parentPaths
init|=
operator|new
name|Path
index|[
name|relParentPaths
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|relParentPaths
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|parentPaths
index|[
name|i
index|]
operator|=
name|relParentPaths
index|[
name|i
index|]
operator|.
name|makeQualified
argument_list|(
name|uri
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// Now work on the last component of the path
name|GlobFilter
name|fp
init|=
operator|new
name|GlobFilter
argument_list|(
name|components
index|[
name|components
operator|.
name|length
operator|-
literal|1
index|]
argument_list|,
name|filter
argument_list|)
decl_stmt|;
if|if
condition|(
name|fp
operator|.
name|hasPattern
argument_list|()
condition|)
block|{
comment|// last component has a pattern
comment|// list parent directories and then glob the results
try|try
block|{
name|results
operator|=
name|listStatus
argument_list|(
name|parentPaths
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|results
operator|=
literal|null
expr_stmt|;
block|}
name|hasGlob
index|[
literal|0
index|]
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// last component does not have a pattern
comment|// get all the path names
name|ArrayList
argument_list|<
name|Path
argument_list|>
name|filteredPaths
init|=
operator|new
name|ArrayList
argument_list|<
name|Path
argument_list|>
argument_list|(
name|parentPaths
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parentPaths
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|parentPaths
index|[
name|i
index|]
operator|=
operator|new
name|Path
argument_list|(
name|parentPaths
index|[
name|i
index|]
argument_list|,
name|components
index|[
name|components
operator|.
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|.
name|accept
argument_list|(
name|parentPaths
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|filteredPaths
operator|.
name|add
argument_list|(
name|parentPaths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|// get all their statuses
name|results
operator|=
name|getFileStatus
argument_list|(
name|filteredPaths
operator|.
name|toArray
argument_list|(
operator|new
name|Path
index|[
name|filteredPaths
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Decide if the pathPattern contains a glob or not
if|if
condition|(
name|results
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|hasGlob
index|[
literal|0
index|]
condition|)
block|{
name|results
operator|=
operator|new
name|FileStatus
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|results
operator|.
name|length
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|hasGlob
index|[
literal|0
index|]
condition|)
block|{
name|results
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|results
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|results
return|;
block|}
comment|/*      * For a path of N components, return a list of paths that match the      * components [<code>level</code>,<code>N-1</code>].      */
DECL|method|globPathsLevel (Path[] parents, String[] filePattern, int level, boolean[] hasGlob)
specifier|private
name|Path
index|[]
name|globPathsLevel
parameter_list|(
name|Path
index|[]
name|parents
parameter_list|,
name|String
index|[]
name|filePattern
parameter_list|,
name|int
name|level
parameter_list|,
name|boolean
index|[]
name|hasGlob
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileNotFoundException
throws|,
name|IOException
block|{
if|if
condition|(
name|level
operator|==
name|filePattern
operator|.
name|length
operator|-
literal|1
condition|)
block|{
return|return
name|parents
return|;
block|}
if|if
condition|(
name|parents
operator|==
literal|null
operator|||
name|parents
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|GlobFilter
name|fp
init|=
operator|new
name|GlobFilter
argument_list|(
name|filePattern
index|[
name|level
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|fp
operator|.
name|hasPattern
argument_list|()
condition|)
block|{
try|try
block|{
name|parents
operator|=
name|FileUtil
operator|.
name|stat2Paths
argument_list|(
name|listStatus
argument_list|(
name|parents
argument_list|,
name|fp
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
name|parents
operator|=
literal|null
expr_stmt|;
block|}
name|hasGlob
index|[
literal|0
index|]
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parents
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|parents
index|[
name|i
index|]
operator|=
operator|new
name|Path
argument_list|(
name|parents
index|[
name|i
index|]
argument_list|,
name|filePattern
index|[
name|level
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|globPathsLevel
argument_list|(
name|parents
argument_list|,
name|filePattern
argument_list|,
name|level
operator|+
literal|1
argument_list|,
name|hasGlob
argument_list|)
return|;
block|}
comment|/**      * Copy file from src to dest. See      * {@link #copy(Path, Path, boolean, boolean)}      */
DECL|method|copy (final Path src, final Path dst)
specifier|public
name|boolean
name|copy
parameter_list|(
specifier|final
name|Path
name|src
parameter_list|,
specifier|final
name|Path
name|dst
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileAlreadyExistsException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
return|return
name|copy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Copy from src to dst, optionally deleting src and overwriting dst.      * @param src      * @param dst      * @param deleteSource - delete src if true      * @param overwrite  overwrite dst if true; throw IOException if dst exists      *         and overwrite is false.      *      * @return true if copy is successful      *      * @throws AccessControlException If access is denied      * @throws FileAlreadyExistsException If<code>dst</code> already exists      * @throws FileNotFoundException If<code>src</code> does not exist      * @throws ParentNotDirectoryException If parent of<code>dst</code> is not      *           a directory      * @throws UnsupportedFileSystemException If file system for       *<code>src</code> or<code>dst</code> is not supported      * @throws IOException If an I/O error occurred      *       * Exceptions applicable to file systems accessed over RPC:      * @throws RpcClientException If an exception occurred in the RPC client      * @throws RpcServerException If an exception occurred in the RPC server      * @throws UnexpectedServerException If server implementation throws       *           undeclared exception to RPC server      *       * RuntimeExceptions:      * @throws InvalidPathException If path<code>dst</code> is invalid      */
DECL|method|copy (final Path src, final Path dst, boolean deleteSource, boolean overwrite)
specifier|public
name|boolean
name|copy
parameter_list|(
specifier|final
name|Path
name|src
parameter_list|,
specifier|final
name|Path
name|dst
parameter_list|,
name|boolean
name|deleteSource
parameter_list|,
name|boolean
name|overwrite
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|FileAlreadyExistsException
throws|,
name|FileNotFoundException
throws|,
name|ParentNotDirectoryException
throws|,
name|UnsupportedFileSystemException
throws|,
name|IOException
block|{
name|checkNotSchemeWithRelative
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|checkNotSchemeWithRelative
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|Path
name|qSrc
init|=
name|makeQualified
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|Path
name|qDst
init|=
name|makeQualified
argument_list|(
name|dst
argument_list|)
decl_stmt|;
name|checkDest
argument_list|(
name|qSrc
operator|.
name|getName
argument_list|()
argument_list|,
name|qDst
argument_list|,
name|overwrite
argument_list|)
expr_stmt|;
name|FileStatus
name|fs
init|=
name|FileContext
operator|.
name|this
operator|.
name|getFileStatus
argument_list|(
name|qSrc
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
name|checkDependencies
argument_list|(
name|qSrc
argument_list|,
name|qDst
argument_list|)
expr_stmt|;
name|mkdir
argument_list|(
name|qDst
argument_list|,
name|FsPermission
operator|.
name|getDirDefault
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|FileStatus
index|[]
name|contents
init|=
name|listStatus
argument_list|(
name|qSrc
argument_list|)
decl_stmt|;
for|for
control|(
name|FileStatus
name|content
range|:
name|contents
control|)
block|{
name|copy
argument_list|(
name|makeQualified
argument_list|(
name|content
operator|.
name|getPath
argument_list|()
argument_list|)
argument_list|,
name|makeQualified
argument_list|(
operator|new
name|Path
argument_list|(
name|qDst
argument_list|,
name|content
operator|.
name|getPath
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
argument_list|,
name|deleteSource
argument_list|,
name|overwrite
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|InputStream
name|in
init|=
literal|null
decl_stmt|;
name|OutputStream
name|out
init|=
literal|null
decl_stmt|;
try|try
block|{
name|in
operator|=
name|open
argument_list|(
name|qSrc
argument_list|)
expr_stmt|;
name|EnumSet
argument_list|<
name|CreateFlag
argument_list|>
name|createFlag
init|=
name|overwrite
condition|?
name|EnumSet
operator|.
name|of
argument_list|(
name|CreateFlag
operator|.
name|CREATE
argument_list|,
name|CreateFlag
operator|.
name|OVERWRITE
argument_list|)
else|:
name|EnumSet
operator|.
name|of
argument_list|(
name|CreateFlag
operator|.
name|CREATE
argument_list|)
decl_stmt|;
name|out
operator|=
name|create
argument_list|(
name|qDst
argument_list|,
name|createFlag
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|copyBytes
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|conf
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|in
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
if|if
condition|(
name|deleteSource
condition|)
block|{
return|return
name|delete
argument_list|(
name|qSrc
argument_list|,
literal|true
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
comment|/**    * Check if copying srcName to dst would overwrite an existing     * file or directory.    * @param srcName File or directory to be copied.    * @param dst Destination to copy srcName to.    * @param overwrite Whether it's ok to overwrite an existing file.     * @throws AccessControlException If access is denied.    * @throws IOException If dst is an existing directory, or dst is an     * existing file and the overwrite option is not passed.    */
DECL|method|checkDest (String srcName, Path dst, boolean overwrite)
specifier|private
name|void
name|checkDest
parameter_list|(
name|String
name|srcName
parameter_list|,
name|Path
name|dst
parameter_list|,
name|boolean
name|overwrite
parameter_list|)
throws|throws
name|AccessControlException
throws|,
name|IOException
block|{
try|try
block|{
name|FileStatus
name|dstFs
init|=
name|getFileStatus
argument_list|(
name|dst
argument_list|)
decl_stmt|;
if|if
condition|(
name|dstFs
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
if|if
condition|(
literal|null
operator|==
name|srcName
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Target "
operator|+
name|dst
operator|+
literal|" is a directory"
argument_list|)
throw|;
block|}
comment|// Recurse to check if dst/srcName exists.
name|checkDest
argument_list|(
literal|null
argument_list|,
operator|new
name|Path
argument_list|(
name|dst
argument_list|,
name|srcName
argument_list|)
argument_list|,
name|overwrite
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|overwrite
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Target "
operator|+
operator|new
name|Path
argument_list|(
name|dst
argument_list|,
name|srcName
argument_list|)
operator|+
literal|" already exists"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|// dst does not exist - OK to copy.
block|}
block|}
comment|//
comment|// If the destination is a subdirectory of the source, then
comment|// generate exception
comment|//
DECL|method|checkDependencies (Path qualSrc, Path qualDst)
specifier|private
specifier|static
name|void
name|checkDependencies
parameter_list|(
name|Path
name|qualSrc
parameter_list|,
name|Path
name|qualDst
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|isSameFS
argument_list|(
name|qualSrc
argument_list|,
name|qualDst
argument_list|)
condition|)
block|{
name|String
name|srcq
init|=
name|qualSrc
operator|.
name|toString
argument_list|()
operator|+
name|Path
operator|.
name|SEPARATOR
decl_stmt|;
name|String
name|dstq
init|=
name|qualDst
operator|.
name|toString
argument_list|()
operator|+
name|Path
operator|.
name|SEPARATOR
decl_stmt|;
if|if
condition|(
name|dstq
operator|.
name|startsWith
argument_list|(
name|srcq
argument_list|)
condition|)
block|{
if|if
condition|(
name|srcq
operator|.
name|length
argument_list|()
operator|==
name|dstq
operator|.
name|length
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot copy "
operator|+
name|qualSrc
operator|+
literal|" to itself."
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot copy "
operator|+
name|qualSrc
operator|+
literal|" to its subdirectory "
operator|+
name|qualDst
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**    * Are qualSrc and qualDst of the same file system?    * @param qualPath1 - fully qualified path    * @param qualPath2 - fully qualified path    * @return    */
DECL|method|isSameFS (Path qualPath1, Path qualPath2)
specifier|private
specifier|static
name|boolean
name|isSameFS
parameter_list|(
name|Path
name|qualPath1
parameter_list|,
name|Path
name|qualPath2
parameter_list|)
block|{
name|URI
name|srcUri
init|=
name|qualPath1
operator|.
name|toUri
argument_list|()
decl_stmt|;
name|URI
name|dstUri
init|=
name|qualPath2
operator|.
name|toUri
argument_list|()
decl_stmt|;
return|return
operator|(
name|srcUri
operator|.
name|getScheme
argument_list|()
operator|.
name|equals
argument_list|(
name|dstUri
operator|.
name|getScheme
argument_list|()
argument_list|)
operator|&&
operator|!
operator|(
name|srcUri
operator|.
name|getAuthority
argument_list|()
operator|!=
literal|null
operator|&&
name|dstUri
operator|.
name|getAuthority
argument_list|()
operator|!=
literal|null
operator|&&
name|srcUri
operator|.
name|getAuthority
argument_list|()
operator|.
name|equals
argument_list|(
name|dstUri
operator|.
name|getAuthority
argument_list|()
argument_list|)
operator|)
operator|)
return|;
block|}
comment|/**    * Deletes all the paths in deleteOnExit on JVM shutdown.    */
DECL|class|FileContextFinalizer
specifier|static
class|class
name|FileContextFinalizer
implements|implements
name|Runnable
block|{
annotation|@
name|Override
DECL|method|run ()
specifier|public
specifier|synchronized
name|void
name|run
parameter_list|()
block|{
name|processDeleteOnExit
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**    * Resolves all symbolic links in the specified path.    * Returns the new path object.    */
DECL|method|resolve (final Path f)
specifier|protected
name|Path
name|resolve
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|FileNotFoundException
throws|,
name|UnresolvedLinkException
throws|,
name|AccessControlException
throws|,
name|IOException
block|{
return|return
operator|new
name|FSLinkResolver
argument_list|<
name|Path
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Path
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
return|return
name|fs
operator|.
name|resolvePath
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|f
argument_list|)
return|;
block|}
comment|/**    * Resolves all symbolic links in the specified path leading up     * to, but not including the final path component.    * @param f path to resolve    * @return the new path object.    */
DECL|method|resolveIntermediate (final Path f)
specifier|protected
name|Path
name|resolveIntermediate
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|FSLinkResolver
argument_list|<
name|FileStatus
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileStatus
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
return|return
name|fs
operator|.
name|getFileLinkStatus
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|f
argument_list|)
operator|.
name|getPath
argument_list|()
return|;
block|}
comment|/**    * Returns the list of AbstractFileSystems accessed in the path. The list may    * contain more than one AbstractFileSystems objects in case of symlinks.    *     * @param f    *          Path which needs to be resolved    * @return List of AbstractFileSystems accessed in the path    * @throws IOException    */
DECL|method|resolveAbstractFileSystems (final Path f)
name|Set
argument_list|<
name|AbstractFileSystem
argument_list|>
name|resolveAbstractFileSystems
parameter_list|(
specifier|final
name|Path
name|f
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|absF
init|=
name|fixRelativePart
argument_list|(
name|f
argument_list|)
decl_stmt|;
specifier|final
name|HashSet
argument_list|<
name|AbstractFileSystem
argument_list|>
name|result
init|=
operator|new
name|HashSet
argument_list|<
name|AbstractFileSystem
argument_list|>
argument_list|()
decl_stmt|;
operator|new
name|FSLinkResolver
argument_list|<
name|Void
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Void
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
block|{
name|result
operator|.
name|add
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|fs
operator|.
name|getFileStatus
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
operator|.
name|resolve
argument_list|(
name|this
argument_list|,
name|absF
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**    * Class used to perform an operation on and resolve symlinks in a    * path. The operation may potentially span multiple file systems.      */
DECL|class|FSLinkResolver
specifier|protected
specifier|static
specifier|abstract
class|class
name|FSLinkResolver
parameter_list|<
name|T
parameter_list|>
block|{
comment|// The maximum number of symbolic link components in a path
DECL|field|MAX_PATH_LINKS
specifier|private
specifier|static
specifier|final
name|int
name|MAX_PATH_LINKS
init|=
literal|32
decl_stmt|;
comment|/**      * Generic helper function overridden on instantiation to perform a       * specific operation on the given file system using the given path      * which may result in an UnresolvedLinkException.       * @param fs AbstractFileSystem to perform the operation on.      * @param p Path given the file system.      * @return Generic type determined by the specific implementation.      * @throws UnresolvedLinkException If symbolic link<code>path</code> could       *           not be resolved      * @throws IOException an I/O error occured      */
DECL|method|next (final AbstractFileSystem fs, final Path p)
specifier|public
specifier|abstract
name|T
name|next
parameter_list|(
specifier|final
name|AbstractFileSystem
name|fs
parameter_list|,
specifier|final
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
throws|,
name|UnresolvedLinkException
function_decl|;
comment|/**      * Performs the operation specified by the next function, calling it      * repeatedly until all symlinks in the given path are resolved.      * @param fc FileContext used to access file systems.      * @param p The path to resolve symlinks in.      * @return Generic type determined by the implementation of next.      * @throws IOException      */
DECL|method|resolve (final FileContext fc, Path p)
specifier|public
name|T
name|resolve
parameter_list|(
specifier|final
name|FileContext
name|fc
parameter_list|,
name|Path
name|p
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|T
name|in
init|=
literal|null
decl_stmt|;
name|Path
name|first
init|=
name|p
decl_stmt|;
comment|// NB: More than one AbstractFileSystem can match a scheme, eg
comment|// "file" resolves to LocalFs but could have come by RawLocalFs.
name|AbstractFileSystem
name|fs
init|=
name|fc
operator|.
name|getFSofPath
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|// Loop until all symlinks are resolved or the limit is reached
for|for
control|(
name|boolean
name|isLink
init|=
literal|true
init|;
name|isLink
condition|;
control|)
block|{
try|try
block|{
name|in
operator|=
name|next
argument_list|(
name|fs
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|isLink
operator|=
literal|false
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnresolvedLinkException
name|e
parameter_list|)
block|{
if|if
condition|(
name|count
operator|++
operator|>
name|MAX_PATH_LINKS
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Possible cyclic loop while "
operator|+
literal|"following symbolic link "
operator|+
name|first
argument_list|)
throw|;
block|}
comment|// Resolve the first unresolved path component
name|p
operator|=
name|qualifySymlinkTarget
argument_list|(
name|fs
argument_list|,
name|p
argument_list|,
name|fs
operator|.
name|getLinkTarget
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|=
name|fc
operator|.
name|getFSofPath
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|in
return|;
block|}
block|}
comment|/**    * Get the statistics for a particular file system    *     * @param uri    *          the uri to lookup the statistics. Only scheme and authority part    *          of the uri are used as the key to store and lookup.    * @return a statistics object    */
DECL|method|getStatistics (URI uri)
specifier|public
specifier|static
name|Statistics
name|getStatistics
parameter_list|(
name|URI
name|uri
parameter_list|)
block|{
return|return
name|AbstractFileSystem
operator|.
name|getStatistics
argument_list|(
name|uri
argument_list|)
return|;
block|}
comment|/**    * Clears all the statistics stored in AbstractFileSystem, for all the file    * systems.    */
DECL|method|clearStatistics ()
specifier|public
specifier|static
name|void
name|clearStatistics
parameter_list|()
block|{
name|AbstractFileSystem
operator|.
name|clearStatistics
argument_list|()
expr_stmt|;
block|}
comment|/**    * Prints the statistics to standard output. File System is identified by the    * scheme and authority.    */
DECL|method|printStatistics ()
specifier|public
specifier|static
name|void
name|printStatistics
parameter_list|()
block|{
name|AbstractFileSystem
operator|.
name|printStatistics
argument_list|()
expr_stmt|;
block|}
comment|/**    * @return Map of uri and statistics for each filesystem instantiated. The uri    *         consists of scheme and authority for the filesystem.    */
DECL|method|getAllStatistics ()
specifier|public
specifier|static
name|Map
argument_list|<
name|URI
argument_list|,
name|Statistics
argument_list|>
name|getAllStatistics
parameter_list|()
block|{
return|return
name|AbstractFileSystem
operator|.
name|getAllStatistics
argument_list|()
return|;
block|}
comment|/**    * Get delegation tokens for the file systems accessed for a given    * path.    * @param p Path for which delegations tokens are requested.    * @param renewer the account name that is allowed to renew the token.    * @return List of delegation tokens.    * @throws IOException    */
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|,
literal|"MapReduce"
block|}
argument_list|)
DECL|method|getDelegationTokens ( Path p, String renewer)
specifier|public
name|List
argument_list|<
name|Token
argument_list|<
name|?
argument_list|>
argument_list|>
name|getDelegationTokens
parameter_list|(
name|Path
name|p
parameter_list|,
name|String
name|renewer
parameter_list|)
throws|throws
name|IOException
block|{
name|Set
argument_list|<
name|AbstractFileSystem
argument_list|>
name|afsSet
init|=
name|resolveAbstractFileSystems
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Token
argument_list|<
name|?
argument_list|>
argument_list|>
name|tokenList
init|=
operator|new
name|ArrayList
argument_list|<
name|Token
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|AbstractFileSystem
name|afs
range|:
name|afsSet
control|)
block|{
name|List
argument_list|<
name|Token
argument_list|<
name|?
argument_list|>
argument_list|>
name|afsTokens
init|=
name|afs
operator|.
name|getDelegationTokens
argument_list|(
name|renewer
argument_list|)
decl_stmt|;
name|tokenList
operator|.
name|addAll
argument_list|(
name|afsTokens
argument_list|)
expr_stmt|;
block|}
return|return
name|tokenList
return|;
block|}
block|}
end_class

end_unit

