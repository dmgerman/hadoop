begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  Licensed to the Apache Software Foundation (ASF) under one or more  *  contributor license agreements.  See the NOTICE file distributed with  *  this work for additional information regarding copyright ownership.  *  The ASF licenses this file to You under the Apache License, Version 2.0  *  (the "License"); you may not use this file except in compliance with  *  the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  *  */
end_comment

begin_comment
comment|/*  * This package is based on the work done by Keiron Liddle, Aftex Software  *<keiron@aftexsw.com> to whom the Ant project is very grateful for his  * great code.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.io.compress.bzip2
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|bzip2
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|compress
operator|.
name|SplittableCompressionCodec
operator|.
name|READ_MODE
import|;
end_import

begin_comment
comment|/**  * An input stream that decompresses from the BZip2 format (without the file  * header chars) to be read as any other stream.  *  *<p>  * The decompression requires large amounts of memory. Thus you should call the  * {@link #close() close()} method as soon as possible, to force  *<tt>CBZip2InputStream</tt> to release the allocated memory. See  * {@link CBZip2OutputStream CBZip2OutputStream} for information about memory  * usage.  *</p>  *  *<p>  *<tt>CBZip2InputStream</tt> reads bytes from the compressed source stream via  * the single byte {@link java.io.InputStream#read() read()} method exclusively.  * Thus you should consider to use a buffered source stream.  *</p>  *  *<p>  * This Ant code was enhanced so that it can de-compress blocks of bzip2 data.  * Current position in the stream is an important statistic for Hadoop. For  * example in LineRecordReader, we solely depend on the current position in the  * stream to know about the progess. The notion of position becomes complicated  * for compressed files. The Hadoop splitting is done in terms of compressed  * file. But a compressed file deflates to a large amount of data. So we have  * handled this problem in the following way.  *  * On object creation time, we find the next block start delimiter. Once such a  * marker is found, the stream stops there (we discard any read compressed data  * in this process) and the position is updated (i.e. the caller of this class  * will find out the stream location). At this point we are ready for actual  * reading (i.e. decompression) of data.  *  * The subsequent read calls give out data. The position is updated when the  * caller of this class has read off the current block + 1 bytes. In between the  * block reading, position is not updated. (We can only update the postion on  * block boundaries).  *</p>  *  *<p>  * Instances of this class are not threadsafe.  *</p>  */
end_comment

begin_class
DECL|class|CBZip2InputStream
specifier|public
class|class
name|CBZip2InputStream
extends|extends
name|InputStream
implements|implements
name|BZip2Constants
block|{
DECL|field|BLOCK_DELIMITER
specifier|public
specifier|static
specifier|final
name|long
name|BLOCK_DELIMITER
init|=
literal|0X314159265359L
decl_stmt|;
comment|// start of block
DECL|field|EOS_DELIMITER
specifier|public
specifier|static
specifier|final
name|long
name|EOS_DELIMITER
init|=
literal|0X177245385090L
decl_stmt|;
comment|// end of bzip2 stream
DECL|field|DELIMITER_BIT_LENGTH
specifier|private
specifier|static
specifier|final
name|int
name|DELIMITER_BIT_LENGTH
init|=
literal|48
decl_stmt|;
DECL|field|readMode
name|READ_MODE
name|readMode
init|=
name|READ_MODE
operator|.
name|CONTINUOUS
decl_stmt|;
comment|// The variable records the current advertised position of the stream.
DECL|field|reportedBytesReadFromCompressedStream
specifier|private
name|long
name|reportedBytesReadFromCompressedStream
init|=
literal|0L
decl_stmt|;
comment|// The following variable keep record of compressed bytes read.
DECL|field|bytesReadFromCompressedStream
specifier|private
name|long
name|bytesReadFromCompressedStream
init|=
literal|0L
decl_stmt|;
DECL|field|lazyInitialization
specifier|private
name|boolean
name|lazyInitialization
init|=
literal|false
decl_stmt|;
DECL|field|array
specifier|private
name|byte
name|array
index|[]
init|=
operator|new
name|byte
index|[
literal|1
index|]
decl_stmt|;
comment|/**   * Index of the last char in the block, so the block size == last + 1.   */
DECL|field|last
specifier|private
name|int
name|last
decl_stmt|;
comment|/**   * Index in zptr[] of original string after sorting.   */
DECL|field|origPtr
specifier|private
name|int
name|origPtr
decl_stmt|;
comment|/**   * always: in the range 0 .. 9. The current block size is 100000 * this   * number.   */
DECL|field|blockSize100k
specifier|private
name|int
name|blockSize100k
decl_stmt|;
DECL|field|blockRandomised
specifier|private
name|boolean
name|blockRandomised
init|=
literal|false
decl_stmt|;
DECL|field|bsBuff
specifier|private
name|long
name|bsBuff
decl_stmt|;
DECL|field|bsLive
specifier|private
name|long
name|bsLive
decl_stmt|;
DECL|field|crc
specifier|private
specifier|final
name|CRC
name|crc
init|=
operator|new
name|CRC
argument_list|()
decl_stmt|;
DECL|field|nInUse
specifier|private
name|int
name|nInUse
decl_stmt|;
DECL|field|in
specifier|private
name|BufferedInputStream
name|in
decl_stmt|;
DECL|field|currentChar
specifier|private
name|int
name|currentChar
init|=
operator|-
literal|1
decl_stmt|;
comment|/**    * A state machine to keep track of current state of the de-coder    *    */
DECL|enum|STATE
specifier|public
enum|enum
name|STATE
block|{
DECL|enumConstant|EOF
DECL|enumConstant|START_BLOCK_STATE
DECL|enumConstant|RAND_PART_A_STATE
DECL|enumConstant|RAND_PART_B_STATE
DECL|enumConstant|RAND_PART_C_STATE
DECL|enumConstant|NO_RAND_PART_A_STATE
DECL|enumConstant|NO_RAND_PART_B_STATE
DECL|enumConstant|NO_RAND_PART_C_STATE
DECL|enumConstant|NO_PROCESS_STATE
name|EOF
block|,
name|START_BLOCK_STATE
block|,
name|RAND_PART_A_STATE
block|,
name|RAND_PART_B_STATE
block|,
name|RAND_PART_C_STATE
block|,
name|NO_RAND_PART_A_STATE
block|,
name|NO_RAND_PART_B_STATE
block|,
name|NO_RAND_PART_C_STATE
block|,
name|NO_PROCESS_STATE
block|}
empty_stmt|;
DECL|field|currentState
specifier|private
name|STATE
name|currentState
init|=
name|STATE
operator|.
name|START_BLOCK_STATE
decl_stmt|;
DECL|field|storedBlockCRC
DECL|field|storedCombinedCRC
specifier|private
name|int
name|storedBlockCRC
decl_stmt|,
name|storedCombinedCRC
decl_stmt|;
DECL|field|computedBlockCRC
DECL|field|computedCombinedCRC
specifier|private
name|int
name|computedBlockCRC
decl_stmt|,
name|computedCombinedCRC
decl_stmt|;
DECL|field|skipResult
specifier|private
name|boolean
name|skipResult
init|=
literal|false
decl_stmt|;
comment|// used by skipToNextMarker
DECL|field|skipDecompression
specifier|private
name|boolean
name|skipDecompression
init|=
literal|false
decl_stmt|;
comment|// Variables used by setup* methods exclusively
DECL|field|su_count
specifier|private
name|int
name|su_count
decl_stmt|;
DECL|field|su_ch2
specifier|private
name|int
name|su_ch2
decl_stmt|;
DECL|field|su_chPrev
specifier|private
name|int
name|su_chPrev
decl_stmt|;
DECL|field|su_i2
specifier|private
name|int
name|su_i2
decl_stmt|;
DECL|field|su_j2
specifier|private
name|int
name|su_j2
decl_stmt|;
DECL|field|su_rNToGo
specifier|private
name|int
name|su_rNToGo
decl_stmt|;
DECL|field|su_rTPos
specifier|private
name|int
name|su_rTPos
decl_stmt|;
DECL|field|su_tPos
specifier|private
name|int
name|su_tPos
decl_stmt|;
DECL|field|su_z
specifier|private
name|char
name|su_z
decl_stmt|;
comment|/**   * All memory intensive stuff. This field is initialized by initBlock().   */
DECL|field|data
specifier|private
name|CBZip2InputStream
operator|.
name|Data
name|data
decl_stmt|;
comment|/**   * This method reports the processed bytes so far. Please note that this   * statistic is only updated on block boundaries and only when the stream is   * initiated in BYBLOCK mode.   */
DECL|method|getProcessedByteCount ()
specifier|public
name|long
name|getProcessedByteCount
parameter_list|()
block|{
return|return
name|reportedBytesReadFromCompressedStream
return|;
block|}
comment|/**    * This method keeps track of raw processed compressed    * bytes.    *    * @param count count is the number of bytes to be    *           added to raw processed bytes    */
DECL|method|updateProcessedByteCount (int count)
specifier|protected
name|void
name|updateProcessedByteCount
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|this
operator|.
name|bytesReadFromCompressedStream
operator|+=
name|count
expr_stmt|;
block|}
comment|/**    * This method is called by the client of this    * class in case there are any corrections in    * the stream position.  One common example is    * when client of this code removes starting BZ    * characters from the compressed stream.    *    * @param count count bytes are added to the reported bytes    *    */
DECL|method|updateReportedByteCount (int count)
specifier|public
name|void
name|updateReportedByteCount
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|this
operator|.
name|reportedBytesReadFromCompressedStream
operator|+=
name|count
expr_stmt|;
name|this
operator|.
name|updateProcessedByteCount
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
comment|/**   * This method reads a Byte from the compressed stream. Whenever we need to   * read from the underlying compressed stream, this method should be called   * instead of directly calling the read method of the underlying compressed   * stream. This method does important record keeping to have the statistic   * that how many bytes have been read off the compressed stream.   */
DECL|method|readAByte (InputStream inStream)
specifier|private
name|int
name|readAByte
parameter_list|(
name|InputStream
name|inStream
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|read
init|=
name|inStream
operator|.
name|read
argument_list|()
decl_stmt|;
if|if
condition|(
name|read
operator|>=
literal|0
condition|)
block|{
name|this
operator|.
name|updateProcessedByteCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|read
return|;
block|}
comment|/**   * This method tries to find the marker (passed to it as the first parameter)   * in the stream.  It can find bit patterns of length<= 63 bits.  Specifically   * this method is used in CBZip2InputStream to find the end of block (EOB)   * delimiter in the stream, starting from the current position of the stream.   * If marker is found, the stream position will be right after marker at the   * end of this call.   *   * @param marker  The bit pattern to be found in the stream   * @param markerBitLength  No of bits in the marker   *   * @throws IOException   * @throws IllegalArgumentException  if marketBitLength is greater than 63   */
DECL|method|skipToNextMarker (long marker, int markerBitLength)
specifier|public
name|boolean
name|skipToNextMarker
parameter_list|(
name|long
name|marker
parameter_list|,
name|int
name|markerBitLength
parameter_list|)
throws|throws
name|IOException
throws|,
name|IllegalArgumentException
block|{
try|try
block|{
if|if
condition|(
name|markerBitLength
operator|>
literal|63
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"skipToNextMarker can not find patterns greater than 63 bits"
argument_list|)
throw|;
block|}
comment|// pick next marketBitLength bits in the stream
name|long
name|bytes
init|=
literal|0
decl_stmt|;
name|bytes
operator|=
name|this
operator|.
name|bsR
argument_list|(
name|markerBitLength
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|false
return|;
block|}
while|while
condition|(
literal|true
condition|)
block|{
if|if
condition|(
name|bytes
operator|==
name|marker
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
name|bytes
operator|=
name|bytes
operator|<<
literal|1
expr_stmt|;
name|bytes
operator|=
name|bytes
operator|&
operator|(
operator|(
literal|1L
operator|<<
name|markerBitLength
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|int
name|oneBit
init|=
operator|(
name|int
operator|)
name|this
operator|.
name|bsR
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|oneBit
operator|!=
operator|-
literal|1
condition|)
block|{
name|bytes
operator|=
name|bytes
operator||
name|oneBit
expr_stmt|;
block|}
else|else
return|return
literal|false
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
DECL|method|reportCRCError ()
specifier|protected
name|void
name|reportCRCError
parameter_list|()
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"crc error"
argument_list|)
throw|;
block|}
DECL|method|makeMaps ()
specifier|private
name|void
name|makeMaps
parameter_list|()
block|{
specifier|final
name|boolean
index|[]
name|inUse
init|=
name|this
operator|.
name|data
operator|.
name|inUse
decl_stmt|;
specifier|final
name|byte
index|[]
name|seqToUnseq
init|=
name|this
operator|.
name|data
operator|.
name|seqToUnseq
decl_stmt|;
name|int
name|nInUseShadow
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inUse
index|[
name|i
index|]
condition|)
name|seqToUnseq
index|[
name|nInUseShadow
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|i
expr_stmt|;
block|}
name|this
operator|.
name|nInUse
operator|=
name|nInUseShadow
expr_stmt|;
block|}
comment|/**   * Constructs a new CBZip2InputStream which decompresses bytes read from the   * specified stream.   *   *<p>   * Although BZip2 headers are marked with the magic<tt>"Bz"</tt> this   * constructor expects the next byte in the stream to be the first one after   * the magic. Thus callers have to skip the first two bytes. Otherwise this   * constructor will throw an exception.   *</p>   *   * @throws IOException   *             if the stream content is malformed or an I/O error occurs.   * @throws NullPointerException   *             if<tt>in == null</tt>   */
DECL|method|CBZip2InputStream (final InputStream in, READ_MODE readMode)
specifier|public
name|CBZip2InputStream
parameter_list|(
specifier|final
name|InputStream
name|in
parameter_list|,
name|READ_MODE
name|readMode
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|in
argument_list|,
name|readMode
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|CBZip2InputStream (final InputStream in, READ_MODE readMode, boolean skipDecompression)
specifier|private
name|CBZip2InputStream
parameter_list|(
specifier|final
name|InputStream
name|in
parameter_list|,
name|READ_MODE
name|readMode
parameter_list|,
name|boolean
name|skipDecompression
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|()
expr_stmt|;
name|int
name|blockSize
init|=
literal|0X39
decl_stmt|;
comment|// i.e 9
name|this
operator|.
name|blockSize100k
operator|=
name|blockSize
operator|-
literal|'0'
expr_stmt|;
name|this
operator|.
name|in
operator|=
operator|new
name|BufferedInputStream
argument_list|(
name|in
argument_list|,
literal|1024
operator|*
literal|9
argument_list|)
expr_stmt|;
comment|//>1 MB buffer
name|this
operator|.
name|readMode
operator|=
name|readMode
expr_stmt|;
name|this
operator|.
name|skipDecompression
operator|=
name|skipDecompression
expr_stmt|;
if|if
condition|(
name|readMode
operator|==
name|READ_MODE
operator|.
name|CONTINUOUS
condition|)
block|{
name|currentState
operator|=
name|STATE
operator|.
name|START_BLOCK_STATE
expr_stmt|;
name|lazyInitialization
operator|=
operator|(
name|in
operator|.
name|available
argument_list|()
operator|==
literal|0
operator|)
condition|?
literal|true
else|:
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|lazyInitialization
condition|)
block|{
name|init
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|readMode
operator|==
name|READ_MODE
operator|.
name|BYBLOCK
condition|)
block|{
name|this
operator|.
name|currentState
operator|=
name|STATE
operator|.
name|NO_PROCESS_STATE
expr_stmt|;
name|skipResult
operator|=
name|this
operator|.
name|skipToNextMarker
argument_list|(
name|CBZip2InputStream
operator|.
name|BLOCK_DELIMITER
argument_list|,
name|DELIMITER_BIT_LENGTH
argument_list|)
expr_stmt|;
name|this
operator|.
name|reportedBytesReadFromCompressedStream
operator|=
name|this
operator|.
name|bytesReadFromCompressedStream
expr_stmt|;
if|if
condition|(
operator|!
name|skipDecompression
condition|)
block|{
name|changeStateToProcessABlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Returns the number of bytes between the current stream position    * and the immediate next BZip2 block marker.    *    * @param in    *             The InputStream    *    * @return long Number of bytes between current stream position and the    * next BZip2 block start marker.  * @throws IOException    *    */
DECL|method|numberOfBytesTillNextMarker (final InputStream in)
specifier|public
specifier|static
name|long
name|numberOfBytesTillNextMarker
parameter_list|(
specifier|final
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|CBZip2InputStream
name|anObject
init|=
operator|new
name|CBZip2InputStream
argument_list|(
name|in
argument_list|,
name|READ_MODE
operator|.
name|BYBLOCK
argument_list|,
literal|true
argument_list|)
decl_stmt|;
return|return
name|anObject
operator|.
name|getProcessedByteCount
argument_list|()
return|;
block|}
DECL|method|CBZip2InputStream (final InputStream in)
specifier|public
name|CBZip2InputStream
parameter_list|(
specifier|final
name|InputStream
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|this
argument_list|(
name|in
argument_list|,
name|READ_MODE
operator|.
name|CONTINUOUS
argument_list|)
expr_stmt|;
block|}
DECL|method|changeStateToProcessABlock ()
specifier|private
name|void
name|changeStateToProcessABlock
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|skipResult
operator|==
literal|true
condition|)
block|{
name|initBlock
argument_list|()
expr_stmt|;
name|setupBlock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|currentState
operator|=
name|STATE
operator|.
name|EOF
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|read ()
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|in
operator|!=
literal|null
condition|)
block|{
name|int
name|result
init|=
name|this
operator|.
name|read
argument_list|(
name|array
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|value
init|=
literal|0XFF
operator|&
name|array
index|[
literal|0
index|]
decl_stmt|;
return|return
operator|(
name|result
operator|>
literal|0
condition|?
name|value
else|:
name|result
operator|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"stream closed"
argument_list|)
throw|;
block|}
block|}
comment|/**    * In CONTINOUS reading mode, this read method starts from the    * start of the compressed stream and end at the end of file by    * emitting un-compressed data.  In this mode stream positioning    * is not announced and should be ignored.    *    * In BYBLOCK reading mode, this read method informs about the end    * of a BZip2 block by returning EOB.  At this event, the compressed    * stream position is also announced.  This announcement tells that    * how much of the compressed stream has been de-compressed and read    * out of this class.  In between EOB events, the stream position is    * not updated.    *    *    * @throws IOException    *             if the stream content is malformed or an I/O error occurs.    *    * @return int The return value greater than 0 are the bytes read.  A value    * of -1 means end of stream while -2 represents end of block    */
annotation|@
name|Override
DECL|method|read (final byte[] dest, final int offs, final int len)
specifier|public
name|int
name|read
parameter_list|(
specifier|final
name|byte
index|[]
name|dest
parameter_list|,
specifier|final
name|int
name|offs
parameter_list|,
specifier|final
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|offs
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"offs("
operator|+
name|offs
operator|+
literal|")< 0."
argument_list|)
throw|;
block|}
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"len("
operator|+
name|len
operator|+
literal|")< 0."
argument_list|)
throw|;
block|}
if|if
condition|(
name|offs
operator|+
name|len
operator|>
name|dest
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"offs("
operator|+
name|offs
operator|+
literal|") + len("
operator|+
name|len
operator|+
literal|")> dest.length("
operator|+
name|dest
operator|.
name|length
operator|+
literal|")."
argument_list|)
throw|;
block|}
if|if
condition|(
name|this
operator|.
name|in
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"stream closed"
argument_list|)
throw|;
block|}
if|if
condition|(
name|lazyInitialization
condition|)
block|{
name|this
operator|.
name|init
argument_list|()
expr_stmt|;
name|this
operator|.
name|lazyInitialization
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|skipDecompression
condition|)
block|{
name|changeStateToProcessABlock
argument_list|()
expr_stmt|;
name|skipDecompression
operator|=
literal|false
expr_stmt|;
block|}
specifier|final
name|int
name|hi
init|=
name|offs
operator|+
name|len
decl_stmt|;
name|int
name|destOffs
init|=
name|offs
decl_stmt|;
name|int
name|b
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
operator|(
operator|(
name|destOffs
operator|<
name|hi
operator|)
operator|&&
operator|(
operator|(
name|b
operator|=
name|read0
argument_list|()
operator|)
operator|)
operator|>=
literal|0
operator|)
condition|;
control|)
block|{
name|dest
index|[
name|destOffs
operator|++
index|]
operator|=
operator|(
name|byte
operator|)
name|b
expr_stmt|;
block|}
name|int
name|result
init|=
name|destOffs
operator|-
name|offs
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
comment|//report 'end of block' or 'end of stream'
name|result
operator|=
name|b
expr_stmt|;
name|skipResult
operator|=
name|this
operator|.
name|skipToNextMarker
argument_list|(
name|CBZip2InputStream
operator|.
name|BLOCK_DELIMITER
argument_list|,
name|DELIMITER_BIT_LENGTH
argument_list|)
expr_stmt|;
comment|//Exactly when we are about to start a new block, we advertise the stream position.
name|this
operator|.
name|reportedBytesReadFromCompressedStream
operator|=
name|this
operator|.
name|bytesReadFromCompressedStream
expr_stmt|;
name|changeStateToProcessABlock
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|read0 ()
specifier|private
name|int
name|read0
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|int
name|retChar
init|=
name|this
operator|.
name|currentChar
decl_stmt|;
switch|switch
condition|(
name|this
operator|.
name|currentState
condition|)
block|{
case|case
name|EOF
case|:
return|return
name|END_OF_STREAM
return|;
comment|// return -1
case|case
name|NO_PROCESS_STATE
case|:
return|return
name|END_OF_BLOCK
return|;
comment|// return -2
case|case
name|START_BLOCK_STATE
case|:
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
case|case
name|RAND_PART_A_STATE
case|:
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
case|case
name|RAND_PART_B_STATE
case|:
name|setupRandPartB
argument_list|()
expr_stmt|;
break|break;
case|case
name|RAND_PART_C_STATE
case|:
name|setupRandPartC
argument_list|()
expr_stmt|;
break|break;
case|case
name|NO_RAND_PART_A_STATE
case|:
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
case|case
name|NO_RAND_PART_B_STATE
case|:
name|setupNoRandPartB
argument_list|()
expr_stmt|;
break|break;
case|case
name|NO_RAND_PART_C_STATE
case|:
name|setupNoRandPartC
argument_list|()
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
return|return
name|retChar
return|;
block|}
DECL|method|init ()
specifier|private
name|void
name|init
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|magic2
init|=
name|this
operator|.
name|readAByte
argument_list|(
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
name|magic2
operator|!=
literal|'h'
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stream is not BZip2 formatted: expected 'h'"
operator|+
literal|" as first byte but got '"
operator|+
operator|(
name|char
operator|)
name|magic2
operator|+
literal|"'"
argument_list|)
throw|;
block|}
name|int
name|blockSize
init|=
name|this
operator|.
name|readAByte
argument_list|(
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|blockSize
operator|<
literal|'1'
operator|)
operator|||
operator|(
name|blockSize
operator|>
literal|'9'
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Stream is not BZip2 formatted: illegal "
operator|+
literal|"blocksize "
operator|+
operator|(
name|char
operator|)
name|blockSize
argument_list|)
throw|;
block|}
name|this
operator|.
name|blockSize100k
operator|=
name|blockSize
operator|-
literal|'0'
expr_stmt|;
name|initBlock
argument_list|()
expr_stmt|;
name|setupBlock
argument_list|()
expr_stmt|;
block|}
DECL|method|initBlock ()
specifier|private
name|void
name|initBlock
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|readMode
operator|==
name|READ_MODE
operator|.
name|BYBLOCK
condition|)
block|{
comment|// this.checkBlockIntegrity();
name|this
operator|.
name|storedBlockCRC
operator|=
name|bsGetInt
argument_list|()
expr_stmt|;
name|this
operator|.
name|blockRandomised
operator|=
name|bsR
argument_list|(
literal|1
argument_list|)
operator|==
literal|1
expr_stmt|;
comment|/**       * Allocate data here instead in constructor, so we do not allocate       * it if the input file is empty.       */
if|if
condition|(
name|this
operator|.
name|data
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|data
operator|=
operator|new
name|Data
argument_list|(
name|this
operator|.
name|blockSize100k
argument_list|)
expr_stmt|;
block|}
comment|// currBlockNo++;
name|getAndMoveToFrontDecode
argument_list|()
expr_stmt|;
name|this
operator|.
name|crc
operator|.
name|initialiseCRC
argument_list|()
expr_stmt|;
name|this
operator|.
name|currentState
operator|=
name|STATE
operator|.
name|START_BLOCK_STATE
expr_stmt|;
return|return;
block|}
name|char
name|magic0
init|=
name|bsGetUByte
argument_list|()
decl_stmt|;
name|char
name|magic1
init|=
name|bsGetUByte
argument_list|()
decl_stmt|;
name|char
name|magic2
init|=
name|bsGetUByte
argument_list|()
decl_stmt|;
name|char
name|magic3
init|=
name|bsGetUByte
argument_list|()
decl_stmt|;
name|char
name|magic4
init|=
name|bsGetUByte
argument_list|()
decl_stmt|;
name|char
name|magic5
init|=
name|bsGetUByte
argument_list|()
decl_stmt|;
if|if
condition|(
name|magic0
operator|==
literal|0x17
operator|&&
name|magic1
operator|==
literal|0x72
operator|&&
name|magic2
operator|==
literal|0x45
operator|&&
name|magic3
operator|==
literal|0x38
operator|&&
name|magic4
operator|==
literal|0x50
operator|&&
name|magic5
operator|==
literal|0x90
condition|)
block|{
name|complete
argument_list|()
expr_stmt|;
comment|// end of file
block|}
elseif|else
if|if
condition|(
name|magic0
operator|!=
literal|0x31
operator|||
comment|// '1'
name|magic1
operator|!=
literal|0x41
operator|||
comment|// ')'
name|magic2
operator|!=
literal|0x59
operator|||
comment|// 'Y'
name|magic3
operator|!=
literal|0x26
operator|||
comment|// '&'
name|magic4
operator|!=
literal|0x53
operator|||
comment|// 'S'
name|magic5
operator|!=
literal|0x59
comment|// 'Y'
condition|)
block|{
name|this
operator|.
name|currentState
operator|=
name|STATE
operator|.
name|EOF
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"bad block header"
argument_list|)
throw|;
block|}
else|else
block|{
name|this
operator|.
name|storedBlockCRC
operator|=
name|bsGetInt
argument_list|()
expr_stmt|;
name|this
operator|.
name|blockRandomised
operator|=
name|bsR
argument_list|(
literal|1
argument_list|)
operator|==
literal|1
expr_stmt|;
comment|/**       * Allocate data here instead in constructor, so we do not allocate       * it if the input file is empty.       */
if|if
condition|(
name|this
operator|.
name|data
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|data
operator|=
operator|new
name|Data
argument_list|(
name|this
operator|.
name|blockSize100k
argument_list|)
expr_stmt|;
block|}
comment|// currBlockNo++;
name|getAndMoveToFrontDecode
argument_list|()
expr_stmt|;
name|this
operator|.
name|crc
operator|.
name|initialiseCRC
argument_list|()
expr_stmt|;
name|this
operator|.
name|currentState
operator|=
name|STATE
operator|.
name|START_BLOCK_STATE
expr_stmt|;
block|}
block|}
DECL|method|endBlock ()
specifier|private
name|void
name|endBlock
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|computedBlockCRC
operator|=
name|this
operator|.
name|crc
operator|.
name|getFinalCRC
argument_list|()
expr_stmt|;
comment|// A bad CRC is considered a fatal error.
if|if
condition|(
name|this
operator|.
name|storedBlockCRC
operator|!=
name|this
operator|.
name|computedBlockCRC
condition|)
block|{
comment|// make next blocks readable without error
comment|// (repair feature, not yet documented, not tested)
name|this
operator|.
name|computedCombinedCRC
operator|=
operator|(
name|this
operator|.
name|storedCombinedCRC
operator|<<
literal|1
operator|)
operator||
operator|(
name|this
operator|.
name|storedCombinedCRC
operator|>>>
literal|31
operator|)
expr_stmt|;
name|this
operator|.
name|computedCombinedCRC
operator|^=
name|this
operator|.
name|storedBlockCRC
expr_stmt|;
name|reportCRCError
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|computedCombinedCRC
operator|=
operator|(
name|this
operator|.
name|computedCombinedCRC
operator|<<
literal|1
operator|)
operator||
operator|(
name|this
operator|.
name|computedCombinedCRC
operator|>>>
literal|31
operator|)
expr_stmt|;
name|this
operator|.
name|computedCombinedCRC
operator|^=
name|this
operator|.
name|computedBlockCRC
expr_stmt|;
block|}
DECL|method|complete ()
specifier|private
name|void
name|complete
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|storedCombinedCRC
operator|=
name|bsGetInt
argument_list|()
expr_stmt|;
name|this
operator|.
name|currentState
operator|=
name|STATE
operator|.
name|EOF
expr_stmt|;
name|this
operator|.
name|data
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|storedCombinedCRC
operator|!=
name|this
operator|.
name|computedCombinedCRC
condition|)
block|{
name|reportCRCError
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
name|InputStream
name|inShadow
init|=
name|this
operator|.
name|in
decl_stmt|;
if|if
condition|(
name|inShadow
operator|!=
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|inShadow
operator|!=
name|System
operator|.
name|in
condition|)
block|{
name|inShadow
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|this
operator|.
name|data
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|in
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
DECL|method|bsR (final long n)
specifier|private
name|long
name|bsR
parameter_list|(
specifier|final
name|long
name|n
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|bsLiveShadow
init|=
name|this
operator|.
name|bsLive
decl_stmt|;
name|long
name|bsBuffShadow
init|=
name|this
operator|.
name|bsBuff
decl_stmt|;
if|if
condition|(
name|bsLiveShadow
operator|<
name|n
condition|)
block|{
specifier|final
name|InputStream
name|inShadow
init|=
name|this
operator|.
name|in
decl_stmt|;
do|do
block|{
name|int
name|thech
init|=
name|readAByte
argument_list|(
name|inShadow
argument_list|)
decl_stmt|;
if|if
condition|(
name|thech
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"unexpected end of stream"
argument_list|)
throw|;
block|}
name|bsBuffShadow
operator|=
operator|(
name|bsBuffShadow
operator|<<
literal|8
operator|)
operator||
name|thech
expr_stmt|;
name|bsLiveShadow
operator|+=
literal|8
expr_stmt|;
block|}
do|while
condition|(
name|bsLiveShadow
operator|<
name|n
condition|)
do|;
name|this
operator|.
name|bsBuff
operator|=
name|bsBuffShadow
expr_stmt|;
block|}
name|this
operator|.
name|bsLive
operator|=
name|bsLiveShadow
operator|-
name|n
expr_stmt|;
return|return
operator|(
name|bsBuffShadow
operator|>>
operator|(
name|bsLiveShadow
operator|-
name|n
operator|)
operator|)
operator|&
operator|(
operator|(
literal|1L
operator|<<
name|n
operator|)
operator|-
literal|1
operator|)
return|;
block|}
DECL|method|bsGetBit ()
specifier|private
name|boolean
name|bsGetBit
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|bsLiveShadow
init|=
name|this
operator|.
name|bsLive
decl_stmt|;
name|long
name|bsBuffShadow
init|=
name|this
operator|.
name|bsBuff
decl_stmt|;
if|if
condition|(
name|bsLiveShadow
operator|<
literal|1
condition|)
block|{
name|int
name|thech
init|=
name|this
operator|.
name|readAByte
argument_list|(
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
name|thech
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"unexpected end of stream"
argument_list|)
throw|;
block|}
name|bsBuffShadow
operator|=
operator|(
name|bsBuffShadow
operator|<<
literal|8
operator|)
operator||
name|thech
expr_stmt|;
name|bsLiveShadow
operator|+=
literal|8
expr_stmt|;
name|this
operator|.
name|bsBuff
operator|=
name|bsBuffShadow
expr_stmt|;
block|}
name|this
operator|.
name|bsLive
operator|=
name|bsLiveShadow
operator|-
literal|1
expr_stmt|;
return|return
operator|(
operator|(
name|bsBuffShadow
operator|>>
operator|(
name|bsLiveShadow
operator|-
literal|1
operator|)
operator|)
operator|&
literal|1
operator|)
operator|!=
literal|0
return|;
block|}
DECL|method|bsGetUByte ()
specifier|private
name|char
name|bsGetUByte
parameter_list|()
throws|throws
name|IOException
block|{
return|return
operator|(
name|char
operator|)
name|bsR
argument_list|(
literal|8
argument_list|)
return|;
block|}
DECL|method|bsGetInt ()
specifier|private
name|int
name|bsGetInt
parameter_list|()
throws|throws
name|IOException
block|{
return|return
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
operator|(
operator|(
operator|(
name|bsR
argument_list|(
literal|8
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|bsR
argument_list|(
literal|8
argument_list|)
operator|)
operator|<<
literal|8
operator|)
operator||
name|bsR
argument_list|(
literal|8
argument_list|)
operator|)
operator|<<
literal|8
operator|)
operator||
name|bsR
argument_list|(
literal|8
argument_list|)
argument_list|)
return|;
block|}
comment|/**   * Called by createHuffmanDecodingTables() exclusively.   */
DECL|method|hbCreateDecodeTables (final int[] limit, final int[] base, final int[] perm, final char[] length, final int minLen, final int maxLen, final int alphaSize)
specifier|private
specifier|static
name|void
name|hbCreateDecodeTables
parameter_list|(
specifier|final
name|int
index|[]
name|limit
parameter_list|,
specifier|final
name|int
index|[]
name|base
parameter_list|,
specifier|final
name|int
index|[]
name|perm
parameter_list|,
specifier|final
name|char
index|[]
name|length
parameter_list|,
specifier|final
name|int
name|minLen
parameter_list|,
specifier|final
name|int
name|maxLen
parameter_list|,
specifier|final
name|int
name|alphaSize
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|minLen
init|,
name|pp
init|=
literal|0
init|;
name|i
operator|<=
name|maxLen
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|alphaSize
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|length
index|[
name|j
index|]
operator|==
name|i
condition|)
block|{
name|perm
index|[
name|pp
operator|++
index|]
operator|=
name|j
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|int
name|i
init|=
name|MAX_CODE_LEN
init|;
operator|--
name|i
operator|>
literal|0
condition|;
control|)
block|{
name|base
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|limit
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
name|base
index|[
name|length
index|[
name|i
index|]
operator|+
literal|1
index|]
operator|++
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|,
name|b
init|=
name|base
index|[
literal|0
index|]
init|;
name|i
operator|<
name|MAX_CODE_LEN
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|+=
name|base
index|[
name|i
index|]
expr_stmt|;
name|base
index|[
name|i
index|]
operator|=
name|b
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|minLen
init|,
name|vec
init|=
literal|0
init|,
name|b
init|=
name|base
index|[
name|i
index|]
init|;
name|i
operator|<=
name|maxLen
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|int
name|nb
init|=
name|base
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
name|vec
operator|+=
name|nb
operator|-
name|b
expr_stmt|;
name|b
operator|=
name|nb
expr_stmt|;
name|limit
index|[
name|i
index|]
operator|=
name|vec
operator|-
literal|1
expr_stmt|;
name|vec
operator|<<=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
name|minLen
operator|+
literal|1
init|;
name|i
operator|<=
name|maxLen
condition|;
name|i
operator|++
control|)
block|{
name|base
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|limit
index|[
name|i
operator|-
literal|1
index|]
operator|+
literal|1
operator|)
operator|<<
literal|1
operator|)
operator|-
name|base
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
DECL|method|recvDecodingTables ()
specifier|private
name|void
name|recvDecodingTables
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|Data
name|dataShadow
init|=
name|this
operator|.
name|data
decl_stmt|;
specifier|final
name|boolean
index|[]
name|inUse
init|=
name|dataShadow
operator|.
name|inUse
decl_stmt|;
specifier|final
name|byte
index|[]
name|pos
init|=
name|dataShadow
operator|.
name|recvDecodingTables_pos
decl_stmt|;
specifier|final
name|byte
index|[]
name|selector
init|=
name|dataShadow
operator|.
name|selector
decl_stmt|;
specifier|final
name|byte
index|[]
name|selectorMtf
init|=
name|dataShadow
operator|.
name|selectorMtf
decl_stmt|;
name|int
name|inUse16
init|=
literal|0
decl_stmt|;
comment|/* Receive the mapping table */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bsGetBit
argument_list|()
condition|)
block|{
name|inUse16
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|256
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|inUse
index|[
name|i
index|]
operator|=
literal|false
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|inUse16
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|final
name|int
name|i16
init|=
name|i
operator|<<
literal|4
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|bsGetBit
argument_list|()
condition|)
block|{
name|inUse
index|[
name|i16
operator|+
name|j
index|]
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
name|makeMaps
argument_list|()
expr_stmt|;
specifier|final
name|int
name|alphaSize
init|=
name|this
operator|.
name|nInUse
operator|+
literal|2
decl_stmt|;
comment|/* Now the selectors */
specifier|final
name|int
name|nGroups
init|=
operator|(
name|int
operator|)
name|bsR
argument_list|(
literal|3
argument_list|)
decl_stmt|;
specifier|final
name|int
name|nSelectors
init|=
operator|(
name|int
operator|)
name|bsR
argument_list|(
literal|15
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nSelectors
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|bsGetBit
argument_list|()
condition|)
block|{
name|j
operator|++
expr_stmt|;
block|}
name|selectorMtf
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
name|j
expr_stmt|;
block|}
comment|/* Undo the MTF values for the selectors. */
for|for
control|(
name|int
name|v
init|=
name|nGroups
init|;
operator|--
name|v
operator|>=
literal|0
condition|;
control|)
block|{
name|pos
index|[
name|v
index|]
operator|=
operator|(
name|byte
operator|)
name|v
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nSelectors
condition|;
name|i
operator|++
control|)
block|{
name|int
name|v
init|=
name|selectorMtf
index|[
name|i
index|]
operator|&
literal|0xff
decl_stmt|;
specifier|final
name|byte
name|tmp
init|=
name|pos
index|[
name|v
index|]
decl_stmt|;
while|while
condition|(
name|v
operator|>
literal|0
condition|)
block|{
comment|// nearly all times v is zero, 4 in most other cases
name|pos
index|[
name|v
index|]
operator|=
name|pos
index|[
name|v
operator|-
literal|1
index|]
expr_stmt|;
name|v
operator|--
expr_stmt|;
block|}
name|pos
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
name|selector
index|[
name|i
index|]
operator|=
name|tmp
expr_stmt|;
block|}
specifier|final
name|char
index|[]
index|[]
name|len
init|=
name|dataShadow
operator|.
name|temp_charArray2d
decl_stmt|;
comment|/* Now the coding tables */
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|nGroups
condition|;
name|t
operator|++
control|)
block|{
name|int
name|curr
init|=
operator|(
name|int
operator|)
name|bsR
argument_list|(
literal|5
argument_list|)
decl_stmt|;
specifier|final
name|char
index|[]
name|len_t
init|=
name|len
index|[
name|t
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|alphaSize
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|bsGetBit
argument_list|()
condition|)
block|{
name|curr
operator|+=
name|bsGetBit
argument_list|()
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
block|}
name|len_t
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|curr
expr_stmt|;
block|}
block|}
comment|// finally create the Huffman tables
name|createHuffmanDecodingTables
argument_list|(
name|alphaSize
argument_list|,
name|nGroups
argument_list|)
expr_stmt|;
block|}
comment|/**   * Called by recvDecodingTables() exclusively.   */
DECL|method|createHuffmanDecodingTables (final int alphaSize, final int nGroups)
specifier|private
name|void
name|createHuffmanDecodingTables
parameter_list|(
specifier|final
name|int
name|alphaSize
parameter_list|,
specifier|final
name|int
name|nGroups
parameter_list|)
block|{
specifier|final
name|Data
name|dataShadow
init|=
name|this
operator|.
name|data
decl_stmt|;
specifier|final
name|char
index|[]
index|[]
name|len
init|=
name|dataShadow
operator|.
name|temp_charArray2d
decl_stmt|;
specifier|final
name|int
index|[]
name|minLens
init|=
name|dataShadow
operator|.
name|minLens
decl_stmt|;
specifier|final
name|int
index|[]
index|[]
name|limit
init|=
name|dataShadow
operator|.
name|limit
decl_stmt|;
specifier|final
name|int
index|[]
index|[]
name|base
init|=
name|dataShadow
operator|.
name|base
decl_stmt|;
specifier|final
name|int
index|[]
index|[]
name|perm
init|=
name|dataShadow
operator|.
name|perm
decl_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|nGroups
condition|;
name|t
operator|++
control|)
block|{
name|int
name|minLen
init|=
literal|32
decl_stmt|;
name|int
name|maxLen
init|=
literal|0
decl_stmt|;
specifier|final
name|char
index|[]
name|len_t
init|=
name|len
index|[
name|t
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|alphaSize
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
specifier|final
name|char
name|lent
init|=
name|len_t
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|lent
operator|>
name|maxLen
condition|)
block|{
name|maxLen
operator|=
name|lent
expr_stmt|;
block|}
if|if
condition|(
name|lent
operator|<
name|minLen
condition|)
block|{
name|minLen
operator|=
name|lent
expr_stmt|;
block|}
block|}
name|hbCreateDecodeTables
argument_list|(
name|limit
index|[
name|t
index|]
argument_list|,
name|base
index|[
name|t
index|]
argument_list|,
name|perm
index|[
name|t
index|]
argument_list|,
name|len
index|[
name|t
index|]
argument_list|,
name|minLen
argument_list|,
name|maxLen
argument_list|,
name|alphaSize
argument_list|)
expr_stmt|;
name|minLens
index|[
name|t
index|]
operator|=
name|minLen
expr_stmt|;
block|}
block|}
DECL|method|getAndMoveToFrontDecode ()
specifier|private
name|void
name|getAndMoveToFrontDecode
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|origPtr
operator|=
operator|(
name|int
operator|)
name|bsR
argument_list|(
literal|24
argument_list|)
expr_stmt|;
name|recvDecodingTables
argument_list|()
expr_stmt|;
specifier|final
name|InputStream
name|inShadow
init|=
name|this
operator|.
name|in
decl_stmt|;
specifier|final
name|Data
name|dataShadow
init|=
name|this
operator|.
name|data
decl_stmt|;
specifier|final
name|byte
index|[]
name|ll8
init|=
name|dataShadow
operator|.
name|ll8
decl_stmt|;
specifier|final
name|int
index|[]
name|unzftab
init|=
name|dataShadow
operator|.
name|unzftab
decl_stmt|;
specifier|final
name|byte
index|[]
name|selector
init|=
name|dataShadow
operator|.
name|selector
decl_stmt|;
specifier|final
name|byte
index|[]
name|seqToUnseq
init|=
name|dataShadow
operator|.
name|seqToUnseq
decl_stmt|;
specifier|final
name|char
index|[]
name|yy
init|=
name|dataShadow
operator|.
name|getAndMoveToFrontDecode_yy
decl_stmt|;
specifier|final
name|int
index|[]
name|minLens
init|=
name|dataShadow
operator|.
name|minLens
decl_stmt|;
specifier|final
name|int
index|[]
index|[]
name|limit
init|=
name|dataShadow
operator|.
name|limit
decl_stmt|;
specifier|final
name|int
index|[]
index|[]
name|base
init|=
name|dataShadow
operator|.
name|base
decl_stmt|;
specifier|final
name|int
index|[]
index|[]
name|perm
init|=
name|dataShadow
operator|.
name|perm
decl_stmt|;
specifier|final
name|int
name|limitLast
init|=
name|this
operator|.
name|blockSize100k
operator|*
literal|100000
decl_stmt|;
comment|/*     * Setting up the unzftab entries here is not strictly necessary, but it     * does save having to do it later in a separate pass, and so saves a     * block's worth of cache misses.     */
for|for
control|(
name|int
name|i
init|=
literal|256
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|yy
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|i
expr_stmt|;
name|unzftab
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|groupNo
init|=
literal|0
decl_stmt|;
name|int
name|groupPos
init|=
name|G_SIZE
operator|-
literal|1
decl_stmt|;
specifier|final
name|int
name|eob
init|=
name|this
operator|.
name|nInUse
operator|+
literal|1
decl_stmt|;
name|int
name|nextSym
init|=
name|getAndMoveToFrontDecode0
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|bsBuffShadow
init|=
operator|(
name|int
operator|)
name|this
operator|.
name|bsBuff
decl_stmt|;
name|int
name|bsLiveShadow
init|=
operator|(
name|int
operator|)
name|this
operator|.
name|bsLive
decl_stmt|;
name|int
name|lastShadow
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|zt
init|=
name|selector
index|[
name|groupNo
index|]
operator|&
literal|0xff
decl_stmt|;
name|int
index|[]
name|base_zt
init|=
name|base
index|[
name|zt
index|]
decl_stmt|;
name|int
index|[]
name|limit_zt
init|=
name|limit
index|[
name|zt
index|]
decl_stmt|;
name|int
index|[]
name|perm_zt
init|=
name|perm
index|[
name|zt
index|]
decl_stmt|;
name|int
name|minLens_zt
init|=
name|minLens
index|[
name|zt
index|]
decl_stmt|;
while|while
condition|(
name|nextSym
operator|!=
name|eob
condition|)
block|{
if|if
condition|(
operator|(
name|nextSym
operator|==
name|RUNA
operator|)
operator|||
operator|(
name|nextSym
operator|==
name|RUNB
operator|)
condition|)
block|{
name|int
name|s
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|n
init|=
literal|1
init|;
literal|true
condition|;
name|n
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|nextSym
operator|==
name|RUNA
condition|)
block|{
name|s
operator|+=
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextSym
operator|==
name|RUNB
condition|)
block|{
name|s
operator|+=
name|n
operator|<<
literal|1
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
if|if
condition|(
name|groupPos
operator|==
literal|0
condition|)
block|{
name|groupPos
operator|=
name|G_SIZE
operator|-
literal|1
expr_stmt|;
name|zt
operator|=
name|selector
index|[
operator|++
name|groupNo
index|]
operator|&
literal|0xff
expr_stmt|;
name|base_zt
operator|=
name|base
index|[
name|zt
index|]
expr_stmt|;
name|limit_zt
operator|=
name|limit
index|[
name|zt
index|]
expr_stmt|;
name|perm_zt
operator|=
name|perm
index|[
name|zt
index|]
expr_stmt|;
name|minLens_zt
operator|=
name|minLens
index|[
name|zt
index|]
expr_stmt|;
block|}
else|else
block|{
name|groupPos
operator|--
expr_stmt|;
block|}
name|int
name|zn
init|=
name|minLens_zt
decl_stmt|;
while|while
condition|(
name|bsLiveShadow
operator|<
name|zn
condition|)
block|{
specifier|final
name|int
name|thech
init|=
name|readAByte
argument_list|(
name|inShadow
argument_list|)
decl_stmt|;
if|if
condition|(
name|thech
operator|>=
literal|0
condition|)
block|{
name|bsBuffShadow
operator|=
operator|(
name|bsBuffShadow
operator|<<
literal|8
operator|)
operator||
name|thech
expr_stmt|;
name|bsLiveShadow
operator|+=
literal|8
expr_stmt|;
continue|continue;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"unexpected end of stream"
argument_list|)
throw|;
block|}
block|}
name|long
name|zvec
init|=
operator|(
name|bsBuffShadow
operator|>>
operator|(
name|bsLiveShadow
operator|-
name|zn
operator|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|zn
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|bsLiveShadow
operator|-=
name|zn
expr_stmt|;
while|while
condition|(
name|zvec
operator|>
name|limit_zt
index|[
name|zn
index|]
condition|)
block|{
name|zn
operator|++
expr_stmt|;
while|while
condition|(
name|bsLiveShadow
operator|<
literal|1
condition|)
block|{
specifier|final
name|int
name|thech
init|=
name|readAByte
argument_list|(
name|inShadow
argument_list|)
decl_stmt|;
if|if
condition|(
name|thech
operator|>=
literal|0
condition|)
block|{
name|bsBuffShadow
operator|=
operator|(
name|bsBuffShadow
operator|<<
literal|8
operator|)
operator||
name|thech
expr_stmt|;
name|bsLiveShadow
operator|+=
literal|8
expr_stmt|;
continue|continue;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"unexpected end of stream"
argument_list|)
throw|;
block|}
block|}
name|bsLiveShadow
operator|--
expr_stmt|;
name|zvec
operator|=
operator|(
name|zvec
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|bsBuffShadow
operator|>>
name|bsLiveShadow
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
block|}
name|nextSym
operator|=
name|perm_zt
index|[
call|(
name|int
call|)
argument_list|(
name|zvec
operator|-
name|base_zt
index|[
name|zn
index|]
argument_list|)
index|]
expr_stmt|;
block|}
specifier|final
name|byte
name|ch
init|=
name|seqToUnseq
index|[
name|yy
index|[
literal|0
index|]
index|]
decl_stmt|;
name|unzftab
index|[
name|ch
operator|&
literal|0xff
index|]
operator|+=
name|s
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|s
operator|--
operator|>=
literal|0
condition|)
block|{
name|ll8
index|[
operator|++
name|lastShadow
index|]
operator|=
name|ch
expr_stmt|;
block|}
if|if
condition|(
name|lastShadow
operator|>=
name|limitLast
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"block overrun"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|++
name|lastShadow
operator|>=
name|limitLast
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"block overrun"
argument_list|)
throw|;
block|}
specifier|final
name|char
name|tmp
init|=
name|yy
index|[
name|nextSym
operator|-
literal|1
index|]
decl_stmt|;
name|unzftab
index|[
name|seqToUnseq
index|[
name|tmp
index|]
operator|&
literal|0xff
index|]
operator|++
expr_stmt|;
name|ll8
index|[
name|lastShadow
index|]
operator|=
name|seqToUnseq
index|[
name|tmp
index|]
expr_stmt|;
comment|/*         * This loop is hammered during decompression, hence avoid         * native method call overhead of System.arraycopy for very         * small ranges to copy.         */
if|if
condition|(
name|nextSym
operator|<=
literal|16
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
name|nextSym
operator|-
literal|1
init|;
name|j
operator|>
literal|0
condition|;
control|)
block|{
name|yy
index|[
name|j
index|]
operator|=
name|yy
index|[
operator|--
name|j
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|yy
argument_list|,
literal|0
argument_list|,
name|yy
argument_list|,
literal|1
argument_list|,
name|nextSym
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|yy
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|groupPos
operator|==
literal|0
condition|)
block|{
name|groupPos
operator|=
name|G_SIZE
operator|-
literal|1
expr_stmt|;
name|zt
operator|=
name|selector
index|[
operator|++
name|groupNo
index|]
operator|&
literal|0xff
expr_stmt|;
name|base_zt
operator|=
name|base
index|[
name|zt
index|]
expr_stmt|;
name|limit_zt
operator|=
name|limit
index|[
name|zt
index|]
expr_stmt|;
name|perm_zt
operator|=
name|perm
index|[
name|zt
index|]
expr_stmt|;
name|minLens_zt
operator|=
name|minLens
index|[
name|zt
index|]
expr_stmt|;
block|}
else|else
block|{
name|groupPos
operator|--
expr_stmt|;
block|}
name|int
name|zn
init|=
name|minLens_zt
decl_stmt|;
while|while
condition|(
name|bsLiveShadow
operator|<
name|zn
condition|)
block|{
specifier|final
name|int
name|thech
init|=
name|readAByte
argument_list|(
name|inShadow
argument_list|)
decl_stmt|;
if|if
condition|(
name|thech
operator|>=
literal|0
condition|)
block|{
name|bsBuffShadow
operator|=
operator|(
name|bsBuffShadow
operator|<<
literal|8
operator|)
operator||
name|thech
expr_stmt|;
name|bsLiveShadow
operator|+=
literal|8
expr_stmt|;
continue|continue;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"unexpected end of stream"
argument_list|)
throw|;
block|}
block|}
name|int
name|zvec
init|=
operator|(
name|bsBuffShadow
operator|>>
operator|(
name|bsLiveShadow
operator|-
name|zn
operator|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|zn
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|bsLiveShadow
operator|-=
name|zn
expr_stmt|;
while|while
condition|(
name|zvec
operator|>
name|limit_zt
index|[
name|zn
index|]
condition|)
block|{
name|zn
operator|++
expr_stmt|;
while|while
condition|(
name|bsLiveShadow
operator|<
literal|1
condition|)
block|{
specifier|final
name|int
name|thech
init|=
name|readAByte
argument_list|(
name|inShadow
argument_list|)
decl_stmt|;
if|if
condition|(
name|thech
operator|>=
literal|0
condition|)
block|{
name|bsBuffShadow
operator|=
operator|(
name|bsBuffShadow
operator|<<
literal|8
operator|)
operator||
name|thech
expr_stmt|;
name|bsLiveShadow
operator|+=
literal|8
expr_stmt|;
continue|continue;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"unexpected end of stream"
argument_list|)
throw|;
block|}
block|}
name|bsLiveShadow
operator|--
expr_stmt|;
name|zvec
operator|=
operator|(
operator|(
name|zvec
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|bsBuffShadow
operator|>>
name|bsLiveShadow
operator|)
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
block|}
name|nextSym
operator|=
name|perm_zt
index|[
name|zvec
operator|-
name|base_zt
index|[
name|zn
index|]
index|]
expr_stmt|;
block|}
block|}
name|this
operator|.
name|last
operator|=
name|lastShadow
expr_stmt|;
name|this
operator|.
name|bsLive
operator|=
name|bsLiveShadow
expr_stmt|;
name|this
operator|.
name|bsBuff
operator|=
name|bsBuffShadow
expr_stmt|;
block|}
DECL|method|getAndMoveToFrontDecode0 (final int groupNo)
specifier|private
name|int
name|getAndMoveToFrontDecode0
parameter_list|(
specifier|final
name|int
name|groupNo
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|InputStream
name|inShadow
init|=
name|this
operator|.
name|in
decl_stmt|;
specifier|final
name|Data
name|dataShadow
init|=
name|this
operator|.
name|data
decl_stmt|;
specifier|final
name|int
name|zt
init|=
name|dataShadow
operator|.
name|selector
index|[
name|groupNo
index|]
operator|&
literal|0xff
decl_stmt|;
specifier|final
name|int
index|[]
name|limit_zt
init|=
name|dataShadow
operator|.
name|limit
index|[
name|zt
index|]
decl_stmt|;
name|int
name|zn
init|=
name|dataShadow
operator|.
name|minLens
index|[
name|zt
index|]
decl_stmt|;
name|int
name|zvec
init|=
operator|(
name|int
operator|)
name|bsR
argument_list|(
name|zn
argument_list|)
decl_stmt|;
name|int
name|bsLiveShadow
init|=
operator|(
name|int
operator|)
name|this
operator|.
name|bsLive
decl_stmt|;
name|int
name|bsBuffShadow
init|=
operator|(
name|int
operator|)
name|this
operator|.
name|bsBuff
decl_stmt|;
while|while
condition|(
name|zvec
operator|>
name|limit_zt
index|[
name|zn
index|]
condition|)
block|{
name|zn
operator|++
expr_stmt|;
while|while
condition|(
name|bsLiveShadow
operator|<
literal|1
condition|)
block|{
specifier|final
name|int
name|thech
init|=
name|readAByte
argument_list|(
name|inShadow
argument_list|)
decl_stmt|;
if|if
condition|(
name|thech
operator|>=
literal|0
condition|)
block|{
name|bsBuffShadow
operator|=
operator|(
name|bsBuffShadow
operator|<<
literal|8
operator|)
operator||
name|thech
expr_stmt|;
name|bsLiveShadow
operator|+=
literal|8
expr_stmt|;
continue|continue;
block|}
else|else
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"unexpected end of stream"
argument_list|)
throw|;
block|}
block|}
name|bsLiveShadow
operator|--
expr_stmt|;
name|zvec
operator|=
operator|(
name|zvec
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|bsBuffShadow
operator|>>
name|bsLiveShadow
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
block|}
name|this
operator|.
name|bsLive
operator|=
name|bsLiveShadow
expr_stmt|;
name|this
operator|.
name|bsBuff
operator|=
name|bsBuffShadow
expr_stmt|;
return|return
name|dataShadow
operator|.
name|perm
index|[
name|zt
index|]
index|[
name|zvec
operator|-
name|dataShadow
operator|.
name|base
index|[
name|zt
index|]
index|[
name|zn
index|]
index|]
return|;
block|}
DECL|method|setupBlock ()
specifier|private
name|void
name|setupBlock
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|data
operator|==
literal|null
condition|)
block|{
return|return;
block|}
specifier|final
name|int
index|[]
name|cftab
init|=
name|this
operator|.
name|data
operator|.
name|cftab
decl_stmt|;
specifier|final
name|int
index|[]
name|tt
init|=
name|this
operator|.
name|data
operator|.
name|initTT
argument_list|(
name|this
operator|.
name|last
operator|+
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|byte
index|[]
name|ll8
init|=
name|this
operator|.
name|data
operator|.
name|ll8
decl_stmt|;
name|cftab
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|this
operator|.
name|data
operator|.
name|unzftab
argument_list|,
literal|0
argument_list|,
name|cftab
argument_list|,
literal|1
argument_list|,
literal|256
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|,
name|c
init|=
name|cftab
index|[
literal|0
index|]
init|;
name|i
operator|<=
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|+=
name|cftab
index|[
name|i
index|]
expr_stmt|;
name|cftab
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|lastShadow
init|=
name|this
operator|.
name|last
init|;
name|i
operator|<=
name|lastShadow
condition|;
name|i
operator|++
control|)
block|{
name|tt
index|[
name|cftab
index|[
name|ll8
index|[
name|i
index|]
operator|&
literal|0xff
index|]
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|this
operator|.
name|origPtr
operator|<
literal|0
operator|)
operator|||
operator|(
name|this
operator|.
name|origPtr
operator|>=
name|tt
operator|.
name|length
operator|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"stream corrupted"
argument_list|)
throw|;
block|}
name|this
operator|.
name|su_tPos
operator|=
name|tt
index|[
name|this
operator|.
name|origPtr
index|]
expr_stmt|;
name|this
operator|.
name|su_count
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|su_i2
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|su_ch2
operator|=
literal|256
expr_stmt|;
comment|/* not a char and not EOF */
if|if
condition|(
name|this
operator|.
name|blockRandomised
condition|)
block|{
name|this
operator|.
name|su_rNToGo
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|su_rTPos
operator|=
literal|0
expr_stmt|;
name|setupRandPartA
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|setupNoRandPartA
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|setupRandPartA ()
specifier|private
name|void
name|setupRandPartA
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|su_i2
operator|<=
name|this
operator|.
name|last
condition|)
block|{
name|this
operator|.
name|su_chPrev
operator|=
name|this
operator|.
name|su_ch2
expr_stmt|;
name|int
name|su_ch2Shadow
init|=
name|this
operator|.
name|data
operator|.
name|ll8
index|[
name|this
operator|.
name|su_tPos
index|]
operator|&
literal|0xff
decl_stmt|;
name|this
operator|.
name|su_tPos
operator|=
name|this
operator|.
name|data
operator|.
name|tt
index|[
name|this
operator|.
name|su_tPos
index|]
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|su_rNToGo
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|su_rNToGo
operator|=
name|BZip2Constants
operator|.
name|rNums
index|[
name|this
operator|.
name|su_rTPos
index|]
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|this
operator|.
name|su_rTPos
operator|==
literal|512
condition|)
block|{
name|this
operator|.
name|su_rTPos
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|this
operator|.
name|su_rNToGo
operator|--
expr_stmt|;
block|}
name|this
operator|.
name|su_ch2
operator|=
name|su_ch2Shadow
operator|^=
operator|(
name|this
operator|.
name|su_rNToGo
operator|==
literal|1
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|this
operator|.
name|su_i2
operator|++
expr_stmt|;
name|this
operator|.
name|currentChar
operator|=
name|su_ch2Shadow
expr_stmt|;
name|this
operator|.
name|currentState
operator|=
name|STATE
operator|.
name|RAND_PART_B_STATE
expr_stmt|;
name|this
operator|.
name|crc
operator|.
name|updateCRC
argument_list|(
name|su_ch2Shadow
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|endBlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|readMode
operator|==
name|READ_MODE
operator|.
name|CONTINUOUS
condition|)
block|{
name|initBlock
argument_list|()
expr_stmt|;
name|setupBlock
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readMode
operator|==
name|READ_MODE
operator|.
name|BYBLOCK
condition|)
block|{
name|this
operator|.
name|currentState
operator|=
name|STATE
operator|.
name|NO_PROCESS_STATE
expr_stmt|;
block|}
block|}
block|}
DECL|method|setupNoRandPartA ()
specifier|private
name|void
name|setupNoRandPartA
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|su_i2
operator|<=
name|this
operator|.
name|last
condition|)
block|{
name|this
operator|.
name|su_chPrev
operator|=
name|this
operator|.
name|su_ch2
expr_stmt|;
name|int
name|su_ch2Shadow
init|=
name|this
operator|.
name|data
operator|.
name|ll8
index|[
name|this
operator|.
name|su_tPos
index|]
operator|&
literal|0xff
decl_stmt|;
name|this
operator|.
name|su_ch2
operator|=
name|su_ch2Shadow
expr_stmt|;
name|this
operator|.
name|su_tPos
operator|=
name|this
operator|.
name|data
operator|.
name|tt
index|[
name|this
operator|.
name|su_tPos
index|]
expr_stmt|;
name|this
operator|.
name|su_i2
operator|++
expr_stmt|;
name|this
operator|.
name|currentChar
operator|=
name|su_ch2Shadow
expr_stmt|;
name|this
operator|.
name|currentState
operator|=
name|STATE
operator|.
name|NO_RAND_PART_B_STATE
expr_stmt|;
name|this
operator|.
name|crc
operator|.
name|updateCRC
argument_list|(
name|su_ch2Shadow
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|currentState
operator|=
name|STATE
operator|.
name|NO_RAND_PART_A_STATE
expr_stmt|;
name|endBlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|readMode
operator|==
name|READ_MODE
operator|.
name|CONTINUOUS
condition|)
block|{
name|initBlock
argument_list|()
expr_stmt|;
name|setupBlock
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readMode
operator|==
name|READ_MODE
operator|.
name|BYBLOCK
condition|)
block|{
name|this
operator|.
name|currentState
operator|=
name|STATE
operator|.
name|NO_PROCESS_STATE
expr_stmt|;
block|}
block|}
block|}
DECL|method|setupRandPartB ()
specifier|private
name|void
name|setupRandPartB
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|su_ch2
operator|!=
name|this
operator|.
name|su_chPrev
condition|)
block|{
name|this
operator|.
name|currentState
operator|=
name|STATE
operator|.
name|RAND_PART_A_STATE
expr_stmt|;
name|this
operator|.
name|su_count
operator|=
literal|1
expr_stmt|;
name|setupRandPartA
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|++
name|this
operator|.
name|su_count
operator|>=
literal|4
condition|)
block|{
name|this
operator|.
name|su_z
operator|=
call|(
name|char
call|)
argument_list|(
name|this
operator|.
name|data
operator|.
name|ll8
index|[
name|this
operator|.
name|su_tPos
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|this
operator|.
name|su_tPos
operator|=
name|this
operator|.
name|data
operator|.
name|tt
index|[
name|this
operator|.
name|su_tPos
index|]
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|su_rNToGo
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|su_rNToGo
operator|=
name|BZip2Constants
operator|.
name|rNums
index|[
name|this
operator|.
name|su_rTPos
index|]
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|this
operator|.
name|su_rTPos
operator|==
literal|512
condition|)
block|{
name|this
operator|.
name|su_rTPos
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|this
operator|.
name|su_rNToGo
operator|--
expr_stmt|;
block|}
name|this
operator|.
name|su_j2
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|currentState
operator|=
name|STATE
operator|.
name|RAND_PART_C_STATE
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|su_rNToGo
operator|==
literal|1
condition|)
block|{
name|this
operator|.
name|su_z
operator|^=
literal|1
expr_stmt|;
block|}
name|setupRandPartC
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|currentState
operator|=
name|STATE
operator|.
name|RAND_PART_A_STATE
expr_stmt|;
name|setupRandPartA
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|setupRandPartC ()
specifier|private
name|void
name|setupRandPartC
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|su_j2
operator|<
name|this
operator|.
name|su_z
condition|)
block|{
name|this
operator|.
name|currentChar
operator|=
name|this
operator|.
name|su_ch2
expr_stmt|;
name|this
operator|.
name|crc
operator|.
name|updateCRC
argument_list|(
name|this
operator|.
name|su_ch2
argument_list|)
expr_stmt|;
name|this
operator|.
name|su_j2
operator|++
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|currentState
operator|=
name|STATE
operator|.
name|RAND_PART_A_STATE
expr_stmt|;
name|this
operator|.
name|su_i2
operator|++
expr_stmt|;
name|this
operator|.
name|su_count
operator|=
literal|0
expr_stmt|;
name|setupRandPartA
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|setupNoRandPartB ()
specifier|private
name|void
name|setupNoRandPartB
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|su_ch2
operator|!=
name|this
operator|.
name|su_chPrev
condition|)
block|{
name|this
operator|.
name|su_count
operator|=
literal|1
expr_stmt|;
name|setupNoRandPartA
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|++
name|this
operator|.
name|su_count
operator|>=
literal|4
condition|)
block|{
name|this
operator|.
name|su_z
operator|=
call|(
name|char
call|)
argument_list|(
name|this
operator|.
name|data
operator|.
name|ll8
index|[
name|this
operator|.
name|su_tPos
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|this
operator|.
name|su_tPos
operator|=
name|this
operator|.
name|data
operator|.
name|tt
index|[
name|this
operator|.
name|su_tPos
index|]
expr_stmt|;
name|this
operator|.
name|su_j2
operator|=
literal|0
expr_stmt|;
name|setupNoRandPartC
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|setupNoRandPartA
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|setupNoRandPartC ()
specifier|private
name|void
name|setupNoRandPartC
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|su_j2
operator|<
name|this
operator|.
name|su_z
condition|)
block|{
name|int
name|su_ch2Shadow
init|=
name|this
operator|.
name|su_ch2
decl_stmt|;
name|this
operator|.
name|currentChar
operator|=
name|su_ch2Shadow
expr_stmt|;
name|this
operator|.
name|crc
operator|.
name|updateCRC
argument_list|(
name|su_ch2Shadow
argument_list|)
expr_stmt|;
name|this
operator|.
name|su_j2
operator|++
expr_stmt|;
name|this
operator|.
name|currentState
operator|=
name|STATE
operator|.
name|NO_RAND_PART_C_STATE
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|su_i2
operator|++
expr_stmt|;
name|this
operator|.
name|su_count
operator|=
literal|0
expr_stmt|;
name|setupNoRandPartA
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|Data
specifier|private
specifier|static
specifier|final
class|class
name|Data
extends|extends
name|Object
block|{
comment|// (with blockSize 900k)
DECL|field|inUse
specifier|final
name|boolean
index|[]
name|inUse
init|=
operator|new
name|boolean
index|[
literal|256
index|]
decl_stmt|;
comment|// 256 byte
DECL|field|seqToUnseq
specifier|final
name|byte
index|[]
name|seqToUnseq
init|=
operator|new
name|byte
index|[
literal|256
index|]
decl_stmt|;
comment|// 256 byte
DECL|field|selector
specifier|final
name|byte
index|[]
name|selector
init|=
operator|new
name|byte
index|[
name|MAX_SELECTORS
index|]
decl_stmt|;
comment|// 18002 byte
DECL|field|selectorMtf
specifier|final
name|byte
index|[]
name|selectorMtf
init|=
operator|new
name|byte
index|[
name|MAX_SELECTORS
index|]
decl_stmt|;
comment|// 18002 byte
comment|/**     * Freq table collected to save a pass over the data during     * decompression.     */
DECL|field|unzftab
specifier|final
name|int
index|[]
name|unzftab
init|=
operator|new
name|int
index|[
literal|256
index|]
decl_stmt|;
comment|// 1024 byte
DECL|field|limit
specifier|final
name|int
index|[]
index|[]
name|limit
init|=
operator|new
name|int
index|[
name|N_GROUPS
index|]
index|[
name|MAX_ALPHA_SIZE
index|]
decl_stmt|;
comment|// 6192 byte
DECL|field|base
specifier|final
name|int
index|[]
index|[]
name|base
init|=
operator|new
name|int
index|[
name|N_GROUPS
index|]
index|[
name|MAX_ALPHA_SIZE
index|]
decl_stmt|;
comment|// 6192 byte
DECL|field|perm
specifier|final
name|int
index|[]
index|[]
name|perm
init|=
operator|new
name|int
index|[
name|N_GROUPS
index|]
index|[
name|MAX_ALPHA_SIZE
index|]
decl_stmt|;
comment|// 6192 byte
DECL|field|minLens
specifier|final
name|int
index|[]
name|minLens
init|=
operator|new
name|int
index|[
name|N_GROUPS
index|]
decl_stmt|;
comment|// 24 byte
DECL|field|cftab
specifier|final
name|int
index|[]
name|cftab
init|=
operator|new
name|int
index|[
literal|257
index|]
decl_stmt|;
comment|// 1028 byte
DECL|field|getAndMoveToFrontDecode_yy
specifier|final
name|char
index|[]
name|getAndMoveToFrontDecode_yy
init|=
operator|new
name|char
index|[
literal|256
index|]
decl_stmt|;
comment|// 512 byte
DECL|field|temp_charArray2d
specifier|final
name|char
index|[]
index|[]
name|temp_charArray2d
init|=
operator|new
name|char
index|[
name|N_GROUPS
index|]
index|[
name|MAX_ALPHA_SIZE
index|]
decl_stmt|;
comment|// 3096
comment|// byte
DECL|field|recvDecodingTables_pos
specifier|final
name|byte
index|[]
name|recvDecodingTables_pos
init|=
operator|new
name|byte
index|[
name|N_GROUPS
index|]
decl_stmt|;
comment|// 6 byte
comment|// ---------------
comment|// 60798 byte
DECL|field|tt
name|int
index|[]
name|tt
decl_stmt|;
comment|// 3600000 byte
DECL|field|ll8
name|byte
index|[]
name|ll8
decl_stmt|;
comment|// 900000 byte
comment|// ---------------
comment|// 4560782 byte
comment|// ===============
DECL|method|Data (int blockSize100k)
name|Data
parameter_list|(
name|int
name|blockSize100k
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|this
operator|.
name|ll8
operator|=
operator|new
name|byte
index|[
name|blockSize100k
operator|*
name|BZip2Constants
operator|.
name|baseBlockSize
index|]
expr_stmt|;
block|}
comment|/**     * Initializes the {@link #tt} array.     *     * This method is called when the required length of the array is known.     * I don't initialize it at construction time to avoid unneccessary     * memory allocation when compressing small files.     */
DECL|method|initTT (int length)
specifier|final
name|int
index|[]
name|initTT
parameter_list|(
name|int
name|length
parameter_list|)
block|{
name|int
index|[]
name|ttShadow
init|=
name|this
operator|.
name|tt
decl_stmt|;
comment|// tt.length should always be>= length, but theoretically
comment|// it can happen, if the compressor mixed small and large
comment|// blocks. Normally only the last block will be smaller
comment|// than others.
if|if
condition|(
operator|(
name|ttShadow
operator|==
literal|null
operator|)
operator|||
operator|(
name|ttShadow
operator|.
name|length
operator|<
name|length
operator|)
condition|)
block|{
name|this
operator|.
name|tt
operator|=
name|ttShadow
operator|=
operator|new
name|int
index|[
name|length
index|]
expr_stmt|;
block|}
return|return
name|ttShadow
return|;
block|}
block|}
block|}
end_class

end_unit

