begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.io.nativeio
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|nativeio
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileDescriptor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|RandomAccessFile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|MappedByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|FileChannel
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|HardLink
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|SecureIOUtils
operator|.
name|AlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|NativeCodeLoader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Shell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|PerformanceAdvisory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|sun
operator|.
name|misc
operator|.
name|Unsafe
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  * JNI wrappers for various native IO-related calls not available in Java.  * These functions should generally be used alongside a fallback to another  * more portable mechanism.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|class|NativeIO
specifier|public
class|class
name|NativeIO
block|{
DECL|class|POSIX
specifier|public
specifier|static
class|class
name|POSIX
block|{
comment|// Flags for open() call from bits/fcntl.h
DECL|field|O_RDONLY
specifier|public
specifier|static
specifier|final
name|int
name|O_RDONLY
init|=
literal|00
decl_stmt|;
DECL|field|O_WRONLY
specifier|public
specifier|static
specifier|final
name|int
name|O_WRONLY
init|=
literal|01
decl_stmt|;
DECL|field|O_RDWR
specifier|public
specifier|static
specifier|final
name|int
name|O_RDWR
init|=
literal|02
decl_stmt|;
DECL|field|O_CREAT
specifier|public
specifier|static
specifier|final
name|int
name|O_CREAT
init|=
literal|0100
decl_stmt|;
DECL|field|O_EXCL
specifier|public
specifier|static
specifier|final
name|int
name|O_EXCL
init|=
literal|0200
decl_stmt|;
DECL|field|O_NOCTTY
specifier|public
specifier|static
specifier|final
name|int
name|O_NOCTTY
init|=
literal|0400
decl_stmt|;
DECL|field|O_TRUNC
specifier|public
specifier|static
specifier|final
name|int
name|O_TRUNC
init|=
literal|01000
decl_stmt|;
DECL|field|O_APPEND
specifier|public
specifier|static
specifier|final
name|int
name|O_APPEND
init|=
literal|02000
decl_stmt|;
DECL|field|O_NONBLOCK
specifier|public
specifier|static
specifier|final
name|int
name|O_NONBLOCK
init|=
literal|04000
decl_stmt|;
DECL|field|O_SYNC
specifier|public
specifier|static
specifier|final
name|int
name|O_SYNC
init|=
literal|010000
decl_stmt|;
comment|// Flags for posix_fadvise() from bits/fcntl.h
comment|/* No further special treatment.  */
DECL|field|POSIX_FADV_NORMAL
specifier|public
specifier|static
specifier|final
name|int
name|POSIX_FADV_NORMAL
init|=
literal|0
decl_stmt|;
comment|/* Expect random page references.  */
DECL|field|POSIX_FADV_RANDOM
specifier|public
specifier|static
specifier|final
name|int
name|POSIX_FADV_RANDOM
init|=
literal|1
decl_stmt|;
comment|/* Expect sequential page references.  */
DECL|field|POSIX_FADV_SEQUENTIAL
specifier|public
specifier|static
specifier|final
name|int
name|POSIX_FADV_SEQUENTIAL
init|=
literal|2
decl_stmt|;
comment|/* Will need these pages.  */
DECL|field|POSIX_FADV_WILLNEED
specifier|public
specifier|static
specifier|final
name|int
name|POSIX_FADV_WILLNEED
init|=
literal|3
decl_stmt|;
comment|/* Don't need these pages.  */
DECL|field|POSIX_FADV_DONTNEED
specifier|public
specifier|static
specifier|final
name|int
name|POSIX_FADV_DONTNEED
init|=
literal|4
decl_stmt|;
comment|/* Data will be accessed once.  */
DECL|field|POSIX_FADV_NOREUSE
specifier|public
specifier|static
specifier|final
name|int
name|POSIX_FADV_NOREUSE
init|=
literal|5
decl_stmt|;
comment|/* Wait upon writeout of all pages        in the range before performing the        write.  */
DECL|field|SYNC_FILE_RANGE_WAIT_BEFORE
specifier|public
specifier|static
specifier|final
name|int
name|SYNC_FILE_RANGE_WAIT_BEFORE
init|=
literal|1
decl_stmt|;
comment|/* Initiate writeout of all those        dirty pages in the range which are        not presently under writeback.  */
DECL|field|SYNC_FILE_RANGE_WRITE
specifier|public
specifier|static
specifier|final
name|int
name|SYNC_FILE_RANGE_WRITE
init|=
literal|2
decl_stmt|;
comment|/* Wait upon writeout of all pages in        the range after performing the        write.  */
DECL|field|SYNC_FILE_RANGE_WAIT_AFTER
specifier|public
specifier|static
specifier|final
name|int
name|SYNC_FILE_RANGE_WAIT_AFTER
init|=
literal|4
decl_stmt|;
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|NativeIO
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|nativeLoaded
specifier|private
specifier|static
name|boolean
name|nativeLoaded
init|=
literal|false
decl_stmt|;
DECL|field|fadvisePossible
specifier|private
specifier|static
name|boolean
name|fadvisePossible
init|=
literal|true
decl_stmt|;
DECL|field|syncFileRangePossible
specifier|private
specifier|static
name|boolean
name|syncFileRangePossible
init|=
literal|true
decl_stmt|;
DECL|field|WORKAROUND_NON_THREADSAFE_CALLS_KEY
specifier|static
specifier|final
name|String
name|WORKAROUND_NON_THREADSAFE_CALLS_KEY
init|=
literal|"hadoop.workaround.non.threadsafe.getpwuid"
decl_stmt|;
DECL|field|WORKAROUND_NON_THREADSAFE_CALLS_DEFAULT
specifier|static
specifier|final
name|boolean
name|WORKAROUND_NON_THREADSAFE_CALLS_DEFAULT
init|=
literal|true
decl_stmt|;
DECL|field|cacheTimeout
specifier|private
specifier|static
name|long
name|cacheTimeout
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|cacheManipulator
specifier|private
specifier|static
name|CacheManipulator
name|cacheManipulator
init|=
operator|new
name|CacheManipulator
argument_list|()
decl_stmt|;
DECL|method|getCacheManipulator ()
specifier|public
specifier|static
name|CacheManipulator
name|getCacheManipulator
parameter_list|()
block|{
return|return
name|cacheManipulator
return|;
block|}
DECL|method|setCacheManipulator (CacheManipulator cacheManipulator)
specifier|public
specifier|static
name|void
name|setCacheManipulator
parameter_list|(
name|CacheManipulator
name|cacheManipulator
parameter_list|)
block|{
name|POSIX
operator|.
name|cacheManipulator
operator|=
name|cacheManipulator
expr_stmt|;
block|}
comment|/**      * Used to manipulate the operating system cache.      */
annotation|@
name|VisibleForTesting
DECL|class|CacheManipulator
specifier|public
specifier|static
class|class
name|CacheManipulator
block|{
DECL|method|mlock (String identifier, ByteBuffer buffer, long len)
specifier|public
name|void
name|mlock
parameter_list|(
name|String
name|identifier
parameter_list|,
name|ByteBuffer
name|buffer
parameter_list|,
name|long
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|POSIX
operator|.
name|mlock
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
DECL|method|getMemlockLimit ()
specifier|public
name|long
name|getMemlockLimit
parameter_list|()
block|{
return|return
name|NativeIO
operator|.
name|getMemlockLimit
argument_list|()
return|;
block|}
DECL|method|getOperatingSystemPageSize ()
specifier|public
name|long
name|getOperatingSystemPageSize
parameter_list|()
block|{
return|return
name|NativeIO
operator|.
name|getOperatingSystemPageSize
argument_list|()
return|;
block|}
DECL|method|posixFadviseIfPossible (String identifier, FileDescriptor fd, long offset, long len, int flags)
specifier|public
name|void
name|posixFadviseIfPossible
parameter_list|(
name|String
name|identifier
parameter_list|,
name|FileDescriptor
name|fd
parameter_list|,
name|long
name|offset
parameter_list|,
name|long
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|NativeIOException
block|{
name|NativeIO
operator|.
name|POSIX
operator|.
name|posixFadviseIfPossible
argument_list|(
name|identifier
argument_list|,
name|fd
argument_list|,
name|offset
argument_list|,
name|len
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
DECL|method|verifyCanMlock ()
specifier|public
name|boolean
name|verifyCanMlock
parameter_list|()
block|{
return|return
name|NativeIO
operator|.
name|isAvailable
argument_list|()
return|;
block|}
block|}
comment|/**      * A CacheManipulator used for testing which does not actually call mlock.      * This allows many tests to be run even when the operating system does not      * allow mlock, or only allows limited mlocking.      */
annotation|@
name|VisibleForTesting
DECL|class|NoMlockCacheManipulator
specifier|public
specifier|static
class|class
name|NoMlockCacheManipulator
extends|extends
name|CacheManipulator
block|{
DECL|method|mlock (String identifier, ByteBuffer buffer, long len)
specifier|public
name|void
name|mlock
parameter_list|(
name|String
name|identifier
parameter_list|,
name|ByteBuffer
name|buffer
parameter_list|,
name|long
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"mlocking "
operator|+
name|identifier
argument_list|)
expr_stmt|;
block|}
DECL|method|getMemlockLimit ()
specifier|public
name|long
name|getMemlockLimit
parameter_list|()
block|{
return|return
literal|1125899906842624L
return|;
block|}
DECL|method|getOperatingSystemPageSize ()
specifier|public
name|long
name|getOperatingSystemPageSize
parameter_list|()
block|{
return|return
literal|4096
return|;
block|}
DECL|method|verifyCanMlock ()
specifier|public
name|boolean
name|verifyCanMlock
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
static|static
block|{
if|if
condition|(
name|NativeCodeLoader
operator|.
name|isNativeCodeLoaded
argument_list|()
condition|)
block|{
try|try
block|{
name|Configuration
name|conf
init|=
operator|new
name|Configuration
argument_list|()
decl_stmt|;
name|workaroundNonThreadSafePasswdCalls
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|WORKAROUND_NON_THREADSAFE_CALLS_KEY
argument_list|,
name|WORKAROUND_NON_THREADSAFE_CALLS_DEFAULT
argument_list|)
expr_stmt|;
name|initNative
argument_list|()
expr_stmt|;
name|nativeLoaded
operator|=
literal|true
expr_stmt|;
name|cacheTimeout
operator|=
name|conf
operator|.
name|getLong
argument_list|(
name|CommonConfigurationKeys
operator|.
name|HADOOP_SECURITY_UID_NAME_CACHE_TIMEOUT_KEY
argument_list|,
name|CommonConfigurationKeys
operator|.
name|HADOOP_SECURITY_UID_NAME_CACHE_TIMEOUT_DEFAULT
argument_list|)
operator|*
literal|1000
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Initialized cache for IDs to User/Group mapping with a "
operator|+
literal|" cache timeout of "
operator|+
name|cacheTimeout
operator|/
literal|1000
operator|+
literal|" seconds."
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// This can happen if the user has an older version of libhadoop.so
comment|// installed - in this case we can continue without native IO
comment|// after warning
name|PerformanceAdvisory
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unable to initialize NativeIO libraries"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Return true if the JNI-based native IO extensions are available.      */
DECL|method|isAvailable ()
specifier|public
specifier|static
name|boolean
name|isAvailable
parameter_list|()
block|{
return|return
name|NativeCodeLoader
operator|.
name|isNativeCodeLoaded
argument_list|()
operator|&&
name|nativeLoaded
return|;
block|}
DECL|method|assertCodeLoaded ()
specifier|private
specifier|static
name|void
name|assertCodeLoaded
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|isAvailable
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"NativeIO was not loaded"
argument_list|)
throw|;
block|}
block|}
comment|/** Wrapper around open(2) */
DECL|method|open (String path, int flags, int mode)
specifier|public
specifier|static
specifier|native
name|FileDescriptor
name|open
parameter_list|(
name|String
name|path
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Wrapper around fstat(2) */
DECL|method|fstat (FileDescriptor fd)
specifier|private
specifier|static
specifier|native
name|Stat
name|fstat
parameter_list|(
name|FileDescriptor
name|fd
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Native chmod implementation. On UNIX, it is a wrapper around chmod(2) */
DECL|method|chmodImpl (String path, int mode)
specifier|private
specifier|static
specifier|native
name|void
name|chmodImpl
parameter_list|(
name|String
name|path
parameter_list|,
name|int
name|mode
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|chmod (String path, int mode)
specifier|public
specifier|static
name|void
name|chmod
parameter_list|(
name|String
name|path
parameter_list|,
name|int
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|Shell
operator|.
name|WINDOWS
condition|)
block|{
name|chmodImpl
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|chmodImpl
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NativeIOException
name|nioe
parameter_list|)
block|{
if|if
condition|(
name|nioe
operator|.
name|getErrorCode
argument_list|()
operator|==
literal|3
condition|)
block|{
throw|throw
operator|new
name|NativeIOException
argument_list|(
literal|"No such file or directory"
argument_list|,
name|Errno
operator|.
name|ENOENT
argument_list|)
throw|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"NativeIO.chmod error (%d): %s"
argument_list|,
name|nioe
operator|.
name|getErrorCode
argument_list|()
argument_list|,
name|nioe
operator|.
name|getMessage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|NativeIOException
argument_list|(
literal|"Unknown error"
argument_list|,
name|Errno
operator|.
name|UNKNOWN
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/** Wrapper around posix_fadvise(2) */
DECL|method|posix_fadvise ( FileDescriptor fd, long offset, long len, int flags)
specifier|static
specifier|native
name|void
name|posix_fadvise
parameter_list|(
name|FileDescriptor
name|fd
parameter_list|,
name|long
name|offset
parameter_list|,
name|long
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|NativeIOException
function_decl|;
comment|/** Wrapper around sync_file_range(2) */
DECL|method|sync_file_range ( FileDescriptor fd, long offset, long nbytes, int flags)
specifier|static
specifier|native
name|void
name|sync_file_range
parameter_list|(
name|FileDescriptor
name|fd
parameter_list|,
name|long
name|offset
parameter_list|,
name|long
name|nbytes
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|NativeIOException
function_decl|;
comment|/**      * Call posix_fadvise on the given file descriptor. See the manpage      * for this syscall for more information. On systems where this      * call is not available, does nothing.      *      * @throws NativeIOException if there is an error with the syscall      */
DECL|method|posixFadviseIfPossible (String identifier, FileDescriptor fd, long offset, long len, int flags)
specifier|static
name|void
name|posixFadviseIfPossible
parameter_list|(
name|String
name|identifier
parameter_list|,
name|FileDescriptor
name|fd
parameter_list|,
name|long
name|offset
parameter_list|,
name|long
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|NativeIOException
block|{
if|if
condition|(
name|nativeLoaded
operator|&&
name|fadvisePossible
condition|)
block|{
try|try
block|{
name|posix_fadvise
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|,
name|len
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|uoe
parameter_list|)
block|{
name|fadvisePossible
operator|=
literal|false
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsatisfiedLinkError
name|ule
parameter_list|)
block|{
name|fadvisePossible
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Call sync_file_range on the given file descriptor. See the manpage      * for this syscall for more information. On systems where this      * call is not available, does nothing.      *      * @throws NativeIOException if there is an error with the syscall      */
DECL|method|syncFileRangeIfPossible ( FileDescriptor fd, long offset, long nbytes, int flags)
specifier|public
specifier|static
name|void
name|syncFileRangeIfPossible
parameter_list|(
name|FileDescriptor
name|fd
parameter_list|,
name|long
name|offset
parameter_list|,
name|long
name|nbytes
parameter_list|,
name|int
name|flags
parameter_list|)
throws|throws
name|NativeIOException
block|{
if|if
condition|(
name|nativeLoaded
operator|&&
name|syncFileRangePossible
condition|)
block|{
try|try
block|{
name|sync_file_range
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|,
name|nbytes
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|uoe
parameter_list|)
block|{
name|syncFileRangePossible
operator|=
literal|false
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsatisfiedLinkError
name|ule
parameter_list|)
block|{
name|syncFileRangePossible
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
DECL|method|mlock_native ( ByteBuffer buffer, long len)
specifier|static
specifier|native
name|void
name|mlock_native
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|,
name|long
name|len
parameter_list|)
throws|throws
name|NativeIOException
function_decl|;
comment|/**      * Locks the provided direct ByteBuffer into memory, preventing it from      * swapping out. After a buffer is locked, future accesses will not incur      * a page fault.      *       * See the mlock(2) man page for more information.      *       * @throws NativeIOException      */
DECL|method|mlock (ByteBuffer buffer, long len)
specifier|static
name|void
name|mlock
parameter_list|(
name|ByteBuffer
name|buffer
parameter_list|,
name|long
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|assertCodeLoaded
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
operator|.
name|isDirect
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Cannot mlock a non-direct ByteBuffer"
argument_list|)
throw|;
block|}
name|mlock_native
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/**      * Unmaps the block from memory. See munmap(2).      *      * There isn't any portable way to unmap a memory region in Java.      * So we use the sun.nio method here.      * Note that unmapping a memory region could cause crashes if code      * continues to reference the unmapped code.  However, if we don't      * manually unmap the memory, we are dependent on the finalizer to      * do it, and we have no idea when the finalizer will run.      *      * @param buffer    The buffer to unmap.      */
DECL|method|munmap (MappedByteBuffer buffer)
specifier|public
specifier|static
name|void
name|munmap
parameter_list|(
name|MappedByteBuffer
name|buffer
parameter_list|)
block|{
if|if
condition|(
name|buffer
operator|instanceof
name|sun
operator|.
name|nio
operator|.
name|ch
operator|.
name|DirectBuffer
condition|)
block|{
name|sun
operator|.
name|misc
operator|.
name|Cleaner
name|cleaner
init|=
operator|(
operator|(
name|sun
operator|.
name|nio
operator|.
name|ch
operator|.
name|DirectBuffer
operator|)
name|buffer
operator|)
operator|.
name|cleaner
argument_list|()
decl_stmt|;
name|cleaner
operator|.
name|clean
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Linux only methods used for getOwner() implementation */
DECL|method|getUIDforFDOwnerforOwner (FileDescriptor fd)
specifier|private
specifier|static
specifier|native
name|long
name|getUIDforFDOwnerforOwner
parameter_list|(
name|FileDescriptor
name|fd
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|getUserName (long uid)
specifier|private
specifier|static
specifier|native
name|String
name|getUserName
parameter_list|(
name|long
name|uid
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Result type of the fstat call      */
DECL|class|Stat
specifier|public
specifier|static
class|class
name|Stat
block|{
DECL|field|ownerId
DECL|field|groupId
specifier|private
name|int
name|ownerId
decl_stmt|,
name|groupId
decl_stmt|;
DECL|field|owner
DECL|field|group
specifier|private
name|String
name|owner
decl_stmt|,
name|group
decl_stmt|;
DECL|field|mode
specifier|private
name|int
name|mode
decl_stmt|;
comment|// Mode constants
DECL|field|S_IFMT
specifier|public
specifier|static
specifier|final
name|int
name|S_IFMT
init|=
literal|0170000
decl_stmt|;
comment|/* type of file */
DECL|field|S_IFIFO
specifier|public
specifier|static
specifier|final
name|int
name|S_IFIFO
init|=
literal|0010000
decl_stmt|;
comment|/* named pipe (fifo) */
DECL|field|S_IFCHR
specifier|public
specifier|static
specifier|final
name|int
name|S_IFCHR
init|=
literal|0020000
decl_stmt|;
comment|/* character special */
DECL|field|S_IFDIR
specifier|public
specifier|static
specifier|final
name|int
name|S_IFDIR
init|=
literal|0040000
decl_stmt|;
comment|/* directory */
DECL|field|S_IFBLK
specifier|public
specifier|static
specifier|final
name|int
name|S_IFBLK
init|=
literal|0060000
decl_stmt|;
comment|/* block special */
DECL|field|S_IFREG
specifier|public
specifier|static
specifier|final
name|int
name|S_IFREG
init|=
literal|0100000
decl_stmt|;
comment|/* regular */
DECL|field|S_IFLNK
specifier|public
specifier|static
specifier|final
name|int
name|S_IFLNK
init|=
literal|0120000
decl_stmt|;
comment|/* symbolic link */
DECL|field|S_IFSOCK
specifier|public
specifier|static
specifier|final
name|int
name|S_IFSOCK
init|=
literal|0140000
decl_stmt|;
comment|/* socket */
DECL|field|S_ISUID
specifier|public
specifier|static
specifier|final
name|int
name|S_ISUID
init|=
literal|0004000
decl_stmt|;
comment|/* set user id on execution */
DECL|field|S_ISGID
specifier|public
specifier|static
specifier|final
name|int
name|S_ISGID
init|=
literal|0002000
decl_stmt|;
comment|/* set group id on execution */
DECL|field|S_ISVTX
specifier|public
specifier|static
specifier|final
name|int
name|S_ISVTX
init|=
literal|0001000
decl_stmt|;
comment|/* save swapped text even after use */
DECL|field|S_IRUSR
specifier|public
specifier|static
specifier|final
name|int
name|S_IRUSR
init|=
literal|0000400
decl_stmt|;
comment|/* read permission, owner */
DECL|field|S_IWUSR
specifier|public
specifier|static
specifier|final
name|int
name|S_IWUSR
init|=
literal|0000200
decl_stmt|;
comment|/* write permission, owner */
DECL|field|S_IXUSR
specifier|public
specifier|static
specifier|final
name|int
name|S_IXUSR
init|=
literal|0000100
decl_stmt|;
comment|/* execute/search permission, owner */
DECL|method|Stat (int ownerId, int groupId, int mode)
name|Stat
parameter_list|(
name|int
name|ownerId
parameter_list|,
name|int
name|groupId
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|this
operator|.
name|ownerId
operator|=
name|ownerId
expr_stmt|;
name|this
operator|.
name|groupId
operator|=
name|groupId
expr_stmt|;
name|this
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
block|}
DECL|method|Stat (String owner, String group, int mode)
name|Stat
parameter_list|(
name|String
name|owner
parameter_list|,
name|String
name|group
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Shell
operator|.
name|WINDOWS
condition|)
block|{
name|this
operator|.
name|owner
operator|=
name|owner
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|owner
operator|=
name|stripDomain
argument_list|(
name|owner
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Shell
operator|.
name|WINDOWS
condition|)
block|{
name|this
operator|.
name|group
operator|=
name|group
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|group
operator|=
name|stripDomain
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Stat(owner='"
operator|+
name|owner
operator|+
literal|"', group='"
operator|+
name|group
operator|+
literal|"'"
operator|+
literal|", mode="
operator|+
name|mode
operator|+
literal|")"
return|;
block|}
DECL|method|getOwner ()
specifier|public
name|String
name|getOwner
parameter_list|()
block|{
return|return
name|owner
return|;
block|}
DECL|method|getGroup ()
specifier|public
name|String
name|getGroup
parameter_list|()
block|{
return|return
name|group
return|;
block|}
DECL|method|getMode ()
specifier|public
name|int
name|getMode
parameter_list|()
block|{
return|return
name|mode
return|;
block|}
block|}
comment|/**      * Returns the file stat for a file descriptor.      *      * @param fd file descriptor.      * @return the file descriptor file stat.      * @throws IOException thrown if there was an IO error while obtaining the file stat.      */
DECL|method|getFstat (FileDescriptor fd)
specifier|public
specifier|static
name|Stat
name|getFstat
parameter_list|(
name|FileDescriptor
name|fd
parameter_list|)
throws|throws
name|IOException
block|{
name|Stat
name|stat
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|Shell
operator|.
name|WINDOWS
condition|)
block|{
name|stat
operator|=
name|fstat
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|stat
operator|.
name|owner
operator|=
name|getName
argument_list|(
name|IdCache
operator|.
name|USER
argument_list|,
name|stat
operator|.
name|ownerId
argument_list|)
expr_stmt|;
name|stat
operator|.
name|group
operator|=
name|getName
argument_list|(
name|IdCache
operator|.
name|GROUP
argument_list|,
name|stat
operator|.
name|groupId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|stat
operator|=
name|fstat
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NativeIOException
name|nioe
parameter_list|)
block|{
if|if
condition|(
name|nioe
operator|.
name|getErrorCode
argument_list|()
operator|==
literal|6
condition|)
block|{
throw|throw
operator|new
name|NativeIOException
argument_list|(
literal|"The handle is invalid."
argument_list|,
name|Errno
operator|.
name|EBADF
argument_list|)
throw|;
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"NativeIO.getFstat error (%d): %s"
argument_list|,
name|nioe
operator|.
name|getErrorCode
argument_list|()
argument_list|,
name|nioe
operator|.
name|getMessage
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|NativeIOException
argument_list|(
literal|"Unknown error"
argument_list|,
name|Errno
operator|.
name|UNKNOWN
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|stat
return|;
block|}
DECL|method|getName (IdCache domain, int id)
specifier|private
specifier|static
name|String
name|getName
parameter_list|(
name|IdCache
name|domain
parameter_list|,
name|int
name|id
parameter_list|)
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|Integer
argument_list|,
name|CachedName
argument_list|>
name|idNameCache
init|=
operator|(
name|domain
operator|==
name|IdCache
operator|.
name|USER
operator|)
condition|?
name|USER_ID_NAME_CACHE
else|:
name|GROUP_ID_NAME_CACHE
decl_stmt|;
name|String
name|name
decl_stmt|;
name|CachedName
name|cachedName
init|=
name|idNameCache
operator|.
name|get
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|cachedName
operator|!=
literal|null
operator|&&
operator|(
name|cachedName
operator|.
name|timestamp
operator|+
name|cacheTimeout
operator|)
operator|>
name|now
condition|)
block|{
name|name
operator|=
name|cachedName
operator|.
name|name
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
operator|(
name|domain
operator|==
name|IdCache
operator|.
name|USER
operator|)
condition|?
name|getUserName
argument_list|(
name|id
argument_list|)
else|:
name|getGroupName
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|String
name|type
init|=
operator|(
name|domain
operator|==
name|IdCache
operator|.
name|USER
operator|)
condition|?
literal|"UserName"
else|:
literal|"GroupName"
decl_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Got "
operator|+
name|type
operator|+
literal|" "
operator|+
name|name
operator|+
literal|" for ID "
operator|+
name|id
operator|+
literal|" from the native implementation"
argument_list|)
expr_stmt|;
block|}
name|cachedName
operator|=
operator|new
name|CachedName
argument_list|(
name|name
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|idNameCache
operator|.
name|put
argument_list|(
name|id
argument_list|,
name|cachedName
argument_list|)
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
DECL|method|getUserName (int uid)
specifier|static
specifier|native
name|String
name|getUserName
parameter_list|(
name|int
name|uid
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|getGroupName (int uid)
specifier|static
specifier|native
name|String
name|getGroupName
parameter_list|(
name|int
name|uid
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|class|CachedName
specifier|private
specifier|static
class|class
name|CachedName
block|{
DECL|field|timestamp
specifier|final
name|long
name|timestamp
decl_stmt|;
DECL|field|name
specifier|final
name|String
name|name
decl_stmt|;
DECL|method|CachedName (String name, long timestamp)
specifier|public
name|CachedName
parameter_list|(
name|String
name|name
parameter_list|,
name|long
name|timestamp
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|timestamp
operator|=
name|timestamp
expr_stmt|;
block|}
block|}
DECL|field|USER_ID_NAME_CACHE
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|CachedName
argument_list|>
name|USER_ID_NAME_CACHE
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|Integer
argument_list|,
name|CachedName
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|GROUP_ID_NAME_CACHE
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Integer
argument_list|,
name|CachedName
argument_list|>
name|GROUP_ID_NAME_CACHE
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|Integer
argument_list|,
name|CachedName
argument_list|>
argument_list|()
decl_stmt|;
DECL|enum|IdCache
DECL|enumConstant|USER
DECL|enumConstant|GROUP
specifier|private
enum|enum
name|IdCache
block|{
name|USER
block|,
name|GROUP
block|}
DECL|field|MMAP_PROT_READ
specifier|public
specifier|final
specifier|static
name|int
name|MMAP_PROT_READ
init|=
literal|0x1
decl_stmt|;
DECL|field|MMAP_PROT_WRITE
specifier|public
specifier|final
specifier|static
name|int
name|MMAP_PROT_WRITE
init|=
literal|0x2
decl_stmt|;
DECL|field|MMAP_PROT_EXEC
specifier|public
specifier|final
specifier|static
name|int
name|MMAP_PROT_EXEC
init|=
literal|0x4
decl_stmt|;
DECL|method|mmap (FileDescriptor fd, int prot, boolean shared, long length)
specifier|public
specifier|static
specifier|native
name|long
name|mmap
parameter_list|(
name|FileDescriptor
name|fd
parameter_list|,
name|int
name|prot
parameter_list|,
name|boolean
name|shared
parameter_list|,
name|long
name|length
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|munmap (long addr, long length)
specifier|public
specifier|static
specifier|native
name|void
name|munmap
parameter_list|(
name|long
name|addr
parameter_list|,
name|long
name|length
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
DECL|field|workaroundNonThreadSafePasswdCalls
specifier|private
specifier|static
name|boolean
name|workaroundNonThreadSafePasswdCalls
init|=
literal|false
decl_stmt|;
DECL|class|Windows
specifier|public
specifier|static
class|class
name|Windows
block|{
comment|// Flags for CreateFile() call on Windows
DECL|field|GENERIC_READ
specifier|public
specifier|static
specifier|final
name|long
name|GENERIC_READ
init|=
literal|0x80000000L
decl_stmt|;
DECL|field|GENERIC_WRITE
specifier|public
specifier|static
specifier|final
name|long
name|GENERIC_WRITE
init|=
literal|0x40000000L
decl_stmt|;
DECL|field|FILE_SHARE_READ
specifier|public
specifier|static
specifier|final
name|long
name|FILE_SHARE_READ
init|=
literal|0x00000001L
decl_stmt|;
DECL|field|FILE_SHARE_WRITE
specifier|public
specifier|static
specifier|final
name|long
name|FILE_SHARE_WRITE
init|=
literal|0x00000002L
decl_stmt|;
DECL|field|FILE_SHARE_DELETE
specifier|public
specifier|static
specifier|final
name|long
name|FILE_SHARE_DELETE
init|=
literal|0x00000004L
decl_stmt|;
DECL|field|CREATE_NEW
specifier|public
specifier|static
specifier|final
name|long
name|CREATE_NEW
init|=
literal|1
decl_stmt|;
DECL|field|CREATE_ALWAYS
specifier|public
specifier|static
specifier|final
name|long
name|CREATE_ALWAYS
init|=
literal|2
decl_stmt|;
DECL|field|OPEN_EXISTING
specifier|public
specifier|static
specifier|final
name|long
name|OPEN_EXISTING
init|=
literal|3
decl_stmt|;
DECL|field|OPEN_ALWAYS
specifier|public
specifier|static
specifier|final
name|long
name|OPEN_ALWAYS
init|=
literal|4
decl_stmt|;
DECL|field|TRUNCATE_EXISTING
specifier|public
specifier|static
specifier|final
name|long
name|TRUNCATE_EXISTING
init|=
literal|5
decl_stmt|;
DECL|field|FILE_BEGIN
specifier|public
specifier|static
specifier|final
name|long
name|FILE_BEGIN
init|=
literal|0
decl_stmt|;
DECL|field|FILE_CURRENT
specifier|public
specifier|static
specifier|final
name|long
name|FILE_CURRENT
init|=
literal|1
decl_stmt|;
DECL|field|FILE_END
specifier|public
specifier|static
specifier|final
name|long
name|FILE_END
init|=
literal|2
decl_stmt|;
DECL|field|FILE_ATTRIBUTE_NORMAL
specifier|public
specifier|static
specifier|final
name|long
name|FILE_ATTRIBUTE_NORMAL
init|=
literal|0x00000080L
decl_stmt|;
comment|/**      * Create a directory with permissions set to the specified mode.  By setting      * permissions at creation time, we avoid issues related to the user lacking      * WRITE_DAC rights on subsequent chmod calls.  One example where this can      * occur is writing to an SMB share where the user does not have Full Control      * rights, and therefore WRITE_DAC is denied.      *      * @param path directory to create      * @param mode permissions of new directory      * @throws IOException if there is an I/O error      */
DECL|method|createDirectoryWithMode (File path, int mode)
specifier|public
specifier|static
name|void
name|createDirectoryWithMode
parameter_list|(
name|File
name|path
parameter_list|,
name|int
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
name|createDirectoryWithMode0
argument_list|(
name|path
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/** Wrapper around CreateDirectory() on Windows */
DECL|method|createDirectoryWithMode0 (String path, int mode)
specifier|private
specifier|static
specifier|native
name|void
name|createDirectoryWithMode0
parameter_list|(
name|String
name|path
parameter_list|,
name|int
name|mode
parameter_list|)
throws|throws
name|NativeIOException
function_decl|;
comment|/** Wrapper around CreateFile() on Windows */
DECL|method|createFile (String path, long desiredAccess, long shareMode, long creationDisposition)
specifier|public
specifier|static
specifier|native
name|FileDescriptor
name|createFile
parameter_list|(
name|String
name|path
parameter_list|,
name|long
name|desiredAccess
parameter_list|,
name|long
name|shareMode
parameter_list|,
name|long
name|creationDisposition
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Create a file for write with permissions set to the specified mode.  By      * setting permissions at creation time, we avoid issues related to the user      * lacking WRITE_DAC rights on subsequent chmod calls.  One example where      * this can occur is writing to an SMB share where the user does not have      * Full Control rights, and therefore WRITE_DAC is denied.      *      * This method mimics the semantics implemented by the JDK in      * {@link java.io.FileOutputStream}.  The file is opened for truncate or      * append, the sharing mode allows other readers and writers, and paths      * longer than MAX_PATH are supported.  (See io_util_md.c in the JDK.)      *      * @param path file to create      * @param append if true, then open file for append      * @param mode permissions of new directory      * @return FileOutputStream of opened file      * @throws IOException if there is an I/O error      */
DECL|method|createFileOutputStreamWithMode (File path, boolean append, int mode)
specifier|public
specifier|static
name|FileOutputStream
name|createFileOutputStreamWithMode
parameter_list|(
name|File
name|path
parameter_list|,
name|boolean
name|append
parameter_list|,
name|int
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|desiredAccess
init|=
name|GENERIC_WRITE
decl_stmt|;
name|long
name|shareMode
init|=
name|FILE_SHARE_READ
operator||
name|FILE_SHARE_WRITE
decl_stmt|;
name|long
name|creationDisposition
init|=
name|append
condition|?
name|OPEN_ALWAYS
else|:
name|CREATE_ALWAYS
decl_stmt|;
return|return
operator|new
name|FileOutputStream
argument_list|(
name|createFileWithMode0
argument_list|(
name|path
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|desiredAccess
argument_list|,
name|shareMode
argument_list|,
name|creationDisposition
argument_list|,
name|mode
argument_list|)
argument_list|)
return|;
block|}
comment|/** Wrapper around CreateFile() with security descriptor on Windows */
DECL|method|createFileWithMode0 (String path, long desiredAccess, long shareMode, long creationDisposition, int mode)
specifier|private
specifier|static
specifier|native
name|FileDescriptor
name|createFileWithMode0
parameter_list|(
name|String
name|path
parameter_list|,
name|long
name|desiredAccess
parameter_list|,
name|long
name|shareMode
parameter_list|,
name|long
name|creationDisposition
parameter_list|,
name|int
name|mode
parameter_list|)
throws|throws
name|NativeIOException
function_decl|;
comment|/** Wrapper around SetFilePointer() on Windows */
DECL|method|setFilePointer (FileDescriptor fd, long distanceToMove, long moveMethod)
specifier|public
specifier|static
specifier|native
name|long
name|setFilePointer
parameter_list|(
name|FileDescriptor
name|fd
parameter_list|,
name|long
name|distanceToMove
parameter_list|,
name|long
name|moveMethod
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Windows only methods used for getOwner() implementation */
DECL|method|getOwner (FileDescriptor fd)
specifier|private
specifier|static
specifier|native
name|String
name|getOwner
parameter_list|(
name|FileDescriptor
name|fd
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/** Supported list of Windows access right flags */
DECL|enum|AccessRight
specifier|public
specifier|static
enum|enum
name|AccessRight
block|{
DECL|enumConstant|ACCESS_READ
name|ACCESS_READ
argument_list|(
literal|0x0001
argument_list|)
block|,
comment|// FILE_READ_DATA
DECL|enumConstant|ACCESS_WRITE
name|ACCESS_WRITE
argument_list|(
literal|0x0002
argument_list|)
block|,
comment|// FILE_WRITE_DATA
DECL|enumConstant|ACCESS_EXECUTE
name|ACCESS_EXECUTE
argument_list|(
literal|0x0020
argument_list|)
block|;
comment|// FILE_EXECUTE
DECL|field|accessRight
specifier|private
specifier|final
name|int
name|accessRight
decl_stmt|;
DECL|method|AccessRight (int access)
name|AccessRight
parameter_list|(
name|int
name|access
parameter_list|)
block|{
name|accessRight
operator|=
name|access
expr_stmt|;
block|}
DECL|method|accessRight ()
specifier|public
name|int
name|accessRight
parameter_list|()
block|{
return|return
name|accessRight
return|;
block|}
block|}
empty_stmt|;
comment|/** Windows only method used to check if the current process has requested      *  access rights on the given path. */
DECL|method|access0 (String path, int requestedAccess)
specifier|private
specifier|static
specifier|native
name|boolean
name|access0
parameter_list|(
name|String
name|path
parameter_list|,
name|int
name|requestedAccess
parameter_list|)
function_decl|;
comment|/**      * Checks whether the current process has desired access rights on      * the given path.      *       * Longer term this native function can be substituted with JDK7      * function Files#isReadable, isWritable, isExecutable.      *      * @param path input path      * @param desiredAccess ACCESS_READ, ACCESS_WRITE or ACCESS_EXECUTE      * @return true if access is allowed      * @throws IOException I/O exception on error      */
DECL|method|access (String path, AccessRight desiredAccess)
specifier|public
specifier|static
name|boolean
name|access
parameter_list|(
name|String
name|path
parameter_list|,
name|AccessRight
name|desiredAccess
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|access0
argument_list|(
name|path
argument_list|,
name|desiredAccess
operator|.
name|accessRight
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Extends both the minimum and maximum working set size of the current      * process.  This method gets the current minimum and maximum working set      * size, adds the requested amount to each and then sets the minimum and      * maximum working set size to the new values.  Controlling the working set      * size of the process also controls the amount of memory it can lock.      *      * @param delta amount to increment minimum and maximum working set size      * @throws IOException for any error      * @see POSIX#mlock(ByteBuffer, long)      */
DECL|method|extendWorkingSetSize (long delta)
specifier|public
specifier|static
specifier|native
name|void
name|extendWorkingSetSize
parameter_list|(
name|long
name|delta
parameter_list|)
throws|throws
name|IOException
function_decl|;
static|static
block|{
if|if
condition|(
name|NativeCodeLoader
operator|.
name|isNativeCodeLoaded
argument_list|()
condition|)
block|{
try|try
block|{
name|initNative
argument_list|()
expr_stmt|;
name|nativeLoaded
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// This can happen if the user has an older version of libhadoop.so
comment|// installed - in this case we can continue without native IO
comment|// after warning
name|PerformanceAdvisory
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unable to initialize NativeIO libraries"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|NativeIO
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|nativeLoaded
specifier|private
specifier|static
name|boolean
name|nativeLoaded
init|=
literal|false
decl_stmt|;
static|static
block|{
if|if
condition|(
name|NativeCodeLoader
operator|.
name|isNativeCodeLoaded
argument_list|()
condition|)
block|{
try|try
block|{
name|initNative
argument_list|()
expr_stmt|;
name|nativeLoaded
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// This can happen if the user has an older version of libhadoop.so
comment|// installed - in this case we can continue without native IO
comment|// after warning
name|PerformanceAdvisory
operator|.
name|LOG
operator|.
name|debug
argument_list|(
literal|"Unable to initialize NativeIO libraries"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**    * Return true if the JNI-based native IO extensions are available.    */
DECL|method|isAvailable ()
specifier|public
specifier|static
name|boolean
name|isAvailable
parameter_list|()
block|{
return|return
name|NativeCodeLoader
operator|.
name|isNativeCodeLoaded
argument_list|()
operator|&&
name|nativeLoaded
return|;
block|}
comment|/** Initialize the JNI method ID and class ID cache */
DECL|method|initNative ()
specifier|private
specifier|static
specifier|native
name|void
name|initNative
parameter_list|()
function_decl|;
comment|/**    * Get the maximum number of bytes that can be locked into memory at any    * given point.    *    * @return 0 if no bytes can be locked into memory;    *         Long.MAX_VALUE if there is no limit;    *         The number of bytes that can be locked into memory otherwise.    */
DECL|method|getMemlockLimit ()
specifier|static
name|long
name|getMemlockLimit
parameter_list|()
block|{
return|return
name|isAvailable
argument_list|()
condition|?
name|getMemlockLimit0
argument_list|()
else|:
literal|0
return|;
block|}
DECL|method|getMemlockLimit0 ()
specifier|private
specifier|static
specifier|native
name|long
name|getMemlockLimit0
parameter_list|()
function_decl|;
comment|/**    * @return the operating system's page size.    */
DECL|method|getOperatingSystemPageSize ()
specifier|static
name|long
name|getOperatingSystemPageSize
parameter_list|()
block|{
try|try
block|{
name|Field
name|f
init|=
name|Unsafe
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"theUnsafe"
argument_list|)
decl_stmt|;
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Unsafe
name|unsafe
init|=
operator|(
name|Unsafe
operator|)
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
return|return
name|unsafe
operator|.
name|pageSize
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unable to get operating system page size.  Guessing 4096."
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|4096
return|;
block|}
block|}
DECL|class|CachedUid
specifier|private
specifier|static
class|class
name|CachedUid
block|{
DECL|field|timestamp
specifier|final
name|long
name|timestamp
decl_stmt|;
DECL|field|username
specifier|final
name|String
name|username
decl_stmt|;
DECL|method|CachedUid (String username, long timestamp)
specifier|public
name|CachedUid
parameter_list|(
name|String
name|username
parameter_list|,
name|long
name|timestamp
parameter_list|)
block|{
name|this
operator|.
name|timestamp
operator|=
name|timestamp
expr_stmt|;
name|this
operator|.
name|username
operator|=
name|username
expr_stmt|;
block|}
block|}
DECL|field|uidCache
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Long
argument_list|,
name|CachedUid
argument_list|>
name|uidCache
init|=
operator|new
name|ConcurrentHashMap
argument_list|<
name|Long
argument_list|,
name|CachedUid
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|cacheTimeout
specifier|private
specifier|static
name|long
name|cacheTimeout
decl_stmt|;
DECL|field|initialized
specifier|private
specifier|static
name|boolean
name|initialized
init|=
literal|false
decl_stmt|;
comment|/**    * The Windows logon name has two part, NetBIOS domain name and    * user account name, of the format DOMAIN\UserName. This method    * will remove the domain part of the full logon name.    *    * @param Fthe full principal name containing the domain    * @return name with domain removed    */
DECL|method|stripDomain (String name)
specifier|private
specifier|static
name|String
name|stripDomain
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|int
name|i
init|=
name|name
operator|.
name|indexOf
argument_list|(
literal|'\\'
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
name|name
operator|=
name|name
operator|.
name|substring
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
DECL|method|getOwner (FileDescriptor fd)
specifier|public
specifier|static
name|String
name|getOwner
parameter_list|(
name|FileDescriptor
name|fd
parameter_list|)
throws|throws
name|IOException
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|Shell
operator|.
name|WINDOWS
condition|)
block|{
name|String
name|owner
init|=
name|Windows
operator|.
name|getOwner
argument_list|(
name|fd
argument_list|)
decl_stmt|;
name|owner
operator|=
name|stripDomain
argument_list|(
name|owner
argument_list|)
expr_stmt|;
return|return
name|owner
return|;
block|}
else|else
block|{
name|long
name|uid
init|=
name|POSIX
operator|.
name|getUIDforFDOwnerforOwner
argument_list|(
name|fd
argument_list|)
decl_stmt|;
name|CachedUid
name|cUid
init|=
name|uidCache
operator|.
name|get
argument_list|(
name|uid
argument_list|)
decl_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|cUid
operator|!=
literal|null
operator|&&
operator|(
name|cUid
operator|.
name|timestamp
operator|+
name|cacheTimeout
operator|)
operator|>
name|now
condition|)
block|{
return|return
name|cUid
operator|.
name|username
return|;
block|}
name|String
name|user
init|=
name|POSIX
operator|.
name|getUserName
argument_list|(
name|uid
argument_list|)
decl_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Got UserName "
operator|+
name|user
operator|+
literal|" for UID "
operator|+
name|uid
operator|+
literal|" from the native implementation"
argument_list|)
expr_stmt|;
name|cUid
operator|=
operator|new
name|CachedUid
argument_list|(
name|user
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|uidCache
operator|.
name|put
argument_list|(
name|uid
argument_list|,
name|cUid
argument_list|)
expr_stmt|;
return|return
name|user
return|;
block|}
block|}
comment|/**    * Create a FileInputStream that shares delete permission on the    * file opened, i.e. other process can delete the file the    * FileInputStream is reading. Only Windows implementation uses    * the native interface.    */
DECL|method|getShareDeleteFileInputStream (File f)
specifier|public
specifier|static
name|FileInputStream
name|getShareDeleteFileInputStream
parameter_list|(
name|File
name|f
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|Shell
operator|.
name|WINDOWS
condition|)
block|{
comment|// On Linux the default FileInputStream shares delete permission
comment|// on the file opened.
comment|//
return|return
operator|new
name|FileInputStream
argument_list|(
name|f
argument_list|)
return|;
block|}
else|else
block|{
comment|// Use Windows native interface to create a FileInputStream that
comment|// shares delete permission on the file opened.
comment|//
name|FileDescriptor
name|fd
init|=
name|Windows
operator|.
name|createFile
argument_list|(
name|f
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|Windows
operator|.
name|GENERIC_READ
argument_list|,
name|Windows
operator|.
name|FILE_SHARE_READ
operator||
name|Windows
operator|.
name|FILE_SHARE_WRITE
operator||
name|Windows
operator|.
name|FILE_SHARE_DELETE
argument_list|,
name|Windows
operator|.
name|OPEN_EXISTING
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileInputStream
argument_list|(
name|fd
argument_list|)
return|;
block|}
block|}
comment|/**    * Create a FileInputStream that shares delete permission on the    * file opened at a given offset, i.e. other process can delete    * the file the FileInputStream is reading. Only Windows implementation    * uses the native interface.    */
DECL|method|getShareDeleteFileInputStream (File f, long seekOffset)
specifier|public
specifier|static
name|FileInputStream
name|getShareDeleteFileInputStream
parameter_list|(
name|File
name|f
parameter_list|,
name|long
name|seekOffset
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|Shell
operator|.
name|WINDOWS
condition|)
block|{
name|RandomAccessFile
name|rf
init|=
operator|new
name|RandomAccessFile
argument_list|(
name|f
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
name|seekOffset
operator|>
literal|0
condition|)
block|{
name|rf
operator|.
name|seek
argument_list|(
name|seekOffset
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|FileInputStream
argument_list|(
name|rf
operator|.
name|getFD
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|// Use Windows native interface to create a FileInputStream that
comment|// shares delete permission on the file opened, and set it to the
comment|// given offset.
comment|//
name|FileDescriptor
name|fd
init|=
name|NativeIO
operator|.
name|Windows
operator|.
name|createFile
argument_list|(
name|f
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|NativeIO
operator|.
name|Windows
operator|.
name|GENERIC_READ
argument_list|,
name|NativeIO
operator|.
name|Windows
operator|.
name|FILE_SHARE_READ
operator||
name|NativeIO
operator|.
name|Windows
operator|.
name|FILE_SHARE_WRITE
operator||
name|NativeIO
operator|.
name|Windows
operator|.
name|FILE_SHARE_DELETE
argument_list|,
name|NativeIO
operator|.
name|Windows
operator|.
name|OPEN_EXISTING
argument_list|)
decl_stmt|;
if|if
condition|(
name|seekOffset
operator|>
literal|0
condition|)
name|NativeIO
operator|.
name|Windows
operator|.
name|setFilePointer
argument_list|(
name|fd
argument_list|,
name|seekOffset
argument_list|,
name|NativeIO
operator|.
name|Windows
operator|.
name|FILE_BEGIN
argument_list|)
expr_stmt|;
return|return
operator|new
name|FileInputStream
argument_list|(
name|fd
argument_list|)
return|;
block|}
block|}
comment|/**    * Create the specified File for write access, ensuring that it does not exist.    * @param f the file that we want to create    * @param permissions we want to have on the file (if security is enabled)    *    * @throws AlreadyExistsException if the file already exists    * @throws IOException if any other error occurred    */
DECL|method|getCreateForWriteFileOutputStream (File f, int permissions)
specifier|public
specifier|static
name|FileOutputStream
name|getCreateForWriteFileOutputStream
parameter_list|(
name|File
name|f
parameter_list|,
name|int
name|permissions
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|Shell
operator|.
name|WINDOWS
condition|)
block|{
comment|// Use the native wrapper around open(2)
try|try
block|{
name|FileDescriptor
name|fd
init|=
name|NativeIO
operator|.
name|POSIX
operator|.
name|open
argument_list|(
name|f
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|NativeIO
operator|.
name|POSIX
operator|.
name|O_WRONLY
operator||
name|NativeIO
operator|.
name|POSIX
operator|.
name|O_CREAT
operator||
name|NativeIO
operator|.
name|POSIX
operator|.
name|O_EXCL
argument_list|,
name|permissions
argument_list|)
decl_stmt|;
return|return
operator|new
name|FileOutputStream
argument_list|(
name|fd
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NativeIOException
name|nioe
parameter_list|)
block|{
if|if
condition|(
name|nioe
operator|.
name|getErrno
argument_list|()
operator|==
name|Errno
operator|.
name|EEXIST
condition|)
block|{
throw|throw
operator|new
name|AlreadyExistsException
argument_list|(
name|nioe
argument_list|)
throw|;
block|}
throw|throw
name|nioe
throw|;
block|}
block|}
else|else
block|{
comment|// Use the Windows native APIs to create equivalent FileOutputStream
try|try
block|{
name|FileDescriptor
name|fd
init|=
name|NativeIO
operator|.
name|Windows
operator|.
name|createFile
argument_list|(
name|f
operator|.
name|getCanonicalPath
argument_list|()
argument_list|,
name|NativeIO
operator|.
name|Windows
operator|.
name|GENERIC_WRITE
argument_list|,
name|NativeIO
operator|.
name|Windows
operator|.
name|FILE_SHARE_DELETE
operator||
name|NativeIO
operator|.
name|Windows
operator|.
name|FILE_SHARE_READ
operator||
name|NativeIO
operator|.
name|Windows
operator|.
name|FILE_SHARE_WRITE
argument_list|,
name|NativeIO
operator|.
name|Windows
operator|.
name|CREATE_NEW
argument_list|)
decl_stmt|;
name|NativeIO
operator|.
name|POSIX
operator|.
name|chmod
argument_list|(
name|f
operator|.
name|getCanonicalPath
argument_list|()
argument_list|,
name|permissions
argument_list|)
expr_stmt|;
return|return
operator|new
name|FileOutputStream
argument_list|(
name|fd
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NativeIOException
name|nioe
parameter_list|)
block|{
if|if
condition|(
name|nioe
operator|.
name|getErrorCode
argument_list|()
operator|==
literal|80
condition|)
block|{
comment|// ERROR_FILE_EXISTS
comment|// 80 (0x50)
comment|// The file exists
throw|throw
operator|new
name|AlreadyExistsException
argument_list|(
name|nioe
argument_list|)
throw|;
block|}
throw|throw
name|nioe
throw|;
block|}
block|}
block|}
DECL|method|ensureInitialized ()
specifier|private
specifier|synchronized
specifier|static
name|void
name|ensureInitialized
parameter_list|()
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|cacheTimeout
operator|=
operator|new
name|Configuration
argument_list|()
operator|.
name|getLong
argument_list|(
literal|"hadoop.security.uid.cache.secs"
argument_list|,
literal|4
operator|*
literal|60
operator|*
literal|60
argument_list|)
operator|*
literal|1000
expr_stmt|;
name|LOG
operator|.
name|info
argument_list|(
literal|"Initialized cache for UID to User mapping with a cache"
operator|+
literal|" timeout of "
operator|+
name|cacheTimeout
operator|/
literal|1000
operator|+
literal|" seconds."
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|/**    * A version of renameTo that throws a descriptive exception when it fails.    *    * @param src                  The source path    * @param dst                  The destination path    *     * @throws NativeIOException   On failure.    */
DECL|method|renameTo (File src, File dst)
specifier|public
specifier|static
name|void
name|renameTo
parameter_list|(
name|File
name|src
parameter_list|,
name|File
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|nativeLoaded
condition|)
block|{
if|if
condition|(
operator|!
name|src
operator|.
name|renameTo
argument_list|(
name|dst
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"renameTo(src="
operator|+
name|src
operator|+
literal|", dst="
operator|+
name|dst
operator|+
literal|") failed."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|renameTo0
argument_list|(
name|src
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|dst
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * Creates a hardlink "dst" that points to "src".    *    * This is deprecated since JDK7 NIO can create hardlinks via the    * {@link java.nio.file.Files} API.    *    * @param src source file    * @param dst hardlink location    * @throws IOException    */
annotation|@
name|Deprecated
DECL|method|link (File src, File dst)
specifier|public
specifier|static
name|void
name|link
parameter_list|(
name|File
name|src
parameter_list|,
name|File
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|nativeLoaded
condition|)
block|{
name|HardLink
operator|.
name|createHardLink
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|link0
argument_list|(
name|src
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|dst
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**    * A version of renameTo that throws a descriptive exception when it fails.    *    * @param src                  The source path    * @param dst                  The destination path    *     * @throws NativeIOException   On failure.    */
DECL|method|renameTo0 (String src, String dst)
specifier|private
specifier|static
specifier|native
name|void
name|renameTo0
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|)
throws|throws
name|NativeIOException
function_decl|;
DECL|method|link0 (String src, String dst)
specifier|private
specifier|static
specifier|native
name|void
name|link0
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|)
throws|throws
name|NativeIOException
function_decl|;
comment|/**    * Unbuffered file copy from src to dst without tainting OS buffer cache    *    * In POSIX platform:    * It uses FileChannel#transferTo() which internally attempts    * unbuffered IO on OS with native sendfile64() support and falls back to    * buffered IO otherwise.    *    * It minimizes the number of FileChannel#transferTo call by passing the the    * src file size directly instead of a smaller size as the 3rd parameter.    * This saves the number of sendfile64() system call when native sendfile64()    * is supported. In the two fall back cases where sendfile is not supported,    * FileChannle#transferTo already has its own batching of size 8 MB and 8 KB,    * respectively.    *    * In Windows Platform:    * It uses its own native wrapper of CopyFileEx with COPY_FILE_NO_BUFFERING    * flag, which is supported on Windows Server 2008 and above.    *    * Ideally, we should use FileChannel#transferTo() across both POSIX and Windows    * platform. Unfortunately, the wrapper(Java_sun_nio_ch_FileChannelImpl_transferTo0)    * used by FileChannel#transferTo for unbuffered IO is not implemented on Windows.    * Based on OpenJDK 6/7/8 source code, Java_sun_nio_ch_FileChannelImpl_transferTo0    * on Windows simply returns IOS_UNSUPPORTED.    *    * Note: This simple native wrapper does minimal parameter checking before copy and    * consistency check (e.g., size) after copy.    * It is recommended to use wrapper function like    * the Storage#nativeCopyFileUnbuffered() function in hadoop-hdfs with pre/post copy    * checks.    *    * @param src                  The source path    * @param dst                  The destination path    * @throws IOException    */
DECL|method|copyFileUnbuffered (File src, File dst)
specifier|public
specifier|static
name|void
name|copyFileUnbuffered
parameter_list|(
name|File
name|src
parameter_list|,
name|File
name|dst
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|nativeLoaded
operator|&&
name|Shell
operator|.
name|WINDOWS
condition|)
block|{
name|copyFileUnbuffered0
argument_list|(
name|src
operator|.
name|getAbsolutePath
argument_list|()
argument_list|,
name|dst
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FileInputStream
name|fis
init|=
literal|null
decl_stmt|;
name|FileOutputStream
name|fos
init|=
literal|null
decl_stmt|;
name|FileChannel
name|input
init|=
literal|null
decl_stmt|;
name|FileChannel
name|output
init|=
literal|null
decl_stmt|;
try|try
block|{
name|fis
operator|=
operator|new
name|FileInputStream
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|fos
operator|=
operator|new
name|FileOutputStream
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|input
operator|=
name|fis
operator|.
name|getChannel
argument_list|()
expr_stmt|;
name|output
operator|=
name|fos
operator|.
name|getChannel
argument_list|()
expr_stmt|;
name|long
name|remaining
init|=
name|input
operator|.
name|size
argument_list|()
decl_stmt|;
name|long
name|position
init|=
literal|0
decl_stmt|;
name|long
name|transferred
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
name|transferred
operator|=
name|input
operator|.
name|transferTo
argument_list|(
name|position
argument_list|,
name|remaining
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|remaining
operator|-=
name|transferred
expr_stmt|;
name|position
operator|+=
name|transferred
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|fos
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|cleanup
argument_list|(
name|LOG
argument_list|,
name|fis
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|copyFileUnbuffered0 (String src, String dst)
specifier|private
specifier|static
specifier|native
name|void
name|copyFileUnbuffered0
parameter_list|(
name|String
name|src
parameter_list|,
name|String
name|dst
parameter_list|)
throws|throws
name|NativeIOException
function_decl|;
block|}
end_class

end_unit

