begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.security
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Reader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|naming
operator|.
name|Context
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|naming
operator|.
name|NamingEnumeration
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|naming
operator|.
name|NamingException
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|naming
operator|.
name|directory
operator|.
name|Attribute
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|naming
operator|.
name|directory
operator|.
name|DirContext
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|naming
operator|.
name|directory
operator|.
name|InitialDirContext
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|naming
operator|.
name|directory
operator|.
name|SearchControls
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|naming
operator|.
name|directory
operator|.
name|SearchResult
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|naming
operator|.
name|ldap
operator|.
name|LdapName
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|naming
operator|.
name|ldap
operator|.
name|Rdn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|io
operator|.
name|Charsets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configurable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_comment
comment|/**  * An implementation of {@link GroupMappingServiceProvider} which  * connects directly to an LDAP server for determining group membership.  *   * This provider should be used only if it is necessary to map users to  * groups that reside exclusively in an Active Directory or LDAP installation.  * The common case for a Hadoop installation will be that LDAP users and groups  * materialized on the Unix servers, and for an installation like that,  * ShellBasedUnixGroupsMapping is preferred. However, in cases where  * those users and groups aren't materialized in Unix, but need to be used for  * access control, this class may be used to communicate directly with the LDAP  * server.  *   * It is important to note that resolving group mappings will incur network  * traffic, and may cause degraded performance, although user-group mappings  * will be cached via the infrastructure provided by {@link Groups}.  *   * This implementation does not support configurable search limits. If a filter  * is used for searching users or groups which returns more results than are  * allowed by the server, an exception will be thrown.  *   * The implementation also does not attempt to resolve group hierarchies. In  * order to be considered a member of a group, the user must be an explicit  * member in LDAP.  */
end_comment

begin_class
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|,
literal|"MapReduce"
block|}
argument_list|)
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|LdapGroupsMapping
specifier|public
class|class
name|LdapGroupsMapping
implements|implements
name|GroupMappingServiceProvider
implements|,
name|Configurable
block|{
DECL|field|LDAP_CONFIG_PREFIX
specifier|public
specifier|static
specifier|final
name|String
name|LDAP_CONFIG_PREFIX
init|=
literal|"hadoop.security.group.mapping.ldap"
decl_stmt|;
comment|/*    * URL of the LDAP server    */
DECL|field|LDAP_URL_KEY
specifier|public
specifier|static
specifier|final
name|String
name|LDAP_URL_KEY
init|=
name|LDAP_CONFIG_PREFIX
operator|+
literal|".url"
decl_stmt|;
DECL|field|LDAP_URL_DEFAULT
specifier|public
specifier|static
specifier|final
name|String
name|LDAP_URL_DEFAULT
init|=
literal|""
decl_stmt|;
comment|/*    * Should SSL be used to connect to the server    */
DECL|field|LDAP_USE_SSL_KEY
specifier|public
specifier|static
specifier|final
name|String
name|LDAP_USE_SSL_KEY
init|=
name|LDAP_CONFIG_PREFIX
operator|+
literal|".ssl"
decl_stmt|;
DECL|field|LDAP_USE_SSL_DEFAULT
specifier|public
specifier|static
specifier|final
name|Boolean
name|LDAP_USE_SSL_DEFAULT
init|=
literal|false
decl_stmt|;
comment|/*    * File path to the location of the SSL keystore to use    */
DECL|field|LDAP_KEYSTORE_KEY
specifier|public
specifier|static
specifier|final
name|String
name|LDAP_KEYSTORE_KEY
init|=
name|LDAP_CONFIG_PREFIX
operator|+
literal|".ssl.keystore"
decl_stmt|;
DECL|field|LDAP_KEYSTORE_DEFAULT
specifier|public
specifier|static
specifier|final
name|String
name|LDAP_KEYSTORE_DEFAULT
init|=
literal|""
decl_stmt|;
comment|/*    * Password for the keystore    */
DECL|field|LDAP_KEYSTORE_PASSWORD_KEY
specifier|public
specifier|static
specifier|final
name|String
name|LDAP_KEYSTORE_PASSWORD_KEY
init|=
name|LDAP_CONFIG_PREFIX
operator|+
literal|".ssl.keystore.password"
decl_stmt|;
DECL|field|LDAP_KEYSTORE_PASSWORD_DEFAULT
specifier|public
specifier|static
specifier|final
name|String
name|LDAP_KEYSTORE_PASSWORD_DEFAULT
init|=
literal|""
decl_stmt|;
DECL|field|LDAP_KEYSTORE_PASSWORD_FILE_KEY
specifier|public
specifier|static
specifier|final
name|String
name|LDAP_KEYSTORE_PASSWORD_FILE_KEY
init|=
name|LDAP_KEYSTORE_PASSWORD_KEY
operator|+
literal|".file"
decl_stmt|;
DECL|field|LDAP_KEYSTORE_PASSWORD_FILE_DEFAULT
specifier|public
specifier|static
specifier|final
name|String
name|LDAP_KEYSTORE_PASSWORD_FILE_DEFAULT
init|=
literal|""
decl_stmt|;
comment|/*    * User to bind to the LDAP server with    */
DECL|field|BIND_USER_KEY
specifier|public
specifier|static
specifier|final
name|String
name|BIND_USER_KEY
init|=
name|LDAP_CONFIG_PREFIX
operator|+
literal|".bind.user"
decl_stmt|;
DECL|field|BIND_USER_DEFAULT
specifier|public
specifier|static
specifier|final
name|String
name|BIND_USER_DEFAULT
init|=
literal|""
decl_stmt|;
comment|/*    * Password for the bind user    */
DECL|field|BIND_PASSWORD_KEY
specifier|public
specifier|static
specifier|final
name|String
name|BIND_PASSWORD_KEY
init|=
name|LDAP_CONFIG_PREFIX
operator|+
literal|".bind.password"
decl_stmt|;
DECL|field|BIND_PASSWORD_DEFAULT
specifier|public
specifier|static
specifier|final
name|String
name|BIND_PASSWORD_DEFAULT
init|=
literal|""
decl_stmt|;
DECL|field|BIND_PASSWORD_FILE_KEY
specifier|public
specifier|static
specifier|final
name|String
name|BIND_PASSWORD_FILE_KEY
init|=
name|BIND_PASSWORD_KEY
operator|+
literal|".file"
decl_stmt|;
DECL|field|BIND_PASSWORD_FILE_DEFAULT
specifier|public
specifier|static
specifier|final
name|String
name|BIND_PASSWORD_FILE_DEFAULT
init|=
literal|""
decl_stmt|;
comment|/*    * Base distinguished name to use for searches    */
DECL|field|BASE_DN_KEY
specifier|public
specifier|static
specifier|final
name|String
name|BASE_DN_KEY
init|=
name|LDAP_CONFIG_PREFIX
operator|+
literal|".base"
decl_stmt|;
DECL|field|BASE_DN_DEFAULT
specifier|public
specifier|static
specifier|final
name|String
name|BASE_DN_DEFAULT
init|=
literal|""
decl_stmt|;
comment|/*    * Any additional filters to apply when searching for users    */
DECL|field|USER_SEARCH_FILTER_KEY
specifier|public
specifier|static
specifier|final
name|String
name|USER_SEARCH_FILTER_KEY
init|=
name|LDAP_CONFIG_PREFIX
operator|+
literal|".search.filter.user"
decl_stmt|;
DECL|field|USER_SEARCH_FILTER_DEFAULT
specifier|public
specifier|static
specifier|final
name|String
name|USER_SEARCH_FILTER_DEFAULT
init|=
literal|"(&(objectClass=user)(sAMAccountName={0}))"
decl_stmt|;
comment|/*    * Any additional filters to apply when finding relevant groups    */
DECL|field|GROUP_SEARCH_FILTER_KEY
specifier|public
specifier|static
specifier|final
name|String
name|GROUP_SEARCH_FILTER_KEY
init|=
name|LDAP_CONFIG_PREFIX
operator|+
literal|".search.filter.group"
decl_stmt|;
DECL|field|GROUP_SEARCH_FILTER_DEFAULT
specifier|public
specifier|static
specifier|final
name|String
name|GROUP_SEARCH_FILTER_DEFAULT
init|=
literal|"(objectClass=group)"
decl_stmt|;
comment|/*      * LDAP attribute to use for determining group membership      */
DECL|field|MEMBEROF_ATTR_KEY
specifier|public
specifier|static
specifier|final
name|String
name|MEMBEROF_ATTR_KEY
init|=
name|LDAP_CONFIG_PREFIX
operator|+
literal|".search.attr.memberof"
decl_stmt|;
DECL|field|MEMBEROF_ATTR_DEFAULT
specifier|public
specifier|static
specifier|final
name|String
name|MEMBEROF_ATTR_DEFAULT
init|=
literal|""
decl_stmt|;
comment|/*    * LDAP attribute to use for determining group membership    */
DECL|field|GROUP_MEMBERSHIP_ATTR_KEY
specifier|public
specifier|static
specifier|final
name|String
name|GROUP_MEMBERSHIP_ATTR_KEY
init|=
name|LDAP_CONFIG_PREFIX
operator|+
literal|".search.attr.member"
decl_stmt|;
DECL|field|GROUP_MEMBERSHIP_ATTR_DEFAULT
specifier|public
specifier|static
specifier|final
name|String
name|GROUP_MEMBERSHIP_ATTR_DEFAULT
init|=
literal|"member"
decl_stmt|;
comment|/*    * LDAP attribute to use for identifying a group's name    */
DECL|field|GROUP_NAME_ATTR_KEY
specifier|public
specifier|static
specifier|final
name|String
name|GROUP_NAME_ATTR_KEY
init|=
name|LDAP_CONFIG_PREFIX
operator|+
literal|".search.attr.group.name"
decl_stmt|;
DECL|field|GROUP_NAME_ATTR_DEFAULT
specifier|public
specifier|static
specifier|final
name|String
name|GROUP_NAME_ATTR_DEFAULT
init|=
literal|"cn"
decl_stmt|;
comment|/*    * LDAP attribute names to use when doing posix-like lookups    */
DECL|field|POSIX_UID_ATTR_KEY
specifier|public
specifier|static
specifier|final
name|String
name|POSIX_UID_ATTR_KEY
init|=
name|LDAP_CONFIG_PREFIX
operator|+
literal|".posix.attr.uid.name"
decl_stmt|;
DECL|field|POSIX_UID_ATTR_DEFAULT
specifier|public
specifier|static
specifier|final
name|String
name|POSIX_UID_ATTR_DEFAULT
init|=
literal|"uidNumber"
decl_stmt|;
DECL|field|POSIX_GID_ATTR_KEY
specifier|public
specifier|static
specifier|final
name|String
name|POSIX_GID_ATTR_KEY
init|=
name|LDAP_CONFIG_PREFIX
operator|+
literal|".posix.attr.gid.name"
decl_stmt|;
DECL|field|POSIX_GID_ATTR_DEFAULT
specifier|public
specifier|static
specifier|final
name|String
name|POSIX_GID_ATTR_DEFAULT
init|=
literal|"gidNumber"
decl_stmt|;
comment|/*    * Posix attributes    */
DECL|field|POSIX_GROUP
specifier|public
specifier|static
specifier|final
name|String
name|POSIX_GROUP
init|=
literal|"posixGroup"
decl_stmt|;
DECL|field|POSIX_ACCOUNT
specifier|public
specifier|static
specifier|final
name|String
name|POSIX_ACCOUNT
init|=
literal|"posixAccount"
decl_stmt|;
comment|/*    * LDAP {@link SearchControls} attribute to set the time limit    * for an invoked directory search. Prevents infinite wait cases.    */
DECL|field|DIRECTORY_SEARCH_TIMEOUT
specifier|public
specifier|static
specifier|final
name|String
name|DIRECTORY_SEARCH_TIMEOUT
init|=
name|LDAP_CONFIG_PREFIX
operator|+
literal|".directory.search.timeout"
decl_stmt|;
DECL|field|DIRECTORY_SEARCH_TIMEOUT_DEFAULT
specifier|public
specifier|static
specifier|final
name|int
name|DIRECTORY_SEARCH_TIMEOUT_DEFAULT
init|=
literal|10000
decl_stmt|;
comment|// 10s
DECL|field|CONNECTION_TIMEOUT
specifier|public
specifier|static
specifier|final
name|String
name|CONNECTION_TIMEOUT
init|=
name|LDAP_CONFIG_PREFIX
operator|+
literal|".connection.timeout.ms"
decl_stmt|;
DECL|field|CONNECTION_TIMEOUT_DEFAULT
specifier|public
specifier|static
specifier|final
name|int
name|CONNECTION_TIMEOUT_DEFAULT
init|=
literal|60
operator|*
literal|1000
decl_stmt|;
comment|// 60 seconds
DECL|field|READ_TIMEOUT
specifier|public
specifier|static
specifier|final
name|String
name|READ_TIMEOUT
init|=
name|LDAP_CONFIG_PREFIX
operator|+
literal|".read.timeout.ms"
decl_stmt|;
DECL|field|READ_TIMEOUT_DEFAULT
specifier|public
specifier|static
specifier|final
name|int
name|READ_TIMEOUT_DEFAULT
init|=
literal|60
operator|*
literal|1000
decl_stmt|;
comment|// 60 seconds
DECL|field|LOG
specifier|private
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|LdapGroupsMapping
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|SEARCH_CONTROLS
specifier|private
specifier|static
specifier|final
name|SearchControls
name|SEARCH_CONTROLS
init|=
operator|new
name|SearchControls
argument_list|()
decl_stmt|;
static|static
block|{
name|SEARCH_CONTROLS
operator|.
name|setSearchScope
argument_list|(
name|SearchControls
operator|.
name|SUBTREE_SCOPE
argument_list|)
expr_stmt|;
block|}
DECL|field|ctx
specifier|private
name|DirContext
name|ctx
decl_stmt|;
DECL|field|conf
specifier|private
name|Configuration
name|conf
decl_stmt|;
DECL|field|ldapUrl
specifier|private
name|String
name|ldapUrl
decl_stmt|;
DECL|field|useSsl
specifier|private
name|boolean
name|useSsl
decl_stmt|;
DECL|field|keystore
specifier|private
name|String
name|keystore
decl_stmt|;
DECL|field|keystorePass
specifier|private
name|String
name|keystorePass
decl_stmt|;
DECL|field|bindUser
specifier|private
name|String
name|bindUser
decl_stmt|;
DECL|field|bindPassword
specifier|private
name|String
name|bindPassword
decl_stmt|;
DECL|field|baseDN
specifier|private
name|String
name|baseDN
decl_stmt|;
DECL|field|groupSearchFilter
specifier|private
name|String
name|groupSearchFilter
decl_stmt|;
DECL|field|userSearchFilter
specifier|private
name|String
name|userSearchFilter
decl_stmt|;
DECL|field|memberOfAttr
specifier|private
name|String
name|memberOfAttr
decl_stmt|;
DECL|field|groupMemberAttr
specifier|private
name|String
name|groupMemberAttr
decl_stmt|;
DECL|field|groupNameAttr
specifier|private
name|String
name|groupNameAttr
decl_stmt|;
DECL|field|posixUidAttr
specifier|private
name|String
name|posixUidAttr
decl_stmt|;
DECL|field|posixGidAttr
specifier|private
name|String
name|posixGidAttr
decl_stmt|;
DECL|field|isPosix
specifier|private
name|boolean
name|isPosix
decl_stmt|;
DECL|field|useOneQuery
specifier|private
name|boolean
name|useOneQuery
decl_stmt|;
DECL|field|RECONNECT_RETRY_COUNT
specifier|public
specifier|static
specifier|final
name|int
name|RECONNECT_RETRY_COUNT
init|=
literal|3
decl_stmt|;
comment|/**    * Returns list of groups for a user.    *     * The LdapCtx which underlies the DirContext object is not thread-safe, so    * we need to block around this whole method. The caching infrastructure will    * ensure that performance stays in an acceptable range.    *    * @param user get groups for this user    * @return list of groups for a given user    */
annotation|@
name|Override
DECL|method|getGroups (String user)
specifier|public
specifier|synchronized
name|List
argument_list|<
name|String
argument_list|>
name|getGroups
parameter_list|(
name|String
name|user
parameter_list|)
block|{
comment|/*      * Normal garbage collection takes care of removing Context instances when they are no longer in use.       * Connections used by Context instances being garbage collected will be closed automatically.      * So in case connection is closed and gets CommunicationException, retry some times with new new DirContext/connection.       */
for|for
control|(
name|int
name|retry
init|=
literal|0
init|;
name|retry
operator|<
name|RECONNECT_RETRY_COUNT
condition|;
name|retry
operator|++
control|)
block|{
try|try
block|{
return|return
name|doGetGroups
argument_list|(
name|user
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NamingException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to get groups for user "
operator|+
name|user
operator|+
literal|" (retry="
operator|+
name|retry
operator|+
literal|") by "
operator|+
name|e
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|trace
argument_list|(
literal|"TRACE"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|//reset ctx so that new DirContext can be created with new connection
name|this
operator|.
name|ctx
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
comment|/**    * A helper method to get the Relative Distinguished Name (RDN) from    * Distinguished name (DN). According to Active Directory documentation,    * a group object's RDN is a CN.    *    * @param distinguishedName A string representing a distinguished name.    * @throws NamingException if the DN is malformed.    * @return a string which represents the RDN    */
DECL|method|getRelativeDistinguishedName (String distinguishedName)
specifier|private
name|String
name|getRelativeDistinguishedName
parameter_list|(
name|String
name|distinguishedName
parameter_list|)
throws|throws
name|NamingException
block|{
name|LdapName
name|ldn
init|=
operator|new
name|LdapName
argument_list|(
name|distinguishedName
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Rdn
argument_list|>
name|rdns
init|=
name|ldn
operator|.
name|getRdns
argument_list|()
decl_stmt|;
if|if
condition|(
name|rdns
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NamingException
argument_list|(
literal|"DN is empty"
argument_list|)
throw|;
block|}
name|Rdn
name|rdn
init|=
name|rdns
operator|.
name|get
argument_list|(
name|rdns
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|rdn
operator|.
name|getType
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|groupNameAttr
argument_list|)
condition|)
block|{
name|String
name|groupName
init|=
operator|(
name|String
operator|)
name|rdn
operator|.
name|getValue
argument_list|()
decl_stmt|;
return|return
name|groupName
return|;
block|}
throw|throw
operator|new
name|NamingException
argument_list|(
literal|"Unable to find RDN: The DN "
operator|+
name|distinguishedName
operator|+
literal|" is malformed."
argument_list|)
throw|;
block|}
comment|/**    * Look up groups using posixGroups semantics. Use posix gid/uid to find    * groups of the user.    *    * @param result the result object returned from the prior user lookup.    * @param c the context object of the LDAP connection.    * @return an object representing the search result.    *    * @throws NamingException if the server does not support posixGroups    * semantics.    */
DECL|method|lookupPosixGroup (SearchResult result, DirContext c)
specifier|private
name|NamingEnumeration
argument_list|<
name|SearchResult
argument_list|>
name|lookupPosixGroup
parameter_list|(
name|SearchResult
name|result
parameter_list|,
name|DirContext
name|c
parameter_list|)
throws|throws
name|NamingException
block|{
name|String
name|gidNumber
init|=
literal|null
decl_stmt|;
name|String
name|uidNumber
init|=
literal|null
decl_stmt|;
name|Attribute
name|gidAttribute
init|=
name|result
operator|.
name|getAttributes
argument_list|()
operator|.
name|get
argument_list|(
name|posixGidAttr
argument_list|)
decl_stmt|;
name|Attribute
name|uidAttribute
init|=
name|result
operator|.
name|getAttributes
argument_list|()
operator|.
name|get
argument_list|(
name|posixUidAttr
argument_list|)
decl_stmt|;
name|String
name|reason
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|gidAttribute
operator|==
literal|null
condition|)
block|{
name|reason
operator|=
literal|"Can't find attribute '"
operator|+
name|posixGidAttr
operator|+
literal|"'."
expr_stmt|;
block|}
else|else
block|{
name|gidNumber
operator|=
name|gidAttribute
operator|.
name|get
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|uidAttribute
operator|==
literal|null
condition|)
block|{
name|reason
operator|=
literal|"Can't find attribute '"
operator|+
name|posixUidAttr
operator|+
literal|"'."
expr_stmt|;
block|}
else|else
block|{
name|uidNumber
operator|=
name|uidAttribute
operator|.
name|get
argument_list|()
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|uidNumber
operator|!=
literal|null
operator|&&
name|gidNumber
operator|!=
literal|null
condition|)
block|{
return|return
name|c
operator|.
name|search
argument_list|(
name|baseDN
argument_list|,
literal|"(&"
operator|+
name|groupSearchFilter
operator|+
literal|"(|("
operator|+
name|posixGidAttr
operator|+
literal|"={0})"
operator|+
literal|"("
operator|+
name|groupMemberAttr
operator|+
literal|"={1})))"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|gidNumber
block|,
name|uidNumber
block|}
argument_list|,
name|SEARCH_CONTROLS
argument_list|)
return|;
block|}
throw|throw
operator|new
name|NamingException
argument_list|(
literal|"The server does not support posixGroups "
operator|+
literal|"semantics. Reason: "
operator|+
name|reason
operator|+
literal|" Returned user object: "
operator|+
name|result
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
comment|/**    * Perform the second query to get the groups of the user.    *    * If posixGroups is enabled, use use posix gid/uid to find.    * Otherwise, use the general group member attribute to find it.    *    * @param result the result object returned from the prior user lookup.    * @param c the context object of the LDAP connection.    * @return a list of strings representing group names of the user.    * @throws NamingException if unable to find group names    */
DECL|method|lookupGroup (SearchResult result, DirContext c)
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|lookupGroup
parameter_list|(
name|SearchResult
name|result
parameter_list|,
name|DirContext
name|c
parameter_list|)
throws|throws
name|NamingException
block|{
name|List
argument_list|<
name|String
argument_list|>
name|groups
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|NamingEnumeration
argument_list|<
name|SearchResult
argument_list|>
name|groupResults
init|=
literal|null
decl_stmt|;
comment|// perform the second LDAP query
if|if
condition|(
name|isPosix
condition|)
block|{
name|groupResults
operator|=
name|lookupPosixGroup
argument_list|(
name|result
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|userDn
init|=
name|result
operator|.
name|getNameInNamespace
argument_list|()
decl_stmt|;
name|groupResults
operator|=
name|c
operator|.
name|search
argument_list|(
name|baseDN
argument_list|,
literal|"(&"
operator|+
name|groupSearchFilter
operator|+
literal|"("
operator|+
name|groupMemberAttr
operator|+
literal|"={0}))"
argument_list|,
operator|new
name|Object
index|[]
block|{
name|userDn
block|}
argument_list|,
name|SEARCH_CONTROLS
argument_list|)
expr_stmt|;
block|}
comment|// if the second query is successful, group objects of the user will be
comment|// returned. Get group names from the returned objects.
if|if
condition|(
name|groupResults
operator|!=
literal|null
condition|)
block|{
while|while
condition|(
name|groupResults
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
name|SearchResult
name|groupResult
init|=
name|groupResults
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|Attribute
name|groupName
init|=
name|groupResult
operator|.
name|getAttributes
argument_list|()
operator|.
name|get
argument_list|(
name|groupNameAttr
argument_list|)
decl_stmt|;
if|if
condition|(
name|groupName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NamingException
argument_list|(
literal|"The group object does not have "
operator|+
literal|"attribute '"
operator|+
name|groupNameAttr
operator|+
literal|"'."
argument_list|)
throw|;
block|}
name|groups
operator|.
name|add
argument_list|(
name|groupName
operator|.
name|get
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|groups
return|;
block|}
comment|/**    * Perform LDAP queries to get group names of a user.    *    * Perform the first LDAP query to get the user object using the user's name.    * If one-query is enabled, retrieve the group names from the user object.    * If one-query is disabled, or if it failed, perform the second query to    * get the groups.    *    * @param user user name    * @return a list of group names for the user. If the user can not be found,    * return an empty string array.    * @throws NamingException if unable to get group names    */
DECL|method|doGetGroups (String user)
name|List
argument_list|<
name|String
argument_list|>
name|doGetGroups
parameter_list|(
name|String
name|user
parameter_list|)
throws|throws
name|NamingException
block|{
name|DirContext
name|c
init|=
name|getDirContext
argument_list|()
decl_stmt|;
comment|// Search for the user. We'll only ever need to look at the first result
name|NamingEnumeration
argument_list|<
name|SearchResult
argument_list|>
name|results
init|=
name|c
operator|.
name|search
argument_list|(
name|baseDN
argument_list|,
name|userSearchFilter
argument_list|,
operator|new
name|Object
index|[]
block|{
name|user
block|}
argument_list|,
name|SEARCH_CONTROLS
argument_list|)
decl_stmt|;
comment|// return empty list if the user can not be found.
if|if
condition|(
operator|!
name|results
operator|.
name|hasMoreElements
argument_list|()
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"doGetGroups("
operator|+
name|user
operator|+
literal|") return no groups because the "
operator|+
literal|"user is not found."
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
return|;
block|}
name|SearchResult
name|result
init|=
name|results
operator|.
name|nextElement
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|groups
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|useOneQuery
condition|)
block|{
try|try
block|{
comment|/**          * For Active Directory servers, the user object has an attribute          * 'memberOf' that represents the DNs of group objects to which the          * user belongs. So the second query may be skipped.          */
name|Attribute
name|groupDNAttr
init|=
name|result
operator|.
name|getAttributes
argument_list|()
operator|.
name|get
argument_list|(
name|memberOfAttr
argument_list|)
decl_stmt|;
if|if
condition|(
name|groupDNAttr
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NamingException
argument_list|(
literal|"The user object does not have '"
operator|+
name|memberOfAttr
operator|+
literal|"' attribute."
operator|+
literal|"Returned user object: "
operator|+
name|result
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|groups
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|NamingEnumeration
name|groupEnumeration
init|=
name|groupDNAttr
operator|.
name|getAll
argument_list|()
decl_stmt|;
while|while
condition|(
name|groupEnumeration
operator|.
name|hasMore
argument_list|()
condition|)
block|{
name|String
name|groupDN
init|=
name|groupEnumeration
operator|.
name|next
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
name|groups
operator|.
name|add
argument_list|(
name|getRelativeDistinguishedName
argument_list|(
name|groupDN
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NamingException
name|e
parameter_list|)
block|{
comment|// If the first lookup failed, fall back to the typical scenario.
name|LOG
operator|.
name|info
argument_list|(
literal|"Failed to get groups from the first lookup. Initiating "
operator|+
literal|"the second LDAP query using the user's DN."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|groups
operator|==
literal|null
operator|||
name|groups
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|groups
operator|=
name|lookupGroup
argument_list|(
name|result
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"doGetGroups("
operator|+
name|user
operator|+
literal|") return "
operator|+
name|groups
argument_list|)
expr_stmt|;
block|}
return|return
name|groups
return|;
block|}
DECL|method|getDirContext ()
name|DirContext
name|getDirContext
parameter_list|()
throws|throws
name|NamingException
block|{
if|if
condition|(
name|ctx
operator|==
literal|null
condition|)
block|{
comment|// Set up the initial environment for LDAP connectivity
name|Hashtable
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|env
init|=
operator|new
name|Hashtable
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|env
operator|.
name|put
argument_list|(
name|Context
operator|.
name|INITIAL_CONTEXT_FACTORY
argument_list|,
name|com
operator|.
name|sun
operator|.
name|jndi
operator|.
name|ldap
operator|.
name|LdapCtxFactory
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|env
operator|.
name|put
argument_list|(
name|Context
operator|.
name|PROVIDER_URL
argument_list|,
name|ldapUrl
argument_list|)
expr_stmt|;
name|env
operator|.
name|put
argument_list|(
name|Context
operator|.
name|SECURITY_AUTHENTICATION
argument_list|,
literal|"simple"
argument_list|)
expr_stmt|;
comment|// Set up SSL security, if necessary
if|if
condition|(
name|useSsl
condition|)
block|{
name|env
operator|.
name|put
argument_list|(
name|Context
operator|.
name|SECURITY_PROTOCOL
argument_list|,
literal|"ssl"
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
literal|"javax.net.ssl.keyStore"
argument_list|,
name|keystore
argument_list|)
expr_stmt|;
name|System
operator|.
name|setProperty
argument_list|(
literal|"javax.net.ssl.keyStorePassword"
argument_list|,
name|keystorePass
argument_list|)
expr_stmt|;
block|}
name|env
operator|.
name|put
argument_list|(
name|Context
operator|.
name|SECURITY_PRINCIPAL
argument_list|,
name|bindUser
argument_list|)
expr_stmt|;
name|env
operator|.
name|put
argument_list|(
name|Context
operator|.
name|SECURITY_CREDENTIALS
argument_list|,
name|bindPassword
argument_list|)
expr_stmt|;
name|env
operator|.
name|put
argument_list|(
literal|"com.sun.jndi.ldap.connect.timeout"
argument_list|,
name|conf
operator|.
name|get
argument_list|(
name|CONNECTION_TIMEOUT
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|CONNECTION_TIMEOUT_DEFAULT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|env
operator|.
name|put
argument_list|(
literal|"com.sun.jndi.ldap.read.timeout"
argument_list|,
name|conf
operator|.
name|get
argument_list|(
name|READ_TIMEOUT
argument_list|,
name|String
operator|.
name|valueOf
argument_list|(
name|READ_TIMEOUT_DEFAULT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|=
operator|new
name|InitialDirContext
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
return|return
name|ctx
return|;
block|}
comment|/**    * Caches groups, no need to do that for this provider    */
annotation|@
name|Override
DECL|method|cacheGroupsRefresh ()
specifier|public
name|void
name|cacheGroupsRefresh
parameter_list|()
throws|throws
name|IOException
block|{
comment|// does nothing in this provider of user to groups mapping
block|}
comment|/**     * Adds groups to cache, no need to do that for this provider    *    * @param groups unused    */
annotation|@
name|Override
DECL|method|cacheGroupsAdd (List<String> groups)
specifier|public
name|void
name|cacheGroupsAdd
parameter_list|(
name|List
argument_list|<
name|String
argument_list|>
name|groups
parameter_list|)
throws|throws
name|IOException
block|{
comment|// does nothing in this provider of user to groups mapping
block|}
annotation|@
name|Override
DECL|method|getConf ()
specifier|public
specifier|synchronized
name|Configuration
name|getConf
parameter_list|()
block|{
return|return
name|conf
return|;
block|}
annotation|@
name|Override
DECL|method|setConf (Configuration conf)
specifier|public
specifier|synchronized
name|void
name|setConf
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|ldapUrl
operator|=
name|conf
operator|.
name|get
argument_list|(
name|LDAP_URL_KEY
argument_list|,
name|LDAP_URL_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldapUrl
operator|==
literal|null
operator|||
name|ldapUrl
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"LDAP URL is not configured"
argument_list|)
throw|;
block|}
name|useSsl
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|LDAP_USE_SSL_KEY
argument_list|,
name|LDAP_USE_SSL_DEFAULT
argument_list|)
expr_stmt|;
name|keystore
operator|=
name|conf
operator|.
name|get
argument_list|(
name|LDAP_KEYSTORE_KEY
argument_list|,
name|LDAP_KEYSTORE_DEFAULT
argument_list|)
expr_stmt|;
name|keystorePass
operator|=
name|getPassword
argument_list|(
name|conf
argument_list|,
name|LDAP_KEYSTORE_PASSWORD_KEY
argument_list|,
name|LDAP_KEYSTORE_PASSWORD_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|keystorePass
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|keystorePass
operator|=
name|extractPassword
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|LDAP_KEYSTORE_PASSWORD_FILE_KEY
argument_list|,
name|LDAP_KEYSTORE_PASSWORD_FILE_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bindUser
operator|=
name|conf
operator|.
name|get
argument_list|(
name|BIND_USER_KEY
argument_list|,
name|BIND_USER_DEFAULT
argument_list|)
expr_stmt|;
name|bindPassword
operator|=
name|getPassword
argument_list|(
name|conf
argument_list|,
name|BIND_PASSWORD_KEY
argument_list|,
name|BIND_PASSWORD_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bindPassword
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|bindPassword
operator|=
name|extractPassword
argument_list|(
name|conf
operator|.
name|get
argument_list|(
name|BIND_PASSWORD_FILE_KEY
argument_list|,
name|BIND_PASSWORD_FILE_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|baseDN
operator|=
name|conf
operator|.
name|get
argument_list|(
name|BASE_DN_KEY
argument_list|,
name|BASE_DN_DEFAULT
argument_list|)
expr_stmt|;
name|groupSearchFilter
operator|=
name|conf
operator|.
name|get
argument_list|(
name|GROUP_SEARCH_FILTER_KEY
argument_list|,
name|GROUP_SEARCH_FILTER_DEFAULT
argument_list|)
expr_stmt|;
name|userSearchFilter
operator|=
name|conf
operator|.
name|get
argument_list|(
name|USER_SEARCH_FILTER_KEY
argument_list|,
name|USER_SEARCH_FILTER_DEFAULT
argument_list|)
expr_stmt|;
name|isPosix
operator|=
name|groupSearchFilter
operator|.
name|contains
argument_list|(
name|POSIX_GROUP
argument_list|)
operator|&&
name|userSearchFilter
operator|.
name|contains
argument_list|(
name|POSIX_ACCOUNT
argument_list|)
expr_stmt|;
name|memberOfAttr
operator|=
name|conf
operator|.
name|get
argument_list|(
name|MEMBEROF_ATTR_KEY
argument_list|,
name|MEMBEROF_ATTR_DEFAULT
argument_list|)
expr_stmt|;
comment|// if memberOf attribute is set, resolve group names from the attribute
comment|// of user objects.
name|useOneQuery
operator|=
operator|!
name|memberOfAttr
operator|.
name|isEmpty
argument_list|()
expr_stmt|;
name|groupMemberAttr
operator|=
name|conf
operator|.
name|get
argument_list|(
name|GROUP_MEMBERSHIP_ATTR_KEY
argument_list|,
name|GROUP_MEMBERSHIP_ATTR_DEFAULT
argument_list|)
expr_stmt|;
name|groupNameAttr
operator|=
name|conf
operator|.
name|get
argument_list|(
name|GROUP_NAME_ATTR_KEY
argument_list|,
name|GROUP_NAME_ATTR_DEFAULT
argument_list|)
expr_stmt|;
name|posixUidAttr
operator|=
name|conf
operator|.
name|get
argument_list|(
name|POSIX_UID_ATTR_KEY
argument_list|,
name|POSIX_UID_ATTR_DEFAULT
argument_list|)
expr_stmt|;
name|posixGidAttr
operator|=
name|conf
operator|.
name|get
argument_list|(
name|POSIX_GID_ATTR_KEY
argument_list|,
name|POSIX_GID_ATTR_DEFAULT
argument_list|)
expr_stmt|;
name|int
name|dirSearchTimeout
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|DIRECTORY_SEARCH_TIMEOUT
argument_list|,
name|DIRECTORY_SEARCH_TIMEOUT_DEFAULT
argument_list|)
decl_stmt|;
name|SEARCH_CONTROLS
operator|.
name|setTimeLimit
argument_list|(
name|dirSearchTimeout
argument_list|)
expr_stmt|;
comment|// Limit the attributes returned to only those required to speed up the search.
comment|// See HADOOP-10626 and HADOOP-12001 for more details.
name|String
index|[]
name|returningAttributes
decl_stmt|;
if|if
condition|(
name|useOneQuery
condition|)
block|{
name|returningAttributes
operator|=
operator|new
name|String
index|[]
block|{
name|groupNameAttr
block|,
name|posixUidAttr
block|,
name|posixGidAttr
block|,
name|memberOfAttr
block|}
expr_stmt|;
block|}
else|else
block|{
name|returningAttributes
operator|=
operator|new
name|String
index|[]
block|{
name|groupNameAttr
block|,
name|posixUidAttr
block|,
name|posixGidAttr
block|}
expr_stmt|;
block|}
name|SEARCH_CONTROLS
operator|.
name|setReturningAttributes
argument_list|(
name|returningAttributes
argument_list|)
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
block|}
DECL|method|getPassword (Configuration conf, String alias, String defaultPass)
name|String
name|getPassword
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|String
name|alias
parameter_list|,
name|String
name|defaultPass
parameter_list|)
block|{
name|String
name|password
init|=
literal|null
decl_stmt|;
try|try
block|{
name|char
index|[]
name|passchars
init|=
name|conf
operator|.
name|getPassword
argument_list|(
name|alias
argument_list|)
decl_stmt|;
if|if
condition|(
name|passchars
operator|!=
literal|null
condition|)
block|{
name|password
operator|=
operator|new
name|String
argument_list|(
name|passchars
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|password
operator|=
name|defaultPass
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception while trying to password for alias "
operator|+
name|alias
operator|+
literal|": "
operator|+
name|ioe
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|password
return|;
block|}
DECL|method|extractPassword (String pwFile)
name|String
name|extractPassword
parameter_list|(
name|String
name|pwFile
parameter_list|)
block|{
if|if
condition|(
name|pwFile
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// If there is no password file defined, we'll assume that we should do
comment|// an anonymous bind
return|return
literal|""
return|;
block|}
name|StringBuilder
name|password
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
try|try
init|(
name|Reader
name|reader
init|=
operator|new
name|InputStreamReader
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|pwFile
argument_list|)
argument_list|,
name|Charsets
operator|.
name|UTF_8
argument_list|)
init|)
block|{
name|int
name|c
init|=
name|reader
operator|.
name|read
argument_list|()
decl_stmt|;
while|while
condition|(
name|c
operator|>
operator|-
literal|1
condition|)
block|{
name|password
operator|.
name|append
argument_list|(
operator|(
name|char
operator|)
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|reader
operator|.
name|read
argument_list|()
expr_stmt|;
block|}
return|return
name|password
operator|.
name|toString
argument_list|()
operator|.
name|trim
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not read password file: "
operator|+
name|pwFile
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

