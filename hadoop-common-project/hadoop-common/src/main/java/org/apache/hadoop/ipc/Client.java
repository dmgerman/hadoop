begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/**  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.ipc
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactoryBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceAudience
operator|.
name|Public
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|classification
operator|.
name|InterfaceStability
operator|.
name|Unstable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|conf
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeys
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|fs
operator|.
name|CommonConfigurationKeysPublic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|Writable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|WritableUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|RetryPolicies
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|RetryPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
operator|.
name|RetryPolicy
operator|.
name|RetryAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RPC
operator|.
name|RpcKind
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|Server
operator|.
name|AuthProtocol
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|protobuf
operator|.
name|IpcConnectionContextProtos
operator|.
name|IpcConnectionContextProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|protobuf
operator|.
name|RpcHeaderProtos
operator|.
name|RpcRequestHeaderProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|protobuf
operator|.
name|RpcHeaderProtos
operator|.
name|RpcRequestHeaderProto
operator|.
name|OperationProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|protobuf
operator|.
name|RpcHeaderProtos
operator|.
name|RpcResponseHeaderProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|protobuf
operator|.
name|RpcHeaderProtos
operator|.
name|RpcResponseHeaderProto
operator|.
name|RpcErrorCodeProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|protobuf
operator|.
name|RpcHeaderProtos
operator|.
name|RpcResponseHeaderProto
operator|.
name|RpcStatusProto
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|ConnectTimeoutException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|net
operator|.
name|NetUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|KerberosInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SaslRpcClient
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SaslRpcServer
operator|.
name|AuthMethod
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|SecurityUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|security
operator|.
name|UserGroupInformation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|ProtoUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|Time
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|util
operator|.
name|concurrent
operator|.
name|AsyncGet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|core
operator|.
name|Span
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|htrace
operator|.
name|core
operator|.
name|Tracer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|slf4j
operator|.
name|LoggerFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|net
operator|.
name|SocketFactory
import|;
end_import

begin_import
import|import
name|javax
operator|.
name|security
operator|.
name|sasl
operator|.
name|Sasl
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RpcConstants
operator|.
name|CONNECTION_CONTEXT_CALL_ID
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RpcConstants
operator|.
name|PING_CALL_ID
import|;
end_import

begin_comment
comment|/** A client for an IPC service.  IPC calls take a single {@link Writable} as a  * parameter, and return a {@link Writable} as their value.  A service runs on  * a port and is defined by a parameter class and a value class.  *   * @see Server  */
end_comment

begin_class
annotation|@
name|Public
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|Client
specifier|public
class|class
name|Client
implements|implements
name|AutoCloseable
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Logger
name|LOG
init|=
name|LoggerFactory
operator|.
name|getLogger
argument_list|(
name|Client
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** A counter for generating call IDs. */
DECL|field|callIdCounter
specifier|private
specifier|static
specifier|final
name|AtomicInteger
name|callIdCounter
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|field|callId
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|Integer
argument_list|>
name|callId
init|=
operator|new
name|ThreadLocal
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|retryCount
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|Integer
argument_list|>
name|retryCount
init|=
operator|new
name|ThreadLocal
argument_list|<
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|EXTERNAL_CALL_HANDLER
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|Object
argument_list|>
name|EXTERNAL_CALL_HANDLER
init|=
operator|new
name|ThreadLocal
argument_list|<>
argument_list|()
decl_stmt|;
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|AsyncGet
argument_list|<
name|?
extends|extends
name|Writable
argument_list|,
name|IOException
argument_list|>
argument_list|>
DECL|field|ASYNC_RPC_RESPONSE
name|ASYNC_RPC_RESPONSE
init|=
operator|new
name|ThreadLocal
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|asynchronousMode
specifier|private
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|Boolean
argument_list|>
name|asynchronousMode
init|=
operator|new
name|ThreadLocal
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|Boolean
name|initialValue
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
block|}
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
annotation|@
name|Unstable
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|Writable
parameter_list|>
name|AsyncGet
argument_list|<
name|T
argument_list|,
name|IOException
argument_list|>
DECL|method|getAsyncRpcResponse ()
name|getAsyncRpcResponse
parameter_list|()
block|{
return|return
operator|(
name|AsyncGet
argument_list|<
name|T
argument_list|,
name|IOException
argument_list|>
operator|)
name|ASYNC_RPC_RESPONSE
operator|.
name|get
argument_list|()
return|;
block|}
comment|/** Set call id and retry count for the next call. */
DECL|method|setCallIdAndRetryCount (int cid, int rc, Object externalHandler)
specifier|public
specifier|static
name|void
name|setCallIdAndRetryCount
parameter_list|(
name|int
name|cid
parameter_list|,
name|int
name|rc
parameter_list|,
name|Object
name|externalHandler
parameter_list|)
block|{
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|cid
operator|!=
name|RpcConstants
operator|.
name|INVALID_CALL_ID
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkState
argument_list|(
name|callId
operator|.
name|get
argument_list|()
operator|==
literal|null
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkArgument
argument_list|(
name|rc
operator|!=
name|RpcConstants
operator|.
name|INVALID_RETRY_COUNT
argument_list|)
expr_stmt|;
name|callId
operator|.
name|set
argument_list|(
name|cid
argument_list|)
expr_stmt|;
name|retryCount
operator|.
name|set
argument_list|(
name|rc
argument_list|)
expr_stmt|;
name|EXTERNAL_CALL_HANDLER
operator|.
name|set
argument_list|(
name|externalHandler
argument_list|)
expr_stmt|;
block|}
DECL|field|connections
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|ConnectionId
argument_list|,
name|Connection
argument_list|>
name|connections
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|putLock
specifier|private
specifier|final
name|Object
name|putLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|emptyCondition
specifier|private
specifier|final
name|Object
name|emptyCondition
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|running
specifier|private
specifier|final
name|AtomicBoolean
name|running
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
decl_stmt|;
DECL|field|valueClass
specifier|private
name|Class
argument_list|<
name|?
extends|extends
name|Writable
argument_list|>
name|valueClass
decl_stmt|;
comment|// class of call values
DECL|field|conf
specifier|final
specifier|private
name|Configuration
name|conf
decl_stmt|;
DECL|field|socketFactory
specifier|private
name|SocketFactory
name|socketFactory
decl_stmt|;
comment|// how to create sockets
DECL|field|refCount
specifier|private
specifier|final
name|AtomicInteger
name|refCount
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|field|connectionTimeout
specifier|private
specifier|final
name|int
name|connectionTimeout
decl_stmt|;
DECL|field|fallbackAllowed
specifier|private
specifier|final
name|boolean
name|fallbackAllowed
decl_stmt|;
DECL|field|bindToWildCardAddress
specifier|private
specifier|final
name|boolean
name|bindToWildCardAddress
decl_stmt|;
DECL|field|clientId
specifier|private
specifier|final
name|byte
index|[]
name|clientId
decl_stmt|;
DECL|field|maxAsyncCalls
specifier|private
specifier|final
name|int
name|maxAsyncCalls
decl_stmt|;
DECL|field|asyncCallCounter
specifier|private
specifier|final
name|AtomicInteger
name|asyncCallCounter
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/**    * Executor on which IPC calls' parameters are sent.    * Deferring the sending of parameters to a separate    * thread isolates them from thread interruptions in the    * calling code.    */
DECL|field|sendParamsExecutor
specifier|private
specifier|final
name|ExecutorService
name|sendParamsExecutor
decl_stmt|;
DECL|field|clientExcecutorFactory
specifier|private
specifier|final
specifier|static
name|ClientExecutorServiceFactory
name|clientExcecutorFactory
init|=
operator|new
name|ClientExecutorServiceFactory
argument_list|()
decl_stmt|;
DECL|class|ClientExecutorServiceFactory
specifier|private
specifier|static
class|class
name|ClientExecutorServiceFactory
block|{
DECL|field|executorRefCount
specifier|private
name|int
name|executorRefCount
init|=
literal|0
decl_stmt|;
DECL|field|clientExecutor
specifier|private
name|ExecutorService
name|clientExecutor
init|=
literal|null
decl_stmt|;
comment|/**      * Get Executor on which IPC calls' parameters are sent.      * If the internal reference counter is zero, this method      * creates the instance of Executor. If not, this method      * just returns the reference of clientExecutor.      *       * @return An ExecutorService instance      */
DECL|method|refAndGetInstance ()
specifier|synchronized
name|ExecutorService
name|refAndGetInstance
parameter_list|()
block|{
if|if
condition|(
name|executorRefCount
operator|==
literal|0
condition|)
block|{
name|clientExecutor
operator|=
name|Executors
operator|.
name|newCachedThreadPool
argument_list|(
operator|new
name|ThreadFactoryBuilder
argument_list|()
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
operator|.
name|setNameFormat
argument_list|(
literal|"IPC Parameter Sending Thread #%d"
argument_list|)
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|executorRefCount
operator|++
expr_stmt|;
return|return
name|clientExecutor
return|;
block|}
comment|/**      * Cleanup Executor on which IPC calls' parameters are sent.      * If reference counter is zero, this method discards the      * instance of the Executor. If not, this method      * just decrements the internal reference counter.      *       * @return An ExecutorService instance if it exists.      *   Null is returned if not.      */
DECL|method|unrefAndCleanup ()
specifier|synchronized
name|ExecutorService
name|unrefAndCleanup
parameter_list|()
block|{
name|executorRefCount
operator|--
expr_stmt|;
assert|assert
operator|(
name|executorRefCount
operator|>=
literal|0
operator|)
assert|;
if|if
condition|(
name|executorRefCount
operator|==
literal|0
condition|)
block|{
name|clientExecutor
operator|.
name|shutdown
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|clientExecutor
operator|.
name|awaitTermination
argument_list|(
literal|1
argument_list|,
name|TimeUnit
operator|.
name|MINUTES
argument_list|)
condition|)
block|{
name|clientExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted while waiting for clientExecutor"
operator|+
literal|" to stop"
argument_list|)
expr_stmt|;
name|clientExecutor
operator|.
name|shutdownNow
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
name|clientExecutor
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|clientExecutor
return|;
block|}
block|}
comment|/**    * set the ping interval value in configuration    *     * @param conf Configuration    * @param pingInterval the ping interval    */
DECL|method|setPingInterval (Configuration conf, int pingInterval)
specifier|public
specifier|static
specifier|final
name|void
name|setPingInterval
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|int
name|pingInterval
parameter_list|)
block|{
name|conf
operator|.
name|setInt
argument_list|(
name|CommonConfigurationKeys
operator|.
name|IPC_PING_INTERVAL_KEY
argument_list|,
name|pingInterval
argument_list|)
expr_stmt|;
block|}
comment|/**    * Get the ping interval from configuration;    * If not set in the configuration, return the default value.    *     * @param conf Configuration    * @return the ping interval    */
DECL|method|getPingInterval (Configuration conf)
specifier|public
specifier|static
specifier|final
name|int
name|getPingInterval
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
return|return
name|conf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeys
operator|.
name|IPC_PING_INTERVAL_KEY
argument_list|,
name|CommonConfigurationKeys
operator|.
name|IPC_PING_INTERVAL_DEFAULT
argument_list|)
return|;
block|}
comment|/**    * The time after which a RPC will timeout.    * If ping is not enabled (via ipc.client.ping), then the timeout value is the     * same as the pingInterval.    * If ping is enabled, then there is no timeout value.    *     * @param conf Configuration    * @return the timeout period in milliseconds. -1 if no timeout value is set    * @deprecated use {@link #getRpcTimeout(Configuration)} instead    */
annotation|@
name|Deprecated
DECL|method|getTimeout (Configuration conf)
specifier|final
specifier|public
specifier|static
name|int
name|getTimeout
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|int
name|timeout
init|=
name|getRpcTimeout
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
return|return
name|timeout
return|;
block|}
if|if
condition|(
operator|!
name|conf
operator|.
name|getBoolean
argument_list|(
name|CommonConfigurationKeys
operator|.
name|IPC_CLIENT_PING_KEY
argument_list|,
name|CommonConfigurationKeys
operator|.
name|IPC_CLIENT_PING_DEFAULT
argument_list|)
condition|)
block|{
return|return
name|getPingInterval
argument_list|(
name|conf
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**    * The time after which a RPC will timeout.    *    * @param conf Configuration    * @return the timeout period in milliseconds.    */
DECL|method|getRpcTimeout (Configuration conf)
specifier|public
specifier|static
specifier|final
name|int
name|getRpcTimeout
parameter_list|(
name|Configuration
name|conf
parameter_list|)
block|{
name|int
name|timeout
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeys
operator|.
name|IPC_CLIENT_RPC_TIMEOUT_KEY
argument_list|,
name|CommonConfigurationKeys
operator|.
name|IPC_CLIENT_RPC_TIMEOUT_DEFAULT
argument_list|)
decl_stmt|;
return|return
operator|(
name|timeout
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|timeout
return|;
block|}
comment|/**    * set the connection timeout value in configuration    *     * @param conf Configuration    * @param timeout the socket connect timeout value    */
DECL|method|setConnectTimeout (Configuration conf, int timeout)
specifier|public
specifier|static
specifier|final
name|void
name|setConnectTimeout
parameter_list|(
name|Configuration
name|conf
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|conf
operator|.
name|setInt
argument_list|(
name|CommonConfigurationKeys
operator|.
name|IPC_CLIENT_CONNECT_TIMEOUT_KEY
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getClientExecutor ()
specifier|public
specifier|static
specifier|final
name|ExecutorService
name|getClientExecutor
parameter_list|()
block|{
return|return
name|Client
operator|.
name|clientExcecutorFactory
operator|.
name|clientExecutor
return|;
block|}
comment|/**    * Increment this client's reference count    */
DECL|method|incCount ()
name|void
name|incCount
parameter_list|()
block|{
name|refCount
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
comment|/**    * Decrement this client's reference count    */
DECL|method|decAndGetCount ()
name|int
name|decAndGetCount
parameter_list|()
block|{
return|return
name|refCount
operator|.
name|decrementAndGet
argument_list|()
return|;
block|}
comment|/** Check the rpc response header. */
DECL|method|checkResponse (RpcResponseHeaderProto header)
name|void
name|checkResponse
parameter_list|(
name|RpcResponseHeaderProto
name|header
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|header
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|EOFException
argument_list|(
literal|"Response is null."
argument_list|)
throw|;
block|}
if|if
condition|(
name|header
operator|.
name|hasClientId
argument_list|()
condition|)
block|{
comment|// check client IDs
specifier|final
name|byte
index|[]
name|id
init|=
name|header
operator|.
name|getClientId
argument_list|()
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|id
argument_list|,
name|RpcConstants
operator|.
name|DUMMY_CLIENT_ID
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|id
argument_list|,
name|clientId
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Client IDs not matched: local ID="
operator|+
name|StringUtils
operator|.
name|byteToHexString
argument_list|(
name|clientId
argument_list|)
operator|+
literal|", ID in response="
operator|+
name|StringUtils
operator|.
name|byteToHexString
argument_list|(
name|header
operator|.
name|getClientId
argument_list|()
operator|.
name|toByteArray
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
block|}
DECL|method|createCall (RPC.RpcKind rpcKind, Writable rpcRequest)
name|Call
name|createCall
parameter_list|(
name|RPC
operator|.
name|RpcKind
name|rpcKind
parameter_list|,
name|Writable
name|rpcRequest
parameter_list|)
block|{
return|return
operator|new
name|Call
argument_list|(
name|rpcKind
argument_list|,
name|rpcRequest
argument_list|)
return|;
block|}
comment|/**     * Class that represents an RPC call    */
DECL|class|Call
specifier|static
class|class
name|Call
block|{
DECL|field|id
specifier|final
name|int
name|id
decl_stmt|;
comment|// call id
DECL|field|retry
specifier|final
name|int
name|retry
decl_stmt|;
comment|// retry count
DECL|field|rpcRequest
specifier|final
name|Writable
name|rpcRequest
decl_stmt|;
comment|// the serialized rpc request
DECL|field|rpcResponse
name|Writable
name|rpcResponse
decl_stmt|;
comment|// null if rpc has error
DECL|field|error
name|IOException
name|error
decl_stmt|;
comment|// exception, null if success
DECL|field|rpcKind
specifier|final
name|RPC
operator|.
name|RpcKind
name|rpcKind
decl_stmt|;
comment|// Rpc EngineKind
DECL|field|done
name|boolean
name|done
decl_stmt|;
comment|// true when call is done
DECL|field|externalHandler
specifier|private
specifier|final
name|Object
name|externalHandler
decl_stmt|;
DECL|field|alignmentContext
specifier|private
name|AlignmentContext
name|alignmentContext
decl_stmt|;
DECL|method|Call (RPC.RpcKind rpcKind, Writable param)
specifier|private
name|Call
parameter_list|(
name|RPC
operator|.
name|RpcKind
name|rpcKind
parameter_list|,
name|Writable
name|param
parameter_list|)
block|{
name|this
operator|.
name|rpcKind
operator|=
name|rpcKind
expr_stmt|;
name|this
operator|.
name|rpcRequest
operator|=
name|param
expr_stmt|;
specifier|final
name|Integer
name|id
init|=
name|callId
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|id
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|id
operator|=
name|nextCallId
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|callId
operator|.
name|set
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
block|}
specifier|final
name|Integer
name|rc
init|=
name|retryCount
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|rc
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|retry
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|retry
operator|=
name|rc
expr_stmt|;
block|}
name|this
operator|.
name|externalHandler
operator|=
name|EXTERNAL_CALL_HANDLER
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
name|id
return|;
block|}
comment|/** Indicate when the call is complete and the      * value or error are available.  Notifies by default.  */
DECL|method|callComplete ()
specifier|protected
specifier|synchronized
name|void
name|callComplete
parameter_list|()
block|{
name|this
operator|.
name|done
operator|=
literal|true
expr_stmt|;
name|notify
argument_list|()
expr_stmt|;
comment|// notify caller
if|if
condition|(
name|externalHandler
operator|!=
literal|null
condition|)
block|{
synchronized|synchronized
init|(
name|externalHandler
init|)
block|{
name|externalHandler
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Set an AlignmentContext for the call to update when call is done.      *      * @param ac alignment context to update.      */
DECL|method|setAlignmentContext (AlignmentContext ac)
specifier|public
specifier|synchronized
name|void
name|setAlignmentContext
parameter_list|(
name|AlignmentContext
name|ac
parameter_list|)
block|{
name|this
operator|.
name|alignmentContext
operator|=
name|ac
expr_stmt|;
block|}
comment|/** Set the exception when there is an error.      * Notify the caller the call is done.      *       * @param error exception thrown by the call; either local or remote      */
DECL|method|setException (IOException error)
specifier|public
specifier|synchronized
name|void
name|setException
parameter_list|(
name|IOException
name|error
parameter_list|)
block|{
name|this
operator|.
name|error
operator|=
name|error
expr_stmt|;
name|callComplete
argument_list|()
expr_stmt|;
block|}
comment|/** Set the return value when there is no error.       * Notify the caller the call is done.      *       * @param rpcResponse return value of the rpc call.      */
DECL|method|setRpcResponse (Writable rpcResponse)
specifier|public
specifier|synchronized
name|void
name|setRpcResponse
parameter_list|(
name|Writable
name|rpcResponse
parameter_list|)
block|{
name|this
operator|.
name|rpcResponse
operator|=
name|rpcResponse
expr_stmt|;
name|callComplete
argument_list|()
expr_stmt|;
block|}
DECL|method|getRpcResponse ()
specifier|public
specifier|synchronized
name|Writable
name|getRpcResponse
parameter_list|()
block|{
return|return
name|rpcResponse
return|;
block|}
block|}
comment|/** Thread that reads responses and notifies callers.  Each connection owns a    * socket connected to a remote address.  Calls are multiplexed through this    * socket: responses may be delivered out of order. */
DECL|class|Connection
specifier|private
class|class
name|Connection
extends|extends
name|Thread
block|{
DECL|field|server
specifier|private
name|InetSocketAddress
name|server
decl_stmt|;
comment|// server ip:port
DECL|field|remoteId
specifier|private
specifier|final
name|ConnectionId
name|remoteId
decl_stmt|;
comment|// connection id
DECL|field|authMethod
specifier|private
name|AuthMethod
name|authMethod
decl_stmt|;
comment|// authentication method
DECL|field|authProtocol
specifier|private
name|AuthProtocol
name|authProtocol
decl_stmt|;
DECL|field|serviceClass
specifier|private
name|int
name|serviceClass
decl_stmt|;
DECL|field|saslRpcClient
specifier|private
name|SaslRpcClient
name|saslRpcClient
decl_stmt|;
DECL|field|socket
specifier|private
name|Socket
name|socket
init|=
literal|null
decl_stmt|;
comment|// connected socket
DECL|field|ipcStreams
specifier|private
name|IpcStreams
name|ipcStreams
decl_stmt|;
DECL|field|maxResponseLength
specifier|private
specifier|final
name|int
name|maxResponseLength
decl_stmt|;
DECL|field|rpcTimeout
specifier|private
specifier|final
name|int
name|rpcTimeout
decl_stmt|;
DECL|field|maxIdleTime
specifier|private
name|int
name|maxIdleTime
decl_stmt|;
comment|//connections will be culled if it was idle for
comment|//maxIdleTime msecs
DECL|field|connectionRetryPolicy
specifier|private
specifier|final
name|RetryPolicy
name|connectionRetryPolicy
decl_stmt|;
DECL|field|maxRetriesOnSasl
specifier|private
specifier|final
name|int
name|maxRetriesOnSasl
decl_stmt|;
DECL|field|maxRetriesOnSocketTimeouts
specifier|private
name|int
name|maxRetriesOnSocketTimeouts
decl_stmt|;
DECL|field|tcpNoDelay
specifier|private
specifier|final
name|boolean
name|tcpNoDelay
decl_stmt|;
comment|// if T then disable Nagle's Algorithm
DECL|field|tcpLowLatency
specifier|private
specifier|final
name|boolean
name|tcpLowLatency
decl_stmt|;
comment|// if T then use low-delay QoS
DECL|field|doPing
specifier|private
specifier|final
name|boolean
name|doPing
decl_stmt|;
comment|//do we need to send ping message
DECL|field|pingInterval
specifier|private
specifier|final
name|int
name|pingInterval
decl_stmt|;
comment|// how often sends ping to the server
DECL|field|soTimeout
specifier|private
specifier|final
name|int
name|soTimeout
decl_stmt|;
comment|// used by ipc ping and rpc timeout
DECL|field|pingRequest
specifier|private
name|byte
index|[]
name|pingRequest
decl_stmt|;
comment|// ping message
comment|// currently active calls
DECL|field|calls
specifier|private
name|Hashtable
argument_list|<
name|Integer
argument_list|,
name|Call
argument_list|>
name|calls
init|=
operator|new
name|Hashtable
argument_list|<
name|Integer
argument_list|,
name|Call
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|lastActivity
specifier|private
name|AtomicLong
name|lastActivity
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
comment|// last I/O activity time
DECL|field|shouldCloseConnection
specifier|private
name|AtomicBoolean
name|shouldCloseConnection
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
comment|// indicate if the connection is closed
DECL|field|closeException
specifier|private
name|IOException
name|closeException
decl_stmt|;
comment|// close reason
DECL|field|sendRpcRequestLock
specifier|private
specifier|final
name|Object
name|sendRpcRequestLock
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|connectingThread
specifier|private
name|AtomicReference
argument_list|<
name|Thread
argument_list|>
name|connectingThread
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|removeMethod
specifier|private
specifier|final
name|Consumer
argument_list|<
name|Connection
argument_list|>
name|removeMethod
decl_stmt|;
DECL|method|Connection (ConnectionId remoteId, int serviceClass, Consumer<Connection> removeMethod)
name|Connection
parameter_list|(
name|ConnectionId
name|remoteId
parameter_list|,
name|int
name|serviceClass
parameter_list|,
name|Consumer
argument_list|<
name|Connection
argument_list|>
name|removeMethod
parameter_list|)
block|{
name|this
operator|.
name|remoteId
operator|=
name|remoteId
expr_stmt|;
name|this
operator|.
name|server
operator|=
name|remoteId
operator|.
name|getAddress
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxResponseLength
operator|=
name|remoteId
operator|.
name|conf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeys
operator|.
name|IPC_MAXIMUM_RESPONSE_LENGTH
argument_list|,
name|CommonConfigurationKeys
operator|.
name|IPC_MAXIMUM_RESPONSE_LENGTH_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|rpcTimeout
operator|=
name|remoteId
operator|.
name|getRpcTimeout
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxIdleTime
operator|=
name|remoteId
operator|.
name|getMaxIdleTime
argument_list|()
expr_stmt|;
name|this
operator|.
name|connectionRetryPolicy
operator|=
name|remoteId
operator|.
name|connectionRetryPolicy
expr_stmt|;
name|this
operator|.
name|maxRetriesOnSasl
operator|=
name|remoteId
operator|.
name|getMaxRetriesOnSasl
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxRetriesOnSocketTimeouts
operator|=
name|remoteId
operator|.
name|getMaxRetriesOnSocketTimeouts
argument_list|()
expr_stmt|;
name|this
operator|.
name|tcpNoDelay
operator|=
name|remoteId
operator|.
name|getTcpNoDelay
argument_list|()
expr_stmt|;
name|this
operator|.
name|tcpLowLatency
operator|=
name|remoteId
operator|.
name|getTcpLowLatency
argument_list|()
expr_stmt|;
name|this
operator|.
name|doPing
operator|=
name|remoteId
operator|.
name|getDoPing
argument_list|()
expr_stmt|;
if|if
condition|(
name|doPing
condition|)
block|{
comment|// construct a RPC header with the callId as the ping callId
name|ResponseBuffer
name|buf
init|=
operator|new
name|ResponseBuffer
argument_list|()
decl_stmt|;
name|RpcRequestHeaderProto
name|pingHeader
init|=
name|ProtoUtil
operator|.
name|makeRpcRequestHeader
argument_list|(
name|RpcKind
operator|.
name|RPC_PROTOCOL_BUFFER
argument_list|,
name|OperationProto
operator|.
name|RPC_FINAL_PACKET
argument_list|,
name|PING_CALL_ID
argument_list|,
name|RpcConstants
operator|.
name|INVALID_RETRY_COUNT
argument_list|,
name|clientId
argument_list|)
decl_stmt|;
try|try
block|{
name|pingHeader
operator|.
name|writeDelimitedTo
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Failed to write to buf for "
operator|+
name|remoteId
operator|+
literal|" in "
operator|+
name|Client
operator|.
name|this
operator|+
literal|" due to "
operator|+
name|e
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|pingRequest
operator|=
name|buf
operator|.
name|toByteArray
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|pingInterval
operator|=
name|remoteId
operator|.
name|getPingInterval
argument_list|()
expr_stmt|;
if|if
condition|(
name|rpcTimeout
operator|>
literal|0
condition|)
block|{
comment|// effective rpc timeout is rounded up to multiple of pingInterval
comment|// if pingInterval< rpcTimeout.
name|this
operator|.
name|soTimeout
operator|=
operator|(
name|doPing
operator|&&
name|pingInterval
operator|<
name|rpcTimeout
operator|)
condition|?
name|pingInterval
else|:
name|rpcTimeout
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|soTimeout
operator|=
name|pingInterval
expr_stmt|;
block|}
name|this
operator|.
name|serviceClass
operator|=
name|serviceClass
expr_stmt|;
name|this
operator|.
name|removeMethod
operator|=
name|removeMethod
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"The ping interval is "
operator|+
name|this
operator|.
name|pingInterval
operator|+
literal|" ms."
argument_list|)
expr_stmt|;
block|}
name|UserGroupInformation
name|ticket
init|=
name|remoteId
operator|.
name|getTicket
argument_list|()
decl_stmt|;
comment|// try SASL if security is enabled or if the ugi contains tokens.
comment|// this causes a SIMPLE client with tokens to attempt SASL
name|boolean
name|trySasl
init|=
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
operator|||
operator|(
name|ticket
operator|!=
literal|null
operator|&&
operator|!
name|ticket
operator|.
name|getTokens
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
decl_stmt|;
name|this
operator|.
name|authProtocol
operator|=
name|trySasl
condition|?
name|AuthProtocol
operator|.
name|SASL
else|:
name|AuthProtocol
operator|.
name|NONE
expr_stmt|;
name|this
operator|.
name|setName
argument_list|(
literal|"IPC Client ("
operator|+
name|socketFactory
operator|.
name|hashCode
argument_list|()
operator|+
literal|") connection to "
operator|+
name|server
operator|.
name|toString
argument_list|()
operator|+
literal|" from "
operator|+
operator|(
operator|(
name|ticket
operator|==
literal|null
operator|)
condition|?
literal|"an unknown user"
else|:
name|ticket
operator|.
name|getUserName
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/** Update lastActivity with the current time. */
DECL|method|touch ()
specifier|private
name|void
name|touch
parameter_list|()
block|{
name|lastActivity
operator|.
name|set
argument_list|(
name|Time
operator|.
name|now
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Add a call to this connection's call queue and notify      * a listener; synchronized.      * Returns false if called during shutdown.      * @param call to add      * @return true if the call was added.      */
DECL|method|addCall (Call call)
specifier|private
specifier|synchronized
name|boolean
name|addCall
parameter_list|(
name|Call
name|call
parameter_list|)
block|{
if|if
condition|(
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
return|return
literal|false
return|;
name|calls
operator|.
name|put
argument_list|(
name|call
operator|.
name|id
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|notify
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/** This class sends a ping to the remote side when timeout on      * reading. If no failure is detected, it retries until at least      * a byte is read.      */
DECL|class|PingInputStream
specifier|private
class|class
name|PingInputStream
extends|extends
name|FilterInputStream
block|{
comment|/* constructor */
DECL|method|PingInputStream (InputStream in)
specifier|protected
name|PingInputStream
parameter_list|(
name|InputStream
name|in
parameter_list|)
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
comment|/* Process timeout exception        * if the connection is not going to be closed or         * the RPC is not timed out yet, send a ping.        */
DECL|method|handleTimeout (SocketTimeoutException e, int waiting)
specifier|private
name|void
name|handleTimeout
parameter_list|(
name|SocketTimeoutException
name|e
parameter_list|,
name|int
name|waiting
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|shouldCloseConnection
operator|.
name|get
argument_list|()
operator|||
operator|!
name|running
operator|.
name|get
argument_list|()
operator|||
operator|(
literal|0
operator|<
name|rpcTimeout
operator|&&
name|rpcTimeout
operator|<=
name|waiting
operator|)
condition|)
block|{
throw|throw
name|e
throw|;
block|}
else|else
block|{
name|sendPing
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Read a byte from the stream.        * Send a ping if timeout on read. Retries if no failure is detected        * until a byte is read.        * @throws IOException for any IO problem other than socket timeout        */
annotation|@
name|Override
DECL|method|read ()
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|waiting
init|=
literal|0
decl_stmt|;
do|do
block|{
try|try
block|{
return|return
name|super
operator|.
name|read
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SocketTimeoutException
name|e
parameter_list|)
block|{
name|waiting
operator|+=
name|soTimeout
expr_stmt|;
name|handleTimeout
argument_list|(
name|e
argument_list|,
name|waiting
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
literal|true
condition|)
do|;
block|}
comment|/** Read bytes into a buffer starting from offset<code>off</code>        * Send a ping if timeout on read. Retries if no failure is detected        * until a byte is read.        *         * @return the total number of bytes read; -1 if the connection is closed.        */
annotation|@
name|Override
DECL|method|read (byte[] buf, int off, int len)
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|waiting
init|=
literal|0
decl_stmt|;
do|do
block|{
try|try
block|{
return|return
name|super
operator|.
name|read
argument_list|(
name|buf
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|SocketTimeoutException
name|e
parameter_list|)
block|{
name|waiting
operator|+=
name|soTimeout
expr_stmt|;
name|handleTimeout
argument_list|(
name|e
argument_list|,
name|waiting
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
literal|true
condition|)
do|;
block|}
block|}
DECL|method|disposeSasl ()
specifier|private
specifier|synchronized
name|void
name|disposeSasl
parameter_list|()
block|{
if|if
condition|(
name|saslRpcClient
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|saslRpcClient
operator|.
name|dispose
argument_list|()
expr_stmt|;
name|saslRpcClient
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ignored
parameter_list|)
block|{         }
block|}
block|}
DECL|method|shouldAuthenticateOverKrb ()
specifier|private
specifier|synchronized
name|boolean
name|shouldAuthenticateOverKrb
parameter_list|()
throws|throws
name|IOException
block|{
name|UserGroupInformation
name|loginUser
init|=
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
decl_stmt|;
name|UserGroupInformation
name|currentUser
init|=
name|UserGroupInformation
operator|.
name|getCurrentUser
argument_list|()
decl_stmt|;
name|UserGroupInformation
name|realUser
init|=
name|currentUser
operator|.
name|getRealUser
argument_list|()
decl_stmt|;
if|if
condition|(
name|authMethod
operator|==
name|AuthMethod
operator|.
name|KERBEROS
operator|&&
name|loginUser
operator|!=
literal|null
operator|&&
comment|// Make sure user logged in using Kerberos either keytab or TGT
name|loginUser
operator|.
name|hasKerberosCredentials
argument_list|()
operator|&&
comment|// relogin only in case it is the login user (e.g. JT)
comment|// or superuser (like oozie).
operator|(
name|loginUser
operator|.
name|equals
argument_list|(
name|currentUser
argument_list|)
operator|||
name|loginUser
operator|.
name|equals
argument_list|(
name|realUser
argument_list|)
operator|)
condition|)
block|{
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|setupSaslConnection (IpcStreams streams)
specifier|private
specifier|synchronized
name|AuthMethod
name|setupSaslConnection
parameter_list|(
name|IpcStreams
name|streams
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Do not use Client.conf here! We must use ConnectionId.conf, since the
comment|// Client object is cached and shared between all RPC clients, even those
comment|// for separate services.
name|saslRpcClient
operator|=
operator|new
name|SaslRpcClient
argument_list|(
name|remoteId
operator|.
name|getTicket
argument_list|()
argument_list|,
name|remoteId
operator|.
name|getProtocol
argument_list|()
argument_list|,
name|remoteId
operator|.
name|getAddress
argument_list|()
argument_list|,
name|remoteId
operator|.
name|conf
argument_list|)
expr_stmt|;
return|return
name|saslRpcClient
operator|.
name|saslConnect
argument_list|(
name|streams
argument_list|)
return|;
block|}
comment|/**      * Update the server address if the address corresponding to the host      * name has changed.      *      * @return true if an addr change was detected.      * @throws IOException when the hostname cannot be resolved.      */
DECL|method|updateAddress ()
specifier|private
specifier|synchronized
name|boolean
name|updateAddress
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Do a fresh lookup with the old host name.
name|InetSocketAddress
name|currentAddr
init|=
name|NetUtils
operator|.
name|createSocketAddrForHost
argument_list|(
name|server
operator|.
name|getHostName
argument_list|()
argument_list|,
name|server
operator|.
name|getPort
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|server
operator|.
name|equals
argument_list|(
name|currentAddr
argument_list|)
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Address change detected. Old: "
operator|+
name|server
operator|.
name|toString
argument_list|()
operator|+
literal|" New: "
operator|+
name|currentAddr
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|server
operator|=
name|currentAddr
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|setupConnection ( UserGroupInformation ticket)
specifier|private
specifier|synchronized
name|void
name|setupConnection
parameter_list|(
name|UserGroupInformation
name|ticket
parameter_list|)
throws|throws
name|IOException
block|{
name|short
name|ioFailures
init|=
literal|0
decl_stmt|;
name|short
name|timeoutFailures
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|this
operator|.
name|socket
operator|=
name|socketFactory
operator|.
name|createSocket
argument_list|()
expr_stmt|;
name|this
operator|.
name|socket
operator|.
name|setTcpNoDelay
argument_list|(
name|tcpNoDelay
argument_list|)
expr_stmt|;
name|this
operator|.
name|socket
operator|.
name|setKeepAlive
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcpLowLatency
condition|)
block|{
comment|/*              * This allows intermediate switches to shape IPC traffic              * differently from Shuffle/HDFS DataStreamer traffic.              *              * IPTOS_RELIABILITY (0x04) | IPTOS_LOWDELAY (0x10)              *              * Prefer to optimize connect() speed& response latency over net              * throughput.              */
name|this
operator|.
name|socket
operator|.
name|setTrafficClass
argument_list|(
literal|0x04
operator||
literal|0x10
argument_list|)
expr_stmt|;
name|this
operator|.
name|socket
operator|.
name|setPerformancePreferences
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*            * Bind the socket to the host specified in the principal name of the            * client, to ensure Server matching address of the client connection            * to host name in principal passed.            */
name|InetSocketAddress
name|bindAddr
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ticket
operator|!=
literal|null
operator|&&
name|ticket
operator|.
name|hasKerberosCredentials
argument_list|()
condition|)
block|{
name|KerberosInfo
name|krbInfo
init|=
name|remoteId
operator|.
name|getProtocol
argument_list|()
operator|.
name|getAnnotation
argument_list|(
name|KerberosInfo
operator|.
name|class
argument_list|)
decl_stmt|;
if|if
condition|(
name|krbInfo
operator|!=
literal|null
condition|)
block|{
name|String
name|principal
init|=
name|ticket
operator|.
name|getUserName
argument_list|()
decl_stmt|;
name|String
name|host
init|=
name|SecurityUtil
operator|.
name|getHostFromPrincipal
argument_list|(
name|principal
argument_list|)
decl_stmt|;
comment|// If host name is a valid local address then bind socket to it
name|InetAddress
name|localAddr
init|=
name|NetUtils
operator|.
name|getLocalInetAddress
argument_list|(
name|host
argument_list|)
decl_stmt|;
if|if
condition|(
name|localAddr
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|socket
operator|.
name|setReuseAddress
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|localAddr
operator|=
name|NetUtils
operator|.
name|bindToLocalAddress
argument_list|(
name|localAddr
argument_list|,
name|bindToWildCardAddress
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Binding {} to {}"
argument_list|,
name|principal
argument_list|,
operator|(
name|bindToWildCardAddress
operator|)
condition|?
literal|"0.0.0.0"
else|:
name|localAddr
argument_list|)
expr_stmt|;
name|this
operator|.
name|socket
operator|.
name|bind
argument_list|(
operator|new
name|InetSocketAddress
argument_list|(
name|localAddr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|NetUtils
operator|.
name|connect
argument_list|(
name|this
operator|.
name|socket
argument_list|,
name|server
argument_list|,
name|bindAddr
argument_list|,
name|connectionTimeout
argument_list|)
expr_stmt|;
name|this
operator|.
name|socket
operator|.
name|setSoTimeout
argument_list|(
name|soTimeout
argument_list|)
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|ConnectTimeoutException
name|toe
parameter_list|)
block|{
comment|/* Check for an address change and update the local reference.            * Reset the failure counter if the address was changed            */
if|if
condition|(
name|updateAddress
argument_list|()
condition|)
block|{
name|timeoutFailures
operator|=
name|ioFailures
operator|=
literal|0
expr_stmt|;
block|}
name|handleConnectionTimeout
argument_list|(
name|timeoutFailures
operator|++
argument_list|,
name|maxRetriesOnSocketTimeouts
argument_list|,
name|toe
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ie
parameter_list|)
block|{
if|if
condition|(
name|updateAddress
argument_list|()
condition|)
block|{
name|timeoutFailures
operator|=
name|ioFailures
operator|=
literal|0
expr_stmt|;
block|}
name|handleConnectionFailure
argument_list|(
name|ioFailures
operator|++
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * If multiple clients with the same principal try to connect to the same      * server at the same time, the server assumes a replay attack is in      * progress. This is a feature of kerberos. In order to work around this,      * what is done is that the client backs off randomly and tries to initiate      * the connection again. The other problem is to do with ticket expiry. To      * handle that, a relogin is attempted.      */
DECL|method|handleSaslConnectionFailure ( final int currRetries, final int maxRetries, final Exception ex, final Random rand, final UserGroupInformation ugi)
specifier|private
specifier|synchronized
name|void
name|handleSaslConnectionFailure
parameter_list|(
specifier|final
name|int
name|currRetries
parameter_list|,
specifier|final
name|int
name|maxRetries
parameter_list|,
specifier|final
name|Exception
name|ex
parameter_list|,
specifier|final
name|Random
name|rand
parameter_list|,
specifier|final
name|UserGroupInformation
name|ugi
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|ugi
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Object
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
specifier|final
name|short
name|MAX_BACKOFF
init|=
literal|5000
decl_stmt|;
name|closeConnection
argument_list|()
expr_stmt|;
name|disposeSasl
argument_list|()
expr_stmt|;
if|if
condition|(
name|shouldAuthenticateOverKrb
argument_list|()
condition|)
block|{
if|if
condition|(
name|currRetries
operator|<
name|maxRetries
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Exception encountered while connecting to "
operator|+
literal|"the server : "
operator|+
name|ex
argument_list|)
expr_stmt|;
block|}
comment|// try re-login
if|if
condition|(
name|UserGroupInformation
operator|.
name|isLoginKeytabBased
argument_list|()
condition|)
block|{
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
operator|.
name|reloginFromKeytab
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|UserGroupInformation
operator|.
name|isLoginTicketBased
argument_list|()
condition|)
block|{
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
operator|.
name|reloginFromTicketCache
argument_list|()
expr_stmt|;
block|}
comment|// have granularity of milliseconds
comment|//we are sleeping with the Connection lock held but since this
comment|//connection instance is being used for connecting to the server
comment|//in question, it is okay
name|Thread
operator|.
name|sleep
argument_list|(
operator|(
name|rand
operator|.
name|nextInt
argument_list|(
name|MAX_BACKOFF
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
name|String
name|msg
init|=
literal|"Couldn't setup connection for "
operator|+
name|UserGroupInformation
operator|.
name|getLoginUser
argument_list|()
operator|.
name|getUserName
argument_list|()
operator|+
literal|" to "
operator|+
name|remoteId
decl_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
name|msg
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|(
name|IOException
operator|)
operator|new
name|IOException
argument_list|(
name|msg
argument_list|)
operator|.
name|initCause
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Exception encountered while connecting to "
operator|+
literal|"the server : "
operator|+
name|ex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ex
operator|instanceof
name|RemoteException
condition|)
throw|throw
operator|(
name|RemoteException
operator|)
name|ex
throw|;
throw|throw
operator|new
name|IOException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/** Connect to the server and set up the I/O streams. It then sends      * a header to the server and starts      * the connection thread that waits for responses.      */
DECL|method|setupIOstreams ( AtomicBoolean fallbackToSimpleAuth)
specifier|private
specifier|synchronized
name|void
name|setupIOstreams
parameter_list|(
name|AtomicBoolean
name|fallbackToSimpleAuth
parameter_list|)
block|{
if|if
condition|(
name|socket
operator|!=
literal|null
operator|||
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
block|{
return|return;
block|}
name|UserGroupInformation
name|ticket
init|=
name|remoteId
operator|.
name|getTicket
argument_list|()
decl_stmt|;
if|if
condition|(
name|ticket
operator|!=
literal|null
condition|)
block|{
specifier|final
name|UserGroupInformation
name|realUser
init|=
name|ticket
operator|.
name|getRealUser
argument_list|()
decl_stmt|;
if|if
condition|(
name|realUser
operator|!=
literal|null
condition|)
block|{
name|ticket
operator|=
name|realUser
expr_stmt|;
block|}
block|}
try|try
block|{
name|connectingThread
operator|.
name|set
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Connecting to "
operator|+
name|server
argument_list|)
expr_stmt|;
block|}
name|Span
name|span
init|=
name|Tracer
operator|.
name|getCurrentSpan
argument_list|()
decl_stmt|;
if|if
condition|(
name|span
operator|!=
literal|null
condition|)
block|{
name|span
operator|.
name|addTimelineAnnotation
argument_list|(
literal|"IPC client connecting to "
operator|+
name|server
argument_list|)
expr_stmt|;
block|}
name|short
name|numRetries
init|=
literal|0
decl_stmt|;
name|Random
name|rand
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|setupConnection
argument_list|(
name|ticket
argument_list|)
expr_stmt|;
name|ipcStreams
operator|=
operator|new
name|IpcStreams
argument_list|(
name|socket
argument_list|,
name|maxResponseLength
argument_list|)
expr_stmt|;
name|writeConnectionHeader
argument_list|(
name|ipcStreams
argument_list|)
expr_stmt|;
if|if
condition|(
name|authProtocol
operator|==
name|AuthProtocol
operator|.
name|SASL
condition|)
block|{
try|try
block|{
name|authMethod
operator|=
name|ticket
operator|.
name|doAs
argument_list|(
operator|new
name|PrivilegedExceptionAction
argument_list|<
name|AuthMethod
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|AuthMethod
name|run
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
return|return
name|setupSaslConnection
argument_list|(
name|ipcStreams
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
if|if
condition|(
name|saslRpcClient
operator|==
literal|null
condition|)
block|{
comment|// whatever happened -it can't be handled, so rethrow
throw|throw
name|ex
throw|;
block|}
comment|// otherwise, assume a connection problem
name|authMethod
operator|=
name|saslRpcClient
operator|.
name|getAuthMethod
argument_list|()
expr_stmt|;
if|if
condition|(
name|rand
operator|==
literal|null
condition|)
block|{
name|rand
operator|=
operator|new
name|Random
argument_list|()
expr_stmt|;
block|}
name|handleSaslConnectionFailure
argument_list|(
name|numRetries
operator|++
argument_list|,
name|maxRetriesOnSasl
argument_list|,
name|ex
argument_list|,
name|rand
argument_list|,
name|ticket
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|authMethod
operator|!=
name|AuthMethod
operator|.
name|SIMPLE
condition|)
block|{
comment|// Sasl connect is successful. Let's set up Sasl i/o streams.
name|ipcStreams
operator|.
name|setSaslClient
argument_list|(
name|saslRpcClient
argument_list|)
expr_stmt|;
comment|// for testing
name|remoteId
operator|.
name|saslQop
operator|=
operator|(
name|String
operator|)
name|saslRpcClient
operator|.
name|getNegotiatedProperty
argument_list|(
name|Sasl
operator|.
name|QOP
argument_list|)
expr_stmt|;
name|LOG
operator|.
name|debug
argument_list|(
literal|"Negotiated QOP is :"
operator|+
name|remoteId
operator|.
name|saslQop
argument_list|)
expr_stmt|;
if|if
condition|(
name|fallbackToSimpleAuth
operator|!=
literal|null
condition|)
block|{
name|fallbackToSimpleAuth
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|UserGroupInformation
operator|.
name|isSecurityEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|fallbackAllowed
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Server asks us to fall back to SIMPLE "
operator|+
literal|"auth, but this client is configured to only allow secure "
operator|+
literal|"connections."
argument_list|)
throw|;
block|}
if|if
condition|(
name|fallbackToSimpleAuth
operator|!=
literal|null
condition|)
block|{
name|fallbackToSimpleAuth
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|doPing
condition|)
block|{
name|ipcStreams
operator|.
name|setInputStream
argument_list|(
operator|new
name|PingInputStream
argument_list|(
name|ipcStreams
operator|.
name|in
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|writeConnectionContext
argument_list|(
name|remoteId
argument_list|,
name|authMethod
argument_list|)
expr_stmt|;
comment|// update last activity time
name|touch
argument_list|()
expr_stmt|;
name|span
operator|=
name|Tracer
operator|.
name|getCurrentSpan
argument_list|()
expr_stmt|;
if|if
condition|(
name|span
operator|!=
literal|null
condition|)
block|{
name|span
operator|.
name|addTimelineAnnotation
argument_list|(
literal|"IPC client connected to "
operator|+
name|server
argument_list|)
expr_stmt|;
block|}
comment|// start the receiver thread after the socket connection has been set
comment|// up
name|start
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|IOException
condition|)
block|{
name|markClosed
argument_list|(
operator|(
name|IOException
operator|)
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|markClosed
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"Couldn't set up IO streams: "
operator|+
name|t
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|connectingThread
operator|.
name|set
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|closeConnection ()
specifier|private
name|void
name|closeConnection
parameter_list|()
block|{
if|if
condition|(
name|socket
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// close the current connection
try|try
block|{
name|socket
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Not able to close a socket"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
comment|// set socket to null so that the next call to setupIOstreams
comment|// can start the process of connect all over again.
name|socket
operator|=
literal|null
expr_stmt|;
block|}
comment|/* Handle connection failures due to timeout on connect      *      * If the current number of retries is equal to the max number of retries,      * stop retrying and throw the exception; Otherwise backoff 1 second and      * try connecting again.      *      * This Method is only called from inside setupIOstreams(), which is      * synchronized. Hence the sleep is synchronized; the locks will be retained.      *      * @param curRetries current number of retries      * @param maxRetries max number of retries allowed      * @param ioe failure reason      * @throws IOException if max number of retries is reached      */
DECL|method|handleConnectionTimeout ( int curRetries, int maxRetries, IOException ioe)
specifier|private
name|void
name|handleConnectionTimeout
parameter_list|(
name|int
name|curRetries
parameter_list|,
name|int
name|maxRetries
parameter_list|,
name|IOException
name|ioe
parameter_list|)
throws|throws
name|IOException
block|{
name|closeConnection
argument_list|()
expr_stmt|;
comment|// throw the exception if the maximum number of retries is reached
if|if
condition|(
name|curRetries
operator|>=
name|maxRetries
condition|)
block|{
throw|throw
name|ioe
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Retrying connect to server: "
operator|+
name|server
operator|+
literal|". Already tried "
operator|+
name|curRetries
operator|+
literal|" time(s); maxRetries="
operator|+
name|maxRetries
argument_list|)
expr_stmt|;
block|}
DECL|method|handleConnectionFailure (int curRetries, IOException ioe )
specifier|private
name|void
name|handleConnectionFailure
parameter_list|(
name|int
name|curRetries
parameter_list|,
name|IOException
name|ioe
parameter_list|)
throws|throws
name|IOException
block|{
name|closeConnection
argument_list|()
expr_stmt|;
specifier|final
name|RetryAction
name|action
decl_stmt|;
try|try
block|{
name|action
operator|=
name|connectionRetryPolicy
operator|.
name|shouldRetry
argument_list|(
name|ioe
argument_list|,
name|curRetries
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
name|e
operator|instanceof
name|IOException
condition|?
operator|(
name|IOException
operator|)
name|e
else|:
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|action
operator|.
name|action
operator|==
name|RetryAction
operator|.
name|RetryDecision
operator|.
name|FAIL
condition|)
block|{
if|if
condition|(
name|action
operator|.
name|reason
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Failed to connect to server: "
operator|+
name|server
operator|+
literal|": "
operator|+
name|action
operator|.
name|reason
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
throw|throw
name|ioe
throw|;
block|}
comment|// Throw the exception if the thread is interrupted
if|if
condition|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Interrupted while trying for connection"
argument_list|)
expr_stmt|;
throw|throw
name|ioe
throw|;
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|action
operator|.
name|delayMillis
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
throw|throw
operator|(
name|IOException
operator|)
operator|new
name|InterruptedIOException
argument_list|(
literal|"Interrupted: action="
operator|+
name|action
operator|+
literal|", retry policy="
operator|+
name|connectionRetryPolicy
argument_list|)
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|LOG
operator|.
name|info
argument_list|(
literal|"Retrying connect to server: "
operator|+
name|server
operator|+
literal|". Already tried "
operator|+
name|curRetries
operator|+
literal|" time(s); retry policy is "
operator|+
name|connectionRetryPolicy
argument_list|)
expr_stmt|;
block|}
comment|/**      * Write the connection header - this is sent when connection is established      * +----------------------------------+      * |  "hrpc" 4 bytes                  |            * +----------------------------------+      * |  Version (1 byte)                |      * +----------------------------------+      * |  Service Class (1 byte)          |      * +----------------------------------+      * |  AuthProtocol (1 byte)           |            * +----------------------------------+      */
DECL|method|writeConnectionHeader (IpcStreams streams)
specifier|private
name|void
name|writeConnectionHeader
parameter_list|(
name|IpcStreams
name|streams
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Write out the header, version and authentication method.
comment|// The output stream is buffered but we must not flush it yet.  The
comment|// connection setup protocol requires the client to send multiple
comment|// messages before reading a response.
comment|//
comment|//   insecure: send header+context+call, read
comment|//   secure  : send header+negotiate, read, (sasl), context+call, read
comment|//
comment|// The client must flush only when it's prepared to read.  Otherwise
comment|// "broken pipe" exceptions occur if the server closes the connection
comment|// before all messages are sent.
specifier|final
name|DataOutputStream
name|out
init|=
name|streams
operator|.
name|out
decl_stmt|;
synchronized|synchronized
init|(
name|out
init|)
block|{
name|out
operator|.
name|write
argument_list|(
name|RpcConstants
operator|.
name|HEADER
operator|.
name|array
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|RpcConstants
operator|.
name|CURRENT_VERSION
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|serviceClass
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|authProtocol
operator|.
name|callId
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Write the connection context header for each connection      * Out is not synchronized because only the first thread does this.      */
DECL|method|writeConnectionContext (ConnectionId remoteId, AuthMethod authMethod)
specifier|private
name|void
name|writeConnectionContext
parameter_list|(
name|ConnectionId
name|remoteId
parameter_list|,
name|AuthMethod
name|authMethod
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Write out the ConnectionHeader
name|IpcConnectionContextProto
name|message
init|=
name|ProtoUtil
operator|.
name|makeIpcConnectionContext
argument_list|(
name|RPC
operator|.
name|getProtocolName
argument_list|(
name|remoteId
operator|.
name|getProtocol
argument_list|()
argument_list|)
argument_list|,
name|remoteId
operator|.
name|getTicket
argument_list|()
argument_list|,
name|authMethod
argument_list|)
decl_stmt|;
name|RpcRequestHeaderProto
name|connectionContextHeader
init|=
name|ProtoUtil
operator|.
name|makeRpcRequestHeader
argument_list|(
name|RpcKind
operator|.
name|RPC_PROTOCOL_BUFFER
argument_list|,
name|OperationProto
operator|.
name|RPC_FINAL_PACKET
argument_list|,
name|CONNECTION_CONTEXT_CALL_ID
argument_list|,
name|RpcConstants
operator|.
name|INVALID_RETRY_COUNT
argument_list|,
name|clientId
argument_list|)
decl_stmt|;
comment|// do not flush.  the context and first ipc call request must be sent
comment|// together to avoid possibility of broken pipes upon authz failure.
comment|// see writeConnectionHeader
specifier|final
name|ResponseBuffer
name|buf
init|=
operator|new
name|ResponseBuffer
argument_list|()
decl_stmt|;
name|connectionContextHeader
operator|.
name|writeDelimitedTo
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|message
operator|.
name|writeDelimitedTo
argument_list|(
name|buf
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|ipcStreams
operator|.
name|out
init|)
block|{
name|ipcStreams
operator|.
name|sendRequest
argument_list|(
name|buf
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* wait till someone signals us to start reading RPC response or      * it is idle too long, it is marked as to be closed,       * or the client is marked as not running.      *       * Return true if it is time to read a response; false otherwise.      */
DECL|method|waitForWork ()
specifier|private
specifier|synchronized
name|boolean
name|waitForWork
parameter_list|()
block|{
if|if
condition|(
name|calls
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|shouldCloseConnection
operator|.
name|get
argument_list|()
operator|&&
name|running
operator|.
name|get
argument_list|()
condition|)
block|{
name|long
name|timeout
init|=
name|maxIdleTime
operator|-
operator|(
name|Time
operator|.
name|now
argument_list|()
operator|-
name|lastActivity
operator|.
name|get
argument_list|()
operator|)
decl_stmt|;
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|wait
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{}
block|}
block|}
if|if
condition|(
operator|!
name|calls
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|shouldCloseConnection
operator|.
name|get
argument_list|()
operator|&&
name|running
operator|.
name|get
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|calls
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// idle connection closed or stopped
name|markClosed
argument_list|(
literal|null
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
comment|// get stopped but there are still pending requests
name|markClosed
argument_list|(
operator|(
name|IOException
operator|)
operator|new
name|IOException
argument_list|()
operator|.
name|initCause
argument_list|(
operator|new
name|InterruptedException
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
DECL|method|getRemoteAddress ()
specifier|public
name|InetSocketAddress
name|getRemoteAddress
parameter_list|()
block|{
return|return
name|server
return|;
block|}
comment|/* Send a ping to the server if the time elapsed       * since last I/O activity is equal to or greater than the ping interval      */
DECL|method|sendPing ()
specifier|private
specifier|synchronized
name|void
name|sendPing
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|curTime
init|=
name|Time
operator|.
name|now
argument_list|()
decl_stmt|;
if|if
condition|(
name|curTime
operator|-
name|lastActivity
operator|.
name|get
argument_list|()
operator|>=
name|pingInterval
condition|)
block|{
name|lastActivity
operator|.
name|set
argument_list|(
name|curTime
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|ipcStreams
operator|.
name|out
init|)
block|{
name|ipcStreams
operator|.
name|sendRequest
argument_list|(
name|pingRequest
argument_list|)
expr_stmt|;
name|ipcStreams
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|run ()
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": starting, having connections "
operator|+
name|connections
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
while|while
condition|(
name|waitForWork
argument_list|()
condition|)
block|{
comment|//wait here for work - read or close connection
name|receiveRpcResponse
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// This truly is unexpected, since we catch IOException in receiveResponse
comment|// -- this is only to be really sure that we don't leave a client hanging
comment|// forever.
name|LOG
operator|.
name|warn
argument_list|(
literal|"Unexpected error reading responses on connection "
operator|+
name|this
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|markClosed
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"Error reading responses"
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": stopped, remaining connections "
operator|+
name|connections
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Initiates a rpc call by sending the rpc request to the remote server.      * Note: this is not called from the Connection thread, but by other      * threads.      * @param call - the rpc request      */
DECL|method|sendRpcRequest (final Call call)
specifier|public
name|void
name|sendRpcRequest
parameter_list|(
specifier|final
name|Call
name|call
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|IOException
block|{
if|if
condition|(
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
block|{
return|return;
block|}
comment|// Serialize the call to be sent. This is done from the actual
comment|// caller thread, rather than the sendParamsExecutor thread,
comment|// so that if the serialization throws an error, it is reported
comment|// properly. This also parallelizes the serialization.
comment|//
comment|// Format of a call on the wire:
comment|// 0) Length of rest below (1 + 2)
comment|// 1) RpcRequestHeader  - is serialized Delimited hence contains length
comment|// 2) RpcRequest
comment|//
comment|// Items '1' and '2' are prepared here.
name|RpcRequestHeaderProto
name|header
init|=
name|ProtoUtil
operator|.
name|makeRpcRequestHeader
argument_list|(
name|call
operator|.
name|rpcKind
argument_list|,
name|OperationProto
operator|.
name|RPC_FINAL_PACKET
argument_list|,
name|call
operator|.
name|id
argument_list|,
name|call
operator|.
name|retry
argument_list|,
name|clientId
argument_list|,
name|call
operator|.
name|alignmentContext
argument_list|)
decl_stmt|;
specifier|final
name|ResponseBuffer
name|buf
init|=
operator|new
name|ResponseBuffer
argument_list|()
decl_stmt|;
name|header
operator|.
name|writeDelimitedTo
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|RpcWritable
operator|.
name|wrap
argument_list|(
name|call
operator|.
name|rpcRequest
argument_list|)
operator|.
name|writeTo
argument_list|(
name|buf
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|sendRpcRequestLock
init|)
block|{
name|Future
argument_list|<
name|?
argument_list|>
name|senderFuture
init|=
name|sendParamsExecutor
operator|.
name|submit
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
synchronized|synchronized
init|(
name|ipcStreams
operator|.
name|out
init|)
block|{
if|if
condition|(
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|" sending #"
operator|+
name|call
operator|.
name|id
operator|+
literal|" "
operator|+
name|call
operator|.
name|rpcRequest
argument_list|)
expr_stmt|;
block|}
comment|// RpcRequestHeader + RpcRequest
name|ipcStreams
operator|.
name|sendRequest
argument_list|(
name|buf
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
name|ipcStreams
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// exception at this point would leave the connection in an
comment|// unrecoverable state (eg half a call left on the wire).
comment|// So, close the connection, killing any outstanding calls
name|markClosed
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|//the buffer is just an in-memory buffer, but it is still polite to
comment|// close early
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
decl_stmt|;
try|try
block|{
name|senderFuture
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|Throwable
name|cause
init|=
name|e
operator|.
name|getCause
argument_list|()
decl_stmt|;
comment|// cause should only be a RuntimeException as the Runnable above
comment|// catches IOException
if|if
condition|(
name|cause
operator|instanceof
name|RuntimeException
condition|)
block|{
throw|throw
operator|(
name|RuntimeException
operator|)
name|cause
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unexpected checked exception"
argument_list|,
name|cause
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/* Receive a response.      * Because only one receiver, so no synchronization on in.      */
DECL|method|receiveRpcResponse ()
specifier|private
name|void
name|receiveRpcResponse
parameter_list|()
block|{
if|if
condition|(
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
block|{
return|return;
block|}
name|touch
argument_list|()
expr_stmt|;
try|try
block|{
name|ByteBuffer
name|bb
init|=
name|ipcStreams
operator|.
name|readResponse
argument_list|()
decl_stmt|;
name|RpcWritable
operator|.
name|Buffer
name|packet
init|=
name|RpcWritable
operator|.
name|Buffer
operator|.
name|wrap
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|RpcResponseHeaderProto
name|header
init|=
name|packet
operator|.
name|getValue
argument_list|(
name|RpcResponseHeaderProto
operator|.
name|getDefaultInstance
argument_list|()
argument_list|)
decl_stmt|;
name|checkResponse
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|int
name|callId
init|=
name|header
operator|.
name|getCallId
argument_list|()
decl_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|" got value #"
operator|+
name|callId
argument_list|)
expr_stmt|;
name|RpcStatusProto
name|status
init|=
name|header
operator|.
name|getStatus
argument_list|()
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|RpcStatusProto
operator|.
name|SUCCESS
condition|)
block|{
name|Writable
name|value
init|=
name|packet
operator|.
name|newInstance
argument_list|(
name|valueClass
argument_list|,
name|conf
argument_list|)
decl_stmt|;
specifier|final
name|Call
name|call
init|=
name|calls
operator|.
name|remove
argument_list|(
name|callId
argument_list|)
decl_stmt|;
name|call
operator|.
name|setRpcResponse
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|call
operator|.
name|alignmentContext
operator|!=
literal|null
condition|)
block|{
name|call
operator|.
name|alignmentContext
operator|.
name|receiveResponseState
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
block|}
comment|// verify that packet length was correct
if|if
condition|(
name|packet
operator|.
name|remaining
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|RpcClientException
argument_list|(
literal|"RPC response length mismatch"
argument_list|)
throw|;
block|}
if|if
condition|(
name|status
operator|!=
name|RpcStatusProto
operator|.
name|SUCCESS
condition|)
block|{
comment|// Rpc Request failed
specifier|final
name|String
name|exceptionClassName
init|=
name|header
operator|.
name|hasExceptionClassName
argument_list|()
condition|?
name|header
operator|.
name|getExceptionClassName
argument_list|()
else|:
literal|"ServerDidNotSetExceptionClassName"
decl_stmt|;
specifier|final
name|String
name|errorMsg
init|=
name|header
operator|.
name|hasErrorMsg
argument_list|()
condition|?
name|header
operator|.
name|getErrorMsg
argument_list|()
else|:
literal|"ServerDidNotSetErrorMsg"
decl_stmt|;
specifier|final
name|RpcErrorCodeProto
name|erCode
init|=
operator|(
name|header
operator|.
name|hasErrorDetail
argument_list|()
condition|?
name|header
operator|.
name|getErrorDetail
argument_list|()
else|:
literal|null
operator|)
decl_stmt|;
if|if
condition|(
name|erCode
operator|==
literal|null
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Detailed error code not set by server on rpc error"
argument_list|)
expr_stmt|;
block|}
name|RemoteException
name|re
init|=
operator|new
name|RemoteException
argument_list|(
name|exceptionClassName
argument_list|,
name|errorMsg
argument_list|,
name|erCode
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|RpcStatusProto
operator|.
name|ERROR
condition|)
block|{
specifier|final
name|Call
name|call
init|=
name|calls
operator|.
name|remove
argument_list|(
name|callId
argument_list|)
decl_stmt|;
name|call
operator|.
name|setException
argument_list|(
name|re
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|RpcStatusProto
operator|.
name|FATAL
condition|)
block|{
comment|// Close the connection
name|markClosed
argument_list|(
name|re
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|markClosed
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|markClosed (IOException e)
specifier|private
specifier|synchronized
name|void
name|markClosed
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
if|if
condition|(
name|shouldCloseConnection
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|closeException
operator|=
name|e
expr_stmt|;
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|interruptConnectingThread ()
specifier|private
name|void
name|interruptConnectingThread
parameter_list|()
block|{
name|Thread
name|connThread
init|=
name|connectingThread
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|connThread
operator|!=
literal|null
condition|)
block|{
name|connThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
comment|/** Close the connection. */
DECL|method|close ()
specifier|private
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
operator|!
name|shouldCloseConnection
operator|.
name|get
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|error
argument_list|(
literal|"The connection is not in the closed state"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// We have marked this connection as closed. Other thread could have
comment|// already known it and replace this closedConnection with a new one.
comment|// We should only remove this closedConnection.
name|removeMethod
operator|.
name|accept
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// close the streams and therefore the socket
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|ipcStreams
argument_list|)
expr_stmt|;
name|disposeSasl
argument_list|()
expr_stmt|;
comment|// clean up all calls
if|if
condition|(
name|closeException
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|calls
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"A connection is closed for no cause and calls are not empty"
argument_list|)
expr_stmt|;
comment|// clean up calls anyway
name|closeException
operator|=
operator|new
name|IOException
argument_list|(
literal|"Unexpected closed connection"
argument_list|)
expr_stmt|;
name|cleanupCalls
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// log the info
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"closing ipc connection to "
operator|+
name|server
operator|+
literal|": "
operator|+
name|closeException
operator|.
name|getMessage
argument_list|()
argument_list|,
name|closeException
argument_list|)
expr_stmt|;
block|}
comment|// cleanup calls
name|cleanupCalls
argument_list|()
expr_stmt|;
block|}
name|closeConnection
argument_list|()
expr_stmt|;
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
name|LOG
operator|.
name|debug
argument_list|(
name|getName
argument_list|()
operator|+
literal|": closed"
argument_list|)
expr_stmt|;
block|}
comment|/* Cleanup all calls and mark them as done */
DECL|method|cleanupCalls ()
specifier|private
name|void
name|cleanupCalls
parameter_list|()
block|{
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|Integer
argument_list|,
name|Call
argument_list|>
argument_list|>
name|itor
init|=
name|calls
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|itor
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Call
name|c
init|=
name|itor
operator|.
name|next
argument_list|()
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|itor
operator|.
name|remove
argument_list|()
expr_stmt|;
name|c
operator|.
name|setException
argument_list|(
name|closeException
argument_list|)
expr_stmt|;
comment|// local exception
block|}
block|}
block|}
comment|/** Construct an IPC client whose values are of the given {@link Writable}    * class. */
DECL|method|Client (Class<? extends Writable> valueClass, Configuration conf, SocketFactory factory)
specifier|public
name|Client
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Writable
argument_list|>
name|valueClass
parameter_list|,
name|Configuration
name|conf
parameter_list|,
name|SocketFactory
name|factory
parameter_list|)
block|{
name|this
operator|.
name|valueClass
operator|=
name|valueClass
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
name|this
operator|.
name|socketFactory
operator|=
name|factory
expr_stmt|;
name|this
operator|.
name|connectionTimeout
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeys
operator|.
name|IPC_CLIENT_CONNECT_TIMEOUT_KEY
argument_list|,
name|CommonConfigurationKeys
operator|.
name|IPC_CLIENT_CONNECT_TIMEOUT_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|fallbackAllowed
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|CommonConfigurationKeys
operator|.
name|IPC_CLIENT_FALLBACK_TO_SIMPLE_AUTH_ALLOWED_KEY
argument_list|,
name|CommonConfigurationKeys
operator|.
name|IPC_CLIENT_FALLBACK_TO_SIMPLE_AUTH_ALLOWED_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|bindToWildCardAddress
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|CommonConfigurationKeys
operator|.
name|IPC_CLIENT_BIND_WILDCARD_ADDR_KEY
argument_list|,
name|CommonConfigurationKeys
operator|.
name|IPC_CLIENT_BIND_WILDCARD_ADDR_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|clientId
operator|=
name|ClientId
operator|.
name|getClientId
argument_list|()
expr_stmt|;
name|this
operator|.
name|sendParamsExecutor
operator|=
name|clientExcecutorFactory
operator|.
name|refAndGetInstance
argument_list|()
expr_stmt|;
name|this
operator|.
name|maxAsyncCalls
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeys
operator|.
name|IPC_CLIENT_ASYNC_CALLS_MAX_KEY
argument_list|,
name|CommonConfigurationKeys
operator|.
name|IPC_CLIENT_ASYNC_CALLS_MAX_DEFAULT
argument_list|)
expr_stmt|;
block|}
comment|/**    * Construct an IPC client with the default SocketFactory    * @param valueClass    * @param conf    */
DECL|method|Client (Class<? extends Writable> valueClass, Configuration conf)
specifier|public
name|Client
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Writable
argument_list|>
name|valueClass
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
argument_list|(
name|valueClass
argument_list|,
name|conf
argument_list|,
name|NetUtils
operator|.
name|getDefaultSocketFactory
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"-"
operator|+
name|StringUtils
operator|.
name|byteToHexString
argument_list|(
name|clientId
argument_list|)
return|;
block|}
comment|/** Return the socket factory of this client    *    * @return this client's socket factory    */
DECL|method|getSocketFactory ()
name|SocketFactory
name|getSocketFactory
parameter_list|()
block|{
return|return
name|socketFactory
return|;
block|}
comment|/** Stop all threads related to this client.  No further calls may be made    * using this client. */
DECL|method|stop ()
specifier|public
name|void
name|stop
parameter_list|()
block|{
if|if
condition|(
name|LOG
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|LOG
operator|.
name|debug
argument_list|(
literal|"Stopping client"
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|putLock
init|)
block|{
comment|// synchronized to avoid put after stop
if|if
condition|(
operator|!
name|running
operator|.
name|compareAndSet
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
comment|// wake up all connections
for|for
control|(
name|Connection
name|conn
range|:
name|connections
operator|.
name|values
argument_list|()
control|)
block|{
name|conn
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|conn
operator|.
name|interruptConnectingThread
argument_list|()
expr_stmt|;
block|}
comment|// wait until all connections are closed
synchronized|synchronized
init|(
name|emptyCondition
init|)
block|{
comment|// synchronized the loop to guarantee wait must be notified.
while|while
condition|(
operator|!
name|connections
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
try|try
block|{
name|emptyCondition
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{         }
block|}
block|}
name|clientExcecutorFactory
operator|.
name|unrefAndCleanup
argument_list|()
expr_stmt|;
block|}
comment|/**     * Make a call, passing<code>rpcRequest</code>, to the IPC server defined by    *<code>remoteId</code>, returning the rpc respond.    *    * @param rpcKind    * @param rpcRequest -  contains serialized method and method parameters    * @param remoteId - the target rpc server    * @param fallbackToSimpleAuth - set to true or false during this method to    *   indicate if a secure client falls back to simple auth    * @return the rpc response    * Throws exceptions if there are network problems or if the remote code    * threw an exception.    */
DECL|method|call (RPC.RpcKind rpcKind, Writable rpcRequest, ConnectionId remoteId, AtomicBoolean fallbackToSimpleAuth)
specifier|public
name|Writable
name|call
parameter_list|(
name|RPC
operator|.
name|RpcKind
name|rpcKind
parameter_list|,
name|Writable
name|rpcRequest
parameter_list|,
name|ConnectionId
name|remoteId
parameter_list|,
name|AtomicBoolean
name|fallbackToSimpleAuth
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|call
argument_list|(
name|rpcKind
argument_list|,
name|rpcRequest
argument_list|,
name|remoteId
argument_list|,
name|RPC
operator|.
name|RPC_SERVICE_CLASS_DEFAULT
argument_list|,
name|fallbackToSimpleAuth
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|call (RPC.RpcKind rpcKind, Writable rpcRequest, ConnectionId remoteId, AtomicBoolean fallbackToSimpleAuth, AlignmentContext alignmentContext)
specifier|public
name|Writable
name|call
parameter_list|(
name|RPC
operator|.
name|RpcKind
name|rpcKind
parameter_list|,
name|Writable
name|rpcRequest
parameter_list|,
name|ConnectionId
name|remoteId
parameter_list|,
name|AtomicBoolean
name|fallbackToSimpleAuth
parameter_list|,
name|AlignmentContext
name|alignmentContext
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|call
argument_list|(
name|rpcKind
argument_list|,
name|rpcRequest
argument_list|,
name|remoteId
argument_list|,
name|RPC
operator|.
name|RPC_SERVICE_CLASS_DEFAULT
argument_list|,
name|fallbackToSimpleAuth
argument_list|,
name|alignmentContext
argument_list|)
return|;
block|}
DECL|method|checkAsyncCall ()
specifier|private
name|void
name|checkAsyncCall
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|isAsynchronousMode
argument_list|()
condition|)
block|{
if|if
condition|(
name|asyncCallCounter
operator|.
name|incrementAndGet
argument_list|()
operator|>
name|maxAsyncCalls
condition|)
block|{
name|asyncCallCounter
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
name|String
name|errMsg
init|=
name|String
operator|.
name|format
argument_list|(
literal|"Exceeded limit of max asynchronous calls: %d, "
operator|+
literal|"please configure %s to adjust it."
argument_list|,
name|maxAsyncCalls
argument_list|,
name|CommonConfigurationKeys
operator|.
name|IPC_CLIENT_ASYNC_CALLS_MAX_KEY
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|AsyncCallLimitExceededException
argument_list|(
name|errMsg
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|call (RPC.RpcKind rpcKind, Writable rpcRequest, ConnectionId remoteId, int serviceClass, AtomicBoolean fallbackToSimpleAuth)
name|Writable
name|call
parameter_list|(
name|RPC
operator|.
name|RpcKind
name|rpcKind
parameter_list|,
name|Writable
name|rpcRequest
parameter_list|,
name|ConnectionId
name|remoteId
parameter_list|,
name|int
name|serviceClass
parameter_list|,
name|AtomicBoolean
name|fallbackToSimpleAuth
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|call
argument_list|(
name|rpcKind
argument_list|,
name|rpcRequest
argument_list|,
name|remoteId
argument_list|,
name|serviceClass
argument_list|,
name|fallbackToSimpleAuth
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**    * Make a call, passing<code>rpcRequest</code>, to the IPC server defined by    *<code>remoteId</code>, returning the rpc response.    *    * @param rpcKind    * @param rpcRequest -  contains serialized method and method parameters    * @param remoteId - the target rpc server    * @param serviceClass - service class for RPC    * @param fallbackToSimpleAuth - set to true or false during this method to    *   indicate if a secure client falls back to simple auth    * @param alignmentContext - state alignment context    * @return the rpc response    * Throws exceptions if there are network problems or if the remote code    * threw an exception.    */
DECL|method|call (RPC.RpcKind rpcKind, Writable rpcRequest, ConnectionId remoteId, int serviceClass, AtomicBoolean fallbackToSimpleAuth, AlignmentContext alignmentContext)
name|Writable
name|call
parameter_list|(
name|RPC
operator|.
name|RpcKind
name|rpcKind
parameter_list|,
name|Writable
name|rpcRequest
parameter_list|,
name|ConnectionId
name|remoteId
parameter_list|,
name|int
name|serviceClass
parameter_list|,
name|AtomicBoolean
name|fallbackToSimpleAuth
parameter_list|,
name|AlignmentContext
name|alignmentContext
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Call
name|call
init|=
name|createCall
argument_list|(
name|rpcKind
argument_list|,
name|rpcRequest
argument_list|)
decl_stmt|;
name|call
operator|.
name|setAlignmentContext
argument_list|(
name|alignmentContext
argument_list|)
expr_stmt|;
specifier|final
name|Connection
name|connection
init|=
name|getConnection
argument_list|(
name|remoteId
argument_list|,
name|call
argument_list|,
name|serviceClass
argument_list|,
name|fallbackToSimpleAuth
argument_list|)
decl_stmt|;
try|try
block|{
name|checkAsyncCall
argument_list|()
expr_stmt|;
try|try
block|{
name|connection
operator|.
name|sendRpcRequest
argument_list|(
name|call
argument_list|)
expr_stmt|;
comment|// send the rpc request
block|}
catch|catch
parameter_list|(
name|RejectedExecutionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"connection has been closed"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|LOG
operator|.
name|warn
argument_list|(
literal|"interrupted waiting to send rpc request to server"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|isAsynchronousMode
argument_list|()
condition|)
block|{
name|releaseAsyncCall
argument_list|()
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
if|if
condition|(
name|isAsynchronousMode
argument_list|()
condition|)
block|{
specifier|final
name|AsyncGet
argument_list|<
name|Writable
argument_list|,
name|IOException
argument_list|>
name|asyncGet
init|=
operator|new
name|AsyncGet
argument_list|<
name|Writable
argument_list|,
name|IOException
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Writable
name|get
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|IOException
throws|,
name|TimeoutException
block|{
name|boolean
name|done
init|=
literal|true
decl_stmt|;
try|try
block|{
specifier|final
name|Writable
name|w
init|=
name|getRpcResponse
argument_list|(
name|call
argument_list|,
name|connection
argument_list|,
name|timeout
argument_list|,
name|unit
argument_list|)
decl_stmt|;
if|if
condition|(
name|w
operator|==
literal|null
condition|)
block|{
name|done
operator|=
literal|false
expr_stmt|;
throw|throw
operator|new
name|TimeoutException
argument_list|(
name|call
operator|+
literal|" timed out "
operator|+
name|timeout
operator|+
literal|" "
operator|+
name|unit
argument_list|)
throw|;
block|}
return|return
name|w
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|done
condition|)
block|{
name|releaseAsyncCall
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|isDone
parameter_list|()
block|{
synchronized|synchronized
init|(
name|call
init|)
block|{
return|return
name|call
operator|.
name|done
return|;
block|}
block|}
block|}
decl_stmt|;
name|ASYNC_RPC_RESPONSE
operator|.
name|set
argument_list|(
name|asyncGet
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|getRpcResponse
argument_list|(
name|call
argument_list|,
name|connection
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|)
return|;
block|}
block|}
comment|/**    * Check if RPC is in asynchronous mode or not.    *    * @return true, if RPC is in asynchronous mode, otherwise false for    *          synchronous mode.    */
annotation|@
name|Unstable
DECL|method|isAsynchronousMode ()
specifier|public
specifier|static
name|boolean
name|isAsynchronousMode
parameter_list|()
block|{
return|return
name|asynchronousMode
operator|.
name|get
argument_list|()
return|;
block|}
comment|/**    * Set RPC to asynchronous or synchronous mode.    *    * @param async    *          true, RPC will be in asynchronous mode, otherwise false for    *          synchronous mode    */
annotation|@
name|Unstable
DECL|method|setAsynchronousMode (boolean async)
specifier|public
specifier|static
name|void
name|setAsynchronousMode
parameter_list|(
name|boolean
name|async
parameter_list|)
block|{
name|asynchronousMode
operator|.
name|set
argument_list|(
name|async
argument_list|)
expr_stmt|;
block|}
DECL|method|releaseAsyncCall ()
specifier|private
name|void
name|releaseAsyncCall
parameter_list|()
block|{
name|asyncCallCounter
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getAsyncCallCount ()
name|int
name|getAsyncCallCount
parameter_list|()
block|{
return|return
name|asyncCallCounter
operator|.
name|get
argument_list|()
return|;
block|}
comment|/** @return the rpc response or, in case of timeout, null. */
DECL|method|getRpcResponse (final Call call, final Connection connection, final long timeout, final TimeUnit unit)
specifier|private
name|Writable
name|getRpcResponse
parameter_list|(
specifier|final
name|Call
name|call
parameter_list|,
specifier|final
name|Connection
name|connection
parameter_list|,
specifier|final
name|long
name|timeout
parameter_list|,
specifier|final
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|call
init|)
block|{
while|while
condition|(
operator|!
name|call
operator|.
name|done
condition|)
block|{
try|try
block|{
name|AsyncGet
operator|.
name|Util
operator|.
name|wait
argument_list|(
name|call
argument_list|,
name|timeout
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|>=
literal|0
operator|&&
operator|!
name|call
operator|.
name|done
condition|)
block|{
return|return
literal|null
return|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|InterruptedIOException
argument_list|(
literal|"Call interrupted"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|call
operator|.
name|error
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|call
operator|.
name|error
operator|instanceof
name|RemoteException
condition|)
block|{
name|call
operator|.
name|error
operator|.
name|fillInStackTrace
argument_list|()
expr_stmt|;
throw|throw
name|call
operator|.
name|error
throw|;
block|}
else|else
block|{
comment|// local exception
name|InetSocketAddress
name|address
init|=
name|connection
operator|.
name|getRemoteAddress
argument_list|()
decl_stmt|;
throw|throw
name|NetUtils
operator|.
name|wrapException
argument_list|(
name|address
operator|.
name|getHostName
argument_list|()
argument_list|,
name|address
operator|.
name|getPort
argument_list|()
argument_list|,
name|NetUtils
operator|.
name|getHostname
argument_list|()
argument_list|,
literal|0
argument_list|,
name|call
operator|.
name|error
argument_list|)
throw|;
block|}
block|}
else|else
block|{
return|return
name|call
operator|.
name|getRpcResponse
argument_list|()
return|;
block|}
block|}
block|}
comment|// for unit testing only
annotation|@
name|InterfaceAudience
operator|.
name|Private
annotation|@
name|InterfaceStability
operator|.
name|Unstable
DECL|method|getConnectionIds ()
name|Set
argument_list|<
name|ConnectionId
argument_list|>
name|getConnectionIds
parameter_list|()
block|{
return|return
name|connections
operator|.
name|keySet
argument_list|()
return|;
block|}
comment|/** Get a connection from the pool, or create a new one and add it to the    * pool.  Connections to a given ConnectionId are reused. */
DECL|method|getConnection (ConnectionId remoteId, Call call, int serviceClass, AtomicBoolean fallbackToSimpleAuth)
specifier|private
name|Connection
name|getConnection
parameter_list|(
name|ConnectionId
name|remoteId
parameter_list|,
name|Call
name|call
parameter_list|,
name|int
name|serviceClass
parameter_list|,
name|AtomicBoolean
name|fallbackToSimpleAuth
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|InetSocketAddress
name|address
init|=
name|remoteId
operator|.
name|getAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|address
operator|.
name|isUnresolved
argument_list|()
condition|)
block|{
throw|throw
name|NetUtils
operator|.
name|wrapException
argument_list|(
name|address
operator|.
name|getHostName
argument_list|()
argument_list|,
name|address
operator|.
name|getPort
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
operator|new
name|UnknownHostException
argument_list|()
argument_list|)
throw|;
block|}
specifier|final
name|Consumer
argument_list|<
name|Connection
argument_list|>
name|removeMethod
init|=
name|c
lambda|->
block|{
specifier|final
name|boolean
name|removed
init|=
name|connections
operator|.
name|remove
argument_list|(
name|remoteId
argument_list|,
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|removed
operator|&&
name|connections
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
synchronized|synchronized
init|(
name|emptyCondition
init|)
block|{
name|emptyCondition
operator|.
name|notify
argument_list|()
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
name|Connection
name|connection
decl_stmt|;
comment|/* we could avoid this allocation for each RPC by having a        * connectionsId object and with set() method. We need to manage the      * refs for keys in HashMap properly. For now its ok.      */
while|while
condition|(
literal|true
condition|)
block|{
synchronized|synchronized
init|(
name|putLock
init|)
block|{
comment|// synchronized to avoid put after stop
if|if
condition|(
operator|!
name|running
operator|.
name|get
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Failed to get connection for "
operator|+
name|remoteId
operator|+
literal|", "
operator|+
name|call
operator|+
literal|": "
operator|+
name|this
operator|+
literal|" is already stopped"
argument_list|)
throw|;
block|}
name|connection
operator|=
name|connections
operator|.
name|computeIfAbsent
argument_list|(
name|remoteId
argument_list|,
name|id
lambda|->
operator|new
name|Connection
argument_list|(
name|id
argument_list|,
name|serviceClass
argument_list|,
name|removeMethod
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|connection
operator|.
name|addCall
argument_list|(
name|call
argument_list|)
condition|)
block|{
break|break;
block|}
else|else
block|{
comment|// This connection is closed, should be removed. But other thread could
comment|// have already known this closedConnection, and replace it with a new
comment|// connection. So we should call conditional remove to make sure we only
comment|// remove this closedConnection.
name|removeMethod
operator|.
name|accept
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
comment|// If the server happens to be slow, the method below will take longer to
comment|// establish a connection.
name|connection
operator|.
name|setupIOstreams
argument_list|(
name|fallbackToSimpleAuth
argument_list|)
expr_stmt|;
return|return
name|connection
return|;
block|}
comment|/**    * This class holds the address and the user ticket. The client connections    * to servers are uniquely identified by {@literal<}remoteAddress, protocol,    * ticket{@literal>}    */
annotation|@
name|InterfaceAudience
operator|.
name|LimitedPrivate
argument_list|(
block|{
literal|"HDFS"
block|,
literal|"MapReduce"
block|}
argument_list|)
annotation|@
name|InterfaceStability
operator|.
name|Evolving
DECL|class|ConnectionId
specifier|public
specifier|static
class|class
name|ConnectionId
block|{
DECL|field|address
name|InetSocketAddress
name|address
decl_stmt|;
DECL|field|ticket
name|UserGroupInformation
name|ticket
decl_stmt|;
DECL|field|protocol
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|protocol
decl_stmt|;
DECL|field|PRIME
specifier|private
specifier|static
specifier|final
name|int
name|PRIME
init|=
literal|16777619
decl_stmt|;
DECL|field|rpcTimeout
specifier|private
specifier|final
name|int
name|rpcTimeout
decl_stmt|;
DECL|field|maxIdleTime
specifier|private
specifier|final
name|int
name|maxIdleTime
decl_stmt|;
comment|//connections will be culled if it was idle for
comment|//maxIdleTime msecs
DECL|field|connectionRetryPolicy
specifier|private
specifier|final
name|RetryPolicy
name|connectionRetryPolicy
decl_stmt|;
DECL|field|maxRetriesOnSasl
specifier|private
specifier|final
name|int
name|maxRetriesOnSasl
decl_stmt|;
comment|// the max. no. of retries for socket connections on time out exceptions
DECL|field|maxRetriesOnSocketTimeouts
specifier|private
specifier|final
name|int
name|maxRetriesOnSocketTimeouts
decl_stmt|;
DECL|field|tcpNoDelay
specifier|private
specifier|final
name|boolean
name|tcpNoDelay
decl_stmt|;
comment|// if T then disable Nagle's Algorithm
DECL|field|tcpLowLatency
specifier|private
specifier|final
name|boolean
name|tcpLowLatency
decl_stmt|;
comment|// if T then use low-delay QoS
DECL|field|doPing
specifier|private
specifier|final
name|boolean
name|doPing
decl_stmt|;
comment|//do we need to send ping message
DECL|field|pingInterval
specifier|private
specifier|final
name|int
name|pingInterval
decl_stmt|;
comment|// how often sends ping to the server in msecs
DECL|field|saslQop
specifier|private
name|String
name|saslQop
decl_stmt|;
comment|// here for testing
DECL|field|conf
specifier|private
specifier|final
name|Configuration
name|conf
decl_stmt|;
comment|// used to get the expected kerberos principal name
DECL|method|ConnectionId (InetSocketAddress address, Class<?> protocol, UserGroupInformation ticket, int rpcTimeout, RetryPolicy connectionRetryPolicy, Configuration conf)
name|ConnectionId
parameter_list|(
name|InetSocketAddress
name|address
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|protocol
parameter_list|,
name|UserGroupInformation
name|ticket
parameter_list|,
name|int
name|rpcTimeout
parameter_list|,
name|RetryPolicy
name|connectionRetryPolicy
parameter_list|,
name|Configuration
name|conf
parameter_list|)
block|{
name|this
operator|.
name|protocol
operator|=
name|protocol
expr_stmt|;
name|this
operator|.
name|address
operator|=
name|address
expr_stmt|;
name|this
operator|.
name|ticket
operator|=
name|ticket
expr_stmt|;
name|this
operator|.
name|rpcTimeout
operator|=
name|rpcTimeout
expr_stmt|;
name|this
operator|.
name|connectionRetryPolicy
operator|=
name|connectionRetryPolicy
expr_stmt|;
name|this
operator|.
name|maxIdleTime
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|IPC_CLIENT_CONNECTION_MAXIDLETIME_KEY
argument_list|,
name|CommonConfigurationKeysPublic
operator|.
name|IPC_CLIENT_CONNECTION_MAXIDLETIME_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxRetriesOnSasl
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeys
operator|.
name|IPC_CLIENT_CONNECT_MAX_RETRIES_ON_SASL_KEY
argument_list|,
name|CommonConfigurationKeys
operator|.
name|IPC_CLIENT_CONNECT_MAX_RETRIES_ON_SASL_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxRetriesOnSocketTimeouts
operator|=
name|conf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|IPC_CLIENT_CONNECT_MAX_RETRIES_ON_SOCKET_TIMEOUTS_KEY
argument_list|,
name|CommonConfigurationKeysPublic
operator|.
name|IPC_CLIENT_CONNECT_MAX_RETRIES_ON_SOCKET_TIMEOUTS_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|tcpNoDelay
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|IPC_CLIENT_TCPNODELAY_KEY
argument_list|,
name|CommonConfigurationKeysPublic
operator|.
name|IPC_CLIENT_TCPNODELAY_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|tcpLowLatency
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|IPC_CLIENT_LOW_LATENCY
argument_list|,
name|CommonConfigurationKeysPublic
operator|.
name|IPC_CLIENT_LOW_LATENCY_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|doPing
operator|=
name|conf
operator|.
name|getBoolean
argument_list|(
name|CommonConfigurationKeys
operator|.
name|IPC_CLIENT_PING_KEY
argument_list|,
name|CommonConfigurationKeys
operator|.
name|IPC_CLIENT_PING_DEFAULT
argument_list|)
expr_stmt|;
name|this
operator|.
name|pingInterval
operator|=
operator|(
name|doPing
condition|?
name|Client
operator|.
name|getPingInterval
argument_list|(
name|conf
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|this
operator|.
name|conf
operator|=
name|conf
expr_stmt|;
block|}
DECL|method|getAddress ()
name|InetSocketAddress
name|getAddress
parameter_list|()
block|{
return|return
name|address
return|;
block|}
DECL|method|getProtocol ()
name|Class
argument_list|<
name|?
argument_list|>
name|getProtocol
parameter_list|()
block|{
return|return
name|protocol
return|;
block|}
DECL|method|getTicket ()
name|UserGroupInformation
name|getTicket
parameter_list|()
block|{
return|return
name|ticket
return|;
block|}
DECL|method|getRpcTimeout ()
specifier|private
name|int
name|getRpcTimeout
parameter_list|()
block|{
return|return
name|rpcTimeout
return|;
block|}
DECL|method|getMaxIdleTime ()
name|int
name|getMaxIdleTime
parameter_list|()
block|{
return|return
name|maxIdleTime
return|;
block|}
DECL|method|getMaxRetriesOnSasl ()
specifier|public
name|int
name|getMaxRetriesOnSasl
parameter_list|()
block|{
return|return
name|maxRetriesOnSasl
return|;
block|}
comment|/** max connection retries on socket time outs */
DECL|method|getMaxRetriesOnSocketTimeouts ()
specifier|public
name|int
name|getMaxRetriesOnSocketTimeouts
parameter_list|()
block|{
return|return
name|maxRetriesOnSocketTimeouts
return|;
block|}
comment|/** disable nagle's algorithm */
DECL|method|getTcpNoDelay ()
name|boolean
name|getTcpNoDelay
parameter_list|()
block|{
return|return
name|tcpNoDelay
return|;
block|}
comment|/** use low-latency QoS bits over TCP */
DECL|method|getTcpLowLatency ()
name|boolean
name|getTcpLowLatency
parameter_list|()
block|{
return|return
name|tcpLowLatency
return|;
block|}
DECL|method|getDoPing ()
name|boolean
name|getDoPing
parameter_list|()
block|{
return|return
name|doPing
return|;
block|}
DECL|method|getPingInterval ()
name|int
name|getPingInterval
parameter_list|()
block|{
return|return
name|pingInterval
return|;
block|}
annotation|@
name|VisibleForTesting
DECL|method|getSaslQop ()
name|String
name|getSaslQop
parameter_list|()
block|{
return|return
name|saslQop
return|;
block|}
comment|/**      * Returns a ConnectionId object.       * @param addr Remote address for the connection.      * @param protocol Protocol for RPC.      * @param ticket UGI      * @param rpcTimeout timeout      * @param conf Configuration object      * @return A ConnectionId instance      * @throws IOException      */
DECL|method|getConnectionId (InetSocketAddress addr, Class<?> protocol, UserGroupInformation ticket, int rpcTimeout, RetryPolicy connectionRetryPolicy, Configuration conf)
specifier|static
name|ConnectionId
name|getConnectionId
parameter_list|(
name|InetSocketAddress
name|addr
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|protocol
parameter_list|,
name|UserGroupInformation
name|ticket
parameter_list|,
name|int
name|rpcTimeout
parameter_list|,
name|RetryPolicy
name|connectionRetryPolicy
parameter_list|,
name|Configuration
name|conf
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|connectionRetryPolicy
operator|==
literal|null
condition|)
block|{
specifier|final
name|int
name|max
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|IPC_CLIENT_CONNECT_MAX_RETRIES_KEY
argument_list|,
name|CommonConfigurationKeysPublic
operator|.
name|IPC_CLIENT_CONNECT_MAX_RETRIES_DEFAULT
argument_list|)
decl_stmt|;
specifier|final
name|int
name|retryInterval
init|=
name|conf
operator|.
name|getInt
argument_list|(
name|CommonConfigurationKeysPublic
operator|.
name|IPC_CLIENT_CONNECT_RETRY_INTERVAL_KEY
argument_list|,
name|CommonConfigurationKeysPublic
operator|.
name|IPC_CLIENT_CONNECT_RETRY_INTERVAL_DEFAULT
argument_list|)
decl_stmt|;
name|connectionRetryPolicy
operator|=
name|RetryPolicies
operator|.
name|retryUpToMaximumCountWithFixedSleep
argument_list|(
name|max
argument_list|,
name|retryInterval
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|ConnectionId
argument_list|(
name|addr
argument_list|,
name|protocol
argument_list|,
name|ticket
argument_list|,
name|rpcTimeout
argument_list|,
name|connectionRetryPolicy
argument_list|,
name|conf
argument_list|)
return|;
block|}
DECL|method|isEqual (Object a, Object b)
specifier|static
name|boolean
name|isEqual
parameter_list|(
name|Object
name|a
parameter_list|,
name|Object
name|b
parameter_list|)
block|{
return|return
name|a
operator|==
literal|null
condition|?
name|b
operator|==
literal|null
else|:
name|a
operator|.
name|equals
argument_list|(
name|b
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|equals (Object obj)
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|obj
operator|instanceof
name|ConnectionId
condition|)
block|{
name|ConnectionId
name|that
init|=
operator|(
name|ConnectionId
operator|)
name|obj
decl_stmt|;
return|return
name|isEqual
argument_list|(
name|this
operator|.
name|address
argument_list|,
name|that
operator|.
name|address
argument_list|)
operator|&&
name|this
operator|.
name|doPing
operator|==
name|that
operator|.
name|doPing
operator|&&
name|this
operator|.
name|maxIdleTime
operator|==
name|that
operator|.
name|maxIdleTime
operator|&&
name|isEqual
argument_list|(
name|this
operator|.
name|connectionRetryPolicy
argument_list|,
name|that
operator|.
name|connectionRetryPolicy
argument_list|)
operator|&&
name|this
operator|.
name|pingInterval
operator|==
name|that
operator|.
name|pingInterval
operator|&&
name|isEqual
argument_list|(
name|this
operator|.
name|protocol
argument_list|,
name|that
operator|.
name|protocol
argument_list|)
operator|&&
name|this
operator|.
name|rpcTimeout
operator|==
name|that
operator|.
name|rpcTimeout
operator|&&
name|this
operator|.
name|tcpNoDelay
operator|==
name|that
operator|.
name|tcpNoDelay
operator|&&
name|isEqual
argument_list|(
name|this
operator|.
name|ticket
argument_list|,
name|that
operator|.
name|ticket
argument_list|)
return|;
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|result
init|=
name|connectionRetryPolicy
operator|.
name|hashCode
argument_list|()
decl_stmt|;
name|result
operator|=
name|PRIME
operator|*
name|result
operator|+
operator|(
operator|(
name|address
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|address
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
name|result
operator|=
name|PRIME
operator|*
name|result
operator|+
operator|(
name|doPing
condition|?
literal|1231
else|:
literal|1237
operator|)
expr_stmt|;
name|result
operator|=
name|PRIME
operator|*
name|result
operator|+
name|maxIdleTime
expr_stmt|;
name|result
operator|=
name|PRIME
operator|*
name|result
operator|+
name|pingInterval
expr_stmt|;
name|result
operator|=
name|PRIME
operator|*
name|result
operator|+
operator|(
operator|(
name|protocol
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|protocol
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
name|result
operator|=
name|PRIME
operator|*
name|result
operator|+
name|rpcTimeout
expr_stmt|;
name|result
operator|=
name|PRIME
operator|*
name|result
operator|+
operator|(
name|tcpNoDelay
condition|?
literal|1231
else|:
literal|1237
operator|)
expr_stmt|;
name|result
operator|=
name|PRIME
operator|*
name|result
operator|+
operator|(
operator|(
name|ticket
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|ticket
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|address
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**    * Returns the next valid sequential call ID by incrementing an atomic counter    * and masking off the sign bit.  Valid call IDs are non-negative integers in    * the range [ 0, 2^31 - 1 ].  Negative numbers are reserved for special    * purposes.  The values can overflow back to 0 and be reused.  Note that prior    * versions of the client did not mask off the sign bit, so a server may still    * see a negative call ID if it receives connections from an old client.    *     * @return next call ID    */
DECL|method|nextCallId ()
specifier|public
specifier|static
name|int
name|nextCallId
parameter_list|()
block|{
return|return
name|callIdCounter
operator|.
name|getAndIncrement
argument_list|()
operator|&
literal|0x7FFFFFFF
return|;
block|}
annotation|@
name|Override
annotation|@
name|Unstable
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|Exception
block|{
name|stop
argument_list|()
expr_stmt|;
block|}
comment|/** Manages the input and output streams for an IPC connection.    *  Only exposed for use by SaslRpcClient.    */
annotation|@
name|InterfaceAudience
operator|.
name|Private
DECL|class|IpcStreams
specifier|public
specifier|static
class|class
name|IpcStreams
implements|implements
name|Closeable
implements|,
name|Flushable
block|{
DECL|field|in
specifier|private
name|DataInputStream
name|in
decl_stmt|;
DECL|field|out
specifier|public
name|DataOutputStream
name|out
decl_stmt|;
DECL|field|maxResponseLength
specifier|private
name|int
name|maxResponseLength
decl_stmt|;
DECL|field|firstResponse
specifier|private
name|boolean
name|firstResponse
init|=
literal|true
decl_stmt|;
DECL|method|IpcStreams (Socket socket, int maxResponseLength)
name|IpcStreams
parameter_list|(
name|Socket
name|socket
parameter_list|,
name|int
name|maxResponseLength
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|maxResponseLength
operator|=
name|maxResponseLength
expr_stmt|;
name|setInputStream
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
name|NetUtils
operator|.
name|getInputStream
argument_list|(
name|socket
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setOutputStream
argument_list|(
operator|new
name|BufferedOutputStream
argument_list|(
name|NetUtils
operator|.
name|getOutputStream
argument_list|(
name|socket
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|setSaslClient (SaslRpcClient client)
name|void
name|setSaslClient
parameter_list|(
name|SaslRpcClient
name|client
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Wrap the input stream in a BufferedInputStream to fill the buffer
comment|// before reading its length (HADOOP-14062).
name|setInputStream
argument_list|(
operator|new
name|BufferedInputStream
argument_list|(
name|client
operator|.
name|getInputStream
argument_list|(
name|in
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setOutputStream
argument_list|(
name|client
operator|.
name|getOutputStream
argument_list|(
name|out
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|setInputStream (InputStream is)
specifier|private
name|void
name|setInputStream
parameter_list|(
name|InputStream
name|is
parameter_list|)
block|{
name|this
operator|.
name|in
operator|=
operator|(
name|is
operator|instanceof
name|DataInputStream
operator|)
condition|?
operator|(
name|DataInputStream
operator|)
name|is
else|:
operator|new
name|DataInputStream
argument_list|(
name|is
argument_list|)
expr_stmt|;
block|}
DECL|method|setOutputStream (OutputStream os)
specifier|private
name|void
name|setOutputStream
parameter_list|(
name|OutputStream
name|os
parameter_list|)
block|{
name|this
operator|.
name|out
operator|=
operator|(
name|os
operator|instanceof
name|DataOutputStream
operator|)
condition|?
operator|(
name|DataOutputStream
operator|)
name|os
else|:
operator|new
name|DataOutputStream
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
DECL|method|readResponse ()
specifier|public
name|ByteBuffer
name|readResponse
parameter_list|()
throws|throws
name|IOException
block|{
name|int
name|length
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|firstResponse
condition|)
block|{
name|firstResponse
operator|=
literal|false
expr_stmt|;
comment|// pre-rpcv9 exception, almost certainly a version mismatch.
if|if
condition|(
name|length
operator|==
operator|-
literal|1
condition|)
block|{
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
comment|// ignore fatal/error status, it's fatal for us.
throw|throw
operator|new
name|RemoteException
argument_list|(
name|WritableUtils
operator|.
name|readString
argument_list|(
name|in
argument_list|)
argument_list|,
name|WritableUtils
operator|.
name|readString
argument_list|(
name|in
argument_list|)
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|length
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|RpcException
argument_list|(
literal|"RPC response has invalid length"
argument_list|)
throw|;
block|}
if|if
condition|(
name|maxResponseLength
operator|>
literal|0
operator|&&
name|length
operator|>
name|maxResponseLength
condition|)
block|{
throw|throw
operator|new
name|RpcException
argument_list|(
literal|"RPC response exceeds maximum data length"
argument_list|)
throw|;
block|}
name|ByteBuffer
name|bb
init|=
name|ByteBuffer
operator|.
name|allocate
argument_list|(
name|length
argument_list|)
decl_stmt|;
name|in
operator|.
name|readFully
argument_list|(
name|bb
operator|.
name|array
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|bb
return|;
block|}
DECL|method|sendRequest (byte[] buf)
specifier|public
name|void
name|sendRequest
parameter_list|(
name|byte
index|[]
name|buf
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|write
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|flush ()
specifier|public
name|void
name|flush
parameter_list|()
throws|throws
name|IOException
block|{
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|close ()
specifier|public
name|void
name|close
parameter_list|()
block|{
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeStream
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

