begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.io.retry
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|ConnectException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|NoRouteToHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|StandbyException
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|annotations
operator|.
name|VisibleForTesting
import|;
end_import

begin_comment
comment|/**  *<p>  * A collection of useful implementations of {@link RetryPolicy}.  *</p>  */
end_comment

begin_class
DECL|class|RetryPolicies
specifier|public
class|class
name|RetryPolicies
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|RetryPolicies
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|RAND
specifier|private
specifier|static
specifier|final
name|Random
name|RAND
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
comment|/**    *<p>    * Try once, and fail by re-throwing the exception.    * This corresponds to having no retry mechanism in place.    *</p>    */
DECL|field|TRY_ONCE_THEN_FAIL
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|TRY_ONCE_THEN_FAIL
init|=
operator|new
name|TryOnceThenFail
argument_list|()
decl_stmt|;
comment|/**    *<p>    * Try once, and fail silently for<code>void</code> methods, or by    * re-throwing the exception for non-<code>void</code> methods.    *</p>    */
DECL|field|TRY_ONCE_DONT_FAIL
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|TRY_ONCE_DONT_FAIL
init|=
operator|new
name|TryOnceDontFail
argument_list|()
decl_stmt|;
comment|/**    *<p>    * Keep trying forever.    *</p>    */
DECL|field|RETRY_FOREVER
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|RETRY_FOREVER
init|=
operator|new
name|RetryForever
argument_list|()
decl_stmt|;
comment|/**    *<p>    * Keep trying a limited number of times, waiting a fixed time between attempts,    * and then fail by re-throwing the exception.    *</p>    */
DECL|method|retryUpToMaximumCountWithFixedSleep (int maxRetries, long sleepTime, TimeUnit timeUnit)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|retryUpToMaximumCountWithFixedSleep
parameter_list|(
name|int
name|maxRetries
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
return|return
operator|new
name|RetryUpToMaximumCountWithFixedSleep
argument_list|(
name|maxRetries
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
return|;
block|}
comment|/**    *<p>    * Keep trying for a maximum time, waiting a fixed time between attempts,    * and then fail by re-throwing the exception.    *</p>    */
DECL|method|retryUpToMaximumTimeWithFixedSleep (long maxTime, long sleepTime, TimeUnit timeUnit)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|retryUpToMaximumTimeWithFixedSleep
parameter_list|(
name|long
name|maxTime
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
return|return
operator|new
name|RetryUpToMaximumTimeWithFixedSleep
argument_list|(
name|maxTime
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
return|;
block|}
comment|/**    *<p>    * Keep trying a limited number of times, waiting a growing amount of time between attempts,    * and then fail by re-throwing the exception.    * The time between attempts is<code>sleepTime</code> mutliplied by the number of tries so far.    *</p>    */
DECL|method|retryUpToMaximumCountWithProportionalSleep (int maxRetries, long sleepTime, TimeUnit timeUnit)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|retryUpToMaximumCountWithProportionalSleep
parameter_list|(
name|int
name|maxRetries
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
return|return
operator|new
name|RetryUpToMaximumCountWithProportionalSleep
argument_list|(
name|maxRetries
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
return|;
block|}
comment|/**    *<p>    * Keep trying a limited number of times, waiting a growing amount of time between attempts,    * and then fail by re-throwing the exception.    * The time between attempts is<code>sleepTime</code> mutliplied by a random    * number in the range of [0, 2 to the number of retries)    *</p>    */
DECL|method|exponentialBackoffRetry ( int maxRetries, long sleepTime, TimeUnit timeUnit)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|exponentialBackoffRetry
parameter_list|(
name|int
name|maxRetries
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
return|return
operator|new
name|ExponentialBackoffRetry
argument_list|(
name|maxRetries
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
return|;
block|}
comment|/**    *<p>    * Set a default policy with some explicit handlers for specific exceptions.    *</p>    */
DECL|method|retryByException (RetryPolicy defaultPolicy, Map<Class<? extends Exception>, RetryPolicy> exceptionToPolicyMap)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|retryByException
parameter_list|(
name|RetryPolicy
name|defaultPolicy
parameter_list|,
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
argument_list|,
name|RetryPolicy
argument_list|>
name|exceptionToPolicyMap
parameter_list|)
block|{
return|return
operator|new
name|ExceptionDependentRetry
argument_list|(
name|defaultPolicy
argument_list|,
name|exceptionToPolicyMap
argument_list|)
return|;
block|}
comment|/**    *<p>    * A retry policy for RemoteException    * Set a default policy with some explicit handlers for specific exceptions.    *</p>    */
DECL|method|retryByRemoteException ( RetryPolicy defaultPolicy, Map<Class<? extends Exception>, RetryPolicy> exceptionToPolicyMap)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|retryByRemoteException
parameter_list|(
name|RetryPolicy
name|defaultPolicy
parameter_list|,
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
argument_list|,
name|RetryPolicy
argument_list|>
name|exceptionToPolicyMap
parameter_list|)
block|{
return|return
operator|new
name|RemoteExceptionDependentRetry
argument_list|(
name|defaultPolicy
argument_list|,
name|exceptionToPolicyMap
argument_list|)
return|;
block|}
DECL|method|failoverOnNetworkException (int maxFailovers)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|failoverOnNetworkException
parameter_list|(
name|int
name|maxFailovers
parameter_list|)
block|{
return|return
name|failoverOnNetworkException
argument_list|(
name|TRY_ONCE_THEN_FAIL
argument_list|,
name|maxFailovers
argument_list|)
return|;
block|}
DECL|method|failoverOnNetworkException ( RetryPolicy fallbackPolicy, int maxFailovers)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|failoverOnNetworkException
parameter_list|(
name|RetryPolicy
name|fallbackPolicy
parameter_list|,
name|int
name|maxFailovers
parameter_list|)
block|{
return|return
name|failoverOnNetworkException
argument_list|(
name|fallbackPolicy
argument_list|,
name|maxFailovers
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
DECL|method|failoverOnNetworkException ( RetryPolicy fallbackPolicy, int maxFailovers, long delayMillis, long maxDelayBase)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|failoverOnNetworkException
parameter_list|(
name|RetryPolicy
name|fallbackPolicy
parameter_list|,
name|int
name|maxFailovers
parameter_list|,
name|long
name|delayMillis
parameter_list|,
name|long
name|maxDelayBase
parameter_list|)
block|{
return|return
operator|new
name|FailoverOnNetworkExceptionRetry
argument_list|(
name|fallbackPolicy
argument_list|,
name|maxFailovers
argument_list|,
name|delayMillis
argument_list|,
name|maxDelayBase
argument_list|)
return|;
block|}
DECL|class|TryOnceThenFail
specifier|static
class|class
name|TryOnceThenFail
implements|implements
name|RetryPolicy
block|{
DECL|method|shouldRetry (Exception e, int retries, int failovers, boolean isMethodIdempotent)
specifier|public
name|RetryAction
name|shouldRetry
parameter_list|(
name|Exception
name|e
parameter_list|,
name|int
name|retries
parameter_list|,
name|int
name|failovers
parameter_list|,
name|boolean
name|isMethodIdempotent
parameter_list|)
throws|throws
name|Exception
block|{
throw|throw
name|e
throw|;
block|}
block|}
DECL|class|TryOnceDontFail
specifier|static
class|class
name|TryOnceDontFail
implements|implements
name|RetryPolicy
block|{
DECL|method|shouldRetry (Exception e, int retries, int failovers, boolean isMethodIdempotent)
specifier|public
name|RetryAction
name|shouldRetry
parameter_list|(
name|Exception
name|e
parameter_list|,
name|int
name|retries
parameter_list|,
name|int
name|failovers
parameter_list|,
name|boolean
name|isMethodIdempotent
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|RetryAction
operator|.
name|FAIL
return|;
block|}
block|}
DECL|class|RetryForever
specifier|static
class|class
name|RetryForever
implements|implements
name|RetryPolicy
block|{
DECL|method|shouldRetry (Exception e, int retries, int failovers, boolean isMethodIdempotent)
specifier|public
name|RetryAction
name|shouldRetry
parameter_list|(
name|Exception
name|e
parameter_list|,
name|int
name|retries
parameter_list|,
name|int
name|failovers
parameter_list|,
name|boolean
name|isMethodIdempotent
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|RetryAction
operator|.
name|RETRY
return|;
block|}
block|}
DECL|class|RetryLimited
specifier|static
specifier|abstract
class|class
name|RetryLimited
implements|implements
name|RetryPolicy
block|{
DECL|field|maxRetries
name|int
name|maxRetries
decl_stmt|;
DECL|field|sleepTime
name|long
name|sleepTime
decl_stmt|;
DECL|field|timeUnit
name|TimeUnit
name|timeUnit
decl_stmt|;
DECL|method|RetryLimited (int maxRetries, long sleepTime, TimeUnit timeUnit)
specifier|public
name|RetryLimited
parameter_list|(
name|int
name|maxRetries
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
name|this
operator|.
name|maxRetries
operator|=
name|maxRetries
expr_stmt|;
name|this
operator|.
name|sleepTime
operator|=
name|sleepTime
expr_stmt|;
name|this
operator|.
name|timeUnit
operator|=
name|timeUnit
expr_stmt|;
block|}
DECL|method|shouldRetry (Exception e, int retries, int failovers, boolean isMethodIdempotent)
specifier|public
name|RetryAction
name|shouldRetry
parameter_list|(
name|Exception
name|e
parameter_list|,
name|int
name|retries
parameter_list|,
name|int
name|failovers
parameter_list|,
name|boolean
name|isMethodIdempotent
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|retries
operator|>=
name|maxRetries
condition|)
block|{
throw|throw
name|e
throw|;
block|}
return|return
operator|new
name|RetryAction
argument_list|(
name|RetryAction
operator|.
name|RetryDecision
operator|.
name|RETRY
argument_list|,
name|timeUnit
operator|.
name|toMillis
argument_list|(
name|calculateSleepTime
argument_list|(
name|retries
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
DECL|method|calculateSleepTime (int retries)
specifier|protected
specifier|abstract
name|long
name|calculateSleepTime
parameter_list|(
name|int
name|retries
parameter_list|)
function_decl|;
block|}
DECL|class|RetryUpToMaximumCountWithFixedSleep
specifier|static
class|class
name|RetryUpToMaximumCountWithFixedSleep
extends|extends
name|RetryLimited
block|{
DECL|method|RetryUpToMaximumCountWithFixedSleep (int maxRetries, long sleepTime, TimeUnit timeUnit)
specifier|public
name|RetryUpToMaximumCountWithFixedSleep
parameter_list|(
name|int
name|maxRetries
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
name|super
argument_list|(
name|maxRetries
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|calculateSleepTime (int retries)
specifier|protected
name|long
name|calculateSleepTime
parameter_list|(
name|int
name|retries
parameter_list|)
block|{
return|return
name|sleepTime
return|;
block|}
block|}
DECL|class|RetryUpToMaximumTimeWithFixedSleep
specifier|static
class|class
name|RetryUpToMaximumTimeWithFixedSleep
extends|extends
name|RetryUpToMaximumCountWithFixedSleep
block|{
DECL|method|RetryUpToMaximumTimeWithFixedSleep (long maxTime, long sleepTime, TimeUnit timeUnit)
specifier|public
name|RetryUpToMaximumTimeWithFixedSleep
parameter_list|(
name|long
name|maxTime
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
name|super
argument_list|(
call|(
name|int
call|)
argument_list|(
name|maxTime
operator|/
name|sleepTime
argument_list|)
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|RetryUpToMaximumCountWithProportionalSleep
specifier|static
class|class
name|RetryUpToMaximumCountWithProportionalSleep
extends|extends
name|RetryLimited
block|{
DECL|method|RetryUpToMaximumCountWithProportionalSleep (int maxRetries, long sleepTime, TimeUnit timeUnit)
specifier|public
name|RetryUpToMaximumCountWithProportionalSleep
parameter_list|(
name|int
name|maxRetries
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
name|super
argument_list|(
name|maxRetries
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|calculateSleepTime (int retries)
specifier|protected
name|long
name|calculateSleepTime
parameter_list|(
name|int
name|retries
parameter_list|)
block|{
return|return
name|sleepTime
operator|*
operator|(
name|retries
operator|+
literal|1
operator|)
return|;
block|}
block|}
DECL|class|ExceptionDependentRetry
specifier|static
class|class
name|ExceptionDependentRetry
implements|implements
name|RetryPolicy
block|{
DECL|field|defaultPolicy
name|RetryPolicy
name|defaultPolicy
decl_stmt|;
DECL|field|exceptionToPolicyMap
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
argument_list|,
name|RetryPolicy
argument_list|>
name|exceptionToPolicyMap
decl_stmt|;
DECL|method|ExceptionDependentRetry (RetryPolicy defaultPolicy, Map<Class<? extends Exception>, RetryPolicy> exceptionToPolicyMap)
specifier|public
name|ExceptionDependentRetry
parameter_list|(
name|RetryPolicy
name|defaultPolicy
parameter_list|,
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
argument_list|,
name|RetryPolicy
argument_list|>
name|exceptionToPolicyMap
parameter_list|)
block|{
name|this
operator|.
name|defaultPolicy
operator|=
name|defaultPolicy
expr_stmt|;
name|this
operator|.
name|exceptionToPolicyMap
operator|=
name|exceptionToPolicyMap
expr_stmt|;
block|}
DECL|method|shouldRetry (Exception e, int retries, int failovers, boolean isMethodIdempotent)
specifier|public
name|RetryAction
name|shouldRetry
parameter_list|(
name|Exception
name|e
parameter_list|,
name|int
name|retries
parameter_list|,
name|int
name|failovers
parameter_list|,
name|boolean
name|isMethodIdempotent
parameter_list|)
throws|throws
name|Exception
block|{
name|RetryPolicy
name|policy
init|=
name|exceptionToPolicyMap
operator|.
name|get
argument_list|(
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|policy
operator|==
literal|null
condition|)
block|{
name|policy
operator|=
name|defaultPolicy
expr_stmt|;
block|}
return|return
name|policy
operator|.
name|shouldRetry
argument_list|(
name|e
argument_list|,
name|retries
argument_list|,
name|failovers
argument_list|,
name|isMethodIdempotent
argument_list|)
return|;
block|}
block|}
DECL|class|RemoteExceptionDependentRetry
specifier|static
class|class
name|RemoteExceptionDependentRetry
implements|implements
name|RetryPolicy
block|{
DECL|field|defaultPolicy
name|RetryPolicy
name|defaultPolicy
decl_stmt|;
DECL|field|exceptionNameToPolicyMap
name|Map
argument_list|<
name|String
argument_list|,
name|RetryPolicy
argument_list|>
name|exceptionNameToPolicyMap
decl_stmt|;
DECL|method|RemoteExceptionDependentRetry (RetryPolicy defaultPolicy, Map<Class<? extends Exception>, RetryPolicy> exceptionToPolicyMap)
specifier|public
name|RemoteExceptionDependentRetry
parameter_list|(
name|RetryPolicy
name|defaultPolicy
parameter_list|,
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
argument_list|,
name|RetryPolicy
argument_list|>
name|exceptionToPolicyMap
parameter_list|)
block|{
name|this
operator|.
name|defaultPolicy
operator|=
name|defaultPolicy
expr_stmt|;
name|this
operator|.
name|exceptionNameToPolicyMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|RetryPolicy
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
argument_list|,
name|RetryPolicy
argument_list|>
name|e
range|:
name|exceptionToPolicyMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|exceptionNameToPolicyMap
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|shouldRetry (Exception e, int retries, int failovers, boolean isMethodIdempotent)
specifier|public
name|RetryAction
name|shouldRetry
parameter_list|(
name|Exception
name|e
parameter_list|,
name|int
name|retries
parameter_list|,
name|int
name|failovers
parameter_list|,
name|boolean
name|isMethodIdempotent
parameter_list|)
throws|throws
name|Exception
block|{
name|RetryPolicy
name|policy
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
name|policy
operator|=
name|exceptionNameToPolicyMap
operator|.
name|get
argument_list|(
operator|(
operator|(
name|RemoteException
operator|)
name|e
operator|)
operator|.
name|getClassName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|policy
operator|==
literal|null
condition|)
block|{
name|policy
operator|=
name|defaultPolicy
expr_stmt|;
block|}
return|return
name|policy
operator|.
name|shouldRetry
argument_list|(
name|e
argument_list|,
name|retries
argument_list|,
name|failovers
argument_list|,
name|isMethodIdempotent
argument_list|)
return|;
block|}
block|}
DECL|class|ExponentialBackoffRetry
specifier|static
class|class
name|ExponentialBackoffRetry
extends|extends
name|RetryLimited
block|{
DECL|method|ExponentialBackoffRetry ( int maxRetries, long sleepTime, TimeUnit timeUnit)
specifier|public
name|ExponentialBackoffRetry
parameter_list|(
name|int
name|maxRetries
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
name|super
argument_list|(
name|maxRetries
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|calculateSleepTime (int retries)
specifier|protected
name|long
name|calculateSleepTime
parameter_list|(
name|int
name|retries
parameter_list|)
block|{
return|return
name|calculateExponentialTime
argument_list|(
name|sleepTime
argument_list|,
name|retries
operator|+
literal|1
argument_list|)
return|;
block|}
block|}
comment|/**    * Fail over and retry in the case of:    *   Remote StandbyException (server is up, but is not the active server)    *   Immediate socket exceptions (e.g. no route to host, econnrefused)    *   Socket exceptions after initial connection when operation is idempotent    *     * The first failover is immediate, while all subsequent failovers wait an    * exponentially-increasing random amount of time.    *     * Fail immediately in the case of:    *   Socket exceptions after initial connection when operation is not idempotent    *     * Fall back on underlying retry policy otherwise.    */
DECL|class|FailoverOnNetworkExceptionRetry
specifier|static
class|class
name|FailoverOnNetworkExceptionRetry
implements|implements
name|RetryPolicy
block|{
DECL|field|fallbackPolicy
specifier|private
name|RetryPolicy
name|fallbackPolicy
decl_stmt|;
DECL|field|maxFailovers
specifier|private
name|int
name|maxFailovers
decl_stmt|;
DECL|field|delayMillis
specifier|private
name|long
name|delayMillis
decl_stmt|;
DECL|field|maxDelayBase
specifier|private
name|long
name|maxDelayBase
decl_stmt|;
DECL|method|FailoverOnNetworkExceptionRetry (RetryPolicy fallbackPolicy, int maxFailovers)
specifier|public
name|FailoverOnNetworkExceptionRetry
parameter_list|(
name|RetryPolicy
name|fallbackPolicy
parameter_list|,
name|int
name|maxFailovers
parameter_list|)
block|{
name|this
argument_list|(
name|fallbackPolicy
argument_list|,
name|maxFailovers
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|FailoverOnNetworkExceptionRetry (RetryPolicy fallbackPolicy, int maxFailovers, long delayMillis, long maxDelayBase)
specifier|public
name|FailoverOnNetworkExceptionRetry
parameter_list|(
name|RetryPolicy
name|fallbackPolicy
parameter_list|,
name|int
name|maxFailovers
parameter_list|,
name|long
name|delayMillis
parameter_list|,
name|long
name|maxDelayBase
parameter_list|)
block|{
name|this
operator|.
name|fallbackPolicy
operator|=
name|fallbackPolicy
expr_stmt|;
name|this
operator|.
name|maxFailovers
operator|=
name|maxFailovers
expr_stmt|;
name|this
operator|.
name|delayMillis
operator|=
name|delayMillis
expr_stmt|;
name|this
operator|.
name|maxDelayBase
operator|=
name|maxDelayBase
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|shouldRetry (Exception e, int retries, int failovers, boolean isMethodIdempotent)
specifier|public
name|RetryAction
name|shouldRetry
parameter_list|(
name|Exception
name|e
parameter_list|,
name|int
name|retries
parameter_list|,
name|int
name|failovers
parameter_list|,
name|boolean
name|isMethodIdempotent
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|failovers
operator|>=
name|maxFailovers
condition|)
block|{
name|LOG
operator|.
name|info
argument_list|(
literal|"Failovers ("
operator|+
name|failovers
operator|+
literal|") exceeded maximum allowed ("
operator|+
name|maxFailovers
operator|+
literal|")"
argument_list|)
expr_stmt|;
return|return
name|RetryAction
operator|.
name|FAIL
return|;
block|}
if|if
condition|(
name|e
operator|instanceof
name|ConnectException
operator|||
name|e
operator|instanceof
name|NoRouteToHostException
operator|||
name|e
operator|instanceof
name|UnknownHostException
operator|||
name|e
operator|instanceof
name|StandbyException
operator|||
name|isWrappedStandbyException
argument_list|(
name|e
argument_list|)
condition|)
block|{
return|return
operator|new
name|RetryAction
argument_list|(
name|RetryAction
operator|.
name|RetryDecision
operator|.
name|FAILOVER_AND_RETRY
argument_list|,
comment|// retry immediately if this is our first failover, sleep otherwise
name|failovers
operator|==
literal|0
condition|?
literal|0
else|:
name|calculateExponentialTime
argument_list|(
name|delayMillis
argument_list|,
name|failovers
argument_list|,
name|maxDelayBase
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|SocketException
operator|||
operator|(
name|e
operator|instanceof
name|IOException
operator|&&
operator|!
operator|(
name|e
operator|instanceof
name|RemoteException
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|isMethodIdempotent
condition|)
block|{
return|return
name|RetryAction
operator|.
name|FAILOVER_AND_RETRY
return|;
block|}
else|else
block|{
return|return
name|RetryAction
operator|.
name|FAIL
return|;
block|}
block|}
else|else
block|{
return|return
name|fallbackPolicy
operator|.
name|shouldRetry
argument_list|(
name|e
argument_list|,
name|retries
argument_list|,
name|failovers
argument_list|,
name|isMethodIdempotent
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * Return a value which is<code>time</code> increasing exponentially as a    * function of<code>retries</code>, +/- 0%-50% of that value, chosen    * randomly.    *     * @param time the base amount of time to work with    * @param retries the number of retries that have so occurred so far    * @param cap value at which to cap the base sleep time    * @return an amount of time to sleep    */
annotation|@
name|VisibleForTesting
DECL|method|calculateExponentialTime (long time, int retries, long cap)
specifier|public
specifier|static
name|long
name|calculateExponentialTime
parameter_list|(
name|long
name|time
parameter_list|,
name|int
name|retries
parameter_list|,
name|long
name|cap
parameter_list|)
block|{
name|long
name|baseTime
init|=
name|Math
operator|.
name|min
argument_list|(
name|time
operator|*
operator|(
operator|(
name|long
operator|)
literal|1
operator|<<
name|retries
operator|)
argument_list|,
name|cap
argument_list|)
decl_stmt|;
return|return
call|(
name|long
call|)
argument_list|(
name|baseTime
operator|*
operator|(
name|RAND
operator|.
name|nextFloat
argument_list|()
operator|+
literal|0.5
operator|)
argument_list|)
return|;
block|}
DECL|method|calculateExponentialTime (long time, int retries)
specifier|private
specifier|static
name|long
name|calculateExponentialTime
parameter_list|(
name|long
name|time
parameter_list|,
name|int
name|retries
parameter_list|)
block|{
return|return
name|calculateExponentialTime
argument_list|(
name|time
argument_list|,
name|retries
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
return|;
block|}
DECL|method|isWrappedStandbyException (Exception e)
specifier|private
specifier|static
name|boolean
name|isWrappedStandbyException
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|e
operator|instanceof
name|RemoteException
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Exception
name|unwrapped
init|=
operator|(
operator|(
name|RemoteException
operator|)
name|e
operator|)
operator|.
name|unwrapRemoteException
argument_list|(
name|StandbyException
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|unwrapped
operator|instanceof
name|StandbyException
return|;
block|}
block|}
end_class

end_unit

