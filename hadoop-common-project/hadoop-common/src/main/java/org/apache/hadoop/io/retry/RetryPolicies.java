begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership.  The ASF licenses this file  * to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.apache.hadoop.io.retry
package|package
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|io
operator|.
name|retry
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|ConnectException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|NoRouteToHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|SocketException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|Log
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|logging
operator|.
name|LogFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|RemoteException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|hadoop
operator|.
name|ipc
operator|.
name|StandbyException
import|;
end_import

begin_comment
comment|/**  *<p>  * A collection of useful implementations of {@link RetryPolicy}.  *</p>  */
end_comment

begin_class
DECL|class|RetryPolicies
specifier|public
class|class
name|RetryPolicies
block|{
DECL|field|LOG
specifier|public
specifier|static
specifier|final
name|Log
name|LOG
init|=
name|LogFactory
operator|.
name|getLog
argument_list|(
name|RetryPolicies
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|RANDOM
specifier|private
specifier|static
name|ThreadLocal
argument_list|<
name|Random
argument_list|>
name|RANDOM
init|=
operator|new
name|ThreadLocal
argument_list|<
name|Random
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|Random
name|initialValue
parameter_list|()
block|{
return|return
operator|new
name|Random
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|/**    *<p>    * Try once, and fail by re-throwing the exception.    * This corresponds to having no retry mechanism in place.    *</p>    */
DECL|field|TRY_ONCE_THEN_FAIL
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|TRY_ONCE_THEN_FAIL
init|=
operator|new
name|TryOnceThenFail
argument_list|()
decl_stmt|;
comment|/**    *<p>    * Keep trying forever.    *</p>    */
DECL|field|RETRY_FOREVER
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|RETRY_FOREVER
init|=
operator|new
name|RetryForever
argument_list|()
decl_stmt|;
comment|/**    *<p>    * Keep trying a limited number of times, waiting a fixed time between attempts,    * and then fail by re-throwing the exception.    *</p>    */
DECL|method|retryUpToMaximumCountWithFixedSleep (int maxRetries, long sleepTime, TimeUnit timeUnit)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|retryUpToMaximumCountWithFixedSleep
parameter_list|(
name|int
name|maxRetries
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
return|return
operator|new
name|RetryUpToMaximumCountWithFixedSleep
argument_list|(
name|maxRetries
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
return|;
block|}
comment|/**    *<p>    * Keep trying for a maximum time, waiting a fixed time between attempts,    * and then fail by re-throwing the exception.    *</p>    */
DECL|method|retryUpToMaximumTimeWithFixedSleep (long maxTime, long sleepTime, TimeUnit timeUnit)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|retryUpToMaximumTimeWithFixedSleep
parameter_list|(
name|long
name|maxTime
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
return|return
operator|new
name|RetryUpToMaximumTimeWithFixedSleep
argument_list|(
name|maxTime
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
return|;
block|}
comment|/**    *<p>    * Keep trying a limited number of times, waiting a growing amount of time between attempts,    * and then fail by re-throwing the exception.    * The time between attempts is<code>sleepTime</code> mutliplied by the number of tries so far.    *</p>    */
DECL|method|retryUpToMaximumCountWithProportionalSleep (int maxRetries, long sleepTime, TimeUnit timeUnit)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|retryUpToMaximumCountWithProportionalSleep
parameter_list|(
name|int
name|maxRetries
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
return|return
operator|new
name|RetryUpToMaximumCountWithProportionalSleep
argument_list|(
name|maxRetries
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
return|;
block|}
comment|/**    *<p>    * Keep trying a limited number of times, waiting a growing amount of time between attempts,    * and then fail by re-throwing the exception.    * The time between attempts is<code>sleepTime</code> mutliplied by a random    * number in the range of [0, 2 to the number of retries)    *</p>    */
DECL|method|exponentialBackoffRetry ( int maxRetries, long sleepTime, TimeUnit timeUnit)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|exponentialBackoffRetry
parameter_list|(
name|int
name|maxRetries
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
return|return
operator|new
name|ExponentialBackoffRetry
argument_list|(
name|maxRetries
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
return|;
block|}
comment|/**    *<p>    * Set a default policy with some explicit handlers for specific exceptions.    *</p>    */
DECL|method|retryByException (RetryPolicy defaultPolicy, Map<Class<? extends Exception>, RetryPolicy> exceptionToPolicyMap)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|retryByException
parameter_list|(
name|RetryPolicy
name|defaultPolicy
parameter_list|,
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
argument_list|,
name|RetryPolicy
argument_list|>
name|exceptionToPolicyMap
parameter_list|)
block|{
return|return
operator|new
name|ExceptionDependentRetry
argument_list|(
name|defaultPolicy
argument_list|,
name|exceptionToPolicyMap
argument_list|)
return|;
block|}
comment|/**    *<p>    * A retry policy for RemoteException    * Set a default policy with some explicit handlers for specific exceptions.    *</p>    */
DECL|method|retryByRemoteException ( RetryPolicy defaultPolicy, Map<Class<? extends Exception>, RetryPolicy> exceptionToPolicyMap)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|retryByRemoteException
parameter_list|(
name|RetryPolicy
name|defaultPolicy
parameter_list|,
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
argument_list|,
name|RetryPolicy
argument_list|>
name|exceptionToPolicyMap
parameter_list|)
block|{
return|return
operator|new
name|RemoteExceptionDependentRetry
argument_list|(
name|defaultPolicy
argument_list|,
name|exceptionToPolicyMap
argument_list|)
return|;
block|}
DECL|method|failoverOnNetworkException (int maxFailovers)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|failoverOnNetworkException
parameter_list|(
name|int
name|maxFailovers
parameter_list|)
block|{
return|return
name|failoverOnNetworkException
argument_list|(
name|TRY_ONCE_THEN_FAIL
argument_list|,
name|maxFailovers
argument_list|)
return|;
block|}
DECL|method|failoverOnNetworkException ( RetryPolicy fallbackPolicy, int maxFailovers)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|failoverOnNetworkException
parameter_list|(
name|RetryPolicy
name|fallbackPolicy
parameter_list|,
name|int
name|maxFailovers
parameter_list|)
block|{
return|return
name|failoverOnNetworkException
argument_list|(
name|fallbackPolicy
argument_list|,
name|maxFailovers
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
DECL|method|failoverOnNetworkException ( RetryPolicy fallbackPolicy, int maxFailovers, long delayMillis, long maxDelayBase)
specifier|public
specifier|static
specifier|final
name|RetryPolicy
name|failoverOnNetworkException
parameter_list|(
name|RetryPolicy
name|fallbackPolicy
parameter_list|,
name|int
name|maxFailovers
parameter_list|,
name|long
name|delayMillis
parameter_list|,
name|long
name|maxDelayBase
parameter_list|)
block|{
return|return
operator|new
name|FailoverOnNetworkExceptionRetry
argument_list|(
name|fallbackPolicy
argument_list|,
name|maxFailovers
argument_list|,
name|delayMillis
argument_list|,
name|maxDelayBase
argument_list|)
return|;
block|}
DECL|class|TryOnceThenFail
specifier|static
class|class
name|TryOnceThenFail
implements|implements
name|RetryPolicy
block|{
annotation|@
name|Override
DECL|method|shouldRetry (Exception e, int retries, int failovers, boolean isMethodIdempotent)
specifier|public
name|RetryAction
name|shouldRetry
parameter_list|(
name|Exception
name|e
parameter_list|,
name|int
name|retries
parameter_list|,
name|int
name|failovers
parameter_list|,
name|boolean
name|isMethodIdempotent
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|RetryAction
operator|.
name|FAIL
return|;
block|}
block|}
DECL|class|RetryForever
specifier|static
class|class
name|RetryForever
implements|implements
name|RetryPolicy
block|{
annotation|@
name|Override
DECL|method|shouldRetry (Exception e, int retries, int failovers, boolean isMethodIdempotent)
specifier|public
name|RetryAction
name|shouldRetry
parameter_list|(
name|Exception
name|e
parameter_list|,
name|int
name|retries
parameter_list|,
name|int
name|failovers
parameter_list|,
name|boolean
name|isMethodIdempotent
parameter_list|)
throws|throws
name|Exception
block|{
return|return
name|RetryAction
operator|.
name|RETRY
return|;
block|}
block|}
comment|/**    * Retry up to maxRetries.    * The actual sleep time of the n-th retry is f(n, sleepTime),    * where f is a function provided by the subclass implementation.    *    * The object of the subclasses should be immutable;    * otherwise, the subclass must override hashCode(), equals(..) and toString().    */
DECL|class|RetryLimited
specifier|static
specifier|abstract
class|class
name|RetryLimited
implements|implements
name|RetryPolicy
block|{
DECL|field|maxRetries
specifier|final
name|int
name|maxRetries
decl_stmt|;
DECL|field|sleepTime
specifier|final
name|long
name|sleepTime
decl_stmt|;
DECL|field|timeUnit
specifier|final
name|TimeUnit
name|timeUnit
decl_stmt|;
DECL|field|myString
specifier|private
name|String
name|myString
decl_stmt|;
DECL|method|RetryLimited (int maxRetries, long sleepTime, TimeUnit timeUnit)
name|RetryLimited
parameter_list|(
name|int
name|maxRetries
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
if|if
condition|(
name|maxRetries
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxRetries = "
operator|+
name|maxRetries
operator|+
literal|"< 0"
argument_list|)
throw|;
block|}
if|if
condition|(
name|sleepTime
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"sleepTime = "
operator|+
name|sleepTime
operator|+
literal|"< 0"
argument_list|)
throw|;
block|}
name|this
operator|.
name|maxRetries
operator|=
name|maxRetries
expr_stmt|;
name|this
operator|.
name|sleepTime
operator|=
name|sleepTime
expr_stmt|;
name|this
operator|.
name|timeUnit
operator|=
name|timeUnit
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|shouldRetry (Exception e, int retries, int failovers, boolean isMethodIdempotent)
specifier|public
name|RetryAction
name|shouldRetry
parameter_list|(
name|Exception
name|e
parameter_list|,
name|int
name|retries
parameter_list|,
name|int
name|failovers
parameter_list|,
name|boolean
name|isMethodIdempotent
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|retries
operator|>=
name|maxRetries
condition|)
block|{
return|return
name|RetryAction
operator|.
name|FAIL
return|;
block|}
return|return
operator|new
name|RetryAction
argument_list|(
name|RetryAction
operator|.
name|RetryDecision
operator|.
name|RETRY
argument_list|,
name|timeUnit
operator|.
name|toMillis
argument_list|(
name|calculateSleepTime
argument_list|(
name|retries
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
DECL|method|calculateSleepTime (int retries)
specifier|protected
specifier|abstract
name|long
name|calculateSleepTime
parameter_list|(
name|int
name|retries
parameter_list|)
function_decl|;
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|toString
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|equals (final Object that)
specifier|public
name|boolean
name|equals
parameter_list|(
specifier|final
name|Object
name|that
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|that
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|that
operator|==
literal|null
operator|||
name|this
operator|.
name|getClass
argument_list|()
operator|!=
name|that
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|this
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|that
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|myString
operator|==
literal|null
condition|)
block|{
name|myString
operator|=
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|"(maxRetries="
operator|+
name|maxRetries
operator|+
literal|", sleepTime="
operator|+
name|sleepTime
operator|+
literal|" "
operator|+
name|timeUnit
operator|+
literal|")"
expr_stmt|;
block|}
return|return
name|myString
return|;
block|}
block|}
DECL|class|RetryUpToMaximumCountWithFixedSleep
specifier|static
class|class
name|RetryUpToMaximumCountWithFixedSleep
extends|extends
name|RetryLimited
block|{
DECL|method|RetryUpToMaximumCountWithFixedSleep (int maxRetries, long sleepTime, TimeUnit timeUnit)
specifier|public
name|RetryUpToMaximumCountWithFixedSleep
parameter_list|(
name|int
name|maxRetries
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
name|super
argument_list|(
name|maxRetries
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|calculateSleepTime (int retries)
specifier|protected
name|long
name|calculateSleepTime
parameter_list|(
name|int
name|retries
parameter_list|)
block|{
return|return
name|sleepTime
return|;
block|}
block|}
DECL|class|RetryUpToMaximumTimeWithFixedSleep
specifier|static
class|class
name|RetryUpToMaximumTimeWithFixedSleep
extends|extends
name|RetryUpToMaximumCountWithFixedSleep
block|{
DECL|method|RetryUpToMaximumTimeWithFixedSleep (long maxTime, long sleepTime, TimeUnit timeUnit)
specifier|public
name|RetryUpToMaximumTimeWithFixedSleep
parameter_list|(
name|long
name|maxTime
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
name|super
argument_list|(
call|(
name|int
call|)
argument_list|(
name|maxTime
operator|/
name|sleepTime
argument_list|)
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|RetryUpToMaximumCountWithProportionalSleep
specifier|static
class|class
name|RetryUpToMaximumCountWithProportionalSleep
extends|extends
name|RetryLimited
block|{
DECL|method|RetryUpToMaximumCountWithProportionalSleep (int maxRetries, long sleepTime, TimeUnit timeUnit)
specifier|public
name|RetryUpToMaximumCountWithProportionalSleep
parameter_list|(
name|int
name|maxRetries
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
name|super
argument_list|(
name|maxRetries
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|calculateSleepTime (int retries)
specifier|protected
name|long
name|calculateSleepTime
parameter_list|(
name|int
name|retries
parameter_list|)
block|{
return|return
name|sleepTime
operator|*
operator|(
name|retries
operator|+
literal|1
operator|)
return|;
block|}
block|}
comment|/**    * Given pairs of number of retries and sleep time (n0, t0), (n1, t1), ...,    * the first n0 retries sleep t0 milliseconds on average,    * the following n1 retries sleep t1 milliseconds on average, and so on.    *     * For all the sleep, the actual sleep time is randomly uniform distributed    * in the close interval [0.5t, 1.5t], where t is the sleep time specified.    *    * The objects of this class are immutable.    */
DECL|class|MultipleLinearRandomRetry
specifier|public
specifier|static
class|class
name|MultipleLinearRandomRetry
implements|implements
name|RetryPolicy
block|{
comment|/** Pairs of numRetries and sleepSeconds */
DECL|class|Pair
specifier|public
specifier|static
class|class
name|Pair
block|{
DECL|field|numRetries
specifier|final
name|int
name|numRetries
decl_stmt|;
DECL|field|sleepMillis
specifier|final
name|int
name|sleepMillis
decl_stmt|;
DECL|method|Pair (final int numRetries, final int sleepMillis)
specifier|public
name|Pair
parameter_list|(
specifier|final
name|int
name|numRetries
parameter_list|,
specifier|final
name|int
name|sleepMillis
parameter_list|)
block|{
if|if
condition|(
name|numRetries
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"numRetries = "
operator|+
name|numRetries
operator|+
literal|"< 0"
argument_list|)
throw|;
block|}
if|if
condition|(
name|sleepMillis
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"sleepMillis = "
operator|+
name|sleepMillis
operator|+
literal|"< 0"
argument_list|)
throw|;
block|}
name|this
operator|.
name|numRetries
operator|=
name|numRetries
expr_stmt|;
name|this
operator|.
name|sleepMillis
operator|=
name|sleepMillis
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|numRetries
operator|+
literal|"x"
operator|+
name|sleepMillis
operator|+
literal|"ms"
return|;
block|}
block|}
DECL|field|pairs
specifier|private
specifier|final
name|List
argument_list|<
name|Pair
argument_list|>
name|pairs
decl_stmt|;
DECL|field|myString
specifier|private
name|String
name|myString
decl_stmt|;
DECL|method|MultipleLinearRandomRetry (List<Pair> pairs)
specifier|public
name|MultipleLinearRandomRetry
parameter_list|(
name|List
argument_list|<
name|Pair
argument_list|>
name|pairs
parameter_list|)
block|{
if|if
condition|(
name|pairs
operator|==
literal|null
operator|||
name|pairs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"pairs must be neither null nor empty."
argument_list|)
throw|;
block|}
name|this
operator|.
name|pairs
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|pairs
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|shouldRetry (Exception e, int curRetry, int failovers, boolean isMethodIdempotent)
specifier|public
name|RetryAction
name|shouldRetry
parameter_list|(
name|Exception
name|e
parameter_list|,
name|int
name|curRetry
parameter_list|,
name|int
name|failovers
parameter_list|,
name|boolean
name|isMethodIdempotent
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|Pair
name|p
init|=
name|searchPair
argument_list|(
name|curRetry
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|null
condition|)
block|{
comment|//no more retries.
return|return
name|RetryAction
operator|.
name|FAIL
return|;
block|}
comment|//calculate sleep time and return.
specifier|final
name|double
name|ratio
init|=
name|RANDOM
operator|.
name|get
argument_list|()
operator|.
name|nextDouble
argument_list|()
operator|+
literal|0.5
decl_stmt|;
comment|//0.5<= ratio<=1.5
specifier|final
name|long
name|sleepTime
init|=
name|Math
operator|.
name|round
argument_list|(
name|p
operator|.
name|sleepMillis
operator|*
name|ratio
argument_list|)
decl_stmt|;
return|return
operator|new
name|RetryAction
argument_list|(
name|RetryAction
operator|.
name|RetryDecision
operator|.
name|RETRY
argument_list|,
name|sleepTime
argument_list|)
return|;
block|}
comment|/**      * Given the current number of retry, search the corresponding pair.      * @return the corresponding pair,      *   or null if the current number of retry> maximum number of retry.       */
DECL|method|searchPair (int curRetry)
specifier|private
name|Pair
name|searchPair
parameter_list|(
name|int
name|curRetry
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|i
argument_list|<
name|pairs
operator|.
name|size
operator|(
operator|)
operator|&&
name|curRetry
argument_list|>
name|pairs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|numRetries
condition|;
name|i
operator|++
control|)
block|{
name|curRetry
operator|-=
name|pairs
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|numRetries
expr_stmt|;
block|}
return|return
name|i
operator|==
name|pairs
operator|.
name|size
argument_list|()
condition|?
literal|null
else|:
name|pairs
operator|.
name|get
argument_list|(
name|i
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode ()
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|toString
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|equals (final Object that)
specifier|public
name|boolean
name|equals
parameter_list|(
specifier|final
name|Object
name|that
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|that
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|that
operator|==
literal|null
operator|||
name|this
operator|.
name|getClass
argument_list|()
operator|!=
name|that
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|this
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|that
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString ()
specifier|public
name|String
name|toString
parameter_list|()
block|{
if|if
condition|(
name|myString
operator|==
literal|null
condition|)
block|{
name|myString
operator|=
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
operator|+
name|pairs
expr_stmt|;
block|}
return|return
name|myString
return|;
block|}
comment|/**      * Parse the given string as a MultipleLinearRandomRetry object.      * The format of the string is "t_1, n_1, t_2, n_2, ...",      * where t_i and n_i are the i-th pair of sleep time and number of retires.      * Note that the white spaces in the string are ignored.      *      * @return the parsed object, or null if the parsing fails.      */
DECL|method|parseCommaSeparatedString (String s)
specifier|public
specifier|static
name|MultipleLinearRandomRetry
name|parseCommaSeparatedString
parameter_list|(
name|String
name|s
parameter_list|)
block|{
specifier|final
name|String
index|[]
name|elements
init|=
name|s
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
if|if
condition|(
name|elements
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Illegal value: there is no element in \""
operator|+
name|s
operator|+
literal|"\"."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|elements
operator|.
name|length
operator|%
literal|2
operator|!=
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Illegal value: the number of elements in \""
operator|+
name|s
operator|+
literal|"\" is "
operator|+
name|elements
operator|.
name|length
operator|+
literal|" but an even number of elements is expected."
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
specifier|final
name|List
argument_list|<
name|RetryPolicies
operator|.
name|MultipleLinearRandomRetry
operator|.
name|Pair
argument_list|>
name|pairs
init|=
operator|new
name|ArrayList
argument_list|<
name|RetryPolicies
operator|.
name|MultipleLinearRandomRetry
operator|.
name|Pair
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|elements
operator|.
name|length
condition|;
control|)
block|{
comment|//parse the i-th sleep-time
specifier|final
name|int
name|sleep
init|=
name|parsePositiveInt
argument_list|(
name|elements
argument_list|,
name|i
operator|++
argument_list|,
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|sleep
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|null
return|;
comment|//parse fails
block|}
comment|//parse the i-th number-of-retries
specifier|final
name|int
name|retries
init|=
name|parsePositiveInt
argument_list|(
name|elements
argument_list|,
name|i
operator|++
argument_list|,
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|retries
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|null
return|;
comment|//parse fails
block|}
name|pairs
operator|.
name|add
argument_list|(
operator|new
name|RetryPolicies
operator|.
name|MultipleLinearRandomRetry
operator|.
name|Pair
argument_list|(
name|retries
argument_list|,
name|sleep
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|RetryPolicies
operator|.
name|MultipleLinearRandomRetry
argument_list|(
name|pairs
argument_list|)
return|;
block|}
comment|/**      * Parse the i-th element as an integer.      * @return -1 if the parsing fails or the parsed value<= 0;      *   otherwise, return the parsed value.      */
DECL|method|parsePositiveInt (final String[] elements, final int i, final String originalString)
specifier|private
specifier|static
name|int
name|parsePositiveInt
parameter_list|(
specifier|final
name|String
index|[]
name|elements
parameter_list|,
specifier|final
name|int
name|i
parameter_list|,
specifier|final
name|String
name|originalString
parameter_list|)
block|{
specifier|final
name|String
name|s
init|=
name|elements
index|[
name|i
index|]
operator|.
name|trim
argument_list|()
decl_stmt|;
specifier|final
name|int
name|n
decl_stmt|;
try|try
block|{
name|n
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"Failed to parse \""
operator|+
name|s
operator|+
literal|"\", which is the index "
operator|+
name|i
operator|+
literal|" element in \""
operator|+
name|originalString
operator|+
literal|"\""
argument_list|,
name|nfe
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
name|LOG
operator|.
name|warn
argument_list|(
literal|"The value "
operator|+
name|n
operator|+
literal|"<= 0: it is parsed from the string \""
operator|+
name|s
operator|+
literal|"\" which is the index "
operator|+
name|i
operator|+
literal|" element in \""
operator|+
name|originalString
operator|+
literal|"\""
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|n
return|;
block|}
block|}
DECL|class|ExceptionDependentRetry
specifier|static
class|class
name|ExceptionDependentRetry
implements|implements
name|RetryPolicy
block|{
DECL|field|defaultPolicy
name|RetryPolicy
name|defaultPolicy
decl_stmt|;
DECL|field|exceptionToPolicyMap
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
argument_list|,
name|RetryPolicy
argument_list|>
name|exceptionToPolicyMap
decl_stmt|;
DECL|method|ExceptionDependentRetry (RetryPolicy defaultPolicy, Map<Class<? extends Exception>, RetryPolicy> exceptionToPolicyMap)
specifier|public
name|ExceptionDependentRetry
parameter_list|(
name|RetryPolicy
name|defaultPolicy
parameter_list|,
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
argument_list|,
name|RetryPolicy
argument_list|>
name|exceptionToPolicyMap
parameter_list|)
block|{
name|this
operator|.
name|defaultPolicy
operator|=
name|defaultPolicy
expr_stmt|;
name|this
operator|.
name|exceptionToPolicyMap
operator|=
name|exceptionToPolicyMap
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|shouldRetry (Exception e, int retries, int failovers, boolean isMethodIdempotent)
specifier|public
name|RetryAction
name|shouldRetry
parameter_list|(
name|Exception
name|e
parameter_list|,
name|int
name|retries
parameter_list|,
name|int
name|failovers
parameter_list|,
name|boolean
name|isMethodIdempotent
parameter_list|)
throws|throws
name|Exception
block|{
name|RetryPolicy
name|policy
init|=
name|exceptionToPolicyMap
operator|.
name|get
argument_list|(
name|e
operator|.
name|getClass
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|policy
operator|==
literal|null
condition|)
block|{
name|policy
operator|=
name|defaultPolicy
expr_stmt|;
block|}
return|return
name|policy
operator|.
name|shouldRetry
argument_list|(
name|e
argument_list|,
name|retries
argument_list|,
name|failovers
argument_list|,
name|isMethodIdempotent
argument_list|)
return|;
block|}
block|}
DECL|class|RemoteExceptionDependentRetry
specifier|static
class|class
name|RemoteExceptionDependentRetry
implements|implements
name|RetryPolicy
block|{
DECL|field|defaultPolicy
name|RetryPolicy
name|defaultPolicy
decl_stmt|;
DECL|field|exceptionNameToPolicyMap
name|Map
argument_list|<
name|String
argument_list|,
name|RetryPolicy
argument_list|>
name|exceptionNameToPolicyMap
decl_stmt|;
DECL|method|RemoteExceptionDependentRetry (RetryPolicy defaultPolicy, Map<Class<? extends Exception>, RetryPolicy> exceptionToPolicyMap)
specifier|public
name|RemoteExceptionDependentRetry
parameter_list|(
name|RetryPolicy
name|defaultPolicy
parameter_list|,
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
argument_list|,
name|RetryPolicy
argument_list|>
name|exceptionToPolicyMap
parameter_list|)
block|{
name|this
operator|.
name|defaultPolicy
operator|=
name|defaultPolicy
expr_stmt|;
name|this
operator|.
name|exceptionNameToPolicyMap
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|RetryPolicy
argument_list|>
argument_list|()
expr_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Exception
argument_list|>
argument_list|,
name|RetryPolicy
argument_list|>
name|e
range|:
name|exceptionToPolicyMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|exceptionNameToPolicyMap
operator|.
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|shouldRetry (Exception e, int retries, int failovers, boolean isMethodIdempotent)
specifier|public
name|RetryAction
name|shouldRetry
parameter_list|(
name|Exception
name|e
parameter_list|,
name|int
name|retries
parameter_list|,
name|int
name|failovers
parameter_list|,
name|boolean
name|isMethodIdempotent
parameter_list|)
throws|throws
name|Exception
block|{
name|RetryPolicy
name|policy
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|RemoteException
condition|)
block|{
name|policy
operator|=
name|exceptionNameToPolicyMap
operator|.
name|get
argument_list|(
operator|(
operator|(
name|RemoteException
operator|)
name|e
operator|)
operator|.
name|getClassName
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|policy
operator|==
literal|null
condition|)
block|{
name|policy
operator|=
name|defaultPolicy
expr_stmt|;
block|}
return|return
name|policy
operator|.
name|shouldRetry
argument_list|(
name|e
argument_list|,
name|retries
argument_list|,
name|failovers
argument_list|,
name|isMethodIdempotent
argument_list|)
return|;
block|}
block|}
DECL|class|ExponentialBackoffRetry
specifier|static
class|class
name|ExponentialBackoffRetry
extends|extends
name|RetryLimited
block|{
DECL|method|ExponentialBackoffRetry ( int maxRetries, long sleepTime, TimeUnit timeUnit)
specifier|public
name|ExponentialBackoffRetry
parameter_list|(
name|int
name|maxRetries
parameter_list|,
name|long
name|sleepTime
parameter_list|,
name|TimeUnit
name|timeUnit
parameter_list|)
block|{
name|super
argument_list|(
name|maxRetries
argument_list|,
name|sleepTime
argument_list|,
name|timeUnit
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxRetries
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxRetries = "
operator|+
name|maxRetries
operator|+
literal|"< 0"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|maxRetries
operator|>=
name|Long
operator|.
name|SIZE
operator|-
literal|1
condition|)
block|{
comment|//calculateSleepTime may overflow.
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maxRetries = "
operator|+
name|maxRetries
operator|+
literal|">= "
operator|+
operator|(
name|Long
operator|.
name|SIZE
operator|-
literal|1
operator|)
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|calculateSleepTime (int retries)
specifier|protected
name|long
name|calculateSleepTime
parameter_list|(
name|int
name|retries
parameter_list|)
block|{
return|return
name|calculateExponentialTime
argument_list|(
name|sleepTime
argument_list|,
name|retries
operator|+
literal|1
argument_list|)
return|;
block|}
block|}
comment|/**    * Fail over and retry in the case of:    *   Remote StandbyException (server is up, but is not the active server)    *   Immediate socket exceptions (e.g. no route to host, econnrefused)    *   Socket exceptions after initial connection when operation is idempotent    *     * The first failover is immediate, while all subsequent failovers wait an    * exponentially-increasing random amount of time.    *     * Fail immediately in the case of:    *   Socket exceptions after initial connection when operation is not idempotent    *     * Fall back on underlying retry policy otherwise.    */
DECL|class|FailoverOnNetworkExceptionRetry
specifier|static
class|class
name|FailoverOnNetworkExceptionRetry
implements|implements
name|RetryPolicy
block|{
DECL|field|fallbackPolicy
specifier|private
name|RetryPolicy
name|fallbackPolicy
decl_stmt|;
DECL|field|maxFailovers
specifier|private
name|int
name|maxFailovers
decl_stmt|;
DECL|field|delayMillis
specifier|private
name|long
name|delayMillis
decl_stmt|;
DECL|field|maxDelayBase
specifier|private
name|long
name|maxDelayBase
decl_stmt|;
DECL|method|FailoverOnNetworkExceptionRetry (RetryPolicy fallbackPolicy, int maxFailovers)
specifier|public
name|FailoverOnNetworkExceptionRetry
parameter_list|(
name|RetryPolicy
name|fallbackPolicy
parameter_list|,
name|int
name|maxFailovers
parameter_list|)
block|{
name|this
argument_list|(
name|fallbackPolicy
argument_list|,
name|maxFailovers
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|FailoverOnNetworkExceptionRetry (RetryPolicy fallbackPolicy, int maxFailovers, long delayMillis, long maxDelayBase)
specifier|public
name|FailoverOnNetworkExceptionRetry
parameter_list|(
name|RetryPolicy
name|fallbackPolicy
parameter_list|,
name|int
name|maxFailovers
parameter_list|,
name|long
name|delayMillis
parameter_list|,
name|long
name|maxDelayBase
parameter_list|)
block|{
name|this
operator|.
name|fallbackPolicy
operator|=
name|fallbackPolicy
expr_stmt|;
name|this
operator|.
name|maxFailovers
operator|=
name|maxFailovers
expr_stmt|;
name|this
operator|.
name|delayMillis
operator|=
name|delayMillis
expr_stmt|;
name|this
operator|.
name|maxDelayBase
operator|=
name|maxDelayBase
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|shouldRetry (Exception e, int retries, int failovers, boolean isMethodIdempotent)
specifier|public
name|RetryAction
name|shouldRetry
parameter_list|(
name|Exception
name|e
parameter_list|,
name|int
name|retries
parameter_list|,
name|int
name|failovers
parameter_list|,
name|boolean
name|isMethodIdempotent
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|failovers
operator|>=
name|maxFailovers
condition|)
block|{
return|return
operator|new
name|RetryAction
argument_list|(
name|RetryAction
operator|.
name|RetryDecision
operator|.
name|FAIL
argument_list|,
literal|0
argument_list|,
literal|"failovers ("
operator|+
name|failovers
operator|+
literal|") exceeded maximum allowed ("
operator|+
name|maxFailovers
operator|+
literal|")"
argument_list|)
return|;
block|}
if|if
condition|(
name|e
operator|instanceof
name|ConnectException
operator|||
name|e
operator|instanceof
name|NoRouteToHostException
operator|||
name|e
operator|instanceof
name|UnknownHostException
operator|||
name|e
operator|instanceof
name|StandbyException
operator|||
name|isWrappedStandbyException
argument_list|(
name|e
argument_list|)
condition|)
block|{
return|return
operator|new
name|RetryAction
argument_list|(
name|RetryAction
operator|.
name|RetryDecision
operator|.
name|FAILOVER_AND_RETRY
argument_list|,
comment|// retry immediately if this is our first failover, sleep otherwise
name|failovers
operator|==
literal|0
condition|?
literal|0
else|:
name|calculateExponentialTime
argument_list|(
name|delayMillis
argument_list|,
name|failovers
argument_list|,
name|maxDelayBase
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|SocketException
operator|||
operator|(
name|e
operator|instanceof
name|IOException
operator|&&
operator|!
operator|(
name|e
operator|instanceof
name|RemoteException
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|isMethodIdempotent
condition|)
block|{
return|return
name|RetryAction
operator|.
name|FAILOVER_AND_RETRY
return|;
block|}
else|else
block|{
return|return
operator|new
name|RetryAction
argument_list|(
name|RetryAction
operator|.
name|RetryDecision
operator|.
name|FAIL
argument_list|,
literal|0
argument_list|,
literal|"the invoked method is not idempotent, and unable to determine "
operator|+
literal|"whether it was invoked"
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
name|fallbackPolicy
operator|.
name|shouldRetry
argument_list|(
name|e
argument_list|,
name|retries
argument_list|,
name|failovers
argument_list|,
name|isMethodIdempotent
argument_list|)
return|;
block|}
block|}
block|}
comment|/**    * Return a value which is<code>time</code> increasing exponentially as a    * function of<code>retries</code>, +/- 0%-50% of that value, chosen    * randomly.    *     * @param time the base amount of time to work with    * @param retries the number of retries that have so occurred so far    * @param cap value at which to cap the base sleep time    * @return an amount of time to sleep    */
DECL|method|calculateExponentialTime (long time, int retries, long cap)
specifier|private
specifier|static
name|long
name|calculateExponentialTime
parameter_list|(
name|long
name|time
parameter_list|,
name|int
name|retries
parameter_list|,
name|long
name|cap
parameter_list|)
block|{
name|long
name|baseTime
init|=
name|Math
operator|.
name|min
argument_list|(
name|time
operator|*
operator|(
literal|1L
operator|<<
name|retries
operator|)
argument_list|,
name|cap
argument_list|)
decl_stmt|;
return|return
call|(
name|long
call|)
argument_list|(
name|baseTime
operator|*
operator|(
name|RANDOM
operator|.
name|get
argument_list|()
operator|.
name|nextDouble
argument_list|()
operator|+
literal|0.5
operator|)
argument_list|)
return|;
block|}
DECL|method|calculateExponentialTime (long time, int retries)
specifier|private
specifier|static
name|long
name|calculateExponentialTime
parameter_list|(
name|long
name|time
parameter_list|,
name|int
name|retries
parameter_list|)
block|{
return|return
name|calculateExponentialTime
argument_list|(
name|time
argument_list|,
name|retries
argument_list|,
name|Long
operator|.
name|MAX_VALUE
argument_list|)
return|;
block|}
DECL|method|isWrappedStandbyException (Exception e)
specifier|private
specifier|static
name|boolean
name|isWrappedStandbyException
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|e
operator|instanceof
name|RemoteException
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Exception
name|unwrapped
init|=
operator|(
operator|(
name|RemoteException
operator|)
name|e
operator|)
operator|.
name|unwrapRemoteException
argument_list|(
name|StandbyException
operator|.
name|class
argument_list|)
decl_stmt|;
return|return
name|unwrapped
operator|instanceof
name|StandbyException
return|;
block|}
block|}
end_class

end_unit

